<TracedFile path="src/lean/Init/Data/List/Zip.lean" md5="371e552d248e9536fd99aa9336e7f0d9">
  <FileNode start="(1, 1)" end="(458, 16)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 26)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 26)">
        <ModuleImportNode start="(9, 1)" end="(9, 31)" module="Init.Data.List.TakeDrop" path="src/lean/Init/Data/List/TakeDrop.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 31)" leading="" trailing="&#10;" raw_val="Init.Data.List.TakeDrop" val="Init.Data.List.TakeDrop"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 26)" module="Init.Data.Function" path="src/lean/Init/Data/Function.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 26)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Function" val="Init.Data.Function"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(12, 1)" end="(14, 3)" comment="# Lemmas about `List.zip`, `List.zipWith`, `List.zipWithAll`, and `List.unzip`.&#10;-/">
      <AtomNode start="(12, 1)" end="(12, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(13, 1)" end="(14, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `List.zip`, `List.zipWith`, `List.zipWithAll`, and `List.unzip`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(16, 1)" end="(16, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(16, 1)" end="(16, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(16, 12)" end="(16, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(16, 33)" end="(16, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(17, 1)" end="(17, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(17, 1)" end="(17, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(17, 12)" end="(17, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(17, 34)" end="(17, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(19, 1)" end="(19, 15)" name="List">
      <AtomNode start="(19, 1)" end="(19, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(19, 11)" end="(19, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(21, 1)" end="(21, 9)">
      <AtomNode start="(21, 1)" end="(21, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(21, 6)" end="(21, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(21, 6)" end="(21, 9)">
          <IdentNode start="(21, 6)" end="(21, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(23, 1)" end="(23, 18)" comment="## Zippers -/">
      <AtomNode start="(23, 1)" end="(23, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(23, 5)" end="(23, 18)" leading="" trailing="&#10;&#10;" val="## Zippers -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(25, 1)" end="(25, 19)" comment="### zipWith -/">
      <AtomNode start="(25, 1)" end="(25, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(25, 5)" end="(25, 19)" leading="" trailing="&#10;&#10;" val="### zipWith -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(27, 1)" end="(31, 46)" name="zipWith_comm" full_name="List.zipWith_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(27, 1)" end="(31, 46)" name="zipWith_comm" full_name="List.zipWith_comm" _is_private_decl="False">
        <AtomNode start="(27, 1)" end="(27, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(27, 9)" end="(27, 21)">
          <IdentNode start="(27, 9)" end="(27, 21)" leading="" trailing=" " raw_val="zipWith_comm" val="zipWith_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(27, 22)" end="(28, 86)">
          <NullNode start="(27, 22)" end="(27, 37)">
            <OtherNode start="(27, 22)" end="(27, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(27, 22)" end="(27, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(27, 23)" end="(27, 24)">
                <IdentNode start="(27, 23)" end="(27, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(27, 25)" end="(27, 36)">
                <AtomNode start="(27, 25)" end="(27, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 27)" end="(27, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(27, 27)" end="(27, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(27, 29)" end="(27, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(27, 31)" end="(27, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(27, 31)" end="(27, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(27, 33)" end="(27, 34)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(27, 35)" end="(27, 36)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(27, 36)" end="(27, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(27, 38)" end="(28, 86)">
            <AtomNode start="(27, 38)" end="(27, 39)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(28, 5)" end="(28, 86)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(28, 5)" end="(28, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(28, 7)" end="(28, 34)">
                <OtherNode start="(28, 7)" end="(28, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(28, 7)" end="(28, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(28, 8)" end="(28, 10)">
                    <IdentNode start="(28, 8)" end="(28, 10)" leading="" trailing=" " raw_val="as" val="as"/>
                  </NullNode>
                  <NullNode start="(28, 11)" end="(28, 19)">
                    <AtomNode start="(28, 11)" end="(28, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(28, 13)" end="(28, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(28, 13)" end="(28, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(28, 18)" end="(28, 19)">
                        <IdentNode start="(28, 18)" end="(28, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(28, 19)" end="(28, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(28, 21)" end="(28, 34)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(28, 21)" end="(28, 22)" leading="" trailing="" val="{"/>
                  <NullNode start="(28, 22)" end="(28, 24)">
                    <IdentNode start="(28, 22)" end="(28, 24)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  </NullNode>
                  <NullNode start="(28, 25)" end="(28, 33)">
                    <AtomNode start="(28, 25)" end="(28, 26)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(28, 27)" end="(28, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(28, 27)" end="(28, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(28, 32)" end="(28, 33)">
                        <IdentNode start="(28, 32)" end="(28, 33)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(28, 33)" end="(28, 34)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(28, 34)" end="(28, 35)" leading="" trailing=" " val=","/>
              <OtherNode start="(28, 36)" end="(28, 86)" kind="«term_=_»">
                <OtherNode start="(28, 36)" end="(28, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(28, 36)" end="(28, 43)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(28, 44)" end="(28, 51)">
                    <IdentNode start="(28, 44)" end="(28, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(28, 46)" end="(28, 48)" leading="" trailing=" " raw_val="as" val="as"/>
                    <IdentNode start="(28, 49)" end="(28, 51)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(28, 52)" end="(28, 53)" leading="" trailing=" " val="="/>
                <OtherNode start="(28, 54)" end="(28, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(28, 54)" end="(28, 61)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(28, 62)" end="(28, 86)">
                    <OtherNode start="(28, 62)" end="(28, 80)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(28, 62)" end="(28, 63)" leading="" trailing="" val="("/>
                      <OtherNode start="(28, 63)" end="(28, 79)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(28, 63)" end="(28, 66)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(28, 67)" end="(28, 79)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(28, 67)" end="(28, 70)">
                            <IdentNode start="(28, 67)" end="(28, 68)" leading="" trailing=" " raw_val="b" val="b"/>
                            <IdentNode start="(28, 69)" end="(28, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(28, 71)" end="(28, 73)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(28, 74)" end="(28, 79)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(28, 74)" end="(28, 75)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(28, 76)" end="(28, 79)">
                              <IdentNode start="(28, 76)" end="(28, 77)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(28, 78)" end="(28, 79)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(28, 79)" end="(28, 80)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(28, 81)" end="(28, 83)" leading="" trailing=" " raw_val="bs" val="bs"/>
                    <IdentNode start="(28, 84)" end="(28, 86)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(29, 3)" end="(31, 46)">
          <OtherNode start="(29, 3)" end="(31, 46)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(29, 3)" end="(31, 46)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(29, 3)" end="(31, 46)">
                <OtherNode start="(29, 3)" end="(29, 41)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(29, 3)" end="(29, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(29, 5)" end="(29, 10)">
                    <NullNode start="(29, 5)" end="(29, 10)">
                      <OtherNode start="(29, 5)" end="(29, 7)" kind="«term[_]»">
                        <AtomNode start="(29, 5)" end="(29, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(29, 6)" end="(29, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(29, 7)" end="(29, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(29, 9)" end="(29, 10)">
                        <AtomNode start="(29, 9)" end="(29, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(29, 11)" end="(29, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(29, 14)" end="(29, 41)" leading="" trailing="&#10;  " raw_val="List.zipWith_nil_right.symm" val="List.zipWith_nil_right.symm"/>
                </OtherNode>
                <OtherNode start="(30, 3)" end="(30, 22)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(30, 3)" end="(30, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(30, 5)" end="(30, 15)">
                    <NullNode start="(30, 5)" end="(30, 15)">
                      <OtherNode start="(30, 5)" end="(30, 11)" kind="«term_::_»">
                        <TermHoleNode start="(30, 5)" end="(30, 6)">
                          <AtomNode start="(30, 5)" end="(30, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(30, 7)" end="(30, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(30, 10)" end="(30, 11)">
                          <AtomNode start="(30, 10)" end="(30, 11)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(30, 11)" end="(30, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(30, 13)" end="(30, 15)" kind="«term[_]»">
                        <AtomNode start="(30, 13)" end="(30, 14)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(30, 14)" end="(30, 15)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(30, 16)" end="(30, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(30, 19)" end="(30, 22)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(31, 3)" end="(31, 46)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(31, 3)" end="(31, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(31, 5)" end="(31, 19)">
                    <NullNode start="(31, 5)" end="(31, 19)">
                      <OtherNode start="(31, 5)" end="(31, 11)" kind="«term_::_»">
                        <TermHoleNode start="(31, 5)" end="(31, 6)">
                          <AtomNode start="(31, 5)" end="(31, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(31, 7)" end="(31, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(31, 10)" end="(31, 11)">
                          <AtomNode start="(31, 10)" end="(31, 11)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(31, 11)" end="(31, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(31, 13)" end="(31, 19)" kind="«term_::_»">
                        <TermHoleNode start="(31, 13)" end="(31, 14)">
                          <AtomNode start="(31, 13)" end="(31, 14)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(31, 15)" end="(31, 17)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(31, 18)" end="(31, 19)">
                          <AtomNode start="(31, 18)" end="(31, 19)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(31, 20)" end="(31, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(31, 23)" end="(31, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(31, 23)" end="(31, 31)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(31, 32)" end="(31, 46)">
                      <TermHoleNode start="(31, 32)" end="(31, 33)">
                        <AtomNode start="(31, 32)" end="(31, 33)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <IdentNode start="(31, 34)" end="(31, 46)" leading="" trailing="&#10;&#10;" raw_val="zipWith_comm" val="zipWith_comm"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(36, 19)" name="zipWith_comm_of_comm" full_name="List.zipWith_comm_of_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(33, 1)" end="(36, 19)" name="zipWith_comm_of_comm" full_name="List.zipWith_comm_of_comm" _is_private_decl="False">
        <AtomNode start="(33, 1)" end="(33, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(33, 9)" end="(33, 29)">
          <IdentNode start="(33, 9)" end="(33, 29)" leading="" trailing=" " raw_val="zipWith_comm_of_comm" val="zipWith_comm_of_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(33, 30)" end="(34, 36)">
          <NullNode start="(33, 30)" end="(33, 95)">
            <OtherNode start="(33, 30)" end="(33, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(33, 30)" end="(33, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(33, 31)" end="(33, 32)">
                <IdentNode start="(33, 31)" end="(33, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(33, 33)" end="(33, 44)">
                <AtomNode start="(33, 33)" end="(33, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 35)" end="(33, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(33, 35)" end="(33, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(33, 37)" end="(33, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(33, 39)" end="(33, 44)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(33, 39)" end="(33, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(33, 41)" end="(33, 42)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(33, 43)" end="(33, 44)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(33, 44)" end="(33, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(33, 46)" end="(33, 79)">
              <AtomNode start="(33, 46)" end="(33, 47)" leading="" trailing="" val="("/>
              <NullNode start="(33, 47)" end="(33, 51)">
                <IdentNode start="(33, 47)" end="(33, 51)" leading="" trailing=" " raw_val="comm" val="comm"/>
              </NullNode>
              <NullNode start="(33, 52)" end="(33, 78)">
                <AtomNode start="(33, 52)" end="(33, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 54)" end="(33, 78)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(33, 54)" end="(33, 55)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(33, 56)" end="(33, 59)">
                    <IdentNode start="(33, 56)" end="(33, 57)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(33, 58)" end="(33, 59)" leading="" trailing=" " raw_val="y" val="y"/>
                  </NullNode>
                  <NullNode start="(33, 60)" end="(33, 63)">
                    <TermTypespecNode start="(33, 60)" end="(33, 63)">
                      <AtomNode start="(33, 60)" end="(33, 61)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(33, 62)" end="(33, 63)" leading="" trailing="" raw_val="α" val="α"/>
                    </TermTypespecNode>
                  </NullNode>
                  <AtomNode start="(33, 63)" end="(33, 64)" leading="" trailing=" " val=","/>
                  <OtherNode start="(33, 65)" end="(33, 78)" kind="«term_=_»">
                    <OtherNode start="(33, 65)" end="(33, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(33, 65)" end="(33, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(33, 67)" end="(33, 70)">
                        <IdentNode start="(33, 67)" end="(33, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(33, 69)" end="(33, 70)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(33, 71)" end="(33, 72)" leading="" trailing=" " val="="/>
                    <OtherNode start="(33, 73)" end="(33, 78)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(33, 73)" end="(33, 74)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(33, 75)" end="(33, 78)">
                        <IdentNode start="(33, 75)" end="(33, 76)" leading="" trailing=" " raw_val="y" val="y"/>
                        <IdentNode start="(33, 77)" end="(33, 78)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(33, 78)" end="(33, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(33, 80)" end="(33, 95)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(33, 80)" end="(33, 81)" leading="" trailing="" val="{"/>
              <NullNode start="(33, 81)" end="(33, 85)">
                <IdentNode start="(33, 81)" end="(33, 82)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(33, 83)" end="(33, 85)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(33, 86)" end="(33, 94)">
                <AtomNode start="(33, 86)" end="(33, 87)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 88)" end="(33, 94)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(33, 88)" end="(33, 92)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(33, 93)" end="(33, 94)">
                    <IdentNode start="(33, 93)" end="(33, 94)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(33, 94)" end="(33, 95)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(33, 96)" end="(34, 36)">
            <AtomNode start="(33, 96)" end="(33, 97)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(34, 5)" end="(34, 36)" kind="«term_=_»">
              <OtherNode start="(34, 5)" end="(34, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 5)" end="(34, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(34, 13)" end="(34, 19)">
                  <IdentNode start="(34, 13)" end="(34, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(34, 15)" end="(34, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(34, 17)" end="(34, 19)" leading="" trailing=" " raw_val="l'" val="l'"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 20)" end="(34, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(34, 22)" end="(34, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 22)" end="(34, 29)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(34, 30)" end="(34, 36)">
                  <IdentNode start="(34, 30)" end="(34, 31)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(34, 32)" end="(34, 34)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  <IdentNode start="(34, 35)" end="(34, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 37)" end="(36, 19)">
          <AtomNode start="(34, 37)" end="(34, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(34, 40)" end="(36, 19)">
            <AtomNode start="(34, 40)" end="(34, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(35, 3)" end="(36, 19)">
              <TacticTacticseq1IndentedNode start="(35, 3)" end="(36, 19)">
                <NullNode start="(35, 3)" end="(36, 19)">
                  <OtherNode start="(35, 3)" end="(35, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → α → β&#10;comm : ∀ (x y : α), f x y = f y x&#10;l l' : List α&#10;⊢ zipWith f l l' = zipWith f l' l" state_after="α : Type u_1&#10;β : Type u_2&#10;f : α → α → β&#10;comm : ∀ (x y : α), f x y = f y x&#10;l l' : List α&#10;⊢ zipWith (fun b a =&amp;gt; f a b) l' l = zipWith f l' l" tactic="rw [zipWith_comm]">
                    <AtomNode start="(35, 3)" end="(35, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(35, 6)" end="(35, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(35, 6)" end="(35, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(35, 7)" end="(35, 19)">
                        <OtherNode start="(35, 7)" end="(35, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(35, 7)" end="(35, 19)" leading="" trailing="" raw_val="zipWith_comm" val="zipWith_comm" full_name="List.zipWith_comm" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(27, 9)" def_end="(27, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(35, 19)" end="(35, 20)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(36, 3)" end="(36, 19)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → α → β&#10;comm : ∀ (x y : α), f x y = f y x&#10;l l' : List α&#10;⊢ zipWith (fun b a =&amp;gt; f a b) l' l = zipWith f l' l" state_after="no goals" tactic="simp only [comm]">
                    <AtomNode start="(36, 3)" end="(36, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(36, 8)" end="(36, 12)">
                      <AtomNode start="(36, 8)" end="(36, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(36, 13)" end="(36, 19)">
                      <AtomNode start="(36, 13)" end="(36, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(36, 14)" end="(36, 18)">
                        <OtherNode start="(36, 14)" end="(36, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(36, 14)" end="(36, 18)" leading="" trailing="" raw_val="comm" val="comm"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(36, 18)" end="(36, 19)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(38, 1)" end="(41, 38)" name="zipWith_self" full_name="List.zipWith_self">
      <CommandDeclmodifiersNode start="(38, 1)" end="(38, 8)">
        <NullNode/>
        <NullNode start="(38, 1)" end="(38, 8)">
          <OtherNode start="(38, 1)" end="(38, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(38, 1)" end="(38, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(38, 3)" end="(38, 7)">
              <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(38, 3)" end="(38, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(38, 7)" end="(38, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(39, 1)" end="(41, 38)" name="zipWith_self" full_name="List.zipWith_self" _is_private_decl="False">
        <AtomNode start="(39, 1)" end="(39, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(39, 9)" end="(39, 21)">
          <IdentNode start="(39, 9)" end="(39, 21)" leading="" trailing=" " raw_val="zipWith_self" val="zipWith_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(39, 22)" end="(39, 92)">
          <NullNode start="(39, 22)" end="(39, 37)">
            <OtherNode start="(39, 22)" end="(39, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(39, 22)" end="(39, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(39, 23)" end="(39, 24)">
                <IdentNode start="(39, 23)" end="(39, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(39, 25)" end="(39, 36)">
                <AtomNode start="(39, 25)" end="(39, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 27)" end="(39, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(39, 27)" end="(39, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(39, 29)" end="(39, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(39, 31)" end="(39, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(39, 31)" end="(39, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(39, 33)" end="(39, 34)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(39, 35)" end="(39, 36)" leading="" trailing="" raw_val="δ" val="δ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(39, 36)" end="(39, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(39, 38)" end="(39, 92)">
            <AtomNode start="(39, 38)" end="(39, 39)" leading="" trailing=" " val=":"/>
            <OtherNode start="(39, 40)" end="(39, 92)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(39, 40)" end="(39, 41)" leading="" trailing=" " val="∀"/>
              <NullNode start="(39, 42)" end="(39, 54)">
                <OtherNode start="(39, 42)" end="(39, 54)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(39, 42)" end="(39, 43)" leading="" trailing="" val="{"/>
                  <NullNode start="(39, 43)" end="(39, 44)">
                    <IdentNode start="(39, 43)" end="(39, 44)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(39, 45)" end="(39, 53)">
                    <AtomNode start="(39, 45)" end="(39, 46)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(39, 47)" end="(39, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(39, 47)" end="(39, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(39, 52)" end="(39, 53)">
                        <IdentNode start="(39, 52)" end="(39, 53)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(39, 53)" end="(39, 54)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(39, 54)" end="(39, 55)" leading="" trailing=" " val=","/>
              <OtherNode start="(39, 56)" end="(39, 92)" kind="«term_=_»">
                <OtherNode start="(39, 56)" end="(39, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(39, 56)" end="(39, 63)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(39, 64)" end="(39, 69)">
                    <IdentNode start="(39, 64)" end="(39, 65)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(39, 66)" end="(39, 67)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(39, 68)" end="(39, 69)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(39, 70)" end="(39, 71)" leading="" trailing=" " val="="/>
                <OtherNode start="(39, 72)" end="(39, 92)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(39, 72)" end="(39, 77)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                  <NullNode start="(39, 78)" end="(39, 92)">
                    <OtherNode start="(39, 78)" end="(39, 92)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(39, 78)" end="(39, 81)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(39, 82)" end="(39, 92)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(39, 82)" end="(39, 83)">
                          <IdentNode start="(39, 82)" end="(39, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(39, 84)" end="(39, 86)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(39, 87)" end="(39, 92)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(39, 87)" end="(39, 88)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(39, 89)" end="(39, 92)">
                            <IdentNode start="(39, 89)" end="(39, 90)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(39, 91)" end="(39, 92)" leading="" trailing="&#10;  " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(40, 3)" end="(41, 38)">
          <OtherNode start="(40, 3)" end="(41, 38)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(40, 3)" end="(41, 38)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(40, 3)" end="(41, 38)">
                <OtherNode start="(40, 3)" end="(40, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(40, 3)" end="(40, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(40, 5)" end="(40, 7)">
                    <NullNode start="(40, 5)" end="(40, 7)">
                      <OtherNode start="(40, 5)" end="(40, 7)" kind="«term[_]»">
                        <AtomNode start="(40, 5)" end="(40, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(40, 6)" end="(40, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(40, 8)" end="(40, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(40, 11)" end="(40, 14)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(41, 3)" end="(41, 38)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(41, 3)" end="(41, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(41, 5)" end="(41, 11)">
                    <NullNode start="(41, 5)" end="(41, 11)">
                      <OtherNode start="(41, 5)" end="(41, 11)" kind="«term_::_»">
                        <TermHoleNode start="(41, 5)" end="(41, 6)">
                          <AtomNode start="(41, 5)" end="(41, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(41, 7)" end="(41, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(41, 10)" end="(41, 11)">
                          <AtomNode start="(41, 10)" end="(41, 11)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(41, 12)" end="(41, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(41, 15)" end="(41, 38)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(41, 15)" end="(41, 23)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(41, 24)" end="(41, 38)">
                      <TermHoleNode start="(41, 24)" end="(41, 25)">
                        <AtomNode start="(41, 24)" end="(41, 25)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <IdentNode start="(41, 26)" end="(41, 38)" leading="" trailing="&#10;&#10;" raw_val="zipWith_self" val="zipWith_self"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(43, 1)" end="(43, 88)" name="zipWith_same" full_name="List.zipWith_same">
      <CommandDeclmodifiersNode start="(43, 1)" end="(43, 51)">
        <NullNode/>
        <NullNode start="(43, 1)" end="(43, 51)">
          <OtherNode start="(43, 1)" end="(43, 51)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(43, 1)" end="(43, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(43, 3)" end="(43, 50)">
              <OtherNode start="(43, 3)" end="(43, 50)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(43, 3)" end="(43, 50)" kind="Lean.deprecated">
                  <AtomNode start="(43, 3)" end="(43, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(43, 14)" end="(43, 26)">
                    <IdentNode start="(43, 14)" end="(43, 26)" leading="" trailing=" " raw_val="zipWith_self" val="zipWith_self" full_name="List.zipWith_self" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(39, 9)" def_end="(39, 21)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(43, 27)" end="(43, 50)">
                    <AtomNode start="(43, 27)" end="(43, 28)" leading="" trailing="" val="("/>
                    <AtomNode start="(43, 28)" end="(43, 33)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(43, 34)" end="(43, 36)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(43, 37)" end="(43, 49)" kind="str">
                      <AtomNode start="(43, 37)" end="(43, 49)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(43, 49)" end="(43, 50)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(43, 50)" end="(43, 51)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(43, 52)" end="(43, 88)" name="zipWith_same">
        <AtomNode start="(43, 52)" end="(43, 58)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(43, 59)" end="(43, 71)">
          <IdentNode start="(43, 59)" end="(43, 71)" leading="" trailing=" " raw_val="zipWith_same" val="zipWith_same"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(43, 72)" end="(43, 88)">
          <AtomNode start="(43, 72)" end="(43, 74)" leading="" trailing=" " val=":="/>
          <OtherNode start="(43, 75)" end="(43, 88)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(43, 75)" end="(43, 76)" leading="" trailing="" val="@"/>
            <IdentNode start="(43, 76)" end="(43, 88)" leading="" trailing="&#10;&#10;" raw_val="zipWith_self" val="zipWith_self" full_name="List.zipWith_self" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(39, 9)" def_end="(39, 21)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(45, 1)" end="(58, 40)" name="getElem?_zipWith" full_name="List.getElem?_zipWith">
      <CommandDeclmodifiersNode start="(45, 1)" end="(48, 3)">
        <NullNode start="(45, 1)" end="(48, 3)">
          <CommandDoccommentNode start="(45, 1)" end="(48, 3)" comment="See also `getElem?_zipWith'` for a variant&#10;using `Option.map` and `Option.bind` rather than a `match`.&#10;-/">
            <AtomNode start="(45, 1)" end="(45, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(46, 1)" end="(48, 3)" leading="" trailing="&#10;" val="See also `getElem?_zipWith'` for a variant&#10;using `Option.map` and `Option.bind` rather than a `match`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(49, 1)" end="(58, 40)" name="getElem?_zipWith" full_name="List.getElem?_zipWith" _is_private_decl="False">
        <AtomNode start="(49, 1)" end="(49, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(49, 9)" end="(49, 25)">
          <IdentNode start="(49, 9)" end="(49, 25)" leading="" trailing=" " raw_val="getElem?_zipWith" val="getElem?_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(49, 26)" end="(51, 54)">
          <NullNode start="(49, 26)" end="(49, 51)">
            <OtherNode start="(49, 26)" end="(49, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(49, 26)" end="(49, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(49, 27)" end="(49, 28)">
                <IdentNode start="(49, 27)" end="(49, 28)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(49, 29)" end="(49, 40)">
                <AtomNode start="(49, 29)" end="(49, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(49, 31)" end="(49, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(49, 31)" end="(49, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(49, 33)" end="(49, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(49, 35)" end="(49, 40)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(49, 35)" end="(49, 36)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(49, 37)" end="(49, 38)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(49, 39)" end="(49, 40)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(49, 40)" end="(49, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(49, 42)" end="(49, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(49, 42)" end="(49, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(49, 43)" end="(49, 44)">
                <IdentNode start="(49, 43)" end="(49, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(49, 45)" end="(49, 50)">
                <AtomNode start="(49, 45)" end="(49, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(49, 47)" end="(49, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(49, 50)" end="(49, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(49, 52)" end="(51, 54)">
            <AtomNode start="(49, 52)" end="(49, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(50, 5)" end="(51, 54)" kind="«term_=_»">
              <OtherNode start="(50, 5)" end="(50, 26)" kind="«term__[_]_?»">
                <OtherNode start="(50, 5)" end="(50, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(50, 5)" end="(50, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(50, 6)" end="(50, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(50, 6)" end="(50, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(50, 14)" end="(50, 21)">
                      <IdentNode start="(50, 14)" end="(50, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(50, 16)" end="(50, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(50, 19)" end="(50, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(50, 21)" end="(50, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(50, 22)" end="(50, 23)" leading="" trailing="" val="["/>
                <IdentNode start="(50, 23)" end="(50, 24)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(50, 24)" end="(50, 25)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(50, 25)" end="(50, 26)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(50, 27)" end="(50, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(50, 29)" end="(51, 54)" kind="Lean.Parser.Term.match">
                <AtomNode start="(50, 29)" end="(50, 34)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(50, 35)" end="(50, 49)">
                  <OtherNode start="(50, 35)" end="(50, 41)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(50, 35)" end="(50, 41)" kind="«term__[_]_?»">
                      <IdentNode start="(50, 35)" end="(50, 37)" leading="" trailing="" raw_val="as" val="as"/>
                      <GroupNode/>
                      <AtomNode start="(50, 37)" end="(50, 38)" leading="" trailing="" val="["/>
                      <IdentNode start="(50, 38)" end="(50, 39)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(50, 39)" end="(50, 40)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(50, 40)" end="(50, 41)" leading="" trailing="" val="?"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(50, 41)" end="(50, 42)" leading="" trailing=" " val=","/>
                  <OtherNode start="(50, 43)" end="(50, 49)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(50, 43)" end="(50, 49)" kind="«term__[_]_?»">
                      <IdentNode start="(50, 43)" end="(50, 45)" leading="" trailing="" raw_val="bs" val="bs"/>
                      <GroupNode/>
                      <AtomNode start="(50, 45)" end="(50, 46)" leading="" trailing="" val="["/>
                      <IdentNode start="(50, 46)" end="(50, 47)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(50, 47)" end="(50, 48)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(50, 48)" end="(50, 49)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(50, 50)" end="(50, 54)" leading="" trailing="&#10;      " val="with"/>
                <OtherNode start="(51, 7)" end="(51, 54)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(51, 7)" end="(51, 54)">
                    <OtherNode start="(51, 7)" end="(51, 39)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(51, 7)" end="(51, 8)" leading="" trailing=" " val="|"/>
                      <NullNode start="(51, 9)" end="(51, 23)">
                        <NullNode start="(51, 9)" end="(51, 23)">
                          <OtherNode start="(51, 9)" end="(51, 15)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(51, 9)" end="(51, 13)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(51, 14)" end="(51, 15)">
                              <IdentNode start="(51, 14)" end="(51, 15)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(51, 15)" end="(51, 16)" leading="" trailing=" " val=","/>
                          <OtherNode start="(51, 17)" end="(51, 23)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(51, 17)" end="(51, 21)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(51, 22)" end="(51, 23)">
                              <IdentNode start="(51, 22)" end="(51, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(51, 24)" end="(51, 26)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(51, 27)" end="(51, 39)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(51, 27)" end="(51, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(51, 32)" end="(51, 39)">
                          <OtherNode start="(51, 32)" end="(51, 39)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(51, 32)" end="(51, 33)" leading="" trailing="" val="("/>
                            <OtherNode start="(51, 33)" end="(51, 38)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(51, 33)" end="(51, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(51, 35)" end="(51, 38)">
                                <IdentNode start="(51, 35)" end="(51, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(51, 37)" end="(51, 38)" leading="" trailing="" raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(51, 38)" end="(51, 39)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(51, 40)" end="(51, 54)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(51, 40)" end="(51, 41)" leading="" trailing=" " val="|"/>
                      <NullNode start="(51, 42)" end="(51, 46)">
                        <NullNode start="(51, 42)" end="(51, 46)">
                          <TermHoleNode start="(51, 42)" end="(51, 43)">
                            <AtomNode start="(51, 42)" end="(51, 43)" leading="" trailing="" val="_"/>
                          </TermHoleNode>
                          <AtomNode start="(51, 43)" end="(51, 44)" leading="" trailing=" " val=","/>
                          <TermHoleNode start="(51, 45)" end="(51, 46)">
                            <AtomNode start="(51, 45)" end="(51, 46)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(51, 47)" end="(51, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                      <IdentNode start="(51, 50)" end="(51, 54)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(51, 55)" end="(58, 40)">
          <AtomNode start="(51, 55)" end="(51, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(51, 58)" end="(58, 40)">
            <AtomNode start="(51, 58)" end="(51, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(52, 3)" end="(58, 40)">
              <TacticTacticseq1IndentedNode start="(52, 3)" end="(58, 40)">
                <NullNode start="(52, 3)" end="(58, 40)">
                  <OtherNode start="(52, 3)" end="(58, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;⊢ (zipWith f as bs)[i]? =&#10;    match as[i]?, bs[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="induction as generalizing bs i with&#10;| nil =&amp;gt; cases bs with&#10;  | nil =&amp;gt; simp&#10;  | cons b bs =&amp;gt; simp&#10;| cons a as aih =&amp;gt; cases bs with&#10;  | nil =&amp;gt; simp&#10;  | cons b bs =&amp;gt; cases i &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(52, 3)" end="(52, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(52, 13)" end="(52, 15)">
                      <OtherNode start="(52, 13)" end="(52, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(52, 13)" end="(52, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(52, 16)" end="(52, 33)">
                      <AtomNode start="(52, 16)" end="(52, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(52, 29)" end="(52, 33)">
                        <IdentNode start="(52, 29)" end="(52, 31)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        <IdentNode start="(52, 32)" end="(52, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(52, 34)" end="(58, 40)">
                      <OtherNode start="(52, 34)" end="(58, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(52, 34)" end="(52, 38)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(53, 3)" end="(58, 40)">
                          <OtherNode start="(53, 3)" end="(55, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(53, 3)" end="(53, 8)">
                              <OtherNode start="(53, 3)" end="(53, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(53, 3)" end="(53, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(53, 5)" end="(53, 8)">
                                  <NullNode/>
                                  <IdentNode start="(53, 5)" end="(53, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(53, 9)" end="(55, 24)">
                              <AtomNode start="(53, 9)" end="(53, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(53, 12)" end="(55, 24)">
                                <TacticTacticseq1IndentedNode start="(53, 12)" end="(55, 24)">
                                  <NullNode start="(53, 12)" end="(55, 24)">
                                    <OtherNode start="(53, 12)" end="(55, 24)" kind="Lean.Parser.Tactic.cases" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;bs : List β&#10;i : Nat&#10;⊢ (zipWith f [] bs)[i]? =&#10;    match [][i]?, bs[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="cases bs with&#10;| nil =&amp;gt; simp&#10;| cons b bs =&amp;gt; simp">
                                      <AtomNode start="(53, 12)" end="(53, 17)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(53, 18)" end="(53, 20)">
                                        <OtherNode start="(53, 18)" end="(53, 20)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(53, 18)" end="(53, 20)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(53, 21)" end="(55, 24)">
                                        <OtherNode start="(53, 21)" end="(55, 24)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(53, 21)" end="(53, 25)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(54, 5)" end="(55, 24)">
                                            <OtherNode start="(54, 5)" end="(54, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(54, 5)" end="(54, 10)">
                                                <OtherNode start="(54, 5)" end="(54, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(54, 5)" end="(54, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(54, 7)" end="(54, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(54, 7)" end="(54, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(54, 11)" end="(54, 18)">
                                                <AtomNode start="(54, 11)" end="(54, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(54, 14)" end="(54, 18)">
                                                  <TacticTacticseq1IndentedNode start="(54, 14)" end="(54, 18)">
                                                    <NullNode start="(54, 14)" end="(54, 18)">
                                                      <OtherNode start="(54, 14)" end="(54, 18)" kind="Lean.Parser.Tactic.simp" state_before="case nil.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;i : Nat&#10;⊢ (zipWith f [] [])[i]? =&#10;    match [][i]?, [][i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(54, 14)" end="(54, 18)" leading="" trailing="&#10;    " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(55, 5)" end="(55, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(55, 5)" end="(55, 16)">
                                                <OtherNode start="(55, 5)" end="(55, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(55, 5)" end="(55, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(55, 7)" end="(55, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(55, 7)" end="(55, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(55, 12)" end="(55, 16)">
                                                    <IdentNode start="(55, 12)" end="(55, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(55, 14)" end="(55, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(55, 17)" end="(55, 24)">
                                                <AtomNode start="(55, 17)" end="(55, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(55, 20)" end="(55, 24)">
                                                  <TacticTacticseq1IndentedNode start="(55, 20)" end="(55, 24)">
                                                    <NullNode start="(55, 20)" end="(55, 24)">
                                                      <OtherNode start="(55, 20)" end="(55, 24)" kind="Lean.Parser.Tactic.simp" state_before="case nil.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;i : Nat&#10;b : β&#10;bs : List β&#10;⊢ (zipWith f [] (b :: bs))[i]? =&#10;    match [][i]?, (b :: bs)[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(55, 20)" end="(55, 24)" leading="" trailing="&#10;  " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(56, 3)" end="(58, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(56, 3)" end="(56, 18)">
                              <OtherNode start="(56, 3)" end="(56, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(56, 3)" end="(56, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(56, 5)" end="(56, 9)">
                                  <NullNode/>
                                  <IdentNode start="(56, 5)" end="(56, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(56, 10)" end="(56, 18)">
                                  <IdentNode start="(56, 10)" end="(56, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(56, 12)" end="(56, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(56, 15)" end="(56, 18)" leading="" trailing=" " raw_val="aih" val="aih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(56, 19)" end="(58, 40)">
                              <AtomNode start="(56, 19)" end="(56, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(56, 22)" end="(58, 40)">
                                <TacticTacticseq1IndentedNode start="(56, 22)" end="(58, 40)">
                                  <NullNode start="(56, 22)" end="(58, 40)">
                                    <OtherNode start="(56, 22)" end="(58, 40)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;a : α&#10;as : List α&#10;aih :&#10;  ∀ {bs : List β} {i : Nat},&#10;    (zipWith f as bs)[i]? =&#10;      match as[i]?, bs[i]? with&#10;      | some a, some b =&amp;gt; some (f a b)&#10;      | x, x_1 =&amp;gt; none&#10;bs : List β&#10;i : Nat&#10;⊢ (zipWith f (a :: as) bs)[i]? =&#10;    match (a :: as)[i]?, bs[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="cases bs with&#10;| nil =&amp;gt; simp&#10;| cons b bs =&amp;gt; cases i &amp;lt;;&amp;gt; simp_all">
                                      <AtomNode start="(56, 22)" end="(56, 27)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(56, 28)" end="(56, 30)">
                                        <OtherNode start="(56, 28)" end="(56, 30)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(56, 28)" end="(56, 30)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(56, 31)" end="(58, 40)">
                                        <OtherNode start="(56, 31)" end="(58, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(56, 31)" end="(56, 35)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(57, 5)" end="(58, 40)">
                                            <OtherNode start="(57, 5)" end="(57, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(57, 5)" end="(57, 10)">
                                                <OtherNode start="(57, 5)" end="(57, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(57, 5)" end="(57, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(57, 7)" end="(57, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(57, 7)" end="(57, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(57, 11)" end="(57, 18)">
                                                <AtomNode start="(57, 11)" end="(57, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(57, 14)" end="(57, 18)">
                                                  <TacticTacticseq1IndentedNode start="(57, 14)" end="(57, 18)">
                                                    <NullNode start="(57, 14)" end="(57, 18)">
                                                      <OtherNode start="(57, 14)" end="(57, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;a : α&#10;as : List α&#10;aih :&#10;  ∀ {bs : List β} {i : Nat},&#10;    (zipWith f as bs)[i]? =&#10;      match as[i]?, bs[i]? with&#10;      | some a, some b =&amp;gt; some (f a b)&#10;      | x, x_1 =&amp;gt; none&#10;i : Nat&#10;⊢ (zipWith f (a :: as) [])[i]? =&#10;    match (a :: as)[i]?, [][i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(57, 14)" end="(57, 18)" leading="" trailing="&#10;    " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(58, 5)" end="(58, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(58, 5)" end="(58, 16)">
                                                <OtherNode start="(58, 5)" end="(58, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(58, 5)" end="(58, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(58, 7)" end="(58, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(58, 7)" end="(58, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(58, 12)" end="(58, 16)">
                                                    <IdentNode start="(58, 12)" end="(58, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(58, 14)" end="(58, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(58, 17)" end="(58, 40)">
                                                <AtomNode start="(58, 17)" end="(58, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(58, 20)" end="(58, 40)">
                                                  <TacticTacticseq1IndentedNode start="(58, 20)" end="(58, 40)">
                                                    <NullNode start="(58, 20)" end="(58, 40)">
                                                      <OtherNode start="(58, 20)" end="(58, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;a : α&#10;as : List α&#10;aih :&#10;  ∀ {bs : List β} {i : Nat},&#10;    (zipWith f as bs)[i]? =&#10;      match as[i]?, bs[i]? with&#10;      | some a, some b =&amp;gt; some (f a b)&#10;      | x, x_1 =&amp;gt; none&#10;i : Nat&#10;b : β&#10;bs : List β&#10;⊢ (zipWith f (a :: as) (b :: bs))[i]? =&#10;    match (a :: as)[i]?, (b :: bs)[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="cases i &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(58, 20)" end="(58, 27)" kind="Lean.Parser.Tactic.cases">
                                                          <AtomNode start="(58, 20)" end="(58, 25)" leading="" trailing=" " val="cases"/>
                                                          <NullNode start="(58, 26)" end="(58, 27)">
                                                            <OtherNode start="(58, 26)" end="(58, 27)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(58, 26)" end="(58, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(58, 28)" end="(58, 31)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(58, 32)" end="(58, 40)" kind="Lean.Parser.Tactic.simpAll">
                                                          <AtomNode start="(58, 32)" end="(58, 40)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(60, 1)" end="(68, 27)" name="getElem?_zipWith'" full_name="List.getElem?_zipWith'">
      <CommandDeclmodifiersNode start="(60, 1)" end="(60, 97)">
        <NullNode start="(60, 1)" end="(60, 97)">
          <CommandDoccommentNode start="(60, 1)" end="(60, 97)" comment="Variant of `getElem?_zipWith` using `Option.map` and `Option.bind` rather than a `match`. -/">
            <AtomNode start="(60, 1)" end="(60, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(60, 5)" end="(60, 97)" leading="" trailing="&#10;" val="Variant of `getElem?_zipWith` using `Option.map` and `Option.bind` rather than a `match`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(61, 1)" end="(68, 27)" name="getElem?_zipWith'" full_name="List.getElem?_zipWith'" _is_private_decl="False">
        <AtomNode start="(61, 1)" end="(61, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(61, 9)" end="(61, 26)">
          <IdentNode start="(61, 9)" end="(61, 26)" leading="" trailing=" " raw_val="getElem?_zipWith'" val="getElem?_zipWith'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(61, 27)" end="(62, 70)">
          <NullNode start="(61, 27)" end="(61, 52)">
            <OtherNode start="(61, 27)" end="(61, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 27)" end="(61, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 28)" end="(61, 29)">
                <IdentNode start="(61, 28)" end="(61, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(61, 30)" end="(61, 41)">
                <AtomNode start="(61, 30)" end="(61, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 32)" end="(61, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(61, 32)" end="(61, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(61, 34)" end="(61, 35)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(61, 36)" end="(61, 41)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(61, 36)" end="(61, 37)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(61, 38)" end="(61, 39)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(61, 40)" end="(61, 41)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(61, 41)" end="(61, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(61, 43)" end="(61, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 43)" end="(61, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 44)" end="(61, 45)">
                <IdentNode start="(61, 44)" end="(61, 45)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(61, 46)" end="(61, 51)">
                <AtomNode start="(61, 46)" end="(61, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(61, 48)" end="(61, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(61, 51)" end="(61, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(61, 53)" end="(62, 70)">
            <AtomNode start="(61, 53)" end="(61, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(62, 5)" end="(62, 70)" kind="«term_=_»">
              <OtherNode start="(62, 5)" end="(62, 26)" kind="«term__[_]_?»">
                <OtherNode start="(62, 5)" end="(62, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(62, 5)" end="(62, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(62, 6)" end="(62, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(62, 6)" end="(62, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(62, 14)" end="(62, 21)">
                      <IdentNode start="(62, 14)" end="(62, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(62, 16)" end="(62, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(62, 19)" end="(62, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(62, 21)" end="(62, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(62, 22)" end="(62, 23)" leading="" trailing="" val="["/>
                <IdentNode start="(62, 23)" end="(62, 24)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(62, 24)" end="(62, 25)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(62, 25)" end="(62, 26)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(62, 27)" end="(62, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(62, 29)" end="(62, 70)" kind="Lean.Parser.Term.app">
                <OtherNode start="(62, 29)" end="(62, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(62, 29)" end="(62, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(62, 29)" end="(62, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(62, 30)" end="(62, 42)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(62, 30)" end="(62, 40)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(62, 30)" end="(62, 36)" kind="«term__[_]_?»">
                          <IdentNode start="(62, 30)" end="(62, 32)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          <GroupNode/>
                          <AtomNode start="(62, 32)" end="(62, 33)" leading="" trailing="" val="["/>
                          <IdentNode start="(62, 33)" end="(62, 34)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(62, 34)" end="(62, 35)" leading="" trailing="" val="]"/>
                          <GroupNode/>
                          <AtomNode start="(62, 35)" end="(62, 36)" leading="" trailing="" val="?"/>
                        </OtherNode>
                        <AtomNode start="(62, 36)" end="(62, 37)" leading="" trailing="" val="."/>
                        <IdentNode start="(62, 37)" end="(62, 40)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(62, 41)" end="(62, 42)">
                        <IdentNode start="(62, 41)" end="(62, 42)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(62, 42)" end="(62, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(62, 43)" end="(62, 44)" leading="" trailing="" val="."/>
                  <IdentNode start="(62, 44)" end="(62, 48)" leading="" trailing=" " raw_val="bind" val="bind" full_name="Option.bind" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(62, 49)" end="(62, 70)">
                  <OtherNode start="(62, 49)" end="(62, 70)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(62, 49)" end="(62, 52)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(62, 53)" end="(62, 70)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(62, 53)" end="(62, 54)">
                        <IdentNode start="(62, 53)" end="(62, 54)" leading="" trailing=" " raw_val="g" val="g"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(62, 55)" end="(62, 57)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(62, 58)" end="(62, 70)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(62, 58)" end="(62, 68)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(62, 58)" end="(62, 64)" kind="«term__[_]_?»">
                            <IdentNode start="(62, 58)" end="(62, 60)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                            <GroupNode/>
                            <AtomNode start="(62, 60)" end="(62, 61)" leading="" trailing="" val="["/>
                            <IdentNode start="(62, 61)" end="(62, 62)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(62, 62)" end="(62, 63)" leading="" trailing="" val="]"/>
                            <GroupNode/>
                            <AtomNode start="(62, 63)" end="(62, 64)" leading="" trailing="" val="?"/>
                          </OtherNode>
                          <AtomNode start="(62, 64)" end="(62, 65)" leading="" trailing="" val="."/>
                          <IdentNode start="(62, 65)" end="(62, 68)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <NullNode start="(62, 69)" end="(62, 70)">
                          <IdentNode start="(62, 69)" end="(62, 70)" leading="" trailing=" " raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(62, 71)" end="(68, 27)">
          <AtomNode start="(62, 71)" end="(62, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(62, 74)" end="(68, 27)">
            <AtomNode start="(62, 74)" end="(62, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(63, 3)" end="(68, 27)">
              <TacticTacticseq1IndentedNode start="(63, 3)" end="(68, 27)">
                <NullNode start="(63, 3)" end="(68, 27)">
                  <OtherNode start="(63, 3)" end="(68, 27)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₁ : List α&#10;l₂ : List β&#10;f : α → β → γ&#10;i : Nat&#10;⊢ (zipWith f l₁ l₂)[i]? = (Option.map f l₁[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?" state_after="no goals" tactic="induction l₁ generalizing l₂ i with&#10;| nil =&amp;gt; rw [zipWith] &amp;lt;;&amp;gt; simp&#10;| cons _ _ =&amp;gt;&#10;  cases l₂&#10;  · simp&#10;  · cases i &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(63, 3)" end="(63, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(63, 13)" end="(63, 15)">
                      <OtherNode start="(63, 13)" end="(63, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(63, 13)" end="(63, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(63, 16)" end="(63, 33)">
                      <AtomNode start="(63, 16)" end="(63, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(63, 29)" end="(63, 33)">
                        <IdentNode start="(63, 29)" end="(63, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <IdentNode start="(63, 32)" end="(63, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(63, 34)" end="(68, 27)">
                      <OtherNode start="(63, 34)" end="(68, 27)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(63, 34)" end="(63, 38)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(64, 3)" end="(68, 27)">
                          <OtherNode start="(64, 3)" end="(64, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(64, 3)" end="(64, 8)">
                              <OtherNode start="(64, 3)" end="(64, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(64, 3)" end="(64, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(64, 5)" end="(64, 8)">
                                  <NullNode/>
                                  <IdentNode start="(64, 5)" end="(64, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(64, 9)" end="(64, 33)">
                              <AtomNode start="(64, 9)" end="(64, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(64, 12)" end="(64, 33)">
                                <TacticTacticseq1IndentedNode start="(64, 12)" end="(64, 33)">
                                  <NullNode start="(64, 12)" end="(64, 33)">
                                    <OtherNode start="(64, 12)" end="(64, 33)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f [] l₂)[i]? = (Option.map f [][i]?).bind fun g =&amp;gt; Option.map g l₂[i]?" state_after="no goals" tactic="rw [zipWith] &amp;lt;;&amp;gt; simp">
                                      <OtherNode start="(64, 12)" end="(64, 24)" kind="Lean.Parser.Tactic.rwSeq">
                                        <AtomNode start="(64, 12)" end="(64, 14)" leading="" trailing=" " val="rw"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <OtherNode start="(64, 15)" end="(64, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                          <AtomNode start="(64, 15)" end="(64, 16)" leading="" trailing="" val="["/>
                                          <NullNode start="(64, 16)" end="(64, 23)">
                                            <OtherNode start="(64, 16)" end="(64, 23)" kind="Lean.Parser.Tactic.rwRule">
                                              <NullNode/>
                                              <IdentNode start="(64, 16)" end="(64, 23)" leading="" trailing="" raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(64, 23)" end="(64, 24)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(64, 25)" end="(64, 28)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(64, 29)" end="(64, 33)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(64, 29)" end="(64, 33)" leading="" trailing="&#10;  " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(65, 3)" end="(68, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(65, 3)" end="(65, 13)">
                              <OtherNode start="(65, 3)" end="(65, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(65, 3)" end="(65, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(65, 5)" end="(65, 9)">
                                  <NullNode/>
                                  <IdentNode start="(65, 5)" end="(65, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(65, 10)" end="(65, 13)">
                                  <TermHoleNode start="(65, 10)" end="(65, 11)">
                                    <AtomNode start="(65, 10)" end="(65, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(65, 12)" end="(65, 13)">
                                    <AtomNode start="(65, 12)" end="(65, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(65, 14)" end="(68, 27)">
                              <AtomNode start="(65, 14)" end="(65, 16)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(66, 5)" end="(68, 27)">
                                <TacticTacticseq1IndentedNode start="(66, 5)" end="(68, 27)">
                                  <NullNode start="(66, 5)" end="(68, 27)">
                                    <OtherNode start="(66, 5)" end="(66, 13)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = (Option.map f tail✝[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) l₂)[i]? = (Option.map f (head✝ :: tail✝)[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?" state_after="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = (Option.map f tail✝[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) [])[i]? = (Option.map f (head✝ :: tail✝)[i]?).bind fun g =&amp;gt; Option.map g [][i]?&#10;&#10;case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝¹ l₂)[i]? = (Option.map f tail✝¹[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;head✝ : β&#10;tail✝ : List β&#10;⊢ (zipWith f (head✝¹ :: tail✝¹) (head✝ :: tail✝))[i]? =&#10;    (Option.map f (head✝¹ :: tail✝¹)[i]?).bind fun g =&amp;gt; Option.map g (head✝ :: tail✝)[i]?" tactic="cases l₂">
                                      <AtomNode start="(66, 5)" end="(66, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(66, 11)" end="(66, 13)">
                                        <OtherNode start="(66, 11)" end="(66, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(66, 11)" end="(66, 13)" leading="" trailing="&#10;    " raw_val="l₂" val="l₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(67, 5)" end="(67, 11)" kind="Lean.cdot" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = (Option.map f tail✝[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) [])[i]? = (Option.map f (head✝ :: tail✝)[i]?).bind fun g =&amp;gt; Option.map g [][i]?&#10;&#10;case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝¹ l₂)[i]? = (Option.map f tail✝¹[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;head✝ : β&#10;tail✝ : List β&#10;⊢ (zipWith f (head✝¹ :: tail✝¹) (head✝ :: tail✝))[i]? =&#10;    (Option.map f (head✝¹ :: tail✝¹)[i]?).bind fun g =&amp;gt; Option.map g (head✝ :: tail✝)[i]?" state_after="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝¹ l₂)[i]? = (Option.map f tail✝¹[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;head✝ : β&#10;tail✝ : List β&#10;⊢ (zipWith f (head✝¹ :: tail✝¹) (head✝ :: tail✝))[i]? =&#10;    (Option.map f (head✝¹ :: tail✝¹)[i]?).bind fun g =&amp;gt; Option.map g (head✝ :: tail✝)[i]?" tactic="· simp">
                                      <OtherNode start="(67, 5)" end="(67, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(67, 5)" end="(67, 6)" kind="patternIgnore">
                                          <OtherNode start="(67, 5)" end="(67, 6)" kind="token.«· »">
                                            <AtomNode start="(67, 5)" end="(67, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(67, 7)" end="(67, 11)">
                                        <TacticTacticseq1IndentedNode start="(67, 7)" end="(67, 11)">
                                          <NullNode start="(67, 7)" end="(67, 11)">
                                            <OtherNode start="(67, 7)" end="(67, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = (Option.map f tail✝[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) [])[i]? = (Option.map f (head✝ :: tail✝)[i]?).bind fun g =&amp;gt; Option.map g [][i]?" state_after="no goals" tactic="simp">
                                              <AtomNode start="(67, 7)" end="(67, 11)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(68, 5)" end="(68, 27)" kind="Lean.cdot" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝¹ l₂)[i]? = (Option.map f tail✝¹[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;head✝ : β&#10;tail✝ : List β&#10;⊢ (zipWith f (head✝¹ :: tail✝¹) (head✝ :: tail✝))[i]? =&#10;    (Option.map f (head✝¹ :: tail✝¹)[i]?).bind fun g =&amp;gt; Option.map g (head✝ :: tail✝)[i]?" state_after="no goals" tactic="· cases i &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(68, 5)" end="(68, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(68, 5)" end="(68, 6)" kind="patternIgnore">
                                          <OtherNode start="(68, 5)" end="(68, 6)" kind="token.«· »">
                                            <AtomNode start="(68, 5)" end="(68, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(68, 7)" end="(68, 27)">
                                        <TacticTacticseq1IndentedNode start="(68, 7)" end="(68, 27)">
                                          <NullNode start="(68, 7)" end="(68, 27)">
                                            <OtherNode start="(68, 7)" end="(68, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝¹ l₂)[i]? = (Option.map f tail✝¹[i]?).bind fun g =&amp;gt; Option.map g l₂[i]?&#10;i : Nat&#10;head✝ : β&#10;tail✝ : List β&#10;⊢ (zipWith f (head✝¹ :: tail✝¹) (head✝ :: tail✝))[i]? =&#10;    (Option.map f (head✝¹ :: tail✝¹)[i]?).bind fun g =&amp;gt; Option.map g (head✝ :: tail✝)[i]?" state_after="no goals" tactic="cases i &amp;lt;;&amp;gt; simp_all">
                                              <OtherNode start="(68, 7)" end="(68, 14)" kind="Lean.Parser.Tactic.cases">
                                                <AtomNode start="(68, 7)" end="(68, 12)" leading="" trailing=" " val="cases"/>
                                                <NullNode start="(68, 13)" end="(68, 14)">
                                                  <OtherNode start="(68, 13)" end="(68, 14)" kind="Lean.Parser.Tactic.elimTarget">
                                                    <NullNode/>
                                                    <IdentNode start="(68, 13)" end="(68, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(68, 15)" end="(68, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(68, 19)" end="(68, 27)" kind="Lean.Parser.Tactic.simpAll">
                                                <AtomNode start="(68, 19)" end="(68, 27)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(70, 1)" end="(75, 38)" name="getElem?_zipWith_eq_some" full_name="List.getElem?_zipWith_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(70, 1)" end="(75, 38)" name="getElem?_zipWith_eq_some" full_name="List.getElem?_zipWith_eq_some" _is_private_decl="False">
        <AtomNode start="(70, 1)" end="(70, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(70, 9)" end="(70, 33)">
          <IdentNode start="(70, 9)" end="(70, 33)" leading="" trailing=" " raw_val="getElem?_zipWith_eq_some" val="getElem?_zipWith_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(70, 34)" end="(72, 59)">
          <NullNode start="(70, 34)" end="(70, 95)">
            <OtherNode start="(70, 34)" end="(70, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(70, 34)" end="(70, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(70, 35)" end="(70, 36)">
                <IdentNode start="(70, 35)" end="(70, 36)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(70, 37)" end="(70, 48)">
                <AtomNode start="(70, 37)" end="(70, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(70, 39)" end="(70, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(70, 39)" end="(70, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(70, 41)" end="(70, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(70, 43)" end="(70, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(70, 43)" end="(70, 44)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(70, 45)" end="(70, 46)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(70, 47)" end="(70, 48)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(70, 48)" end="(70, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(70, 50)" end="(70, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(70, 50)" end="(70, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(70, 51)" end="(70, 53)">
                <IdentNode start="(70, 51)" end="(70, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(70, 54)" end="(70, 62)">
                <AtomNode start="(70, 54)" end="(70, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(70, 56)" end="(70, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(70, 56)" end="(70, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(70, 61)" end="(70, 62)">
                    <IdentNode start="(70, 61)" end="(70, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(70, 62)" end="(70, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(70, 64)" end="(70, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(70, 64)" end="(70, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(70, 65)" end="(70, 67)">
                <IdentNode start="(70, 65)" end="(70, 67)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(70, 68)" end="(70, 76)">
                <AtomNode start="(70, 68)" end="(70, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(70, 70)" end="(70, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(70, 70)" end="(70, 74)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(70, 75)" end="(70, 76)">
                    <IdentNode start="(70, 75)" end="(70, 76)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(70, 76)" end="(70, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(70, 78)" end="(70, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(70, 78)" end="(70, 79)" leading="" trailing="" val="{"/>
              <NullNode start="(70, 79)" end="(70, 80)">
                <IdentNode start="(70, 79)" end="(70, 80)" leading="" trailing=" " raw_val="z" val="z"/>
              </NullNode>
              <NullNode start="(70, 81)" end="(70, 84)">
                <AtomNode start="(70, 81)" end="(70, 82)" leading="" trailing=" " val=":"/>
                <IdentNode start="(70, 83)" end="(70, 84)" leading="" trailing="" raw_val="γ" val="γ"/>
              </NullNode>
              <AtomNode start="(70, 84)" end="(70, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(70, 86)" end="(70, 95)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(70, 86)" end="(70, 87)" leading="" trailing="" val="{"/>
              <NullNode start="(70, 87)" end="(70, 88)">
                <IdentNode start="(70, 87)" end="(70, 88)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(70, 89)" end="(70, 94)">
                <AtomNode start="(70, 89)" end="(70, 90)" leading="" trailing=" " val=":"/>
                <IdentNode start="(70, 91)" end="(70, 94)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(70, 94)" end="(70, 95)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(70, 96)" end="(72, 59)">
            <AtomNode start="(70, 96)" end="(70, 97)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(71, 5)" end="(72, 59)" kind="«term_↔_»">
              <OtherNode start="(71, 5)" end="(71, 35)" kind="«term_=_»">
                <OtherNode start="(71, 5)" end="(71, 26)" kind="«term__[_]_?»">
                  <OtherNode start="(71, 5)" end="(71, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(71, 5)" end="(71, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(71, 6)" end="(71, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(71, 6)" end="(71, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(71, 14)" end="(71, 21)">
                        <IdentNode start="(71, 14)" end="(71, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(71, 16)" end="(71, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(71, 19)" end="(71, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(71, 21)" end="(71, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <GroupNode/>
                  <AtomNode start="(71, 22)" end="(71, 23)" leading="" trailing="" val="["/>
                  <IdentNode start="(71, 23)" end="(71, 24)" leading="" trailing="" raw_val="i" val="i"/>
                  <AtomNode start="(71, 24)" end="(71, 25)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(71, 25)" end="(71, 26)" leading="" trailing=" " val="?"/>
                </OtherNode>
                <AtomNode start="(71, 27)" end="(71, 28)" leading="" trailing=" " val="="/>
                <OtherNode start="(71, 29)" end="(71, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(71, 29)" end="(71, 33)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(71, 34)" end="(71, 35)">
                    <IdentNode start="(71, 34)" end="(71, 35)" leading="" trailing=" " raw_val="z" val="z"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(71, 36)" end="(71, 37)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(72, 7)" end="(72, 59)" kind="«term∃_,_»">
                <AtomNode start="(72, 7)" end="(72, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(72, 9)" end="(72, 12)" kind="Lean.explicitBinders">
                  <OtherNode start="(72, 9)" end="(72, 12)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(72, 9)" end="(72, 12)">
                      <LeanBinderidentNode start="(72, 9)" end="(72, 10)">
                        <IdentNode start="(72, 9)" end="(72, 10)" leading="" trailing=" " raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(72, 11)" end="(72, 12)">
                        <IdentNode start="(72, 11)" end="(72, 12)" leading="" trailing="" raw_val="y" val="y"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(72, 12)" end="(72, 13)" leading="" trailing=" " val=","/>
                <OtherNode start="(72, 14)" end="(72, 59)" kind="«term_∧_»">
                  <OtherNode start="(72, 14)" end="(72, 29)" kind="«term_=_»">
                    <OtherNode start="(72, 14)" end="(72, 20)" kind="«term__[_]_?»">
                      <IdentNode start="(72, 14)" end="(72, 16)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      <GroupNode/>
                      <AtomNode start="(72, 16)" end="(72, 17)" leading="" trailing="" val="["/>
                      <IdentNode start="(72, 17)" end="(72, 18)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(72, 18)" end="(72, 19)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(72, 19)" end="(72, 20)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                    <AtomNode start="(72, 21)" end="(72, 22)" leading="" trailing=" " val="="/>
                    <OtherNode start="(72, 23)" end="(72, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(72, 23)" end="(72, 27)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(72, 28)" end="(72, 29)">
                        <IdentNode start="(72, 28)" end="(72, 29)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(72, 30)" end="(72, 31)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(72, 32)" end="(72, 59)" kind="«term_∧_»">
                    <OtherNode start="(72, 32)" end="(72, 47)" kind="«term_=_»">
                      <OtherNode start="(72, 32)" end="(72, 38)" kind="«term__[_]_?»">
                        <IdentNode start="(72, 32)" end="(72, 34)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        <GroupNode/>
                        <AtomNode start="(72, 34)" end="(72, 35)" leading="" trailing="" val="["/>
                        <IdentNode start="(72, 35)" end="(72, 36)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(72, 36)" end="(72, 37)" leading="" trailing="" val="]"/>
                        <GroupNode/>
                        <AtomNode start="(72, 37)" end="(72, 38)" leading="" trailing=" " val="?"/>
                      </OtherNode>
                      <AtomNode start="(72, 39)" end="(72, 40)" leading="" trailing=" " val="="/>
                      <OtherNode start="(72, 41)" end="(72, 47)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(72, 41)" end="(72, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(72, 46)" end="(72, 47)">
                          <IdentNode start="(72, 46)" end="(72, 47)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(72, 48)" end="(72, 49)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(72, 50)" end="(72, 59)" kind="«term_=_»">
                      <OtherNode start="(72, 50)" end="(72, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(72, 50)" end="(72, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(72, 52)" end="(72, 55)">
                          <IdentNode start="(72, 52)" end="(72, 53)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(72, 54)" end="(72, 55)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(72, 56)" end="(72, 57)" leading="" trailing=" " val="="/>
                      <IdentNode start="(72, 58)" end="(72, 59)" leading="" trailing=" " raw_val="z" val="z"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(72, 60)" end="(75, 38)">
          <AtomNode start="(72, 60)" end="(72, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(72, 63)" end="(75, 38)">
            <AtomNode start="(72, 63)" end="(72, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(73, 3)" end="(75, 38)">
              <TacticTacticseq1IndentedNode start="(73, 3)" end="(75, 38)">
                <NullNode start="(73, 3)" end="(75, 38)">
                  <OtherNode start="(73, 3)" end="(73, 33)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁ : List α&#10;l₂ : List β&#10;z : γ&#10;i : Nat&#10;⊢ (zipWith f l₁ l₂)[i]? = some z ↔ ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z" state_after="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f [] l₂)[i]? = some z ↔ ∃ x y, [][i]? = some x ∧ l₂[i]? = some y ∧ f x y = z&#10;&#10;case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = some z ↔ ∃ x y, tail✝[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) l₂)[i]? = some z ↔ ∃ x y, (head✝ :: tail✝)[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z" tactic="induction l₁ generalizing l₂ i">
                    <AtomNode start="(73, 3)" end="(73, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(73, 13)" end="(73, 15)">
                      <OtherNode start="(73, 13)" end="(73, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(73, 13)" end="(73, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(73, 16)" end="(73, 33)">
                      <AtomNode start="(73, 16)" end="(73, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(73, 29)" end="(73, 33)">
                        <IdentNode start="(73, 29)" end="(73, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <IdentNode start="(73, 32)" end="(73, 33)" leading="" trailing="&#10;  " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(74, 3)" end="(74, 9)" kind="Lean.cdot" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f [] l₂)[i]? = some z ↔ ∃ x y, [][i]? = some x ∧ l₂[i]? = some y ∧ f x y = z&#10;&#10;case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = some z ↔ ∃ x y, tail✝[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) l₂)[i]? = some z ↔ ∃ x y, (head✝ :: tail✝)[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = some z ↔ ∃ x y, tail✝[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) l₂)[i]? = some z ↔ ∃ x y, (head✝ :: tail✝)[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z" tactic="· simp">
                    <OtherNode start="(74, 3)" end="(74, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(74, 3)" end="(74, 4)" kind="patternIgnore">
                        <OtherNode start="(74, 3)" end="(74, 4)" kind="token.«· »">
                          <AtomNode start="(74, 3)" end="(74, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(74, 5)" end="(74, 9)">
                      <TacticTacticseq1IndentedNode start="(74, 5)" end="(74, 9)">
                        <NullNode start="(74, 5)" end="(74, 9)">
                          <OtherNode start="(74, 5)" end="(74, 9)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f [] l₂)[i]? = some z ↔ ∃ x y, [][i]? = some x ∧ l₂[i]? = some y ∧ f x y = z" state_after="no goals" tactic="simp">
                            <AtomNode start="(74, 5)" end="(74, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(75, 3)" end="(75, 38)" kind="Lean.cdot" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = some z ↔ ∃ x y, tail✝[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) l₂)[i]? = some z ↔ ∃ x y, (head✝ :: tail✝)[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z" state_after="no goals" tactic="· cases l₂ &amp;lt;;&amp;gt; cases i &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(75, 3)" end="(75, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(75, 3)" end="(75, 4)" kind="patternIgnore">
                        <OtherNode start="(75, 3)" end="(75, 4)" kind="token.«· »">
                          <AtomNode start="(75, 3)" end="(75, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(75, 5)" end="(75, 38)">
                      <TacticTacticseq1IndentedNode start="(75, 5)" end="(75, 38)">
                        <NullNode start="(75, 5)" end="(75, 38)">
                          <OtherNode start="(75, 5)" end="(75, 38)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;z : γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ :&#10;  ∀ {l₂ : List β} {i : Nat}, (zipWith f tail✝ l₂)[i]? = some z ↔ ∃ x y, tail✝[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z&#10;l₂ : List β&#10;i : Nat&#10;⊢ (zipWith f (head✝ :: tail✝) l₂)[i]? = some z ↔ ∃ x y, (head✝ :: tail✝)[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z" state_after="no goals" tactic="cases l₂ &amp;lt;;&amp;gt; cases i &amp;lt;;&amp;gt; simp_all">
                            <OtherNode start="(75, 5)" end="(75, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                              <OtherNode start="(75, 5)" end="(75, 13)" kind="Lean.Parser.Tactic.cases">
                                <AtomNode start="(75, 5)" end="(75, 10)" leading="" trailing=" " val="cases"/>
                                <NullNode start="(75, 11)" end="(75, 13)">
                                  <OtherNode start="(75, 11)" end="(75, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                    <NullNode/>
                                    <IdentNode start="(75, 11)" end="(75, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(75, 14)" end="(75, 17)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                              <OtherNode start="(75, 18)" end="(75, 25)" kind="Lean.Parser.Tactic.cases">
                                <AtomNode start="(75, 18)" end="(75, 23)" leading="" trailing=" " val="cases"/>
                                <NullNode start="(75, 24)" end="(75, 25)">
                                  <OtherNode start="(75, 24)" end="(75, 25)" kind="Lean.Parser.Tactic.elimTarget">
                                    <NullNode/>
                                    <IdentNode start="(75, 24)" end="(75, 25)" leading="" trailing=" " raw_val="i" val="i"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(75, 26)" end="(75, 29)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(75, 30)" end="(75, 38)" kind="Lean.Parser.Tactic.simpAll">
                              <AtomNode start="(75, 30)" end="(75, 38)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(77, 1)" end="(84, 30)" name="getElem?_zip_eq_some" full_name="List.getElem?_zip_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(77, 1)" end="(84, 30)" name="getElem?_zip_eq_some" full_name="List.getElem?_zip_eq_some" _is_private_decl="False">
        <AtomNode start="(77, 1)" end="(77, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(77, 9)" end="(77, 29)">
          <IdentNode start="(77, 9)" end="(77, 29)" leading="" trailing=" " raw_val="getElem?_zip_eq_some" val="getElem?_zip_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(77, 30)" end="(78, 69)">
          <NullNode start="(77, 30)" end="(77, 79)">
            <OtherNode start="(77, 30)" end="(77, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(77, 30)" end="(77, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(77, 31)" end="(77, 33)">
                <IdentNode start="(77, 31)" end="(77, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(77, 34)" end="(77, 42)">
                <AtomNode start="(77, 34)" end="(77, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(77, 36)" end="(77, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(77, 36)" end="(77, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(77, 41)" end="(77, 42)">
                    <IdentNode start="(77, 41)" end="(77, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(77, 42)" end="(77, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(77, 44)" end="(77, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(77, 44)" end="(77, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(77, 45)" end="(77, 47)">
                <IdentNode start="(77, 45)" end="(77, 47)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(77, 48)" end="(77, 56)">
                <AtomNode start="(77, 48)" end="(77, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(77, 50)" end="(77, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(77, 50)" end="(77, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(77, 55)" end="(77, 56)">
                    <IdentNode start="(77, 55)" end="(77, 56)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(77, 56)" end="(77, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(77, 58)" end="(77, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(77, 58)" end="(77, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(77, 59)" end="(77, 60)">
                <IdentNode start="(77, 59)" end="(77, 60)" leading="" trailing=" " raw_val="z" val="z"/>
              </NullNode>
              <NullNode start="(77, 61)" end="(77, 68)">
                <AtomNode start="(77, 61)" end="(77, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(77, 63)" end="(77, 68)" kind="«term_×_»">
                  <IdentNode start="(77, 63)" end="(77, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(77, 65)" end="(77, 66)" leading="" trailing=" " val="×"/>
                  <IdentNode start="(77, 67)" end="(77, 68)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(77, 68)" end="(77, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(77, 70)" end="(77, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(77, 70)" end="(77, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(77, 71)" end="(77, 72)">
                <IdentNode start="(77, 71)" end="(77, 72)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(77, 73)" end="(77, 78)">
                <AtomNode start="(77, 73)" end="(77, 74)" leading="" trailing=" " val=":"/>
                <IdentNode start="(77, 75)" end="(77, 78)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(77, 78)" end="(77, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(77, 80)" end="(78, 69)">
            <AtomNode start="(77, 80)" end="(77, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(78, 5)" end="(78, 69)" kind="«term_↔_»">
              <OtherNode start="(78, 5)" end="(78, 29)" kind="«term_=_»">
                <OtherNode start="(78, 5)" end="(78, 20)" kind="«term__[_]_?»">
                  <OtherNode start="(78, 5)" end="(78, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(78, 5)" end="(78, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(78, 6)" end="(78, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(78, 6)" end="(78, 9)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(78, 10)" end="(78, 15)">
                        <IdentNode start="(78, 10)" end="(78, 12)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(78, 13)" end="(78, 15)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(78, 15)" end="(78, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <GroupNode/>
                  <AtomNode start="(78, 16)" end="(78, 17)" leading="" trailing="" val="["/>
                  <IdentNode start="(78, 17)" end="(78, 18)" leading="" trailing="" raw_val="i" val="i"/>
                  <AtomNode start="(78, 18)" end="(78, 19)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(78, 19)" end="(78, 20)" leading="" trailing=" " val="?"/>
                </OtherNode>
                <AtomNode start="(78, 21)" end="(78, 22)" leading="" trailing=" " val="="/>
                <OtherNode start="(78, 23)" end="(78, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 23)" end="(78, 27)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(78, 28)" end="(78, 29)">
                    <IdentNode start="(78, 28)" end="(78, 29)" leading="" trailing=" " raw_val="z" val="z"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(78, 30)" end="(78, 31)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(78, 32)" end="(78, 69)" kind="«term_∧_»">
                <OtherNode start="(78, 32)" end="(78, 49)" kind="«term_=_»">
                  <OtherNode start="(78, 32)" end="(78, 38)" kind="«term__[_]_?»">
                    <IdentNode start="(78, 32)" end="(78, 34)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                    <GroupNode/>
                    <AtomNode start="(78, 34)" end="(78, 35)" leading="" trailing="" val="["/>
                    <IdentNode start="(78, 35)" end="(78, 36)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(78, 36)" end="(78, 37)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(78, 37)" end="(78, 38)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(78, 39)" end="(78, 40)" leading="" trailing=" " val="="/>
                  <OtherNode start="(78, 41)" end="(78, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(78, 41)" end="(78, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(78, 46)" end="(78, 49)">
                      <OtherNode start="(78, 46)" end="(78, 49)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(78, 46)" end="(78, 47)" leading="" trailing="" raw_val="z" val="z"/>
                        <AtomNode start="(78, 47)" end="(78, 48)" leading="" trailing="" val="."/>
                        <OtherNode start="(78, 48)" end="(78, 49)" kind="fieldIdx">
                          <AtomNode start="(78, 48)" end="(78, 49)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(78, 50)" end="(78, 51)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(78, 52)" end="(78, 69)" kind="«term_=_»">
                  <OtherNode start="(78, 52)" end="(78, 58)" kind="«term__[_]_?»">
                    <IdentNode start="(78, 52)" end="(78, 54)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    <GroupNode/>
                    <AtomNode start="(78, 54)" end="(78, 55)" leading="" trailing="" val="["/>
                    <IdentNode start="(78, 55)" end="(78, 56)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(78, 56)" end="(78, 57)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(78, 57)" end="(78, 58)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(78, 59)" end="(78, 60)" leading="" trailing=" " val="="/>
                  <OtherNode start="(78, 61)" end="(78, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(78, 61)" end="(78, 65)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(78, 66)" end="(78, 69)">
                      <OtherNode start="(78, 66)" end="(78, 69)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(78, 66)" end="(78, 67)" leading="" trailing="" raw_val="z" val="z"/>
                        <AtomNode start="(78, 67)" end="(78, 68)" leading="" trailing="" val="."/>
                        <OtherNode start="(78, 68)" end="(78, 69)" kind="fieldIdx">
                          <AtomNode start="(78, 68)" end="(78, 69)" leading="" trailing=" " val="2"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(78, 70)" end="(84, 30)">
          <AtomNode start="(78, 70)" end="(78, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(78, 73)" end="(84, 30)">
            <AtomNode start="(78, 73)" end="(78, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(79, 3)" end="(84, 30)">
              <TacticTacticseq1IndentedNode start="(79, 3)" end="(84, 30)">
                <NullNode start="(79, 3)" end="(84, 30)">
                  <OtherNode start="(79, 3)" end="(79, 10)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;z : α × β&#10;i : Nat&#10;⊢ (l₁.zip l₂)[i]? = some z ↔ l₁[i]? = some z.fst ∧ l₂[i]? = some z.snd" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ (l₁.zip l₂)[i]? = some (fst✝, snd✝) ↔ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd" tactic="cases z">
                    <AtomNode start="(79, 3)" end="(79, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(79, 9)" end="(79, 10)">
                      <OtherNode start="(79, 9)" end="(79, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(79, 9)" end="(79, 10)" leading="" trailing="&#10;  " raw_val="z" val="z"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(80, 3)" end="(80, 37)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ (l₁.zip l₂)[i]? = some (fst✝, snd✝) ↔ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ (∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)) ↔&#10;    l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd" tactic="rw [zip, getElem?_zipWith_eq_some]">
                    <AtomNode start="(80, 3)" end="(80, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(80, 6)" end="(80, 37)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(80, 6)" end="(80, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(80, 7)" end="(80, 36)">
                        <OtherNode start="(80, 7)" end="(80, 10)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(80, 7)" end="(80, 10)" leading="" trailing="" raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(80, 10)" end="(80, 11)" leading="" trailing=" " val=","/>
                        <OtherNode start="(80, 12)" end="(80, 36)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(80, 12)" end="(80, 36)" leading="" trailing="" raw_val="getElem?_zipWith_eq_some" val="getElem?_zipWith_eq_some" full_name="List.getElem?_zipWith_eq_some" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(70, 9)" def_end="(70, 33)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(80, 36)" end="(80, 37)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(80, 37)" end="(80, 38)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(80, 39)" end="(80, 50)" kind="Lean.Parser.Tactic.constructor" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ (∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)) ↔&#10;    l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd" state_after="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ (∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)) →&#10;    l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd →&#10;    ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)" tactic="constructor">
                    <AtomNode start="(80, 39)" end="(80, 50)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(81, 3)" end="(82, 28)" kind="Lean.cdot" state_before="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ (∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)) →&#10;    l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd →&#10;    ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)" state_after="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd →&#10;    ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)" tactic="· rintro ⟨x, y, h₀, h₁, h₂⟩&#10;  simpa [h₀, h₁] using h₂">
                    <OtherNode start="(81, 3)" end="(81, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(81, 3)" end="(81, 4)" kind="patternIgnore">
                        <OtherNode start="(81, 3)" end="(81, 4)" kind="token.«· »">
                          <AtomNode start="(81, 3)" end="(81, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(81, 5)" end="(82, 28)">
                      <TacticTacticseq1IndentedNode start="(81, 5)" end="(82, 28)">
                        <NullNode start="(81, 5)" end="(82, 28)">
                          <OtherNode start="(81, 5)" end="(81, 30)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ (∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)) →&#10;    l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd" state_after="case mk.mp.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;x : α&#10;y : β&#10;h₀ : l₁[i]? = some x&#10;h₁ : l₂[i]? = some y&#10;h₂ : (x, y) = (fst✝, snd✝)&#10;⊢ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd" tactic="rintro ⟨x, y, h₀, h₁, h₂⟩">
                            <AtomNode start="(81, 5)" end="(81, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(81, 12)" end="(81, 30)">
                              <OtherNode start="(81, 12)" end="(81, 30)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(81, 12)" end="(81, 30)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(81, 12)" end="(81, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(81, 13)" end="(81, 29)">
                                    <OtherNode start="(81, 13)" end="(81, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(81, 13)" end="(81, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(81, 13)" end="(81, 14)">
                                          <OtherNode start="(81, 13)" end="(81, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(81, 13)" end="(81, 14)" leading="" trailing="" raw_val="x" val="x"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(81, 14)" end="(81, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(81, 16)" end="(81, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(81, 16)" end="(81, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(81, 16)" end="(81, 17)">
                                          <OtherNode start="(81, 16)" end="(81, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(81, 16)" end="(81, 17)" leading="" trailing="" raw_val="y" val="y"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(81, 17)" end="(81, 18)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(81, 19)" end="(81, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(81, 19)" end="(81, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(81, 19)" end="(81, 21)">
                                          <OtherNode start="(81, 19)" end="(81, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(81, 19)" end="(81, 21)" leading="" trailing="" raw_val="h₀" val="h₀"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(81, 21)" end="(81, 22)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(81, 23)" end="(81, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(81, 23)" end="(81, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(81, 23)" end="(81, 25)">
                                          <OtherNode start="(81, 23)" end="(81, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(81, 23)" end="(81, 25)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(81, 25)" end="(81, 26)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(81, 27)" end="(81, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(81, 27)" end="(81, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(81, 27)" end="(81, 29)">
                                          <OtherNode start="(81, 27)" end="(81, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(81, 27)" end="(81, 29)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(81, 29)" end="(81, 30)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(82, 5)" end="(82, 28)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mp.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;x : α&#10;y : β&#10;h₀ : l₁[i]? = some x&#10;h₁ : l₂[i]? = some y&#10;h₂ : (x, y) = (fst✝, snd✝)&#10;⊢ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd" state_after="no goals" tactic="simpa [h₀, h₁] using h₂">
                            <AtomNode start="(82, 5)" end="(82, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(82, 11)" end="(82, 28)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(82, 11)" end="(82, 19)">
                                <OtherNode start="(82, 11)" end="(82, 19)" kind="Lean.Parser.Tactic.simpArgs">
                                  <AtomNode start="(82, 11)" end="(82, 12)" leading="" trailing="" val="["/>
                                  <NullNode start="(82, 12)" end="(82, 18)">
                                    <OtherNode start="(82, 12)" end="(82, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(82, 12)" end="(82, 14)" leading="" trailing="" raw_val="h₀" val="h₀"/>
                                    </OtherNode>
                                    <AtomNode start="(82, 14)" end="(82, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(82, 16)" end="(82, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(82, 16)" end="(82, 18)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(82, 18)" end="(82, 19)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode start="(82, 20)" end="(82, 28)">
                                <AtomNode start="(82, 20)" end="(82, 25)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(82, 26)" end="(82, 28)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(83, 3)" end="(84, 30)" kind="Lean.cdot" state_before="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd →&#10;    ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)" state_after="no goals" tactic="· rintro ⟨h₀, h₁⟩&#10;  exact ⟨_, _, h₀, h₁, rfl⟩">
                    <OtherNode start="(83, 3)" end="(83, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(83, 3)" end="(83, 4)" kind="patternIgnore">
                        <OtherNode start="(83, 3)" end="(83, 4)" kind="token.«· »">
                          <AtomNode start="(83, 3)" end="(83, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(83, 5)" end="(84, 30)">
                      <TacticTacticseq1IndentedNode start="(83, 5)" end="(84, 30)">
                        <NullNode start="(83, 5)" end="(84, 30)">
                          <OtherNode start="(83, 5)" end="(83, 20)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;⊢ l₁[i]? = some (fst✝, snd✝).fst ∧ l₂[i]? = some (fst✝, snd✝).snd →&#10;    ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)" state_after="case mk.mpr.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;h₀ : l₁[i]? = some (fst✝, snd✝).fst&#10;h₁ : l₂[i]? = some (fst✝, snd✝).snd&#10;⊢ ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)" tactic="rintro ⟨h₀, h₁⟩">
                            <AtomNode start="(83, 5)" end="(83, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(83, 12)" end="(83, 20)">
                              <OtherNode start="(83, 12)" end="(83, 20)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(83, 12)" end="(83, 20)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(83, 12)" end="(83, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(83, 13)" end="(83, 19)">
                                    <OtherNode start="(83, 13)" end="(83, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(83, 13)" end="(83, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(83, 13)" end="(83, 15)">
                                          <OtherNode start="(83, 13)" end="(83, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(83, 13)" end="(83, 15)" leading="" trailing="" raw_val="h₀" val="h₀"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(83, 15)" end="(83, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(83, 17)" end="(83, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(83, 17)" end="(83, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(83, 17)" end="(83, 19)">
                                          <OtherNode start="(83, 17)" end="(83, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(83, 17)" end="(83, 19)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(83, 19)" end="(83, 20)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(84, 5)" end="(84, 30)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mpr.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;i : Nat&#10;fst✝ : α&#10;snd✝ : β&#10;h₀ : l₁[i]? = some (fst✝, snd✝).fst&#10;h₁ : l₂[i]? = some (fst✝, snd✝).snd&#10;⊢ ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ (x, y) = (fst✝, snd✝)" state_after="no goals" tactic="exact ⟨_, _, h₀, h₁, rfl⟩">
                            <AtomNode start="(84, 5)" end="(84, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(84, 11)" end="(84, 30)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(84, 11)" end="(84, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(84, 12)" end="(84, 29)">
                                <TermHoleNode start="(84, 12)" end="(84, 13)">
                                  <AtomNode start="(84, 12)" end="(84, 13)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(84, 13)" end="(84, 14)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(84, 15)" end="(84, 16)">
                                  <AtomNode start="(84, 15)" end="(84, 16)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(84, 16)" end="(84, 17)" leading="" trailing=" " val=","/>
                                <IdentNode start="(84, 18)" end="(84, 20)" leading="" trailing="" raw_val="h₀" val="h₀"/>
                                <AtomNode start="(84, 20)" end="(84, 21)" leading="" trailing=" " val=","/>
                                <IdentNode start="(84, 22)" end="(84, 24)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                <AtomNode start="(84, 24)" end="(84, 25)" leading="" trailing=" " val=","/>
                                <IdentNode start="(84, 26)" end="(84, 29)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(84, 29)" end="(84, 30)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(86, 1)" end="(89, 45)" name="head?_zipWith" full_name="List.head?_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(86, 1)" end="(89, 45)" name="head?_zipWith" full_name="List.head?_zipWith" _is_private_decl="False">
        <AtomNode start="(86, 1)" end="(86, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(86, 9)" end="(86, 22)">
          <IdentNode start="(86, 9)" end="(86, 22)" leading="" trailing=" " raw_val="head?_zipWith" val="head?_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(86, 23)" end="(88, 54)">
          <NullNode start="(86, 23)" end="(86, 38)">
            <OtherNode start="(86, 23)" end="(86, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(86, 23)" end="(86, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(86, 24)" end="(86, 25)">
                <IdentNode start="(86, 24)" end="(86, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(86, 26)" end="(86, 37)">
                <AtomNode start="(86, 26)" end="(86, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(86, 28)" end="(86, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(86, 28)" end="(86, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(86, 30)" end="(86, 31)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(86, 32)" end="(86, 37)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(86, 32)" end="(86, 33)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(86, 34)" end="(86, 35)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(86, 36)" end="(86, 37)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(86, 37)" end="(86, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(86, 39)" end="(88, 54)">
            <AtomNode start="(86, 39)" end="(86, 40)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(87, 5)" end="(88, 54)" kind="«term_=_»">
              <OtherNode start="(87, 5)" end="(87, 33)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(87, 5)" end="(87, 27)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(87, 5)" end="(87, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(87, 6)" end="(87, 26)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(87, 6)" end="(87, 18)" leading="" trailing=" " raw_val="List.zipWith" val="List.zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(87, 19)" end="(87, 26)">
                      <IdentNode start="(87, 19)" end="(87, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(87, 21)" end="(87, 23)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(87, 24)" end="(87, 26)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(87, 26)" end="(87, 27)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(87, 27)" end="(87, 28)" leading="" trailing="" val="."/>
                <IdentNode start="(87, 28)" end="(87, 33)" leading="" trailing=" " raw_val="head?" val="head?" full_name="List.head?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(87, 34)" end="(87, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(87, 36)" end="(88, 54)" kind="Lean.Parser.Term.match">
                <AtomNode start="(87, 36)" end="(87, 41)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(87, 42)" end="(87, 60)">
                  <OtherNode start="(87, 42)" end="(87, 50)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <IdentNode start="(87, 42)" end="(87, 50)" leading="" trailing="" raw_val="as.head?" val="as.head?"/>
                  </OtherNode>
                  <AtomNode start="(87, 50)" end="(87, 51)" leading="" trailing=" " val=","/>
                  <OtherNode start="(87, 52)" end="(87, 60)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <IdentNode start="(87, 52)" end="(87, 60)" leading="" trailing=" " raw_val="bs.head?" val="bs.head?"/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(87, 61)" end="(87, 65)" leading="" trailing="&#10;      " val="with"/>
                <OtherNode start="(88, 7)" end="(88, 54)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(88, 7)" end="(88, 54)">
                    <OtherNode start="(88, 7)" end="(88, 39)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(88, 7)" end="(88, 8)" leading="" trailing=" " val="|"/>
                      <NullNode start="(88, 9)" end="(88, 23)">
                        <NullNode start="(88, 9)" end="(88, 23)">
                          <OtherNode start="(88, 9)" end="(88, 15)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(88, 9)" end="(88, 13)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(88, 14)" end="(88, 15)">
                              <IdentNode start="(88, 14)" end="(88, 15)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(88, 15)" end="(88, 16)" leading="" trailing=" " val=","/>
                          <OtherNode start="(88, 17)" end="(88, 23)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(88, 17)" end="(88, 21)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(88, 22)" end="(88, 23)">
                              <IdentNode start="(88, 22)" end="(88, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(88, 24)" end="(88, 26)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(88, 27)" end="(88, 39)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(88, 27)" end="(88, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(88, 32)" end="(88, 39)">
                          <OtherNode start="(88, 32)" end="(88, 39)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(88, 32)" end="(88, 33)" leading="" trailing="" val="("/>
                            <OtherNode start="(88, 33)" end="(88, 38)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(88, 33)" end="(88, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(88, 35)" end="(88, 38)">
                                <IdentNode start="(88, 35)" end="(88, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(88, 37)" end="(88, 38)" leading="" trailing="" raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(88, 38)" end="(88, 39)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(88, 40)" end="(88, 54)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(88, 40)" end="(88, 41)" leading="" trailing=" " val="|"/>
                      <NullNode start="(88, 42)" end="(88, 46)">
                        <NullNode start="(88, 42)" end="(88, 46)">
                          <TermHoleNode start="(88, 42)" end="(88, 43)">
                            <AtomNode start="(88, 42)" end="(88, 43)" leading="" trailing="" val="_"/>
                          </TermHoleNode>
                          <AtomNode start="(88, 43)" end="(88, 44)" leading="" trailing=" " val=","/>
                          <TermHoleNode start="(88, 45)" end="(88, 46)">
                            <AtomNode start="(88, 45)" end="(88, 46)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(88, 47)" end="(88, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                      <IdentNode start="(88, 50)" end="(88, 54)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(88, 55)" end="(89, 45)">
          <AtomNode start="(88, 55)" end="(88, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(88, 58)" end="(89, 45)">
            <AtomNode start="(88, 58)" end="(88, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(89, 3)" end="(89, 45)">
              <TacticTacticseq1IndentedNode start="(89, 3)" end="(89, 45)">
                <NullNode start="(89, 3)" end="(89, 45)">
                  <OtherNode start="(89, 3)" end="(89, 45)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;⊢ (zipWith f as bs).head? =&#10;    match as.head?, bs.head? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="simp [head?_eq_getElem?, getElem?_zipWith]">
                    <AtomNode start="(89, 3)" end="(89, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(89, 8)" end="(89, 45)">
                      <AtomNode start="(89, 8)" end="(89, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(89, 9)" end="(89, 44)">
                        <OtherNode start="(89, 9)" end="(89, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(89, 9)" end="(89, 26)" leading="" trailing="" raw_val="head?_eq_getElem?" val="head?_eq_getElem?" full_name="List.head?_eq_getElem?" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(89, 26)" end="(89, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(89, 28)" end="(89, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(89, 28)" end="(89, 44)" leading="" trailing="" raw_val="getElem?_zipWith" val="getElem?_zipWith" full_name="List.getElem?_zipWith" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(49, 9)" def_end="(49, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(89, 44)" end="(89, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(91, 1)" end="(94, 68)" name="head_zipWith" full_name="List.head_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(91, 1)" end="(94, 68)" name="head_zipWith" full_name="List.head_zipWith" _is_private_decl="False">
        <AtomNode start="(91, 1)" end="(91, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(91, 9)" end="(91, 21)">
          <IdentNode start="(91, 9)" end="(91, 21)" leading="" trailing=" " raw_val="head_zipWith" val="head_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(91, 22)" end="(92, 110)">
          <NullNode start="(91, 22)" end="(91, 41)">
            <OtherNode start="(91, 22)" end="(91, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(91, 22)" end="(91, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(91, 23)" end="(91, 24)">
                <IdentNode start="(91, 23)" end="(91, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(91, 25)" end="(91, 36)">
                <AtomNode start="(91, 25)" end="(91, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(91, 27)" end="(91, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(91, 27)" end="(91, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(91, 29)" end="(91, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(91, 31)" end="(91, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(91, 31)" end="(91, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(91, 33)" end="(91, 34)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(91, 35)" end="(91, 36)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(91, 36)" end="(91, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(91, 38)" end="(91, 41)">
              <AtomNode start="(91, 38)" end="(91, 39)" leading="" trailing="" val="("/>
              <NullNode start="(91, 39)" end="(91, 40)">
                <IdentNode start="(91, 39)" end="(91, 40)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(91, 40)" end="(91, 41)" leading="" trailing="" val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(91, 41)" end="(92, 110)">
            <AtomNode start="(91, 41)" end="(91, 42)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(92, 5)" end="(92, 110)" kind="«term_=_»">
              <OtherNode start="(92, 5)" end="(92, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(92, 5)" end="(92, 32)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(92, 5)" end="(92, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(92, 5)" end="(92, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(92, 6)" end="(92, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(92, 6)" end="(92, 18)" leading="" trailing=" " raw_val="List.zipWith" val="List.zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(92, 19)" end="(92, 26)">
                        <IdentNode start="(92, 19)" end="(92, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(92, 21)" end="(92, 23)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(92, 24)" end="(92, 26)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(92, 26)" end="(92, 27)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(92, 27)" end="(92, 28)" leading="" trailing="" val="."/>
                  <IdentNode start="(92, 28)" end="(92, 32)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(92, 33)" end="(92, 34)">
                  <IdentNode start="(92, 33)" end="(92, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(92, 35)" end="(92, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(92, 37)" end="(92, 110)" kind="Lean.Parser.Term.app">
                <IdentNode start="(92, 37)" end="(92, 38)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(92, 39)" end="(92, 110)">
                  <OtherNode start="(92, 39)" end="(92, 74)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(92, 39)" end="(92, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(92, 40)" end="(92, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(92, 40)" end="(92, 47)" leading="" trailing=" " raw_val="as.head" val="as.head"/>
                      <NullNode start="(92, 48)" end="(92, 73)">
                        <OtherNode start="(92, 48)" end="(92, 73)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(92, 48)" end="(92, 49)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(92, 49)" end="(92, 72)">
                            <AtomNode start="(92, 49)" end="(92, 51)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(92, 52)" end="(92, 72)">
                              <TacticTacticseq1IndentedNode start="(92, 52)" end="(92, 72)">
                                <NullNode start="(92, 52)" end="(92, 72)">
                                  <OtherNode start="(92, 52)" end="(92, 62)" kind="Lean.Parser.Tactic.rintro" state_before="α : Type ?u.39069&#10;β : Type ?u.39068&#10;γ : Type ?u.39067&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;h : zipWith f as bs ≠ []&#10;⊢ as ≠ []" state_after="α : Type ?u.39069&#10;β : Type ?u.39068&#10;γ : Type ?u.39067&#10;bs : List β&#10;f : α → β → γ&#10;h : zipWith f [] bs ≠ []&#10;⊢ False" tactic="rintro rfl">
                                    <AtomNode start="(92, 52)" end="(92, 58)" leading="" trailing=" " val="rintro"/>
                                    <NullNode start="(92, 59)" end="(92, 62)">
                                      <OtherNode start="(92, 59)" end="(92, 62)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(92, 59)" end="(92, 62)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(92, 59)" end="(92, 62)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(92, 62)" end="(92, 63)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(92, 64)" end="(92, 72)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type ?u.39069&#10;β : Type ?u.39068&#10;γ : Type ?u.39067&#10;bs : List β&#10;f : α → β → γ&#10;h : zipWith f [] bs ≠ []&#10;⊢ False" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(92, 64)" end="(92, 72)" leading="" trailing="" val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(92, 72)" end="(92, 73)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(92, 73)" end="(92, 74)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(92, 75)" end="(92, 110)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(92, 75)" end="(92, 76)" leading="" trailing="" val="("/>
                    <OtherNode start="(92, 76)" end="(92, 109)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(92, 76)" end="(92, 83)" leading="" trailing=" " raw_val="bs.head" val="bs.head"/>
                      <NullNode start="(92, 84)" end="(92, 109)">
                        <OtherNode start="(92, 84)" end="(92, 109)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(92, 84)" end="(92, 85)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(92, 85)" end="(92, 108)">
                            <AtomNode start="(92, 85)" end="(92, 87)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(92, 88)" end="(92, 108)">
                              <TacticTacticseq1IndentedNode start="(92, 88)" end="(92, 108)">
                                <NullNode start="(92, 88)" end="(92, 108)">
                                  <OtherNode start="(92, 88)" end="(92, 98)" kind="Lean.Parser.Tactic.rintro" state_before="α : Type ?u.39069&#10;β : Type ?u.39068&#10;γ : Type ?u.39067&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;h : zipWith f as bs ≠ []&#10;⊢ bs ≠ []" state_after="α : Type ?u.39069&#10;β : Type ?u.39068&#10;γ : Type ?u.39067&#10;as : List α&#10;f : α → β → γ&#10;h : zipWith f as [] ≠ []&#10;⊢ False" tactic="rintro rfl">
                                    <AtomNode start="(92, 88)" end="(92, 94)" leading="" trailing=" " val="rintro"/>
                                    <NullNode start="(92, 95)" end="(92, 98)">
                                      <OtherNode start="(92, 95)" end="(92, 98)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(92, 95)" end="(92, 98)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(92, 95)" end="(92, 98)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(92, 98)" end="(92, 99)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(92, 100)" end="(92, 108)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type ?u.39069&#10;β : Type ?u.39068&#10;γ : Type ?u.39067&#10;as : List α&#10;f : α → β → γ&#10;h : zipWith f as [] ≠ []&#10;⊢ False" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(92, 100)" end="(92, 108)" leading="" trailing="" val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(92, 108)" end="(92, 109)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(92, 109)" end="(92, 110)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(92, 111)" end="(94, 68)">
          <AtomNode start="(92, 111)" end="(92, 113)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(92, 114)" end="(94, 68)">
            <AtomNode start="(92, 114)" end="(92, 116)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(93, 3)" end="(94, 68)">
              <TacticTacticseq1IndentedNode start="(93, 3)" end="(94, 68)">
                <NullNode start="(93, 3)" end="(94, 68)">
                  <OtherNode start="(93, 3)" end="(93, 24)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;h : zipWith f as bs ≠ []&#10;⊢ (zipWith f as bs).head h = f (as.head ⋯) (bs.head ⋯)" state_after="case x&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;h : zipWith f as bs ≠ []&#10;⊢ some ((zipWith f as bs).head h) = some (f (as.head ⋯) (bs.head ⋯))" tactic="apply Option.some.inj">
                    <AtomNode start="(93, 3)" end="(93, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(93, 9)" end="(93, 24)" leading="" trailing="&#10;  " raw_val="Option.some.inj" val="Option.some.inj" full_name="Option.some.inj" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(94, 3)" end="(94, 68)" kind="Lean.Parser.Tactic.rwSeq" state_before="case x&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;h : zipWith f as bs ≠ []&#10;⊢ some ((zipWith f as bs).head h) = some (f (as.head ⋯) (bs.head ⋯))" state_after="no goals" tactic="rw [← head?_eq_head, head?_zipWith, head?_eq_head, head?_eq_head]">
                    <AtomNode start="(94, 3)" end="(94, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(94, 6)" end="(94, 68)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(94, 6)" end="(94, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(94, 7)" end="(94, 67)">
                        <OtherNode start="(94, 7)" end="(94, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(94, 7)" end="(94, 8)">
                            <OtherNode start="(94, 7)" end="(94, 8)" kind="patternIgnore">
                              <OtherNode start="(94, 7)" end="(94, 8)" kind="token.«← »">
                                <AtomNode start="(94, 7)" end="(94, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(94, 9)" end="(94, 22)" leading="" trailing="" raw_val="head?_eq_head" val="head?_eq_head" full_name="List.head?_eq_head" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(94, 22)" end="(94, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 24)" end="(94, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(94, 24)" end="(94, 37)" leading="" trailing="" raw_val="head?_zipWith" val="head?_zipWith" full_name="List.head?_zipWith" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(86, 9)" def_end="(86, 22)"/>
                        </OtherNode>
                        <AtomNode start="(94, 37)" end="(94, 38)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 39)" end="(94, 52)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(94, 39)" end="(94, 52)" leading="" trailing="" raw_val="head?_eq_head" val="head?_eq_head" full_name="List.head?_eq_head" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(94, 52)" end="(94, 53)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 54)" end="(94, 67)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(94, 54)" end="(94, 67)" leading="" trailing="" raw_val="head?_eq_head" val="head?_eq_head" full_name="List.head?_eq_head" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(94, 67)" end="(94, 68)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(96, 1)" end="(99, 57)" name="zipWith_map" full_name="List.zipWith_map">
      <CommandDeclmodifiersNode start="(96, 1)" end="(96, 8)">
        <NullNode/>
        <NullNode start="(96, 1)" end="(96, 8)">
          <OtherNode start="(96, 1)" end="(96, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(96, 1)" end="(96, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(96, 3)" end="(96, 7)">
              <OtherNode start="(96, 3)" end="(96, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(96, 3)" end="(96, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(96, 3)" end="(96, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(96, 7)" end="(96, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(97, 1)" end="(99, 57)" name="zipWith_map" full_name="List.zipWith_map" _is_private_decl="False">
        <AtomNode start="(97, 1)" end="(97, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(97, 9)" end="(97, 20)">
          <IdentNode start="(97, 9)" end="(97, 20)" leading="" trailing=" " raw_val="zipWith_map" val="zipWith_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(97, 21)" end="(98, 79)">
          <NullNode start="(97, 21)" end="(97, 92)">
            <OtherNode start="(97, 21)" end="(97, 24)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 21)" end="(97, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 22)" end="(97, 23)">
                <IdentNode start="(97, 22)" end="(97, 23)" leading="" trailing="" raw_val="μ" val="μ"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(97, 23)" end="(97, 24)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(97, 25)" end="(97, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 25)" end="(97, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 26)" end="(97, 27)">
                <IdentNode start="(97, 26)" end="(97, 27)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(97, 28)" end="(97, 39)">
                <AtomNode start="(97, 28)" end="(97, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 30)" end="(97, 39)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(97, 30)" end="(97, 31)" leading="" trailing=" " raw_val="γ" val="γ"/>
                  <AtomNode start="(97, 32)" end="(97, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(97, 34)" end="(97, 39)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(97, 34)" end="(97, 35)" leading="" trailing=" " raw_val="δ" val="δ"/>
                    <AtomNode start="(97, 36)" end="(97, 37)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(97, 38)" end="(97, 39)" leading="" trailing="" raw_val="μ" val="μ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 39)" end="(97, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(97, 41)" end="(97, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 41)" end="(97, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 42)" end="(97, 43)">
                <IdentNode start="(97, 42)" end="(97, 43)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(97, 44)" end="(97, 51)">
                <AtomNode start="(97, 44)" end="(97, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 46)" end="(97, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(97, 46)" end="(97, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(97, 48)" end="(97, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(97, 50)" end="(97, 51)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 51)" end="(97, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(97, 53)" end="(97, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 53)" end="(97, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 54)" end="(97, 55)">
                <IdentNode start="(97, 54)" end="(97, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(97, 56)" end="(97, 63)">
                <AtomNode start="(97, 56)" end="(97, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 58)" end="(97, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(97, 58)" end="(97, 59)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(97, 60)" end="(97, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(97, 62)" end="(97, 63)" leading="" trailing="" raw_val="δ" val="δ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 63)" end="(97, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(97, 65)" end="(97, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 65)" end="(97, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 66)" end="(97, 68)">
                <IdentNode start="(97, 66)" end="(97, 68)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(97, 69)" end="(97, 77)">
                <AtomNode start="(97, 69)" end="(97, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 71)" end="(97, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(97, 71)" end="(97, 75)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(97, 76)" end="(97, 77)">
                    <IdentNode start="(97, 76)" end="(97, 77)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 77)" end="(97, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(97, 79)" end="(97, 92)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 79)" end="(97, 80)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 80)" end="(97, 82)">
                <IdentNode start="(97, 80)" end="(97, 82)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(97, 83)" end="(97, 91)">
                <AtomNode start="(97, 83)" end="(97, 84)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 85)" end="(97, 91)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(97, 85)" end="(97, 89)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(97, 90)" end="(97, 91)">
                    <IdentNode start="(97, 90)" end="(97, 91)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 91)" end="(97, 92)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(97, 93)" end="(98, 79)">
            <AtomNode start="(97, 93)" end="(97, 94)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(98, 5)" end="(98, 79)" kind="«term_=_»">
              <OtherNode start="(98, 5)" end="(98, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(98, 5)" end="(98, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(98, 13)" end="(98, 36)">
                  <IdentNode start="(98, 13)" end="(98, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(98, 15)" end="(98, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(98, 15)" end="(98, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(98, 16)" end="(98, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(98, 16)" end="(98, 22)" leading="" trailing=" " raw_val="l₁.map" val="l₁.map"/>
                      <NullNode start="(98, 23)" end="(98, 24)">
                        <IdentNode start="(98, 23)" end="(98, 24)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(98, 24)" end="(98, 25)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(98, 26)" end="(98, 36)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(98, 26)" end="(98, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(98, 27)" end="(98, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(98, 27)" end="(98, 33)" leading="" trailing=" " raw_val="l₂.map" val="l₂.map"/>
                      <NullNode start="(98, 34)" end="(98, 35)">
                        <IdentNode start="(98, 34)" end="(98, 35)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(98, 35)" end="(98, 36)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(98, 37)" end="(98, 38)" leading="" trailing=" " val="="/>
              <OtherNode start="(98, 39)" end="(98, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(98, 39)" end="(98, 46)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(98, 47)" end="(98, 79)">
                  <OtherNode start="(98, 47)" end="(98, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(98, 47)" end="(98, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(98, 48)" end="(98, 72)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(98, 48)" end="(98, 51)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(98, 52)" end="(98, 72)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(98, 52)" end="(98, 55)">
                          <IdentNode start="(98, 52)" end="(98, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(98, 54)" end="(98, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(98, 56)" end="(98, 58)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(98, 59)" end="(98, 72)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(98, 59)" end="(98, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(98, 61)" end="(98, 72)">
                            <OtherNode start="(98, 61)" end="(98, 66)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(98, 61)" end="(98, 62)" leading="" trailing="" val="("/>
                              <OtherNode start="(98, 62)" end="(98, 65)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(98, 62)" end="(98, 63)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(98, 64)" end="(98, 65)">
                                  <IdentNode start="(98, 64)" end="(98, 65)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(98, 65)" end="(98, 66)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(98, 67)" end="(98, 72)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(98, 67)" end="(98, 68)" leading="" trailing="" val="("/>
                              <OtherNode start="(98, 68)" end="(98, 71)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(98, 68)" end="(98, 69)" leading="" trailing=" " raw_val="h" val="h"/>
                                <NullNode start="(98, 70)" end="(98, 71)">
                                  <IdentNode start="(98, 70)" end="(98, 71)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(98, 71)" end="(98, 72)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(98, 72)" end="(98, 73)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(98, 74)" end="(98, 76)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(98, 77)" end="(98, 79)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(98, 80)" end="(99, 57)">
          <AtomNode start="(98, 80)" end="(98, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(98, 83)" end="(99, 57)">
            <AtomNode start="(98, 83)" end="(98, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(99, 3)" end="(99, 57)">
              <TacticTacticseq1IndentedNode start="(99, 3)" end="(99, 57)">
                <NullNode start="(99, 3)" end="(99, 57)">
                  <OtherNode start="(99, 3)" end="(99, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="γ : Type u_1&#10;δ : Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;μ : Type u_5&#10;f : γ → δ → μ&#10;g : α → γ&#10;h : β → δ&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ zipWith f (map g l₁) (map h l₂) = zipWith (fun a b =&amp;gt; f (g a) (h b)) l₁ l₂" state_after="no goals" tactic="induction l₁ generalizing l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(99, 3)" end="(99, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(99, 3)" end="(99, 31)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(99, 3)" end="(99, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(99, 13)" end="(99, 15)">
                          <OtherNode start="(99, 13)" end="(99, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(99, 13)" end="(99, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(99, 16)" end="(99, 31)">
                          <AtomNode start="(99, 16)" end="(99, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(99, 29)" end="(99, 31)">
                            <IdentNode start="(99, 29)" end="(99, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(99, 32)" end="(99, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(99, 36)" end="(99, 44)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(99, 36)" end="(99, 41)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(99, 42)" end="(99, 44)">
                          <OtherNode start="(99, 42)" end="(99, 44)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(99, 42)" end="(99, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(99, 45)" end="(99, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(99, 49)" end="(99, 57)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(99, 49)" end="(99, 57)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(101, 1)" end="(103, 57)" name="zipWith_map_left" full_name="List.zipWith_map_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(101, 1)" end="(103, 57)" name="zipWith_map_left" full_name="List.zipWith_map_left" _is_private_decl="False">
        <AtomNode start="(101, 1)" end="(101, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(101, 9)" end="(101, 25)">
          <IdentNode start="(101, 9)" end="(101, 25)" leading="" trailing=" " raw_val="zipWith_map_left" val="zipWith_map_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(101, 26)" end="(102, 67)">
          <NullNode start="(101, 26)" end="(101, 83)">
            <OtherNode start="(101, 26)" end="(101, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(101, 26)" end="(101, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(101, 27)" end="(101, 29)">
                <IdentNode start="(101, 27)" end="(101, 29)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(101, 30)" end="(101, 38)">
                <AtomNode start="(101, 30)" end="(101, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(101, 32)" end="(101, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(101, 32)" end="(101, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(101, 37)" end="(101, 38)">
                    <IdentNode start="(101, 37)" end="(101, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(101, 38)" end="(101, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(101, 40)" end="(101, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(101, 40)" end="(101, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(101, 41)" end="(101, 43)">
                <IdentNode start="(101, 41)" end="(101, 43)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(101, 44)" end="(101, 52)">
                <AtomNode start="(101, 44)" end="(101, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(101, 46)" end="(101, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(101, 46)" end="(101, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(101, 51)" end="(101, 52)">
                    <IdentNode start="(101, 51)" end="(101, 52)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(101, 52)" end="(101, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(101, 54)" end="(101, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(101, 54)" end="(101, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(101, 55)" end="(101, 56)">
                <IdentNode start="(101, 55)" end="(101, 56)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(101, 57)" end="(101, 65)">
                <AtomNode start="(101, 57)" end="(101, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(101, 59)" end="(101, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(101, 59)" end="(101, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(101, 61)" end="(101, 62)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(101, 63)" end="(101, 65)" leading="" trailing="" raw_val="α'" val="α'"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(101, 65)" end="(101, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(101, 67)" end="(101, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(101, 67)" end="(101, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(101, 68)" end="(101, 69)">
                <IdentNode start="(101, 68)" end="(101, 69)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(101, 70)" end="(101, 82)">
                <AtomNode start="(101, 70)" end="(101, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(101, 72)" end="(101, 82)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(101, 72)" end="(101, 74)" leading="" trailing=" " raw_val="α'" val="α'"/>
                  <AtomNode start="(101, 75)" end="(101, 76)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(101, 77)" end="(101, 82)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(101, 77)" end="(101, 78)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(101, 79)" end="(101, 80)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(101, 81)" end="(101, 82)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(101, 82)" end="(101, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(101, 84)" end="(102, 67)">
            <AtomNode start="(101, 84)" end="(101, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(102, 5)" end="(102, 67)" kind="«term_=_»">
              <OtherNode start="(102, 5)" end="(102, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(102, 5)" end="(102, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(102, 13)" end="(102, 28)">
                  <IdentNode start="(102, 13)" end="(102, 14)" leading="" trailing=" " raw_val="g" val="g"/>
                  <OtherNode start="(102, 15)" end="(102, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(102, 15)" end="(102, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(102, 16)" end="(102, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(102, 16)" end="(102, 22)" leading="" trailing=" " raw_val="l₁.map" val="l₁.map"/>
                      <NullNode start="(102, 23)" end="(102, 24)">
                        <IdentNode start="(102, 23)" end="(102, 24)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(102, 24)" end="(102, 25)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(102, 26)" end="(102, 28)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(102, 29)" end="(102, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(102, 31)" end="(102, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(102, 31)" end="(102, 38)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(102, 39)" end="(102, 67)">
                  <OtherNode start="(102, 39)" end="(102, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(102, 39)" end="(102, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(102, 40)" end="(102, 60)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(102, 40)" end="(102, 43)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(102, 44)" end="(102, 60)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(102, 44)" end="(102, 47)">
                          <IdentNode start="(102, 44)" end="(102, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(102, 46)" end="(102, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(102, 48)" end="(102, 50)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(102, 51)" end="(102, 60)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(102, 51)" end="(102, 52)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(102, 53)" end="(102, 60)">
                            <OtherNode start="(102, 53)" end="(102, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(102, 53)" end="(102, 54)" leading="" trailing="" val="("/>
                              <OtherNode start="(102, 54)" end="(102, 57)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(102, 54)" end="(102, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(102, 56)" end="(102, 57)">
                                  <IdentNode start="(102, 56)" end="(102, 57)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(102, 57)" end="(102, 58)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(102, 59)" end="(102, 60)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(102, 60)" end="(102, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(102, 62)" end="(102, 64)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(102, 65)" end="(102, 67)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(102, 68)" end="(103, 57)">
          <AtomNode start="(102, 68)" end="(102, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(102, 71)" end="(103, 57)">
            <AtomNode start="(102, 71)" end="(102, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(103, 3)" end="(103, 57)">
              <TacticTacticseq1IndentedNode start="(103, 3)" end="(103, 57)">
                <NullNode start="(103, 3)" end="(103, 57)">
                  <OtherNode start="(103, 3)" end="(103, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;α' : Type u_3&#10;γ : Type u_4&#10;l₁ : List α&#10;l₂ : List β&#10;f : α → α'&#10;g : α' → β → γ&#10;⊢ zipWith g (map f l₁) l₂ = zipWith (fun a b =&amp;gt; g (f a) b) l₁ l₂" state_after="no goals" tactic="induction l₁ generalizing l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(103, 3)" end="(103, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(103, 3)" end="(103, 31)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(103, 3)" end="(103, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(103, 13)" end="(103, 15)">
                          <OtherNode start="(103, 13)" end="(103, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(103, 13)" end="(103, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(103, 16)" end="(103, 31)">
                          <AtomNode start="(103, 16)" end="(103, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(103, 29)" end="(103, 31)">
                            <IdentNode start="(103, 29)" end="(103, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(103, 32)" end="(103, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(103, 36)" end="(103, 44)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(103, 36)" end="(103, 41)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(103, 42)" end="(103, 44)">
                          <OtherNode start="(103, 42)" end="(103, 44)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(103, 42)" end="(103, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(103, 45)" end="(103, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(103, 49)" end="(103, 57)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(103, 49)" end="(103, 57)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(105, 1)" end="(107, 57)" name="zipWith_map_right" full_name="List.zipWith_map_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(105, 1)" end="(107, 57)" name="zipWith_map_right" full_name="List.zipWith_map_right" _is_private_decl="False">
        <AtomNode start="(105, 1)" end="(105, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(105, 9)" end="(105, 26)">
          <IdentNode start="(105, 9)" end="(105, 26)" leading="" trailing=" " raw_val="zipWith_map_right" val="zipWith_map_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(105, 27)" end="(106, 67)">
          <NullNode start="(105, 27)" end="(105, 84)">
            <OtherNode start="(105, 27)" end="(105, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(105, 27)" end="(105, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(105, 28)" end="(105, 30)">
                <IdentNode start="(105, 28)" end="(105, 30)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(105, 31)" end="(105, 39)">
                <AtomNode start="(105, 31)" end="(105, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(105, 33)" end="(105, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(105, 33)" end="(105, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(105, 38)" end="(105, 39)">
                    <IdentNode start="(105, 38)" end="(105, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(105, 39)" end="(105, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(105, 41)" end="(105, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(105, 41)" end="(105, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(105, 42)" end="(105, 44)">
                <IdentNode start="(105, 42)" end="(105, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(105, 45)" end="(105, 53)">
                <AtomNode start="(105, 45)" end="(105, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(105, 47)" end="(105, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(105, 47)" end="(105, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(105, 52)" end="(105, 53)">
                    <IdentNode start="(105, 52)" end="(105, 53)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(105, 53)" end="(105, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(105, 55)" end="(105, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(105, 55)" end="(105, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(105, 56)" end="(105, 57)">
                <IdentNode start="(105, 56)" end="(105, 57)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(105, 58)" end="(105, 66)">
                <AtomNode start="(105, 58)" end="(105, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(105, 60)" end="(105, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(105, 60)" end="(105, 61)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(105, 62)" end="(105, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(105, 64)" end="(105, 66)" leading="" trailing="" raw_val="β'" val="β'"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(105, 66)" end="(105, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(105, 68)" end="(105, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(105, 68)" end="(105, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(105, 69)" end="(105, 70)">
                <IdentNode start="(105, 69)" end="(105, 70)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(105, 71)" end="(105, 83)">
                <AtomNode start="(105, 71)" end="(105, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(105, 73)" end="(105, 83)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(105, 73)" end="(105, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(105, 75)" end="(105, 76)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(105, 77)" end="(105, 83)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(105, 77)" end="(105, 79)" leading="" trailing=" " raw_val="β'" val="β'"/>
                    <AtomNode start="(105, 80)" end="(105, 81)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(105, 82)" end="(105, 83)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(105, 83)" end="(105, 84)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(105, 85)" end="(106, 67)">
            <AtomNode start="(105, 85)" end="(105, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(106, 5)" end="(106, 67)" kind="«term_=_»">
              <OtherNode start="(106, 5)" end="(106, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(106, 5)" end="(106, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(106, 13)" end="(106, 28)">
                  <IdentNode start="(106, 13)" end="(106, 14)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(106, 15)" end="(106, 17)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <OtherNode start="(106, 18)" end="(106, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(106, 18)" end="(106, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(106, 19)" end="(106, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(106, 19)" end="(106, 25)" leading="" trailing=" " raw_val="l₂.map" val="l₂.map"/>
                      <NullNode start="(106, 26)" end="(106, 27)">
                        <IdentNode start="(106, 26)" end="(106, 27)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(106, 27)" end="(106, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(106, 29)" end="(106, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(106, 31)" end="(106, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(106, 31)" end="(106, 38)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(106, 39)" end="(106, 67)">
                  <OtherNode start="(106, 39)" end="(106, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(106, 39)" end="(106, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(106, 40)" end="(106, 60)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(106, 40)" end="(106, 43)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(106, 44)" end="(106, 60)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(106, 44)" end="(106, 47)">
                          <IdentNode start="(106, 44)" end="(106, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(106, 46)" end="(106, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(106, 48)" end="(106, 50)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(106, 51)" end="(106, 60)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(106, 51)" end="(106, 52)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(106, 53)" end="(106, 60)">
                            <IdentNode start="(106, 53)" end="(106, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(106, 55)" end="(106, 60)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(106, 55)" end="(106, 56)" leading="" trailing="" val="("/>
                              <OtherNode start="(106, 56)" end="(106, 59)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(106, 56)" end="(106, 57)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(106, 58)" end="(106, 59)">
                                  <IdentNode start="(106, 58)" end="(106, 59)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(106, 59)" end="(106, 60)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(106, 60)" end="(106, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(106, 62)" end="(106, 64)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(106, 65)" end="(106, 67)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(106, 68)" end="(107, 57)">
          <AtomNode start="(106, 68)" end="(106, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(106, 71)" end="(107, 57)">
            <AtomNode start="(106, 71)" end="(106, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(107, 3)" end="(107, 57)">
              <TacticTacticseq1IndentedNode start="(107, 3)" end="(107, 57)">
                <NullNode start="(107, 3)" end="(107, 57)">
                  <OtherNode start="(107, 3)" end="(107, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;β' : Type u_3&#10;γ : Type u_4&#10;l₁ : List α&#10;l₂ : List β&#10;f : β → β'&#10;g : α → β' → γ&#10;⊢ zipWith g l₁ (map f l₂) = zipWith (fun a b =&amp;gt; g a (f b)) l₁ l₂" state_after="no goals" tactic="induction l₁ generalizing l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(107, 3)" end="(107, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(107, 3)" end="(107, 31)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(107, 3)" end="(107, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(107, 13)" end="(107, 15)">
                          <OtherNode start="(107, 13)" end="(107, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(107, 13)" end="(107, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(107, 16)" end="(107, 31)">
                          <AtomNode start="(107, 16)" end="(107, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(107, 29)" end="(107, 31)">
                            <IdentNode start="(107, 29)" end="(107, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(107, 32)" end="(107, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(107, 36)" end="(107, 44)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(107, 36)" end="(107, 41)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(107, 42)" end="(107, 44)">
                          <OtherNode start="(107, 42)" end="(107, 44)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(107, 42)" end="(107, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(107, 45)" end="(107, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(107, 49)" end="(107, 57)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(107, 49)" end="(107, 57)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(109, 1)" end="(111, 57)" name="zipWith_foldr_eq_zip_foldr" full_name="List.zipWith_foldr_eq_zip_foldr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(109, 1)" end="(111, 57)" name="zipWith_foldr_eq_zip_foldr" full_name="List.zipWith_foldr_eq_zip_foldr" _is_private_decl="False">
        <AtomNode start="(109, 1)" end="(109, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(109, 9)" end="(109, 35)">
          <IdentNode start="(109, 9)" end="(109, 35)" leading="" trailing=" " raw_val="zipWith_foldr_eq_zip_foldr" val="zipWith_foldr_eq_zip_foldr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(109, 36)" end="(110, 83)">
          <NullNode start="(109, 36)" end="(109, 75)">
            <OtherNode start="(109, 36)" end="(109, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 36)" end="(109, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 37)" end="(109, 38)">
                <IdentNode start="(109, 37)" end="(109, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(109, 39)" end="(109, 50)">
                <AtomNode start="(109, 39)" end="(109, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 41)" end="(109, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(109, 41)" end="(109, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(109, 43)" end="(109, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(109, 45)" end="(109, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(109, 45)" end="(109, 46)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(109, 47)" end="(109, 48)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(109, 49)" end="(109, 50)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(109, 50)" end="(109, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(109, 52)" end="(109, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 52)" end="(109, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 53)" end="(109, 54)">
                <IdentNode start="(109, 53)" end="(109, 54)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(109, 55)" end="(109, 58)">
                <AtomNode start="(109, 55)" end="(109, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(109, 57)" end="(109, 58)" leading="" trailing="" raw_val="δ" val="δ"/>
              </NullNode>
              <AtomNode start="(109, 58)" end="(109, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(109, 60)" end="(109, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 60)" end="(109, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 61)" end="(109, 62)">
                <IdentNode start="(109, 61)" end="(109, 62)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(109, 63)" end="(109, 74)">
                <AtomNode start="(109, 63)" end="(109, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 65)" end="(109, 74)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(109, 65)" end="(109, 66)" leading="" trailing=" " raw_val="γ" val="γ"/>
                  <AtomNode start="(109, 67)" end="(109, 68)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(109, 69)" end="(109, 74)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(109, 69)" end="(109, 70)" leading="" trailing=" " raw_val="δ" val="δ"/>
                    <AtomNode start="(109, 71)" end="(109, 72)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(109, 73)" end="(109, 74)" leading="" trailing="" raw_val="δ" val="δ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(109, 74)" end="(109, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(109, 76)" end="(110, 83)">
            <AtomNode start="(109, 76)" end="(109, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(110, 5)" end="(110, 83)" kind="«term_=_»">
              <OtherNode start="(110, 5)" end="(110, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(110, 5)" end="(110, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(110, 5)" end="(110, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(110, 5)" end="(110, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(110, 6)" end="(110, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(110, 6)" end="(110, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(110, 14)" end="(110, 21)">
                        <IdentNode start="(110, 14)" end="(110, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(110, 16)" end="(110, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(110, 19)" end="(110, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(110, 21)" end="(110, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(110, 22)" end="(110, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(110, 23)" end="(110, 28)" leading="" trailing=" " raw_val="foldr" val="foldr" full_name="List.foldr" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(110, 29)" end="(110, 32)">
                  <IdentNode start="(110, 29)" end="(110, 30)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(110, 31)" end="(110, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(110, 33)" end="(110, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(110, 35)" end="(110, 83)" kind="Lean.Parser.Term.app">
                <OtherNode start="(110, 35)" end="(110, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(110, 35)" end="(110, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(110, 35)" end="(110, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(110, 36)" end="(110, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(110, 36)" end="(110, 39)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(110, 40)" end="(110, 45)">
                        <IdentNode start="(110, 40)" end="(110, 42)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(110, 43)" end="(110, 45)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(110, 45)" end="(110, 46)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(110, 46)" end="(110, 47)" leading="" trailing="" val="."/>
                  <IdentNode start="(110, 47)" end="(110, 52)" leading="" trailing=" " raw_val="foldr" val="foldr" full_name="List.foldr" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(110, 53)" end="(110, 83)">
                  <OtherNode start="(110, 53)" end="(110, 81)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(110, 53)" end="(110, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(110, 54)" end="(110, 80)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(110, 54)" end="(110, 57)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(110, 58)" end="(110, 80)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(110, 58)" end="(110, 61)">
                          <IdentNode start="(110, 58)" end="(110, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                          <IdentNode start="(110, 60)" end="(110, 61)" leading="" trailing=" " raw_val="r" val="r"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(110, 62)" end="(110, 64)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(110, 65)" end="(110, 80)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(110, 65)" end="(110, 66)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(110, 67)" end="(110, 80)">
                            <OtherNode start="(110, 67)" end="(110, 78)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(110, 67)" end="(110, 68)" leading="" trailing="" val="("/>
                              <OtherNode start="(110, 68)" end="(110, 77)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(110, 68)" end="(110, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(110, 70)" end="(110, 77)">
                                  <OtherNode start="(110, 70)" end="(110, 73)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(110, 70)" end="(110, 71)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(110, 71)" end="(110, 72)" leading="" trailing="" val="."/>
                                    <OtherNode start="(110, 72)" end="(110, 73)" kind="fieldIdx">
                                      <AtomNode start="(110, 72)" end="(110, 73)" leading="" trailing=" " val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <OtherNode start="(110, 74)" end="(110, 77)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(110, 74)" end="(110, 75)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(110, 75)" end="(110, 76)" leading="" trailing="" val="."/>
                                    <OtherNode start="(110, 76)" end="(110, 77)" kind="fieldIdx">
                                      <AtomNode start="(110, 76)" end="(110, 77)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(110, 77)" end="(110, 78)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(110, 79)" end="(110, 80)" leading="" trailing="" raw_val="r" val="r"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(110, 80)" end="(110, 81)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(110, 82)" end="(110, 83)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(110, 84)" end="(111, 57)">
          <AtomNode start="(110, 84)" end="(110, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(110, 87)" end="(111, 57)">
            <AtomNode start="(110, 87)" end="(110, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(111, 3)" end="(111, 57)">
              <TacticTacticseq1IndentedNode start="(111, 3)" end="(111, 57)">
                <NullNode start="(111, 3)" end="(111, 57)">
                  <OtherNode start="(111, 3)" end="(111, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;l₁ : List α&#10;l₂ : List β&#10;f : α → β → γ&#10;i : δ&#10;g : γ → δ → δ&#10;⊢ foldr g i (zipWith f l₁ l₂) = foldr (fun p r =&amp;gt; g (f p.fst p.snd) r) i (l₁.zip l₂)" state_after="no goals" tactic="induction l₁ generalizing l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(111, 3)" end="(111, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(111, 3)" end="(111, 31)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(111, 3)" end="(111, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(111, 13)" end="(111, 15)">
                          <OtherNode start="(111, 13)" end="(111, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(111, 13)" end="(111, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(111, 16)" end="(111, 31)">
                          <AtomNode start="(111, 16)" end="(111, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(111, 29)" end="(111, 31)">
                            <IdentNode start="(111, 29)" end="(111, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(111, 32)" end="(111, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(111, 36)" end="(111, 44)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(111, 36)" end="(111, 41)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(111, 42)" end="(111, 44)">
                          <OtherNode start="(111, 42)" end="(111, 44)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(111, 42)" end="(111, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(111, 45)" end="(111, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(111, 49)" end="(111, 57)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(111, 49)" end="(111, 57)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(113, 1)" end="(115, 59)" name="zipWith_foldl_eq_zip_foldl" full_name="List.zipWith_foldl_eq_zip_foldl">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(113, 1)" end="(115, 59)" name="zipWith_foldl_eq_zip_foldl" full_name="List.zipWith_foldl_eq_zip_foldl" _is_private_decl="False">
        <AtomNode start="(113, 1)" end="(113, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(113, 9)" end="(113, 35)">
          <IdentNode start="(113, 9)" end="(113, 35)" leading="" trailing=" " raw_val="zipWith_foldl_eq_zip_foldl" val="zipWith_foldl_eq_zip_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(113, 36)" end="(114, 83)">
          <NullNode start="(113, 36)" end="(113, 75)">
            <OtherNode start="(113, 36)" end="(113, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(113, 36)" end="(113, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(113, 37)" end="(113, 38)">
                <IdentNode start="(113, 37)" end="(113, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(113, 39)" end="(113, 50)">
                <AtomNode start="(113, 39)" end="(113, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(113, 41)" end="(113, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(113, 41)" end="(113, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(113, 43)" end="(113, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(113, 45)" end="(113, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(113, 45)" end="(113, 46)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(113, 47)" end="(113, 48)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(113, 49)" end="(113, 50)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(113, 50)" end="(113, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(113, 52)" end="(113, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(113, 52)" end="(113, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(113, 53)" end="(113, 54)">
                <IdentNode start="(113, 53)" end="(113, 54)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(113, 55)" end="(113, 58)">
                <AtomNode start="(113, 55)" end="(113, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(113, 57)" end="(113, 58)" leading="" trailing="" raw_val="δ" val="δ"/>
              </NullNode>
              <AtomNode start="(113, 58)" end="(113, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(113, 60)" end="(113, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(113, 60)" end="(113, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(113, 61)" end="(113, 62)">
                <IdentNode start="(113, 61)" end="(113, 62)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(113, 63)" end="(113, 74)">
                <AtomNode start="(113, 63)" end="(113, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(113, 65)" end="(113, 74)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(113, 65)" end="(113, 66)" leading="" trailing=" " raw_val="δ" val="δ"/>
                  <AtomNode start="(113, 67)" end="(113, 68)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(113, 69)" end="(113, 74)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(113, 69)" end="(113, 70)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    <AtomNode start="(113, 71)" end="(113, 72)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(113, 73)" end="(113, 74)" leading="" trailing="" raw_val="δ" val="δ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(113, 74)" end="(113, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(113, 76)" end="(114, 83)">
            <AtomNode start="(113, 76)" end="(113, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(114, 5)" end="(114, 83)" kind="«term_=_»">
              <OtherNode start="(114, 5)" end="(114, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(114, 5)" end="(114, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(114, 5)" end="(114, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(114, 5)" end="(114, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(114, 6)" end="(114, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(114, 6)" end="(114, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(114, 14)" end="(114, 21)">
                        <IdentNode start="(114, 14)" end="(114, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(114, 16)" end="(114, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(114, 19)" end="(114, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(114, 21)" end="(114, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(114, 22)" end="(114, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(114, 23)" end="(114, 28)" leading="" trailing=" " raw_val="foldl" val="foldl" full_name="List.foldl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(114, 29)" end="(114, 32)">
                  <IdentNode start="(114, 29)" end="(114, 30)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(114, 31)" end="(114, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(114, 33)" end="(114, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(114, 35)" end="(114, 83)" kind="Lean.Parser.Term.app">
                <OtherNode start="(114, 35)" end="(114, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(114, 35)" end="(114, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(114, 35)" end="(114, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(114, 36)" end="(114, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(114, 36)" end="(114, 39)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(114, 40)" end="(114, 45)">
                        <IdentNode start="(114, 40)" end="(114, 42)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(114, 43)" end="(114, 45)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(114, 45)" end="(114, 46)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(114, 46)" end="(114, 47)" leading="" trailing="" val="."/>
                  <IdentNode start="(114, 47)" end="(114, 52)" leading="" trailing=" " raw_val="foldl" val="foldl" full_name="List.foldl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(114, 53)" end="(114, 83)">
                  <OtherNode start="(114, 53)" end="(114, 81)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(114, 53)" end="(114, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(114, 54)" end="(114, 80)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(114, 54)" end="(114, 57)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(114, 58)" end="(114, 80)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(114, 58)" end="(114, 61)">
                          <IdentNode start="(114, 58)" end="(114, 59)" leading="" trailing=" " raw_val="r" val="r"/>
                          <IdentNode start="(114, 60)" end="(114, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(114, 62)" end="(114, 64)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(114, 65)" end="(114, 80)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(114, 65)" end="(114, 66)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(114, 67)" end="(114, 80)">
                            <IdentNode start="(114, 67)" end="(114, 68)" leading="" trailing=" " raw_val="r" val="r"/>
                            <OtherNode start="(114, 69)" end="(114, 80)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(114, 69)" end="(114, 70)" leading="" trailing="" val="("/>
                              <OtherNode start="(114, 70)" end="(114, 79)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(114, 70)" end="(114, 71)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(114, 72)" end="(114, 79)">
                                  <OtherNode start="(114, 72)" end="(114, 75)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(114, 72)" end="(114, 73)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(114, 73)" end="(114, 74)" leading="" trailing="" val="."/>
                                    <OtherNode start="(114, 74)" end="(114, 75)" kind="fieldIdx">
                                      <AtomNode start="(114, 74)" end="(114, 75)" leading="" trailing=" " val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <OtherNode start="(114, 76)" end="(114, 79)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(114, 76)" end="(114, 77)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(114, 77)" end="(114, 78)" leading="" trailing="" val="."/>
                                    <OtherNode start="(114, 78)" end="(114, 79)" kind="fieldIdx">
                                      <AtomNode start="(114, 78)" end="(114, 79)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(114, 79)" end="(114, 80)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(114, 80)" end="(114, 81)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(114, 82)" end="(114, 83)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(114, 84)" end="(115, 59)">
          <AtomNode start="(114, 84)" end="(114, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(114, 87)" end="(115, 59)">
            <AtomNode start="(114, 87)" end="(114, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(115, 3)" end="(115, 59)">
              <TacticTacticseq1IndentedNode start="(115, 3)" end="(115, 59)">
                <NullNode start="(115, 3)" end="(115, 59)">
                  <OtherNode start="(115, 3)" end="(115, 59)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;l₁ : List α&#10;l₂ : List β&#10;f : α → β → γ&#10;i : δ&#10;g : δ → γ → δ&#10;⊢ foldl g i (zipWith f l₁ l₂) = foldl (fun r p =&amp;gt; g r (f p.fst p.snd)) i (l₁.zip l₂)" state_after="no goals" tactic="induction l₁ generalizing i l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(115, 3)" end="(115, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(115, 3)" end="(115, 33)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(115, 3)" end="(115, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(115, 13)" end="(115, 15)">
                          <OtherNode start="(115, 13)" end="(115, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(115, 13)" end="(115, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(115, 16)" end="(115, 33)">
                          <AtomNode start="(115, 16)" end="(115, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(115, 29)" end="(115, 33)">
                            <IdentNode start="(115, 29)" end="(115, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(115, 31)" end="(115, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(115, 34)" end="(115, 37)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(115, 38)" end="(115, 46)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(115, 38)" end="(115, 43)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(115, 44)" end="(115, 46)">
                          <OtherNode start="(115, 44)" end="(115, 46)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(115, 44)" end="(115, 46)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(115, 47)" end="(115, 50)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(115, 51)" end="(115, 59)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(115, 51)" end="(115, 59)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(117, 1)" end="(119, 32)" name="zipWith_eq_nil_iff" full_name="List.zipWith_eq_nil_iff">
      <CommandDeclmodifiersNode start="(117, 1)" end="(117, 8)">
        <NullNode/>
        <NullNode start="(117, 1)" end="(117, 8)">
          <OtherNode start="(117, 1)" end="(117, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(117, 1)" end="(117, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(117, 3)" end="(117, 7)">
              <OtherNode start="(117, 3)" end="(117, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(117, 3)" end="(117, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(117, 3)" end="(117, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(117, 7)" end="(117, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(118, 1)" end="(119, 32)" name="zipWith_eq_nil_iff" full_name="List.zipWith_eq_nil_iff" _is_private_decl="False">
        <AtomNode start="(118, 1)" end="(118, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(118, 9)" end="(118, 27)">
          <IdentNode start="(118, 9)" end="(118, 27)" leading="" trailing=" " raw_val="zipWith_eq_nil_iff" val="zipWith_eq_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(118, 28)" end="(118, 91)">
          <NullNode start="(118, 28)" end="(118, 50)">
            <OtherNode start="(118, 28)" end="(118, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(118, 28)" end="(118, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(118, 29)" end="(118, 30)">
                <IdentNode start="(118, 29)" end="(118, 30)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(118, 31)" end="(118, 42)">
                <AtomNode start="(118, 31)" end="(118, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(118, 33)" end="(118, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(118, 33)" end="(118, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(118, 35)" end="(118, 36)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(118, 37)" end="(118, 42)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(118, 37)" end="(118, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(118, 39)" end="(118, 40)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(118, 41)" end="(118, 42)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(118, 42)" end="(118, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(118, 44)" end="(118, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(118, 44)" end="(118, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(118, 45)" end="(118, 49)">
                <IdentNode start="(118, 45)" end="(118, 46)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(118, 47)" end="(118, 49)" leading="" trailing="" raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(118, 49)" end="(118, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(118, 51)" end="(118, 91)">
            <AtomNode start="(118, 51)" end="(118, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(118, 53)" end="(118, 91)" kind="«term_↔_»">
              <OtherNode start="(118, 53)" end="(118, 72)" kind="«term_=_»">
                <OtherNode start="(118, 53)" end="(118, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(118, 53)" end="(118, 60)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(118, 61)" end="(118, 67)">
                    <IdentNode start="(118, 61)" end="(118, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(118, 63)" end="(118, 64)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(118, 65)" end="(118, 67)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(118, 68)" end="(118, 69)" leading="" trailing=" " val="="/>
                <OtherNode start="(118, 70)" end="(118, 72)" kind="«term[_]»">
                  <AtomNode start="(118, 70)" end="(118, 71)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(118, 71)" end="(118, 72)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(118, 73)" end="(118, 74)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(118, 75)" end="(118, 91)" kind="«term_∨_»">
                <OtherNode start="(118, 75)" end="(118, 81)" kind="«term_=_»">
                  <IdentNode start="(118, 75)" end="(118, 76)" leading="" trailing=" " raw_val="l" val="l"/>
                  <AtomNode start="(118, 77)" end="(118, 78)" leading="" trailing=" " val="="/>
                  <OtherNode start="(118, 79)" end="(118, 81)" kind="«term[_]»">
                    <AtomNode start="(118, 79)" end="(118, 80)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(118, 80)" end="(118, 81)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(118, 82)" end="(118, 83)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(118, 84)" end="(118, 91)" kind="«term_=_»">
                  <IdentNode start="(118, 84)" end="(118, 86)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  <AtomNode start="(118, 87)" end="(118, 88)" leading="" trailing=" " val="="/>
                  <OtherNode start="(118, 89)" end="(118, 91)" kind="«term[_]»">
                    <AtomNode start="(118, 89)" end="(118, 90)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(118, 90)" end="(118, 91)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(118, 92)" end="(119, 32)">
          <AtomNode start="(118, 92)" end="(118, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(118, 95)" end="(119, 32)">
            <AtomNode start="(118, 95)" end="(118, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(119, 3)" end="(119, 32)">
              <TacticTacticseq1IndentedNode start="(119, 3)" end="(119, 32)">
                <NullNode start="(119, 3)" end="(119, 32)">
                  <OtherNode start="(119, 3)" end="(119, 32)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l : List α&#10;l' : List β&#10;⊢ zipWith f l l' = [] ↔ l = [] ∨ l' = []" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; cases l' &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(119, 3)" end="(119, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(119, 3)" end="(119, 10)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(119, 3)" end="(119, 8)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(119, 9)" end="(119, 10)">
                          <OtherNode start="(119, 9)" end="(119, 10)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(119, 9)" end="(119, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(119, 11)" end="(119, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(119, 15)" end="(119, 23)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(119, 15)" end="(119, 20)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(119, 21)" end="(119, 23)">
                          <OtherNode start="(119, 21)" end="(119, 23)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(119, 21)" end="(119, 23)" leading="" trailing=" " raw_val="l'" val="l'"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(119, 24)" end="(119, 27)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(119, 28)" end="(119, 32)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(119, 28)" end="(119, 32)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(121, 1)" end="(128, 18)" name="map_zipWith" full_name="List.map_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(121, 1)" end="(128, 18)" name="map_zipWith" full_name="List.map_zipWith" _is_private_decl="False">
        <AtomNode start="(121, 1)" end="(121, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(121, 9)" end="(121, 20)">
          <IdentNode start="(121, 9)" end="(121, 20)" leading="" trailing=" " raw_val="map_zipWith" val="map_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(121, 21)" end="(122, 65)">
          <NullNode start="(121, 21)" end="(121, 88)">
            <OtherNode start="(121, 21)" end="(121, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 21)" end="(121, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 22)" end="(121, 23)">
                <IdentNode start="(121, 22)" end="(121, 23)" leading="" trailing=" " raw_val="δ" val="δ"/>
              </NullNode>
              <NullNode start="(121, 24)" end="(121, 32)">
                <AtomNode start="(121, 24)" end="(121, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 26)" end="(121, 32)" kind="Lean.Parser.Term.type">
                  <AtomNode start="(121, 26)" end="(121, 30)" leading="" trailing=" " val="Type"/>
                  <NullNode start="(121, 31)" end="(121, 32)">
                    <OtherNode start="(121, 31)" end="(121, 32)" kind="Lean.Parser.Level.hole">
                      <AtomNode start="(121, 31)" end="(121, 32)" leading="" trailing="" val="_"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 32)" end="(121, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(121, 34)" end="(121, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 34)" end="(121, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 35)" end="(121, 36)">
                <IdentNode start="(121, 35)" end="(121, 36)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(121, 37)" end="(121, 44)">
                <AtomNode start="(121, 37)" end="(121, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 39)" end="(121, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(121, 39)" end="(121, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(121, 41)" end="(121, 42)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(121, 43)" end="(121, 44)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 44)" end="(121, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(121, 46)" end="(121, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 46)" end="(121, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 47)" end="(121, 48)">
                <IdentNode start="(121, 47)" end="(121, 48)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(121, 49)" end="(121, 60)">
                <AtomNode start="(121, 49)" end="(121, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 51)" end="(121, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(121, 51)" end="(121, 52)" leading="" trailing=" " raw_val="γ" val="γ"/>
                  <AtomNode start="(121, 53)" end="(121, 54)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(121, 55)" end="(121, 60)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(121, 55)" end="(121, 56)" leading="" trailing=" " raw_val="δ" val="δ"/>
                    <AtomNode start="(121, 57)" end="(121, 58)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(121, 59)" end="(121, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 60)" end="(121, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(121, 62)" end="(121, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 62)" end="(121, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 63)" end="(121, 64)">
                <IdentNode start="(121, 63)" end="(121, 64)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(121, 65)" end="(121, 73)">
                <AtomNode start="(121, 65)" end="(121, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 67)" end="(121, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(121, 67)" end="(121, 71)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(121, 72)" end="(121, 73)">
                    <IdentNode start="(121, 72)" end="(121, 73)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 73)" end="(121, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(121, 75)" end="(121, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 75)" end="(121, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 76)" end="(121, 78)">
                <IdentNode start="(121, 76)" end="(121, 78)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(121, 79)" end="(121, 87)">
                <AtomNode start="(121, 79)" end="(121, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 81)" end="(121, 87)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(121, 81)" end="(121, 85)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(121, 86)" end="(121, 87)">
                    <IdentNode start="(121, 86)" end="(121, 87)" leading="" trailing="" raw_val="δ" val="δ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 87)" end="(121, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(121, 89)" end="(122, 65)">
            <AtomNode start="(121, 89)" end="(121, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(122, 5)" end="(122, 65)" kind="«term_=_»">
              <OtherNode start="(122, 5)" end="(122, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(122, 5)" end="(122, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(122, 9)" end="(122, 27)">
                  <IdentNode start="(122, 9)" end="(122, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(122, 11)" end="(122, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(122, 11)" end="(122, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(122, 12)" end="(122, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(122, 12)" end="(122, 19)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(122, 20)" end="(122, 26)">
                        <IdentNode start="(122, 20)" end="(122, 21)" leading="" trailing=" " raw_val="g" val="g"/>
                        <IdentNode start="(122, 22)" end="(122, 23)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(122, 24)" end="(122, 26)" leading="" trailing="" raw_val="l'" val="l'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(122, 26)" end="(122, 27)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(122, 28)" end="(122, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(122, 30)" end="(122, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(122, 30)" end="(122, 37)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(122, 38)" end="(122, 65)">
                  <OtherNode start="(122, 38)" end="(122, 60)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(122, 38)" end="(122, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(122, 39)" end="(122, 59)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(122, 39)" end="(122, 42)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(122, 43)" end="(122, 59)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(122, 43)" end="(122, 46)">
                          <IdentNode start="(122, 43)" end="(122, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(122, 45)" end="(122, 46)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(122, 47)" end="(122, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(122, 50)" end="(122, 59)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(122, 50)" end="(122, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(122, 52)" end="(122, 59)">
                            <OtherNode start="(122, 52)" end="(122, 59)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(122, 52)" end="(122, 53)" leading="" trailing="" val="("/>
                              <OtherNode start="(122, 53)" end="(122, 58)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(122, 53)" end="(122, 54)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(122, 55)" end="(122, 58)">
                                  <IdentNode start="(122, 55)" end="(122, 56)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(122, 57)" end="(122, 58)" leading="" trailing="" raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(122, 58)" end="(122, 59)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(122, 59)" end="(122, 60)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(122, 61)" end="(122, 62)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(122, 63)" end="(122, 65)" leading="" trailing=" " raw_val="l'" val="l'"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(122, 66)" end="(128, 18)">
          <AtomNode start="(122, 66)" end="(122, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(122, 69)" end="(128, 18)">
            <AtomNode start="(122, 69)" end="(122, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(123, 3)" end="(128, 18)">
              <TacticTacticseq1IndentedNode start="(123, 3)" end="(128, 18)">
                <NullNode start="(123, 3)" end="(128, 18)">
                  <OtherNode start="(123, 3)" end="(128, 18)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;l : List γ&#10;l' : List δ&#10;⊢ map f (zipWith g l l') = zipWith (fun x y =&amp;gt; f (g x y)) l l'" state_after="no goals" tactic="induction l generalizing l' with&#10;| nil =&amp;gt; simp&#10;| cons hd tl hl =&amp;gt;&#10;  · cases l'&#10;    · simp&#10;    · simp [hl]">
                    <AtomNode start="(123, 3)" end="(123, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(123, 13)" end="(123, 14)">
                      <OtherNode start="(123, 13)" end="(123, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(123, 13)" end="(123, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(123, 15)" end="(123, 30)">
                      <AtomNode start="(123, 15)" end="(123, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(123, 28)" end="(123, 30)">
                        <IdentNode start="(123, 28)" end="(123, 30)" leading="" trailing=" " raw_val="l'" val="l'"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(123, 31)" end="(128, 18)">
                      <OtherNode start="(123, 31)" end="(128, 18)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(123, 31)" end="(123, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(124, 3)" end="(128, 18)">
                          <OtherNode start="(124, 3)" end="(124, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(124, 3)" end="(124, 8)">
                              <OtherNode start="(124, 3)" end="(124, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(124, 3)" end="(124, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(124, 5)" end="(124, 8)">
                                  <NullNode/>
                                  <IdentNode start="(124, 5)" end="(124, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(124, 9)" end="(124, 16)">
                              <AtomNode start="(124, 9)" end="(124, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(124, 12)" end="(124, 16)">
                                <TacticTacticseq1IndentedNode start="(124, 12)" end="(124, 16)">
                                  <NullNode start="(124, 12)" end="(124, 16)">
                                    <OtherNode start="(124, 12)" end="(124, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;l' : List δ&#10;⊢ map f (zipWith g [] l') = zipWith (fun x y =&amp;gt; f (g x y)) [] l'" state_after="no goals" tactic="simp">
                                      <AtomNode start="(124, 12)" end="(124, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(125, 3)" end="(128, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(125, 3)" end="(125, 18)">
                              <OtherNode start="(125, 3)" end="(125, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(125, 3)" end="(125, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(125, 5)" end="(125, 9)">
                                  <NullNode/>
                                  <IdentNode start="(125, 5)" end="(125, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(125, 10)" end="(125, 18)">
                                  <IdentNode start="(125, 10)" end="(125, 12)" leading="" trailing=" " raw_val="hd" val="hd"/>
                                  <IdentNode start="(125, 13)" end="(125, 15)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                  <IdentNode start="(125, 16)" end="(125, 18)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(125, 19)" end="(128, 18)">
                              <AtomNode start="(125, 19)" end="(125, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(126, 5)" end="(128, 18)">
                                <TacticTacticseq1IndentedNode start="(126, 5)" end="(128, 18)">
                                  <NullNode start="(126, 5)" end="(128, 18)">
                                    <OtherNode start="(126, 5)" end="(128, 18)" kind="Lean.cdot" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;l' : List δ&#10;⊢ map f (zipWith g (hd :: tl) l') = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) l'" state_after="no goals" tactic="· cases l'&#10;  · simp&#10;  · simp [hl]">
                                      <OtherNode start="(126, 5)" end="(126, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(126, 5)" end="(126, 6)" kind="patternIgnore">
                                          <OtherNode start="(126, 5)" end="(126, 6)" kind="token.«· »">
                                            <AtomNode start="(126, 5)" end="(126, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(126, 7)" end="(128, 18)">
                                        <TacticTacticseq1IndentedNode start="(126, 7)" end="(128, 18)">
                                          <NullNode start="(126, 7)" end="(128, 18)">
                                            <OtherNode start="(126, 7)" end="(126, 15)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;l' : List δ&#10;⊢ map f (zipWith g (hd :: tl) l') = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) l'" state_after="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;⊢ map f (zipWith g (hd :: tl) []) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) []&#10;&#10;case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;head✝ : δ&#10;tail✝ : List δ&#10;⊢ map f (zipWith g (hd :: tl) (head✝ :: tail✝)) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) (head✝ :: tail✝)" tactic="cases l'">
                                              <AtomNode start="(126, 7)" end="(126, 12)" leading="" trailing=" " val="cases"/>
                                              <NullNode start="(126, 13)" end="(126, 15)">
                                                <OtherNode start="(126, 13)" end="(126, 15)" kind="Lean.Parser.Tactic.elimTarget">
                                                  <NullNode/>
                                                  <IdentNode start="(126, 13)" end="(126, 15)" leading="" trailing="&#10;      " raw_val="l'" val="l'"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(127, 7)" end="(127, 13)" kind="Lean.cdot" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;⊢ map f (zipWith g (hd :: tl) []) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) []&#10;&#10;case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;head✝ : δ&#10;tail✝ : List δ&#10;⊢ map f (zipWith g (hd :: tl) (head✝ :: tail✝)) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) (head✝ :: tail✝)" state_after="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;head✝ : δ&#10;tail✝ : List δ&#10;⊢ map f (zipWith g (hd :: tl) (head✝ :: tail✝)) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) (head✝ :: tail✝)" tactic="· simp">
                                              <OtherNode start="(127, 7)" end="(127, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(127, 7)" end="(127, 8)" kind="patternIgnore">
                                                  <OtherNode start="(127, 7)" end="(127, 8)" kind="token.«· »">
                                                    <AtomNode start="(127, 7)" end="(127, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(127, 9)" end="(127, 13)">
                                                <TacticTacticseq1IndentedNode start="(127, 9)" end="(127, 13)">
                                                  <NullNode start="(127, 9)" end="(127, 13)">
                                                    <OtherNode start="(127, 9)" end="(127, 13)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;⊢ map f (zipWith g (hd :: tl) []) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) []" state_after="no goals" tactic="simp">
                                                      <AtomNode start="(127, 9)" end="(127, 13)" leading="" trailing="&#10;      " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(128, 7)" end="(128, 18)" kind="Lean.cdot" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;head✝ : δ&#10;tail✝ : List δ&#10;⊢ map f (zipWith g (hd :: tl) (head✝ :: tail✝)) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) (head✝ :: tail✝)" state_after="no goals" tactic="· simp [hl]">
                                              <OtherNode start="(128, 7)" end="(128, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(128, 7)" end="(128, 8)" kind="patternIgnore">
                                                  <OtherNode start="(128, 7)" end="(128, 8)" kind="token.«· »">
                                                    <AtomNode start="(128, 7)" end="(128, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(128, 9)" end="(128, 18)">
                                                <TacticTacticseq1IndentedNode start="(128, 9)" end="(128, 18)">
                                                  <NullNode start="(128, 9)" end="(128, 18)">
                                                    <OtherNode start="(128, 9)" end="(128, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWith g tl l') = zipWith (fun x y =&amp;gt; f (g x y)) tl l'&#10;head✝ : δ&#10;tail✝ : List δ&#10;⊢ map f (zipWith g (hd :: tl) (head✝ :: tail✝)) = zipWith (fun x y =&amp;gt; f (g x y)) (hd :: tl) (head✝ :: tail✝)" state_after="no goals" tactic="simp [hl]">
                                                      <AtomNode start="(128, 9)" end="(128, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(128, 14)" end="(128, 18)">
                                                        <AtomNode start="(128, 14)" end="(128, 15)" leading="" trailing="" val="["/>
                                                        <NullNode start="(128, 15)" end="(128, 17)">
                                                          <OtherNode start="(128, 15)" end="(128, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(128, 15)" end="(128, 17)" leading="" trailing="" raw_val="hl" val="hl"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(128, 17)" end="(128, 18)" leading="" trailing="&#10;&#10;" val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(130, 1)" end="(138, 18)" name="take_zipWith" full_name="List.take_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(130, 1)" end="(138, 18)" name="take_zipWith" full_name="List.take_zipWith" _is_private_decl="False">
        <AtomNode start="(130, 1)" end="(130, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(130, 9)" end="(130, 21)">
          <IdentNode start="(130, 9)" end="(130, 21)" leading="" trailing=" " raw_val="take_zipWith" val="take_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(130, 22)" end="(130, 82)">
          <NullNode/>
          <TermTypespecNode start="(130, 22)" end="(130, 82)">
            <AtomNode start="(130, 22)" end="(130, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(130, 24)" end="(130, 82)" kind="«term_=_»">
              <OtherNode start="(130, 24)" end="(130, 47)" kind="Lean.Parser.Term.app">
                <OtherNode start="(130, 24)" end="(130, 45)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(130, 24)" end="(130, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(130, 24)" end="(130, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(130, 25)" end="(130, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(130, 25)" end="(130, 32)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(130, 33)" end="(130, 39)">
                        <IdentNode start="(130, 33)" end="(130, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(130, 35)" end="(130, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(130, 37)" end="(130, 39)" leading="" trailing="" raw_val="l'" val="l'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(130, 39)" end="(130, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(130, 40)" end="(130, 41)" leading="" trailing="" val="."/>
                  <IdentNode start="(130, 41)" end="(130, 45)" leading="" trailing=" " raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(130, 46)" end="(130, 47)">
                  <IdentNode start="(130, 46)" end="(130, 47)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(130, 48)" end="(130, 49)" leading="" trailing=" " val="="/>
              <OtherNode start="(130, 50)" end="(130, 82)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 50)" end="(130, 57)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(130, 58)" end="(130, 82)">
                  <IdentNode start="(130, 58)" end="(130, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(130, 60)" end="(130, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(130, 60)" end="(130, 61)" leading="" trailing="" val="("/>
                    <OtherNode start="(130, 61)" end="(130, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(130, 61)" end="(130, 67)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                      <NullNode start="(130, 68)" end="(130, 69)">
                        <IdentNode start="(130, 68)" end="(130, 69)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(130, 69)" end="(130, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(130, 71)" end="(130, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(130, 71)" end="(130, 72)" leading="" trailing="" val="("/>
                    <OtherNode start="(130, 72)" end="(130, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(130, 72)" end="(130, 79)" leading="" trailing=" " raw_val="l'.take" val="l'.take"/>
                      <NullNode start="(130, 80)" end="(130, 81)">
                        <IdentNode start="(130, 80)" end="(130, 81)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(130, 81)" end="(130, 82)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(130, 83)" end="(138, 18)">
          <AtomNode start="(130, 83)" end="(130, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(130, 86)" end="(138, 18)">
            <AtomNode start="(130, 86)" end="(130, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(131, 3)" end="(138, 18)">
              <TacticTacticseq1IndentedNode start="(131, 3)" end="(138, 18)">
                <NullNode start="(131, 3)" end="(138, 18)">
                  <OtherNode start="(131, 3)" end="(138, 18)" kind="Lean.Parser.Tactic.induction" state_before="α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;l : List α✝²&#10;l' : List α✝¹&#10;i : Nat&#10;⊢ take i (zipWith f l l') = zipWith f (take i l) (take i l')" state_after="no goals" tactic="induction l generalizing l' i with&#10;| nil =&amp;gt; simp&#10;| cons hd tl hl =&amp;gt;&#10;  cases l'&#10;  · simp&#10;  · cases i&#10;    · simp&#10;    · simp [hl]">
                    <AtomNode start="(131, 3)" end="(131, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(131, 13)" end="(131, 14)">
                      <OtherNode start="(131, 13)" end="(131, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(131, 13)" end="(131, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(131, 15)" end="(131, 32)">
                      <AtomNode start="(131, 15)" end="(131, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(131, 28)" end="(131, 32)">
                        <IdentNode start="(131, 28)" end="(131, 30)" leading="" trailing=" " raw_val="l'" val="l'"/>
                        <IdentNode start="(131, 31)" end="(131, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(131, 33)" end="(138, 18)">
                      <OtherNode start="(131, 33)" end="(138, 18)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(131, 33)" end="(131, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(132, 3)" end="(138, 18)">
                          <OtherNode start="(132, 3)" end="(132, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(132, 3)" end="(132, 8)">
                              <OtherNode start="(132, 3)" end="(132, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(132, 3)" end="(132, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(132, 5)" end="(132, 8)">
                                  <NullNode/>
                                  <IdentNode start="(132, 5)" end="(132, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(132, 9)" end="(132, 16)">
                              <AtomNode start="(132, 9)" end="(132, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(132, 12)" end="(132, 16)">
                                <TacticTacticseq1IndentedNode start="(132, 12)" end="(132, 16)">
                                  <NullNode start="(132, 12)" end="(132, 16)">
                                    <OtherNode start="(132, 12)" end="(132, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;l' : List α✝¹&#10;i : Nat&#10;⊢ take i (zipWith f [] l') = zipWith f (take i []) (take i l')" state_after="no goals" tactic="simp">
                                      <AtomNode start="(132, 12)" end="(132, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(133, 3)" end="(138, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(133, 3)" end="(133, 18)">
                              <OtherNode start="(133, 3)" end="(133, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(133, 3)" end="(133, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(133, 5)" end="(133, 9)">
                                  <NullNode/>
                                  <IdentNode start="(133, 5)" end="(133, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(133, 10)" end="(133, 18)">
                                  <IdentNode start="(133, 10)" end="(133, 12)" leading="" trailing=" " raw_val="hd" val="hd"/>
                                  <IdentNode start="(133, 13)" end="(133, 15)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                  <IdentNode start="(133, 16)" end="(133, 18)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(133, 19)" end="(138, 18)">
                              <AtomNode start="(133, 19)" end="(133, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(134, 5)" end="(138, 18)">
                                <TacticTacticseq1IndentedNode start="(134, 5)" end="(138, 18)">
                                  <NullNode start="(134, 5)" end="(138, 18)">
                                    <OtherNode start="(134, 5)" end="(134, 13)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;l' : List α✝¹&#10;i : Nat&#10;⊢ take i (zipWith f (hd :: tl) l') = zipWith f (take i (hd :: tl)) (take i l')" state_after="case cons.nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;⊢ take i (zipWith f (hd :: tl) []) = zipWith f (take i (hd :: tl)) (take i [])&#10;&#10;case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take i (hd :: tl)) (take i (head✝ :: tail✝))" tactic="cases l'">
                                      <AtomNode start="(134, 5)" end="(134, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(134, 11)" end="(134, 13)">
                                        <OtherNode start="(134, 11)" end="(134, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(134, 11)" end="(134, 13)" leading="" trailing="&#10;    " raw_val="l'" val="l'"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(135, 5)" end="(135, 11)" kind="Lean.cdot" state_before="case cons.nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;⊢ take i (zipWith f (hd :: tl) []) = zipWith f (take i (hd :: tl)) (take i [])&#10;&#10;case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take i (hd :: tl)) (take i (head✝ :: tail✝))" state_after="case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take i (hd :: tl)) (take i (head✝ :: tail✝))" tactic="· simp">
                                      <OtherNode start="(135, 5)" end="(135, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(135, 5)" end="(135, 6)" kind="patternIgnore">
                                          <OtherNode start="(135, 5)" end="(135, 6)" kind="token.«· »">
                                            <AtomNode start="(135, 5)" end="(135, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(135, 7)" end="(135, 11)">
                                        <TacticTacticseq1IndentedNode start="(135, 7)" end="(135, 11)">
                                          <NullNode start="(135, 7)" end="(135, 11)">
                                            <OtherNode start="(135, 7)" end="(135, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;⊢ take i (zipWith f (hd :: tl) []) = zipWith f (take i (hd :: tl)) (take i [])" state_after="no goals" tactic="simp">
                                              <AtomNode start="(135, 7)" end="(135, 11)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(136, 5)" end="(138, 18)" kind="Lean.cdot" state_before="case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take i (hd :: tl)) (take i (head✝ :: tail✝))" state_after="no goals" tactic="· cases i&#10;  · simp&#10;  · simp [hl]">
                                      <OtherNode start="(136, 5)" end="(136, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(136, 5)" end="(136, 6)" kind="patternIgnore">
                                          <OtherNode start="(136, 5)" end="(136, 6)" kind="token.«· »">
                                            <AtomNode start="(136, 5)" end="(136, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(136, 7)" end="(138, 18)">
                                        <TacticTacticseq1IndentedNode start="(136, 7)" end="(138, 18)">
                                          <NullNode start="(136, 7)" end="(138, 18)">
                                            <OtherNode start="(136, 7)" end="(136, 14)" kind="Lean.Parser.Tactic.cases" state_before="case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take i (hd :: tl)) (take i (head✝ :: tail✝))" state_after="case cons.cons.zero&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take 0 (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take 0 (hd :: tl)) (take 0 (head✝ :: tail✝))&#10;&#10;case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ take (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (take (n✝ + 1) (hd :: tl)) (take (n✝ + 1) (head✝ :: tail✝))" tactic="cases i">
                                              <AtomNode start="(136, 7)" end="(136, 12)" leading="" trailing=" " val="cases"/>
                                              <NullNode start="(136, 13)" end="(136, 14)">
                                                <OtherNode start="(136, 13)" end="(136, 14)" kind="Lean.Parser.Tactic.elimTarget">
                                                  <NullNode/>
                                                  <IdentNode start="(136, 13)" end="(136, 14)" leading="" trailing="&#10;      " raw_val="i" val="i"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(137, 7)" end="(137, 13)" kind="Lean.cdot" state_before="case cons.cons.zero&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take 0 (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take 0 (hd :: tl)) (take 0 (head✝ :: tail✝))&#10;&#10;case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ take (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (take (n✝ + 1) (hd :: tl)) (take (n✝ + 1) (head✝ :: tail✝))" state_after="case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ take (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (take (n✝ + 1) (hd :: tl)) (take (n✝ + 1) (head✝ :: tail✝))" tactic="· simp">
                                              <OtherNode start="(137, 7)" end="(137, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(137, 7)" end="(137, 8)" kind="patternIgnore">
                                                  <OtherNode start="(137, 7)" end="(137, 8)" kind="token.«· »">
                                                    <AtomNode start="(137, 7)" end="(137, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(137, 9)" end="(137, 13)">
                                                <TacticTacticseq1IndentedNode start="(137, 9)" end="(137, 13)">
                                                  <NullNode start="(137, 9)" end="(137, 13)">
                                                    <OtherNode start="(137, 9)" end="(137, 13)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.zero&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ take 0 (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (take 0 (hd :: tl)) (take 0 (head✝ :: tail✝))" state_after="no goals" tactic="simp">
                                                      <AtomNode start="(137, 9)" end="(137, 13)" leading="" trailing="&#10;      " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(138, 7)" end="(138, 18)" kind="Lean.cdot" state_before="case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ take (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (take (n✝ + 1) (hd :: tl)) (take (n✝ + 1) (head✝ :: tail✝))" state_after="no goals" tactic="· simp [hl]">
                                              <OtherNode start="(138, 7)" end="(138, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(138, 7)" end="(138, 8)" kind="patternIgnore">
                                                  <OtherNode start="(138, 7)" end="(138, 8)" kind="token.«· »">
                                                    <AtomNode start="(138, 7)" end="(138, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(138, 9)" end="(138, 18)">
                                                <TacticTacticseq1IndentedNode start="(138, 9)" end="(138, 18)">
                                                  <NullNode start="(138, 9)" end="(138, 18)">
                                                    <OtherNode start="(138, 9)" end="(138, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, take i (zipWith f tl l') = zipWith f (take i tl) (take i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ take (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (take (n✝ + 1) (hd :: tl)) (take (n✝ + 1) (head✝ :: tail✝))" state_after="no goals" tactic="simp [hl]">
                                                      <AtomNode start="(138, 9)" end="(138, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(138, 14)" end="(138, 18)">
                                                        <AtomNode start="(138, 14)" end="(138, 15)" leading="" trailing="" val="["/>
                                                        <NullNode start="(138, 15)" end="(138, 17)">
                                                          <OtherNode start="(138, 15)" end="(138, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(138, 15)" end="(138, 17)" leading="" trailing="" raw_val="hl" val="hl"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(138, 17)" end="(138, 18)" leading="" trailing="&#10;&#10;" val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(140, 1)" end="(148, 20)" name="drop_zipWith" full_name="List.drop_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(140, 1)" end="(148, 20)" name="drop_zipWith" full_name="List.drop_zipWith" _is_private_decl="False">
        <AtomNode start="(140, 1)" end="(140, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(140, 9)" end="(140, 21)">
          <IdentNode start="(140, 9)" end="(140, 21)" leading="" trailing=" " raw_val="drop_zipWith" val="drop_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(140, 22)" end="(140, 82)">
          <NullNode/>
          <TermTypespecNode start="(140, 22)" end="(140, 82)">
            <AtomNode start="(140, 22)" end="(140, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(140, 24)" end="(140, 82)" kind="«term_=_»">
              <OtherNode start="(140, 24)" end="(140, 47)" kind="Lean.Parser.Term.app">
                <OtherNode start="(140, 24)" end="(140, 45)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(140, 24)" end="(140, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(140, 24)" end="(140, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(140, 25)" end="(140, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(140, 25)" end="(140, 32)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(140, 33)" end="(140, 39)">
                        <IdentNode start="(140, 33)" end="(140, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(140, 35)" end="(140, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(140, 37)" end="(140, 39)" leading="" trailing="" raw_val="l'" val="l'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(140, 39)" end="(140, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(140, 40)" end="(140, 41)" leading="" trailing="" val="."/>
                  <IdentNode start="(140, 41)" end="(140, 45)" leading="" trailing=" " raw_val="drop" val="drop" full_name="List.drop" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(140, 46)" end="(140, 47)">
                  <IdentNode start="(140, 46)" end="(140, 47)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(140, 48)" end="(140, 49)" leading="" trailing=" " val="="/>
              <OtherNode start="(140, 50)" end="(140, 82)" kind="Lean.Parser.Term.app">
                <IdentNode start="(140, 50)" end="(140, 57)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(140, 58)" end="(140, 82)">
                  <IdentNode start="(140, 58)" end="(140, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(140, 60)" end="(140, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(140, 60)" end="(140, 61)" leading="" trailing="" val="("/>
                    <OtherNode start="(140, 61)" end="(140, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(140, 61)" end="(140, 67)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                      <NullNode start="(140, 68)" end="(140, 69)">
                        <IdentNode start="(140, 68)" end="(140, 69)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(140, 69)" end="(140, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(140, 71)" end="(140, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(140, 71)" end="(140, 72)" leading="" trailing="" val="("/>
                    <OtherNode start="(140, 72)" end="(140, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(140, 72)" end="(140, 79)" leading="" trailing=" " raw_val="l'.drop" val="l'.drop"/>
                      <NullNode start="(140, 80)" end="(140, 81)">
                        <IdentNode start="(140, 80)" end="(140, 81)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(140, 81)" end="(140, 82)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(140, 83)" end="(148, 20)">
          <AtomNode start="(140, 83)" end="(140, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(140, 86)" end="(148, 20)">
            <AtomNode start="(140, 86)" end="(140, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(141, 3)" end="(148, 20)">
              <TacticTacticseq1IndentedNode start="(141, 3)" end="(148, 20)">
                <NullNode start="(141, 3)" end="(148, 20)">
                  <OtherNode start="(141, 3)" end="(148, 20)" kind="Lean.Parser.Tactic.induction" state_before="α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;l : List α✝²&#10;l' : List α✝¹&#10;i : Nat&#10;⊢ drop i (zipWith f l l') = zipWith f (drop i l) (drop i l')" state_after="no goals" tactic="induction l generalizing l' i with&#10;| nil =&amp;gt; simp&#10;| cons hd tl hl =&amp;gt;&#10;  · cases l'&#10;    · simp&#10;    · cases i&#10;      · simp&#10;      · simp [hl]">
                    <AtomNode start="(141, 3)" end="(141, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(141, 13)" end="(141, 14)">
                      <OtherNode start="(141, 13)" end="(141, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(141, 13)" end="(141, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(141, 15)" end="(141, 32)">
                      <AtomNode start="(141, 15)" end="(141, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(141, 28)" end="(141, 32)">
                        <IdentNode start="(141, 28)" end="(141, 30)" leading="" trailing=" " raw_val="l'" val="l'"/>
                        <IdentNode start="(141, 31)" end="(141, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(141, 33)" end="(148, 20)">
                      <OtherNode start="(141, 33)" end="(148, 20)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(141, 33)" end="(141, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(142, 3)" end="(148, 20)">
                          <OtherNode start="(142, 3)" end="(142, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(142, 3)" end="(142, 8)">
                              <OtherNode start="(142, 3)" end="(142, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(142, 3)" end="(142, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(142, 5)" end="(142, 8)">
                                  <NullNode/>
                                  <IdentNode start="(142, 5)" end="(142, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(142, 9)" end="(142, 16)">
                              <AtomNode start="(142, 9)" end="(142, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(142, 12)" end="(142, 16)">
                                <TacticTacticseq1IndentedNode start="(142, 12)" end="(142, 16)">
                                  <NullNode start="(142, 12)" end="(142, 16)">
                                    <OtherNode start="(142, 12)" end="(142, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;l' : List α✝¹&#10;i : Nat&#10;⊢ drop i (zipWith f [] l') = zipWith f (drop i []) (drop i l')" state_after="no goals" tactic="simp">
                                      <AtomNode start="(142, 12)" end="(142, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(143, 3)" end="(148, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(143, 3)" end="(143, 18)">
                              <OtherNode start="(143, 3)" end="(143, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(143, 3)" end="(143, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(143, 5)" end="(143, 9)">
                                  <NullNode/>
                                  <IdentNode start="(143, 5)" end="(143, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(143, 10)" end="(143, 18)">
                                  <IdentNode start="(143, 10)" end="(143, 12)" leading="" trailing=" " raw_val="hd" val="hd"/>
                                  <IdentNode start="(143, 13)" end="(143, 15)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                  <IdentNode start="(143, 16)" end="(143, 18)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(143, 19)" end="(148, 20)">
                              <AtomNode start="(143, 19)" end="(143, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(144, 5)" end="(148, 20)">
                                <TacticTacticseq1IndentedNode start="(144, 5)" end="(148, 20)">
                                  <NullNode start="(144, 5)" end="(148, 20)">
                                    <OtherNode start="(144, 5)" end="(148, 20)" kind="Lean.cdot" state_before="case cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;l' : List α✝¹&#10;i : Nat&#10;⊢ drop i (zipWith f (hd :: tl) l') = zipWith f (drop i (hd :: tl)) (drop i l')" state_after="no goals" tactic="· cases l'&#10;  · simp&#10;  · cases i&#10;    · simp&#10;    · simp [hl]">
                                      <OtherNode start="(144, 5)" end="(144, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(144, 5)" end="(144, 6)" kind="patternIgnore">
                                          <OtherNode start="(144, 5)" end="(144, 6)" kind="token.«· »">
                                            <AtomNode start="(144, 5)" end="(144, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(144, 7)" end="(148, 20)">
                                        <TacticTacticseq1IndentedNode start="(144, 7)" end="(148, 20)">
                                          <NullNode start="(144, 7)" end="(148, 20)">
                                            <OtherNode start="(144, 7)" end="(144, 15)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;l' : List α✝¹&#10;i : Nat&#10;⊢ drop i (zipWith f (hd :: tl) l') = zipWith f (drop i (hd :: tl)) (drop i l')" state_after="case cons.nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;⊢ drop i (zipWith f (hd :: tl) []) = zipWith f (drop i (hd :: tl)) (drop i [])&#10;&#10;case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop i (hd :: tl)) (drop i (head✝ :: tail✝))" tactic="cases l'">
                                              <AtomNode start="(144, 7)" end="(144, 12)" leading="" trailing=" " val="cases"/>
                                              <NullNode start="(144, 13)" end="(144, 15)">
                                                <OtherNode start="(144, 13)" end="(144, 15)" kind="Lean.Parser.Tactic.elimTarget">
                                                  <NullNode/>
                                                  <IdentNode start="(144, 13)" end="(144, 15)" leading="" trailing="&#10;      " raw_val="l'" val="l'"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(145, 7)" end="(145, 13)" kind="Lean.cdot" state_before="case cons.nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;⊢ drop i (zipWith f (hd :: tl) []) = zipWith f (drop i (hd :: tl)) (drop i [])&#10;&#10;case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop i (hd :: tl)) (drop i (head✝ :: tail✝))" state_after="case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop i (hd :: tl)) (drop i (head✝ :: tail✝))" tactic="· simp">
                                              <OtherNode start="(145, 7)" end="(145, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(145, 7)" end="(145, 8)" kind="patternIgnore">
                                                  <OtherNode start="(145, 7)" end="(145, 8)" kind="token.«· »">
                                                    <AtomNode start="(145, 7)" end="(145, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(145, 9)" end="(145, 13)">
                                                <TacticTacticseq1IndentedNode start="(145, 9)" end="(145, 13)">
                                                  <NullNode start="(145, 9)" end="(145, 13)">
                                                    <OtherNode start="(145, 9)" end="(145, 13)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;⊢ drop i (zipWith f (hd :: tl) []) = zipWith f (drop i (hd :: tl)) (drop i [])" state_after="no goals" tactic="simp">
                                                      <AtomNode start="(145, 9)" end="(145, 13)" leading="" trailing="&#10;      " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(146, 7)" end="(148, 20)" kind="Lean.cdot" state_before="case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop i (hd :: tl)) (drop i (head✝ :: tail✝))" state_after="no goals" tactic="· cases i&#10;  · simp&#10;  · simp [hl]">
                                              <OtherNode start="(146, 7)" end="(146, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(146, 7)" end="(146, 8)" kind="patternIgnore">
                                                  <OtherNode start="(146, 7)" end="(146, 8)" kind="token.«· »">
                                                    <AtomNode start="(146, 7)" end="(146, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(146, 9)" end="(148, 20)">
                                                <TacticTacticseq1IndentedNode start="(146, 9)" end="(148, 20)">
                                                  <NullNode start="(146, 9)" end="(148, 20)">
                                                    <OtherNode start="(146, 9)" end="(146, 16)" kind="Lean.Parser.Tactic.cases" state_before="case cons.cons&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;i : Nat&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop i (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop i (hd :: tl)) (drop i (head✝ :: tail✝))" state_after="case cons.cons.zero&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop 0 (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop 0 (hd :: tl)) (drop 0 (head✝ :: tail✝))&#10;&#10;case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ drop (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (drop (n✝ + 1) (hd :: tl)) (drop (n✝ + 1) (head✝ :: tail✝))" tactic="cases i">
                                                      <AtomNode start="(146, 9)" end="(146, 14)" leading="" trailing=" " val="cases"/>
                                                      <NullNode start="(146, 15)" end="(146, 16)">
                                                        <OtherNode start="(146, 15)" end="(146, 16)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(146, 15)" end="(146, 16)" leading="" trailing="&#10;        " raw_val="i" val="i"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(147, 9)" end="(147, 15)" kind="Lean.cdot" state_before="case cons.cons.zero&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop 0 (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop 0 (hd :: tl)) (drop 0 (head✝ :: tail✝))&#10;&#10;case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ drop (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (drop (n✝ + 1) (hd :: tl)) (drop (n✝ + 1) (head✝ :: tail✝))" state_after="case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ drop (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (drop (n✝ + 1) (hd :: tl)) (drop (n✝ + 1) (head✝ :: tail✝))" tactic="· simp">
                                                      <OtherNode start="(147, 9)" end="(147, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(147, 9)" end="(147, 10)" kind="patternIgnore">
                                                          <OtherNode start="(147, 9)" end="(147, 10)" kind="token.«· »">
                                                            <AtomNode start="(147, 9)" end="(147, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(147, 11)" end="(147, 15)">
                                                        <TacticTacticseq1IndentedNode start="(147, 11)" end="(147, 15)">
                                                          <NullNode start="(147, 11)" end="(147, 15)">
                                                            <OtherNode start="(147, 11)" end="(147, 15)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.zero&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;⊢ drop 0 (zipWith f (hd :: tl) (head✝ :: tail✝)) = zipWith f (drop 0 (hd :: tl)) (drop 0 (head✝ :: tail✝))" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(147, 11)" end="(147, 15)" leading="" trailing="&#10;        " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(148, 9)" end="(148, 20)" kind="Lean.cdot" state_before="case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ drop (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (drop (n✝ + 1) (hd :: tl)) (drop (n✝ + 1) (head✝ :: tail✝))" state_after="no goals" tactic="· simp [hl]">
                                                      <OtherNode start="(148, 9)" end="(148, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(148, 9)" end="(148, 10)" kind="patternIgnore">
                                                          <OtherNode start="(148, 9)" end="(148, 10)" kind="token.«· »">
                                                            <AtomNode start="(148, 9)" end="(148, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(148, 11)" end="(148, 20)">
                                                        <TacticTacticseq1IndentedNode start="(148, 11)" end="(148, 20)">
                                                          <NullNode start="(148, 11)" end="(148, 20)">
                                                            <OtherNode start="(148, 11)" end="(148, 20)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.succ&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;hd : α✝²&#10;tl : List α✝²&#10;hl : ∀ {l' : List α✝¹} {i : Nat}, drop i (zipWith f tl l') = zipWith f (drop i tl) (drop i l')&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;n✝ : Nat&#10;⊢ drop (n✝ + 1) (zipWith f (hd :: tl) (head✝ :: tail✝)) =&#10;    zipWith f (drop (n✝ + 1) (hd :: tl)) (drop (n✝ + 1) (head✝ :: tail✝))" state_after="no goals" tactic="simp [hl]">
                                                            <AtomNode start="(148, 11)" end="(148, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(148, 16)" end="(148, 20)">
                                                            <AtomNode start="(148, 16)" end="(148, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(148, 17)" end="(148, 19)">
                                                            <OtherNode start="(148, 17)" end="(148, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(148, 17)" end="(148, 19)" leading="" trailing="" raw_val="hl" val="hl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(148, 19)" end="(148, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(150, 1)" end="(152, 39)" name="tail_zipWith" full_name="List.tail_zipWith">
      <CommandDeclmodifiersNode start="(150, 1)" end="(150, 8)">
        <NullNode/>
        <NullNode start="(150, 1)" end="(150, 8)">
          <OtherNode start="(150, 1)" end="(150, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(150, 1)" end="(150, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(150, 3)" end="(150, 7)">
              <OtherNode start="(150, 3)" end="(150, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(150, 3)" end="(150, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(150, 3)" end="(150, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(150, 7)" end="(150, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(151, 1)" end="(152, 39)" name="tail_zipWith" full_name="List.tail_zipWith" _is_private_decl="False">
        <AtomNode start="(151, 1)" end="(151, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(151, 9)" end="(151, 21)">
          <IdentNode start="(151, 9)" end="(151, 21)" leading="" trailing=" " raw_val="tail_zipWith" val="tail_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(151, 22)" end="(151, 72)">
          <NullNode/>
          <TermTypespecNode start="(151, 22)" end="(151, 72)">
            <AtomNode start="(151, 22)" end="(151, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(151, 24)" end="(151, 72)" kind="«term_=_»">
              <OtherNode start="(151, 24)" end="(151, 45)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(151, 24)" end="(151, 40)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(151, 24)" end="(151, 25)" leading="" trailing="" val="("/>
                  <OtherNode start="(151, 25)" end="(151, 39)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(151, 25)" end="(151, 32)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(151, 33)" end="(151, 39)">
                      <IdentNode start="(151, 33)" end="(151, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(151, 35)" end="(151, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(151, 37)" end="(151, 39)" leading="" trailing="" raw_val="l'" val="l'"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(151, 39)" end="(151, 40)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(151, 40)" end="(151, 41)" leading="" trailing="" val="."/>
                <IdentNode start="(151, 41)" end="(151, 45)" leading="" trailing=" " raw_val="tail" val="tail" full_name="List.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(151, 46)" end="(151, 47)" leading="" trailing=" " val="="/>
              <OtherNode start="(151, 48)" end="(151, 72)" kind="Lean.Parser.Term.app">
                <IdentNode start="(151, 48)" end="(151, 55)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(151, 56)" end="(151, 72)">
                  <IdentNode start="(151, 56)" end="(151, 57)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(151, 58)" end="(151, 64)" leading="" trailing=" " raw_val="l.tail" val="l.tail"/>
                  <IdentNode start="(151, 65)" end="(151, 72)" leading="" trailing=" " raw_val="l'.tail" val="l'.tail"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(151, 73)" end="(152, 39)">
          <AtomNode start="(151, 73)" end="(151, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(151, 76)" end="(152, 39)">
            <AtomNode start="(151, 76)" end="(151, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(152, 3)" end="(152, 39)">
              <TacticTacticseq1IndentedNode start="(152, 3)" end="(152, 39)">
                <NullNode start="(152, 3)" end="(152, 39)">
                  <OtherNode start="(152, 3)" end="(152, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;l : List α✝²&#10;l' : List α✝¹&#10;⊢ (zipWith f l l').tail = zipWith f l.tail l'.tail" state_after="α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;l : List α✝²&#10;l' : List α✝¹&#10;⊢ drop 1 (zipWith f l l') = zipWith f l.tail l'.tail" tactic="rw [← drop_one]">
                    <AtomNode start="(152, 3)" end="(152, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(152, 6)" end="(152, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(152, 6)" end="(152, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(152, 7)" end="(152, 17)">
                        <OtherNode start="(152, 7)" end="(152, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(152, 7)" end="(152, 8)">
                            <OtherNode start="(152, 7)" end="(152, 8)" kind="patternIgnore">
                              <OtherNode start="(152, 7)" end="(152, 8)" kind="token.«← »">
                                <AtomNode start="(152, 7)" end="(152, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(152, 9)" end="(152, 17)" leading="" trailing="" raw_val="drop_one" val="drop_one" full_name="List.drop_one" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(152, 17)" end="(152, 18)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(152, 18)" end="(152, 19)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(152, 20)" end="(152, 39)" kind="Lean.Parser.Tactic.simp" state_before="α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;l : List α✝²&#10;l' : List α✝¹&#10;⊢ drop 1 (zipWith f l l') = zipWith f l.tail l'.tail" state_after="no goals" tactic="simp [drop_zipWith]">
                    <AtomNode start="(152, 20)" end="(152, 24)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(152, 25)" end="(152, 39)">
                      <AtomNode start="(152, 25)" end="(152, 26)" leading="" trailing="" val="["/>
                      <NullNode start="(152, 26)" end="(152, 38)">
                        <OtherNode start="(152, 26)" end="(152, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(152, 26)" end="(152, 38)" leading="" trailing="" raw_val="drop_zipWith" val="drop_zipWith" full_name="List.drop_zipWith" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(140, 9)" def_end="(140, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(152, 38)" end="(152, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(154, 1)" end="(166, 18)" name="zipWith_append" full_name="List.zipWith_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(154, 1)" end="(166, 18)" name="zipWith_append" full_name="List.zipWith_append" _is_private_decl="False">
        <AtomNode start="(154, 1)" end="(154, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(154, 9)" end="(154, 23)">
          <IdentNode start="(154, 9)" end="(154, 23)" leading="" trailing=" " raw_val="zipWith_append" val="zipWith_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(154, 24)" end="(156, 77)">
          <NullNode start="(154, 24)" end="(155, 32)">
            <OtherNode start="(154, 24)" end="(154, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(154, 24)" end="(154, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(154, 25)" end="(154, 26)">
                <IdentNode start="(154, 25)" end="(154, 26)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(154, 27)" end="(154, 38)">
                <AtomNode start="(154, 27)" end="(154, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(154, 29)" end="(154, 38)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(154, 29)" end="(154, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(154, 31)" end="(154, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(154, 33)" end="(154, 38)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(154, 33)" end="(154, 34)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(154, 35)" end="(154, 36)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(154, 37)" end="(154, 38)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(154, 38)" end="(154, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(154, 40)" end="(154, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(154, 40)" end="(154, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(154, 41)" end="(154, 47)">
                <IdentNode start="(154, 41)" end="(154, 43)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(154, 44)" end="(154, 47)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
              </NullNode>
              <NullNode start="(154, 48)" end="(154, 56)">
                <AtomNode start="(154, 48)" end="(154, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(154, 50)" end="(154, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(154, 50)" end="(154, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(154, 55)" end="(154, 56)">
                    <IdentNode start="(154, 55)" end="(154, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(154, 56)" end="(154, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(154, 58)" end="(154, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(154, 58)" end="(154, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(154, 59)" end="(154, 65)">
                <IdentNode start="(154, 59)" end="(154, 61)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <IdentNode start="(154, 62)" end="(154, 65)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
              </NullNode>
              <NullNode start="(154, 66)" end="(154, 74)">
                <AtomNode start="(154, 66)" end="(154, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(154, 68)" end="(154, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(154, 68)" end="(154, 72)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(154, 73)" end="(154, 74)">
                    <IdentNode start="(154, 73)" end="(154, 74)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(154, 74)" end="(154, 75)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(155, 5)" end="(155, 32)">
              <AtomNode start="(155, 5)" end="(155, 6)" leading="" trailing="" val="("/>
              <NullNode start="(155, 6)" end="(155, 7)">
                <IdentNode start="(155, 6)" end="(155, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(155, 8)" end="(155, 31)">
                <AtomNode start="(155, 8)" end="(155, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(155, 10)" end="(155, 31)" kind="«term_=_»">
                  <IdentNode start="(155, 10)" end="(155, 19)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                  <AtomNode start="(155, 20)" end="(155, 21)" leading="" trailing=" " val="="/>
                  <IdentNode start="(155, 22)" end="(155, 31)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(155, 31)" end="(155, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(155, 33)" end="(156, 77)">
            <AtomNode start="(155, 33)" end="(155, 34)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(156, 5)" end="(156, 77)" kind="«term_=_»">
              <OtherNode start="(156, 5)" end="(156, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(156, 5)" end="(156, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(156, 13)" end="(156, 38)">
                  <IdentNode start="(156, 13)" end="(156, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(156, 15)" end="(156, 26)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(156, 15)" end="(156, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(156, 16)" end="(156, 25)" kind="«term_++_»">
                      <IdentNode start="(156, 16)" end="(156, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(156, 19)" end="(156, 21)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(156, 22)" end="(156, 25)" leading="" trailing="" raw_val="l₁'" val="l₁'"/>
                    </OtherNode>
                    <AtomNode start="(156, 25)" end="(156, 26)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(156, 27)" end="(156, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(156, 27)" end="(156, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(156, 28)" end="(156, 37)" kind="«term_++_»">
                      <IdentNode start="(156, 28)" end="(156, 30)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      <AtomNode start="(156, 31)" end="(156, 33)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(156, 34)" end="(156, 37)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                    </OtherNode>
                    <AtomNode start="(156, 37)" end="(156, 38)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(156, 39)" end="(156, 40)" leading="" trailing=" " val="="/>
              <OtherNode start="(156, 41)" end="(156, 77)" kind="«term_++_»">
                <OtherNode start="(156, 41)" end="(156, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(156, 41)" end="(156, 48)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(156, 49)" end="(156, 56)">
                    <IdentNode start="(156, 49)" end="(156, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(156, 51)" end="(156, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(156, 54)" end="(156, 56)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(156, 57)" end="(156, 59)" leading="" trailing=" " val="++"/>
                <OtherNode start="(156, 60)" end="(156, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(156, 60)" end="(156, 67)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(156, 68)" end="(156, 77)">
                    <IdentNode start="(156, 68)" end="(156, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(156, 70)" end="(156, 73)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                    <IdentNode start="(156, 74)" end="(156, 77)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(156, 78)" end="(166, 18)">
          <AtomNode start="(156, 78)" end="(156, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(156, 81)" end="(166, 18)">
            <AtomNode start="(156, 81)" end="(156, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(157, 3)" end="(166, 18)">
              <TacticTacticseq1IndentedNode start="(157, 3)" end="(166, 18)">
                <NullNode start="(157, 3)" end="(166, 18)">
                  <OtherNode start="(157, 3)" end="(166, 18)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁ l₁' : List α&#10;l₂ l₂' : List β&#10;h : l₁.length = l₂.length&#10;⊢ zipWith f (l₁ ++ l₁') (l₂ ++ l₂') = zipWith f l₁ l₂ ++ zipWith f l₁' l₂'" state_after="no goals" tactic="induction l₁ generalizing l₂ with&#10;| nil =&amp;gt;&#10;  have : l₂ = [] := eq_nil_of_length_eq_zero (by simpa using h.symm)&#10;  simp [this]&#10;| cons hl tl ih =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp at h&#10;  | cons _ _ =&amp;gt;&#10;    simp only [length_cons, Nat.succ.injEq] at h&#10;    simp [ih h]">
                    <AtomNode start="(157, 3)" end="(157, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(157, 13)" end="(157, 15)">
                      <OtherNode start="(157, 13)" end="(157, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(157, 13)" end="(157, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(157, 16)" end="(157, 31)">
                      <AtomNode start="(157, 16)" end="(157, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(157, 29)" end="(157, 31)">
                        <IdentNode start="(157, 29)" end="(157, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(157, 32)" end="(166, 18)">
                      <OtherNode start="(157, 32)" end="(166, 18)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(157, 32)" end="(157, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(158, 3)" end="(166, 18)">
                          <OtherNode start="(158, 3)" end="(160, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(158, 3)" end="(158, 8)">
                              <OtherNode start="(158, 3)" end="(158, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(158, 3)" end="(158, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(158, 5)" end="(158, 8)">
                                  <NullNode/>
                                  <IdentNode start="(158, 5)" end="(158, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(158, 9)" end="(160, 16)">
                              <AtomNode start="(158, 9)" end="(158, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(159, 5)" end="(160, 16)">
                                <TacticTacticseq1IndentedNode start="(159, 5)" end="(160, 16)">
                                  <NullNode start="(159, 5)" end="(160, 16)">
                                    <OtherNode start="(159, 5)" end="(159, 71)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' l₂ : List β&#10;h : [].length = l₂.length&#10;⊢ zipWith f ([] ++ l₁') (l₂ ++ l₂') = zipWith f [] l₂ ++ zipWith f l₁' l₂'" state_after="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' l₂ : List β&#10;h : [].length = l₂.length&#10;this : l₂ = []&#10;⊢ zipWith f ([] ++ l₁') (l₂ ++ l₂') = zipWith f [] l₂ ++ zipWith f l₁' l₂'" tactic="have : l₂ = [] := eq_nil_of_length_eq_zero (by simpa using h.symm)">
                                      <AtomNode start="(159, 5)" end="(159, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(159, 10)" end="(159, 71)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(159, 10)" end="(159, 71)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(159, 10)" end="(159, 10)" kind="Lean.Parser.Term.haveId">
                                            <OtherNode start="(159, 10)" end="(159, 10)" kind="hygieneInfo">
                                              <IdentNode start="(159, 10)" end="(159, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(159, 10)" end="(159, 19)">
                                            <TermTypespecNode start="(159, 10)" end="(159, 19)">
                                              <AtomNode start="(159, 10)" end="(159, 11)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(159, 12)" end="(159, 19)" kind="«term_=_»">
                                                <IdentNode start="(159, 12)" end="(159, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                <AtomNode start="(159, 15)" end="(159, 16)" leading="" trailing=" " val="="/>
                                                <OtherNode start="(159, 17)" end="(159, 19)" kind="«term[_]»">
                                                  <AtomNode start="(159, 17)" end="(159, 18)" leading="" trailing="" val="["/>
                                                  <NullNode/>
                                                  <AtomNode start="(159, 18)" end="(159, 19)" leading="" trailing=" " val="]"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(159, 20)" end="(159, 22)" leading="" trailing=" " val=":="/>
                                          <OtherNode start="(159, 23)" end="(159, 71)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(159, 23)" end="(159, 47)" leading="" trailing=" " raw_val="eq_nil_of_length_eq_zero" val="eq_nil_of_length_eq_zero" full_name="List.eq_nil_of_length_eq_zero" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                            <NullNode start="(159, 48)" end="(159, 71)">
                                              <OtherNode start="(159, 48)" end="(159, 71)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(159, 48)" end="(159, 49)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(159, 49)" end="(159, 70)">
                                                  <AtomNode start="(159, 49)" end="(159, 51)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(159, 52)" end="(159, 70)">
                                                    <TacticTacticseq1IndentedNode start="(159, 52)" end="(159, 70)">
                                                      <NullNode start="(159, 52)" end="(159, 70)">
                                                        <OtherNode start="(159, 52)" end="(159, 70)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' l₂ : List β&#10;h : [].length = l₂.length&#10;⊢ l₂.length = 0" state_after="no goals" tactic="simpa using h.symm">
                                                          <AtomNode start="(159, 52)" end="(159, 57)" leading="" trailing=" " val="simpa"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <OtherNode start="(159, 58)" end="(159, 70)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(159, 58)" end="(159, 70)">
                                                            <AtomNode start="(159, 58)" end="(159, 63)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(159, 64)" end="(159, 70)" leading="" trailing="" raw_val="h.symm" val="h.symm"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(159, 70)" end="(159, 71)" leading="" trailing="&#10;    " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(160, 5)" end="(160, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' l₂ : List β&#10;h : [].length = l₂.length&#10;this : l₂ = []&#10;⊢ zipWith f ([] ++ l₁') (l₂ ++ l₂') = zipWith f [] l₂ ++ zipWith f l₁' l₂'" state_after="no goals" tactic="simp [this]">
                                      <AtomNode start="(160, 5)" end="(160, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(160, 10)" end="(160, 16)">
                                        <AtomNode start="(160, 10)" end="(160, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(160, 11)" end="(160, 15)">
                                          <OtherNode start="(160, 11)" end="(160, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(160, 11)" end="(160, 15)" leading="" trailing="" raw_val="this" val="this"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(160, 15)" end="(160, 16)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(161, 3)" end="(166, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(161, 3)" end="(161, 18)">
                              <OtherNode start="(161, 3)" end="(161, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(161, 3)" end="(161, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(161, 5)" end="(161, 9)">
                                  <NullNode/>
                                  <IdentNode start="(161, 5)" end="(161, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(161, 10)" end="(161, 18)">
                                  <IdentNode start="(161, 10)" end="(161, 12)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                  <IdentNode start="(161, 13)" end="(161, 15)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                  <IdentNode start="(161, 16)" end="(161, 18)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(161, 19)" end="(166, 18)">
                              <AtomNode start="(161, 19)" end="(161, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(162, 5)" end="(166, 18)">
                                <TacticTacticseq1IndentedNode start="(162, 5)" end="(166, 18)">
                                  <NullNode start="(162, 5)" end="(166, 18)">
                                    <OtherNode start="(162, 5)" end="(166, 18)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' : List β&#10;hl : α&#10;tl : List α&#10;ih : ∀ {l₂ : List β}, tl.length = l₂.length → zipWith f (tl ++ l₁') (l₂ ++ l₂') = zipWith f tl l₂ ++ zipWith f l₁' l₂'&#10;l₂ : List β&#10;h : (hl :: tl).length = l₂.length&#10;⊢ zipWith f (hl :: tl ++ l₁') (l₂ ++ l₂') = zipWith f (hl :: tl) l₂ ++ zipWith f l₁' l₂'" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp at h&#10;| cons _ _ =&amp;gt;&#10;  simp only [length_cons, Nat.succ.injEq] at h&#10;  simp [ih h]">
                                      <AtomNode start="(162, 5)" end="(162, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(162, 11)" end="(162, 13)">
                                        <OtherNode start="(162, 11)" end="(162, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(162, 11)" end="(162, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(162, 14)" end="(166, 18)">
                                        <OtherNode start="(162, 14)" end="(166, 18)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(162, 14)" end="(162, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(163, 5)" end="(166, 18)">
                                            <OtherNode start="(163, 5)" end="(163, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(163, 5)" end="(163, 10)">
                                                <OtherNode start="(163, 5)" end="(163, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(163, 5)" end="(163, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(163, 7)" end="(163, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(163, 7)" end="(163, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(163, 11)" end="(163, 23)">
                                                <AtomNode start="(163, 11)" end="(163, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(163, 14)" end="(163, 23)">
                                                  <TacticTacticseq1IndentedNode start="(163, 14)" end="(163, 23)">
                                                    <NullNode start="(163, 14)" end="(163, 23)">
                                                      <OtherNode start="(163, 14)" end="(163, 23)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' : List β&#10;hl : α&#10;tl : List α&#10;ih : ∀ {l₂ : List β}, tl.length = l₂.length → zipWith f (tl ++ l₁') (l₂ ++ l₂') = zipWith f tl l₂ ++ zipWith f l₁' l₂'&#10;h : (hl :: tl).length = [].length&#10;⊢ zipWith f (hl :: tl ++ l₁') ([] ++ l₂') = zipWith f (hl :: tl) [] ++ zipWith f l₁' l₂'" state_after="no goals" tactic="simp at h">
                                                        <AtomNode start="(163, 14)" end="(163, 18)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(163, 19)" end="(163, 23)">
                                                          <OtherNode start="(163, 19)" end="(163, 23)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(163, 19)" end="(163, 21)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(163, 22)" end="(163, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(163, 22)" end="(163, 23)">
                                                            <IdentNode start="(163, 22)" end="(163, 23)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(164, 5)" end="(166, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(164, 5)" end="(164, 15)">
                                                <OtherNode start="(164, 5)" end="(164, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(164, 5)" end="(164, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(164, 7)" end="(164, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(164, 7)" end="(164, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(164, 12)" end="(164, 15)">
                                                    <TermHoleNode start="(164, 12)" end="(164, 13)">
                                                      <AtomNode start="(164, 12)" end="(164, 13)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <TermHoleNode start="(164, 14)" end="(164, 15)">
                                                      <AtomNode start="(164, 14)" end="(164, 15)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(164, 16)" end="(166, 18)">
                                                <AtomNode start="(164, 16)" end="(164, 18)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(165, 7)" end="(166, 18)">
                                                  <TacticTacticseq1IndentedNode start="(165, 7)" end="(166, 18)">
                                                    <NullNode start="(165, 7)" end="(166, 18)">
                                                      <OtherNode start="(165, 7)" end="(165, 51)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' : List β&#10;hl : α&#10;tl : List α&#10;ih : ∀ {l₂ : List β}, tl.length = l₂.length → zipWith f (tl ++ l₁') (l₂ ++ l₂') = zipWith f tl l₂ ++ zipWith f l₁' l₂'&#10;head✝ : β&#10;tail✝ : List β&#10;h : (hl :: tl).length = (head✝ :: tail✝).length&#10;⊢ zipWith f (hl :: tl ++ l₁') (head✝ :: tail✝ ++ l₂') = zipWith f (hl :: tl) (head✝ :: tail✝) ++ zipWith f l₁' l₂'" state_after="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' : List β&#10;hl : α&#10;tl : List α&#10;ih : ∀ {l₂ : List β}, tl.length = l₂.length → zipWith f (tl ++ l₁') (l₂ ++ l₂') = zipWith f tl l₂ ++ zipWith f l₁' l₂'&#10;head✝ : β&#10;tail✝ : List β&#10;h : tl.length = tail✝.length&#10;⊢ zipWith f (hl :: tl ++ l₁') (head✝ :: tail✝ ++ l₂') = zipWith f (hl :: tl) (head✝ :: tail✝) ++ zipWith f l₁' l₂'" tactic="simp only [length_cons, Nat.succ.injEq] at h">
                                                        <AtomNode start="(165, 7)" end="(165, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(165, 12)" end="(165, 16)">
                                                          <AtomNode start="(165, 12)" end="(165, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(165, 17)" end="(165, 46)">
                                                          <AtomNode start="(165, 17)" end="(165, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(165, 18)" end="(165, 45)">
                                                            <OtherNode start="(165, 18)" end="(165, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(165, 18)" end="(165, 29)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(165, 29)" end="(165, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(165, 31)" end="(165, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(165, 31)" end="(165, 45)" leading="" trailing="" raw_val="Nat.succ.injEq" val="Nat.succ.injEq" full_name="Nat.succ.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(165, 45)" end="(165, 46)" leading="" trailing=" " val="]"/>
                                                        </NullNode>
                                                        <NullNode start="(165, 47)" end="(165, 51)">
                                                          <OtherNode start="(165, 47)" end="(165, 51)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(165, 47)" end="(165, 49)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(165, 50)" end="(165, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(165, 50)" end="(165, 51)">
                                                            <IdentNode start="(165, 50)" end="(165, 51)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(166, 7)" end="(166, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁' : List α&#10;l₂' : List β&#10;hl : α&#10;tl : List α&#10;ih : ∀ {l₂ : List β}, tl.length = l₂.length → zipWith f (tl ++ l₁') (l₂ ++ l₂') = zipWith f tl l₂ ++ zipWith f l₁' l₂'&#10;head✝ : β&#10;tail✝ : List β&#10;h : tl.length = tail✝.length&#10;⊢ zipWith f (hl :: tl ++ l₁') (head✝ :: tail✝ ++ l₂') = zipWith f (hl :: tl) (head✝ :: tail✝) ++ zipWith f l₁' l₂'" state_after="no goals" tactic="simp [ih h]">
                                                        <AtomNode start="(166, 7)" end="(166, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(166, 12)" end="(166, 18)">
                                                          <AtomNode start="(166, 12)" end="(166, 13)" leading="" trailing="" val="["/>
                                                          <NullNode start="(166, 13)" end="(166, 17)">
                                                            <OtherNode start="(166, 13)" end="(166, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(166, 13)" end="(166, 17)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(166, 13)" end="(166, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(166, 16)" end="(166, 17)">
                                                            <IdentNode start="(166, 16)" end="(166, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(166, 17)" end="(166, 18)" leading="" trailing="&#10;&#10;" val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(168, 1)" end="(181, 11)" name="zipWith_eq_cons_iff" full_name="List.zipWith_eq_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(168, 1)" end="(181, 11)" name="zipWith_eq_cons_iff" full_name="List.zipWith_eq_cons_iff" _is_private_decl="False">
        <AtomNode start="(168, 1)" end="(168, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(168, 9)" end="(168, 28)">
          <IdentNode start="(168, 9)" end="(168, 28)" leading="" trailing=" " raw_val="zipWith_eq_cons_iff" val="zipWith_eq_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(168, 29)" end="(170, 87)">
          <NullNode start="(168, 29)" end="(168, 72)">
            <OtherNode start="(168, 29)" end="(168, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 29)" end="(168, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 30)" end="(168, 31)">
                <IdentNode start="(168, 30)" end="(168, 31)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(168, 32)" end="(168, 43)">
                <AtomNode start="(168, 32)" end="(168, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 34)" end="(168, 43)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(168, 34)" end="(168, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(168, 36)" end="(168, 37)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(168, 38)" end="(168, 43)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(168, 38)" end="(168, 39)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(168, 40)" end="(168, 41)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(168, 42)" end="(168, 43)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 43)" end="(168, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(168, 45)" end="(168, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 45)" end="(168, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 46)" end="(168, 48)">
                <IdentNode start="(168, 46)" end="(168, 48)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(168, 49)" end="(168, 57)">
                <AtomNode start="(168, 49)" end="(168, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 51)" end="(168, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(168, 51)" end="(168, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(168, 56)" end="(168, 57)">
                    <IdentNode start="(168, 56)" end="(168, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 57)" end="(168, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(168, 59)" end="(168, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 59)" end="(168, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 60)" end="(168, 62)">
                <IdentNode start="(168, 60)" end="(168, 62)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(168, 63)" end="(168, 71)">
                <AtomNode start="(168, 63)" end="(168, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 65)" end="(168, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(168, 65)" end="(168, 69)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(168, 70)" end="(168, 71)">
                    <IdentNode start="(168, 70)" end="(168, 71)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 71)" end="(168, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(168, 73)" end="(170, 87)">
            <AtomNode start="(168, 73)" end="(168, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(169, 5)" end="(170, 87)" kind="«term_↔_»">
              <OtherNode start="(169, 5)" end="(169, 29)" kind="«term_=_»">
                <OtherNode start="(169, 5)" end="(169, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(169, 5)" end="(169, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(169, 13)" end="(169, 20)">
                    <IdentNode start="(169, 13)" end="(169, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(169, 15)" end="(169, 17)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(169, 18)" end="(169, 20)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(169, 21)" end="(169, 22)" leading="" trailing=" " val="="/>
                <OtherNode start="(169, 23)" end="(169, 29)" kind="«term_::_»">
                  <IdentNode start="(169, 23)" end="(169, 24)" leading="" trailing=" " raw_val="g" val="g"/>
                  <AtomNode start="(169, 25)" end="(169, 27)" leading="" trailing=" " val="::"/>
                  <IdentNode start="(169, 28)" end="(169, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(169, 30)" end="(169, 31)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(170, 7)" end="(170, 87)" kind="«term∃_,_»">
                <AtomNode start="(170, 7)" end="(170, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(170, 9)" end="(170, 20)" kind="Lean.explicitBinders">
                  <OtherNode start="(170, 9)" end="(170, 20)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(170, 9)" end="(170, 20)">
                      <LeanBinderidentNode start="(170, 9)" end="(170, 10)">
                        <IdentNode start="(170, 9)" end="(170, 10)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(170, 11)" end="(170, 14)">
                        <IdentNode start="(170, 11)" end="(170, 14)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(170, 15)" end="(170, 16)">
                        <IdentNode start="(170, 15)" end="(170, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(170, 17)" end="(170, 20)">
                        <IdentNode start="(170, 17)" end="(170, 20)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(170, 20)" end="(170, 21)" leading="" trailing=" " val=","/>
                <OtherNode start="(170, 22)" end="(170, 87)" kind="«term_∧_»">
                  <OtherNode start="(170, 22)" end="(170, 35)" kind="«term_=_»">
                    <IdentNode start="(170, 22)" end="(170, 24)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(170, 25)" end="(170, 26)" leading="" trailing=" " val="="/>
                    <OtherNode start="(170, 27)" end="(170, 35)" kind="«term_::_»">
                      <IdentNode start="(170, 27)" end="(170, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(170, 29)" end="(170, 31)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(170, 32)" end="(170, 35)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(170, 36)" end="(170, 37)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(170, 38)" end="(170, 87)" kind="«term_∧_»">
                    <OtherNode start="(170, 38)" end="(170, 51)" kind="«term_=_»">
                      <IdentNode start="(170, 38)" end="(170, 40)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      <AtomNode start="(170, 41)" end="(170, 42)" leading="" trailing=" " val="="/>
                      <OtherNode start="(170, 43)" end="(170, 51)" kind="«term_::_»">
                        <IdentNode start="(170, 43)" end="(170, 44)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(170, 45)" end="(170, 47)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(170, 48)" end="(170, 51)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(170, 52)" end="(170, 53)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(170, 54)" end="(170, 87)" kind="«term_∧_»">
                      <OtherNode start="(170, 54)" end="(170, 63)" kind="«term_=_»">
                        <IdentNode start="(170, 54)" end="(170, 55)" leading="" trailing=" " raw_val="g" val="g"/>
                        <AtomNode start="(170, 56)" end="(170, 57)" leading="" trailing=" " val="="/>
                        <OtherNode start="(170, 58)" end="(170, 63)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(170, 58)" end="(170, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(170, 60)" end="(170, 63)">
                            <IdentNode start="(170, 60)" end="(170, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(170, 62)" end="(170, 63)" leading="" trailing=" " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(170, 64)" end="(170, 65)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(170, 66)" end="(170, 87)" kind="«term_=_»">
                        <IdentNode start="(170, 66)" end="(170, 67)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(170, 68)" end="(170, 69)" leading="" trailing=" " val="="/>
                        <OtherNode start="(170, 70)" end="(170, 87)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(170, 70)" end="(170, 77)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          <NullNode start="(170, 78)" end="(170, 87)">
                            <IdentNode start="(170, 78)" end="(170, 79)" leading="" trailing=" " raw_val="f" val="f"/>
                            <IdentNode start="(170, 80)" end="(170, 83)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                            <IdentNode start="(170, 84)" end="(170, 87)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(170, 88)" end="(181, 11)">
          <AtomNode start="(170, 88)" end="(170, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(170, 91)" end="(181, 11)">
            <AtomNode start="(170, 91)" end="(170, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(171, 3)" end="(181, 11)">
              <TacticTacticseq1IndentedNode start="(171, 3)" end="(181, 11)">
                <NullNode start="(171, 3)" end="(181, 11)">
                  <OtherNode start="(171, 3)" end="(181, 11)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ zipWith f l₁ l₂ = g :: l ↔ ∃ a l₁' b l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ g = f a b ∧ l = zipWith f l₁' l₂'" state_after="no goals" tactic="match l₁, l₂ with&#10;| [], [] =&amp;gt; simp&#10;| [], b :: l₂ =&amp;gt; simp&#10;| a :: l₁, [] =&amp;gt; simp&#10;| a' :: l₁, b' :: l₂ =&amp;gt;&#10;  simp only [zip_cons_cons, cons.injEq, Prod.mk.injEq]&#10;  constructor&#10;  · rintro ⟨⟨rfl, rfl⟩, rfl⟩&#10;    refine ⟨a', l₁, b', l₂, by simp⟩&#10;  · rintro ⟨a, l₁, b, l₂, ⟨rfl, rfl⟩, ⟨rfl, rfl⟩, rfl, rfl⟩&#10;    simp">
                    <AtomNode start="(171, 3)" end="(171, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(171, 9)" end="(171, 15)">
                      <OtherNode start="(171, 9)" end="(171, 11)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(171, 9)" end="(171, 11)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(171, 11)" end="(171, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(171, 13)" end="(171, 15)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(171, 13)" end="(171, 15)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(171, 16)" end="(171, 20)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(172, 3)" end="(181, 11)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(172, 3)" end="(181, 11)">
                        <OtherNode start="(172, 3)" end="(172, 19)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(172, 3)" end="(172, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(172, 5)" end="(172, 11)">
                            <NullNode start="(172, 5)" end="(172, 11)">
                              <OtherNode start="(172, 5)" end="(172, 7)" kind="«term[_]»">
                                <AtomNode start="(172, 5)" end="(172, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(172, 6)" end="(172, 7)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(172, 7)" end="(172, 8)" leading="" trailing=" " val=","/>
                              <OtherNode start="(172, 9)" end="(172, 11)" kind="«term[_]»">
                                <AtomNode start="(172, 9)" end="(172, 10)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(172, 10)" end="(172, 11)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(172, 12)" end="(172, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(172, 15)" end="(172, 19)">
                            <TacticTacticseq1IndentedNode start="(172, 15)" end="(172, 19)">
                              <NullNode start="(172, 15)" end="(172, 19)">
                                <OtherNode start="(172, 15)" end="(172, 19)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ zipWith f [] [] = g :: l ↔ ∃ a l₁' b l₂', [] = a :: l₁' ∧ [] = b :: l₂' ∧ g = f a b ∧ l = zipWith f l₁' l₂'" state_after="no goals" tactic="simp">
                                  <AtomNode start="(172, 15)" end="(172, 19)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(173, 3)" end="(173, 24)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(173, 3)" end="(173, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(173, 5)" end="(173, 16)">
                            <NullNode start="(173, 5)" end="(173, 16)">
                              <OtherNode start="(173, 5)" end="(173, 7)" kind="«term[_]»">
                                <AtomNode start="(173, 5)" end="(173, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(173, 6)" end="(173, 7)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(173, 7)" end="(173, 8)" leading="" trailing=" " val=","/>
                              <OtherNode start="(173, 9)" end="(173, 16)" kind="«term_::_»">
                                <IdentNode start="(173, 9)" end="(173, 10)" leading="" trailing=" " raw_val="b" val="b"/>
                                <AtomNode start="(173, 11)" end="(173, 13)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(173, 14)" end="(173, 16)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(173, 17)" end="(173, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(173, 20)" end="(173, 24)">
                            <TacticTacticseq1IndentedNode start="(173, 20)" end="(173, 24)">
                              <NullNode start="(173, 20)" end="(173, 24)">
                                <OtherNode start="(173, 20)" end="(173, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁ : List α&#10;l₂✝ : List β&#10;b : β&#10;l₂ : List β&#10;⊢ zipWith f [] (b :: l₂) = g :: l ↔&#10;    ∃ a l₁' b_1 l₂', [] = a :: l₁' ∧ b :: l₂ = b_1 :: l₂' ∧ g = f a b_1 ∧ l = zipWith f l₁' l₂'" state_after="no goals" tactic="simp">
                                  <AtomNode start="(173, 20)" end="(173, 24)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(174, 3)" end="(174, 24)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(174, 3)" end="(174, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(174, 5)" end="(174, 16)">
                            <NullNode start="(174, 5)" end="(174, 16)">
                              <OtherNode start="(174, 5)" end="(174, 12)" kind="«term_::_»">
                                <IdentNode start="(174, 5)" end="(174, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(174, 7)" end="(174, 9)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(174, 10)" end="(174, 12)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                              </OtherNode>
                              <AtomNode start="(174, 12)" end="(174, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(174, 14)" end="(174, 16)" kind="«term[_]»">
                                <AtomNode start="(174, 14)" end="(174, 15)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(174, 15)" end="(174, 16)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(174, 17)" end="(174, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(174, 20)" end="(174, 24)">
                            <TacticTacticseq1IndentedNode start="(174, 20)" end="(174, 24)">
                              <NullNode start="(174, 20)" end="(174, 24)">
                                <OtherNode start="(174, 20)" end="(174, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂ : List β&#10;a : α&#10;l₁ : List α&#10;⊢ zipWith f (a :: l₁) [] = g :: l ↔&#10;    ∃ a_1 l₁' b l₂', a :: l₁ = a_1 :: l₁' ∧ [] = b :: l₂' ∧ g = f a_1 b ∧ l = zipWith f l₁' l₂'" state_after="no goals" tactic="simp">
                                  <AtomNode start="(174, 20)" end="(174, 24)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(175, 3)" end="(181, 11)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(175, 3)" end="(175, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(175, 5)" end="(175, 23)">
                            <NullNode start="(175, 5)" end="(175, 23)">
                              <OtherNode start="(175, 5)" end="(175, 13)" kind="«term_::_»">
                                <IdentNode start="(175, 5)" end="(175, 7)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                <AtomNode start="(175, 8)" end="(175, 10)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(175, 11)" end="(175, 13)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                              </OtherNode>
                              <AtomNode start="(175, 13)" end="(175, 14)" leading="" trailing=" " val=","/>
                              <OtherNode start="(175, 15)" end="(175, 23)" kind="«term_::_»">
                                <IdentNode start="(175, 15)" end="(175, 17)" leading="" trailing=" " raw_val="b'" val="b'"/>
                                <AtomNode start="(175, 18)" end="(175, 20)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(175, 21)" end="(175, 23)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(175, 24)" end="(175, 26)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(176, 5)" end="(181, 11)">
                            <TacticTacticseq1IndentedNode start="(176, 5)" end="(181, 11)">
                              <NullNode start="(176, 5)" end="(181, 11)">
                                <OtherNode start="(176, 5)" end="(176, 57)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = g :: l ↔&#10;    ∃ a l₁' b l₂', a' :: l₁ = a :: l₁' ∧ b' :: l₂ = b :: l₂' ∧ g = f a b ∧ l = zipWith f l₁' l₂'" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = g :: l ↔&#10;    ∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂'" tactic="simp only [zip_cons_cons, cons.injEq, Prod.mk.injEq]">
                                  <AtomNode start="(176, 5)" end="(176, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(176, 10)" end="(176, 14)">
                                    <AtomNode start="(176, 10)" end="(176, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(176, 15)" end="(176, 57)">
                                    <AtomNode start="(176, 15)" end="(176, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(176, 16)" end="(176, 56)">
                                      <OtherNode start="(176, 16)" end="(176, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(176, 16)" end="(176, 29)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(176, 29)" end="(176, 30)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(176, 31)" end="(176, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(176, 31)" end="(176, 41)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(176, 41)" end="(176, 42)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(176, 43)" end="(176, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(176, 43)" end="(176, 56)" leading="" trailing="" raw_val="Prod.mk.injEq" val="Prod.mk.injEq" full_name="Prod.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(176, 56)" end="(176, 57)" leading="" trailing="&#10;    " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(177, 5)" end="(177, 16)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = g :: l ↔&#10;    ∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂'" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = g :: l →&#10;    ∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂'&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ (∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂') →&#10;    zipWith f (a' :: l₁) (b' :: l₂) = g :: l" tactic="constructor">
                                  <AtomNode start="(177, 5)" end="(177, 16)" leading="" trailing="&#10;    " val="constructor"/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(178, 5)" end="(179, 39)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = g :: l →&#10;    ∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂'&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ (∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂') →&#10;    zipWith f (a' :: l₁) (b' :: l₂) = g :: l" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ (∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂') →&#10;    zipWith f (a' :: l₁) (b' :: l₂) = g :: l" tactic="· rintro ⟨⟨rfl, rfl⟩, rfl⟩&#10;  refine ⟨a', l₁, b', l₂, by simp⟩">
                                  <OtherNode start="(178, 5)" end="(178, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(178, 5)" end="(178, 6)" kind="patternIgnore">
                                      <OtherNode start="(178, 5)" end="(178, 6)" kind="token.«· »">
                                        <AtomNode start="(178, 5)" end="(178, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(178, 7)" end="(179, 39)">
                                    <TacticTacticseq1IndentedNode start="(178, 7)" end="(179, 39)">
                                      <NullNode start="(178, 7)" end="(179, 39)">
                                        <OtherNode start="(178, 7)" end="(178, 31)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = g :: l →&#10;    ∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂'" state_after="case mp.refl&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ ∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ f a' b' = f a b ∧ zipWith f l₁ l₂ = zipWith f l₁' l₂'" tactic="rintro ⟨⟨rfl, rfl⟩, rfl⟩">
                                          <AtomNode start="(178, 7)" end="(178, 13)" leading="" trailing=" " val="rintro"/>
                                          <NullNode start="(178, 14)" end="(178, 31)">
                                            <OtherNode start="(178, 14)" end="(178, 31)" kind="Lean.Parser.Tactic.rintroPat.one">
                                              <OtherNode start="(178, 14)" end="(178, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                <AtomNode start="(178, 14)" end="(178, 15)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(178, 15)" end="(178, 30)">
                                                  <OtherNode start="(178, 15)" end="(178, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(178, 15)" end="(178, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(178, 15)" end="(178, 25)">
                                                        <OtherNode start="(178, 15)" end="(178, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                          <AtomNode start="(178, 15)" end="(178, 16)" leading="" trailing="" val="⟨"/>
                                                          <NullNode start="(178, 16)" end="(178, 24)">
                                                            <OtherNode start="(178, 16)" end="(178, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(178, 16)" end="(178, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(178, 16)" end="(178, 19)">
                                                            <OtherNode start="(178, 16)" end="(178, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(178, 16)" end="(178, 19)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(178, 19)" end="(178, 20)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(178, 21)" end="(178, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(178, 21)" end="(178, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(178, 21)" end="(178, 24)">
                                                            <OtherNode start="(178, 21)" end="(178, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(178, 21)" end="(178, 24)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(178, 24)" end="(178, 25)" leading="" trailing="" val="⟩"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(178, 25)" end="(178, 26)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(178, 27)" end="(178, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(178, 27)" end="(178, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(178, 27)" end="(178, 30)">
                                                        <OtherNode start="(178, 27)" end="(178, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                          <IdentNode start="(178, 27)" end="(178, 30)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(178, 30)" end="(178, 31)" leading="" trailing="&#10;      " val="⟩"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(179, 7)" end="(179, 39)" kind="Lean.Parser.Tactic.refine" state_before="case mp.refl&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ ∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ f a' b' = f a b ∧ zipWith f l₁ l₂ = zipWith f l₁' l₂'" state_after="no goals" tactic="refine ⟨a', l₁, b', l₂, by simp⟩">
                                          <AtomNode start="(179, 7)" end="(179, 13)" leading="" trailing=" " val="refine"/>
                                          <OtherNode start="(179, 14)" end="(179, 39)" kind="Lean.Parser.Term.anonymousCtor">
                                            <AtomNode start="(179, 14)" end="(179, 15)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(179, 15)" end="(179, 38)">
                                              <IdentNode start="(179, 15)" end="(179, 17)" leading="" trailing="" raw_val="a'" val="a'"/>
                                              <AtomNode start="(179, 17)" end="(179, 18)" leading="" trailing=" " val=","/>
                                              <IdentNode start="(179, 19)" end="(179, 21)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                              <AtomNode start="(179, 21)" end="(179, 22)" leading="" trailing=" " val=","/>
                                              <IdentNode start="(179, 23)" end="(179, 25)" leading="" trailing="" raw_val="b'" val="b'"/>
                                              <AtomNode start="(179, 25)" end="(179, 26)" leading="" trailing=" " val=","/>
                                              <IdentNode start="(179, 27)" end="(179, 29)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                              <AtomNode start="(179, 29)" end="(179, 30)" leading="" trailing=" " val=","/>
                                              <TermBytacticNode start="(179, 31)" end="(179, 38)">
                                                <AtomNode start="(179, 31)" end="(179, 33)" leading="" trailing=" " val="by"/>
                                                <TacticTacticseqNode start="(179, 34)" end="(179, 38)">
                                                  <TacticTacticseq1IndentedNode start="(179, 34)" end="(179, 38)">
                                                    <NullNode start="(179, 34)" end="(179, 38)">
                                                      <OtherNode start="(179, 34)" end="(179, 38)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ (a' = a' ∧ l₁ = l₁) ∧ (b' = b' ∧ l₂ = l₂) ∧ f a' b' = f a' b' ∧ zipWith f l₁ l₂ = zipWith f l₁ l₂" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(179, 34)" end="(179, 38)" leading="" trailing="" val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </TermBytacticNode>
                                            </NullNode>
                                            <AtomNode start="(179, 38)" end="(179, 39)" leading="" trailing="&#10;    " val="⟩"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(180, 5)" end="(181, 11)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ (∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂') →&#10;    zipWith f (a' :: l₁) (b' :: l₂) = g :: l" state_after="no goals" tactic="· rintro ⟨a, l₁, b, l₂, ⟨rfl, rfl⟩, ⟨rfl, rfl⟩, rfl, rfl⟩&#10;  simp">
                                  <OtherNode start="(180, 5)" end="(180, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(180, 5)" end="(180, 6)" kind="patternIgnore">
                                      <OtherNode start="(180, 5)" end="(180, 6)" kind="token.«· »">
                                        <AtomNode start="(180, 5)" end="(180, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(180, 7)" end="(181, 11)">
                                    <TacticTacticseq1IndentedNode start="(180, 7)" end="(181, 11)">
                                      <NullNode start="(180, 7)" end="(181, 11)">
                                        <OtherNode start="(180, 7)" end="(180, 62)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;g : γ&#10;l : List γ&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ (∃ a l₁' b l₂', (a' = a ∧ l₁ = l₁') ∧ (b' = b ∧ l₂ = l₂') ∧ g = f a b ∧ l = zipWith f l₁' l₂') →&#10;    zipWith f (a' :: l₁) (b' :: l₂) = g :: l" state_after="case mpr.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = f a' b' :: zipWith f l₁ l₂" tactic="rintro ⟨a, l₁, b, l₂, ⟨rfl, rfl⟩, ⟨rfl, rfl⟩, rfl, rfl⟩">
                                          <AtomNode start="(180, 7)" end="(180, 13)" leading="" trailing=" " val="rintro"/>
                                          <NullNode start="(180, 14)" end="(180, 62)">
                                            <OtherNode start="(180, 14)" end="(180, 62)" kind="Lean.Parser.Tactic.rintroPat.one">
                                              <OtherNode start="(180, 14)" end="(180, 62)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                <AtomNode start="(180, 14)" end="(180, 15)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(180, 15)" end="(180, 61)">
                                                  <OtherNode start="(180, 15)" end="(180, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 15)" end="(180, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 15)" end="(180, 16)">
                                                        <OtherNode start="(180, 15)" end="(180, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                          <IdentNode start="(180, 15)" end="(180, 16)" leading="" trailing="" raw_val="a" val="a"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(180, 16)" end="(180, 17)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(180, 18)" end="(180, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 18)" end="(180, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 18)" end="(180, 20)">
                                                        <OtherNode start="(180, 18)" end="(180, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                          <IdentNode start="(180, 18)" end="(180, 20)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(180, 20)" end="(180, 21)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(180, 22)" end="(180, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 22)" end="(180, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 22)" end="(180, 23)">
                                                        <OtherNode start="(180, 22)" end="(180, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                          <IdentNode start="(180, 22)" end="(180, 23)" leading="" trailing="" raw_val="b" val="b"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(180, 23)" end="(180, 24)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(180, 25)" end="(180, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 25)" end="(180, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 25)" end="(180, 27)">
                                                        <OtherNode start="(180, 25)" end="(180, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                          <IdentNode start="(180, 25)" end="(180, 27)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(180, 27)" end="(180, 28)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(180, 29)" end="(180, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 29)" end="(180, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 29)" end="(180, 39)">
                                                        <OtherNode start="(180, 29)" end="(180, 39)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                          <AtomNode start="(180, 29)" end="(180, 30)" leading="" trailing="" val="⟨"/>
                                                          <NullNode start="(180, 30)" end="(180, 38)">
                                                            <OtherNode start="(180, 30)" end="(180, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(180, 30)" end="(180, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(180, 30)" end="(180, 33)">
                                                            <OtherNode start="(180, 30)" end="(180, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(180, 30)" end="(180, 33)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(180, 33)" end="(180, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(180, 35)" end="(180, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(180, 35)" end="(180, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(180, 35)" end="(180, 38)">
                                                            <OtherNode start="(180, 35)" end="(180, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(180, 35)" end="(180, 38)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(180, 38)" end="(180, 39)" leading="" trailing="" val="⟩"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(180, 39)" end="(180, 40)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(180, 41)" end="(180, 51)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 41)" end="(180, 51)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 41)" end="(180, 51)">
                                                        <OtherNode start="(180, 41)" end="(180, 51)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                          <AtomNode start="(180, 41)" end="(180, 42)" leading="" trailing="" val="⟨"/>
                                                          <NullNode start="(180, 42)" end="(180, 50)">
                                                            <OtherNode start="(180, 42)" end="(180, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(180, 42)" end="(180, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(180, 42)" end="(180, 45)">
                                                            <OtherNode start="(180, 42)" end="(180, 45)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(180, 42)" end="(180, 45)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(180, 45)" end="(180, 46)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(180, 47)" end="(180, 50)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(180, 47)" end="(180, 50)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(180, 47)" end="(180, 50)">
                                                            <OtherNode start="(180, 47)" end="(180, 50)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(180, 47)" end="(180, 50)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(180, 50)" end="(180, 51)" leading="" trailing="" val="⟩"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(180, 51)" end="(180, 52)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(180, 53)" end="(180, 56)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 53)" end="(180, 56)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 53)" end="(180, 56)">
                                                        <OtherNode start="(180, 53)" end="(180, 56)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                          <IdentNode start="(180, 53)" end="(180, 56)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(180, 56)" end="(180, 57)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(180, 58)" end="(180, 61)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(180, 58)" end="(180, 61)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(180, 58)" end="(180, 61)">
                                                        <OtherNode start="(180, 58)" end="(180, 61)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                          <IdentNode start="(180, 58)" end="(180, 61)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(180, 61)" end="(180, 62)" leading="" trailing="&#10;      " val="⟩"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(181, 7)" end="(181, 11)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₁✝ : List α&#10;l₂✝ : List β&#10;a' : α&#10;l₁ : List α&#10;b' : β&#10;l₂ : List β&#10;⊢ zipWith f (a' :: l₁) (b' :: l₂) = f a' b' :: zipWith f l₁ l₂" state_after="no goals" tactic="simp">
                                          <AtomNode start="(181, 7)" end="(181, 11)" leading="" trailing="&#10;&#10;" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(183, 1)" end="(225, 52)" name="zipWith_eq_append_iff" full_name="List.zipWith_eq_append_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(183, 1)" end="(225, 52)" name="zipWith_eq_append_iff" full_name="List.zipWith_eq_append_iff" _is_private_decl="False">
        <AtomNode start="(183, 1)" end="(183, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(183, 9)" end="(183, 30)">
          <IdentNode start="(183, 9)" end="(183, 30)" leading="" trailing=" " raw_val="zipWith_eq_append_iff" val="zipWith_eq_append_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(183, 31)" end="(185, 123)">
          <NullNode start="(183, 31)" end="(183, 74)">
            <OtherNode start="(183, 31)" end="(183, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(183, 31)" end="(183, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(183, 32)" end="(183, 33)">
                <IdentNode start="(183, 32)" end="(183, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(183, 34)" end="(183, 45)">
                <AtomNode start="(183, 34)" end="(183, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 36)" end="(183, 45)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(183, 36)" end="(183, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(183, 38)" end="(183, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(183, 40)" end="(183, 45)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(183, 40)" end="(183, 41)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(183, 42)" end="(183, 43)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(183, 44)" end="(183, 45)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(183, 45)" end="(183, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(183, 47)" end="(183, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(183, 47)" end="(183, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(183, 48)" end="(183, 50)">
                <IdentNode start="(183, 48)" end="(183, 50)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(183, 51)" end="(183, 59)">
                <AtomNode start="(183, 51)" end="(183, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 53)" end="(183, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(183, 53)" end="(183, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(183, 58)" end="(183, 59)">
                    <IdentNode start="(183, 58)" end="(183, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(183, 59)" end="(183, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(183, 61)" end="(183, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(183, 61)" end="(183, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(183, 62)" end="(183, 64)">
                <IdentNode start="(183, 62)" end="(183, 64)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(183, 65)" end="(183, 73)">
                <AtomNode start="(183, 65)" end="(183, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 67)" end="(183, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(183, 67)" end="(183, 71)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(183, 72)" end="(183, 73)">
                    <IdentNode start="(183, 72)" end="(183, 73)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(183, 73)" end="(183, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(183, 75)" end="(185, 123)">
            <AtomNode start="(183, 75)" end="(183, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(184, 5)" end="(185, 123)" kind="«term_↔_»">
              <OtherNode start="(184, 5)" end="(184, 33)" kind="«term_=_»">
                <OtherNode start="(184, 5)" end="(184, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(184, 5)" end="(184, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(184, 13)" end="(184, 20)">
                    <IdentNode start="(184, 13)" end="(184, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(184, 15)" end="(184, 17)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(184, 18)" end="(184, 20)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(184, 21)" end="(184, 22)" leading="" trailing=" " val="="/>
                <OtherNode start="(184, 23)" end="(184, 33)" kind="«term_++_»">
                  <IdentNode start="(184, 23)" end="(184, 26)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                  <AtomNode start="(184, 27)" end="(184, 29)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(184, 30)" end="(184, 33)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(184, 34)" end="(184, 35)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(185, 7)" end="(185, 123)" kind="«term∃_,_»">
                <AtomNode start="(185, 7)" end="(185, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(185, 9)" end="(185, 20)" kind="Lean.explicitBinders">
                  <OtherNode start="(185, 9)" end="(185, 20)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(185, 9)" end="(185, 20)">
                      <LeanBinderidentNode start="(185, 9)" end="(185, 11)">
                        <IdentNode start="(185, 9)" end="(185, 11)" leading="" trailing=" " raw_val="ws" val="ws"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(185, 12)" end="(185, 14)">
                        <IdentNode start="(185, 12)" end="(185, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(185, 15)" end="(185, 17)">
                        <IdentNode start="(185, 15)" end="(185, 17)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(185, 18)" end="(185, 20)">
                        <IdentNode start="(185, 18)" end="(185, 20)" leading="" trailing="" raw_val="zs" val="zs"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(185, 20)" end="(185, 21)" leading="" trailing=" " val=","/>
                <OtherNode start="(185, 22)" end="(185, 123)" kind="«term_∧_»">
                  <OtherNode start="(185, 22)" end="(185, 43)" kind="«term_=_»">
                    <IdentNode start="(185, 22)" end="(185, 31)" leading="" trailing=" " raw_val="ws.length" val="ws.length"/>
                    <AtomNode start="(185, 32)" end="(185, 33)" leading="" trailing=" " val="="/>
                    <IdentNode start="(185, 34)" end="(185, 43)" leading="" trailing=" " raw_val="ys.length" val="ys.length"/>
                  </OtherNode>
                  <AtomNode start="(185, 44)" end="(185, 45)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(185, 46)" end="(185, 123)" kind="«term_∧_»">
                    <OtherNode start="(185, 46)" end="(185, 59)" kind="«term_=_»">
                      <IdentNode start="(185, 46)" end="(185, 48)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(185, 49)" end="(185, 50)" leading="" trailing=" " val="="/>
                      <OtherNode start="(185, 51)" end="(185, 59)" kind="«term_++_»">
                        <IdentNode start="(185, 51)" end="(185, 53)" leading="" trailing=" " raw_val="ws" val="ws"/>
                        <AtomNode start="(185, 54)" end="(185, 56)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(185, 57)" end="(185, 59)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(185, 60)" end="(185, 61)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(185, 62)" end="(185, 123)" kind="«term_∧_»">
                      <OtherNode start="(185, 62)" end="(185, 75)" kind="«term_=_»">
                        <IdentNode start="(185, 62)" end="(185, 64)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <AtomNode start="(185, 65)" end="(185, 66)" leading="" trailing=" " val="="/>
                        <OtherNode start="(185, 67)" end="(185, 75)" kind="«term_++_»">
                          <IdentNode start="(185, 67)" end="(185, 69)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          <AtomNode start="(185, 70)" end="(185, 72)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(185, 73)" end="(185, 75)" leading="" trailing=" " raw_val="zs" val="zs"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(185, 76)" end="(185, 77)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(185, 78)" end="(185, 123)" kind="«term_∧_»">
                        <OtherNode start="(185, 78)" end="(185, 99)" kind="«term_=_»">
                          <IdentNode start="(185, 78)" end="(185, 81)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                          <AtomNode start="(185, 82)" end="(185, 83)" leading="" trailing=" " val="="/>
                          <OtherNode start="(185, 84)" end="(185, 99)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(185, 84)" end="(185, 91)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                            <NullNode start="(185, 92)" end="(185, 99)">
                              <IdentNode start="(185, 92)" end="(185, 93)" leading="" trailing=" " raw_val="f" val="f"/>
                              <IdentNode start="(185, 94)" end="(185, 96)" leading="" trailing=" " raw_val="ws" val="ws"/>
                              <IdentNode start="(185, 97)" end="(185, 99)" leading="" trailing=" " raw_val="ys" val="ys"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(185, 100)" end="(185, 101)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(185, 102)" end="(185, 123)" kind="«term_=_»">
                          <IdentNode start="(185, 102)" end="(185, 105)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                          <AtomNode start="(185, 106)" end="(185, 107)" leading="" trailing=" " val="="/>
                          <OtherNode start="(185, 108)" end="(185, 123)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(185, 108)" end="(185, 115)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                            <NullNode start="(185, 116)" end="(185, 123)">
                              <IdentNode start="(185, 116)" end="(185, 117)" leading="" trailing=" " raw_val="f" val="f"/>
                              <IdentNode start="(185, 118)" end="(185, 120)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              <IdentNode start="(185, 121)" end="(185, 123)" leading="" trailing=" " raw_val="zs" val="zs"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(185, 124)" end="(225, 52)">
          <AtomNode start="(185, 124)" end="(185, 126)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(185, 127)" end="(225, 52)">
            <AtomNode start="(185, 127)" end="(185, 129)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(186, 3)" end="(225, 52)">
              <TacticTacticseq1IndentedNode start="(186, 3)" end="(225, 52)">
                <NullNode start="(186, 3)" end="(225, 52)">
                  <OtherNode start="(186, 3)" end="(225, 52)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₁' l₂' : List γ&#10;f : α → β → γ&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs, ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="no goals" tactic="induction l₁ generalizing l₂ l₁' with&#10;| nil =&amp;gt;&#10;  simp&#10;  constructor&#10;  · rintro ⟨rfl, rfl⟩&#10;    exact ⟨[], [], [], by simp⟩&#10;  · rintro ⟨_, _, _, -, ⟨rfl, rfl⟩, _, rfl, rfl, rfl⟩&#10;    simp&#10;| cons x₁ l₁ ih₁ =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt;&#10;    constructor&#10;    · simp only [zipWith_nil_right, nil_eq, append_eq_nil_iff, exists_and_left, and_imp]&#10;      rintro rfl  rfl&#10;      exact ⟨[], x₁ :: l₁, [], by simp⟩&#10;    · rintro ⟨_, _, _, _, h₁, _, h₃, rfl, rfl⟩&#10;      simp only [nil_eq, append_eq_nil_iff] at h₃&#10;      obtain ⟨rfl, rfl⟩ := h₃&#10;      simp&#10;  | cons x₂ l₂ =&amp;gt;&#10;    simp only [zipWith_cons_cons]&#10;    rw [cons_eq_append_iff]&#10;    constructor&#10;    · rintro (⟨rfl, rfl⟩ | ⟨_, rfl, h⟩)&#10;      · exact ⟨[], x₁ :: l₁, [], x₂ :: l₂, by simp⟩&#10;      · rw [ih₁] at h&#10;        obtain ⟨ws, xs, ys, zs, h, rfl, rfl, h', rfl⟩ := h&#10;        refine ⟨x₁ :: ws, xs, x₂ :: ys, zs, by simp [h, h']⟩&#10;    · rintro ⟨_, _, _, _, h₁, h₂, h₃, rfl, rfl⟩&#10;      rw [cons_eq_append_iff] at h₂&#10;      rw [cons_eq_append_iff] at h₃&#10;      obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₂&#10;      · simp only [zipWith_nil_left, true_and, nil_eq, reduceCtorEq, false_and, exists_const,&#10;        or_false]&#10;        obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;        · simp&#10;        · simp_all&#10;      · obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;        · simp_all&#10;        · simp_all [zipWith_append, Nat.succ_inj]">
                    <AtomNode start="(186, 3)" end="(186, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(186, 13)" end="(186, 15)">
                      <OtherNode start="(186, 13)" end="(186, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(186, 13)" end="(186, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(186, 16)" end="(186, 35)">
                      <AtomNode start="(186, 16)" end="(186, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(186, 29)" end="(186, 35)">
                        <IdentNode start="(186, 29)" end="(186, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <IdentNode start="(186, 32)" end="(186, 35)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(186, 36)" end="(225, 52)">
                      <OtherNode start="(186, 36)" end="(225, 52)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(186, 36)" end="(186, 40)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(187, 3)" end="(225, 52)">
                          <OtherNode start="(187, 3)" end="(193, 11)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(187, 3)" end="(187, 8)">
                              <OtherNode start="(187, 3)" end="(187, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(187, 3)" end="(187, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(187, 5)" end="(187, 8)">
                                  <NullNode/>
                                  <IdentNode start="(187, 5)" end="(187, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(187, 9)" end="(193, 11)">
                              <AtomNode start="(187, 9)" end="(187, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(188, 5)" end="(193, 11)">
                                <TacticTacticseq1IndentedNode start="(188, 5)" end="(193, 11)">
                                  <NullNode start="(188, 5)" end="(193, 11)">
                                    <OtherNode start="(188, 5)" end="(188, 9)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ zipWith f [] l₂ = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs, ws.length = ys.length ∧ [] = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ l₁' = [] ∧ l₂' = [] ↔&#10;    ∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x" tactic="simp">
                                      <AtomNode start="(188, 5)" end="(188, 9)" leading="" trailing="&#10;    " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(189, 5)" end="(189, 16)" kind="Lean.Parser.Tactic.constructor" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ l₁' = [] ∧ l₂' = [] ↔&#10;    ∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x" state_after="case nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ l₁' = [] ∧ l₂' = [] →&#10;    ∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x&#10;&#10;case nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ (∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x) →&#10;    l₁' = [] ∧ l₂' = []" tactic="constructor">
                                      <AtomNode start="(189, 5)" end="(189, 16)" leading="" trailing="&#10;    " val="constructor"/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(190, 5)" end="(191, 34)" kind="Lean.cdot" state_before="case nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ l₁' = [] ∧ l₂' = [] →&#10;    ∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x&#10;&#10;case nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ (∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x) →&#10;    l₁' = [] ∧ l₂' = []" state_after="case nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ (∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x) →&#10;    l₁' = [] ∧ l₂' = []" tactic="· rintro ⟨rfl, rfl⟩&#10;  exact ⟨[], [], [], by simp⟩">
                                      <OtherNode start="(190, 5)" end="(190, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(190, 5)" end="(190, 6)" kind="patternIgnore">
                                          <OtherNode start="(190, 5)" end="(190, 6)" kind="token.«· »">
                                            <AtomNode start="(190, 5)" end="(190, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(190, 7)" end="(191, 34)">
                                        <TacticTacticseq1IndentedNode start="(190, 7)" end="(191, 34)">
                                          <NullNode start="(190, 7)" end="(191, 34)">
                                            <OtherNode start="(190, 7)" end="(190, 24)" kind="Lean.Parser.Tactic.rintro" state_before="case nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ l₁' = [] ∧ l₂' = [] →&#10;    ∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x" state_after="case nil.mp.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₂ : List β&#10;⊢ ∃ ws xs ys,&#10;    ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ [] = zipWith f ws ys ∧ [] = zipWith f xs x" tactic="rintro ⟨rfl, rfl⟩">
                                              <AtomNode start="(190, 7)" end="(190, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(190, 14)" end="(190, 24)">
                                                <OtherNode start="(190, 14)" end="(190, 24)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(190, 14)" end="(190, 24)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                    <AtomNode start="(190, 14)" end="(190, 15)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(190, 15)" end="(190, 23)">
                                                      <OtherNode start="(190, 15)" end="(190, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(190, 15)" end="(190, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(190, 15)" end="(190, 18)">
                                                            <OtherNode start="(190, 15)" end="(190, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(190, 15)" end="(190, 18)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(190, 18)" end="(190, 19)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(190, 20)" end="(190, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(190, 20)" end="(190, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(190, 20)" end="(190, 23)">
                                                            <OtherNode start="(190, 20)" end="(190, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(190, 20)" end="(190, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(190, 23)" end="(190, 24)" leading="" trailing="&#10;      " val="⟩"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(191, 7)" end="(191, 34)" kind="Lean.Parser.Tactic.exact" state_before="case nil.mp.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₂ : List β&#10;⊢ ∃ ws xs ys,&#10;    ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ [] = zipWith f ws ys ∧ [] = zipWith f xs x" state_after="no goals" tactic="exact ⟨[], [], [], by simp⟩">
                                              <AtomNode start="(191, 7)" end="(191, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(191, 13)" end="(191, 34)" kind="Lean.Parser.Term.anonymousCtor">
                                                <AtomNode start="(191, 13)" end="(191, 14)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(191, 14)" end="(191, 33)">
                                                  <OtherNode start="(191, 14)" end="(191, 16)" kind="«term[_]»">
                                                    <AtomNode start="(191, 14)" end="(191, 15)" leading="" trailing="" val="["/>
                                                    <NullNode/>
                                                    <AtomNode start="(191, 15)" end="(191, 16)" leading="" trailing="" val="]"/>
                                                  </OtherNode>
                                                  <AtomNode start="(191, 16)" end="(191, 17)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(191, 18)" end="(191, 20)" kind="«term[_]»">
                                                    <AtomNode start="(191, 18)" end="(191, 19)" leading="" trailing="" val="["/>
                                                    <NullNode/>
                                                    <AtomNode start="(191, 19)" end="(191, 20)" leading="" trailing="" val="]"/>
                                                  </OtherNode>
                                                  <AtomNode start="(191, 20)" end="(191, 21)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(191, 22)" end="(191, 24)" kind="«term[_]»">
                                                    <AtomNode start="(191, 22)" end="(191, 23)" leading="" trailing="" val="["/>
                                                    <NullNode/>
                                                    <AtomNode start="(191, 23)" end="(191, 24)" leading="" trailing="" val="]"/>
                                                  </OtherNode>
                                                  <AtomNode start="(191, 24)" end="(191, 25)" leading="" trailing=" " val=","/>
                                                  <TermBytacticNode start="(191, 26)" end="(191, 33)">
                                                    <AtomNode start="(191, 26)" end="(191, 28)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(191, 29)" end="(191, 33)">
                                                      <TacticTacticseq1IndentedNode start="(191, 29)" end="(191, 33)">
                                                        <NullNode start="(191, 29)" end="(191, 33)">
                                                          <OtherNode start="(191, 29)" end="(191, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l₂ : List β&#10;⊢ [].length = [].length ∧ ([] = [] ∧ [] = []) ∧ ∃ x, l₂ = [] ++ x ∧ [] = zipWith f [] [] ∧ [] = zipWith f [] x" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(191, 29)" end="(191, 33)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </NullNode>
                                                <AtomNode start="(191, 33)" end="(191, 34)" leading="" trailing="&#10;    " val="⟩"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(192, 5)" end="(193, 11)" kind="Lean.cdot" state_before="case nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ (∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x) →&#10;    l₁' = [] ∧ l₂' = []" state_after="no goals" tactic="· rintro ⟨_, _, _, -, ⟨rfl, rfl⟩, _, rfl, rfl, rfl⟩&#10;  simp">
                                      <OtherNode start="(192, 5)" end="(192, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(192, 5)" end="(192, 6)" kind="patternIgnore">
                                          <OtherNode start="(192, 5)" end="(192, 6)" kind="token.«· »">
                                            <AtomNode start="(192, 5)" end="(192, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(192, 7)" end="(193, 11)">
                                        <TacticTacticseq1IndentedNode start="(192, 7)" end="(193, 11)">
                                          <NullNode start="(192, 7)" end="(193, 11)">
                                            <OtherNode start="(192, 7)" end="(192, 56)" kind="Lean.Parser.Tactic.rintro" state_before="case nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ (∃ ws xs ys,&#10;      ws.length = ys.length ∧ (ws = [] ∧ xs = []) ∧ ∃ x, l₂ = ys ++ x ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x) →&#10;    l₁' = [] ∧ l₂' = []" state_after="case nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;w✝¹ w✝ : List β&#10;⊢ zipWith f [] w✝¹ = [] ∧ zipWith f [] w✝ = []" tactic="rintro ⟨_, _, _, -, ⟨rfl, rfl⟩, _, rfl, rfl, rfl⟩">
                                              <AtomNode start="(192, 7)" end="(192, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(192, 14)" end="(192, 56)">
                                                <OtherNode start="(192, 14)" end="(192, 56)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(192, 14)" end="(192, 56)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                    <AtomNode start="(192, 14)" end="(192, 15)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(192, 15)" end="(192, 55)">
                                                      <OtherNode start="(192, 15)" end="(192, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 15)" end="(192, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 15)" end="(192, 16)">
                                                            <OtherNode start="(192, 15)" end="(192, 16)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(192, 15)" end="(192, 16)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 16)" end="(192, 17)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 18)" end="(192, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 18)" end="(192, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 18)" end="(192, 19)">
                                                            <OtherNode start="(192, 18)" end="(192, 19)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(192, 18)" end="(192, 19)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 19)" end="(192, 20)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 21)" end="(192, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 21)" end="(192, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 21)" end="(192, 22)">
                                                            <OtherNode start="(192, 21)" end="(192, 22)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(192, 21)" end="(192, 22)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 22)" end="(192, 23)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 24)" end="(192, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 24)" end="(192, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 24)" end="(192, 25)">
                                                            <OtherNode start="(192, 24)" end="(192, 25)" kind="Lean.Parser.Tactic.rcasesPat.clear">
                                                            <AtomNode start="(192, 24)" end="(192, 25)" leading="" trailing="" val="-"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 25)" end="(192, 26)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 27)" end="(192, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 27)" end="(192, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 27)" end="(192, 37)">
                                                            <OtherNode start="(192, 27)" end="(192, 37)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(192, 27)" end="(192, 28)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(192, 28)" end="(192, 36)">
                                                            <OtherNode start="(192, 28)" end="(192, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(192, 28)" end="(192, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(192, 28)" end="(192, 31)">
                                                            <OtherNode start="(192, 28)" end="(192, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(192, 28)" end="(192, 31)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(192, 31)" end="(192, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(192, 33)" end="(192, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(192, 33)" end="(192, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(192, 33)" end="(192, 36)">
                                                            <OtherNode start="(192, 33)" end="(192, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(192, 33)" end="(192, 36)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(192, 36)" end="(192, 37)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 37)" end="(192, 38)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 39)" end="(192, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 39)" end="(192, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 39)" end="(192, 40)">
                                                            <OtherNode start="(192, 39)" end="(192, 40)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(192, 39)" end="(192, 40)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 40)" end="(192, 41)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 42)" end="(192, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 42)" end="(192, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 42)" end="(192, 45)">
                                                            <OtherNode start="(192, 42)" end="(192, 45)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(192, 42)" end="(192, 45)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 45)" end="(192, 46)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 47)" end="(192, 50)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 47)" end="(192, 50)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 47)" end="(192, 50)">
                                                            <OtherNode start="(192, 47)" end="(192, 50)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(192, 47)" end="(192, 50)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(192, 50)" end="(192, 51)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(192, 52)" end="(192, 55)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(192, 52)" end="(192, 55)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(192, 52)" end="(192, 55)">
                                                            <OtherNode start="(192, 52)" end="(192, 55)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(192, 52)" end="(192, 55)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(192, 55)" end="(192, 56)" leading="" trailing="&#10;      " val="⟩"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(193, 7)" end="(193, 11)" kind="Lean.Parser.Tactic.simp" state_before="case nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;w✝¹ w✝ : List β&#10;⊢ zipWith f [] w✝¹ = [] ∧ zipWith f [] w✝ = []" state_after="no goals" tactic="simp">
                                              <AtomNode start="(193, 7)" end="(193, 11)" leading="" trailing="&#10;  " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(194, 3)" end="(225, 52)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(194, 3)" end="(194, 19)">
                              <OtherNode start="(194, 3)" end="(194, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(194, 3)" end="(194, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(194, 5)" end="(194, 9)">
                                  <NullNode/>
                                  <IdentNode start="(194, 5)" end="(194, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(194, 10)" end="(194, 19)">
                                  <IdentNode start="(194, 10)" end="(194, 12)" leading="" trailing=" " raw_val="x₁" val="x₁"/>
                                  <IdentNode start="(194, 13)" end="(194, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(194, 16)" end="(194, 19)" leading="" trailing=" " raw_val="ih₁" val="ih₁"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(194, 20)" end="(225, 52)">
                              <AtomNode start="(194, 20)" end="(194, 22)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(195, 5)" end="(225, 52)">
                                <TacticTacticseq1IndentedNode start="(195, 5)" end="(225, 52)">
                                  <NullNode start="(195, 5)" end="(225, 52)">
                                    <OtherNode start="(195, 5)" end="(225, 52)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;l₂ : List β&#10;⊢ zipWith f (x₁ :: l₁) l₂ = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt;&#10;  constructor&#10;  · simp only [zipWith_nil_right, nil_eq, append_eq_nil_iff, exists_and_left, and_imp]&#10;    rintro rfl  rfl&#10;    exact ⟨[], x₁ :: l₁, [], by simp⟩&#10;  · rintro ⟨_, _, _, _, h₁, _, h₃, rfl, rfl⟩&#10;    simp only [nil_eq, append_eq_nil_iff] at h₃&#10;    obtain ⟨rfl, rfl⟩ := h₃&#10;    simp&#10;| cons x₂ l₂ =&amp;gt;&#10;  simp only [zipWith_cons_cons]&#10;  rw [cons_eq_append_iff]&#10;  constructor&#10;  · rintro (⟨rfl, rfl⟩ | ⟨_, rfl, h⟩)&#10;    · exact ⟨[], x₁ :: l₁, [], x₂ :: l₂, by simp⟩&#10;    · rw [ih₁] at h&#10;      obtain ⟨ws, xs, ys, zs, h, rfl, rfl, h', rfl⟩ := h&#10;      refine ⟨x₁ :: ws, xs, x₂ :: ys, zs, by simp [h, h']⟩&#10;  · rintro ⟨_, _, _, _, h₁, h₂, h₃, rfl, rfl⟩&#10;    rw [cons_eq_append_iff] at h₂&#10;    rw [cons_eq_append_iff] at h₃&#10;    obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₂&#10;    · simp only [zipWith_nil_left, true_and, nil_eq, reduceCtorEq, false_and, exists_const,&#10;      or_false]&#10;      obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;      · simp&#10;      · simp_all&#10;    · obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;      · simp_all&#10;      · simp_all [zipWith_append, Nat.succ_inj]">
                                      <AtomNode start="(195, 5)" end="(195, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(195, 11)" end="(195, 13)">
                                        <OtherNode start="(195, 11)" end="(195, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(195, 11)" end="(195, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(195, 14)" end="(225, 52)">
                                        <OtherNode start="(195, 14)" end="(225, 52)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(195, 14)" end="(195, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(196, 5)" end="(225, 52)">
                                            <OtherNode start="(196, 5)" end="(204, 13)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(196, 5)" end="(196, 10)">
                                                <OtherNode start="(196, 5)" end="(196, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(196, 5)" end="(196, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(196, 7)" end="(196, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(196, 7)" end="(196, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(196, 11)" end="(204, 13)">
                                                <AtomNode start="(196, 11)" end="(196, 13)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(197, 7)" end="(204, 13)">
                                                  <TacticTacticseq1IndentedNode start="(197, 7)" end="(204, 13)">
                                                    <NullNode start="(197, 7)" end="(204, 13)">
                                                      <OtherNode start="(197, 7)" end="(197, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ zipWith f (x₁ :: l₁) [] = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ zipWith f (x₁ :: l₁) [] = l₁' ++ l₂' →&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;&#10;case cons.nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    zipWith f (x₁ :: l₁) [] = l₁' ++ l₂'" tactic="constructor">
                                                        <AtomNode start="(197, 7)" end="(197, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(198, 7)" end="(200, 42)" kind="Lean.cdot" state_before="case cons.nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ zipWith f (x₁ :: l₁) [] = l₁' ++ l₂' →&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;&#10;case cons.nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    zipWith f (x₁ :: l₁) [] = l₁' ++ l₂'" state_after="case cons.nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    zipWith f (x₁ :: l₁) [] = l₁' ++ l₂'" tactic="· simp only [zipWith_nil_right, nil_eq, append_eq_nil_iff, exists_and_left, and_imp]&#10;  rintro rfl  rfl&#10;  exact ⟨[], x₁ :: l₁, [], by simp⟩">
                                                        <OtherNode start="(198, 7)" end="(198, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(198, 7)" end="(198, 8)" kind="patternIgnore">
                                                            <OtherNode start="(198, 7)" end="(198, 8)" kind="token.«· »">
                                                            <AtomNode start="(198, 7)" end="(198, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(198, 9)" end="(200, 42)">
                                                          <TacticTacticseq1IndentedNode start="(198, 9)" end="(200, 42)">
                                                            <NullNode start="(198, 9)" end="(200, 42)">
                                                            <OtherNode start="(198, 9)" end="(198, 91)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ zipWith f (x₁ :: l₁) [] = l₁' ++ l₂' →&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ l₁' = [] →&#10;    l₂' = [] →&#10;      ∃ ws xs ys,&#10;        ws.length = ys.length ∧&#10;          x₁ :: l₁ = ws ++ xs ∧ ∃ x, (ys = [] ∧ x = []) ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x" tactic="simp only [zipWith_nil_right, nil_eq, append_eq_nil_iff, exists_and_left, and_imp]">
                                                            <AtomNode start="(198, 9)" end="(198, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(198, 14)" end="(198, 18)">
                                                            <AtomNode start="(198, 14)" end="(198, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(198, 19)" end="(198, 91)">
                                                            <AtomNode start="(198, 19)" end="(198, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(198, 20)" end="(198, 90)">
                                                            <OtherNode start="(198, 20)" end="(198, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(198, 20)" end="(198, 37)" leading="" trailing="" raw_val="zipWith_nil_right" val="zipWith_nil_right" full_name="List.zipWith_nil_right" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(198, 37)" end="(198, 38)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(198, 39)" end="(198, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(198, 39)" end="(198, 45)" leading="" trailing="" raw_val="nil_eq" val="nil_eq" full_name="List.nil_eq" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(198, 45)" end="(198, 46)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(198, 47)" end="(198, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(198, 47)" end="(198, 64)" leading="" trailing="" raw_val="append_eq_nil_iff" val="append_eq_nil_iff" full_name="List.append_eq_nil_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(198, 64)" end="(198, 65)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(198, 66)" end="(198, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(198, 66)" end="(198, 81)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(198, 81)" end="(198, 82)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(198, 83)" end="(198, 90)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(198, 83)" end="(198, 90)" leading="" trailing="" raw_val="and_imp" val="and_imp" full_name="and_imp" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(198, 90)" end="(198, 91)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(199, 9)" end="(199, 24)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ l₁' = [] →&#10;    l₂' = [] →&#10;      ∃ ws xs ys,&#10;        ws.length = ys.length ∧&#10;          x₁ :: l₁ = ws ++ xs ∧ ∃ x, (ys = [] ∧ x = []) ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs x" state_after="case cons.nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ [] ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ [] = zipWith f xs zs&#10;⊢ ∃ ws xs ys,&#10;    ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ ∃ x, (ys = [] ∧ x = []) ∧ [] = zipWith f ws ys ∧ [] = zipWith f xs x" tactic="rintro rfl  rfl">
                                                            <AtomNode start="(199, 9)" end="(199, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(199, 16)" end="(199, 24)">
                                                            <OtherNode start="(199, 16)" end="(199, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(199, 16)" end="(199, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(199, 16)" end="(199, 19)" leading="" trailing="  " raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <OtherNode start="(199, 21)" end="(199, 24)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(199, 21)" end="(199, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(199, 21)" end="(199, 24)" leading="" trailing="&#10;        " raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(200, 9)" end="(200, 42)" kind="Lean.Parser.Tactic.exact" state_before="case cons.nil.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ [] ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ [] = zipWith f xs zs&#10;⊢ ∃ ws xs ys,&#10;    ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ ∃ x, (ys = [] ∧ x = []) ∧ [] = zipWith f ws ys ∧ [] = zipWith f xs x" state_after="no goals" tactic="exact ⟨[], x₁ :: l₁, [], by simp⟩">
                                                            <AtomNode start="(200, 9)" end="(200, 14)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(200, 15)" end="(200, 42)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(200, 15)" end="(200, 16)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(200, 16)" end="(200, 41)">
                                                            <OtherNode start="(200, 16)" end="(200, 18)" kind="«term[_]»">
                                                            <AtomNode start="(200, 16)" end="(200, 17)" leading="" trailing="" val="["/>
                                                            <NullNode/>
                                                            <AtomNode start="(200, 17)" end="(200, 18)" leading="" trailing="" val="]"/>
                                                            </OtherNode>
                                                            <AtomNode start="(200, 18)" end="(200, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(200, 20)" end="(200, 28)" kind="«term_::_»">
                                                            <IdentNode start="(200, 20)" end="(200, 22)" leading="" trailing=" " raw_val="x₁" val="x₁"/>
                                                            <AtomNode start="(200, 23)" end="(200, 25)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(200, 26)" end="(200, 28)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                            <AtomNode start="(200, 28)" end="(200, 29)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(200, 30)" end="(200, 32)" kind="«term[_]»">
                                                            <AtomNode start="(200, 30)" end="(200, 31)" leading="" trailing="" val="["/>
                                                            <NullNode/>
                                                            <AtomNode start="(200, 31)" end="(200, 32)" leading="" trailing="" val="]"/>
                                                            </OtherNode>
                                                            <AtomNode start="(200, 32)" end="(200, 33)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(200, 34)" end="(200, 41)">
                                                            <AtomNode start="(200, 34)" end="(200, 36)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(200, 37)" end="(200, 41)">
                                                            <TacticTacticseq1IndentedNode start="(200, 37)" end="(200, 41)">
                                                            <NullNode start="(200, 37)" end="(200, 41)">
                                                            <OtherNode start="(200, 37)" end="(200, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ [] ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ [] = zipWith f xs zs&#10;⊢ [].length = [].length ∧&#10;    x₁ :: l₁ = [] ++ x₁ :: l₁ ∧ ∃ x, ([] = [] ∧ x = []) ∧ [] = zipWith f [] [] ∧ [] = zipWith f (x₁ :: l₁) x" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(200, 37)" end="(200, 41)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(200, 41)" end="(200, 42)" leading="" trailing="&#10;      " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(201, 7)" end="(204, 13)" kind="Lean.cdot" state_before="case cons.nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    zipWith f (x₁ :: l₁) [] = l₁' ++ l₂'" state_after="no goals" tactic="· rintro ⟨_, _, _, _, h₁, _, h₃, rfl, rfl⟩&#10;  simp only [nil_eq, append_eq_nil_iff] at h₃&#10;  obtain ⟨rfl, rfl⟩ := h₃&#10;  simp">
                                                        <OtherNode start="(201, 7)" end="(201, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(201, 7)" end="(201, 8)" kind="patternIgnore">
                                                            <OtherNode start="(201, 7)" end="(201, 8)" kind="token.«· »">
                                                            <AtomNode start="(201, 7)" end="(201, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(201, 9)" end="(204, 13)">
                                                          <TacticTacticseq1IndentedNode start="(201, 9)" end="(204, 13)">
                                                            <NullNode start="(201, 9)" end="(204, 13)">
                                                            <OtherNode start="(201, 9)" end="(201, 49)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.nil.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ [] = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    zipWith f (x₁ :: l₁) [] = l₁' ++ l₂'" state_after="case cons.nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;left✝ : x₁ :: l₁ = w✝³ ++ w✝²&#10;h₃ : [] = w✝¹ ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) [] = zipWith f w✝³ w✝¹ ++ zipWith f w✝² w✝" tactic="rintro ⟨_, _, _, _, h₁, _, h₃, rfl, rfl⟩">
                                                            <AtomNode start="(201, 9)" end="(201, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(201, 16)" end="(201, 49)">
                                                            <OtherNode start="(201, 16)" end="(201, 49)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(201, 16)" end="(201, 49)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(201, 16)" end="(201, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(201, 17)" end="(201, 48)">
                                                            <OtherNode start="(201, 17)" end="(201, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 17)" end="(201, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 17)" end="(201, 18)">
                                                            <OtherNode start="(201, 17)" end="(201, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(201, 17)" end="(201, 18)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 18)" end="(201, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 20)" end="(201, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 20)" end="(201, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 20)" end="(201, 21)">
                                                            <OtherNode start="(201, 20)" end="(201, 21)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(201, 20)" end="(201, 21)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 21)" end="(201, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 23)" end="(201, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 23)" end="(201, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 23)" end="(201, 24)">
                                                            <OtherNode start="(201, 23)" end="(201, 24)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(201, 23)" end="(201, 24)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 24)" end="(201, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 26)" end="(201, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 26)" end="(201, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 26)" end="(201, 27)">
                                                            <OtherNode start="(201, 26)" end="(201, 27)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(201, 26)" end="(201, 27)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 27)" end="(201, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 29)" end="(201, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 29)" end="(201, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 29)" end="(201, 31)">
                                                            <OtherNode start="(201, 29)" end="(201, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(201, 29)" end="(201, 31)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 31)" end="(201, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 33)" end="(201, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 33)" end="(201, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 33)" end="(201, 34)">
                                                            <OtherNode start="(201, 33)" end="(201, 34)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(201, 33)" end="(201, 34)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 34)" end="(201, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 36)" end="(201, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 36)" end="(201, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 36)" end="(201, 38)">
                                                            <OtherNode start="(201, 36)" end="(201, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(201, 36)" end="(201, 38)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 38)" end="(201, 39)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 40)" end="(201, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 40)" end="(201, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 40)" end="(201, 43)">
                                                            <OtherNode start="(201, 40)" end="(201, 43)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(201, 40)" end="(201, 43)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(201, 43)" end="(201, 44)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(201, 45)" end="(201, 48)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(201, 45)" end="(201, 48)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(201, 45)" end="(201, 48)">
                                                            <OtherNode start="(201, 45)" end="(201, 48)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(201, 45)" end="(201, 48)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(201, 48)" end="(201, 49)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(202, 9)" end="(202, 52)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;left✝ : x₁ :: l₁ = w✝³ ++ w✝²&#10;h₃ : [] = w✝¹ ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) [] = zipWith f w✝³ w✝¹ ++ zipWith f w✝² w✝" state_after="case cons.nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;left✝ : x₁ :: l₁ = w✝³ ++ w✝²&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;h₃ : w✝¹ = [] ∧ w✝ = []&#10;⊢ zipWith f (x₁ :: l₁) [] = zipWith f w✝³ w✝¹ ++ zipWith f w✝² w✝" tactic="simp only [nil_eq, append_eq_nil_iff] at h₃">
                                                            <AtomNode start="(202, 9)" end="(202, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(202, 14)" end="(202, 18)">
                                                            <AtomNode start="(202, 14)" end="(202, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(202, 19)" end="(202, 46)">
                                                            <AtomNode start="(202, 19)" end="(202, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(202, 20)" end="(202, 45)">
                                                            <OtherNode start="(202, 20)" end="(202, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(202, 20)" end="(202, 26)" leading="" trailing="" raw_val="nil_eq" val="nil_eq" full_name="List.nil_eq" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(202, 26)" end="(202, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(202, 28)" end="(202, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(202, 28)" end="(202, 45)" leading="" trailing="" raw_val="append_eq_nil_iff" val="append_eq_nil_iff" full_name="List.append_eq_nil_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(202, 45)" end="(202, 46)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(202, 47)" end="(202, 52)">
                                                            <OtherNode start="(202, 47)" end="(202, 52)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(202, 47)" end="(202, 49)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(202, 50)" end="(202, 52)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(202, 50)" end="(202, 52)">
                                                            <IdentNode start="(202, 50)" end="(202, 52)" leading="" trailing="&#10;        " raw_val="h₃" val="h₃"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(203, 9)" end="(203, 32)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;left✝ : x₁ :: l₁ = w✝³ ++ w✝²&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;h₃ : w✝¹ = [] ∧ w✝ = []&#10;⊢ zipWith f (x₁ :: l₁) [] = zipWith f w✝³ w✝¹ ++ zipWith f w✝² w✝" state_after="case cons.nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ w✝¹ w✝ : List α&#10;left✝ : x₁ :: l₁ = w✝¹ ++ w✝&#10;h₁ : w✝¹.length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝ [] ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝ [] = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) [] = zipWith f w✝¹ [] ++ zipWith f w✝ []" tactic="obtain ⟨rfl, rfl⟩ := h₃">
                                                            <AtomNode start="(203, 9)" end="(203, 15)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(203, 16)" end="(203, 26)">
                                                            <OtherNode start="(203, 16)" end="(203, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(203, 16)" end="(203, 26)">
                                                            <OtherNode start="(203, 16)" end="(203, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(203, 16)" end="(203, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(203, 17)" end="(203, 25)">
                                                            <OtherNode start="(203, 17)" end="(203, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(203, 17)" end="(203, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(203, 17)" end="(203, 20)">
                                                            <OtherNode start="(203, 17)" end="(203, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(203, 17)" end="(203, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(203, 20)" end="(203, 21)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(203, 22)" end="(203, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(203, 22)" end="(203, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(203, 22)" end="(203, 25)">
                                                            <OtherNode start="(203, 22)" end="(203, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(203, 22)" end="(203, 25)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(203, 25)" end="(203, 26)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(203, 27)" end="(203, 32)">
                                                            <AtomNode start="(203, 27)" end="(203, 29)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(203, 30)" end="(203, 32)">
                                                            <IdentNode start="(203, 30)" end="(203, 32)" leading="" trailing="&#10;        " raw_val="h₃" val="h₃"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(204, 9)" end="(204, 13)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil.mpr.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ w✝¹ w✝ : List α&#10;left✝ : x₁ :: l₁ = w✝¹ ++ w✝&#10;h₁ : w✝¹.length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝ [] ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝ [] = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) [] = zipWith f w✝¹ [] ++ zipWith f w✝ []" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(204, 9)" end="(204, 13)" leading="" trailing="&#10;    " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(205, 5)" end="(225, 52)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(205, 5)" end="(205, 17)">
                                                <OtherNode start="(205, 5)" end="(205, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(205, 5)" end="(205, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(205, 7)" end="(205, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(205, 7)" end="(205, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(205, 12)" end="(205, 17)">
                                                    <IdentNode start="(205, 12)" end="(205, 14)" leading="" trailing=" " raw_val="x₂" val="x₂"/>
                                                    <IdentNode start="(205, 15)" end="(205, 17)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(205, 18)" end="(225, 52)">
                                                <AtomNode start="(205, 18)" end="(205, 20)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(206, 7)" end="(225, 52)">
                                                  <TacticTacticseq1IndentedNode start="(206, 7)" end="(225, 52)">
                                                    <NullNode start="(206, 7)" end="(225, 52)">
                                                      <OtherNode start="(206, 7)" end="(206, 36)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ zipWith f (x₁ :: l₁) (x₂ :: l₂) = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ f x₁ x₂ :: zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" tactic="simp only [zipWith_cons_cons]">
                                                        <AtomNode start="(206, 7)" end="(206, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(206, 12)" end="(206, 16)">
                                                          <AtomNode start="(206, 12)" end="(206, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(206, 17)" end="(206, 36)">
                                                          <AtomNode start="(206, 17)" end="(206, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(206, 18)" end="(206, 35)">
                                                            <OtherNode start="(206, 18)" end="(206, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(206, 18)" end="(206, 35)" leading="" trailing="" raw_val="zipWith_cons_cons" val="zipWith_cons_cons" full_name="List.zipWith_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(206, 35)" end="(206, 36)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(207, 7)" end="(207, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ f x₁ x₂ :: zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂') ↔&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" tactic="rw [cons_eq_append_iff]">
                                                        <AtomNode start="(207, 7)" end="(207, 9)" leading="" trailing=" " val="rw"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <OtherNode start="(207, 10)" end="(207, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                          <AtomNode start="(207, 10)" end="(207, 11)" leading="" trailing="" val="["/>
                                                          <NullNode start="(207, 11)" end="(207, 29)">
                                                            <OtherNode start="(207, 11)" end="(207, 29)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(207, 11)" end="(207, 29)" leading="" trailing="" raw_val="cons_eq_append_iff" val="cons_eq_append_iff" full_name="List.cons_eq_append_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(207, 29)" end="(207, 30)" leading="" trailing="&#10;      " val="]"/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(208, 7)" end="(208, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂') ↔&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.cons.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂') →&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;&#10;case cons.cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧&#10;        x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂'" tactic="constructor">
                                                        <AtomNode start="(208, 7)" end="(208, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(209, 7)" end="(213, 63)" kind="Lean.cdot" state_before="case cons.cons.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂') →&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;&#10;case cons.cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧&#10;        x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂'" state_after="case cons.cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧&#10;        x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂'" tactic="· rintro (⟨rfl, rfl⟩ | ⟨_, rfl, h⟩)&#10;  · exact ⟨[], x₁ :: l₁, [], x₂ :: l₂, by simp⟩&#10;  · rw [ih₁] at h&#10;    obtain ⟨ws, xs, ys, zs, h, rfl, rfl, h', rfl⟩ := h&#10;    refine ⟨x₁ :: ws, xs, x₂ :: ys, zs, by simp [h, h']⟩">
                                                        <OtherNode start="(209, 7)" end="(209, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(209, 7)" end="(209, 8)" kind="patternIgnore">
                                                            <OtherNode start="(209, 7)" end="(209, 8)" kind="token.«· »">
                                                            <AtomNode start="(209, 7)" end="(209, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(209, 9)" end="(213, 63)">
                                                          <TacticTacticseq1IndentedNode start="(209, 9)" end="(213, 63)">
                                                            <NullNode start="(209, 9)" end="(213, 63)">
                                                            <OtherNode start="(209, 9)" end="(209, 42)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.cons.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂') →&#10;    ∃ ws xs ys zs,&#10;      ws.length = ys.length ∧ x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.cons.mp.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f l₁ l₂_1 = l₁' ++ f x₁ x₂ :: zipWith f l₁ l₂ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f xs zs&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ [] = zipWith f ws ys ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f xs zs&#10;&#10;case cons.cons.mp.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;x₂ : β&#10;l₂ : List β&#10;w✝ : List γ&#10;h : zipWith f l₁ l₂ = w✝ ++ l₂'&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ f x₁ x₂ :: w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs" tactic="rintro (⟨rfl, rfl⟩ | ⟨_, rfl, h⟩)">
                                                            <AtomNode start="(209, 9)" end="(209, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(209, 16)" end="(209, 42)">
                                                            <OtherNode start="(209, 16)" end="(209, 42)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(209, 16)" end="(209, 42)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(209, 16)" end="(209, 17)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(209, 17)" end="(209, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(209, 17)" end="(209, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(209, 17)" end="(209, 41)">
                                                            <OtherNode start="(209, 17)" end="(209, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(209, 17)" end="(209, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(209, 18)" end="(209, 26)">
                                                            <OtherNode start="(209, 18)" end="(209, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(209, 18)" end="(209, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(209, 18)" end="(209, 21)">
                                                            <OtherNode start="(209, 18)" end="(209, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(209, 18)" end="(209, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(209, 21)" end="(209, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(209, 23)" end="(209, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(209, 23)" end="(209, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(209, 23)" end="(209, 26)">
                                                            <OtherNode start="(209, 23)" end="(209, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(209, 23)" end="(209, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(209, 26)" end="(209, 27)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(209, 28)" end="(209, 29)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(209, 30)" end="(209, 41)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(209, 30)" end="(209, 31)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(209, 31)" end="(209, 40)">
                                                            <OtherNode start="(209, 31)" end="(209, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(209, 31)" end="(209, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(209, 31)" end="(209, 32)">
                                                            <OtherNode start="(209, 31)" end="(209, 32)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(209, 31)" end="(209, 32)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(209, 32)" end="(209, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(209, 34)" end="(209, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(209, 34)" end="(209, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(209, 34)" end="(209, 37)">
                                                            <OtherNode start="(209, 34)" end="(209, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(209, 34)" end="(209, 37)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(209, 37)" end="(209, 38)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(209, 39)" end="(209, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(209, 39)" end="(209, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(209, 39)" end="(209, 40)">
                                                            <OtherNode start="(209, 39)" end="(209, 40)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(209, 39)" end="(209, 40)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(209, 40)" end="(209, 41)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(209, 41)" end="(209, 42)" leading="" trailing="&#10;        " val=")"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(210, 9)" end="(210, 54)" kind="Lean.cdot" state_before="case cons.cons.mp.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f l₁ l₂_1 = l₁' ++ f x₁ x₂ :: zipWith f l₁ l₂ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f xs zs&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ [] = zipWith f ws ys ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f xs zs&#10;&#10;case cons.cons.mp.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;x₂ : β&#10;l₂ : List β&#10;w✝ : List γ&#10;h : zipWith f l₁ l₂ = w✝ ++ l₂'&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ f x₁ x₂ :: w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.cons.mp.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;x₂ : β&#10;l₂ : List β&#10;w✝ : List γ&#10;h : zipWith f l₁ l₂ = w✝ ++ l₂'&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ f x₁ x₂ :: w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs" tactic="· exact ⟨[], x₁ :: l₁, [], x₂ :: l₂, by simp⟩">
                                                            <OtherNode start="(210, 9)" end="(210, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(210, 9)" end="(210, 10)" kind="patternIgnore">
                                                            <OtherNode start="(210, 9)" end="(210, 10)" kind="token.«· »">
                                                            <AtomNode start="(210, 9)" end="(210, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(210, 11)" end="(210, 54)">
                                                            <TacticTacticseq1IndentedNode start="(210, 11)" end="(210, 54)">
                                                            <NullNode start="(210, 11)" end="(210, 54)">
                                                            <OtherNode start="(210, 11)" end="(210, 54)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.mp.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f l₁ l₂_1 = l₁' ++ f x₁ x₂ :: zipWith f l₁ l₂ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f xs zs&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ [] = zipWith f ws ys ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f xs zs" state_after="no goals" tactic="exact ⟨[], x₁ :: l₁, [], x₂ :: l₂, by simp⟩">
                                                            <AtomNode start="(210, 11)" end="(210, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(210, 17)" end="(210, 54)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(210, 17)" end="(210, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(210, 18)" end="(210, 53)">
                                                            <OtherNode start="(210, 18)" end="(210, 20)" kind="«term[_]»">
                                                            <AtomNode start="(210, 18)" end="(210, 19)" leading="" trailing="" val="["/>
                                                            <NullNode/>
                                                            <AtomNode start="(210, 19)" end="(210, 20)" leading="" trailing="" val="]"/>
                                                            </OtherNode>
                                                            <AtomNode start="(210, 20)" end="(210, 21)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(210, 22)" end="(210, 30)" kind="«term_::_»">
                                                            <IdentNode start="(210, 22)" end="(210, 24)" leading="" trailing=" " raw_val="x₁" val="x₁"/>
                                                            <AtomNode start="(210, 25)" end="(210, 27)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(210, 28)" end="(210, 30)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                            <AtomNode start="(210, 30)" end="(210, 31)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(210, 32)" end="(210, 34)" kind="«term[_]»">
                                                            <AtomNode start="(210, 32)" end="(210, 33)" leading="" trailing="" val="["/>
                                                            <NullNode/>
                                                            <AtomNode start="(210, 33)" end="(210, 34)" leading="" trailing="" val="]"/>
                                                            </OtherNode>
                                                            <AtomNode start="(210, 34)" end="(210, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(210, 36)" end="(210, 44)" kind="«term_::_»">
                                                            <IdentNode start="(210, 36)" end="(210, 38)" leading="" trailing=" " raw_val="x₂" val="x₂"/>
                                                            <AtomNode start="(210, 39)" end="(210, 41)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(210, 42)" end="(210, 44)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                            </OtherNode>
                                                            <AtomNode start="(210, 44)" end="(210, 45)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(210, 46)" end="(210, 53)">
                                                            <AtomNode start="(210, 46)" end="(210, 48)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(210, 49)" end="(210, 53)">
                                                            <TacticTacticseq1IndentedNode start="(210, 49)" end="(210, 53)">
                                                            <NullNode start="(210, 49)" end="(210, 53)">
                                                            <OtherNode start="(210, 49)" end="(210, 53)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f l₁ l₂_1 = l₁' ++ f x₁ x₂ :: zipWith f l₁ l₂ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f xs zs&#10;⊢ [].length = [].length ∧&#10;    x₁ :: l₁ = [] ++ x₁ :: l₁ ∧&#10;      x₂ :: l₂ = [] ++ x₂ :: l₂ ∧ [] = zipWith f [] [] ∧ f x₁ x₂ :: zipWith f l₁ l₂ = zipWith f (x₁ :: l₁) (x₂ :: l₂)" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(210, 49)" end="(210, 53)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(210, 53)" end="(210, 54)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(211, 9)" end="(213, 63)" kind="Lean.cdot" state_before="case cons.cons.mp.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;x₂ : β&#10;l₂ : List β&#10;w✝ : List γ&#10;h : zipWith f l₁ l₂ = w✝ ++ l₂'&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ f x₁ x₂ :: w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="no goals" tactic="· rw [ih₁] at h&#10;  obtain ⟨ws, xs, ys, zs, h, rfl, rfl, h', rfl⟩ := h&#10;  refine ⟨x₁ :: ws, xs, x₂ :: ys, zs, by simp [h, h']⟩">
                                                            <OtherNode start="(211, 9)" end="(211, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(211, 9)" end="(211, 10)" kind="patternIgnore">
                                                            <OtherNode start="(211, 9)" end="(211, 10)" kind="token.«· »">
                                                            <AtomNode start="(211, 9)" end="(211, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(211, 11)" end="(213, 63)">
                                                            <TacticTacticseq1IndentedNode start="(211, 11)" end="(213, 63)">
                                                            <NullNode start="(211, 11)" end="(213, 63)">
                                                            <OtherNode start="(211, 11)" end="(211, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons.mp.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;x₂ : β&#10;l₂ : List β&#10;w✝ : List γ&#10;h : zipWith f l₁ l₂ = w✝ ++ l₂'&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ f x₁ x₂ :: w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.cons.mp.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;x₂ : β&#10;l₂ : List β&#10;w✝ : List γ&#10;h : ∃ ws xs ys zs, ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ f x₁ x₂ :: w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs" tactic="rw [ih₁] at h">
                                                            <AtomNode start="(211, 11)" end="(211, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(211, 14)" end="(211, 19)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(211, 14)" end="(211, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(211, 15)" end="(211, 18)">
                                                            <OtherNode start="(211, 15)" end="(211, 18)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(211, 15)" end="(211, 18)" leading="" trailing="" raw_val="ih₁" val="ih₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(211, 18)" end="(211, 19)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(211, 20)" end="(211, 24)">
                                                            <OtherNode start="(211, 20)" end="(211, 24)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(211, 20)" end="(211, 22)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(211, 23)" end="(211, 24)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(211, 23)" end="(211, 24)">
                                                            <IdentNode start="(211, 23)" end="(211, 24)" leading="" trailing="&#10;          " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(212, 11)" end="(212, 61)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.cons.mp.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;x₂ : β&#10;l₂ : List β&#10;w✝ : List γ&#10;h : ∃ ws xs ys zs, ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;⊢ ∃ ws xs ys zs,&#10;    ws.length = ys.length ∧&#10;      x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ f x₁ x₂ :: w✝ = zipWith f ws ys ∧ l₂' = zipWith f xs zs" state_after="case cons.cons.mp.inr.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝ : List γ&#10;ws xs : List α&#10;ys zs : List β&#10;h : ws.length = ys.length&#10;h' : w✝ = zipWith f ws ys&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (ws ++ xs) l₂ = l₁' ++ zipWith f xs zs ↔&#10;      ∃ ws_1 xs_1 ys zs_1,&#10;        ws_1.length = ys.length ∧&#10;          ws ++ xs = ws_1 ++ xs_1 ∧ l₂ = ys ++ zs_1 ∧ l₁' = zipWith f ws_1 ys ∧ zipWith f xs zs = zipWith f xs_1 zs_1&#10;⊢ ∃ ws_1 xs_1 ys_1 zs_1,&#10;    ws_1.length = ys_1.length ∧&#10;      x₁ :: (ws ++ xs) = ws_1 ++ xs_1 ∧&#10;        x₂ :: (ys ++ zs) = ys_1 ++ zs_1 ∧ f x₁ x₂ :: w✝ = zipWith f ws_1 ys_1 ∧ zipWith f xs zs = zipWith f xs_1 zs_1" tactic="obtain ⟨ws, xs, ys, zs, h, rfl, rfl, h', rfl⟩ := h">
                                                            <AtomNode start="(212, 11)" end="(212, 17)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(212, 18)" end="(212, 56)">
                                                            <OtherNode start="(212, 18)" end="(212, 56)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 18)" end="(212, 56)">
                                                            <OtherNode start="(212, 18)" end="(212, 56)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(212, 18)" end="(212, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(212, 19)" end="(212, 55)">
                                                            <OtherNode start="(212, 19)" end="(212, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 19)" end="(212, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 19)" end="(212, 21)">
                                                            <OtherNode start="(212, 19)" end="(212, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 19)" end="(212, 21)" leading="" trailing="" raw_val="ws" val="ws"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 21)" end="(212, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 23)" end="(212, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 23)" end="(212, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 23)" end="(212, 25)">
                                                            <OtherNode start="(212, 23)" end="(212, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 23)" end="(212, 25)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 25)" end="(212, 26)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 27)" end="(212, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 27)" end="(212, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 27)" end="(212, 29)">
                                                            <OtherNode start="(212, 27)" end="(212, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 27)" end="(212, 29)" leading="" trailing="" raw_val="ys" val="ys"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 29)" end="(212, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 31)" end="(212, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 31)" end="(212, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 31)" end="(212, 33)">
                                                            <OtherNode start="(212, 31)" end="(212, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 31)" end="(212, 33)" leading="" trailing="" raw_val="zs" val="zs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 33)" end="(212, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 35)" end="(212, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 35)" end="(212, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 35)" end="(212, 36)">
                                                            <OtherNode start="(212, 35)" end="(212, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 35)" end="(212, 36)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 36)" end="(212, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 38)" end="(212, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 38)" end="(212, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 38)" end="(212, 41)">
                                                            <OtherNode start="(212, 38)" end="(212, 41)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 38)" end="(212, 41)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 41)" end="(212, 42)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 43)" end="(212, 46)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 43)" end="(212, 46)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 43)" end="(212, 46)">
                                                            <OtherNode start="(212, 43)" end="(212, 46)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 43)" end="(212, 46)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 46)" end="(212, 47)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 48)" end="(212, 50)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 48)" end="(212, 50)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 48)" end="(212, 50)">
                                                            <OtherNode start="(212, 48)" end="(212, 50)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 48)" end="(212, 50)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(212, 50)" end="(212, 51)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(212, 52)" end="(212, 55)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(212, 52)" end="(212, 55)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(212, 52)" end="(212, 55)">
                                                            <OtherNode start="(212, 52)" end="(212, 55)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(212, 52)" end="(212, 55)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(212, 55)" end="(212, 56)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(212, 57)" end="(212, 61)">
                                                            <AtomNode start="(212, 57)" end="(212, 59)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(212, 60)" end="(212, 61)">
                                                            <IdentNode start="(212, 60)" end="(212, 61)" leading="" trailing="&#10;          " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(213, 11)" end="(213, 63)" kind="Lean.Parser.Tactic.refine" state_before="case cons.cons.mp.inr.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝ : List γ&#10;ws xs : List α&#10;ys zs : List β&#10;h : ws.length = ys.length&#10;h' : w✝ = zipWith f ws ys&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (ws ++ xs) l₂ = l₁' ++ zipWith f xs zs ↔&#10;      ∃ ws_1 xs_1 ys zs_1,&#10;        ws_1.length = ys.length ∧&#10;          ws ++ xs = ws_1 ++ xs_1 ∧ l₂ = ys ++ zs_1 ∧ l₁' = zipWith f ws_1 ys ∧ zipWith f xs zs = zipWith f xs_1 zs_1&#10;⊢ ∃ ws_1 xs_1 ys_1 zs_1,&#10;    ws_1.length = ys_1.length ∧&#10;      x₁ :: (ws ++ xs) = ws_1 ++ xs_1 ∧&#10;        x₂ :: (ys ++ zs) = ys_1 ++ zs_1 ∧ f x₁ x₂ :: w✝ = zipWith f ws_1 ys_1 ∧ zipWith f xs zs = zipWith f xs_1 zs_1" state_after="no goals" tactic="refine ⟨x₁ :: ws, xs, x₂ :: ys, zs, by simp [h, h']⟩">
                                                            <AtomNode start="(213, 11)" end="(213, 17)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(213, 18)" end="(213, 63)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(213, 18)" end="(213, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(213, 19)" end="(213, 62)">
                                                            <OtherNode start="(213, 19)" end="(213, 27)" kind="«term_::_»">
                                                            <IdentNode start="(213, 19)" end="(213, 21)" leading="" trailing=" " raw_val="x₁" val="x₁"/>
                                                            <AtomNode start="(213, 22)" end="(213, 24)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(213, 25)" end="(213, 27)" leading="" trailing="" raw_val="ws" val="ws"/>
                                                            </OtherNode>
                                                            <AtomNode start="(213, 27)" end="(213, 28)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(213, 29)" end="(213, 31)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            <AtomNode start="(213, 31)" end="(213, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(213, 33)" end="(213, 41)" kind="«term_::_»">
                                                            <IdentNode start="(213, 33)" end="(213, 35)" leading="" trailing=" " raw_val="x₂" val="x₂"/>
                                                            <AtomNode start="(213, 36)" end="(213, 38)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(213, 39)" end="(213, 41)" leading="" trailing="" raw_val="ys" val="ys"/>
                                                            </OtherNode>
                                                            <AtomNode start="(213, 41)" end="(213, 42)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(213, 43)" end="(213, 45)" leading="" trailing="" raw_val="zs" val="zs"/>
                                                            <AtomNode start="(213, 45)" end="(213, 46)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(213, 47)" end="(213, 62)">
                                                            <AtomNode start="(213, 47)" end="(213, 49)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(213, 50)" end="(213, 62)">
                                                            <TacticTacticseq1IndentedNode start="(213, 50)" end="(213, 62)">
                                                            <NullNode start="(213, 50)" end="(213, 62)">
                                                            <OtherNode start="(213, 50)" end="(213, 62)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝ : List γ&#10;ws xs : List α&#10;ys zs : List β&#10;h : ws.length = ys.length&#10;h' : w✝ = zipWith f ws ys&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (ws ++ xs) l₂ = l₁' ++ zipWith f xs zs ↔&#10;      ∃ ws_1 xs_1 ys zs_1,&#10;        ws_1.length = ys.length ∧&#10;          ws ++ xs = ws_1 ++ xs_1 ∧ l₂ = ys ++ zs_1 ∧ l₁' = zipWith f ws_1 ys ∧ zipWith f xs zs = zipWith f xs_1 zs_1&#10;⊢ (x₁ :: ws).length = (x₂ :: ys).length ∧&#10;    x₁ :: (ws ++ xs) = x₁ :: ws ++ xs ∧&#10;      x₂ :: (ys ++ zs) = x₂ :: ys ++ zs ∧&#10;        f x₁ x₂ :: w✝ = zipWith f (x₁ :: ws) (x₂ :: ys) ∧ zipWith f xs zs = zipWith f xs zs" state_after="no goals" tactic="simp [h, h']">
                                                            <AtomNode start="(213, 50)" end="(213, 54)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(213, 55)" end="(213, 62)">
                                                            <AtomNode start="(213, 55)" end="(213, 56)" leading="" trailing="" val="["/>
                                                            <NullNode start="(213, 56)" end="(213, 61)">
                                                            <OtherNode start="(213, 56)" end="(213, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(213, 56)" end="(213, 57)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            <AtomNode start="(213, 57)" end="(213, 58)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(213, 59)" end="(213, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(213, 59)" end="(213, 61)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(213, 61)" end="(213, 62)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(213, 62)" end="(213, 63)" leading="" trailing="&#10;      " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(214, 7)" end="(225, 52)" kind="Lean.cdot" state_before="case cons.cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧&#10;        x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂'" state_after="no goals" tactic="· rintro ⟨_, _, _, _, h₁, h₂, h₃, rfl, rfl⟩&#10;  rw [cons_eq_append_iff] at h₂&#10;  rw [cons_eq_append_iff] at h₃&#10;  obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₂&#10;  · simp only [zipWith_nil_left, true_and, nil_eq, reduceCtorEq, false_and, exists_const,&#10;    or_false]&#10;    obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;    · simp&#10;    · simp_all&#10;  · obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;    · simp_all&#10;    · simp_all [zipWith_append, Nat.succ_inj]">
                                                        <OtherNode start="(214, 7)" end="(214, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(214, 7)" end="(214, 8)" kind="patternIgnore">
                                                            <OtherNode start="(214, 7)" end="(214, 8)" kind="token.«· »">
                                                            <AtomNode start="(214, 7)" end="(214, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(214, 9)" end="(225, 52)">
                                                          <TacticTacticseq1IndentedNode start="(214, 9)" end="(225, 52)">
                                                            <NullNode start="(214, 9)" end="(225, 52)">
                                                            <OtherNode start="(214, 9)" end="(214, 50)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l₂' : List γ&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ l₂' ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs&#10;l₁' : List γ&#10;x₂ : β&#10;l₂ : List β&#10;⊢ (∃ ws xs ys zs,&#10;      ws.length = ys.length ∧&#10;        x₁ :: l₁ = ws ++ xs ∧ x₂ :: l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ l₂' = zipWith f xs zs) →&#10;    l₁' = [] ∧ l₂' = f x₁ x₂ :: zipWith f l₁ l₂ ∨ ∃ as', l₁' = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ l₂'" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;h₂ : x₁ :: l₁ = w✝³ ++ w✝²&#10;h₃ : x₂ :: l₂ = w✝¹ ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f w✝³ w✝¹ = [] ∧ zipWith f w✝² w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f w✝³ w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f w✝² w✝" tactic="rintro ⟨_, _, _, _, h₁, h₂, h₃, rfl, rfl⟩">
                                                            <AtomNode start="(214, 9)" end="(214, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(214, 16)" end="(214, 50)">
                                                            <OtherNode start="(214, 16)" end="(214, 50)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(214, 16)" end="(214, 50)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(214, 16)" end="(214, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(214, 17)" end="(214, 49)">
                                                            <OtherNode start="(214, 17)" end="(214, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 17)" end="(214, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 17)" end="(214, 18)">
                                                            <OtherNode start="(214, 17)" end="(214, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(214, 17)" end="(214, 18)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 18)" end="(214, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 20)" end="(214, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 20)" end="(214, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 20)" end="(214, 21)">
                                                            <OtherNode start="(214, 20)" end="(214, 21)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(214, 20)" end="(214, 21)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 21)" end="(214, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 23)" end="(214, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 23)" end="(214, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 23)" end="(214, 24)">
                                                            <OtherNode start="(214, 23)" end="(214, 24)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(214, 23)" end="(214, 24)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 24)" end="(214, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 26)" end="(214, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 26)" end="(214, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 26)" end="(214, 27)">
                                                            <OtherNode start="(214, 26)" end="(214, 27)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(214, 26)" end="(214, 27)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 27)" end="(214, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 29)" end="(214, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 29)" end="(214, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 29)" end="(214, 31)">
                                                            <OtherNode start="(214, 29)" end="(214, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(214, 29)" end="(214, 31)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 31)" end="(214, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 33)" end="(214, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 33)" end="(214, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 33)" end="(214, 35)">
                                                            <OtherNode start="(214, 33)" end="(214, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(214, 33)" end="(214, 35)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 35)" end="(214, 36)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 37)" end="(214, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 37)" end="(214, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 37)" end="(214, 39)">
                                                            <OtherNode start="(214, 37)" end="(214, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(214, 37)" end="(214, 39)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 39)" end="(214, 40)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 41)" end="(214, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 41)" end="(214, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 41)" end="(214, 44)">
                                                            <OtherNode start="(214, 41)" end="(214, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(214, 41)" end="(214, 44)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(214, 44)" end="(214, 45)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(214, 46)" end="(214, 49)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(214, 46)" end="(214, 49)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(214, 46)" end="(214, 49)">
                                                            <OtherNode start="(214, 46)" end="(214, 49)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(214, 46)" end="(214, 49)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(214, 49)" end="(214, 50)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(215, 9)" end="(215, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;h₂ : x₁ :: l₁ = w✝³ ++ w✝²&#10;h₃ : x₂ :: l₂ = w✝¹ ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f w✝³ w✝¹ = [] ∧ zipWith f w✝² w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f w✝³ w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f w✝² w✝" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;h₂ : w✝³ = [] ∧ w✝² = x₁ :: l₁ ∨ ∃ as', w✝³ = x₁ :: as' ∧ l₁ = as' ++ w✝²&#10;h₃ : x₂ :: l₂ = w✝¹ ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f w✝³ w✝¹ = [] ∧ zipWith f w✝² w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f w✝³ w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f w✝² w✝" tactic="rw [cons_eq_append_iff] at h₂">
                                                            <AtomNode start="(215, 9)" end="(215, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(215, 12)" end="(215, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(215, 12)" end="(215, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(215, 13)" end="(215, 31)">
                                                            <OtherNode start="(215, 13)" end="(215, 31)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(215, 13)" end="(215, 31)" leading="" trailing="" raw_val="cons_eq_append_iff" val="cons_eq_append_iff" full_name="List.cons_eq_append_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(215, 31)" end="(215, 32)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(215, 33)" end="(215, 38)">
                                                            <OtherNode start="(215, 33)" end="(215, 38)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(215, 33)" end="(215, 35)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(215, 36)" end="(215, 38)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(215, 36)" end="(215, 38)">
                                                            <IdentNode start="(215, 36)" end="(215, 38)" leading="" trailing="&#10;        " raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(216, 9)" end="(216, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;h₂ : w✝³ = [] ∧ w✝² = x₁ :: l₁ ∨ ∃ as', w✝³ = x₁ :: as' ∧ l₁ = as' ++ w✝²&#10;h₃ : x₂ :: l₂ = w✝¹ ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f w✝³ w✝¹ = [] ∧ zipWith f w✝² w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f w✝³ w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f w✝² w✝" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;h₂ : w✝³ = [] ∧ w✝² = x₁ :: l₁ ∨ ∃ as', w✝³ = x₁ :: as' ∧ l₁ = as' ++ w✝²&#10;h₃ : w✝¹ = [] ∧ w✝ = x₂ :: l₂ ∨ ∃ as', w✝¹ = x₂ :: as' ∧ l₂ = as' ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f w✝³ w✝¹ = [] ∧ zipWith f w✝² w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f w✝³ w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f w✝² w✝" tactic="rw [cons_eq_append_iff] at h₃">
                                                            <AtomNode start="(216, 9)" end="(216, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(216, 12)" end="(216, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(216, 12)" end="(216, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(216, 13)" end="(216, 31)">
                                                            <OtherNode start="(216, 13)" end="(216, 31)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(216, 13)" end="(216, 31)" leading="" trailing="" raw_val="cons_eq_append_iff" val="cons_eq_append_iff" full_name="List.cons_eq_append_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(216, 31)" end="(216, 32)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(216, 33)" end="(216, 38)">
                                                            <OtherNode start="(216, 33)" end="(216, 38)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(216, 33)" end="(216, 35)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(216, 36)" end="(216, 38)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(216, 36)" end="(216, 38)">
                                                            <IdentNode start="(216, 36)" end="(216, 38)" leading="" trailing="&#10;        " raw_val="h₃" val="h₃"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(217, 9)" end="(217, 50)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ w✝² : List α&#10;w✝¹ w✝ : List β&#10;h₁ : w✝³.length = w✝¹.length&#10;h₂ : w✝³ = [] ∧ w✝² = x₁ :: l₁ ∨ ∃ as', w✝³ = x₁ :: as' ∧ l₁ = as' ++ w✝²&#10;h₃ : w✝¹ = [] ∧ w✝ = x₂ :: l₂ ∨ ∃ as', w✝¹ = x₂ :: as' ∧ l₂ = as' ++ w✝&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f w✝² w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝² w✝ = zipWith f xs zs&#10;⊢ zipWith f w✝³ w✝¹ = [] ∧ zipWith f w✝² w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f w✝³ w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f w✝² w✝" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ w✝¹ w✝ : List β&#10;h₃ : w✝¹ = [] ∧ w✝ = x₂ :: l₂ ∨ ∃ as', w✝¹ = x₂ :: as' ∧ l₂ = as' ++ w✝&#10;h₁ : [].length = w✝¹.length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝ = zipWith f xs zs&#10;⊢ zipWith f [] w✝¹ = [] ∧ zipWith f (x₁ :: l₁) w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f [] w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f (x₁ :: l₁) w✝&#10;&#10;case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ : List α&#10;w✝² w✝¹ : List β&#10;h₃ : w✝² = [] ∧ w✝¹ = x₂ :: l₂ ∨ ∃ as', w✝² = x₂ :: as' ∧ l₂ = as' ++ w✝¹&#10;w✝ : List α&#10;h₁ : (x₁ :: w✝).length = w✝².length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝¹ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) w✝² = [] ∧ zipWith f w✝³ w✝¹ = f x₁ x₂ :: zipWith f (w✝ ++ w✝³) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) w✝² = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝³) l₂ = as' ++ zipWith f w✝³ w✝¹" tactic="obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₂">
                                                            <AtomNode start="(217, 9)" end="(217, 15)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(217, 16)" end="(217, 44)">
                                                            <OtherNode start="(217, 16)" end="(217, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(217, 16)" end="(217, 44)">
                                                            <OtherNode start="(217, 16)" end="(217, 44)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(217, 16)" end="(217, 17)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(217, 17)" end="(217, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(217, 17)" end="(217, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(217, 17)" end="(217, 43)">
                                                            <OtherNode start="(217, 17)" end="(217, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(217, 17)" end="(217, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(217, 18)" end="(217, 26)">
                                                            <OtherNode start="(217, 18)" end="(217, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(217, 18)" end="(217, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(217, 18)" end="(217, 21)">
                                                            <OtherNode start="(217, 18)" end="(217, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(217, 18)" end="(217, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(217, 21)" end="(217, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(217, 23)" end="(217, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(217, 23)" end="(217, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(217, 23)" end="(217, 26)">
                                                            <OtherNode start="(217, 23)" end="(217, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(217, 23)" end="(217, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(217, 26)" end="(217, 27)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(217, 28)" end="(217, 29)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(217, 30)" end="(217, 43)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(217, 30)" end="(217, 31)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(217, 31)" end="(217, 42)">
                                                            <OtherNode start="(217, 31)" end="(217, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(217, 31)" end="(217, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(217, 31)" end="(217, 32)">
                                                            <OtherNode start="(217, 31)" end="(217, 32)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(217, 31)" end="(217, 32)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(217, 32)" end="(217, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(217, 34)" end="(217, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(217, 34)" end="(217, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(217, 34)" end="(217, 37)">
                                                            <OtherNode start="(217, 34)" end="(217, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(217, 34)" end="(217, 37)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(217, 37)" end="(217, 38)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(217, 39)" end="(217, 42)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(217, 39)" end="(217, 42)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(217, 39)" end="(217, 42)">
                                                            <OtherNode start="(217, 39)" end="(217, 42)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(217, 39)" end="(217, 42)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(217, 42)" end="(217, 43)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(217, 43)" end="(217, 44)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(217, 45)" end="(217, 50)">
                                                            <AtomNode start="(217, 45)" end="(217, 47)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(217, 48)" end="(217, 50)">
                                                            <IdentNode start="(217, 48)" end="(217, 50)" leading="" trailing="&#10;        " raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(218, 9)" end="(222, 21)" kind="Lean.cdot" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ w✝¹ w✝ : List β&#10;h₃ : w✝¹ = [] ∧ w✝ = x₂ :: l₂ ∨ ∃ as', w✝¹ = x₂ :: as' ∧ l₂ = as' ++ w✝&#10;h₁ : [].length = w✝¹.length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝ = zipWith f xs zs&#10;⊢ zipWith f [] w✝¹ = [] ∧ zipWith f (x₁ :: l₁) w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f [] w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f (x₁ :: l₁) w✝&#10;&#10;case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ : List α&#10;w✝² w✝¹ : List β&#10;h₃ : w✝² = [] ∧ w✝¹ = x₂ :: l₂ ∨ ∃ as', w✝² = x₂ :: as' ∧ l₂ = as' ++ w✝¹&#10;w✝ : List α&#10;h₁ : (x₁ :: w✝).length = w✝².length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝¹ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) w✝² = [] ∧ zipWith f w✝³ w✝¹ = f x₁ x₂ :: zipWith f (w✝ ++ w✝³) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) w✝² = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝³) l₂ = as' ++ zipWith f w✝³ w✝¹" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ : List α&#10;w✝² w✝¹ : List β&#10;h₃ : w✝² = [] ∧ w✝¹ = x₂ :: l₂ ∨ ∃ as', w✝² = x₂ :: as' ∧ l₂ = as' ++ w✝¹&#10;w✝ : List α&#10;h₁ : (x₁ :: w✝).length = w✝².length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝¹ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) w✝² = [] ∧ zipWith f w✝³ w✝¹ = f x₁ x₂ :: zipWith f (w✝ ++ w✝³) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) w✝² = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝³) l₂ = as' ++ zipWith f w✝³ w✝¹" tactic="· simp only [zipWith_nil_left, true_and, nil_eq, reduceCtorEq, false_and, exists_const,&#10;  or_false]&#10;  obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;  · simp&#10;  · simp_all">
                                                            <OtherNode start="(218, 9)" end="(218, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(218, 9)" end="(218, 10)" kind="patternIgnore">
                                                            <OtherNode start="(218, 9)" end="(218, 10)" kind="token.«· »">
                                                            <AtomNode start="(218, 9)" end="(218, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(218, 11)" end="(222, 21)">
                                                            <TacticTacticseq1IndentedNode start="(218, 11)" end="(222, 21)">
                                                            <NullNode start="(218, 11)" end="(222, 21)">
                                                            <OtherNode start="(218, 11)" end="(219, 20)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ w✝¹ w✝ : List β&#10;h₃ : w✝¹ = [] ∧ w✝ = x₂ :: l₂ ∨ ∃ as', w✝¹ = x₂ :: as' ∧ l₂ = as' ++ w✝&#10;h₁ : [].length = w✝¹.length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝ = zipWith f xs zs&#10;⊢ zipWith f [] w✝¹ = [] ∧ zipWith f (x₁ :: l₁) w✝ = f x₁ x₂ :: zipWith f l₁ l₂ ∨&#10;    ∃ as', zipWith f [] w✝¹ = f x₁ x₂ :: as' ∧ zipWith f l₁ l₂ = as' ++ zipWith f (x₁ :: l₁) w✝" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ w✝¹ w✝ : List β&#10;h₃ : w✝¹ = [] ∧ w✝ = x₂ :: l₂ ∨ ∃ as', w✝¹ = x₂ :: as' ∧ l₂ = as' ++ w✝&#10;h₁ : [].length = w✝¹.length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) w✝ = f x₁ x₂ :: zipWith f l₁ l₂" tactic="simp only [zipWith_nil_left, true_and, nil_eq, reduceCtorEq, false_and, exists_const,&#10;or_false]">
                                                            <AtomNode start="(218, 11)" end="(218, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(218, 16)" end="(218, 20)">
                                                            <AtomNode start="(218, 16)" end="(218, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(218, 21)" end="(219, 20)">
                                                            <AtomNode start="(218, 21)" end="(218, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(218, 22)" end="(219, 19)">
                                                            <OtherNode start="(218, 22)" end="(218, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(218, 22)" end="(218, 38)" leading="" trailing="" raw_val="zipWith_nil_left" val="zipWith_nil_left" full_name="List.zipWith_nil_left" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(218, 38)" end="(218, 39)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(218, 40)" end="(218, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(218, 40)" end="(218, 48)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(218, 48)" end="(218, 49)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(218, 50)" end="(218, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(218, 50)" end="(218, 56)" leading="" trailing="" raw_val="nil_eq" val="nil_eq" full_name="List.nil_eq" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(218, 56)" end="(218, 57)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(218, 58)" end="(218, 70)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(218, 58)" end="(218, 70)" leading="" trailing="" raw_val="reduceCtorEq" val="reduceCtorEq"/>
                                                            </OtherNode>
                                                            <AtomNode start="(218, 70)" end="(218, 71)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(218, 72)" end="(218, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(218, 72)" end="(218, 81)" leading="" trailing="" raw_val="false_and" val="false_and" full_name="false_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(218, 81)" end="(218, 82)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(218, 83)" end="(218, 95)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(218, 83)" end="(218, 95)" leading="" trailing="" raw_val="exists_const" val="exists_const" full_name="exists_const" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(218, 95)" end="(218, 96)" leading="" trailing="&#10;          " val=","/>
                                                            <OtherNode start="(219, 11)" end="(219, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(219, 11)" end="(219, 19)" leading="" trailing="" raw_val="or_false" val="or_false" full_name="or_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(219, 19)" end="(219, 20)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(220, 11)" end="(220, 52)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ w✝¹ w✝ : List β&#10;h₃ : w✝¹ = [] ∧ w✝ = x₂ :: l₂ ∨ ∃ as', w✝¹ = x₂ :: as' ∧ l₂ = as' ++ w✝&#10;h₁ : [].length = w✝¹.length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) w✝ = f x₁ x₂ :: zipWith f l₁ l₂" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;h₁ : [].length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f l₁ l₂_1 = l₁' ++ zipWith f (x₁ :: l₁) (x₂ :: l₂) ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) (x₂ :: l₂) = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) (x₂ :: l₂) = f x₁ x₂ :: zipWith f l₁ l₂&#10;&#10;case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;w✝¹ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝¹ = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : [].length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: l₁) w✝¹ = f x₁ x₂ :: zipWith f l₁ (w✝ ++ w✝¹)" tactic="obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃">
                                                            <AtomNode start="(220, 11)" end="(220, 17)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(220, 18)" end="(220, 46)">
                                                            <OtherNode start="(220, 18)" end="(220, 46)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(220, 18)" end="(220, 46)">
                                                            <OtherNode start="(220, 18)" end="(220, 46)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(220, 18)" end="(220, 19)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(220, 19)" end="(220, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(220, 19)" end="(220, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(220, 19)" end="(220, 45)">
                                                            <OtherNode start="(220, 19)" end="(220, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(220, 19)" end="(220, 20)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(220, 20)" end="(220, 28)">
                                                            <OtherNode start="(220, 20)" end="(220, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(220, 20)" end="(220, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(220, 20)" end="(220, 23)">
                                                            <OtherNode start="(220, 20)" end="(220, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(220, 20)" end="(220, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(220, 23)" end="(220, 24)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(220, 25)" end="(220, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(220, 25)" end="(220, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(220, 25)" end="(220, 28)">
                                                            <OtherNode start="(220, 25)" end="(220, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(220, 25)" end="(220, 28)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(220, 28)" end="(220, 29)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(220, 30)" end="(220, 31)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(220, 32)" end="(220, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(220, 32)" end="(220, 33)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(220, 33)" end="(220, 44)">
                                                            <OtherNode start="(220, 33)" end="(220, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(220, 33)" end="(220, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(220, 33)" end="(220, 34)">
                                                            <OtherNode start="(220, 33)" end="(220, 34)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(220, 33)" end="(220, 34)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(220, 34)" end="(220, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(220, 36)" end="(220, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(220, 36)" end="(220, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(220, 36)" end="(220, 39)">
                                                            <OtherNode start="(220, 36)" end="(220, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(220, 36)" end="(220, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(220, 39)" end="(220, 40)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(220, 41)" end="(220, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(220, 41)" end="(220, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(220, 41)" end="(220, 44)">
                                                            <OtherNode start="(220, 41)" end="(220, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(220, 41)" end="(220, 44)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(220, 44)" end="(220, 45)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(220, 45)" end="(220, 46)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(220, 47)" end="(220, 52)">
                                                            <AtomNode start="(220, 47)" end="(220, 49)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(220, 50)" end="(220, 52)">
                                                            <IdentNode start="(220, 50)" end="(220, 52)" leading="" trailing="&#10;          " raw_val="h₃" val="h₃"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(221, 11)" end="(221, 17)" kind="Lean.cdot" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;h₁ : [].length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f l₁ l₂_1 = l₁' ++ zipWith f (x₁ :: l₁) (x₂ :: l₂) ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) (x₂ :: l₂) = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) (x₂ :: l₂) = f x₁ x₂ :: zipWith f l₁ l₂&#10;&#10;case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;w✝¹ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝¹ = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : [].length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: l₁) w✝¹ = f x₁ x₂ :: zipWith f l₁ (w✝ ++ w✝¹)" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;w✝¹ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝¹ = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : [].length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: l₁) w✝¹ = f x₁ x₂ :: zipWith f l₁ (w✝ ++ w✝¹)" tactic="· simp">
                                                            <OtherNode start="(221, 11)" end="(221, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(221, 11)" end="(221, 12)" kind="patternIgnore">
                                                            <OtherNode start="(221, 11)" end="(221, 12)" kind="token.«· »">
                                                            <AtomNode start="(221, 11)" end="(221, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(221, 13)" end="(221, 17)">
                                                            <TacticTacticseq1IndentedNode start="(221, 13)" end="(221, 17)">
                                                            <NullNode start="(221, 13)" end="(221, 17)">
                                                            <OtherNode start="(221, 13)" end="(221, 17)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;l₂ : List β&#10;h₁ : [].length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f l₁ l₂_1 = l₁' ++ zipWith f (x₁ :: l₁) (x₂ :: l₂) ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) (x₂ :: l₂) = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: l₁) (x₂ :: l₂) = f x₁ x₂ :: zipWith f l₁ l₂" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(221, 13)" end="(221, 17)" leading="" trailing="&#10;          " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(222, 11)" end="(222, 21)" kind="Lean.cdot" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;w✝¹ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝¹ = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : [].length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: l₁) w✝¹ = f x₁ x₂ :: zipWith f l₁ (w✝ ++ w✝¹)" state_after="no goals" tactic="· simp_all">
                                                            <OtherNode start="(222, 11)" end="(222, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(222, 11)" end="(222, 12)" kind="patternIgnore">
                                                            <OtherNode start="(222, 11)" end="(222, 12)" kind="token.«· »">
                                                            <AtomNode start="(222, 11)" end="(222, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(222, 13)" end="(222, 21)">
                                                            <TacticTacticseq1IndentedNode start="(222, 13)" end="(222, 21)">
                                                            <NullNode start="(222, 13)" end="(222, 21)">
                                                            <OtherNode start="(222, 13)" end="(222, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inl.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;l₁ : List α&#10;x₂ : β&#10;w✝¹ : List β&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f l₁ l₂ = l₁' ++ zipWith f (x₁ :: l₁) w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f (x₁ :: l₁) w✝¹ = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : [].length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: l₁) w✝¹ = f x₁ x₂ :: zipWith f l₁ (w✝ ++ w✝¹)" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(222, 13)" end="(222, 21)" leading="" trailing="&#10;        " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(223, 9)" end="(225, 52)" kind="Lean.cdot" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ : List α&#10;w✝² w✝¹ : List β&#10;h₃ : w✝² = [] ∧ w✝¹ = x₂ :: l₂ ∨ ∃ as', w✝² = x₂ :: as' ∧ l₂ = as' ++ w✝¹&#10;w✝ : List α&#10;h₁ : (x₁ :: w✝).length = w✝².length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝¹ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) w✝² = [] ∧ zipWith f w✝³ w✝¹ = f x₁ x₂ :: zipWith f (w✝ ++ w✝³) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) w✝² = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝³) l₂ = as' ++ zipWith f w✝³ w✝¹" state_after="no goals" tactic="· obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃&#10;  · simp_all&#10;  · simp_all [zipWith_append, Nat.succ_inj]">
                                                            <OtherNode start="(223, 9)" end="(223, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(223, 9)" end="(223, 10)" kind="patternIgnore">
                                                            <OtherNode start="(223, 9)" end="(223, 10)" kind="token.«· »">
                                                            <AtomNode start="(223, 9)" end="(223, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(223, 11)" end="(225, 52)">
                                                            <TacticTacticseq1IndentedNode start="(223, 11)" end="(225, 52)">
                                                            <NullNode start="(223, 11)" end="(225, 52)">
                                                            <OtherNode start="(223, 11)" end="(223, 52)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝³ : List α&#10;w✝² w✝¹ : List β&#10;h₃ : w✝² = [] ∧ w✝¹ = x₂ :: l₂ ∨ ∃ as', w✝² = x₂ :: as' ∧ l₂ = as' ++ w✝¹&#10;w✝ : List α&#10;h₁ : (x₁ :: w✝).length = w✝².length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝¹ ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝¹ = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) w✝² = [] ∧ zipWith f w✝³ w✝¹ = f x₁ x₂ :: zipWith f (w✝ ++ w✝³) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) w✝² = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝³) l₂ = as' ++ zipWith f w✝³ w✝¹" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝¹ w✝ : List α&#10;h₁ : (x₁ :: w✝).length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f (w✝ ++ w✝¹) l₂_1 = l₁' ++ zipWith f w✝¹ (x₂ :: l₂) ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝¹ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝¹ (x₂ :: l₂) = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) [] = [] ∧ zipWith f w✝¹ (x₂ :: l₂) = f x₁ x₂ :: zipWith f (w✝ ++ w✝¹) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) [] = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝¹) l₂ = as' ++ zipWith f w✝¹ (x₂ :: l₂)&#10;&#10;case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝³ : List α&#10;w✝² : List β&#10;w✝¹ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝¹ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝² ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝¹ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝² = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : (x₁ :: w✝¹).length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = [] ∧ zipWith f w✝³ w✝² = f x₁ x₂ :: zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) ∨&#10;    ∃ as',&#10;      zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = f x₁ x₂ :: as' ∧ zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) = as' ++ zipWith f w✝³ w✝²" tactic="obtain (⟨rfl, rfl⟩ | ⟨_, rfl, rfl⟩) := h₃">
                                                            <AtomNode start="(223, 11)" end="(223, 17)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(223, 18)" end="(223, 46)">
                                                            <OtherNode start="(223, 18)" end="(223, 46)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(223, 18)" end="(223, 46)">
                                                            <OtherNode start="(223, 18)" end="(223, 46)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(223, 18)" end="(223, 19)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(223, 19)" end="(223, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(223, 19)" end="(223, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(223, 19)" end="(223, 45)">
                                                            <OtherNode start="(223, 19)" end="(223, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(223, 19)" end="(223, 20)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(223, 20)" end="(223, 28)">
                                                            <OtherNode start="(223, 20)" end="(223, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(223, 20)" end="(223, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(223, 20)" end="(223, 23)">
                                                            <OtherNode start="(223, 20)" end="(223, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(223, 20)" end="(223, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(223, 23)" end="(223, 24)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(223, 25)" end="(223, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(223, 25)" end="(223, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(223, 25)" end="(223, 28)">
                                                            <OtherNode start="(223, 25)" end="(223, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(223, 25)" end="(223, 28)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(223, 28)" end="(223, 29)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(223, 30)" end="(223, 31)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(223, 32)" end="(223, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(223, 32)" end="(223, 33)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(223, 33)" end="(223, 44)">
                                                            <OtherNode start="(223, 33)" end="(223, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(223, 33)" end="(223, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(223, 33)" end="(223, 34)">
                                                            <OtherNode start="(223, 33)" end="(223, 34)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(223, 33)" end="(223, 34)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(223, 34)" end="(223, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(223, 36)" end="(223, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(223, 36)" end="(223, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(223, 36)" end="(223, 39)">
                                                            <OtherNode start="(223, 36)" end="(223, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(223, 36)" end="(223, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(223, 39)" end="(223, 40)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(223, 41)" end="(223, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(223, 41)" end="(223, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(223, 41)" end="(223, 44)">
                                                            <OtherNode start="(223, 41)" end="(223, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(223, 41)" end="(223, 44)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(223, 44)" end="(223, 45)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(223, 45)" end="(223, 46)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(223, 47)" end="(223, 52)">
                                                            <AtomNode start="(223, 47)" end="(223, 49)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(223, 50)" end="(223, 52)">
                                                            <IdentNode start="(223, 50)" end="(223, 52)" leading="" trailing="&#10;          " raw_val="h₃" val="h₃"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(224, 11)" end="(224, 21)" kind="Lean.cdot" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝¹ w✝ : List α&#10;h₁ : (x₁ :: w✝).length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f (w✝ ++ w✝¹) l₂_1 = l₁' ++ zipWith f w✝¹ (x₂ :: l₂) ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝¹ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝¹ (x₂ :: l₂) = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) [] = [] ∧ zipWith f w✝¹ (x₂ :: l₂) = f x₁ x₂ :: zipWith f (w✝ ++ w✝¹) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) [] = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝¹) l₂ = as' ++ zipWith f w✝¹ (x₂ :: l₂)&#10;&#10;case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝³ : List α&#10;w✝² : List β&#10;w✝¹ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝¹ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝² ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝¹ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝² = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : (x₁ :: w✝¹).length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = [] ∧ zipWith f w✝³ w✝² = f x₁ x₂ :: zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) ∨&#10;    ∃ as',&#10;      zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = f x₁ x₂ :: as' ∧ zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) = as' ++ zipWith f w✝³ w✝²" state_after="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝³ : List α&#10;w✝² : List β&#10;w✝¹ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝¹ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝² ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝¹ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝² = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : (x₁ :: w✝¹).length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = [] ∧ zipWith f w✝³ w✝² = f x₁ x₂ :: zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) ∨&#10;    ∃ as',&#10;      zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = f x₁ x₂ :: as' ∧ zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) = as' ++ zipWith f w✝³ w✝²" tactic="· simp_all">
                                                            <OtherNode start="(224, 11)" end="(224, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(224, 11)" end="(224, 12)" kind="patternIgnore">
                                                            <OtherNode start="(224, 11)" end="(224, 12)" kind="token.«· »">
                                                            <AtomNode start="(224, 11)" end="(224, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(224, 13)" end="(224, 21)">
                                                            <TacticTacticseq1IndentedNode start="(224, 13)" end="(224, 21)">
                                                            <NullNode start="(224, 13)" end="(224, 21)">
                                                            <OtherNode start="(224, 13)" end="(224, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;l₂ : List β&#10;w✝¹ w✝ : List α&#10;h₁ : (x₁ :: w✝).length = [].length&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂_1 : List β},&#10;    zipWith f (w✝ ++ w✝¹) l₂_1 = l₁' ++ zipWith f w✝¹ (x₂ :: l₂) ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝ ++ w✝¹ = ws ++ xs ∧ l₂_1 = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝¹ (x₂ :: l₂) = zipWith f xs zs&#10;⊢ zipWith f (x₁ :: w✝) [] = [] ∧ zipWith f w✝¹ (x₂ :: l₂) = f x₁ x₂ :: zipWith f (w✝ ++ w✝¹) l₂ ∨&#10;    ∃ as', zipWith f (x₁ :: w✝) [] = f x₁ x₂ :: as' ∧ zipWith f (w✝ ++ w✝¹) l₂ = as' ++ zipWith f w✝¹ (x₂ :: l₂)" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(224, 13)" end="(224, 21)" leading="" trailing="&#10;          " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(225, 11)" end="(225, 52)" kind="Lean.cdot" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝³ : List α&#10;w✝² : List β&#10;w✝¹ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝¹ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝² ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝¹ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝² = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : (x₁ :: w✝¹).length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = [] ∧ zipWith f w✝³ w✝² = f x₁ x₂ :: zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) ∨&#10;    ∃ as',&#10;      zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = f x₁ x₂ :: as' ∧ zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) = as' ++ zipWith f w✝³ w✝²" state_after="no goals" tactic="· simp_all [zipWith_append, Nat.succ_inj]">
                                                            <OtherNode start="(225, 11)" end="(225, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(225, 11)" end="(225, 12)" kind="patternIgnore">
                                                            <OtherNode start="(225, 11)" end="(225, 12)" kind="token.«· »">
                                                            <AtomNode start="(225, 11)" end="(225, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(225, 13)" end="(225, 52)">
                                                            <TacticTacticseq1IndentedNode start="(225, 13)" end="(225, 52)">
                                                            <NullNode start="(225, 13)" end="(225, 52)">
                                                            <OtherNode start="(225, 13)" end="(225, 52)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.cons.mpr.intro.intro.intro.intro.intro.intro.intro.intro.inr.intro.intro.inr.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;x₁ : α&#10;x₂ : β&#10;w✝³ : List α&#10;w✝² : List β&#10;w✝¹ : List α&#10;ih₁ :&#10;  ∀ {l₁' : List γ} {l₂ : List β},&#10;    zipWith f (w✝¹ ++ w✝³) l₂ = l₁' ++ zipWith f w✝³ w✝² ↔&#10;      ∃ ws xs ys zs,&#10;        ws.length = ys.length ∧&#10;          w✝¹ ++ w✝³ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = zipWith f ws ys ∧ zipWith f w✝³ w✝² = zipWith f xs zs&#10;w✝ : List β&#10;h₁ : (x₁ :: w✝¹).length = (x₂ :: w✝).length&#10;⊢ zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = [] ∧ zipWith f w✝³ w✝² = f x₁ x₂ :: zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) ∨&#10;    ∃ as',&#10;      zipWith f (x₁ :: w✝¹) (x₂ :: w✝) = f x₁ x₂ :: as' ∧ zipWith f (w✝¹ ++ w✝³) (w✝ ++ w✝²) = as' ++ zipWith f w✝³ w✝²" state_after="no goals" tactic="simp_all [zipWith_append, Nat.succ_inj]">
                                                            <AtomNode start="(225, 13)" end="(225, 21)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(225, 22)" end="(225, 52)">
                                                            <AtomNode start="(225, 22)" end="(225, 23)" leading="" trailing="" val="["/>
                                                            <NullNode start="(225, 23)" end="(225, 51)">
                                                            <OtherNode start="(225, 23)" end="(225, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(225, 23)" end="(225, 37)" leading="" trailing="" raw_val="zipWith_append" val="zipWith_append" full_name="List.zipWith_append" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(154, 9)" def_end="(154, 23)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(225, 37)" end="(225, 38)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(225, 39)" end="(225, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(225, 39)" end="(225, 51)" leading="" trailing="" raw_val="Nat.succ_inj" val="Nat.succ_inj" full_name="Nat.succ_inj" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(225, 51)" end="(225, 52)" leading="" trailing="&#10;&#10;" val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(227, 1)" end="(232, 43)" name="zipWith_replicate'" full_name="List.zipWith_replicate'">
      <CommandDeclmodifiersNode start="(227, 1)" end="(228, 8)">
        <NullNode start="(227, 1)" end="(227, 115)">
          <CommandDoccommentNode start="(227, 1)" end="(227, 115)" comment="See also `List.zipWith_replicate` in `Init.Data.List.TakeDrop` for a generalization with different lengths. -/">
            <AtomNode start="(227, 1)" end="(227, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(227, 5)" end="(227, 115)" leading="" trailing="&#10;" val="See also `List.zipWith_replicate` in `Init.Data.List.TakeDrop` for a generalization with different lengths. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(228, 1)" end="(228, 8)">
          <OtherNode start="(228, 1)" end="(228, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(228, 1)" end="(228, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(228, 3)" end="(228, 7)">
              <OtherNode start="(228, 3)" end="(228, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(228, 3)" end="(228, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(228, 3)" end="(228, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(228, 7)" end="(228, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(228, 9)" end="(232, 43)" name="zipWith_replicate'" full_name="List.zipWith_replicate'" _is_private_decl="False">
        <AtomNode start="(228, 9)" end="(228, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(228, 17)" end="(228, 35)">
          <IdentNode start="(228, 17)" end="(228, 35)" leading="" trailing=" " raw_val="zipWith_replicate'" val="zipWith_replicate'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(228, 36)" end="(229, 68)">
          <NullNode start="(228, 36)" end="(228, 61)">
            <OtherNode start="(228, 36)" end="(228, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 36)" end="(228, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 37)" end="(228, 38)">
                <IdentNode start="(228, 37)" end="(228, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(228, 39)" end="(228, 42)">
                <AtomNode start="(228, 39)" end="(228, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(228, 41)" end="(228, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(228, 42)" end="(228, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(228, 44)" end="(228, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 44)" end="(228, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 45)" end="(228, 46)">
                <IdentNode start="(228, 45)" end="(228, 46)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(228, 47)" end="(228, 50)">
                <AtomNode start="(228, 47)" end="(228, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(228, 49)" end="(228, 50)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(228, 50)" end="(228, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(228, 52)" end="(228, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 52)" end="(228, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 53)" end="(228, 54)">
                <IdentNode start="(228, 53)" end="(228, 54)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(228, 55)" end="(228, 60)">
                <AtomNode start="(228, 55)" end="(228, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(228, 57)" end="(228, 60)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(228, 60)" end="(228, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(228, 62)" end="(229, 68)">
            <AtomNode start="(228, 62)" end="(228, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(229, 5)" end="(229, 68)" kind="«term_=_»">
              <OtherNode start="(229, 5)" end="(229, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(229, 5)" end="(229, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(229, 13)" end="(229, 46)">
                  <IdentNode start="(229, 13)" end="(229, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(229, 15)" end="(229, 30)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(229, 15)" end="(229, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(229, 16)" end="(229, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(229, 16)" end="(229, 25)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(229, 26)" end="(229, 29)">
                        <IdentNode start="(229, 26)" end="(229, 27)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(229, 28)" end="(229, 29)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(229, 29)" end="(229, 30)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(229, 31)" end="(229, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(229, 31)" end="(229, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(229, 32)" end="(229, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(229, 32)" end="(229, 41)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(229, 42)" end="(229, 45)">
                        <IdentNode start="(229, 42)" end="(229, 43)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(229, 44)" end="(229, 45)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(229, 45)" end="(229, 46)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(229, 47)" end="(229, 48)" leading="" trailing=" " val="="/>
              <OtherNode start="(229, 49)" end="(229, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(229, 49)" end="(229, 58)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(229, 59)" end="(229, 68)">
                  <IdentNode start="(229, 59)" end="(229, 60)" leading="" trailing=" " raw_val="n" val="n"/>
                  <OtherNode start="(229, 61)" end="(229, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(229, 61)" end="(229, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(229, 62)" end="(229, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(229, 62)" end="(229, 63)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(229, 64)" end="(229, 67)">
                        <IdentNode start="(229, 64)" end="(229, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(229, 66)" end="(229, 67)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(229, 67)" end="(229, 68)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(229, 69)" end="(232, 43)">
          <AtomNode start="(229, 69)" end="(229, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(229, 72)" end="(232, 43)">
            <AtomNode start="(229, 72)" end="(229, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(230, 3)" end="(232, 43)">
              <TacticTacticseq1IndentedNode start="(230, 3)" end="(232, 43)">
                <NullNode start="(230, 3)" end="(232, 43)">
                  <OtherNode start="(230, 3)" end="(232, 43)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : α → β → α✝&#10;a : α&#10;b : β&#10;n : Nat&#10;⊢ zipWith f (replicate n a) (replicate n b) = replicate n (f a b)" state_after="no goals" tactic="induction n with&#10;| zero =&amp;gt; rfl&#10;| succ n ih =&amp;gt; simp [replicate_succ, ih]">
                    <AtomNode start="(230, 3)" end="(230, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(230, 13)" end="(230, 14)">
                      <OtherNode start="(230, 13)" end="(230, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(230, 13)" end="(230, 14)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(230, 15)" end="(232, 43)">
                      <OtherNode start="(230, 15)" end="(232, 43)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(230, 15)" end="(230, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(231, 3)" end="(232, 43)">
                          <OtherNode start="(231, 3)" end="(231, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(231, 3)" end="(231, 9)">
                              <OtherNode start="(231, 3)" end="(231, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(231, 3)" end="(231, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(231, 5)" end="(231, 9)">
                                  <NullNode/>
                                  <IdentNode start="(231, 5)" end="(231, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(231, 10)" end="(231, 16)">
                              <AtomNode start="(231, 10)" end="(231, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(231, 13)" end="(231, 16)">
                                <TacticTacticseq1IndentedNode start="(231, 13)" end="(231, 16)">
                                  <NullNode start="(231, 13)" end="(231, 16)">
                                    <OtherNode start="(231, 13)" end="(231, 16)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case zero&#10;α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : α → β → α✝&#10;a : α&#10;b : β&#10;⊢ zipWith f (replicate 0 a) (replicate 0 b) = replicate 0 (f a b)" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(231, 13)" end="(231, 16)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(232, 3)" end="(232, 43)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(232, 3)" end="(232, 14)">
                              <OtherNode start="(232, 3)" end="(232, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(232, 3)" end="(232, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(232, 5)" end="(232, 9)">
                                  <NullNode/>
                                  <IdentNode start="(232, 5)" end="(232, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(232, 10)" end="(232, 14)">
                                  <IdentNode start="(232, 10)" end="(232, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                  <IdentNode start="(232, 12)" end="(232, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(232, 15)" end="(232, 43)">
                              <AtomNode start="(232, 15)" end="(232, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(232, 18)" end="(232, 43)">
                                <TacticTacticseq1IndentedNode start="(232, 18)" end="(232, 43)">
                                  <NullNode start="(232, 18)" end="(232, 43)">
                                    <OtherNode start="(232, 18)" end="(232, 43)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : α → β → α✝&#10;a : α&#10;b : β&#10;n : Nat&#10;ih : zipWith f (replicate n a) (replicate n b) = replicate n (f a b)&#10;⊢ zipWith f (replicate (n + 1) a) (replicate (n + 1) b) = replicate (n + 1) (f a b)" state_after="no goals" tactic="simp [replicate_succ, ih]">
                                      <AtomNode start="(232, 18)" end="(232, 22)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(232, 23)" end="(232, 43)">
                                        <AtomNode start="(232, 23)" end="(232, 24)" leading="" trailing="" val="["/>
                                        <NullNode start="(232, 24)" end="(232, 42)">
                                          <OtherNode start="(232, 24)" end="(232, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(232, 24)" end="(232, 38)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(232, 38)" end="(232, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(232, 40)" end="(232, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(232, 40)" end="(232, 42)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(232, 42)" end="(232, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(234, 1)" end="(240, 27)" name="map_uncurry_zip_eq_zipWith" full_name="List.map_uncurry_zip_eq_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(234, 1)" end="(240, 27)" name="map_uncurry_zip_eq_zipWith" full_name="List.map_uncurry_zip_eq_zipWith" _is_private_decl="False">
        <AtomNode start="(234, 1)" end="(234, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(234, 9)" end="(234, 35)">
          <IdentNode start="(234, 9)" end="(234, 35)" leading="" trailing=" " raw_val="map_uncurry_zip_eq_zipWith" val="map_uncurry_zip_eq_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(234, 36)" end="(235, 57)">
          <NullNode start="(234, 36)" end="(234, 78)">
            <OtherNode start="(234, 36)" end="(234, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(234, 36)" end="(234, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(234, 37)" end="(234, 38)">
                <IdentNode start="(234, 37)" end="(234, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(234, 39)" end="(234, 50)">
                <AtomNode start="(234, 39)" end="(234, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(234, 41)" end="(234, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(234, 41)" end="(234, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(234, 43)" end="(234, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(234, 45)" end="(234, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(234, 45)" end="(234, 46)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(234, 47)" end="(234, 48)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(234, 49)" end="(234, 50)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(234, 50)" end="(234, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(234, 52)" end="(234, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(234, 52)" end="(234, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(234, 53)" end="(234, 54)">
                <IdentNode start="(234, 53)" end="(234, 54)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(234, 55)" end="(234, 63)">
                <AtomNode start="(234, 55)" end="(234, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(234, 57)" end="(234, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(234, 57)" end="(234, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(234, 62)" end="(234, 63)">
                    <IdentNode start="(234, 62)" end="(234, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(234, 63)" end="(234, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(234, 65)" end="(234, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(234, 65)" end="(234, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(234, 66)" end="(234, 68)">
                <IdentNode start="(234, 66)" end="(234, 68)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(234, 69)" end="(234, 77)">
                <AtomNode start="(234, 69)" end="(234, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(234, 71)" end="(234, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(234, 71)" end="(234, 75)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(234, 76)" end="(234, 77)">
                    <IdentNode start="(234, 76)" end="(234, 77)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(234, 77)" end="(234, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(234, 79)" end="(235, 57)">
            <AtomNode start="(234, 79)" end="(234, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(235, 5)" end="(235, 57)" kind="«term_=_»">
              <OtherNode start="(235, 5)" end="(235, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(235, 5)" end="(235, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(235, 9)" end="(235, 40)">
                  <OtherNode start="(235, 9)" end="(235, 29)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(235, 9)" end="(235, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(235, 10)" end="(235, 28)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(235, 10)" end="(235, 26)" leading="" trailing=" " raw_val="Function.uncurry" val="Function.uncurry" full_name="Function.uncurry" mod_name="Init.Data.Function" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Function.lean"/>
                      <NullNode start="(235, 27)" end="(235, 28)">
                        <IdentNode start="(235, 27)" end="(235, 28)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(235, 28)" end="(235, 29)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(235, 30)" end="(235, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(235, 30)" end="(235, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(235, 31)" end="(235, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(235, 31)" end="(235, 36)" leading="" trailing=" " raw_val="l.zip" val="l.zip"/>
                      <NullNode start="(235, 37)" end="(235, 39)">
                        <IdentNode start="(235, 37)" end="(235, 39)" leading="" trailing="" raw_val="l'" val="l'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(235, 39)" end="(235, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(235, 41)" end="(235, 42)" leading="" trailing=" " val="="/>
              <OtherNode start="(235, 43)" end="(235, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(235, 43)" end="(235, 50)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(235, 51)" end="(235, 57)">
                  <IdentNode start="(235, 51)" end="(235, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(235, 53)" end="(235, 54)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(235, 55)" end="(235, 57)" leading="" trailing=" " raw_val="l'" val="l'"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(235, 58)" end="(240, 27)">
          <AtomNode start="(235, 58)" end="(235, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(235, 61)" end="(240, 27)">
            <AtomNode start="(235, 61)" end="(235, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(236, 3)" end="(240, 27)">
              <TacticTacticseq1IndentedNode start="(236, 3)" end="(240, 27)">
                <NullNode start="(236, 3)" end="(240, 27)">
                  <OtherNode start="(236, 3)" end="(236, 11)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l : List α&#10;l' : List β&#10;⊢ map (Function.uncurry f) (l.zip l') = zipWith f l l'" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l : List α&#10;l' : List β&#10;⊢ map (Function.uncurry f) (zipWith Prod.mk l l') = zipWith f l l'" tactic="rw [zip]">
                    <AtomNode start="(236, 3)" end="(236, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(236, 6)" end="(236, 11)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(236, 6)" end="(236, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(236, 7)" end="(236, 10)">
                        <OtherNode start="(236, 7)" end="(236, 10)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(236, 7)" end="(236, 10)" leading="" trailing="" raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(236, 10)" end="(236, 11)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(237, 3)" end="(240, 27)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l : List α&#10;l' : List β&#10;⊢ map (Function.uncurry f) (zipWith Prod.mk l l') = zipWith f l l'" state_after="no goals" tactic="induction l generalizing l' with&#10;| nil =&amp;gt; simp&#10;| cons hl tl ih =&amp;gt;&#10;  cases l' &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(237, 3)" end="(237, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(237, 13)" end="(237, 14)">
                      <OtherNode start="(237, 13)" end="(237, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(237, 13)" end="(237, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(237, 15)" end="(237, 30)">
                      <AtomNode start="(237, 15)" end="(237, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(237, 28)" end="(237, 30)">
                        <IdentNode start="(237, 28)" end="(237, 30)" leading="" trailing=" " raw_val="l'" val="l'"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(237, 31)" end="(240, 27)">
                      <OtherNode start="(237, 31)" end="(240, 27)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(237, 31)" end="(237, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(238, 3)" end="(240, 27)">
                          <OtherNode start="(238, 3)" end="(238, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(238, 3)" end="(238, 8)">
                              <OtherNode start="(238, 3)" end="(238, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(238, 3)" end="(238, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(238, 5)" end="(238, 8)">
                                  <NullNode/>
                                  <IdentNode start="(238, 5)" end="(238, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(238, 9)" end="(238, 16)">
                              <AtomNode start="(238, 9)" end="(238, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(238, 12)" end="(238, 16)">
                                <TacticTacticseq1IndentedNode start="(238, 12)" end="(238, 16)">
                                  <NullNode start="(238, 12)" end="(238, 16)">
                                    <OtherNode start="(238, 12)" end="(238, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;l' : List β&#10;⊢ map (Function.uncurry f) (zipWith Prod.mk [] l') = zipWith f [] l'" state_after="no goals" tactic="simp">
                                      <AtomNode start="(238, 12)" end="(238, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(239, 3)" end="(240, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(239, 3)" end="(239, 18)">
                              <OtherNode start="(239, 3)" end="(239, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(239, 3)" end="(239, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(239, 5)" end="(239, 9)">
                                  <NullNode/>
                                  <IdentNode start="(239, 5)" end="(239, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(239, 10)" end="(239, 18)">
                                  <IdentNode start="(239, 10)" end="(239, 12)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                  <IdentNode start="(239, 13)" end="(239, 15)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                  <IdentNode start="(239, 16)" end="(239, 18)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(239, 19)" end="(240, 27)">
                              <AtomNode start="(239, 19)" end="(239, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(240, 5)" end="(240, 27)">
                                <TacticTacticseq1IndentedNode start="(240, 5)" end="(240, 27)">
                                  <NullNode start="(240, 5)" end="(240, 27)">
                                    <OtherNode start="(240, 5)" end="(240, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;hl : α&#10;tl : List α&#10;ih : ∀ {l' : List β}, map (Function.uncurry f) (zipWith Prod.mk tl l') = zipWith f tl l'&#10;l' : List β&#10;⊢ map (Function.uncurry f) (zipWith Prod.mk (hl :: tl) l') = zipWith f (hl :: tl) l'" state_after="no goals" tactic="cases l' &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(240, 5)" end="(240, 13)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(240, 5)" end="(240, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(240, 11)" end="(240, 13)">
                                          <OtherNode start="(240, 11)" end="(240, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(240, 11)" end="(240, 13)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(240, 14)" end="(240, 17)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(240, 18)" end="(240, 27)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(240, 18)" end="(240, 22)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(240, 23)" end="(240, 27)">
                                          <AtomNode start="(240, 23)" end="(240, 24)" leading="" trailing="" val="["/>
                                          <NullNode start="(240, 24)" end="(240, 26)">
                                            <OtherNode start="(240, 24)" end="(240, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(240, 24)" end="(240, 26)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(240, 26)" end="(240, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(242, 1)" end="(248, 27)" name="map_zip_eq_zipWith" full_name="List.map_zip_eq_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(242, 1)" end="(248, 27)" name="map_zip_eq_zipWith" full_name="List.map_zip_eq_zipWith" _is_private_decl="False">
        <AtomNode start="(242, 1)" end="(242, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(242, 9)" end="(242, 27)">
          <IdentNode start="(242, 9)" end="(242, 27)" leading="" trailing=" " raw_val="map_zip_eq_zipWith" val="map_zip_eq_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(242, 28)" end="(243, 55)">
          <NullNode start="(242, 28)" end="(242, 70)">
            <OtherNode start="(242, 28)" end="(242, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(242, 28)" end="(242, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(242, 29)" end="(242, 30)">
                <IdentNode start="(242, 29)" end="(242, 30)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(242, 31)" end="(242, 42)">
                <AtomNode start="(242, 31)" end="(242, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(242, 33)" end="(242, 42)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(242, 33)" end="(242, 38)" kind="«term_×_»">
                    <IdentNode start="(242, 33)" end="(242, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(242, 35)" end="(242, 36)" leading="" trailing=" " val="×"/>
                    <IdentNode start="(242, 37)" end="(242, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                  </OtherNode>
                  <AtomNode start="(242, 39)" end="(242, 40)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(242, 41)" end="(242, 42)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(242, 42)" end="(242, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(242, 44)" end="(242, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(242, 44)" end="(242, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(242, 45)" end="(242, 46)">
                <IdentNode start="(242, 45)" end="(242, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(242, 47)" end="(242, 55)">
                <AtomNode start="(242, 47)" end="(242, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(242, 49)" end="(242, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(242, 49)" end="(242, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(242, 54)" end="(242, 55)">
                    <IdentNode start="(242, 54)" end="(242, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(242, 55)" end="(242, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(242, 57)" end="(242, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(242, 57)" end="(242, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(242, 58)" end="(242, 60)">
                <IdentNode start="(242, 58)" end="(242, 60)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(242, 61)" end="(242, 69)">
                <AtomNode start="(242, 61)" end="(242, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(242, 63)" end="(242, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(242, 63)" end="(242, 67)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(242, 68)" end="(242, 69)">
                    <IdentNode start="(242, 68)" end="(242, 69)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(242, 69)" end="(242, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(242, 71)" end="(243, 55)">
            <AtomNode start="(242, 71)" end="(242, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(243, 5)" end="(243, 55)" kind="«term_=_»">
              <OtherNode start="(243, 5)" end="(243, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(243, 5)" end="(243, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(243, 9)" end="(243, 21)">
                  <IdentNode start="(243, 9)" end="(243, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(243, 11)" end="(243, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(243, 11)" end="(243, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(243, 12)" end="(243, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(243, 12)" end="(243, 17)" leading="" trailing=" " raw_val="l.zip" val="l.zip"/>
                      <NullNode start="(243, 18)" end="(243, 20)">
                        <IdentNode start="(243, 18)" end="(243, 20)" leading="" trailing="" raw_val="l'" val="l'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(243, 20)" end="(243, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(243, 22)" end="(243, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(243, 24)" end="(243, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(243, 24)" end="(243, 31)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(243, 32)" end="(243, 55)">
                  <OtherNode start="(243, 32)" end="(243, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(243, 32)" end="(243, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(243, 33)" end="(243, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(243, 33)" end="(243, 47)" leading="" trailing=" " raw_val="Function.curry" val="Function.curry" full_name="Function.curry" mod_name="Init.Data.Function" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Function.lean"/>
                      <NullNode start="(243, 48)" end="(243, 49)">
                        <IdentNode start="(243, 48)" end="(243, 49)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(243, 49)" end="(243, 50)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(243, 51)" end="(243, 52)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(243, 53)" end="(243, 55)" leading="" trailing=" " raw_val="l'" val="l'"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(243, 56)" end="(248, 27)">
          <AtomNode start="(243, 56)" end="(243, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(243, 59)" end="(248, 27)">
            <AtomNode start="(243, 59)" end="(243, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(244, 3)" end="(248, 27)">
              <TacticTacticseq1IndentedNode start="(244, 3)" end="(248, 27)">
                <NullNode start="(244, 3)" end="(248, 27)">
                  <OtherNode start="(244, 3)" end="(244, 11)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;l : List α&#10;l' : List β&#10;⊢ map f (l.zip l') = zipWith (Function.curry f) l l'" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;l : List α&#10;l' : List β&#10;⊢ map f (zipWith Prod.mk l l') = zipWith (Function.curry f) l l'" tactic="rw [zip]">
                    <AtomNode start="(244, 3)" end="(244, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(244, 6)" end="(244, 11)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(244, 6)" end="(244, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(244, 7)" end="(244, 10)">
                        <OtherNode start="(244, 7)" end="(244, 10)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(244, 7)" end="(244, 10)" leading="" trailing="" raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(244, 10)" end="(244, 11)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(245, 3)" end="(248, 27)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;l : List α&#10;l' : List β&#10;⊢ map f (zipWith Prod.mk l l') = zipWith (Function.curry f) l l'" state_after="no goals" tactic="induction l generalizing l' with&#10;| nil =&amp;gt; simp&#10;| cons hl tl ih =&amp;gt;&#10;  cases l' &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(245, 3)" end="(245, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(245, 13)" end="(245, 14)">
                      <OtherNode start="(245, 13)" end="(245, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(245, 13)" end="(245, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(245, 15)" end="(245, 30)">
                      <AtomNode start="(245, 15)" end="(245, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(245, 28)" end="(245, 30)">
                        <IdentNode start="(245, 28)" end="(245, 30)" leading="" trailing=" " raw_val="l'" val="l'"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(245, 31)" end="(248, 27)">
                      <OtherNode start="(245, 31)" end="(248, 27)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(245, 31)" end="(245, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(246, 3)" end="(248, 27)">
                          <OtherNode start="(246, 3)" end="(246, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(246, 3)" end="(246, 8)">
                              <OtherNode start="(246, 3)" end="(246, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(246, 3)" end="(246, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(246, 5)" end="(246, 8)">
                                  <NullNode/>
                                  <IdentNode start="(246, 5)" end="(246, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(246, 9)" end="(246, 16)">
                              <AtomNode start="(246, 9)" end="(246, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(246, 12)" end="(246, 16)">
                                <TacticTacticseq1IndentedNode start="(246, 12)" end="(246, 16)">
                                  <NullNode start="(246, 12)" end="(246, 16)">
                                    <OtherNode start="(246, 12)" end="(246, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;l' : List β&#10;⊢ map f (zipWith Prod.mk [] l') = zipWith (Function.curry f) [] l'" state_after="no goals" tactic="simp">
                                      <AtomNode start="(246, 12)" end="(246, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(247, 3)" end="(248, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(247, 3)" end="(247, 18)">
                              <OtherNode start="(247, 3)" end="(247, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(247, 3)" end="(247, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(247, 5)" end="(247, 9)">
                                  <NullNode/>
                                  <IdentNode start="(247, 5)" end="(247, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(247, 10)" end="(247, 18)">
                                  <IdentNode start="(247, 10)" end="(247, 12)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                  <IdentNode start="(247, 13)" end="(247, 15)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                  <IdentNode start="(247, 16)" end="(247, 18)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(247, 19)" end="(248, 27)">
                              <AtomNode start="(247, 19)" end="(247, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(248, 5)" end="(248, 27)">
                                <TacticTacticseq1IndentedNode start="(248, 5)" end="(248, 27)">
                                  <NullNode start="(248, 5)" end="(248, 27)">
                                    <OtherNode start="(248, 5)" end="(248, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;hl : α&#10;tl : List α&#10;ih : ∀ {l' : List β}, map f (zipWith Prod.mk tl l') = zipWith (Function.curry f) tl l'&#10;l' : List β&#10;⊢ map f (zipWith Prod.mk (hl :: tl) l') = zipWith (Function.curry f) (hl :: tl) l'" state_after="no goals" tactic="cases l' &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(248, 5)" end="(248, 13)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(248, 5)" end="(248, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(248, 11)" end="(248, 13)">
                                          <OtherNode start="(248, 11)" end="(248, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(248, 11)" end="(248, 13)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(248, 14)" end="(248, 17)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(248, 18)" end="(248, 27)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(248, 18)" end="(248, 22)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(248, 23)" end="(248, 27)">
                                          <AtomNode start="(248, 23)" end="(248, 24)" leading="" trailing="" val="["/>
                                          <NullNode start="(248, 24)" end="(248, 26)">
                                            <OtherNode start="(248, 24)" end="(248, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(248, 24)" end="(248, 26)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(248, 26)" end="(248, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(250, 1)" end="(250, 15)" comment="### zip -/">
      <AtomNode start="(250, 1)" end="(250, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(250, 5)" end="(250, 15)" leading="" trailing="&#10;&#10;" val="### zip -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(252, 1)" end="(255, 75)" name="zip_eq_zipWith" full_name="List.zip_eq_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(252, 1)" end="(255, 75)" name="zip_eq_zipWith" full_name="List.zip_eq_zipWith" _is_private_decl="False">
        <AtomNode start="(252, 1)" end="(252, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(252, 9)" end="(252, 23)">
          <IdentNode start="(252, 9)" end="(252, 23)" leading="" trailing=" " raw_val="zip_eq_zipWith" val="zip_eq_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(252, 24)" end="(252, 90)">
          <NullNode/>
          <TermTypespecNode start="(252, 24)" end="(252, 90)">
            <AtomNode start="(252, 24)" end="(252, 25)" leading="" trailing=" " val=":"/>
            <OtherNode start="(252, 26)" end="(252, 90)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(252, 26)" end="(252, 27)" leading="" trailing=" " val="∀"/>
              <NullNode start="(252, 28)" end="(252, 55)">
                <OtherNode start="(252, 28)" end="(252, 41)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(252, 28)" end="(252, 29)" leading="" trailing="" val="{"/>
                  <NullNode start="(252, 29)" end="(252, 31)">
                    <IdentNode start="(252, 29)" end="(252, 31)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(252, 32)" end="(252, 40)">
                    <AtomNode start="(252, 32)" end="(252, 33)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(252, 34)" end="(252, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(252, 34)" end="(252, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(252, 39)" end="(252, 40)">
                        <IdentNode start="(252, 39)" end="(252, 40)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(252, 40)" end="(252, 41)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(252, 42)" end="(252, 55)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(252, 42)" end="(252, 43)" leading="" trailing="" val="{"/>
                  <NullNode start="(252, 43)" end="(252, 45)">
                    <IdentNode start="(252, 43)" end="(252, 45)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(252, 46)" end="(252, 54)">
                    <AtomNode start="(252, 46)" end="(252, 47)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(252, 48)" end="(252, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(252, 48)" end="(252, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(252, 53)" end="(252, 54)">
                        <IdentNode start="(252, 53)" end="(252, 54)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(252, 54)" end="(252, 55)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(252, 55)" end="(252, 56)" leading="" trailing=" " val=","/>
              <OtherNode start="(252, 57)" end="(252, 90)" kind="«term_=_»">
                <OtherNode start="(252, 57)" end="(252, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(252, 57)" end="(252, 60)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(252, 61)" end="(252, 66)">
                    <IdentNode start="(252, 61)" end="(252, 63)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(252, 64)" end="(252, 66)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(252, 67)" end="(252, 68)" leading="" trailing=" " val="="/>
                <OtherNode start="(252, 69)" end="(252, 90)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(252, 69)" end="(252, 76)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(252, 77)" end="(252, 90)">
                    <IdentNode start="(252, 77)" end="(252, 84)" leading="" trailing=" " raw_val="Prod.mk" val="Prod.mk" full_name="Prod.mk" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <IdentNode start="(252, 85)" end="(252, 87)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(252, 88)" end="(252, 90)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(253, 3)" end="(255, 75)">
          <OtherNode start="(253, 3)" end="(255, 75)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(253, 3)" end="(255, 75)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(253, 3)" end="(255, 75)">
                <OtherNode start="(253, 3)" end="(253, 17)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(253, 3)" end="(253, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(253, 5)" end="(253, 10)">
                    <NullNode start="(253, 5)" end="(253, 10)">
                      <OtherNode start="(253, 5)" end="(253, 7)" kind="«term[_]»">
                        <AtomNode start="(253, 5)" end="(253, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(253, 6)" end="(253, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(253, 7)" end="(253, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(253, 9)" end="(253, 10)">
                        <AtomNode start="(253, 9)" end="(253, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(253, 11)" end="(253, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(253, 14)" end="(253, 17)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(254, 3)" end="(254, 17)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(254, 3)" end="(254, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(254, 5)" end="(254, 10)">
                    <NullNode start="(254, 5)" end="(254, 10)">
                      <TermHoleNode start="(254, 5)" end="(254, 6)">
                        <AtomNode start="(254, 5)" end="(254, 6)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(254, 6)" end="(254, 7)" leading="" trailing=" " val=","/>
                      <OtherNode start="(254, 8)" end="(254, 10)" kind="«term[_]»">
                        <AtomNode start="(254, 8)" end="(254, 9)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(254, 9)" end="(254, 10)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(254, 11)" end="(254, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(254, 14)" end="(254, 17)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(255, 3)" end="(255, 75)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(255, 3)" end="(255, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(255, 5)" end="(255, 21)">
                    <NullNode start="(255, 5)" end="(255, 21)">
                      <OtherNode start="(255, 5)" end="(255, 12)" kind="«term_::_»">
                        <IdentNode start="(255, 5)" end="(255, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(255, 7)" end="(255, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(255, 10)" end="(255, 12)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(255, 12)" end="(255, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(255, 14)" end="(255, 21)" kind="«term_::_»">
                        <IdentNode start="(255, 14)" end="(255, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(255, 16)" end="(255, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(255, 19)" end="(255, 21)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(255, 22)" end="(255, 24)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(255, 25)" end="(255, 75)">
                    <AtomNode start="(255, 25)" end="(255, 27)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(255, 28)" end="(255, 75)">
                      <TacticTacticseq1IndentedNode start="(255, 28)" end="(255, 75)">
                        <NullNode start="(255, 28)" end="(255, 75)">
                          <OtherNode start="(255, 28)" end="(255, 75)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;l₁ : List α&#10;b : β&#10;l₂ : List β&#10;⊢ (a :: l₁).zip (b :: l₂) = zipWith Prod.mk (a :: l₁) (b :: l₂)" state_after="no goals" tactic="simp [zip_cons_cons, zip_eq_zipWith (l₁ := l₁)]">
                            <AtomNode start="(255, 28)" end="(255, 32)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(255, 33)" end="(255, 75)">
                              <AtomNode start="(255, 33)" end="(255, 34)" leading="" trailing="" val="["/>
                              <NullNode start="(255, 34)" end="(255, 74)">
                                <OtherNode start="(255, 34)" end="(255, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(255, 34)" end="(255, 47)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(255, 47)" end="(255, 48)" leading="" trailing=" " val=","/>
                                <OtherNode start="(255, 49)" end="(255, 74)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(255, 49)" end="(255, 74)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(255, 49)" end="(255, 63)" leading="" trailing=" " raw_val="zip_eq_zipWith" val="zip_eq_zipWith"/>
                                    <NullNode start="(255, 64)" end="(255, 74)">
                                      <OtherNode start="(255, 64)" end="(255, 74)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(255, 64)" end="(255, 65)" leading="" trailing="" val="("/>
                                        <IdentNode start="(255, 65)" end="(255, 67)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                        <AtomNode start="(255, 68)" end="(255, 70)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(255, 71)" end="(255, 73)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                        <AtomNode start="(255, 73)" end="(255, 74)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(255, 74)" end="(255, 75)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(257, 1)" end="(261, 75)" name="zip_map" full_name="List.zip_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(257, 1)" end="(261, 75)" name="zip_map" full_name="List.zip_map" _is_private_decl="False">
        <AtomNode start="(257, 1)" end="(257, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(257, 9)" end="(257, 16)">
          <IdentNode start="(257, 9)" end="(257, 16)" leading="" trailing=" " raw_val="zip_map" val="zip_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(257, 17)" end="(258, 94)">
          <NullNode start="(257, 17)" end="(257, 40)">
            <OtherNode start="(257, 17)" end="(257, 28)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(257, 17)" end="(257, 18)" leading="" trailing="" val="{"/>
              <NullNode start="(257, 18)" end="(257, 19)">
                <IdentNode start="(257, 18)" end="(257, 19)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(257, 20)" end="(257, 27)">
                <AtomNode start="(257, 20)" end="(257, 21)" leading="" trailing=" " val=":"/>
                <OtherNode start="(257, 22)" end="(257, 27)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(257, 22)" end="(257, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(257, 24)" end="(257, 25)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(257, 26)" end="(257, 27)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(257, 27)" end="(257, 28)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(257, 29)" end="(257, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(257, 29)" end="(257, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(257, 30)" end="(257, 31)">
                <IdentNode start="(257, 30)" end="(257, 31)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(257, 32)" end="(257, 39)">
                <AtomNode start="(257, 32)" end="(257, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(257, 34)" end="(257, 39)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(257, 34)" end="(257, 35)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(257, 36)" end="(257, 37)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(257, 38)" end="(257, 39)" leading="" trailing="" raw_val="δ" val="δ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(257, 39)" end="(257, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(257, 41)" end="(258, 94)">
            <AtomNode start="(257, 41)" end="(257, 42)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(258, 5)" end="(258, 94)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(258, 5)" end="(258, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(258, 7)" end="(258, 34)">
                <OtherNode start="(258, 7)" end="(258, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(258, 7)" end="(258, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(258, 8)" end="(258, 10)">
                    <IdentNode start="(258, 8)" end="(258, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(258, 11)" end="(258, 19)">
                    <AtomNode start="(258, 11)" end="(258, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(258, 13)" end="(258, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(258, 13)" end="(258, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(258, 18)" end="(258, 19)">
                        <IdentNode start="(258, 18)" end="(258, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(258, 19)" end="(258, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(258, 21)" end="(258, 34)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(258, 21)" end="(258, 22)" leading="" trailing="" val="{"/>
                  <NullNode start="(258, 22)" end="(258, 24)">
                    <IdentNode start="(258, 22)" end="(258, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(258, 25)" end="(258, 33)">
                    <AtomNode start="(258, 25)" end="(258, 26)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(258, 27)" end="(258, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(258, 27)" end="(258, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(258, 32)" end="(258, 33)">
                        <IdentNode start="(258, 32)" end="(258, 33)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(258, 33)" end="(258, 34)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(258, 34)" end="(258, 35)" leading="" trailing=" " val=","/>
              <OtherNode start="(258, 36)" end="(258, 94)" kind="«term_=_»">
                <OtherNode start="(258, 36)" end="(258, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(258, 36)" end="(258, 39)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(258, 40)" end="(258, 61)">
                    <OtherNode start="(258, 40)" end="(258, 50)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(258, 40)" end="(258, 41)" leading="" trailing="" val="("/>
                      <OtherNode start="(258, 41)" end="(258, 49)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(258, 41)" end="(258, 47)" leading="" trailing=" " raw_val="l₁.map" val="l₁.map"/>
                        <NullNode start="(258, 48)" end="(258, 49)">
                          <IdentNode start="(258, 48)" end="(258, 49)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(258, 49)" end="(258, 50)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(258, 51)" end="(258, 61)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(258, 51)" end="(258, 52)" leading="" trailing="" val="("/>
                      <OtherNode start="(258, 52)" end="(258, 60)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(258, 52)" end="(258, 58)" leading="" trailing=" " raw_val="l₂.map" val="l₂.map"/>
                        <NullNode start="(258, 59)" end="(258, 60)">
                          <IdentNode start="(258, 59)" end="(258, 60)" leading="" trailing="" raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(258, 60)" end="(258, 61)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(258, 62)" end="(258, 63)" leading="" trailing=" " val="="/>
                <OtherNode start="(258, 64)" end="(258, 94)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(258, 64)" end="(258, 79)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(258, 64)" end="(258, 75)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(258, 64)" end="(258, 65)" leading="" trailing="" val="("/>
                      <OtherNode start="(258, 65)" end="(258, 74)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(258, 65)" end="(258, 68)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(258, 69)" end="(258, 74)">
                          <IdentNode start="(258, 69)" end="(258, 71)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <IdentNode start="(258, 72)" end="(258, 74)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(258, 74)" end="(258, 75)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(258, 75)" end="(258, 76)" leading="" trailing="" val="."/>
                    <IdentNode start="(258, 76)" end="(258, 79)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(258, 80)" end="(258, 94)">
                    <OtherNode start="(258, 80)" end="(258, 94)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(258, 80)" end="(258, 81)" leading="" trailing="" val="("/>
                      <OtherNode start="(258, 81)" end="(258, 93)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(258, 81)" end="(258, 89)" leading="" trailing=" " raw_val="Prod.map" val="Prod.map" full_name="Prod.map" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        <NullNode start="(258, 90)" end="(258, 93)">
                          <IdentNode start="(258, 90)" end="(258, 91)" leading="" trailing=" " raw_val="f" val="f"/>
                          <IdentNode start="(258, 92)" end="(258, 93)" leading="" trailing="" raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(258, 93)" end="(258, 94)" leading="" trailing="&#10;  " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(259, 3)" end="(261, 75)">
          <OtherNode start="(259, 3)" end="(261, 75)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(259, 3)" end="(261, 75)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(259, 3)" end="(261, 75)">
                <OtherNode start="(259, 3)" end="(259, 17)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(259, 3)" end="(259, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(259, 5)" end="(259, 10)">
                    <NullNode start="(259, 5)" end="(259, 10)">
                      <OtherNode start="(259, 5)" end="(259, 7)" kind="«term[_]»">
                        <AtomNode start="(259, 5)" end="(259, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(259, 6)" end="(259, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(259, 7)" end="(259, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(259, 9)" end="(259, 10)">
                        <AtomNode start="(259, 9)" end="(259, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(259, 11)" end="(259, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(259, 14)" end="(259, 17)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(260, 3)" end="(260, 47)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(260, 3)" end="(260, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(260, 5)" end="(260, 10)">
                    <NullNode start="(260, 5)" end="(260, 10)">
                      <TermHoleNode start="(260, 5)" end="(260, 6)">
                        <AtomNode start="(260, 5)" end="(260, 6)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(260, 6)" end="(260, 7)" leading="" trailing=" " val=","/>
                      <OtherNode start="(260, 8)" end="(260, 10)" kind="«term[_]»">
                        <AtomNode start="(260, 8)" end="(260, 9)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(260, 9)" end="(260, 10)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(260, 11)" end="(260, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(260, 14)" end="(260, 47)">
                    <AtomNode start="(260, 14)" end="(260, 16)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(260, 17)" end="(260, 47)">
                      <TacticTacticseq1IndentedNode start="(260, 17)" end="(260, 47)">
                        <NullNode start="(260, 17)" end="(260, 47)">
                          <OtherNode start="(260, 17)" end="(260, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;δ : Type u_4&#10;f : α → γ&#10;g : β → δ&#10;x✝ : List α&#10;⊢ (map f x✝).zip (map g []) = map (Prod.map f g) (x✝.zip [])" state_after="no goals" tactic="simp only [map, zip_nil_right]">
                            <AtomNode start="(260, 17)" end="(260, 21)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(260, 22)" end="(260, 26)">
                              <AtomNode start="(260, 22)" end="(260, 26)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(260, 27)" end="(260, 47)">
                              <AtomNode start="(260, 27)" end="(260, 28)" leading="" trailing="" val="["/>
                              <NullNode start="(260, 28)" end="(260, 46)">
                                <OtherNode start="(260, 28)" end="(260, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(260, 28)" end="(260, 31)" leading="" trailing="" raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(260, 31)" end="(260, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(260, 33)" end="(260, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(260, 33)" end="(260, 46)" leading="" trailing="" raw_val="zip_nil_right" val="zip_nil_right" full_name="List.zip_nil_right" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(260, 46)" end="(260, 47)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(261, 3)" end="(261, 75)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(261, 3)" end="(261, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(261, 5)" end="(261, 19)">
                    <NullNode start="(261, 5)" end="(261, 19)">
                      <OtherNode start="(261, 5)" end="(261, 11)" kind="«term_::_»">
                        <TermHoleNode start="(261, 5)" end="(261, 6)">
                          <AtomNode start="(261, 5)" end="(261, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(261, 7)" end="(261, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(261, 10)" end="(261, 11)">
                          <AtomNode start="(261, 10)" end="(261, 11)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(261, 11)" end="(261, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(261, 13)" end="(261, 19)" kind="«term_::_»">
                        <TermHoleNode start="(261, 13)" end="(261, 14)">
                          <AtomNode start="(261, 13)" end="(261, 14)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(261, 15)" end="(261, 17)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(261, 18)" end="(261, 19)">
                          <AtomNode start="(261, 18)" end="(261, 19)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(261, 20)" end="(261, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(261, 23)" end="(261, 75)">
                    <AtomNode start="(261, 23)" end="(261, 25)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(261, 26)" end="(261, 75)">
                      <TacticTacticseq1IndentedNode start="(261, 26)" end="(261, 75)">
                        <NullNode start="(261, 26)" end="(261, 75)">
                          <OtherNode start="(261, 26)" end="(261, 75)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;δ : Type u_4&#10;f : α → γ&#10;g : β → δ&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : β&#10;tail✝ : List β&#10;⊢ (map f (head✝¹ :: tail✝¹)).zip (map g (head✝ :: tail✝)) = map (Prod.map f g) ((head✝¹ :: tail✝¹).zip (head✝ :: tail✝))" state_after="no goals" tactic="simp only [map, zip_cons_cons, zip_map, Prod.map]">
                            <AtomNode start="(261, 26)" end="(261, 30)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(261, 31)" end="(261, 35)">
                              <AtomNode start="(261, 31)" end="(261, 35)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(261, 36)" end="(261, 75)">
                              <AtomNode start="(261, 36)" end="(261, 37)" leading="" trailing="" val="["/>
                              <NullNode start="(261, 37)" end="(261, 74)">
                                <OtherNode start="(261, 37)" end="(261, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(261, 37)" end="(261, 40)" leading="" trailing="" raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(261, 40)" end="(261, 41)" leading="" trailing=" " val=","/>
                                <OtherNode start="(261, 42)" end="(261, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(261, 42)" end="(261, 55)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(261, 55)" end="(261, 56)" leading="" trailing=" " val=","/>
                                <OtherNode start="(261, 57)" end="(261, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(261, 57)" end="(261, 64)" leading="" trailing="" raw_val="zip_map" val="zip_map"/>
                                </OtherNode>
                                <AtomNode start="(261, 64)" end="(261, 65)" leading="" trailing=" " val=","/>
                                <OtherNode start="(261, 66)" end="(261, 74)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(261, 66)" end="(261, 74)" leading="" trailing="" raw_val="Prod.map" val="Prod.map" full_name="Prod.map" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(261, 74)" end="(261, 75)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(263, 1)" end="(264, 85)" name="zip_map_left" full_name="List.zip_map_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(263, 1)" end="(264, 85)" name="zip_map_left" full_name="List.zip_map_left" _is_private_decl="False">
        <AtomNode start="(263, 1)" end="(263, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(263, 9)" end="(263, 21)">
          <IdentNode start="(263, 9)" end="(263, 21)" leading="" trailing=" " raw_val="zip_map_left" val="zip_map_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(263, 22)" end="(264, 56)">
          <NullNode start="(263, 22)" end="(263, 61)">
            <OtherNode start="(263, 22)" end="(263, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(263, 22)" end="(263, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(263, 23)" end="(263, 24)">
                <IdentNode start="(263, 23)" end="(263, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(263, 25)" end="(263, 32)">
                <AtomNode start="(263, 25)" end="(263, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(263, 27)" end="(263, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(263, 27)" end="(263, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(263, 29)" end="(263, 30)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(263, 31)" end="(263, 32)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(263, 32)" end="(263, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(263, 34)" end="(263, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(263, 34)" end="(263, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(263, 35)" end="(263, 37)">
                <IdentNode start="(263, 35)" end="(263, 37)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(263, 38)" end="(263, 46)">
                <AtomNode start="(263, 38)" end="(263, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(263, 40)" end="(263, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(263, 40)" end="(263, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(263, 45)" end="(263, 46)">
                    <IdentNode start="(263, 45)" end="(263, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(263, 46)" end="(263, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(263, 48)" end="(263, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(263, 48)" end="(263, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(263, 49)" end="(263, 51)">
                <IdentNode start="(263, 49)" end="(263, 51)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(263, 52)" end="(263, 60)">
                <AtomNode start="(263, 52)" end="(263, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(263, 54)" end="(263, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(263, 54)" end="(263, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(263, 59)" end="(263, 60)">
                    <IdentNode start="(263, 59)" end="(263, 60)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(263, 60)" end="(263, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(263, 62)" end="(264, 56)">
            <AtomNode start="(263, 62)" end="(263, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(264, 5)" end="(264, 56)" kind="«term_=_»">
              <OtherNode start="(264, 5)" end="(264, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(264, 5)" end="(264, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(264, 9)" end="(264, 22)">
                  <OtherNode start="(264, 9)" end="(264, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(264, 9)" end="(264, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(264, 10)" end="(264, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(264, 10)" end="(264, 16)" leading="" trailing=" " raw_val="l₁.map" val="l₁.map"/>
                      <NullNode start="(264, 17)" end="(264, 18)">
                        <IdentNode start="(264, 17)" end="(264, 18)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(264, 18)" end="(264, 19)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(264, 20)" end="(264, 22)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(264, 23)" end="(264, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(264, 25)" end="(264, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(264, 25)" end="(264, 40)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(264, 25)" end="(264, 36)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(264, 25)" end="(264, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(264, 26)" end="(264, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(264, 26)" end="(264, 29)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(264, 30)" end="(264, 35)">
                        <IdentNode start="(264, 30)" end="(264, 32)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(264, 33)" end="(264, 35)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(264, 35)" end="(264, 36)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(264, 36)" end="(264, 37)" leading="" trailing="" val="."/>
                  <IdentNode start="(264, 37)" end="(264, 40)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(264, 41)" end="(264, 56)">
                  <OtherNode start="(264, 41)" end="(264, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(264, 41)" end="(264, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(264, 42)" end="(264, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(264, 42)" end="(264, 50)" leading="" trailing=" " raw_val="Prod.map" val="Prod.map" full_name="Prod.map" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      <NullNode start="(264, 51)" end="(264, 55)">
                        <IdentNode start="(264, 51)" end="(264, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(264, 53)" end="(264, 55)" leading="" trailing="" raw_val="id" val="id" full_name="id" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(264, 55)" end="(264, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(264, 57)" end="(264, 85)">
          <AtomNode start="(264, 57)" end="(264, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(264, 60)" end="(264, 85)">
            <AtomNode start="(264, 60)" end="(264, 62)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(264, 63)" end="(264, 85)">
              <TacticTacticseq1IndentedNode start="(264, 63)" end="(264, 85)">
                <NullNode start="(264, 63)" end="(264, 85)">
                  <OtherNode start="(264, 63)" end="(264, 85)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;f : α → γ&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (map f l₁).zip l₂ = map (Prod.map f id) (l₁.zip l₂)" state_after="no goals" tactic="rw [← zip_map, map_id]">
                    <AtomNode start="(264, 63)" end="(264, 65)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(264, 66)" end="(264, 85)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(264, 66)" end="(264, 67)" leading="" trailing="" val="["/>
                      <NullNode start="(264, 67)" end="(264, 84)">
                        <OtherNode start="(264, 67)" end="(264, 76)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(264, 67)" end="(264, 68)">
                            <OtherNode start="(264, 67)" end="(264, 68)" kind="patternIgnore">
                              <OtherNode start="(264, 67)" end="(264, 68)" kind="token.«← »">
                                <AtomNode start="(264, 67)" end="(264, 68)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(264, 69)" end="(264, 76)" leading="" trailing="" raw_val="zip_map" val="zip_map" full_name="List.zip_map" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(257, 9)" def_end="(257, 16)"/>
                        </OtherNode>
                        <AtomNode start="(264, 76)" end="(264, 77)" leading="" trailing=" " val=","/>
                        <OtherNode start="(264, 78)" end="(264, 84)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(264, 78)" end="(264, 84)" leading="" trailing="" raw_val="map_id" val="map_id" full_name="List.map_id" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(264, 84)" end="(264, 85)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(266, 1)" end="(267, 85)" name="zip_map_right" full_name="List.zip_map_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(266, 1)" end="(267, 85)" name="zip_map_right" full_name="List.zip_map_right" _is_private_decl="False">
        <AtomNode start="(266, 1)" end="(266, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(266, 9)" end="(266, 22)">
          <IdentNode start="(266, 9)" end="(266, 22)" leading="" trailing=" " raw_val="zip_map_right" val="zip_map_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(266, 23)" end="(267, 56)">
          <NullNode start="(266, 23)" end="(266, 62)">
            <OtherNode start="(266, 23)" end="(266, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(266, 23)" end="(266, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(266, 24)" end="(266, 25)">
                <IdentNode start="(266, 24)" end="(266, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(266, 26)" end="(266, 33)">
                <AtomNode start="(266, 26)" end="(266, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 28)" end="(266, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(266, 28)" end="(266, 29)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(266, 30)" end="(266, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(266, 32)" end="(266, 33)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(266, 33)" end="(266, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(266, 35)" end="(266, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(266, 35)" end="(266, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(266, 36)" end="(266, 38)">
                <IdentNode start="(266, 36)" end="(266, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(266, 39)" end="(266, 47)">
                <AtomNode start="(266, 39)" end="(266, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 41)" end="(266, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(266, 41)" end="(266, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(266, 46)" end="(266, 47)">
                    <IdentNode start="(266, 46)" end="(266, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(266, 47)" end="(266, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(266, 49)" end="(266, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(266, 49)" end="(266, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(266, 50)" end="(266, 52)">
                <IdentNode start="(266, 50)" end="(266, 52)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(266, 53)" end="(266, 61)">
                <AtomNode start="(266, 53)" end="(266, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 55)" end="(266, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(266, 55)" end="(266, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(266, 60)" end="(266, 61)">
                    <IdentNode start="(266, 60)" end="(266, 61)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(266, 61)" end="(266, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(266, 63)" end="(267, 56)">
            <AtomNode start="(266, 63)" end="(266, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(267, 5)" end="(267, 56)" kind="«term_=_»">
              <OtherNode start="(267, 5)" end="(267, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(267, 5)" end="(267, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(267, 9)" end="(267, 22)">
                  <IdentNode start="(267, 9)" end="(267, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <OtherNode start="(267, 12)" end="(267, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(267, 12)" end="(267, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(267, 13)" end="(267, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(267, 13)" end="(267, 19)" leading="" trailing=" " raw_val="l₂.map" val="l₂.map"/>
                      <NullNode start="(267, 20)" end="(267, 21)">
                        <IdentNode start="(267, 20)" end="(267, 21)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(267, 21)" end="(267, 22)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(267, 23)" end="(267, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(267, 25)" end="(267, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(267, 25)" end="(267, 40)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(267, 25)" end="(267, 36)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(267, 25)" end="(267, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(267, 26)" end="(267, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(267, 26)" end="(267, 29)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(267, 30)" end="(267, 35)">
                        <IdentNode start="(267, 30)" end="(267, 32)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(267, 33)" end="(267, 35)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(267, 35)" end="(267, 36)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(267, 36)" end="(267, 37)" leading="" trailing="" val="."/>
                  <IdentNode start="(267, 37)" end="(267, 40)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(267, 41)" end="(267, 56)">
                  <OtherNode start="(267, 41)" end="(267, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(267, 41)" end="(267, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(267, 42)" end="(267, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(267, 42)" end="(267, 50)" leading="" trailing=" " raw_val="Prod.map" val="Prod.map" full_name="Prod.map" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      <NullNode start="(267, 51)" end="(267, 55)">
                        <IdentNode start="(267, 51)" end="(267, 53)" leading="" trailing=" " raw_val="id" val="id" full_name="id" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <IdentNode start="(267, 54)" end="(267, 55)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(267, 55)" end="(267, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(267, 57)" end="(267, 85)">
          <AtomNode start="(267, 57)" end="(267, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(267, 60)" end="(267, 85)">
            <AtomNode start="(267, 60)" end="(267, 62)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(267, 63)" end="(267, 85)">
              <TacticTacticseq1IndentedNode start="(267, 63)" end="(267, 85)">
                <NullNode start="(267, 63)" end="(267, 85)">
                  <OtherNode start="(267, 63)" end="(267, 85)" kind="Lean.Parser.Tactic.rwSeq" state_before="β : Type u_1&#10;γ : Type u_2&#10;α : Type u_3&#10;f : β → γ&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ l₁.zip (map f l₂) = map (Prod.map id f) (l₁.zip l₂)" state_after="no goals" tactic="rw [← zip_map, map_id]">
                    <AtomNode start="(267, 63)" end="(267, 65)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(267, 66)" end="(267, 85)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(267, 66)" end="(267, 67)" leading="" trailing="" val="["/>
                      <NullNode start="(267, 67)" end="(267, 84)">
                        <OtherNode start="(267, 67)" end="(267, 76)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(267, 67)" end="(267, 68)">
                            <OtherNode start="(267, 67)" end="(267, 68)" kind="patternIgnore">
                              <OtherNode start="(267, 67)" end="(267, 68)" kind="token.«← »">
                                <AtomNode start="(267, 67)" end="(267, 68)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(267, 69)" end="(267, 76)" leading="" trailing="" raw_val="zip_map" val="zip_map" full_name="List.zip_map" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(257, 9)" def_end="(257, 16)"/>
                        </OtherNode>
                        <AtomNode start="(267, 76)" end="(267, 77)" leading="" trailing=" " val=","/>
                        <OtherNode start="(267, 78)" end="(267, 84)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(267, 78)" end="(267, 84)" leading="" trailing="" raw_val="map_id" val="map_id" full_name="List.map_id" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(267, 84)" end="(267, 85)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(269, 1)" end="(271, 33)" name="tail_zip" full_name="List.tail_zip">
      <CommandDeclmodifiersNode start="(269, 1)" end="(269, 8)">
        <NullNode/>
        <NullNode start="(269, 1)" end="(269, 8)">
          <OtherNode start="(269, 1)" end="(269, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(269, 1)" end="(269, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(269, 3)" end="(269, 7)">
              <OtherNode start="(269, 3)" end="(269, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(269, 3)" end="(269, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(269, 3)" end="(269, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(269, 7)" end="(269, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(269, 9)" end="(271, 33)" name="tail_zip" full_name="List.tail_zip" _is_private_decl="False">
        <AtomNode start="(269, 9)" end="(269, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(269, 17)" end="(269, 25)">
          <IdentNode start="(269, 17)" end="(269, 25)" leading="" trailing=" " raw_val="tail_zip" val="tail_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(269, 26)" end="(270, 43)">
          <NullNode start="(269, 26)" end="(269, 53)">
            <OtherNode start="(269, 26)" end="(269, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(269, 26)" end="(269, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(269, 27)" end="(269, 29)">
                <IdentNode start="(269, 27)" end="(269, 29)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(269, 30)" end="(269, 38)">
                <AtomNode start="(269, 30)" end="(269, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(269, 32)" end="(269, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(269, 32)" end="(269, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(269, 37)" end="(269, 38)">
                    <IdentNode start="(269, 37)" end="(269, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(269, 38)" end="(269, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(269, 40)" end="(269, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(269, 40)" end="(269, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(269, 41)" end="(269, 43)">
                <IdentNode start="(269, 41)" end="(269, 43)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(269, 44)" end="(269, 52)">
                <AtomNode start="(269, 44)" end="(269, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(269, 46)" end="(269, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(269, 46)" end="(269, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(269, 51)" end="(269, 52)">
                    <IdentNode start="(269, 51)" end="(269, 52)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(269, 52)" end="(269, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(269, 54)" end="(270, 43)">
            <AtomNode start="(269, 54)" end="(269, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(270, 5)" end="(270, 43)" kind="«term_=_»">
              <OtherNode start="(270, 5)" end="(270, 21)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(270, 5)" end="(270, 16)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(270, 5)" end="(270, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(270, 6)" end="(270, 15)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(270, 6)" end="(270, 9)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(270, 10)" end="(270, 15)">
                      <IdentNode start="(270, 10)" end="(270, 12)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(270, 13)" end="(270, 15)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(270, 15)" end="(270, 16)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(270, 16)" end="(270, 17)" leading="" trailing="" val="."/>
                <IdentNode start="(270, 17)" end="(270, 21)" leading="" trailing=" " raw_val="tail" val="tail" full_name="List.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(270, 22)" end="(270, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(270, 24)" end="(270, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(270, 24)" end="(270, 27)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(270, 28)" end="(270, 43)">
                  <IdentNode start="(270, 28)" end="(270, 35)" leading="" trailing=" " raw_val="l₁.tail" val="l₁.tail"/>
                  <IdentNode start="(270, 36)" end="(270, 43)" leading="" trailing=" " raw_val="l₂.tail" val="l₂.tail"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(270, 44)" end="(271, 33)">
          <AtomNode start="(270, 44)" end="(270, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(270, 47)" end="(271, 33)">
            <AtomNode start="(270, 47)" end="(270, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(271, 3)" end="(271, 33)">
              <TacticTacticseq1IndentedNode start="(271, 3)" end="(271, 33)">
                <NullNode start="(271, 3)" end="(271, 33)">
                  <OtherNode start="(271, 3)" end="(271, 33)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (l₁.zip l₂).tail = l₁.tail.zip l₂.tail" state_after="no goals" tactic="cases l₁ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(271, 3)" end="(271, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(271, 3)" end="(271, 11)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(271, 3)" end="(271, 8)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(271, 9)" end="(271, 11)">
                          <OtherNode start="(271, 9)" end="(271, 11)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(271, 9)" end="(271, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(271, 12)" end="(271, 15)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(271, 16)" end="(271, 24)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(271, 16)" end="(271, 21)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(271, 22)" end="(271, 24)">
                          <OtherNode start="(271, 22)" end="(271, 24)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(271, 22)" end="(271, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(271, 25)" end="(271, 28)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(271, 29)" end="(271, 33)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(271, 29)" end="(271, 33)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(273, 1)" end="(279, 72)" name="zip_append" full_name="List.zip_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(273, 1)" end="(279, 72)" name="zip_append" full_name="List.zip_append" _is_private_decl="False">
        <AtomNode start="(273, 1)" end="(273, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(273, 9)" end="(273, 19)">
          <IdentNode start="(273, 9)" end="(273, 19)" leading="" trailing=" " raw_val="zip_append" val="zip_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(273, 20)" end="(275, 57)">
          <NullNode/>
          <TermTypespecNode start="(273, 20)" end="(275, 57)">
            <AtomNode start="(273, 20)" end="(273, 21)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(274, 5)" end="(275, 57)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(274, 5)" end="(274, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(274, 7)" end="(274, 69)">
                <OtherNode start="(274, 7)" end="(274, 23)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(274, 7)" end="(274, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(274, 8)" end="(274, 13)">
                    <IdentNode start="(274, 8)" end="(274, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(274, 11)" end="(274, 13)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                  </NullNode>
                  <NullNode start="(274, 14)" end="(274, 22)">
                    <AtomNode start="(274, 14)" end="(274, 15)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(274, 16)" end="(274, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(274, 16)" end="(274, 20)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(274, 21)" end="(274, 22)">
                        <IdentNode start="(274, 21)" end="(274, 22)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(274, 22)" end="(274, 23)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(274, 24)" end="(274, 40)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(274, 24)" end="(274, 25)" leading="" trailing="" val="{"/>
                  <NullNode start="(274, 25)" end="(274, 30)">
                    <IdentNode start="(274, 25)" end="(274, 27)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    <IdentNode start="(274, 28)" end="(274, 30)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
                  </NullNode>
                  <NullNode start="(274, 31)" end="(274, 39)">
                    <AtomNode start="(274, 31)" end="(274, 32)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(274, 33)" end="(274, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(274, 33)" end="(274, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(274, 38)" end="(274, 39)">
                        <IdentNode start="(274, 38)" end="(274, 39)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(274, 39)" end="(274, 40)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <TermExplicitbinderNode start="(274, 41)" end="(274, 69)">
                  <AtomNode start="(274, 41)" end="(274, 42)" leading="" trailing="" val="("/>
                  <NullNode start="(274, 42)" end="(274, 44)">
                    <IdentNode start="(274, 42)" end="(274, 44)" leading="" trailing=" " raw_val="_h" val="_h"/>
                  </NullNode>
                  <NullNode start="(274, 45)" end="(274, 68)">
                    <AtomNode start="(274, 45)" end="(274, 46)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(274, 47)" end="(274, 68)" kind="«term_=_»">
                      <OtherNode start="(274, 47)" end="(274, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(274, 47)" end="(274, 53)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(274, 54)" end="(274, 56)">
                          <IdentNode start="(274, 54)" end="(274, 56)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(274, 57)" end="(274, 58)" leading="" trailing=" " val="="/>
                      <OtherNode start="(274, 59)" end="(274, 68)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(274, 59)" end="(274, 65)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(274, 66)" end="(274, 68)">
                          <IdentNode start="(274, 66)" end="(274, 68)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(274, 68)" end="(274, 69)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(274, 69)" end="(274, 70)" leading="" trailing="&#10;      " val=","/>
              <OtherNode start="(275, 7)" end="(275, 57)" kind="«term_=_»">
                <OtherNode start="(275, 7)" end="(275, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(275, 7)" end="(275, 10)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(275, 11)" end="(275, 32)">
                    <OtherNode start="(275, 11)" end="(275, 21)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(275, 11)" end="(275, 12)" leading="" trailing="" val="("/>
                      <OtherNode start="(275, 12)" end="(275, 20)" kind="«term_++_»">
                        <IdentNode start="(275, 12)" end="(275, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <AtomNode start="(275, 15)" end="(275, 17)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(275, 18)" end="(275, 20)" leading="" trailing="" raw_val="r₁" val="r₁"/>
                      </OtherNode>
                      <AtomNode start="(275, 20)" end="(275, 21)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(275, 22)" end="(275, 32)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(275, 22)" end="(275, 23)" leading="" trailing="" val="("/>
                      <OtherNode start="(275, 23)" end="(275, 31)" kind="«term_++_»">
                        <IdentNode start="(275, 23)" end="(275, 25)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <AtomNode start="(275, 26)" end="(275, 28)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(275, 29)" end="(275, 31)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                      </OtherNode>
                      <AtomNode start="(275, 31)" end="(275, 32)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(275, 33)" end="(275, 34)" leading="" trailing=" " val="="/>
                <OtherNode start="(275, 35)" end="(275, 57)" kind="«term_++_»">
                  <OtherNode start="(275, 35)" end="(275, 44)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(275, 35)" end="(275, 38)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(275, 39)" end="(275, 44)">
                      <IdentNode start="(275, 39)" end="(275, 41)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(275, 42)" end="(275, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(275, 45)" end="(275, 47)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(275, 48)" end="(275, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(275, 48)" end="(275, 51)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(275, 52)" end="(275, 57)">
                      <IdentNode start="(275, 52)" end="(275, 54)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                      <IdentNode start="(275, 55)" end="(275, 57)" leading="" trailing="&#10;  " raw_val="r₂" val="r₂"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(276, 3)" end="(279, 72)">
          <OtherNode start="(276, 3)" end="(279, 72)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(276, 3)" end="(279, 72)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(276, 3)" end="(279, 72)">
                <OtherNode start="(276, 3)" end="(276, 74)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(276, 3)" end="(276, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(276, 5)" end="(276, 19)">
                    <NullNode start="(276, 5)" end="(276, 19)">
                      <OtherNode start="(276, 5)" end="(276, 7)" kind="«term[_]»">
                        <AtomNode start="(276, 5)" end="(276, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(276, 6)" end="(276, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(276, 7)" end="(276, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(276, 9)" end="(276, 10)">
                        <AtomNode start="(276, 9)" end="(276, 10)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(276, 10)" end="(276, 11)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(276, 12)" end="(276, 13)">
                        <AtomNode start="(276, 12)" end="(276, 13)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(276, 13)" end="(276, 14)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(276, 15)" end="(276, 16)">
                        <AtomNode start="(276, 15)" end="(276, 16)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(276, 16)" end="(276, 17)" leading="" trailing=" " val=","/>
                      <IdentNode start="(276, 18)" end="(276, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(276, 20)" end="(276, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(276, 23)" end="(276, 74)">
                    <AtomNode start="(276, 23)" end="(276, 25)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(276, 26)" end="(276, 74)">
                      <TacticTacticseq1IndentedNode start="(276, 26)" end="(276, 74)">
                        <NullNode start="(276, 26)" end="(276, 74)">
                          <OtherNode start="(276, 26)" end="(276, 69)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝² : List α&#10;x✝¹ x✝ : List β&#10;h : [].length = x✝¹.length&#10;⊢ ([] ++ x✝²).zip (x✝¹ ++ x✝) = [].zip x✝¹ ++ x✝².zip x✝" state_after="α : Type u_1&#10;β : Type u_2&#10;x✝² : List α&#10;x✝¹ x✝ : List β&#10;h : [].length = x✝¹.length&#10;⊢ ([] ++ x✝²).zip ([] ++ x✝) = [].zip [] ++ x✝².zip x✝" tactic="simp only [eq_nil_of_length_eq_zero h.symm]">
                            <AtomNode start="(276, 26)" end="(276, 30)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(276, 31)" end="(276, 35)">
                              <AtomNode start="(276, 31)" end="(276, 35)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(276, 36)" end="(276, 69)">
                              <AtomNode start="(276, 36)" end="(276, 37)" leading="" trailing="" val="["/>
                              <NullNode start="(276, 37)" end="(276, 68)">
                                <OtherNode start="(276, 37)" end="(276, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(276, 37)" end="(276, 68)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(276, 37)" end="(276, 61)" leading="" trailing=" " raw_val="eq_nil_of_length_eq_zero" val="eq_nil_of_length_eq_zero" full_name="List.eq_nil_of_length_eq_zero" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                    <NullNode start="(276, 62)" end="(276, 68)">
                                      <IdentNode start="(276, 62)" end="(276, 68)" leading="" trailing="" raw_val="h.symm" val="h.symm"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(276, 68)" end="(276, 69)" leading="" trailing="" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(276, 69)" end="(276, 70)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(276, 71)" end="(276, 74)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝² : List α&#10;x✝¹ x✝ : List β&#10;h : [].length = x✝¹.length&#10;⊢ ([] ++ x✝²).zip ([] ++ x✝) = [].zip [] ++ x✝².zip x✝" state_after="no goals" tactic="rfl">
                            <AtomNode start="(276, 71)" end="(276, 74)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(277, 3)" end="(277, 69)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(277, 3)" end="(277, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(277, 5)" end="(277, 19)">
                    <NullNode start="(277, 5)" end="(277, 19)">
                      <TermHoleNode start="(277, 5)" end="(277, 6)">
                        <AtomNode start="(277, 5)" end="(277, 6)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(277, 6)" end="(277, 7)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(277, 8)" end="(277, 9)">
                        <AtomNode start="(277, 8)" end="(277, 9)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(277, 9)" end="(277, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(277, 11)" end="(277, 13)" kind="«term[_]»">
                        <AtomNode start="(277, 11)" end="(277, 12)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(277, 12)" end="(277, 13)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(277, 13)" end="(277, 14)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(277, 15)" end="(277, 16)">
                        <AtomNode start="(277, 15)" end="(277, 16)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(277, 16)" end="(277, 17)" leading="" trailing=" " val=","/>
                      <IdentNode start="(277, 18)" end="(277, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(277, 20)" end="(277, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(277, 23)" end="(277, 69)">
                    <AtomNode start="(277, 23)" end="(277, 25)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(277, 26)" end="(277, 69)">
                      <TacticTacticseq1IndentedNode start="(277, 26)" end="(277, 69)">
                        <NullNode start="(277, 26)" end="(277, 69)">
                          <OtherNode start="(277, 26)" end="(277, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝² x✝¹ : List α&#10;x✝ : List β&#10;h : x✝².length = [].length&#10;⊢ (x✝² ++ x✝¹).zip ([] ++ x✝) = x✝².zip [] ++ x✝¹.zip x✝" state_after="α : Type u_1&#10;β : Type u_2&#10;x✝² x✝¹ : List α&#10;x✝ : List β&#10;h : x✝².length = [].length&#10;⊢ ([] ++ x✝¹).zip ([] ++ x✝) = [].zip [] ++ x✝¹.zip x✝" tactic="simp only [eq_nil_of_length_eq_zero h]">
                            <AtomNode start="(277, 26)" end="(277, 30)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(277, 31)" end="(277, 35)">
                              <AtomNode start="(277, 31)" end="(277, 35)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(277, 36)" end="(277, 64)">
                              <AtomNode start="(277, 36)" end="(277, 37)" leading="" trailing="" val="["/>
                              <NullNode start="(277, 37)" end="(277, 63)">
                                <OtherNode start="(277, 37)" end="(277, 63)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(277, 37)" end="(277, 63)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(277, 37)" end="(277, 61)" leading="" trailing=" " raw_val="eq_nil_of_length_eq_zero" val="eq_nil_of_length_eq_zero" full_name="List.eq_nil_of_length_eq_zero" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                    <NullNode start="(277, 62)" end="(277, 63)">
                                      <IdentNode start="(277, 62)" end="(277, 63)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(277, 63)" end="(277, 64)" leading="" trailing="" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(277, 64)" end="(277, 65)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(277, 66)" end="(277, 69)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝² x✝¹ : List α&#10;x✝ : List β&#10;h : x✝².length = [].length&#10;⊢ ([] ++ x✝¹).zip ([] ++ x✝) = [].zip [] ++ x✝¹.zip x✝" state_after="no goals" tactic="rfl">
                            <AtomNode start="(277, 66)" end="(277, 69)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(278, 3)" end="(279, 72)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(278, 3)" end="(278, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(278, 5)" end="(278, 28)">
                    <NullNode start="(278, 5)" end="(278, 28)">
                      <OtherNode start="(278, 5)" end="(278, 11)" kind="«term_::_»">
                        <TermHoleNode start="(278, 5)" end="(278, 6)">
                          <AtomNode start="(278, 5)" end="(278, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(278, 7)" end="(278, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(278, 10)" end="(278, 11)">
                          <AtomNode start="(278, 10)" end="(278, 11)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(278, 11)" end="(278, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(278, 13)" end="(278, 14)">
                        <AtomNode start="(278, 13)" end="(278, 14)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(278, 14)" end="(278, 15)" leading="" trailing=" " val=","/>
                      <OtherNode start="(278, 16)" end="(278, 22)" kind="«term_::_»">
                        <TermHoleNode start="(278, 16)" end="(278, 17)">
                          <AtomNode start="(278, 16)" end="(278, 17)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(278, 18)" end="(278, 20)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(278, 21)" end="(278, 22)">
                          <AtomNode start="(278, 21)" end="(278, 22)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(278, 22)" end="(278, 23)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(278, 24)" end="(278, 25)">
                        <AtomNode start="(278, 24)" end="(278, 25)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(278, 25)" end="(278, 26)" leading="" trailing=" " val=","/>
                      <IdentNode start="(278, 27)" end="(278, 28)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(278, 29)" end="(278, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(278, 32)" end="(279, 72)">
                    <AtomNode start="(278, 32)" end="(278, 34)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(279, 5)" end="(279, 72)">
                      <TacticTacticseq1IndentedNode start="(279, 5)" end="(279, 72)">
                        <NullNode start="(279, 5)" end="(279, 72)">
                          <OtherNode start="(279, 5)" end="(279, 72)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;head✝¹ : α&#10;tail✝¹ x✝¹ : List α&#10;head✝ : β&#10;tail✝ x✝ : List β&#10;h : (head✝¹ :: tail✝¹).length = (head✝ :: tail✝).length&#10;⊢ (head✝¹ :: tail✝¹ ++ x✝¹).zip (head✝ :: tail✝ ++ x✝) = (head✝¹ :: tail✝¹).zip (head✝ :: tail✝) ++ x✝¹.zip x✝" state_after="no goals" tactic="simp only [cons_append, zip_cons_cons, zip_append (Nat.succ.inj h)]">
                            <AtomNode start="(279, 5)" end="(279, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(279, 10)" end="(279, 14)">
                              <AtomNode start="(279, 10)" end="(279, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(279, 15)" end="(279, 72)">
                              <AtomNode start="(279, 15)" end="(279, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(279, 16)" end="(279, 71)">
                                <OtherNode start="(279, 16)" end="(279, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(279, 16)" end="(279, 27)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(279, 27)" end="(279, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(279, 29)" end="(279, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(279, 29)" end="(279, 42)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(279, 42)" end="(279, 43)" leading="" trailing=" " val=","/>
                                <OtherNode start="(279, 44)" end="(279, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(279, 44)" end="(279, 71)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(279, 44)" end="(279, 54)" leading="" trailing=" " raw_val="zip_append" val="zip_append"/>
                                    <NullNode start="(279, 55)" end="(279, 71)">
                                      <OtherNode start="(279, 55)" end="(279, 71)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(279, 55)" end="(279, 56)" leading="" trailing="" val="("/>
                                        <OtherNode start="(279, 56)" end="(279, 70)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(279, 56)" end="(279, 68)" leading="" trailing=" " raw_val="Nat.succ.inj" val="Nat.succ.inj" full_name="Nat.succ.inj" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          <NullNode start="(279, 69)" end="(279, 70)">
                                            <IdentNode start="(279, 69)" end="(279, 70)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(279, 70)" end="(279, 71)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(279, 71)" end="(279, 72)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(281, 1)" end="(284, 58)" name="zip_map'" full_name="List.zip_map'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(281, 1)" end="(284, 58)" name="zip_map'" full_name="List.zip_map'" _is_private_decl="False">
        <AtomNode start="(281, 1)" end="(281, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(281, 9)" end="(281, 17)">
          <IdentNode start="(281, 9)" end="(281, 17)" leading="" trailing=" " raw_val="zip_map'" val="zip_map'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(281, 18)" end="(282, 72)">
          <NullNode start="(281, 18)" end="(281, 41)">
            <OtherNode start="(281, 18)" end="(281, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(281, 18)" end="(281, 19)" leading="" trailing="" val="{"/>
              <NullNode start="(281, 19)" end="(281, 20)">
                <IdentNode start="(281, 19)" end="(281, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(281, 21)" end="(281, 28)">
                <AtomNode start="(281, 21)" end="(281, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(281, 23)" end="(281, 28)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(281, 23)" end="(281, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(281, 25)" end="(281, 26)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(281, 27)" end="(281, 28)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(281, 28)" end="(281, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(281, 30)" end="(281, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(281, 30)" end="(281, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(281, 31)" end="(281, 32)">
                <IdentNode start="(281, 31)" end="(281, 32)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(281, 33)" end="(281, 40)">
                <AtomNode start="(281, 33)" end="(281, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(281, 35)" end="(281, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(281, 35)" end="(281, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(281, 37)" end="(281, 38)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(281, 39)" end="(281, 40)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(281, 40)" end="(281, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(281, 42)" end="(282, 72)">
            <AtomNode start="(281, 42)" end="(281, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(282, 5)" end="(282, 72)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(282, 5)" end="(282, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(282, 7)" end="(282, 19)">
                <OtherNode start="(282, 7)" end="(282, 19)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(282, 7)" end="(282, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(282, 8)" end="(282, 9)">
                    <IdentNode start="(282, 8)" end="(282, 9)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(282, 10)" end="(282, 18)">
                    <AtomNode start="(282, 10)" end="(282, 11)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(282, 12)" end="(282, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(282, 12)" end="(282, 16)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(282, 17)" end="(282, 18)">
                        <IdentNode start="(282, 17)" end="(282, 18)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(282, 18)" end="(282, 19)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(282, 19)" end="(282, 20)" leading="" trailing=" " val=","/>
              <OtherNode start="(282, 21)" end="(282, 72)" kind="«term_=_»">
                <OtherNode start="(282, 21)" end="(282, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(282, 21)" end="(282, 24)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(282, 25)" end="(282, 44)">
                    <OtherNode start="(282, 25)" end="(282, 34)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(282, 25)" end="(282, 26)" leading="" trailing="" val="("/>
                      <OtherNode start="(282, 26)" end="(282, 33)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(282, 26)" end="(282, 31)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                        <NullNode start="(282, 32)" end="(282, 33)">
                          <IdentNode start="(282, 32)" end="(282, 33)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(282, 33)" end="(282, 34)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(282, 35)" end="(282, 44)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(282, 35)" end="(282, 36)" leading="" trailing="" val="("/>
                      <OtherNode start="(282, 36)" end="(282, 43)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(282, 36)" end="(282, 41)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                        <NullNode start="(282, 42)" end="(282, 43)">
                          <IdentNode start="(282, 42)" end="(282, 43)" leading="" trailing="" raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(282, 43)" end="(282, 44)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(282, 45)" end="(282, 46)" leading="" trailing=" " val="="/>
                <OtherNode start="(282, 47)" end="(282, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(282, 47)" end="(282, 52)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                  <NullNode start="(282, 53)" end="(282, 72)">
                    <OtherNode start="(282, 53)" end="(282, 72)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(282, 53)" end="(282, 56)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(282, 57)" end="(282, 72)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(282, 57)" end="(282, 58)">
                          <IdentNode start="(282, 57)" end="(282, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(282, 59)" end="(282, 61)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(282, 62)" end="(282, 72)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(282, 62)" end="(282, 63)" leading="" trailing="" val="("/>
                          <NullNode start="(282, 63)" end="(282, 71)">
                            <OtherNode start="(282, 63)" end="(282, 66)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(282, 63)" end="(282, 64)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(282, 65)" end="(282, 66)">
                                <IdentNode start="(282, 65)" end="(282, 66)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(282, 66)" end="(282, 67)" leading="" trailing=" " val=","/>
                            <NullNode start="(282, 68)" end="(282, 71)">
                              <OtherNode start="(282, 68)" end="(282, 71)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(282, 68)" end="(282, 69)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(282, 70)" end="(282, 71)">
                                  <IdentNode start="(282, 70)" end="(282, 71)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(282, 71)" end="(282, 72)" leading="" trailing="&#10;  " val=")"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(283, 3)" end="(284, 58)">
          <OtherNode start="(283, 3)" end="(284, 58)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(283, 3)" end="(284, 58)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(283, 3)" end="(284, 58)">
                <OtherNode start="(283, 3)" end="(283, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(283, 3)" end="(283, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(283, 5)" end="(283, 7)">
                    <NullNode start="(283, 5)" end="(283, 7)">
                      <OtherNode start="(283, 5)" end="(283, 7)" kind="«term[_]»">
                        <AtomNode start="(283, 5)" end="(283, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(283, 6)" end="(283, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(283, 8)" end="(283, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(283, 11)" end="(283, 14)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(284, 3)" end="(284, 58)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(284, 3)" end="(284, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(284, 5)" end="(284, 11)">
                    <NullNode start="(284, 5)" end="(284, 11)">
                      <OtherNode start="(284, 5)" end="(284, 11)" kind="«term_::_»">
                        <IdentNode start="(284, 5)" end="(284, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(284, 7)" end="(284, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(284, 10)" end="(284, 11)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(284, 12)" end="(284, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(284, 15)" end="(284, 58)">
                    <AtomNode start="(284, 15)" end="(284, 17)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(284, 18)" end="(284, 58)">
                      <TacticTacticseq1IndentedNode start="(284, 18)" end="(284, 58)">
                        <NullNode start="(284, 18)" end="(284, 58)">
                          <OtherNode start="(284, 18)" end="(284, 58)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β&#10;g : α → γ&#10;a : α&#10;l : List α&#10;⊢ (map f (a :: l)).zip (map g (a :: l)) = map (fun a =&amp;gt; (f a, g a)) (a :: l)" state_after="no goals" tactic="simp only [map, zip_cons_cons, zip_map']">
                            <AtomNode start="(284, 18)" end="(284, 22)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(284, 23)" end="(284, 27)">
                              <AtomNode start="(284, 23)" end="(284, 27)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(284, 28)" end="(284, 58)">
                              <AtomNode start="(284, 28)" end="(284, 29)" leading="" trailing="" val="["/>
                              <NullNode start="(284, 29)" end="(284, 57)">
                                <OtherNode start="(284, 29)" end="(284, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(284, 29)" end="(284, 32)" leading="" trailing="" raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(284, 32)" end="(284, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(284, 34)" end="(284, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(284, 34)" end="(284, 47)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(284, 47)" end="(284, 48)" leading="" trailing=" " val=","/>
                                <OtherNode start="(284, 49)" end="(284, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(284, 49)" end="(284, 57)" leading="" trailing="" raw_val="zip_map'" val="zip_map'"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(284, 57)" end="(284, 58)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(286, 1)" end="(292, 51)" name="of_mem_zip" full_name="List.of_mem_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(286, 1)" end="(292, 51)" name="of_mem_zip" full_name="List.of_mem_zip" _is_private_decl="False">
        <AtomNode start="(286, 1)" end="(286, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(286, 9)" end="(286, 19)">
          <IdentNode start="(286, 9)" end="(286, 19)" leading="" trailing=" " raw_val="of_mem_zip" val="of_mem_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(286, 20)" end="(286, 95)">
          <NullNode start="(286, 20)" end="(286, 25)">
            <OtherNode start="(286, 20)" end="(286, 25)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(286, 20)" end="(286, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(286, 21)" end="(286, 24)">
                <IdentNode start="(286, 21)" end="(286, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(286, 23)" end="(286, 24)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(286, 24)" end="(286, 25)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(286, 26)" end="(286, 95)">
            <AtomNode start="(286, 26)" end="(286, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(286, 28)" end="(286, 95)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(286, 28)" end="(286, 29)" leading="" trailing=" " val="∀"/>
              <NullNode start="(286, 30)" end="(286, 57)">
                <OtherNode start="(286, 30)" end="(286, 43)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(286, 30)" end="(286, 31)" leading="" trailing="" val="{"/>
                  <NullNode start="(286, 31)" end="(286, 33)">
                    <IdentNode start="(286, 31)" end="(286, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(286, 34)" end="(286, 42)">
                    <AtomNode start="(286, 34)" end="(286, 35)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(286, 36)" end="(286, 42)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(286, 36)" end="(286, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(286, 41)" end="(286, 42)">
                        <IdentNode start="(286, 41)" end="(286, 42)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(286, 42)" end="(286, 43)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(286, 44)" end="(286, 57)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(286, 44)" end="(286, 45)" leading="" trailing="" val="{"/>
                  <NullNode start="(286, 45)" end="(286, 47)">
                    <IdentNode start="(286, 45)" end="(286, 47)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(286, 48)" end="(286, 56)">
                    <AtomNode start="(286, 48)" end="(286, 49)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(286, 50)" end="(286, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(286, 50)" end="(286, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(286, 55)" end="(286, 56)">
                        <IdentNode start="(286, 55)" end="(286, 56)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(286, 56)" end="(286, 57)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(286, 57)" end="(286, 58)" leading="" trailing=" " val=","/>
              <OtherNode start="(286, 59)" end="(286, 95)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(286, 59)" end="(286, 77)" kind="«term_∈_»">
                  <OtherNode start="(286, 59)" end="(286, 65)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(286, 59)" end="(286, 60)" leading="" trailing="" val="("/>
                    <NullNode start="(286, 60)" end="(286, 64)">
                      <IdentNode start="(286, 60)" end="(286, 61)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(286, 61)" end="(286, 62)" leading="" trailing=" " val=","/>
                      <NullNode start="(286, 63)" end="(286, 64)">
                        <IdentNode start="(286, 63)" end="(286, 64)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(286, 64)" end="(286, 65)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(286, 66)" end="(286, 67)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(286, 68)" end="(286, 77)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(286, 68)" end="(286, 71)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(286, 72)" end="(286, 77)">
                      <IdentNode start="(286, 72)" end="(286, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(286, 75)" end="(286, 77)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(286, 78)" end="(286, 79)" leading="" trailing=" " val="→"/>
                <OtherNode start="(286, 80)" end="(286, 95)" kind="«term_∧_»">
                  <OtherNode start="(286, 80)" end="(286, 86)" kind="«term_∈_»">
                    <IdentNode start="(286, 80)" end="(286, 81)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(286, 82)" end="(286, 83)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(286, 84)" end="(286, 86)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </OtherNode>
                  <AtomNode start="(286, 87)" end="(286, 88)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(286, 89)" end="(286, 95)" kind="«term_∈_»">
                    <IdentNode start="(286, 89)" end="(286, 90)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(286, 91)" end="(286, 92)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(286, 93)" end="(286, 95)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(287, 3)" end="(292, 51)">
          <OtherNode start="(287, 3)" end="(292, 51)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(287, 3)" end="(292, 51)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(287, 3)" end="(292, 51)">
                <OtherNode start="(287, 3)" end="(292, 51)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(287, 3)" end="(287, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(287, 5)" end="(287, 24)">
                    <NullNode start="(287, 5)" end="(287, 24)">
                      <OtherNode start="(287, 5)" end="(287, 12)" kind="«term_::_»">
                        <TermHoleNode start="(287, 5)" end="(287, 6)">
                          <AtomNode start="(287, 5)" end="(287, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(287, 7)" end="(287, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(287, 10)" end="(287, 12)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(287, 12)" end="(287, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(287, 14)" end="(287, 21)" kind="«term_::_»">
                        <TermHoleNode start="(287, 14)" end="(287, 15)">
                          <AtomNode start="(287, 14)" end="(287, 15)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(287, 16)" end="(287, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(287, 19)" end="(287, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </OtherNode>
                      <AtomNode start="(287, 21)" end="(287, 22)" leading="" trailing=" " val=","/>
                      <IdentNode start="(287, 23)" end="(287, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(287, 25)" end="(287, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(287, 28)" end="(292, 51)">
                    <AtomNode start="(287, 28)" end="(287, 30)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(288, 5)" end="(292, 51)">
                      <TacticTacticseq1IndentedNode start="(288, 5)" end="(292, 51)">
                        <NullNode start="(288, 5)" end="(292, 51)">
                          <OtherNode start="(288, 5)" end="(288, 12)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;h : (a, b) ∈ (head✝¹ :: l₁).zip (head✝ :: l₂)&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" state_after="case head&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ a ∈ a :: l₁ ∧ b ∈ b :: l₂&#10;&#10;case tail&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;a✝ : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" tactic="cases h">
                            <AtomNode start="(288, 5)" end="(288, 10)" leading="" trailing=" " val="cases"/>
                            <NullNode start="(288, 11)" end="(288, 12)">
                              <OtherNode start="(288, 11)" end="(288, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(288, 11)" end="(288, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(289, 5)" end="(289, 22)" kind="Lean.Parser.Tactic.case" state_before="case head&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ a ∈ a :: l₁ ∧ b ∈ b :: l₂&#10;&#10;case tail&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;a✝ : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" state_after="case tail&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;a✝ : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" tactic="case head =&amp;gt; simp">
                            <AtomNode start="(289, 5)" end="(289, 9)" leading="" trailing=" " val="case"/>
                            <NullNode start="(289, 10)" end="(289, 14)">
                              <OtherNode start="(289, 10)" end="(289, 14)" kind="Lean.Parser.Tactic.caseArg">
                                <LeanBinderidentNode start="(289, 10)" end="(289, 14)">
                                  <IdentNode start="(289, 10)" end="(289, 14)" leading="" trailing=" " raw_val="head" val="head"/>
                                </LeanBinderidentNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(289, 15)" end="(289, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(289, 18)" end="(289, 22)">
                              <TacticTacticseq1IndentedNode start="(289, 18)" end="(289, 22)">
                                <NullNode start="(289, 18)" end="(289, 22)">
                                  <OtherNode start="(289, 18)" end="(289, 22)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ a ∈ a :: l₁ ∧ b ∈ b :: l₂" state_after="no goals" tactic="simp">
                                    <AtomNode start="(289, 18)" end="(289, 22)" leading="" trailing="&#10;    " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(290, 5)" end="(292, 51)" kind="Lean.Parser.Tactic.case" state_before="case tail&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;a✝ : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" state_after="no goals" tactic="case tail h =&amp;gt;&#10;· have := of_mem_zip h&#10;  exact ⟨Mem.tail _ this.1, Mem.tail _ this.2⟩">
                            <AtomNode start="(290, 5)" end="(290, 9)" leading="" trailing=" " val="case"/>
                            <NullNode start="(290, 10)" end="(290, 16)">
                              <OtherNode start="(290, 10)" end="(290, 16)" kind="Lean.Parser.Tactic.caseArg">
                                <LeanBinderidentNode start="(290, 10)" end="(290, 14)">
                                  <IdentNode start="(290, 10)" end="(290, 14)" leading="" trailing=" " raw_val="tail" val="tail"/>
                                </LeanBinderidentNode>
                                <NullNode start="(290, 15)" end="(290, 16)">
                                  <LeanBinderidentNode start="(290, 15)" end="(290, 16)">
                                    <IdentNode start="(290, 15)" end="(290, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                  </LeanBinderidentNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(290, 17)" end="(290, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(291, 5)" end="(292, 51)">
                              <TacticTacticseq1IndentedNode start="(291, 5)" end="(292, 51)">
                                <NullNode start="(291, 5)" end="(292, 51)">
                                  <OtherNode start="(291, 5)" end="(292, 51)" kind="Lean.cdot" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;h : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" state_after="no goals" tactic="· have := of_mem_zip h&#10;  exact ⟨Mem.tail _ this.1, Mem.tail _ this.2⟩">
                                    <OtherNode start="(291, 5)" end="(291, 6)" kind="Lean.cdotTk">
                                      <OtherNode start="(291, 5)" end="(291, 6)" kind="patternIgnore">
                                        <OtherNode start="(291, 5)" end="(291, 6)" kind="token.«· »">
                                          <AtomNode start="(291, 5)" end="(291, 6)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(291, 7)" end="(292, 51)">
                                      <TacticTacticseq1IndentedNode start="(291, 7)" end="(292, 51)">
                                        <NullNode start="(291, 7)" end="(292, 51)">
                                          <OtherNode start="(291, 7)" end="(291, 27)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;h : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" state_after="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;h : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;this : a ∈ l₁ ∧ b ∈ l₂&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" tactic="have := of_mem_zip h">
                                            <AtomNode start="(291, 7)" end="(291, 11)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(291, 12)" end="(291, 27)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(291, 12)" end="(291, 27)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(291, 12)" end="(291, 12)" kind="Lean.Parser.Term.haveId">
                                                  <OtherNode start="(291, 12)" end="(291, 12)" kind="hygieneInfo">
                                                    <IdentNode start="(291, 12)" end="(291, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <AtomNode start="(291, 12)" end="(291, 14)" leading="" trailing=" " val=":="/>
                                                <OtherNode start="(291, 15)" end="(291, 27)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(291, 15)" end="(291, 25)" leading="" trailing=" " raw_val="of_mem_zip" val="of_mem_zip"/>
                                                  <NullNode start="(291, 26)" end="(291, 27)">
                                                    <IdentNode start="(291, 26)" end="(291, 27)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(292, 7)" end="(292, 51)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;head✝¹ : α&#10;l₁ : List α&#10;head✝ : β&#10;l₂ : List β&#10;h : Mem (a, b) (zipWith Prod.mk l₁ l₂)&#10;this : a ∈ l₁ ∧ b ∈ l₂&#10;⊢ a ∈ head✝¹ :: l₁ ∧ b ∈ head✝ :: l₂" state_after="no goals" tactic="exact ⟨Mem.tail _ this.1, Mem.tail _ this.2⟩">
                                            <AtomNode start="(292, 7)" end="(292, 12)" leading="" trailing=" " val="exact"/>
                                            <OtherNode start="(292, 13)" end="(292, 51)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(292, 13)" end="(292, 14)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(292, 14)" end="(292, 50)">
                                                <OtherNode start="(292, 14)" end="(292, 31)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(292, 14)" end="(292, 22)" leading="" trailing=" " raw_val="Mem.tail" val="Mem.tail" full_name="List.Mem.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  <NullNode start="(292, 23)" end="(292, 31)">
                                                    <TermHoleNode start="(292, 23)" end="(292, 24)">
                                                      <AtomNode start="(292, 23)" end="(292, 24)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <OtherNode start="(292, 25)" end="(292, 31)" kind="Lean.Parser.Term.proj">
                                                      <IdentNode start="(292, 25)" end="(292, 29)" leading="" trailing="" raw_val="this" val="this"/>
                                                      <AtomNode start="(292, 29)" end="(292, 30)" leading="" trailing="" val="."/>
                                                      <OtherNode start="(292, 30)" end="(292, 31)" kind="fieldIdx">
                                                        <AtomNode start="(292, 30)" end="(292, 31)" leading="" trailing="" val="1"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(292, 31)" end="(292, 32)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(292, 33)" end="(292, 50)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(292, 33)" end="(292, 41)" leading="" trailing=" " raw_val="Mem.tail" val="Mem.tail" full_name="List.Mem.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  <NullNode start="(292, 42)" end="(292, 50)">
                                                    <TermHoleNode start="(292, 42)" end="(292, 43)">
                                                      <AtomNode start="(292, 42)" end="(292, 43)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <OtherNode start="(292, 44)" end="(292, 50)" kind="Lean.Parser.Term.proj">
                                                      <IdentNode start="(292, 44)" end="(292, 48)" leading="" trailing="" raw_val="this" val="this"/>
                                                      <AtomNode start="(292, 48)" end="(292, 49)" leading="" trailing="" val="."/>
                                                      <OtherNode start="(292, 49)" end="(292, 50)" kind="fieldIdx">
                                                        <AtomNode start="(292, 49)" end="(292, 50)" leading="" trailing="" val="2"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(292, 50)" end="(292, 51)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(294, 1)" end="(301, 34)" name="map_fst_zip" full_name="List.map_fst_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(294, 1)" end="(301, 34)" name="map_fst_zip" full_name="List.map_fst_zip" _is_private_decl="False">
        <AtomNode start="(294, 1)" end="(294, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(294, 9)" end="(294, 20)">
          <IdentNode start="(294, 9)" end="(294, 20)" leading="" trailing=" " raw_val="map_fst_zip" val="map_fst_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(294, 21)" end="(295, 89)">
          <NullNode/>
          <TermTypespecNode start="(294, 21)" end="(295, 89)">
            <AtomNode start="(294, 21)" end="(294, 22)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(295, 5)" end="(295, 89)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(295, 5)" end="(295, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(295, 7)" end="(295, 34)">
                <OtherNode start="(295, 7)" end="(295, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(295, 7)" end="(295, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(295, 8)" end="(295, 10)">
                    <IdentNode start="(295, 8)" end="(295, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(295, 11)" end="(295, 19)">
                    <AtomNode start="(295, 11)" end="(295, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(295, 13)" end="(295, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(295, 13)" end="(295, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(295, 18)" end="(295, 19)">
                        <IdentNode start="(295, 18)" end="(295, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(295, 19)" end="(295, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(295, 21)" end="(295, 34)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(295, 21)" end="(295, 22)" leading="" trailing="" val="{"/>
                  <NullNode start="(295, 22)" end="(295, 24)">
                    <IdentNode start="(295, 22)" end="(295, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(295, 25)" end="(295, 33)">
                    <AtomNode start="(295, 25)" end="(295, 26)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(295, 27)" end="(295, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(295, 27)" end="(295, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(295, 32)" end="(295, 33)">
                        <IdentNode start="(295, 32)" end="(295, 33)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(295, 33)" end="(295, 34)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(295, 34)" end="(295, 35)" leading="" trailing=" " val=","/>
              <OtherNode start="(295, 36)" end="(295, 89)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(295, 36)" end="(295, 57)" kind="«term_≤_»">
                  <IdentNode start="(295, 36)" end="(295, 45)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                  <AtomNode start="(295, 46)" end="(295, 47)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(295, 48)" end="(295, 57)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                </OtherNode>
                <AtomNode start="(295, 58)" end="(295, 59)" leading="" trailing=" " val="→"/>
                <OtherNode start="(295, 60)" end="(295, 89)" kind="«term_=_»">
                  <OtherNode start="(295, 60)" end="(295, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(295, 60)" end="(295, 63)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(295, 64)" end="(295, 84)">
                      <IdentNode start="(295, 64)" end="(295, 72)" leading="" trailing=" " raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <OtherNode start="(295, 73)" end="(295, 84)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(295, 73)" end="(295, 74)" leading="" trailing="" val="("/>
                        <OtherNode start="(295, 74)" end="(295, 83)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(295, 74)" end="(295, 77)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          <NullNode start="(295, 78)" end="(295, 83)">
                            <IdentNode start="(295, 78)" end="(295, 80)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                            <IdentNode start="(295, 81)" end="(295, 83)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(295, 83)" end="(295, 84)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(295, 85)" end="(295, 86)" leading="" trailing=" " val="="/>
                  <IdentNode start="(295, 87)" end="(295, 89)" leading="" trailing="&#10;  " raw_val="l₁" val="l₁"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(296, 3)" end="(301, 34)">
          <OtherNode start="(296, 3)" end="(301, 34)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(296, 3)" end="(301, 34)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(296, 3)" end="(301, 34)">
                <OtherNode start="(296, 3)" end="(296, 20)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(296, 3)" end="(296, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(296, 5)" end="(296, 13)">
                    <NullNode start="(296, 5)" end="(296, 13)">
                      <OtherNode start="(296, 5)" end="(296, 7)" kind="«term[_]»">
                        <AtomNode start="(296, 5)" end="(296, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(296, 6)" end="(296, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(296, 7)" end="(296, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(296, 9)" end="(296, 10)">
                        <AtomNode start="(296, 9)" end="(296, 10)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(296, 10)" end="(296, 11)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(296, 12)" end="(296, 13)">
                        <AtomNode start="(296, 12)" end="(296, 13)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(296, 14)" end="(296, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(296, 17)" end="(296, 20)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(297, 3)" end="(300, 34)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(297, 3)" end="(297, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(297, 5)" end="(297, 24)">
                    <NullNode start="(297, 5)" end="(297, 24)">
                      <OtherNode start="(297, 5)" end="(297, 12)" kind="«term_::_»">
                        <TermHoleNode start="(297, 5)" end="(297, 6)">
                          <AtomNode start="(297, 5)" end="(297, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(297, 7)" end="(297, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(297, 10)" end="(297, 12)" leading="" trailing="" raw_val="as" val="as"/>
                      </OtherNode>
                      <AtomNode start="(297, 12)" end="(297, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(297, 14)" end="(297, 21)" kind="«term_::_»">
                        <TermHoleNode start="(297, 14)" end="(297, 15)">
                          <AtomNode start="(297, 14)" end="(297, 15)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(297, 16)" end="(297, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(297, 19)" end="(297, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </OtherNode>
                      <AtomNode start="(297, 21)" end="(297, 22)" leading="" trailing=" " val=","/>
                      <IdentNode start="(297, 23)" end="(297, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(297, 25)" end="(297, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(297, 28)" end="(300, 34)">
                    <AtomNode start="(297, 28)" end="(297, 30)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(298, 5)" end="(300, 34)">
                      <TacticTacticseq1IndentedNode start="(298, 5)" end="(300, 34)">
                        <NullNode start="(298, 5)" end="(300, 34)">
                          <OtherNode start="(298, 5)" end="(298, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;head✝¹ : α&#10;as : List α&#10;head✝ : β&#10;bs : List β&#10;h : (head✝¹ :: as).length ≤ (head✝ :: bs).length&#10;⊢ map Prod.fst ((head✝¹ :: as).zip (head✝ :: bs)) = head✝¹ :: as" state_after="α : Type u_1&#10;β : Type u_2&#10;head✝¹ : α&#10;as : List α&#10;head✝ : β&#10;bs : List β&#10;h : as.length ≤ bs.length&#10;⊢ map Prod.fst ((head✝¹ :: as).zip (head✝ :: bs)) = head✝¹ :: as" tactic="simp [Nat.succ_le_succ_iff] at h">
                            <AtomNode start="(298, 5)" end="(298, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(298, 10)" end="(298, 32)">
                              <AtomNode start="(298, 10)" end="(298, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(298, 11)" end="(298, 31)">
                                <OtherNode start="(298, 11)" end="(298, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(298, 11)" end="(298, 31)" leading="" trailing="" raw_val="Nat.succ_le_succ_iff" val="Nat.succ_le_succ_iff" full_name="Nat.succ_le_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(298, 31)" end="(298, 32)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(298, 33)" end="(298, 37)">
                              <OtherNode start="(298, 33)" end="(298, 37)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(298, 33)" end="(298, 35)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(298, 36)" end="(298, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(298, 36)" end="(298, 37)">
                                    <IdentNode start="(298, 36)" end="(298, 37)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(299, 5)" end="(299, 49)" kind="Lean.Parser.Tactic.tacticShow_" state_before="α : Type u_1&#10;β : Type u_2&#10;head✝¹ : α&#10;as : List α&#10;head✝ : β&#10;bs : List β&#10;h : as.length ≤ bs.length&#10;⊢ map Prod.fst ((head✝¹ :: as).zip (head✝ :: bs)) = head✝¹ :: as" state_after="α : Type u_1&#10;β : Type u_2&#10;head✝¹ : α&#10;as : List α&#10;head✝ : β&#10;bs : List β&#10;h : as.length ≤ bs.length&#10;⊢ (head✝¹, head✝).fst :: map Prod.fst (as.zip bs) = head✝¹ :: as" tactic="show _ :: map Prod.fst (zip as bs) = _ :: as">
                            <AtomNode start="(299, 5)" end="(299, 9)" leading="" trailing=" " val="show"/>
                            <OtherNode start="(299, 10)" end="(299, 49)" kind="«term_=_»">
                              <OtherNode start="(299, 10)" end="(299, 39)" kind="«term_::_»">
                                <TermHoleNode start="(299, 10)" end="(299, 11)">
                                  <AtomNode start="(299, 10)" end="(299, 11)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(299, 12)" end="(299, 14)" leading="" trailing=" " val="::"/>
                                <OtherNode start="(299, 15)" end="(299, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(299, 15)" end="(299, 18)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  <NullNode start="(299, 19)" end="(299, 39)">
                                    <IdentNode start="(299, 19)" end="(299, 27)" leading="" trailing=" " raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <OtherNode start="(299, 28)" end="(299, 39)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(299, 28)" end="(299, 29)" leading="" trailing="" val="("/>
                                      <OtherNode start="(299, 29)" end="(299, 38)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(299, 29)" end="(299, 32)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        <NullNode start="(299, 33)" end="(299, 38)">
                                          <IdentNode start="(299, 33)" end="(299, 35)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <IdentNode start="(299, 36)" end="(299, 38)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(299, 38)" end="(299, 39)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(299, 40)" end="(299, 41)" leading="" trailing=" " val="="/>
                              <OtherNode start="(299, 42)" end="(299, 49)" kind="«term_::_»">
                                <TermHoleNode start="(299, 42)" end="(299, 43)">
                                  <AtomNode start="(299, 42)" end="(299, 43)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(299, 44)" end="(299, 46)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(299, 47)" end="(299, 49)" leading="" trailing="&#10;    " raw_val="as" val="as"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(300, 5)" end="(300, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;head✝¹ : α&#10;as : List α&#10;head✝ : β&#10;bs : List β&#10;h : as.length ≤ bs.length&#10;⊢ (head✝¹, head✝).fst :: map Prod.fst (as.zip bs) = head✝¹ :: as" state_after="no goals" tactic="rw [map_fst_zip (l₁ := as) h]">
                            <AtomNode start="(300, 5)" end="(300, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(300, 8)" end="(300, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(300, 8)" end="(300, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(300, 9)" end="(300, 33)">
                                <OtherNode start="(300, 9)" end="(300, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(300, 9)" end="(300, 33)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(300, 9)" end="(300, 20)" leading="" trailing=" " raw_val="map_fst_zip" val="map_fst_zip"/>
                                    <NullNode start="(300, 21)" end="(300, 33)">
                                      <OtherNode start="(300, 21)" end="(300, 31)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(300, 21)" end="(300, 22)" leading="" trailing="" val="("/>
                                        <IdentNode start="(300, 22)" end="(300, 24)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                        <AtomNode start="(300, 25)" end="(300, 27)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(300, 28)" end="(300, 30)" leading="" trailing="" raw_val="as" val="as"/>
                                        <AtomNode start="(300, 30)" end="(300, 31)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <IdentNode start="(300, 32)" end="(300, 33)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(300, 33)" end="(300, 34)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(301, 3)" end="(301, 34)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(301, 3)" end="(301, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(301, 5)" end="(301, 18)">
                    <NullNode start="(301, 5)" end="(301, 18)">
                      <OtherNode start="(301, 5)" end="(301, 11)" kind="«term_::_»">
                        <TermHoleNode start="(301, 5)" end="(301, 6)">
                          <AtomNode start="(301, 5)" end="(301, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(301, 7)" end="(301, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(301, 10)" end="(301, 11)">
                          <AtomNode start="(301, 10)" end="(301, 11)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(301, 11)" end="(301, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(301, 13)" end="(301, 15)" kind="«term[_]»">
                        <AtomNode start="(301, 13)" end="(301, 14)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(301, 14)" end="(301, 15)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(301, 15)" end="(301, 16)" leading="" trailing=" " val=","/>
                      <IdentNode start="(301, 17)" end="(301, 18)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(301, 19)" end="(301, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(301, 22)" end="(301, 34)">
                    <AtomNode start="(301, 22)" end="(301, 24)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(301, 25)" end="(301, 34)">
                      <TacticTacticseq1IndentedNode start="(301, 25)" end="(301, 34)">
                        <NullNode start="(301, 25)" end="(301, 34)">
                          <OtherNode start="(301, 25)" end="(301, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;head✝ : α&#10;tail✝ : List α&#10;h : (head✝ :: tail✝).length ≤ [].length&#10;⊢ map Prod.fst ((head✝ :: tail✝).zip []) = head✝ :: tail✝" state_after="no goals" tactic="simp at h">
                            <AtomNode start="(301, 25)" end="(301, 29)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(301, 30)" end="(301, 34)">
                              <OtherNode start="(301, 30)" end="(301, 34)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(301, 30)" end="(301, 32)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(301, 33)" end="(301, 34)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(301, 33)" end="(301, 34)">
                                    <IdentNode start="(301, 33)" end="(301, 34)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(303, 1)" end="(312, 34)" name="map_snd_zip" full_name="List.map_snd_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(303, 1)" end="(312, 34)" name="map_snd_zip" full_name="List.map_snd_zip" _is_private_decl="False">
        <AtomNode start="(303, 1)" end="(303, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(303, 9)" end="(303, 20)">
          <IdentNode start="(303, 9)" end="(303, 20)" leading="" trailing=" " raw_val="map_snd_zip" val="map_snd_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(303, 21)" end="(304, 89)">
          <NullNode/>
          <TermTypespecNode start="(303, 21)" end="(304, 89)">
            <AtomNode start="(303, 21)" end="(303, 22)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(304, 5)" end="(304, 89)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(304, 5)" end="(304, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(304, 7)" end="(304, 34)">
                <OtherNode start="(304, 7)" end="(304, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(304, 7)" end="(304, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(304, 8)" end="(304, 10)">
                    <IdentNode start="(304, 8)" end="(304, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(304, 11)" end="(304, 19)">
                    <AtomNode start="(304, 11)" end="(304, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(304, 13)" end="(304, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(304, 13)" end="(304, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(304, 18)" end="(304, 19)">
                        <IdentNode start="(304, 18)" end="(304, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(304, 19)" end="(304, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(304, 21)" end="(304, 34)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(304, 21)" end="(304, 22)" leading="" trailing="" val="{"/>
                  <NullNode start="(304, 22)" end="(304, 24)">
                    <IdentNode start="(304, 22)" end="(304, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(304, 25)" end="(304, 33)">
                    <AtomNode start="(304, 25)" end="(304, 26)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(304, 27)" end="(304, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(304, 27)" end="(304, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(304, 32)" end="(304, 33)">
                        <IdentNode start="(304, 32)" end="(304, 33)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(304, 33)" end="(304, 34)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(304, 34)" end="(304, 35)" leading="" trailing=" " val=","/>
              <OtherNode start="(304, 36)" end="(304, 89)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(304, 36)" end="(304, 57)" kind="«term_≤_»">
                  <IdentNode start="(304, 36)" end="(304, 45)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                  <AtomNode start="(304, 46)" end="(304, 47)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(304, 48)" end="(304, 57)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                </OtherNode>
                <AtomNode start="(304, 58)" end="(304, 59)" leading="" trailing=" " val="→"/>
                <OtherNode start="(304, 60)" end="(304, 89)" kind="«term_=_»">
                  <OtherNode start="(304, 60)" end="(304, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(304, 60)" end="(304, 63)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(304, 64)" end="(304, 84)">
                      <IdentNode start="(304, 64)" end="(304, 72)" leading="" trailing=" " raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <OtherNode start="(304, 73)" end="(304, 84)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(304, 73)" end="(304, 74)" leading="" trailing="" val="("/>
                        <OtherNode start="(304, 74)" end="(304, 83)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(304, 74)" end="(304, 77)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          <NullNode start="(304, 78)" end="(304, 83)">
                            <IdentNode start="(304, 78)" end="(304, 80)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                            <IdentNode start="(304, 81)" end="(304, 83)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(304, 83)" end="(304, 84)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(304, 85)" end="(304, 86)" leading="" trailing=" " val="="/>
                  <IdentNode start="(304, 87)" end="(304, 89)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(305, 3)" end="(312, 34)">
          <OtherNode start="(305, 3)" end="(312, 34)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(305, 3)" end="(312, 34)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(305, 3)" end="(312, 34)">
                <OtherNode start="(305, 3)" end="(307, 8)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(305, 3)" end="(305, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(305, 5)" end="(305, 13)">
                    <NullNode start="(305, 5)" end="(305, 13)">
                      <TermHoleNode start="(305, 5)" end="(305, 6)">
                        <AtomNode start="(305, 5)" end="(305, 6)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(305, 6)" end="(305, 7)" leading="" trailing=" " val=","/>
                      <OtherNode start="(305, 8)" end="(305, 10)" kind="«term[_]»">
                        <AtomNode start="(305, 8)" end="(305, 9)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(305, 9)" end="(305, 10)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(305, 10)" end="(305, 11)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(305, 12)" end="(305, 13)">
                        <AtomNode start="(305, 12)" end="(305, 13)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(305, 14)" end="(305, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(305, 17)" end="(307, 8)">
                    <AtomNode start="(305, 17)" end="(305, 19)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(306, 5)" end="(307, 8)">
                      <TacticTacticseq1IndentedNode start="(306, 5)" end="(307, 8)">
                        <NullNode start="(306, 5)" end="(307, 8)">
                          <OtherNode start="(306, 5)" end="(306, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝¹ : List α&#10;x✝ : [].length ≤ x✝¹.length&#10;⊢ map Prod.snd (x✝¹.zip []) = []" state_after="α : Type u_1&#10;β : Type u_2&#10;x✝¹ : List α&#10;x✝ : [].length ≤ x✝¹.length&#10;⊢ map Prod.snd [] = []" tactic="rw [zip_nil_right]">
                            <AtomNode start="(306, 5)" end="(306, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(306, 8)" end="(306, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(306, 8)" end="(306, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(306, 9)" end="(306, 22)">
                                <OtherNode start="(306, 9)" end="(306, 22)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(306, 9)" end="(306, 22)" leading="" trailing="" raw_val="zip_nil_right" val="zip_nil_right" full_name="List.zip_nil_right" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(306, 22)" end="(306, 23)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(307, 5)" end="(307, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝¹ : List α&#10;x✝ : [].length ≤ x✝¹.length&#10;⊢ map Prod.snd [] = []" state_after="no goals" tactic="rfl">
                            <AtomNode start="(307, 5)" end="(307, 8)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(308, 3)" end="(308, 35)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(308, 3)" end="(308, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(308, 5)" end="(308, 19)">
                    <NullNode start="(308, 5)" end="(308, 19)">
                      <OtherNode start="(308, 5)" end="(308, 7)" kind="«term[_]»">
                        <AtomNode start="(308, 5)" end="(308, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(308, 6)" end="(308, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(308, 7)" end="(308, 8)" leading="" trailing=" " val=","/>
                      <OtherNode start="(308, 9)" end="(308, 16)" kind="«term_::_»">
                        <IdentNode start="(308, 9)" end="(308, 10)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(308, 11)" end="(308, 13)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(308, 14)" end="(308, 16)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </OtherNode>
                      <AtomNode start="(308, 16)" end="(308, 17)" leading="" trailing=" " val=","/>
                      <IdentNode start="(308, 18)" end="(308, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(308, 20)" end="(308, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(308, 23)" end="(308, 35)">
                    <AtomNode start="(308, 23)" end="(308, 25)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(308, 26)" end="(308, 35)">
                      <TacticTacticseq1IndentedNode start="(308, 26)" end="(308, 35)">
                        <NullNode start="(308, 26)" end="(308, 35)">
                          <OtherNode start="(308, 26)" end="(308, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;b : β&#10;bs : List β&#10;h : (b :: bs).length ≤ [].length&#10;⊢ map Prod.snd ([].zip (b :: bs)) = b :: bs" state_after="no goals" tactic="simp at h">
                            <AtomNode start="(308, 26)" end="(308, 30)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(308, 31)" end="(308, 35)">
                              <OtherNode start="(308, 31)" end="(308, 35)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(308, 31)" end="(308, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(308, 34)" end="(308, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(308, 34)" end="(308, 35)">
                                    <IdentNode start="(308, 34)" end="(308, 35)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(309, 3)" end="(312, 34)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(309, 3)" end="(309, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(309, 5)" end="(309, 24)">
                    <NullNode start="(309, 5)" end="(309, 24)">
                      <OtherNode start="(309, 5)" end="(309, 12)" kind="«term_::_»">
                        <IdentNode start="(309, 5)" end="(309, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(309, 7)" end="(309, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(309, 10)" end="(309, 12)" leading="" trailing="" raw_val="as" val="as"/>
                      </OtherNode>
                      <AtomNode start="(309, 12)" end="(309, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(309, 14)" end="(309, 21)" kind="«term_::_»">
                        <IdentNode start="(309, 14)" end="(309, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(309, 16)" end="(309, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(309, 19)" end="(309, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </OtherNode>
                      <AtomNode start="(309, 21)" end="(309, 22)" leading="" trailing=" " val=","/>
                      <IdentNode start="(309, 23)" end="(309, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(309, 25)" end="(309, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(309, 28)" end="(312, 34)">
                    <AtomNode start="(309, 28)" end="(309, 30)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(310, 5)" end="(312, 34)">
                      <TacticTacticseq1IndentedNode start="(310, 5)" end="(312, 34)">
                        <NullNode start="(310, 5)" end="(312, 34)">
                          <OtherNode start="(310, 5)" end="(310, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;h : (b :: bs).length ≤ (a :: as).length&#10;⊢ map Prod.snd ((a :: as).zip (b :: bs)) = b :: bs" state_after="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;h : bs.length ≤ as.length&#10;⊢ map Prod.snd ((a :: as).zip (b :: bs)) = b :: bs" tactic="simp [Nat.succ_le_succ_iff] at h">
                            <AtomNode start="(310, 5)" end="(310, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(310, 10)" end="(310, 32)">
                              <AtomNode start="(310, 10)" end="(310, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(310, 11)" end="(310, 31)">
                                <OtherNode start="(310, 11)" end="(310, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(310, 11)" end="(310, 31)" leading="" trailing="" raw_val="Nat.succ_le_succ_iff" val="Nat.succ_le_succ_iff" full_name="Nat.succ_le_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(310, 31)" end="(310, 32)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(310, 33)" end="(310, 37)">
                              <OtherNode start="(310, 33)" end="(310, 37)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(310, 33)" end="(310, 35)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(310, 36)" end="(310, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(310, 36)" end="(310, 37)">
                                    <IdentNode start="(310, 36)" end="(310, 37)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(311, 5)" end="(311, 49)" kind="Lean.Parser.Tactic.tacticShow_" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;h : bs.length ≤ as.length&#10;⊢ map Prod.snd ((a :: as).zip (b :: bs)) = b :: bs" state_after="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;h : bs.length ≤ as.length&#10;⊢ (a, b).snd :: map Prod.snd (as.zip bs) = b :: bs" tactic="show _ :: map Prod.snd (zip as bs) = _ :: bs">
                            <AtomNode start="(311, 5)" end="(311, 9)" leading="" trailing=" " val="show"/>
                            <OtherNode start="(311, 10)" end="(311, 49)" kind="«term_=_»">
                              <OtherNode start="(311, 10)" end="(311, 39)" kind="«term_::_»">
                                <TermHoleNode start="(311, 10)" end="(311, 11)">
                                  <AtomNode start="(311, 10)" end="(311, 11)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(311, 12)" end="(311, 14)" leading="" trailing=" " val="::"/>
                                <OtherNode start="(311, 15)" end="(311, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(311, 15)" end="(311, 18)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  <NullNode start="(311, 19)" end="(311, 39)">
                                    <IdentNode start="(311, 19)" end="(311, 27)" leading="" trailing=" " raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <OtherNode start="(311, 28)" end="(311, 39)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(311, 28)" end="(311, 29)" leading="" trailing="" val="("/>
                                      <OtherNode start="(311, 29)" end="(311, 38)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(311, 29)" end="(311, 32)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        <NullNode start="(311, 33)" end="(311, 38)">
                                          <IdentNode start="(311, 33)" end="(311, 35)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <IdentNode start="(311, 36)" end="(311, 38)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(311, 38)" end="(311, 39)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(311, 40)" end="(311, 41)" leading="" trailing=" " val="="/>
                              <OtherNode start="(311, 42)" end="(311, 49)" kind="«term_::_»">
                                <TermHoleNode start="(311, 42)" end="(311, 43)">
                                  <AtomNode start="(311, 42)" end="(311, 43)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(311, 44)" end="(311, 46)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(311, 47)" end="(311, 49)" leading="" trailing="&#10;    " raw_val="bs" val="bs"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(312, 5)" end="(312, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;h : bs.length ≤ as.length&#10;⊢ (a, b).snd :: map Prod.snd (as.zip bs) = b :: bs" state_after="no goals" tactic="rw [map_snd_zip (l₂ := bs) h]">
                            <AtomNode start="(312, 5)" end="(312, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(312, 8)" end="(312, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(312, 8)" end="(312, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(312, 9)" end="(312, 33)">
                                <OtherNode start="(312, 9)" end="(312, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(312, 9)" end="(312, 33)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(312, 9)" end="(312, 20)" leading="" trailing=" " raw_val="map_snd_zip" val="map_snd_zip"/>
                                    <NullNode start="(312, 21)" end="(312, 33)">
                                      <OtherNode start="(312, 21)" end="(312, 31)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(312, 21)" end="(312, 22)" leading="" trailing="" val="("/>
                                        <IdentNode start="(312, 22)" end="(312, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                        <AtomNode start="(312, 25)" end="(312, 27)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(312, 28)" end="(312, 30)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        <AtomNode start="(312, 30)" end="(312, 31)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <IdentNode start="(312, 32)" end="(312, 33)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(312, 33)" end="(312, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(314, 1)" end="(318, 7)" name="map_prod_left_eq_zip" full_name="List.map_prod_left_eq_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(314, 1)" end="(318, 7)" name="map_prod_left_eq_zip" full_name="List.map_prod_left_eq_zip" _is_private_decl="False">
        <AtomNode start="(314, 1)" end="(314, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(314, 9)" end="(314, 29)">
          <IdentNode start="(314, 9)" end="(314, 29)" leading="" trailing=" " raw_val="map_prod_left_eq_zip" val="map_prod_left_eq_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(314, 30)" end="(315, 48)">
          <NullNode start="(314, 30)" end="(314, 54)">
            <OtherNode start="(314, 30)" end="(314, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(314, 30)" end="(314, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(314, 31)" end="(314, 32)">
                <IdentNode start="(314, 31)" end="(314, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(314, 33)" end="(314, 41)">
                <AtomNode start="(314, 33)" end="(314, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(314, 35)" end="(314, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(314, 35)" end="(314, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(314, 40)" end="(314, 41)">
                    <IdentNode start="(314, 40)" end="(314, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(314, 41)" end="(314, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(314, 43)" end="(314, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(314, 43)" end="(314, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(314, 44)" end="(314, 45)">
                <IdentNode start="(314, 44)" end="(314, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(314, 46)" end="(314, 53)">
                <AtomNode start="(314, 46)" end="(314, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(314, 48)" end="(314, 53)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(314, 48)" end="(314, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(314, 50)" end="(314, 51)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(314, 52)" end="(314, 53)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(314, 53)" end="(314, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(314, 55)" end="(315, 48)">
            <AtomNode start="(314, 55)" end="(314, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(315, 5)" end="(315, 48)" kind="«term_=_»">
              <OtherNode start="(315, 5)" end="(315, 30)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(315, 5)" end="(315, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(315, 6)" end="(315, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(315, 6)" end="(315, 11)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                  <NullNode start="(315, 12)" end="(315, 29)">
                    <OtherNode start="(315, 12)" end="(315, 29)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(315, 12)" end="(315, 15)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(315, 16)" end="(315, 29)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(315, 16)" end="(315, 17)">
                          <IdentNode start="(315, 16)" end="(315, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(315, 18)" end="(315, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(315, 21)" end="(315, 29)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(315, 21)" end="(315, 22)" leading="" trailing="" val="("/>
                          <NullNode start="(315, 22)" end="(315, 28)">
                            <IdentNode start="(315, 22)" end="(315, 23)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(315, 23)" end="(315, 24)" leading="" trailing=" " val=","/>
                            <NullNode start="(315, 25)" end="(315, 28)">
                              <OtherNode start="(315, 25)" end="(315, 28)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(315, 25)" end="(315, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(315, 27)" end="(315, 28)">
                                  <IdentNode start="(315, 27)" end="(315, 28)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(315, 28)" end="(315, 29)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(315, 29)" end="(315, 30)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(315, 31)" end="(315, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(315, 33)" end="(315, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(315, 33)" end="(315, 38)" leading="" trailing=" " raw_val="l.zip" val="l.zip"/>
                <NullNode start="(315, 39)" end="(315, 48)">
                  <OtherNode start="(315, 39)" end="(315, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(315, 39)" end="(315, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(315, 40)" end="(315, 47)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(315, 40)" end="(315, 45)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(315, 46)" end="(315, 47)">
                        <IdentNode start="(315, 46)" end="(315, 47)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(315, 47)" end="(315, 48)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(315, 49)" end="(318, 7)">
          <AtomNode start="(315, 49)" end="(315, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(315, 52)" end="(318, 7)">
            <AtomNode start="(315, 52)" end="(315, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(316, 3)" end="(318, 7)">
              <TacticTacticseq1IndentedNode start="(316, 3)" end="(318, 7)">
                <NullNode start="(316, 3)" end="(318, 7)">
                  <OtherNode start="(316, 3)" end="(316, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; (x, f x)) l = l.zip (map f l)" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ (map (fun x =&amp;gt; x) l).zip (map f l) = l.zip (map f l)" tactic="rw [← zip_map']">
                    <AtomNode start="(316, 3)" end="(316, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(316, 6)" end="(316, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(316, 6)" end="(316, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(316, 7)" end="(316, 17)">
                        <OtherNode start="(316, 7)" end="(316, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(316, 7)" end="(316, 8)">
                            <OtherNode start="(316, 7)" end="(316, 8)" kind="patternIgnore">
                              <OtherNode start="(316, 7)" end="(316, 8)" kind="token.«← »">
                                <AtomNode start="(316, 7)" end="(316, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(316, 9)" end="(316, 17)" leading="" trailing="" raw_val="zip_map'" val="zip_map'" full_name="List.zip_map'" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(281, 9)" def_end="(281, 17)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(316, 17)" end="(316, 18)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(317, 3)" end="(317, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ (map (fun x =&amp;gt; x) l).zip (map f l) = l.zip (map f l)" state_after="case e_a&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; x) l = l" tactic="congr">
                    <AtomNode start="(317, 3)" end="(317, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(318, 3)" end="(318, 7)" kind="Lean.Parser.Tactic.simp" state_before="case e_a&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; x) l = l" state_after="no goals" tactic="simp">
                    <AtomNode start="(318, 3)" end="(318, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(320, 1)" end="(324, 7)" name="map_prod_right_eq_zip" full_name="List.map_prod_right_eq_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(320, 1)" end="(324, 7)" name="map_prod_right_eq_zip" full_name="List.map_prod_right_eq_zip" _is_private_decl="False">
        <AtomNode start="(320, 1)" end="(320, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(320, 9)" end="(320, 30)">
          <IdentNode start="(320, 9)" end="(320, 30)" leading="" trailing=" " raw_val="map_prod_right_eq_zip" val="map_prod_right_eq_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(320, 31)" end="(321, 48)">
          <NullNode start="(320, 31)" end="(320, 55)">
            <OtherNode start="(320, 31)" end="(320, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(320, 31)" end="(320, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(320, 32)" end="(320, 33)">
                <IdentNode start="(320, 32)" end="(320, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(320, 34)" end="(320, 42)">
                <AtomNode start="(320, 34)" end="(320, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(320, 36)" end="(320, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(320, 36)" end="(320, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(320, 41)" end="(320, 42)">
                    <IdentNode start="(320, 41)" end="(320, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(320, 42)" end="(320, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(320, 44)" end="(320, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(320, 44)" end="(320, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(320, 45)" end="(320, 46)">
                <IdentNode start="(320, 45)" end="(320, 46)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(320, 47)" end="(320, 54)">
                <AtomNode start="(320, 47)" end="(320, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(320, 49)" end="(320, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(320, 49)" end="(320, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(320, 51)" end="(320, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(320, 53)" end="(320, 54)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(320, 54)" end="(320, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(320, 56)" end="(321, 48)">
            <AtomNode start="(320, 56)" end="(320, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(321, 5)" end="(321, 48)" kind="«term_=_»">
              <OtherNode start="(321, 5)" end="(321, 30)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(321, 5)" end="(321, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(321, 6)" end="(321, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(321, 6)" end="(321, 11)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                  <NullNode start="(321, 12)" end="(321, 29)">
                    <OtherNode start="(321, 12)" end="(321, 29)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(321, 12)" end="(321, 15)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(321, 16)" end="(321, 29)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(321, 16)" end="(321, 17)">
                          <IdentNode start="(321, 16)" end="(321, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(321, 18)" end="(321, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(321, 21)" end="(321, 29)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(321, 21)" end="(321, 22)" leading="" trailing="" val="("/>
                          <NullNode start="(321, 22)" end="(321, 28)">
                            <OtherNode start="(321, 22)" end="(321, 25)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(321, 22)" end="(321, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(321, 24)" end="(321, 25)">
                                <IdentNode start="(321, 24)" end="(321, 25)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(321, 25)" end="(321, 26)" leading="" trailing=" " val=","/>
                            <NullNode start="(321, 27)" end="(321, 28)">
                              <IdentNode start="(321, 27)" end="(321, 28)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(321, 28)" end="(321, 29)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(321, 29)" end="(321, 30)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(321, 31)" end="(321, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(321, 33)" end="(321, 48)" kind="Lean.Parser.Term.app">
                <OtherNode start="(321, 33)" end="(321, 46)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(321, 33)" end="(321, 42)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(321, 33)" end="(321, 34)" leading="" trailing="" val="("/>
                    <OtherNode start="(321, 34)" end="(321, 41)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(321, 34)" end="(321, 39)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(321, 40)" end="(321, 41)">
                        <IdentNode start="(321, 40)" end="(321, 41)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(321, 41)" end="(321, 42)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(321, 42)" end="(321, 43)" leading="" trailing="" val="."/>
                  <IdentNode start="(321, 43)" end="(321, 46)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(321, 47)" end="(321, 48)">
                  <IdentNode start="(321, 47)" end="(321, 48)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(321, 49)" end="(324, 7)">
          <AtomNode start="(321, 49)" end="(321, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(321, 52)" end="(324, 7)">
            <AtomNode start="(321, 52)" end="(321, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(322, 3)" end="(324, 7)">
              <TacticTacticseq1IndentedNode start="(322, 3)" end="(324, 7)">
                <NullNode start="(322, 3)" end="(324, 7)">
                  <OtherNode start="(322, 3)" end="(322, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; (f x, x)) l = (map f l).zip l" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ (map f l).zip (map (fun x =&amp;gt; x) l) = (map f l).zip l" tactic="rw [← zip_map']">
                    <AtomNode start="(322, 3)" end="(322, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(322, 6)" end="(322, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(322, 6)" end="(322, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(322, 7)" end="(322, 17)">
                        <OtherNode start="(322, 7)" end="(322, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(322, 7)" end="(322, 8)">
                            <OtherNode start="(322, 7)" end="(322, 8)" kind="patternIgnore">
                              <OtherNode start="(322, 7)" end="(322, 8)" kind="token.«← »">
                                <AtomNode start="(322, 7)" end="(322, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(322, 9)" end="(322, 17)" leading="" trailing="" raw_val="zip_map'" val="zip_map'" full_name="List.zip_map'" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(281, 9)" def_end="(281, 17)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(322, 17)" end="(322, 18)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(323, 3)" end="(323, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ (map f l).zip (map (fun x =&amp;gt; x) l) = (map f l).zip l" state_after="case e_a&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; x) l = l" tactic="congr">
                    <AtomNode start="(323, 3)" end="(323, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(324, 3)" end="(324, 7)" kind="Lean.Parser.Tactic.simp" state_before="case e_a&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; x) l = l" state_after="no goals" tactic="simp">
                    <AtomNode start="(324, 3)" end="(324, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(326, 1)" end="(328, 24)" name="zip_eq_nil_iff" full_name="List.zip_eq_nil_iff">
      <CommandDeclmodifiersNode start="(326, 1)" end="(326, 8)">
        <NullNode/>
        <NullNode start="(326, 1)" end="(326, 8)">
          <OtherNode start="(326, 1)" end="(326, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(326, 1)" end="(326, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(326, 3)" end="(326, 7)">
              <OtherNode start="(326, 3)" end="(326, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(326, 3)" end="(326, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(326, 3)" end="(326, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(326, 7)" end="(326, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(326, 9)" end="(328, 24)" name="zip_eq_nil_iff" full_name="List.zip_eq_nil_iff" _is_private_decl="False">
        <AtomNode start="(326, 9)" end="(326, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(326, 17)" end="(326, 31)">
          <IdentNode start="(326, 17)" end="(326, 31)" leading="" trailing=" " raw_val="zip_eq_nil_iff" val="zip_eq_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(326, 32)" end="(327, 39)">
          <NullNode start="(326, 32)" end="(326, 59)">
            <OtherNode start="(326, 32)" end="(326, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(326, 32)" end="(326, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(326, 33)" end="(326, 35)">
                <IdentNode start="(326, 33)" end="(326, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(326, 36)" end="(326, 44)">
                <AtomNode start="(326, 36)" end="(326, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(326, 38)" end="(326, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(326, 38)" end="(326, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(326, 43)" end="(326, 44)">
                    <IdentNode start="(326, 43)" end="(326, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(326, 44)" end="(326, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(326, 46)" end="(326, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(326, 46)" end="(326, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(326, 47)" end="(326, 49)">
                <IdentNode start="(326, 47)" end="(326, 49)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(326, 50)" end="(326, 58)">
                <AtomNode start="(326, 50)" end="(326, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(326, 52)" end="(326, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(326, 52)" end="(326, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(326, 57)" end="(326, 58)">
                    <IdentNode start="(326, 57)" end="(326, 58)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(326, 58)" end="(326, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(326, 60)" end="(327, 39)">
            <AtomNode start="(326, 60)" end="(326, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(327, 5)" end="(327, 39)" kind="«term_↔_»">
              <OtherNode start="(327, 5)" end="(327, 19)" kind="«term_=_»">
                <OtherNode start="(327, 5)" end="(327, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(327, 5)" end="(327, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(327, 9)" end="(327, 14)">
                    <IdentNode start="(327, 9)" end="(327, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(327, 12)" end="(327, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(327, 15)" end="(327, 16)" leading="" trailing=" " val="="/>
                <OtherNode start="(327, 17)" end="(327, 19)" kind="«term[_]»">
                  <AtomNode start="(327, 17)" end="(327, 18)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(327, 18)" end="(327, 19)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(327, 20)" end="(327, 21)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(327, 22)" end="(327, 39)" kind="«term_∨_»">
                <OtherNode start="(327, 22)" end="(327, 29)" kind="«term_=_»">
                  <IdentNode start="(327, 22)" end="(327, 24)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(327, 25)" end="(327, 26)" leading="" trailing=" " val="="/>
                  <OtherNode start="(327, 27)" end="(327, 29)" kind="«term[_]»">
                    <AtomNode start="(327, 27)" end="(327, 28)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(327, 28)" end="(327, 29)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(327, 30)" end="(327, 31)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(327, 32)" end="(327, 39)" kind="«term_=_»">
                  <IdentNode start="(327, 32)" end="(327, 34)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <AtomNode start="(327, 35)" end="(327, 36)" leading="" trailing=" " val="="/>
                  <OtherNode start="(327, 37)" end="(327, 39)" kind="«term[_]»">
                    <AtomNode start="(327, 37)" end="(327, 38)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(327, 38)" end="(327, 39)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(327, 40)" end="(328, 24)">
          <AtomNode start="(327, 40)" end="(327, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(327, 43)" end="(328, 24)">
            <AtomNode start="(327, 43)" end="(327, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(328, 3)" end="(328, 24)">
              <TacticTacticseq1IndentedNode start="(328, 3)" end="(328, 24)">
                <NullNode start="(328, 3)" end="(328, 24)">
                  <OtherNode start="(328, 3)" end="(328, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ l₁.zip l₂ = [] ↔ l₁ = [] ∨ l₂ = []" state_after="no goals" tactic="simp [zip_eq_zipWith]">
                    <AtomNode start="(328, 3)" end="(328, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(328, 8)" end="(328, 24)">
                      <AtomNode start="(328, 8)" end="(328, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(328, 9)" end="(328, 23)">
                        <OtherNode start="(328, 9)" end="(328, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(328, 9)" end="(328, 23)" leading="" trailing="" raw_val="zip_eq_zipWith" val="zip_eq_zipWith" full_name="List.zip_eq_zipWith" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(252, 9)" def_end="(252, 23)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(328, 23)" end="(328, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(330, 1)" end="(340, 37)" name="zip_eq_cons_iff" full_name="List.zip_eq_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(330, 1)" end="(340, 37)" name="zip_eq_cons_iff" full_name="List.zip_eq_cons_iff" _is_private_decl="False">
        <AtomNode start="(330, 1)" end="(330, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(330, 9)" end="(330, 24)">
          <IdentNode start="(330, 9)" end="(330, 24)" leading="" trailing=" " raw_val="zip_eq_cons_iff" val="zip_eq_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(330, 25)" end="(332, 65)">
          <NullNode start="(330, 25)" end="(330, 52)">
            <OtherNode start="(330, 25)" end="(330, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(330, 25)" end="(330, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(330, 26)" end="(330, 28)">
                <IdentNode start="(330, 26)" end="(330, 28)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(330, 29)" end="(330, 37)">
                <AtomNode start="(330, 29)" end="(330, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(330, 31)" end="(330, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(330, 31)" end="(330, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(330, 36)" end="(330, 37)">
                    <IdentNode start="(330, 36)" end="(330, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(330, 37)" end="(330, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(330, 39)" end="(330, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(330, 39)" end="(330, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(330, 40)" end="(330, 42)">
                <IdentNode start="(330, 40)" end="(330, 42)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(330, 43)" end="(330, 51)">
                <AtomNode start="(330, 43)" end="(330, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(330, 45)" end="(330, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(330, 45)" end="(330, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(330, 50)" end="(330, 51)">
                    <IdentNode start="(330, 50)" end="(330, 51)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(330, 51)" end="(330, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(330, 53)" end="(332, 65)">
            <AtomNode start="(330, 53)" end="(330, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(331, 5)" end="(332, 65)" kind="«term_↔_»">
              <OtherNode start="(331, 5)" end="(331, 28)" kind="«term_=_»">
                <OtherNode start="(331, 5)" end="(331, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(331, 5)" end="(331, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(331, 9)" end="(331, 14)">
                    <IdentNode start="(331, 9)" end="(331, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(331, 12)" end="(331, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(331, 15)" end="(331, 16)" leading="" trailing=" " val="="/>
                <OtherNode start="(331, 17)" end="(331, 28)" kind="«term_::_»">
                  <OtherNode start="(331, 17)" end="(331, 23)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(331, 17)" end="(331, 18)" leading="" trailing="" val="("/>
                    <NullNode start="(331, 18)" end="(331, 22)">
                      <IdentNode start="(331, 18)" end="(331, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(331, 19)" end="(331, 20)" leading="" trailing=" " val=","/>
                      <NullNode start="(331, 21)" end="(331, 22)">
                        <IdentNode start="(331, 21)" end="(331, 22)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(331, 22)" end="(331, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(331, 24)" end="(331, 26)" leading="" trailing=" " val="::"/>
                  <IdentNode start="(331, 27)" end="(331, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(331, 29)" end="(331, 30)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(332, 7)" end="(332, 65)" kind="«term∃_,_»">
                <AtomNode start="(332, 7)" end="(332, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(332, 9)" end="(332, 16)" kind="Lean.explicitBinders">
                  <OtherNode start="(332, 9)" end="(332, 16)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(332, 9)" end="(332, 16)">
                      <LeanBinderidentNode start="(332, 9)" end="(332, 12)">
                        <IdentNode start="(332, 9)" end="(332, 12)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(332, 13)" end="(332, 16)">
                        <IdentNode start="(332, 13)" end="(332, 16)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(332, 16)" end="(332, 17)" leading="" trailing=" " val=","/>
                <OtherNode start="(332, 18)" end="(332, 65)" kind="«term_∧_»">
                  <OtherNode start="(332, 18)" end="(332, 31)" kind="«term_=_»">
                    <IdentNode start="(332, 18)" end="(332, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(332, 21)" end="(332, 22)" leading="" trailing=" " val="="/>
                    <OtherNode start="(332, 23)" end="(332, 31)" kind="«term_::_»">
                      <IdentNode start="(332, 23)" end="(332, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(332, 25)" end="(332, 27)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(332, 28)" end="(332, 31)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(332, 32)" end="(332, 33)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(332, 34)" end="(332, 65)" kind="«term_∧_»">
                    <OtherNode start="(332, 34)" end="(332, 47)" kind="«term_=_»">
                      <IdentNode start="(332, 34)" end="(332, 36)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      <AtomNode start="(332, 37)" end="(332, 38)" leading="" trailing=" " val="="/>
                      <OtherNode start="(332, 39)" end="(332, 47)" kind="«term_::_»">
                        <IdentNode start="(332, 39)" end="(332, 40)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(332, 41)" end="(332, 43)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(332, 44)" end="(332, 47)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(332, 48)" end="(332, 49)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(332, 50)" end="(332, 65)" kind="«term_=_»">
                      <IdentNode start="(332, 50)" end="(332, 51)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(332, 52)" end="(332, 53)" leading="" trailing=" " val="="/>
                      <OtherNode start="(332, 54)" end="(332, 65)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(332, 54)" end="(332, 57)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(332, 58)" end="(332, 65)">
                          <IdentNode start="(332, 58)" end="(332, 61)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                          <IdentNode start="(332, 62)" end="(332, 65)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(332, 66)" end="(340, 37)">
          <AtomNode start="(332, 66)" end="(332, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(332, 69)" end="(340, 37)">
            <AtomNode start="(332, 69)" end="(332, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(333, 3)" end="(340, 37)">
              <TacticTacticseq1IndentedNode start="(333, 3)" end="(340, 37)">
                <NullNode start="(333, 3)" end="(340, 37)">
                  <OtherNode start="(333, 3)" end="(333, 50)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ l₁.zip l₂ = (a, b) :: l ↔ ∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = l₁'.zip l₂'" state_after="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ a_1 l₁' b_1 l₂', l₁ = a_1 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_1, b_1) ∧ l = zipWith Prod.mk l₁' l₂') ↔&#10;    ∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂'" tactic="simp only [zip_eq_zipWith, zipWith_eq_cons_iff]">
                    <AtomNode start="(333, 3)" end="(333, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(333, 8)" end="(333, 12)">
                      <AtomNode start="(333, 8)" end="(333, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(333, 13)" end="(333, 50)">
                      <AtomNode start="(333, 13)" end="(333, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(333, 14)" end="(333, 49)">
                        <OtherNode start="(333, 14)" end="(333, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(333, 14)" end="(333, 28)" leading="" trailing="" raw_val="zip_eq_zipWith" val="zip_eq_zipWith" full_name="List.zip_eq_zipWith" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(252, 9)" def_end="(252, 23)"/>
                        </OtherNode>
                        <AtomNode start="(333, 28)" end="(333, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(333, 30)" end="(333, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(333, 30)" end="(333, 49)" leading="" trailing="" raw_val="zipWith_eq_cons_iff" val="zipWith_eq_cons_iff" full_name="List.zipWith_eq_cons_iff" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(168, 9)" def_end="(168, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(333, 49)" end="(333, 50)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(334, 3)" end="(334, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ a_1 l₁' b_1 l₂', l₁ = a_1 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_1, b_1) ∧ l = zipWith Prod.mk l₁' l₂') ↔&#10;    ∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂'" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ a_1 l₁' b_1 l₂', l₁ = a_1 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_1, b_1) ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂'&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ a_2 l₁' b_1 l₂', l₁ = a_2 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_2, b_1) ∧ l = zipWith Prod.mk l₁' l₂'" tactic="constructor">
                    <AtomNode start="(334, 3)" end="(334, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(335, 3)" end="(338, 9)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ a_1 l₁' b_1 l₂', l₁ = a_1 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_1, b_1) ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂'&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ a_2 l₁' b_1 l₂', l₁ = a_2 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_2, b_1) ∧ l = zipWith Prod.mk l₁' l₂'" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ a_2 l₁' b_1 l₂', l₁ = a_2 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_2, b_1) ∧ l = zipWith Prod.mk l₁' l₂'" tactic="· rintro ⟨a, l₁, b, l₂, rfl, rfl, h, rfl, rfl⟩&#10;  simp only [Prod.mk.injEq] at h&#10;  obtain ⟨rfl, rfl⟩ := h&#10;  simp">
                    <OtherNode start="(335, 3)" end="(335, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(335, 3)" end="(335, 4)" kind="patternIgnore">
                        <OtherNode start="(335, 3)" end="(335, 4)" kind="token.«· »">
                          <AtomNode start="(335, 3)" end="(335, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(335, 5)" end="(338, 9)">
                      <TacticTacticseq1IndentedNode start="(335, 5)" end="(338, 9)">
                        <NullNode start="(335, 5)" end="(338, 9)">
                          <OtherNode start="(335, 5)" end="(335, 49)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ a_1 l₁' b_1 l₂', l₁ = a_1 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_1, b_1) ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂'" state_after="case mp.intro.intro.intro.intro.intro.intro.intro.refl&#10;α : Type u_1&#10;β : Type u_2&#10;a✝ : α&#10;b✝ : β&#10;a : α&#10;l₁ : List α&#10;b : β&#10;l₂ : List β&#10;h : (a✝, b✝) = (a, b)&#10;⊢ ∃ l₁' l₂', a :: l₁ = a✝ :: l₁' ∧ b :: l₂ = b✝ :: l₂' ∧ zipWith Prod.mk l₁ l₂ = zipWith Prod.mk l₁' l₂'" tactic="rintro ⟨a, l₁, b, l₂, rfl, rfl, h, rfl, rfl⟩">
                            <AtomNode start="(335, 5)" end="(335, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(335, 12)" end="(335, 49)">
                              <OtherNode start="(335, 12)" end="(335, 49)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(335, 12)" end="(335, 49)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(335, 12)" end="(335, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(335, 13)" end="(335, 48)">
                                    <OtherNode start="(335, 13)" end="(335, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 13)" end="(335, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 13)" end="(335, 14)">
                                          <OtherNode start="(335, 13)" end="(335, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 13)" end="(335, 14)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 14)" end="(335, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 16)" end="(335, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 16)" end="(335, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 16)" end="(335, 18)">
                                          <OtherNode start="(335, 16)" end="(335, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 16)" end="(335, 18)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 18)" end="(335, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 20)" end="(335, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 20)" end="(335, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 20)" end="(335, 21)">
                                          <OtherNode start="(335, 20)" end="(335, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 20)" end="(335, 21)" leading="" trailing="" raw_val="b" val="b"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 21)" end="(335, 22)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 23)" end="(335, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 23)" end="(335, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 23)" end="(335, 25)">
                                          <OtherNode start="(335, 23)" end="(335, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 23)" end="(335, 25)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 25)" end="(335, 26)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 27)" end="(335, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 27)" end="(335, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 27)" end="(335, 30)">
                                          <OtherNode start="(335, 27)" end="(335, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 27)" end="(335, 30)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 30)" end="(335, 31)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 32)" end="(335, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 32)" end="(335, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 32)" end="(335, 35)">
                                          <OtherNode start="(335, 32)" end="(335, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 32)" end="(335, 35)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 35)" end="(335, 36)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 37)" end="(335, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 37)" end="(335, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 37)" end="(335, 38)">
                                          <OtherNode start="(335, 37)" end="(335, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 37)" end="(335, 38)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 38)" end="(335, 39)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 40)" end="(335, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 40)" end="(335, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 40)" end="(335, 43)">
                                          <OtherNode start="(335, 40)" end="(335, 43)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 40)" end="(335, 43)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(335, 43)" end="(335, 44)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(335, 45)" end="(335, 48)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(335, 45)" end="(335, 48)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(335, 45)" end="(335, 48)">
                                          <OtherNode start="(335, 45)" end="(335, 48)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(335, 45)" end="(335, 48)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(335, 48)" end="(335, 49)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(336, 5)" end="(336, 35)" kind="Lean.Parser.Tactic.simp" state_before="case mp.intro.intro.intro.intro.intro.intro.intro.refl&#10;α : Type u_1&#10;β : Type u_2&#10;a✝ : α&#10;b✝ : β&#10;a : α&#10;l₁ : List α&#10;b : β&#10;l₂ : List β&#10;h : (a✝, b✝) = (a, b)&#10;⊢ ∃ l₁' l₂', a :: l₁ = a✝ :: l₁' ∧ b :: l₂ = b✝ :: l₂' ∧ zipWith Prod.mk l₁ l₂ = zipWith Prod.mk l₁' l₂'" state_after="case mp.intro.intro.intro.intro.intro.intro.intro.refl&#10;α : Type u_1&#10;β : Type u_2&#10;a✝ : α&#10;b✝ : β&#10;a : α&#10;l₁ : List α&#10;b : β&#10;l₂ : List β&#10;h : a✝ = a ∧ b✝ = b&#10;⊢ ∃ l₁' l₂', a :: l₁ = a✝ :: l₁' ∧ b :: l₂ = b✝ :: l₂' ∧ zipWith Prod.mk l₁ l₂ = zipWith Prod.mk l₁' l₂'" tactic="simp only [Prod.mk.injEq] at h">
                            <AtomNode start="(336, 5)" end="(336, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(336, 10)" end="(336, 14)">
                              <AtomNode start="(336, 10)" end="(336, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(336, 15)" end="(336, 30)">
                              <AtomNode start="(336, 15)" end="(336, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(336, 16)" end="(336, 29)">
                                <OtherNode start="(336, 16)" end="(336, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(336, 16)" end="(336, 29)" leading="" trailing="" raw_val="Prod.mk.injEq" val="Prod.mk.injEq" full_name="Prod.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(336, 29)" end="(336, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(336, 31)" end="(336, 35)">
                              <OtherNode start="(336, 31)" end="(336, 35)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(336, 31)" end="(336, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(336, 34)" end="(336, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(336, 34)" end="(336, 35)">
                                    <IdentNode start="(336, 34)" end="(336, 35)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(337, 5)" end="(337, 27)" kind="Lean.Parser.Tactic.obtain" state_before="case mp.intro.intro.intro.intro.intro.intro.intro.refl&#10;α : Type u_1&#10;β : Type u_2&#10;a✝ : α&#10;b✝ : β&#10;a : α&#10;l₁ : List α&#10;b : β&#10;l₂ : List β&#10;h : a✝ = a ∧ b✝ = b&#10;⊢ ∃ l₁' l₂', a :: l₁ = a✝ :: l₁' ∧ b :: l₂ = b✝ :: l₂' ∧ zipWith Prod.mk l₁ l₂ = zipWith Prod.mk l₁' l₂'" state_after="case mp.intro.intro.intro.intro.intro.intro.intro.refl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ ∃ l₁' l₂', a :: l₁ = a :: l₁' ∧ b :: l₂ = b :: l₂' ∧ zipWith Prod.mk l₁ l₂ = zipWith Prod.mk l₁' l₂'" tactic="obtain ⟨rfl, rfl⟩ := h">
                            <AtomNode start="(337, 5)" end="(337, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(337, 12)" end="(337, 22)">
                              <OtherNode start="(337, 12)" end="(337, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(337, 12)" end="(337, 22)">
                                  <OtherNode start="(337, 12)" end="(337, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(337, 12)" end="(337, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(337, 13)" end="(337, 21)">
                                      <OtherNode start="(337, 13)" end="(337, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(337, 13)" end="(337, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(337, 13)" end="(337, 16)">
                                            <OtherNode start="(337, 13)" end="(337, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(337, 13)" end="(337, 16)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(337, 16)" end="(337, 17)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(337, 18)" end="(337, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(337, 18)" end="(337, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(337, 18)" end="(337, 21)">
                                            <OtherNode start="(337, 18)" end="(337, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(337, 18)" end="(337, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(337, 21)" end="(337, 22)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(337, 23)" end="(337, 27)">
                              <AtomNode start="(337, 23)" end="(337, 25)" leading="" trailing=" " val=":="/>
                              <NullNode start="(337, 26)" end="(337, 27)">
                                <IdentNode start="(337, 26)" end="(337, 27)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(338, 5)" end="(338, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mp.intro.intro.intro.intro.intro.intro.intro.refl.intro&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ ∃ l₁' l₂', a :: l₁ = a :: l₁' ∧ b :: l₂ = b :: l₂' ∧ zipWith Prod.mk l₁ l₂ = zipWith Prod.mk l₁' l₂'" state_after="no goals" tactic="simp">
                            <AtomNode start="(338, 5)" end="(338, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(339, 3)" end="(340, 37)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ a_2 l₁' b_1 l₂', l₁ = a_2 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_2, b_1) ∧ l = zipWith Prod.mk l₁' l₂'" state_after="no goals" tactic="· rintro ⟨l₁', l₂', rfl, rfl, rfl⟩&#10;  refine ⟨a, l₁', b, l₂', by simp⟩">
                    <OtherNode start="(339, 3)" end="(339, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(339, 3)" end="(339, 4)" kind="patternIgnore">
                        <OtherNode start="(339, 3)" end="(339, 4)" kind="token.«· »">
                          <AtomNode start="(339, 3)" end="(339, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(339, 5)" end="(340, 37)">
                      <TacticTacticseq1IndentedNode start="(339, 5)" end="(340, 37)">
                        <NullNode start="(339, 5)" end="(340, 37)">
                          <OtherNode start="(339, 5)" end="(339, 37)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ (∃ l₁' l₂', l₁ = a :: l₁' ∧ l₂ = b :: l₂' ∧ l = zipWith Prod.mk l₁' l₂') →&#10;    ∃ a_2 l₁' b_1 l₂', l₁ = a_2 :: l₁' ∧ l₂ = b_1 :: l₂' ∧ (a, b) = (a_2, b_1) ∧ l = zipWith Prod.mk l₁' l₂'" state_after="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁' : List α&#10;l₂' : List β&#10;⊢ ∃ a_1 l₁'_1 b_1 l₂'_1,&#10;    a :: l₁' = a_1 :: l₁'_1 ∧&#10;      b :: l₂' = b_1 :: l₂'_1 ∧ (a, b) = (a_1, b_1) ∧ zipWith Prod.mk l₁' l₂' = zipWith Prod.mk l₁'_1 l₂'_1" tactic="rintro ⟨l₁', l₂', rfl, rfl, rfl⟩">
                            <AtomNode start="(339, 5)" end="(339, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(339, 12)" end="(339, 37)">
                              <OtherNode start="(339, 12)" end="(339, 37)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(339, 12)" end="(339, 37)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(339, 12)" end="(339, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(339, 13)" end="(339, 36)">
                                    <OtherNode start="(339, 13)" end="(339, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(339, 13)" end="(339, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(339, 13)" end="(339, 16)">
                                          <OtherNode start="(339, 13)" end="(339, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(339, 13)" end="(339, 16)" leading="" trailing="" raw_val="l₁'" val="l₁'"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(339, 16)" end="(339, 17)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(339, 18)" end="(339, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(339, 18)" end="(339, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(339, 18)" end="(339, 21)">
                                          <OtherNode start="(339, 18)" end="(339, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(339, 18)" end="(339, 21)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(339, 21)" end="(339, 22)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(339, 23)" end="(339, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(339, 23)" end="(339, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(339, 23)" end="(339, 26)">
                                          <OtherNode start="(339, 23)" end="(339, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(339, 23)" end="(339, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(339, 26)" end="(339, 27)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(339, 28)" end="(339, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(339, 28)" end="(339, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(339, 28)" end="(339, 31)">
                                          <OtherNode start="(339, 28)" end="(339, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(339, 28)" end="(339, 31)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(339, 31)" end="(339, 32)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(339, 33)" end="(339, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(339, 33)" end="(339, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(339, 33)" end="(339, 36)">
                                          <OtherNode start="(339, 33)" end="(339, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(339, 33)" end="(339, 36)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(339, 36)" end="(339, 37)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(340, 5)" end="(340, 37)" kind="Lean.Parser.Tactic.refine" state_before="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁' : List α&#10;l₂' : List β&#10;⊢ ∃ a_1 l₁'_1 b_1 l₂'_1,&#10;    a :: l₁' = a_1 :: l₁'_1 ∧&#10;      b :: l₂' = b_1 :: l₂'_1 ∧ (a, b) = (a_1, b_1) ∧ zipWith Prod.mk l₁' l₂' = zipWith Prod.mk l₁'_1 l₂'_1" state_after="no goals" tactic="refine ⟨a, l₁', b, l₂', by simp⟩">
                            <AtomNode start="(340, 5)" end="(340, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(340, 12)" end="(340, 37)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(340, 12)" end="(340, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(340, 13)" end="(340, 36)">
                                <IdentNode start="(340, 13)" end="(340, 14)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(340, 14)" end="(340, 15)" leading="" trailing=" " val=","/>
                                <IdentNode start="(340, 16)" end="(340, 19)" leading="" trailing="" raw_val="l₁'" val="l₁'"/>
                                <AtomNode start="(340, 19)" end="(340, 20)" leading="" trailing=" " val=","/>
                                <IdentNode start="(340, 21)" end="(340, 22)" leading="" trailing="" raw_val="b" val="b"/>
                                <AtomNode start="(340, 22)" end="(340, 23)" leading="" trailing=" " val=","/>
                                <IdentNode start="(340, 24)" end="(340, 27)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                                <AtomNode start="(340, 27)" end="(340, 28)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(340, 29)" end="(340, 36)">
                                  <AtomNode start="(340, 29)" end="(340, 31)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(340, 32)" end="(340, 36)">
                                    <TacticTacticseq1IndentedNode start="(340, 32)" end="(340, 36)">
                                      <NullNode start="(340, 32)" end="(340, 36)">
                                        <OtherNode start="(340, 32)" end="(340, 36)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l₁' : List α&#10;l₂' : List β&#10;⊢ a :: l₁' = a :: l₁' ∧ b :: l₂' = b :: l₂' ∧ (a, b) = (a, b) ∧ zipWith Prod.mk l₁' l₂' = zipWith Prod.mk l₁' l₂'" state_after="no goals" tactic="simp">
                                          <AtomNode start="(340, 32)" end="(340, 36)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(340, 36)" end="(340, 37)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(342, 1)" end="(345, 47)" name="zip_eq_append_iff" full_name="List.zip_eq_append_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(342, 1)" end="(345, 47)" name="zip_eq_append_iff" full_name="List.zip_eq_append_iff" _is_private_decl="False">
        <AtomNode start="(342, 1)" end="(342, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(342, 9)" end="(342, 26)">
          <IdentNode start="(342, 9)" end="(342, 26)" leading="" trailing=" " raw_val="zip_eq_append_iff" val="zip_eq_append_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(342, 27)" end="(344, 111)">
          <NullNode start="(342, 27)" end="(342, 54)">
            <OtherNode start="(342, 27)" end="(342, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 27)" end="(342, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 28)" end="(342, 30)">
                <IdentNode start="(342, 28)" end="(342, 30)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(342, 31)" end="(342, 39)">
                <AtomNode start="(342, 31)" end="(342, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 33)" end="(342, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(342, 33)" end="(342, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(342, 38)" end="(342, 39)">
                    <IdentNode start="(342, 38)" end="(342, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 39)" end="(342, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(342, 41)" end="(342, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 41)" end="(342, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 42)" end="(342, 44)">
                <IdentNode start="(342, 42)" end="(342, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(342, 45)" end="(342, 53)">
                <AtomNode start="(342, 45)" end="(342, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 47)" end="(342, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(342, 47)" end="(342, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(342, 52)" end="(342, 53)">
                    <IdentNode start="(342, 52)" end="(342, 53)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 53)" end="(342, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(342, 55)" end="(344, 111)">
            <AtomNode start="(342, 55)" end="(342, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(343, 5)" end="(344, 111)" kind="«term_↔_»">
              <OtherNode start="(343, 5)" end="(343, 27)" kind="«term_=_»">
                <OtherNode start="(343, 5)" end="(343, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(343, 5)" end="(343, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(343, 9)" end="(343, 14)">
                    <IdentNode start="(343, 9)" end="(343, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(343, 12)" end="(343, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(343, 15)" end="(343, 16)" leading="" trailing=" " val="="/>
                <OtherNode start="(343, 17)" end="(343, 27)" kind="«term_++_»">
                  <IdentNode start="(343, 17)" end="(343, 20)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                  <AtomNode start="(343, 21)" end="(343, 23)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(343, 24)" end="(343, 27)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(343, 28)" end="(343, 29)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(344, 7)" end="(344, 111)" kind="«term∃_,_»">
                <AtomNode start="(344, 7)" end="(344, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(344, 9)" end="(344, 20)" kind="Lean.explicitBinders">
                  <OtherNode start="(344, 9)" end="(344, 20)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(344, 9)" end="(344, 20)">
                      <LeanBinderidentNode start="(344, 9)" end="(344, 11)">
                        <IdentNode start="(344, 9)" end="(344, 11)" leading="" trailing=" " raw_val="ws" val="ws"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(344, 12)" end="(344, 14)">
                        <IdentNode start="(344, 12)" end="(344, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(344, 15)" end="(344, 17)">
                        <IdentNode start="(344, 15)" end="(344, 17)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(344, 18)" end="(344, 20)">
                        <IdentNode start="(344, 18)" end="(344, 20)" leading="" trailing="" raw_val="zs" val="zs"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(344, 20)" end="(344, 21)" leading="" trailing=" " val=","/>
                <OtherNode start="(344, 22)" end="(344, 111)" kind="«term_∧_»">
                  <OtherNode start="(344, 22)" end="(344, 43)" kind="«term_=_»">
                    <IdentNode start="(344, 22)" end="(344, 31)" leading="" trailing=" " raw_val="ws.length" val="ws.length"/>
                    <AtomNode start="(344, 32)" end="(344, 33)" leading="" trailing=" " val="="/>
                    <IdentNode start="(344, 34)" end="(344, 43)" leading="" trailing=" " raw_val="ys.length" val="ys.length"/>
                  </OtherNode>
                  <AtomNode start="(344, 44)" end="(344, 45)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(344, 46)" end="(344, 111)" kind="«term_∧_»">
                    <OtherNode start="(344, 46)" end="(344, 59)" kind="«term_=_»">
                      <IdentNode start="(344, 46)" end="(344, 48)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(344, 49)" end="(344, 50)" leading="" trailing=" " val="="/>
                      <OtherNode start="(344, 51)" end="(344, 59)" kind="«term_++_»">
                        <IdentNode start="(344, 51)" end="(344, 53)" leading="" trailing=" " raw_val="ws" val="ws"/>
                        <AtomNode start="(344, 54)" end="(344, 56)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(344, 57)" end="(344, 59)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(344, 60)" end="(344, 61)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(344, 62)" end="(344, 111)" kind="«term_∧_»">
                      <OtherNode start="(344, 62)" end="(344, 75)" kind="«term_=_»">
                        <IdentNode start="(344, 62)" end="(344, 64)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <AtomNode start="(344, 65)" end="(344, 66)" leading="" trailing=" " val="="/>
                        <OtherNode start="(344, 67)" end="(344, 75)" kind="«term_++_»">
                          <IdentNode start="(344, 67)" end="(344, 69)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          <AtomNode start="(344, 70)" end="(344, 72)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(344, 73)" end="(344, 75)" leading="" trailing=" " raw_val="zs" val="zs"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(344, 76)" end="(344, 77)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(344, 78)" end="(344, 111)" kind="«term_∧_»">
                        <OtherNode start="(344, 78)" end="(344, 93)" kind="«term_=_»">
                          <IdentNode start="(344, 78)" end="(344, 81)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                          <AtomNode start="(344, 82)" end="(344, 83)" leading="" trailing=" " val="="/>
                          <OtherNode start="(344, 84)" end="(344, 93)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(344, 84)" end="(344, 87)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                            <NullNode start="(344, 88)" end="(344, 93)">
                              <IdentNode start="(344, 88)" end="(344, 90)" leading="" trailing=" " raw_val="ws" val="ws"/>
                              <IdentNode start="(344, 91)" end="(344, 93)" leading="" trailing=" " raw_val="ys" val="ys"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(344, 94)" end="(344, 95)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(344, 96)" end="(344, 111)" kind="«term_=_»">
                          <IdentNode start="(344, 96)" end="(344, 99)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                          <AtomNode start="(344, 100)" end="(344, 101)" leading="" trailing=" " val="="/>
                          <OtherNode start="(344, 102)" end="(344, 111)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(344, 102)" end="(344, 105)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                            <NullNode start="(344, 106)" end="(344, 111)">
                              <IdentNode start="(344, 106)" end="(344, 108)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              <IdentNode start="(344, 109)" end="(344, 111)" leading="" trailing=" " raw_val="zs" val="zs"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(344, 112)" end="(345, 47)">
          <AtomNode start="(344, 112)" end="(344, 114)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(344, 115)" end="(345, 47)">
            <AtomNode start="(344, 115)" end="(344, 117)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(345, 3)" end="(345, 47)">
              <TacticTacticseq1IndentedNode start="(345, 3)" end="(345, 47)">
                <NullNode start="(345, 3)" end="(345, 47)">
                  <OtherNode start="(345, 3)" end="(345, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List (α × β)&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ l₁.zip l₂ = l₁' ++ l₂' ↔&#10;    ∃ ws xs ys zs, ws.length = ys.length ∧ l₁ = ws ++ xs ∧ l₂ = ys ++ zs ∧ l₁' = ws.zip ys ∧ l₂' = xs.zip zs" state_after="no goals" tactic="simp [zip_eq_zipWith, zipWith_eq_append_iff]">
                    <AtomNode start="(345, 3)" end="(345, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(345, 8)" end="(345, 47)">
                      <AtomNode start="(345, 8)" end="(345, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(345, 9)" end="(345, 46)">
                        <OtherNode start="(345, 9)" end="(345, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(345, 9)" end="(345, 23)" leading="" trailing="" raw_val="zip_eq_zipWith" val="zip_eq_zipWith" full_name="List.zip_eq_zipWith" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(252, 9)" def_end="(252, 23)"/>
                        </OtherNode>
                        <AtomNode start="(345, 23)" end="(345, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(345, 25)" end="(345, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(345, 25)" end="(345, 46)" leading="" trailing="" raw_val="zipWith_eq_append_iff" val="zipWith_eq_append_iff" full_name="List.zipWith_eq_append_iff" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(183, 9)" def_end="(183, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(345, 46)" end="(345, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(347, 1)" end="(352, 43)" name="zip_replicate'" full_name="List.zip_replicate'">
      <CommandDeclmodifiersNode start="(347, 1)" end="(348, 8)">
        <NullNode start="(347, 1)" end="(347, 111)">
          <CommandDoccommentNode start="(347, 1)" end="(347, 111)" comment="See also `List.zip_replicate` in `Init.Data.List.TakeDrop` for a generalization with different lengths. -/">
            <AtomNode start="(347, 1)" end="(347, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(347, 5)" end="(347, 111)" leading="" trailing="&#10;" val="See also `List.zip_replicate` in `Init.Data.List.TakeDrop` for a generalization with different lengths. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(348, 1)" end="(348, 8)">
          <OtherNode start="(348, 1)" end="(348, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(348, 1)" end="(348, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(348, 3)" end="(348, 7)">
              <OtherNode start="(348, 3)" end="(348, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(348, 3)" end="(348, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(348, 3)" end="(348, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(348, 7)" end="(348, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(348, 9)" end="(352, 43)" name="zip_replicate'" full_name="List.zip_replicate'" _is_private_decl="False">
        <AtomNode start="(348, 9)" end="(348, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(348, 17)" end="(348, 31)">
          <IdentNode start="(348, 17)" end="(348, 31)" leading="" trailing=" " raw_val="zip_replicate'" val="zip_replicate'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(348, 32)" end="(349, 61)">
          <NullNode start="(348, 32)" end="(348, 57)">
            <OtherNode start="(348, 32)" end="(348, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(348, 32)" end="(348, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(348, 33)" end="(348, 34)">
                <IdentNode start="(348, 33)" end="(348, 34)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(348, 35)" end="(348, 38)">
                <AtomNode start="(348, 35)" end="(348, 36)" leading="" trailing=" " val=":"/>
                <IdentNode start="(348, 37)" end="(348, 38)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(348, 38)" end="(348, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(348, 40)" end="(348, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(348, 40)" end="(348, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(348, 41)" end="(348, 42)">
                <IdentNode start="(348, 41)" end="(348, 42)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(348, 43)" end="(348, 46)">
                <AtomNode start="(348, 43)" end="(348, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(348, 45)" end="(348, 46)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(348, 46)" end="(348, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(348, 48)" end="(348, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(348, 48)" end="(348, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(348, 49)" end="(348, 50)">
                <IdentNode start="(348, 49)" end="(348, 50)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(348, 51)" end="(348, 56)">
                <AtomNode start="(348, 51)" end="(348, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(348, 53)" end="(348, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(348, 56)" end="(348, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(348, 58)" end="(349, 61)">
            <AtomNode start="(348, 58)" end="(348, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(349, 5)" end="(349, 61)" kind="«term_=_»">
              <OtherNode start="(349, 5)" end="(349, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(349, 5)" end="(349, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(349, 9)" end="(349, 40)">
                  <OtherNode start="(349, 9)" end="(349, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(349, 9)" end="(349, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(349, 10)" end="(349, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(349, 10)" end="(349, 19)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(349, 20)" end="(349, 23)">
                        <IdentNode start="(349, 20)" end="(349, 21)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(349, 22)" end="(349, 23)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(349, 23)" end="(349, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(349, 25)" end="(349, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(349, 25)" end="(349, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(349, 26)" end="(349, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(349, 26)" end="(349, 35)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(349, 36)" end="(349, 39)">
                        <IdentNode start="(349, 36)" end="(349, 37)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(349, 38)" end="(349, 39)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(349, 39)" end="(349, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(349, 41)" end="(349, 42)" leading="" trailing=" " val="="/>
              <OtherNode start="(349, 43)" end="(349, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(349, 43)" end="(349, 52)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(349, 53)" end="(349, 61)">
                  <IdentNode start="(349, 53)" end="(349, 54)" leading="" trailing=" " raw_val="n" val="n"/>
                  <OtherNode start="(349, 55)" end="(349, 61)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(349, 55)" end="(349, 56)" leading="" trailing="" val="("/>
                    <NullNode start="(349, 56)" end="(349, 60)">
                      <IdentNode start="(349, 56)" end="(349, 57)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(349, 57)" end="(349, 58)" leading="" trailing=" " val=","/>
                      <NullNode start="(349, 59)" end="(349, 60)">
                        <IdentNode start="(349, 59)" end="(349, 60)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(349, 60)" end="(349, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(349, 62)" end="(352, 43)">
          <AtomNode start="(349, 62)" end="(349, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(349, 65)" end="(352, 43)">
            <AtomNode start="(349, 65)" end="(349, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(350, 3)" end="(352, 43)">
              <TacticTacticseq1IndentedNode start="(350, 3)" end="(352, 43)">
                <NullNode start="(350, 3)" end="(352, 43)">
                  <OtherNode start="(350, 3)" end="(352, 43)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;n : Nat&#10;⊢ (replicate n a).zip (replicate n b) = replicate n (a, b)" state_after="no goals" tactic="induction n with&#10;| zero =&amp;gt; rfl&#10;| succ n ih =&amp;gt; simp [replicate_succ, ih]">
                    <AtomNode start="(350, 3)" end="(350, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(350, 13)" end="(350, 14)">
                      <OtherNode start="(350, 13)" end="(350, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(350, 13)" end="(350, 14)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(350, 15)" end="(352, 43)">
                      <OtherNode start="(350, 15)" end="(352, 43)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(350, 15)" end="(350, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(351, 3)" end="(352, 43)">
                          <OtherNode start="(351, 3)" end="(351, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(351, 3)" end="(351, 9)">
                              <OtherNode start="(351, 3)" end="(351, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(351, 3)" end="(351, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(351, 5)" end="(351, 9)">
                                  <NullNode/>
                                  <IdentNode start="(351, 5)" end="(351, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(351, 10)" end="(351, 16)">
                              <AtomNode start="(351, 10)" end="(351, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(351, 13)" end="(351, 16)">
                                <TacticTacticseq1IndentedNode start="(351, 13)" end="(351, 16)">
                                  <NullNode start="(351, 13)" end="(351, 16)">
                                    <OtherNode start="(351, 13)" end="(351, 16)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case zero&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;⊢ (replicate 0 a).zip (replicate 0 b) = replicate 0 (a, b)" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(351, 13)" end="(351, 16)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(352, 3)" end="(352, 43)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(352, 3)" end="(352, 14)">
                              <OtherNode start="(352, 3)" end="(352, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(352, 3)" end="(352, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(352, 5)" end="(352, 9)">
                                  <NullNode/>
                                  <IdentNode start="(352, 5)" end="(352, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(352, 10)" end="(352, 14)">
                                  <IdentNode start="(352, 10)" end="(352, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                  <IdentNode start="(352, 12)" end="(352, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(352, 15)" end="(352, 43)">
                              <AtomNode start="(352, 15)" end="(352, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(352, 18)" end="(352, 43)">
                                <TacticTacticseq1IndentedNode start="(352, 18)" end="(352, 43)">
                                  <NullNode start="(352, 18)" end="(352, 43)">
                                    <OtherNode start="(352, 18)" end="(352, 43)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;n : Nat&#10;ih : (replicate n a).zip (replicate n b) = replicate n (a, b)&#10;⊢ (replicate (n + 1) a).zip (replicate (n + 1) b) = replicate (n + 1) (a, b)" state_after="no goals" tactic="simp [replicate_succ, ih]">
                                      <AtomNode start="(352, 18)" end="(352, 22)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(352, 23)" end="(352, 43)">
                                        <AtomNode start="(352, 23)" end="(352, 24)" leading="" trailing="" val="["/>
                                        <NullNode start="(352, 24)" end="(352, 42)">
                                          <OtherNode start="(352, 24)" end="(352, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(352, 24)" end="(352, 38)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(352, 38)" end="(352, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(352, 40)" end="(352, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(352, 40)" end="(352, 42)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(352, 42)" end="(352, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(354, 1)" end="(354, 22)" comment="### zipWithAll -/">
      <AtomNode start="(354, 1)" end="(354, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(354, 5)" end="(354, 22)" leading="" trailing="&#10;&#10;" val="### zipWithAll -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(356, 1)" end="(367, 40)" name="getElem?_zipWithAll" full_name="List.getElem?_zipWithAll">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(356, 1)" end="(367, 40)" name="getElem?_zipWithAll" full_name="List.getElem?_zipWithAll" _is_private_decl="False">
        <AtomNode start="(356, 1)" end="(356, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(356, 9)" end="(356, 28)">
          <IdentNode start="(356, 9)" end="(356, 28)" leading="" trailing=" " raw_val="getElem?_zipWithAll" val="getElem?_zipWithAll"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(356, 29)" end="(358, 55)">
          <NullNode start="(356, 29)" end="(356, 68)">
            <OtherNode start="(356, 29)" end="(356, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(356, 29)" end="(356, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(356, 30)" end="(356, 31)">
                <IdentNode start="(356, 30)" end="(356, 31)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(356, 32)" end="(356, 57)">
                <AtomNode start="(356, 32)" end="(356, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(356, 34)" end="(356, 57)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(356, 34)" end="(356, 42)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(356, 34)" end="(356, 40)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(356, 41)" end="(356, 42)">
                      <IdentNode start="(356, 41)" end="(356, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(356, 43)" end="(356, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(356, 45)" end="(356, 57)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(356, 45)" end="(356, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(356, 45)" end="(356, 51)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(356, 52)" end="(356, 53)">
                        <IdentNode start="(356, 52)" end="(356, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(356, 54)" end="(356, 55)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(356, 56)" end="(356, 57)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(356, 57)" end="(356, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(356, 59)" end="(356, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(356, 59)" end="(356, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(356, 60)" end="(356, 61)">
                <IdentNode start="(356, 60)" end="(356, 61)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(356, 62)" end="(356, 67)">
                <AtomNode start="(356, 62)" end="(356, 63)" leading="" trailing=" " val=":"/>
                <IdentNode start="(356, 64)" end="(356, 67)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(356, 67)" end="(356, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(356, 69)" end="(358, 55)">
            <AtomNode start="(356, 69)" end="(356, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(357, 5)" end="(358, 55)" kind="«term_=_»">
              <OtherNode start="(357, 5)" end="(357, 29)" kind="«term__[_]_?»">
                <OtherNode start="(357, 5)" end="(357, 25)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(357, 5)" end="(357, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(357, 6)" end="(357, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(357, 6)" end="(357, 16)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(357, 17)" end="(357, 24)">
                      <IdentNode start="(357, 17)" end="(357, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(357, 19)" end="(357, 21)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(357, 22)" end="(357, 24)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(357, 24)" end="(357, 25)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(357, 25)" end="(357, 26)" leading="" trailing="" val="["/>
                <IdentNode start="(357, 26)" end="(357, 27)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(357, 27)" end="(357, 28)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(357, 28)" end="(357, 29)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(357, 30)" end="(357, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(357, 32)" end="(358, 55)" kind="Lean.Parser.Term.match">
                <AtomNode start="(357, 32)" end="(357, 37)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(357, 38)" end="(357, 52)">
                  <OtherNode start="(357, 38)" end="(357, 44)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(357, 38)" end="(357, 44)" kind="«term__[_]_?»">
                      <IdentNode start="(357, 38)" end="(357, 40)" leading="" trailing="" raw_val="as" val="as"/>
                      <GroupNode/>
                      <AtomNode start="(357, 40)" end="(357, 41)" leading="" trailing="" val="["/>
                      <IdentNode start="(357, 41)" end="(357, 42)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(357, 42)" end="(357, 43)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(357, 43)" end="(357, 44)" leading="" trailing="" val="?"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(357, 44)" end="(357, 45)" leading="" trailing=" " val=","/>
                  <OtherNode start="(357, 46)" end="(357, 52)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(357, 46)" end="(357, 52)" kind="«term__[_]_?»">
                      <IdentNode start="(357, 46)" end="(357, 48)" leading="" trailing="" raw_val="bs" val="bs"/>
                      <GroupNode/>
                      <AtomNode start="(357, 48)" end="(357, 49)" leading="" trailing="" val="["/>
                      <IdentNode start="(357, 49)" end="(357, 50)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(357, 50)" end="(357, 51)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(357, 51)" end="(357, 52)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(357, 53)" end="(357, 57)" leading="" trailing="&#10;      " val="with"/>
                <OtherNode start="(358, 7)" end="(358, 55)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(358, 7)" end="(358, 55)">
                    <OtherNode start="(358, 7)" end="(358, 28)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(358, 7)" end="(358, 8)" leading="" trailing=" " val="|"/>
                      <NullNode start="(358, 9)" end="(358, 19)">
                        <NullNode start="(358, 9)" end="(358, 19)">
                          <IdentNode start="(358, 9)" end="(358, 13)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <AtomNode start="(358, 13)" end="(358, 14)" leading="" trailing=" " val=","/>
                          <IdentNode start="(358, 15)" end="(358, 19)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(358, 20)" end="(358, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(358, 23)" end="(358, 28)" kind="Lean.Parser.Term.dotIdent">
                        <AtomNode start="(358, 23)" end="(358, 24)" leading="" trailing="" val="."/>
                        <IdentNode start="(358, 24)" end="(358, 28)" leading="" trailing=" " raw_val="none" val="none"/>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(358, 29)" end="(358, 55)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(358, 29)" end="(358, 30)" leading="" trailing=" " val="|"/>
                      <NullNode start="(358, 31)" end="(358, 37)">
                        <NullNode start="(358, 31)" end="(358, 37)">
                          <IdentNode start="(358, 31)" end="(358, 33)" leading="" trailing="" raw_val="a?" val="a?"/>
                          <AtomNode start="(358, 33)" end="(358, 34)" leading="" trailing=" " val=","/>
                          <IdentNode start="(358, 35)" end="(358, 37)" leading="" trailing=" " raw_val="b?" val="b?"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(358, 38)" end="(358, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(358, 41)" end="(358, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(358, 41)" end="(358, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(358, 46)" end="(358, 55)">
                          <OtherNode start="(358, 46)" end="(358, 55)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(358, 46)" end="(358, 47)" leading="" trailing="" val="("/>
                            <OtherNode start="(358, 47)" end="(358, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(358, 47)" end="(358, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(358, 49)" end="(358, 54)">
                                <IdentNode start="(358, 49)" end="(358, 51)" leading="" trailing=" " raw_val="a?" val="a?"/>
                                <IdentNode start="(358, 52)" end="(358, 54)" leading="" trailing="" raw_val="b?" val="b?"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(358, 54)" end="(358, 55)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(358, 56)" end="(367, 40)">
          <AtomNode start="(358, 56)" end="(358, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(358, 59)" end="(367, 40)">
            <AtomNode start="(358, 59)" end="(358, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(359, 3)" end="(367, 40)">
              <TacticTacticseq1IndentedNode start="(359, 3)" end="(367, 40)">
                <NullNode start="(359, 3)" end="(367, 40)">
                  <OtherNode start="(359, 3)" end="(367, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;⊢ (zipWithAll f as bs)[i]? =&#10;    match as[i]?, bs[i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="induction as generalizing bs i with&#10;| nil =&amp;gt; induction bs generalizing i with&#10;  | nil =&amp;gt; simp&#10;  | cons b bs bih =&amp;gt; cases i &amp;lt;;&amp;gt; simp_all&#10;| cons a as aih =&amp;gt; cases bs with&#10;  | nil =&amp;gt;&#10;    specialize @aih []&#10;    cases i &amp;lt;;&amp;gt; simp_all&#10;  | cons b bs =&amp;gt; cases i &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(359, 3)" end="(359, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(359, 13)" end="(359, 15)">
                      <OtherNode start="(359, 13)" end="(359, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(359, 13)" end="(359, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(359, 16)" end="(359, 33)">
                      <AtomNode start="(359, 16)" end="(359, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(359, 29)" end="(359, 33)">
                        <IdentNode start="(359, 29)" end="(359, 31)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        <IdentNode start="(359, 32)" end="(359, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(359, 34)" end="(367, 40)">
                      <OtherNode start="(359, 34)" end="(367, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(359, 34)" end="(359, 38)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(360, 3)" end="(367, 40)">
                          <OtherNode start="(360, 3)" end="(362, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(360, 3)" end="(360, 8)">
                              <OtherNode start="(360, 3)" end="(360, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(360, 3)" end="(360, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(360, 5)" end="(360, 8)">
                                  <NullNode/>
                                  <IdentNode start="(360, 5)" end="(360, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(360, 9)" end="(362, 44)">
                              <AtomNode start="(360, 9)" end="(360, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(360, 12)" end="(362, 44)">
                                <TacticTacticseq1IndentedNode start="(360, 12)" end="(362, 44)">
                                  <NullNode start="(360, 12)" end="(362, 44)">
                                    <OtherNode start="(360, 12)" end="(362, 44)" kind="Lean.Parser.Tactic.induction" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;bs : List β&#10;i : Nat&#10;⊢ (zipWithAll f [] bs)[i]? =&#10;    match [][i]?, bs[i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="induction bs generalizing i with&#10;| nil =&amp;gt; simp&#10;| cons b bs bih =&amp;gt; cases i &amp;lt;;&amp;gt; simp_all">
                                      <AtomNode start="(360, 12)" end="(360, 21)" leading="" trailing=" " val="induction"/>
                                      <NullNode start="(360, 22)" end="(360, 24)">
                                        <OtherNode start="(360, 22)" end="(360, 24)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(360, 22)" end="(360, 24)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(360, 25)" end="(360, 39)">
                                        <AtomNode start="(360, 25)" end="(360, 37)" leading="" trailing=" " val="generalizing"/>
                                        <NullNode start="(360, 38)" end="(360, 39)">
                                          <IdentNode start="(360, 38)" end="(360, 39)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </NullNode>
                                      </NullNode>
                                      <NullNode start="(360, 40)" end="(362, 44)">
                                        <OtherNode start="(360, 40)" end="(362, 44)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(360, 40)" end="(360, 44)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(361, 5)" end="(362, 44)">
                                            <OtherNode start="(361, 5)" end="(361, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(361, 5)" end="(361, 10)">
                                                <OtherNode start="(361, 5)" end="(361, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(361, 5)" end="(361, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(361, 7)" end="(361, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(361, 7)" end="(361, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(361, 11)" end="(361, 18)">
                                                <AtomNode start="(361, 11)" end="(361, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(361, 14)" end="(361, 18)">
                                                  <TacticTacticseq1IndentedNode start="(361, 14)" end="(361, 18)">
                                                    <NullNode start="(361, 14)" end="(361, 18)">
                                                      <OtherNode start="(361, 14)" end="(361, 18)" kind="Lean.Parser.Tactic.simp" state_before="case nil.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;i : Nat&#10;⊢ (zipWithAll f [] [])[i]? =&#10;    match [][i]?, [][i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(361, 14)" end="(361, 18)" leading="" trailing="&#10;    " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(362, 5)" end="(362, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(362, 5)" end="(362, 20)">
                                                <OtherNode start="(362, 5)" end="(362, 20)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(362, 5)" end="(362, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(362, 7)" end="(362, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(362, 7)" end="(362, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(362, 12)" end="(362, 20)">
                                                    <IdentNode start="(362, 12)" end="(362, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(362, 14)" end="(362, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                    <IdentNode start="(362, 17)" end="(362, 20)" leading="" trailing=" " raw_val="bih" val="bih"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(362, 21)" end="(362, 44)">
                                                <AtomNode start="(362, 21)" end="(362, 23)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(362, 24)" end="(362, 44)">
                                                  <TacticTacticseq1IndentedNode start="(362, 24)" end="(362, 44)">
                                                    <NullNode start="(362, 24)" end="(362, 44)">
                                                      <OtherNode start="(362, 24)" end="(362, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case nil.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;b : β&#10;bs : List β&#10;bih :&#10;  ∀ {i : Nat},&#10;    (zipWithAll f [] bs)[i]? =&#10;      match [][i]?, bs[i]? with&#10;      | none, none =&amp;gt; none&#10;      | a?, b? =&amp;gt; some (f a? b?)&#10;i : Nat&#10;⊢ (zipWithAll f [] (b :: bs))[i]? =&#10;    match [][i]?, (b :: bs)[i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="cases i &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(362, 24)" end="(362, 31)" kind="Lean.Parser.Tactic.cases">
                                                          <AtomNode start="(362, 24)" end="(362, 29)" leading="" trailing=" " val="cases"/>
                                                          <NullNode start="(362, 30)" end="(362, 31)">
                                                            <OtherNode start="(362, 30)" end="(362, 31)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(362, 30)" end="(362, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(362, 32)" end="(362, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(362, 36)" end="(362, 44)" kind="Lean.Parser.Tactic.simpAll">
                                                          <AtomNode start="(362, 36)" end="(362, 44)" leading="" trailing="&#10;  " val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(363, 3)" end="(367, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(363, 3)" end="(363, 18)">
                              <OtherNode start="(363, 3)" end="(363, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(363, 3)" end="(363, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(363, 5)" end="(363, 9)">
                                  <NullNode/>
                                  <IdentNode start="(363, 5)" end="(363, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(363, 10)" end="(363, 18)">
                                  <IdentNode start="(363, 10)" end="(363, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(363, 12)" end="(363, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(363, 15)" end="(363, 18)" leading="" trailing=" " raw_val="aih" val="aih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(363, 19)" end="(367, 40)">
                              <AtomNode start="(363, 19)" end="(363, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(363, 22)" end="(367, 40)">
                                <TacticTacticseq1IndentedNode start="(363, 22)" end="(367, 40)">
                                  <NullNode start="(363, 22)" end="(367, 40)">
                                    <OtherNode start="(363, 22)" end="(367, 40)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;a : α&#10;as : List α&#10;aih :&#10;  ∀ {bs : List β} {i : Nat},&#10;    (zipWithAll f as bs)[i]? =&#10;      match as[i]?, bs[i]? with&#10;      | none, none =&amp;gt; none&#10;      | a?, b? =&amp;gt; some (f a? b?)&#10;bs : List β&#10;i : Nat&#10;⊢ (zipWithAll f (a :: as) bs)[i]? =&#10;    match (a :: as)[i]?, bs[i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="cases bs with&#10;| nil =&amp;gt;&#10;specialize @aih []&#10;cases i &amp;lt;;&amp;gt; simp_all&#10;| cons b bs =&amp;gt; cases i &amp;lt;;&amp;gt; simp_all">
                                      <AtomNode start="(363, 22)" end="(363, 27)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(363, 28)" end="(363, 30)">
                                        <OtherNode start="(363, 28)" end="(363, 30)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(363, 28)" end="(363, 30)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(363, 31)" end="(367, 40)">
                                        <OtherNode start="(363, 31)" end="(367, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(363, 31)" end="(363, 35)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(364, 5)" end="(367, 40)">
                                            <OtherNode start="(364, 5)" end="(366, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(364, 5)" end="(364, 10)">
                                                <OtherNode start="(364, 5)" end="(364, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(364, 5)" end="(364, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(364, 7)" end="(364, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(364, 7)" end="(364, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(364, 11)" end="(366, 27)">
                                                <AtomNode start="(364, 11)" end="(364, 13)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(365, 7)" end="(366, 27)">
                                                  <TacticTacticseq1IndentedNode start="(365, 7)" end="(366, 27)">
                                                    <NullNode start="(365, 7)" end="(366, 27)">
                                                      <OtherNode start="(365, 7)" end="(365, 25)" kind="Lean.Parser.Tactic.specialize" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;a : α&#10;as : List α&#10;aih :&#10;  ∀ {bs : List β} {i : Nat},&#10;    (zipWithAll f as bs)[i]? =&#10;      match as[i]?, bs[i]? with&#10;      | none, none =&amp;gt; none&#10;      | a?, b? =&amp;gt; some (f a? b?)&#10;i : Nat&#10;⊢ (zipWithAll f (a :: as) [])[i]? =&#10;    match (a :: as)[i]?, [][i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;a : α&#10;as : List α&#10;i : Nat&#10;aih :&#10;  ∀ {i : Nat},&#10;    (zipWithAll f as [])[i]? =&#10;      match as[i]?, [][i]? with&#10;      | none, none =&amp;gt; none&#10;      | a?, b? =&amp;gt; some (f a? b?)&#10;⊢ (zipWithAll f (a :: as) [])[i]? =&#10;    match (a :: as)[i]?, [][i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" tactic="specialize @aih []">
                                                        <AtomNode start="(365, 7)" end="(365, 17)" leading="" trailing=" " val="specialize"/>
                                                        <OtherNode start="(365, 18)" end="(365, 25)" kind="Lean.Parser.Term.app">
                                                          <OtherNode start="(365, 18)" end="(365, 22)" kind="Lean.Parser.Term.explicit">
                                                            <AtomNode start="(365, 18)" end="(365, 19)" leading="" trailing="" val="@"/>
                                                            <IdentNode start="(365, 19)" end="(365, 22)" leading="" trailing=" " raw_val="aih" val="aih"/>
                                                          </OtherNode>
                                                          <NullNode start="(365, 23)" end="(365, 25)">
                                                            <OtherNode start="(365, 23)" end="(365, 25)" kind="«term[_]»">
                                                            <AtomNode start="(365, 23)" end="(365, 24)" leading="" trailing="" val="["/>
                                                            <NullNode/>
                                                            <AtomNode start="(365, 24)" end="(365, 25)" leading="" trailing="&#10;      " val="]"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(366, 7)" end="(366, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;a : α&#10;as : List α&#10;i : Nat&#10;aih :&#10;  ∀ {i : Nat},&#10;    (zipWithAll f as [])[i]? =&#10;      match as[i]?, [][i]? with&#10;      | none, none =&amp;gt; none&#10;      | a?, b? =&amp;gt; some (f a? b?)&#10;⊢ (zipWithAll f (a :: as) [])[i]? =&#10;    match (a :: as)[i]?, [][i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="cases i &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(366, 7)" end="(366, 14)" kind="Lean.Parser.Tactic.cases">
                                                          <AtomNode start="(366, 7)" end="(366, 12)" leading="" trailing=" " val="cases"/>
                                                          <NullNode start="(366, 13)" end="(366, 14)">
                                                            <OtherNode start="(366, 13)" end="(366, 14)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(366, 13)" end="(366, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(366, 15)" end="(366, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(366, 19)" end="(366, 27)" kind="Lean.Parser.Tactic.simpAll">
                                                          <AtomNode start="(366, 19)" end="(366, 27)" leading="" trailing="&#10;    " val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(367, 5)" end="(367, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(367, 5)" end="(367, 16)">
                                                <OtherNode start="(367, 5)" end="(367, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(367, 5)" end="(367, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(367, 7)" end="(367, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(367, 7)" end="(367, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(367, 12)" end="(367, 16)">
                                                    <IdentNode start="(367, 12)" end="(367, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(367, 14)" end="(367, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(367, 17)" end="(367, 40)">
                                                <AtomNode start="(367, 17)" end="(367, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(367, 20)" end="(367, 40)">
                                                  <TacticTacticseq1IndentedNode start="(367, 20)" end="(367, 40)">
                                                    <NullNode start="(367, 20)" end="(367, 40)">
                                                      <OtherNode start="(367, 20)" end="(367, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;a : α&#10;as : List α&#10;aih :&#10;  ∀ {bs : List β} {i : Nat},&#10;    (zipWithAll f as bs)[i]? =&#10;      match as[i]?, bs[i]? with&#10;      | none, none =&amp;gt; none&#10;      | a?, b? =&amp;gt; some (f a? b?)&#10;i : Nat&#10;b : β&#10;bs : List β&#10;⊢ (zipWithAll f (a :: as) (b :: bs))[i]? =&#10;    match (a :: as)[i]?, (b :: bs)[i]? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="cases i &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(367, 20)" end="(367, 27)" kind="Lean.Parser.Tactic.cases">
                                                          <AtomNode start="(367, 20)" end="(367, 25)" leading="" trailing=" " val="cases"/>
                                                          <NullNode start="(367, 26)" end="(367, 27)">
                                                            <OtherNode start="(367, 26)" end="(367, 27)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(367, 26)" end="(367, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(367, 28)" end="(367, 31)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(367, 32)" end="(367, 40)" kind="Lean.Parser.Tactic.simpAll">
                                                          <AtomNode start="(367, 32)" end="(367, 40)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(369, 1)" end="(372, 48)" name="head?_zipWithAll" full_name="List.head?_zipWithAll">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(369, 1)" end="(372, 48)" name="head?_zipWithAll" full_name="List.head?_zipWithAll" _is_private_decl="False">
        <AtomNode start="(369, 1)" end="(369, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(369, 9)" end="(369, 25)">
          <IdentNode start="(369, 9)" end="(369, 25)" leading="" trailing=" " raw_val="head?_zipWithAll" val="head?_zipWithAll"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(369, 26)" end="(371, 55)">
          <NullNode start="(369, 26)" end="(369, 55)">
            <OtherNode start="(369, 26)" end="(369, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(369, 26)" end="(369, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(369, 27)" end="(369, 28)">
                <IdentNode start="(369, 27)" end="(369, 28)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(369, 29)" end="(369, 54)">
                <AtomNode start="(369, 29)" end="(369, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(369, 31)" end="(369, 54)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(369, 31)" end="(369, 39)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(369, 31)" end="(369, 37)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(369, 38)" end="(369, 39)">
                      <IdentNode start="(369, 38)" end="(369, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(369, 40)" end="(369, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(369, 42)" end="(369, 54)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(369, 42)" end="(369, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(369, 42)" end="(369, 48)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(369, 49)" end="(369, 50)">
                        <IdentNode start="(369, 49)" end="(369, 50)" leading="" trailing=" " raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(369, 51)" end="(369, 52)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(369, 53)" end="(369, 54)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(369, 54)" end="(369, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(369, 56)" end="(371, 55)">
            <AtomNode start="(369, 56)" end="(369, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(370, 5)" end="(371, 55)" kind="«term_=_»">
              <OtherNode start="(370, 5)" end="(370, 31)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(370, 5)" end="(370, 25)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(370, 5)" end="(370, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(370, 6)" end="(370, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(370, 6)" end="(370, 16)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(370, 17)" end="(370, 24)">
                      <IdentNode start="(370, 17)" end="(370, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(370, 19)" end="(370, 21)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(370, 22)" end="(370, 24)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(370, 24)" end="(370, 25)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(370, 25)" end="(370, 26)" leading="" trailing="" val="."/>
                <IdentNode start="(370, 26)" end="(370, 31)" leading="" trailing=" " raw_val="head?" val="head?" full_name="List.head?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(370, 32)" end="(370, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(370, 34)" end="(371, 55)" kind="Lean.Parser.Term.match">
                <AtomNode start="(370, 34)" end="(370, 39)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(370, 40)" end="(370, 58)">
                  <OtherNode start="(370, 40)" end="(370, 48)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <IdentNode start="(370, 40)" end="(370, 48)" leading="" trailing="" raw_val="as.head?" val="as.head?"/>
                  </OtherNode>
                  <AtomNode start="(370, 48)" end="(370, 49)" leading="" trailing=" " val=","/>
                  <OtherNode start="(370, 50)" end="(370, 58)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <IdentNode start="(370, 50)" end="(370, 58)" leading="" trailing=" " raw_val="bs.head?" val="bs.head?"/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(370, 59)" end="(370, 63)" leading="" trailing="&#10;      " val="with"/>
                <OtherNode start="(371, 7)" end="(371, 55)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(371, 7)" end="(371, 55)">
                    <OtherNode start="(371, 7)" end="(371, 28)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(371, 7)" end="(371, 8)" leading="" trailing=" " val="|"/>
                      <NullNode start="(371, 9)" end="(371, 19)">
                        <NullNode start="(371, 9)" end="(371, 19)">
                          <IdentNode start="(371, 9)" end="(371, 13)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <AtomNode start="(371, 13)" end="(371, 14)" leading="" trailing=" " val=","/>
                          <IdentNode start="(371, 15)" end="(371, 19)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(371, 20)" end="(371, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(371, 23)" end="(371, 28)" kind="Lean.Parser.Term.dotIdent">
                        <AtomNode start="(371, 23)" end="(371, 24)" leading="" trailing="" val="."/>
                        <IdentNode start="(371, 24)" end="(371, 28)" leading="" trailing=" " raw_val="none" val="none"/>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(371, 29)" end="(371, 55)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(371, 29)" end="(371, 30)" leading="" trailing=" " val="|"/>
                      <NullNode start="(371, 31)" end="(371, 37)">
                        <NullNode start="(371, 31)" end="(371, 37)">
                          <IdentNode start="(371, 31)" end="(371, 33)" leading="" trailing="" raw_val="a?" val="a?"/>
                          <AtomNode start="(371, 33)" end="(371, 34)" leading="" trailing=" " val=","/>
                          <IdentNode start="(371, 35)" end="(371, 37)" leading="" trailing=" " raw_val="b?" val="b?"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(371, 38)" end="(371, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(371, 41)" end="(371, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(371, 41)" end="(371, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(371, 46)" end="(371, 55)">
                          <OtherNode start="(371, 46)" end="(371, 55)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(371, 46)" end="(371, 47)" leading="" trailing="" val="("/>
                            <OtherNode start="(371, 47)" end="(371, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(371, 47)" end="(371, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(371, 49)" end="(371, 54)">
                                <IdentNode start="(371, 49)" end="(371, 51)" leading="" trailing=" " raw_val="a?" val="a?"/>
                                <IdentNode start="(371, 52)" end="(371, 54)" leading="" trailing="" raw_val="b?" val="b?"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(371, 54)" end="(371, 55)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(371, 56)" end="(372, 48)">
          <AtomNode start="(371, 56)" end="(371, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(371, 59)" end="(372, 48)">
            <AtomNode start="(371, 59)" end="(371, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(372, 3)" end="(372, 48)">
              <TacticTacticseq1IndentedNode start="(372, 3)" end="(372, 48)">
                <NullNode start="(372, 3)" end="(372, 48)">
                  <OtherNode start="(372, 3)" end="(372, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;⊢ (zipWithAll f as bs).head? =&#10;    match as.head?, bs.head? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)" state_after="no goals" tactic="simp [head?_eq_getElem?, getElem?_zipWithAll]">
                    <AtomNode start="(372, 3)" end="(372, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(372, 8)" end="(372, 48)">
                      <AtomNode start="(372, 8)" end="(372, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(372, 9)" end="(372, 47)">
                        <OtherNode start="(372, 9)" end="(372, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(372, 9)" end="(372, 26)" leading="" trailing="" raw_val="head?_eq_getElem?" val="head?_eq_getElem?" full_name="List.head?_eq_getElem?" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(372, 26)" end="(372, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(372, 28)" end="(372, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(372, 28)" end="(372, 47)" leading="" trailing="" raw_val="getElem?_zipWithAll" val="getElem?_zipWithAll" full_name="List.getElem?_zipWithAll" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(356, 9)" def_end="(356, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(372, 47)" end="(372, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(374, 1)" end="(378, 21)" name="head_zipWithAll" full_name="List.head_zipWithAll">
      <CommandDeclmodifiersNode start="(374, 1)" end="(374, 8)">
        <NullNode/>
        <NullNode start="(374, 1)" end="(374, 8)">
          <OtherNode start="(374, 1)" end="(374, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(374, 1)" end="(374, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(374, 3)" end="(374, 7)">
              <OtherNode start="(374, 3)" end="(374, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(374, 3)" end="(374, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(374, 3)" end="(374, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(374, 7)" end="(374, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(374, 9)" end="(378, 21)" name="head_zipWithAll" full_name="List.head_zipWithAll" _is_private_decl="False">
        <AtomNode start="(374, 9)" end="(374, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(374, 17)" end="(374, 32)">
          <IdentNode start="(374, 17)" end="(374, 32)" leading="" trailing=" " raw_val="head_zipWithAll" val="head_zipWithAll"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(374, 33)" end="(375, 54)">
          <NullNode start="(374, 33)" end="(374, 66)">
            <OtherNode start="(374, 33)" end="(374, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(374, 33)" end="(374, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(374, 34)" end="(374, 35)">
                <IdentNode start="(374, 34)" end="(374, 35)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(374, 36)" end="(374, 61)">
                <AtomNode start="(374, 36)" end="(374, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(374, 38)" end="(374, 61)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(374, 38)" end="(374, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(374, 38)" end="(374, 44)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(374, 45)" end="(374, 46)">
                      <IdentNode start="(374, 45)" end="(374, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(374, 47)" end="(374, 48)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(374, 49)" end="(374, 61)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(374, 49)" end="(374, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(374, 49)" end="(374, 55)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(374, 56)" end="(374, 57)">
                        <IdentNode start="(374, 56)" end="(374, 57)" leading="" trailing=" " raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(374, 58)" end="(374, 59)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(374, 60)" end="(374, 61)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(374, 61)" end="(374, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(374, 63)" end="(374, 66)">
              <AtomNode start="(374, 63)" end="(374, 64)" leading="" trailing="" val="("/>
              <NullNode start="(374, 64)" end="(374, 65)">
                <IdentNode start="(374, 64)" end="(374, 65)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(374, 65)" end="(374, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(374, 67)" end="(375, 54)">
            <AtomNode start="(374, 67)" end="(374, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(375, 5)" end="(375, 54)" kind="«term_=_»">
              <OtherNode start="(375, 5)" end="(375, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(375, 5)" end="(375, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(375, 5)" end="(375, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(375, 5)" end="(375, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(375, 6)" end="(375, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(375, 6)" end="(375, 16)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(375, 17)" end="(375, 24)">
                        <IdentNode start="(375, 17)" end="(375, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(375, 19)" end="(375, 21)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(375, 22)" end="(375, 24)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(375, 24)" end="(375, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(375, 25)" end="(375, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(375, 26)" end="(375, 30)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(375, 31)" end="(375, 32)">
                  <IdentNode start="(375, 31)" end="(375, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(375, 33)" end="(375, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(375, 35)" end="(375, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(375, 35)" end="(375, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(375, 37)" end="(375, 54)">
                  <IdentNode start="(375, 37)" end="(375, 45)" leading="" trailing=" " raw_val="as.head?" val="as.head?"/>
                  <IdentNode start="(375, 46)" end="(375, 54)" leading="" trailing=" " raw_val="bs.head?" val="bs.head?"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(375, 55)" end="(378, 21)">
          <AtomNode start="(375, 55)" end="(375, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(375, 58)" end="(378, 21)">
            <AtomNode start="(375, 58)" end="(375, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(376, 3)" end="(378, 21)">
              <TacticTacticseq1IndentedNode start="(376, 3)" end="(378, 21)">
                <NullNode start="(376, 3)" end="(378, 21)">
                  <OtherNode start="(376, 3)" end="(376, 24)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;h : zipWithAll f as bs ≠ []&#10;⊢ (zipWithAll f as bs).head h = f as.head? bs.head?" state_after="case x&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;h : zipWithAll f as bs ≠ []&#10;⊢ some ((zipWithAll f as bs).head h) = some (f as.head? bs.head?)" tactic="apply Option.some.inj">
                    <AtomNode start="(376, 3)" end="(376, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(376, 9)" end="(376, 24)" leading="" trailing="&#10;  " raw_val="Option.some.inj" val="Option.some.inj" full_name="Option.some.inj" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(377, 3)" end="(377, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="case x&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;h : zipWithAll f as bs ≠ []&#10;⊢ some ((zipWithAll f as bs).head h) = some (f as.head? bs.head?)" state_after="case x&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;h : zipWithAll f as bs ≠ []&#10;⊢ (match as.head?, bs.head? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)) =&#10;    some (f as.head? bs.head?)" tactic="rw [← head?_eq_head, head?_zipWithAll]">
                    <AtomNode start="(377, 3)" end="(377, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(377, 6)" end="(377, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(377, 6)" end="(377, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(377, 7)" end="(377, 40)">
                        <OtherNode start="(377, 7)" end="(377, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(377, 7)" end="(377, 8)">
                            <OtherNode start="(377, 7)" end="(377, 8)" kind="patternIgnore">
                              <OtherNode start="(377, 7)" end="(377, 8)" kind="token.«← »">
                                <AtomNode start="(377, 7)" end="(377, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(377, 9)" end="(377, 22)" leading="" trailing="" raw_val="head?_eq_head" val="head?_eq_head" full_name="List.head?_eq_head" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(377, 22)" end="(377, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(377, 24)" end="(377, 40)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(377, 24)" end="(377, 40)" leading="" trailing="" raw_val="head?_zipWithAll" val="head?_zipWithAll" full_name="List.head?_zipWithAll" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(369, 9)" def_end="(369, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(377, 40)" end="(377, 41)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(378, 3)" end="(378, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case x&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;h : zipWithAll f as bs ≠ []&#10;⊢ (match as.head?, bs.head? with&#10;    | none, none =&amp;gt; none&#10;    | a?, b? =&amp;gt; some (f a? b?)) =&#10;    some (f as.head? bs.head?)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(378, 3)" end="(378, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(378, 3)" end="(378, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(378, 9)" end="(378, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(378, 13)" end="(378, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(378, 13)" end="(378, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(380, 1)" end="(382, 33)" name="tail_zipWithAll" full_name="List.tail_zipWithAll">
      <CommandDeclmodifiersNode start="(380, 1)" end="(380, 8)">
        <NullNode/>
        <NullNode start="(380, 1)" end="(380, 8)">
          <OtherNode start="(380, 1)" end="(380, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(380, 1)" end="(380, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(380, 3)" end="(380, 7)">
              <OtherNode start="(380, 3)" end="(380, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(380, 3)" end="(380, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(380, 3)" end="(380, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(380, 7)" end="(380, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(380, 9)" end="(382, 33)" name="tail_zipWithAll" full_name="List.tail_zipWithAll" _is_private_decl="False">
        <AtomNode start="(380, 9)" end="(380, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(380, 17)" end="(380, 32)">
          <IdentNode start="(380, 17)" end="(380, 32)" leading="" trailing=" " raw_val="tail_zipWithAll" val="tail_zipWithAll"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(380, 33)" end="(381, 61)">
          <NullNode start="(380, 33)" end="(380, 62)">
            <OtherNode start="(380, 33)" end="(380, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(380, 33)" end="(380, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(380, 34)" end="(380, 35)">
                <IdentNode start="(380, 34)" end="(380, 35)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(380, 36)" end="(380, 61)">
                <AtomNode start="(380, 36)" end="(380, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(380, 38)" end="(380, 61)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(380, 38)" end="(380, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(380, 38)" end="(380, 44)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(380, 45)" end="(380, 46)">
                      <IdentNode start="(380, 45)" end="(380, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(380, 47)" end="(380, 48)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(380, 49)" end="(380, 61)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(380, 49)" end="(380, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(380, 49)" end="(380, 55)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(380, 56)" end="(380, 57)">
                        <IdentNode start="(380, 56)" end="(380, 57)" leading="" trailing=" " raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(380, 58)" end="(380, 59)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(380, 60)" end="(380, 61)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(380, 61)" end="(380, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(380, 63)" end="(381, 61)">
            <AtomNode start="(380, 63)" end="(380, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(381, 5)" end="(381, 61)" kind="«term_=_»">
              <OtherNode start="(381, 5)" end="(381, 30)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(381, 5)" end="(381, 25)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(381, 5)" end="(381, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(381, 6)" end="(381, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(381, 6)" end="(381, 16)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(381, 17)" end="(381, 24)">
                      <IdentNode start="(381, 17)" end="(381, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(381, 19)" end="(381, 21)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(381, 22)" end="(381, 24)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(381, 24)" end="(381, 25)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(381, 25)" end="(381, 26)" leading="" trailing="" val="."/>
                <IdentNode start="(381, 26)" end="(381, 30)" leading="" trailing=" " raw_val="tail" val="tail" full_name="List.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(381, 31)" end="(381, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(381, 33)" end="(381, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(381, 33)" end="(381, 43)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(381, 44)" end="(381, 61)">
                  <IdentNode start="(381, 44)" end="(381, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(381, 46)" end="(381, 53)" leading="" trailing=" " raw_val="as.tail" val="as.tail"/>
                  <IdentNode start="(381, 54)" end="(381, 61)" leading="" trailing=" " raw_val="bs.tail" val="bs.tail"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(381, 62)" end="(382, 33)">
          <AtomNode start="(381, 62)" end="(381, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(381, 65)" end="(382, 33)">
            <AtomNode start="(381, 65)" end="(381, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(382, 3)" end="(382, 33)">
              <TacticTacticseq1IndentedNode start="(382, 3)" end="(382, 33)">
                <NullNode start="(382, 3)" end="(382, 33)">
                  <OtherNode start="(382, 3)" end="(382, 33)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;⊢ (zipWithAll f as bs).tail = zipWithAll f as.tail bs.tail" state_after="no goals" tactic="cases as &amp;lt;;&amp;gt; cases bs &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(382, 3)" end="(382, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(382, 3)" end="(382, 11)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(382, 3)" end="(382, 8)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(382, 9)" end="(382, 11)">
                          <OtherNode start="(382, 9)" end="(382, 11)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(382, 9)" end="(382, 11)" leading="" trailing=" " raw_val="as" val="as"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(382, 12)" end="(382, 15)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(382, 16)" end="(382, 24)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(382, 16)" end="(382, 21)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(382, 22)" end="(382, 24)">
                          <OtherNode start="(382, 22)" end="(382, 24)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(382, 22)" end="(382, 24)" leading="" trailing=" " raw_val="bs" val="bs"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(382, 25)" end="(382, 28)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(382, 29)" end="(382, 33)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(382, 29)" end="(382, 33)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(384, 1)" end="(386, 57)" name="zipWithAll_map" full_name="List.zipWithAll_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(384, 1)" end="(386, 57)" name="zipWithAll_map" full_name="List.zipWithAll_map" _is_private_decl="False">
        <AtomNode start="(384, 1)" end="(384, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(384, 9)" end="(384, 23)">
          <IdentNode start="(384, 9)" end="(384, 23)" leading="" trailing=" " raw_val="zipWithAll_map" val="zipWithAll_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(384, 24)" end="(385, 93)">
          <NullNode start="(384, 24)" end="(384, 109)">
            <OtherNode start="(384, 24)" end="(384, 27)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 24)" end="(384, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 25)" end="(384, 26)">
                <IdentNode start="(384, 25)" end="(384, 26)" leading="" trailing="" raw_val="μ" val="μ"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(384, 26)" end="(384, 27)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(384, 28)" end="(384, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 28)" end="(384, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 29)" end="(384, 30)">
                <IdentNode start="(384, 29)" end="(384, 30)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(384, 31)" end="(384, 56)">
                <AtomNode start="(384, 31)" end="(384, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(384, 33)" end="(384, 56)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(384, 33)" end="(384, 41)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(384, 33)" end="(384, 39)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(384, 40)" end="(384, 41)">
                      <IdentNode start="(384, 40)" end="(384, 41)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(384, 42)" end="(384, 43)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(384, 44)" end="(384, 56)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(384, 44)" end="(384, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(384, 44)" end="(384, 50)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(384, 51)" end="(384, 52)">
                        <IdentNode start="(384, 51)" end="(384, 52)" leading="" trailing=" " raw_val="δ" val="δ"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(384, 53)" end="(384, 54)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(384, 55)" end="(384, 56)" leading="" trailing="" raw_val="μ" val="μ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(384, 56)" end="(384, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(384, 58)" end="(384, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 58)" end="(384, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 59)" end="(384, 60)">
                <IdentNode start="(384, 59)" end="(384, 60)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(384, 61)" end="(384, 68)">
                <AtomNode start="(384, 61)" end="(384, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(384, 63)" end="(384, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(384, 63)" end="(384, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(384, 65)" end="(384, 66)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(384, 67)" end="(384, 68)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(384, 68)" end="(384, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(384, 70)" end="(384, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 70)" end="(384, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 71)" end="(384, 72)">
                <IdentNode start="(384, 71)" end="(384, 72)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(384, 73)" end="(384, 80)">
                <AtomNode start="(384, 73)" end="(384, 74)" leading="" trailing=" " val=":"/>
                <OtherNode start="(384, 75)" end="(384, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(384, 75)" end="(384, 76)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(384, 77)" end="(384, 78)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(384, 79)" end="(384, 80)" leading="" trailing="" raw_val="δ" val="δ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(384, 80)" end="(384, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(384, 82)" end="(384, 95)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 82)" end="(384, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 83)" end="(384, 85)">
                <IdentNode start="(384, 83)" end="(384, 85)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(384, 86)" end="(384, 94)">
                <AtomNode start="(384, 86)" end="(384, 87)" leading="" trailing=" " val=":"/>
                <OtherNode start="(384, 88)" end="(384, 94)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(384, 88)" end="(384, 92)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(384, 93)" end="(384, 94)">
                    <IdentNode start="(384, 93)" end="(384, 94)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(384, 94)" end="(384, 95)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(384, 96)" end="(384, 109)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 96)" end="(384, 97)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 97)" end="(384, 99)">
                <IdentNode start="(384, 97)" end="(384, 99)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(384, 100)" end="(384, 108)">
                <AtomNode start="(384, 100)" end="(384, 101)" leading="" trailing=" " val=":"/>
                <OtherNode start="(384, 102)" end="(384, 108)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(384, 102)" end="(384, 106)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(384, 107)" end="(384, 108)">
                    <IdentNode start="(384, 107)" end="(384, 108)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(384, 108)" end="(384, 109)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(384, 110)" end="(385, 93)">
            <AtomNode start="(384, 110)" end="(384, 111)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(385, 5)" end="(385, 93)" kind="«term_=_»">
              <OtherNode start="(385, 5)" end="(385, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(385, 5)" end="(385, 15)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(385, 16)" end="(385, 39)">
                  <IdentNode start="(385, 16)" end="(385, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(385, 18)" end="(385, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(385, 18)" end="(385, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(385, 19)" end="(385, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(385, 19)" end="(385, 25)" leading="" trailing=" " raw_val="l₁.map" val="l₁.map"/>
                      <NullNode start="(385, 26)" end="(385, 27)">
                        <IdentNode start="(385, 26)" end="(385, 27)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(385, 27)" end="(385, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(385, 29)" end="(385, 39)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(385, 29)" end="(385, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(385, 30)" end="(385, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(385, 30)" end="(385, 36)" leading="" trailing=" " raw_val="l₂.map" val="l₂.map"/>
                      <NullNode start="(385, 37)" end="(385, 38)">
                        <IdentNode start="(385, 37)" end="(385, 38)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(385, 38)" end="(385, 39)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(385, 40)" end="(385, 41)" leading="" trailing=" " val="="/>
              <OtherNode start="(385, 42)" end="(385, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(385, 42)" end="(385, 52)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(385, 53)" end="(385, 93)">
                  <OtherNode start="(385, 53)" end="(385, 87)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(385, 53)" end="(385, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(385, 54)" end="(385, 86)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(385, 54)" end="(385, 57)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(385, 58)" end="(385, 86)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(385, 58)" end="(385, 61)">
                          <IdentNode start="(385, 58)" end="(385, 59)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(385, 60)" end="(385, 61)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(385, 62)" end="(385, 64)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(385, 65)" end="(385, 86)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(385, 65)" end="(385, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(385, 67)" end="(385, 86)">
                            <OtherNode start="(385, 67)" end="(385, 76)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(385, 67)" end="(385, 68)" leading="" trailing="" val="("/>
                              <OtherNode start="(385, 68)" end="(385, 75)" kind="«term_&amp;lt;$&amp;gt;_»">
                                <IdentNode start="(385, 68)" end="(385, 69)" leading="" trailing=" " raw_val="g" val="g"/>
                                <AtomNode start="(385, 70)" end="(385, 73)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                                <IdentNode start="(385, 74)" end="(385, 75)" leading="" trailing="" raw_val="a" val="a"/>
                              </OtherNode>
                              <AtomNode start="(385, 75)" end="(385, 76)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(385, 77)" end="(385, 86)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(385, 77)" end="(385, 78)" leading="" trailing="" val="("/>
                              <OtherNode start="(385, 78)" end="(385, 85)" kind="«term_&amp;lt;$&amp;gt;_»">
                                <IdentNode start="(385, 78)" end="(385, 79)" leading="" trailing=" " raw_val="h" val="h"/>
                                <AtomNode start="(385, 80)" end="(385, 83)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                                <IdentNode start="(385, 84)" end="(385, 85)" leading="" trailing="" raw_val="b" val="b"/>
                              </OtherNode>
                              <AtomNode start="(385, 85)" end="(385, 86)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(385, 86)" end="(385, 87)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(385, 88)" end="(385, 90)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(385, 91)" end="(385, 93)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(385, 94)" end="(386, 57)">
          <AtomNode start="(385, 94)" end="(385, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(385, 97)" end="(386, 57)">
            <AtomNode start="(385, 97)" end="(385, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(386, 3)" end="(386, 57)">
              <TacticTacticseq1IndentedNode start="(386, 3)" end="(386, 57)">
                <NullNode start="(386, 3)" end="(386, 57)">
                  <OtherNode start="(386, 3)" end="(386, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="γ : Type u_1&#10;δ : Type u_2&#10;α : Type u_1&#10;β : Type u_2&#10;μ : Type u_3&#10;f : Option γ → Option δ → μ&#10;g : α → γ&#10;h : β → δ&#10;l₁ : List α&#10;l₂ : List β&#10;⊢ zipWithAll f (map g l₁) (map h l₂) = zipWithAll (fun a b =&amp;gt; f (g &amp;lt;$&amp;gt; a) (h &amp;lt;$&amp;gt; b)) l₁ l₂" state_after="no goals" tactic="induction l₁ generalizing l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(386, 3)" end="(386, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(386, 3)" end="(386, 31)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(386, 3)" end="(386, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(386, 13)" end="(386, 15)">
                          <OtherNode start="(386, 13)" end="(386, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(386, 13)" end="(386, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(386, 16)" end="(386, 31)">
                          <AtomNode start="(386, 16)" end="(386, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(386, 29)" end="(386, 31)">
                            <IdentNode start="(386, 29)" end="(386, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(386, 32)" end="(386, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(386, 36)" end="(386, 44)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(386, 36)" end="(386, 41)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(386, 42)" end="(386, 44)">
                          <OtherNode start="(386, 42)" end="(386, 44)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(386, 42)" end="(386, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(386, 45)" end="(386, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(386, 49)" end="(386, 57)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(386, 49)" end="(386, 57)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(388, 1)" end="(390, 57)" name="zipWithAll_map_left" full_name="List.zipWithAll_map_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(388, 1)" end="(390, 57)" name="zipWithAll_map_left" full_name="List.zipWithAll_map_left" _is_private_decl="False">
        <AtomNode start="(388, 1)" end="(388, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(388, 9)" end="(388, 28)">
          <IdentNode start="(388, 9)" end="(388, 28)" leading="" trailing=" " raw_val="zipWithAll_map_left" val="zipWithAll_map_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(388, 29)" end="(389, 77)">
          <NullNode start="(388, 29)" end="(388, 100)">
            <OtherNode start="(388, 29)" end="(388, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(388, 29)" end="(388, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(388, 30)" end="(388, 32)">
                <IdentNode start="(388, 30)" end="(388, 32)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(388, 33)" end="(388, 41)">
                <AtomNode start="(388, 33)" end="(388, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 35)" end="(388, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(388, 35)" end="(388, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(388, 40)" end="(388, 41)">
                    <IdentNode start="(388, 40)" end="(388, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(388, 41)" end="(388, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(388, 43)" end="(388, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(388, 43)" end="(388, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(388, 44)" end="(388, 46)">
                <IdentNode start="(388, 44)" end="(388, 46)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(388, 47)" end="(388, 55)">
                <AtomNode start="(388, 47)" end="(388, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 49)" end="(388, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(388, 49)" end="(388, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(388, 54)" end="(388, 55)">
                    <IdentNode start="(388, 54)" end="(388, 55)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(388, 55)" end="(388, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(388, 57)" end="(388, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(388, 57)" end="(388, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(388, 58)" end="(388, 59)">
                <IdentNode start="(388, 58)" end="(388, 59)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(388, 60)" end="(388, 68)">
                <AtomNode start="(388, 60)" end="(388, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 62)" end="(388, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(388, 62)" end="(388, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(388, 64)" end="(388, 65)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(388, 66)" end="(388, 68)" leading="" trailing="" raw_val="α'" val="α'"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(388, 68)" end="(388, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(388, 70)" end="(388, 100)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(388, 70)" end="(388, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(388, 71)" end="(388, 72)">
                <IdentNode start="(388, 71)" end="(388, 72)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(388, 73)" end="(388, 99)">
                <AtomNode start="(388, 73)" end="(388, 74)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 75)" end="(388, 99)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(388, 75)" end="(388, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(388, 75)" end="(388, 81)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(388, 82)" end="(388, 84)">
                      <IdentNode start="(388, 82)" end="(388, 84)" leading="" trailing=" " raw_val="α'" val="α'"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(388, 85)" end="(388, 86)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(388, 87)" end="(388, 99)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(388, 87)" end="(388, 95)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(388, 87)" end="(388, 93)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(388, 94)" end="(388, 95)">
                        <IdentNode start="(388, 94)" end="(388, 95)" leading="" trailing=" " raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(388, 96)" end="(388, 97)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(388, 98)" end="(388, 99)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(388, 99)" end="(388, 100)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(388, 101)" end="(389, 77)">
            <AtomNode start="(388, 101)" end="(388, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(389, 5)" end="(389, 77)" kind="«term_=_»">
              <OtherNode start="(389, 5)" end="(389, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(389, 5)" end="(389, 15)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(389, 16)" end="(389, 31)">
                  <IdentNode start="(389, 16)" end="(389, 17)" leading="" trailing=" " raw_val="g" val="g"/>
                  <OtherNode start="(389, 18)" end="(389, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(389, 18)" end="(389, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(389, 19)" end="(389, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(389, 19)" end="(389, 25)" leading="" trailing=" " raw_val="l₁.map" val="l₁.map"/>
                      <NullNode start="(389, 26)" end="(389, 27)">
                        <IdentNode start="(389, 26)" end="(389, 27)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(389, 27)" end="(389, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(389, 29)" end="(389, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(389, 32)" end="(389, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(389, 34)" end="(389, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(389, 34)" end="(389, 44)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(389, 45)" end="(389, 77)">
                  <OtherNode start="(389, 45)" end="(389, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(389, 45)" end="(389, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(389, 46)" end="(389, 70)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(389, 46)" end="(389, 49)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(389, 50)" end="(389, 70)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(389, 50)" end="(389, 53)">
                          <IdentNode start="(389, 50)" end="(389, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(389, 52)" end="(389, 53)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(389, 54)" end="(389, 56)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(389, 57)" end="(389, 70)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(389, 57)" end="(389, 58)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(389, 59)" end="(389, 70)">
                            <OtherNode start="(389, 59)" end="(389, 68)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(389, 59)" end="(389, 60)" leading="" trailing="" val="("/>
                              <OtherNode start="(389, 60)" end="(389, 67)" kind="«term_&amp;lt;$&amp;gt;_»">
                                <IdentNode start="(389, 60)" end="(389, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                                <AtomNode start="(389, 62)" end="(389, 65)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                                <IdentNode start="(389, 66)" end="(389, 67)" leading="" trailing="" raw_val="a" val="a"/>
                              </OtherNode>
                              <AtomNode start="(389, 67)" end="(389, 68)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(389, 69)" end="(389, 70)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(389, 70)" end="(389, 71)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(389, 72)" end="(389, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(389, 75)" end="(389, 77)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(389, 78)" end="(390, 57)">
          <AtomNode start="(389, 78)" end="(389, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(389, 81)" end="(390, 57)">
            <AtomNode start="(389, 81)" end="(389, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(390, 3)" end="(390, 57)">
              <TacticTacticseq1IndentedNode start="(390, 3)" end="(390, 57)">
                <NullNode start="(390, 3)" end="(390, 57)">
                  <OtherNode start="(390, 3)" end="(390, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;α' : Type u_1&#10;γ : Type u_3&#10;l₁ : List α&#10;l₂ : List β&#10;f : α → α'&#10;g : Option α' → Option β → γ&#10;⊢ zipWithAll g (map f l₁) l₂ = zipWithAll (fun a b =&amp;gt; g (f &amp;lt;$&amp;gt; a) b) l₁ l₂" state_after="no goals" tactic="induction l₁ generalizing l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(390, 3)" end="(390, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(390, 3)" end="(390, 31)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(390, 3)" end="(390, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(390, 13)" end="(390, 15)">
                          <OtherNode start="(390, 13)" end="(390, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(390, 13)" end="(390, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(390, 16)" end="(390, 31)">
                          <AtomNode start="(390, 16)" end="(390, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(390, 29)" end="(390, 31)">
                            <IdentNode start="(390, 29)" end="(390, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(390, 32)" end="(390, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(390, 36)" end="(390, 44)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(390, 36)" end="(390, 41)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(390, 42)" end="(390, 44)">
                          <OtherNode start="(390, 42)" end="(390, 44)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(390, 42)" end="(390, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(390, 45)" end="(390, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(390, 49)" end="(390, 57)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(390, 49)" end="(390, 57)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(392, 1)" end="(394, 57)" name="zipWithAll_map_right" full_name="List.zipWithAll_map_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(392, 1)" end="(394, 57)" name="zipWithAll_map_right" full_name="List.zipWithAll_map_right" _is_private_decl="False">
        <AtomNode start="(392, 1)" end="(392, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(392, 9)" end="(392, 29)">
          <IdentNode start="(392, 9)" end="(392, 29)" leading="" trailing=" " raw_val="zipWithAll_map_right" val="zipWithAll_map_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(392, 30)" end="(393, 77)">
          <NullNode start="(392, 30)" end="(392, 101)">
            <OtherNode start="(392, 30)" end="(392, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(392, 30)" end="(392, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(392, 31)" end="(392, 33)">
                <IdentNode start="(392, 31)" end="(392, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(392, 34)" end="(392, 42)">
                <AtomNode start="(392, 34)" end="(392, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(392, 36)" end="(392, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(392, 36)" end="(392, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(392, 41)" end="(392, 42)">
                    <IdentNode start="(392, 41)" end="(392, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(392, 42)" end="(392, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(392, 44)" end="(392, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(392, 44)" end="(392, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(392, 45)" end="(392, 47)">
                <IdentNode start="(392, 45)" end="(392, 47)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(392, 48)" end="(392, 56)">
                <AtomNode start="(392, 48)" end="(392, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(392, 50)" end="(392, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(392, 50)" end="(392, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(392, 55)" end="(392, 56)">
                    <IdentNode start="(392, 55)" end="(392, 56)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(392, 56)" end="(392, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(392, 58)" end="(392, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(392, 58)" end="(392, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(392, 59)" end="(392, 60)">
                <IdentNode start="(392, 59)" end="(392, 60)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(392, 61)" end="(392, 69)">
                <AtomNode start="(392, 61)" end="(392, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(392, 63)" end="(392, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(392, 63)" end="(392, 64)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(392, 65)" end="(392, 66)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(392, 67)" end="(392, 69)" leading="" trailing="" raw_val="β'" val="β'"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(392, 69)" end="(392, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(392, 71)" end="(392, 101)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(392, 71)" end="(392, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(392, 72)" end="(392, 73)">
                <IdentNode start="(392, 72)" end="(392, 73)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(392, 74)" end="(392, 100)">
                <AtomNode start="(392, 74)" end="(392, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(392, 76)" end="(392, 100)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(392, 76)" end="(392, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(392, 76)" end="(392, 82)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(392, 83)" end="(392, 84)">
                      <IdentNode start="(392, 83)" end="(392, 84)" leading="" trailing=" " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(392, 85)" end="(392, 86)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(392, 87)" end="(392, 100)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(392, 87)" end="(392, 96)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(392, 87)" end="(392, 93)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(392, 94)" end="(392, 96)">
                        <IdentNode start="(392, 94)" end="(392, 96)" leading="" trailing=" " raw_val="β'" val="β'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(392, 97)" end="(392, 98)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(392, 99)" end="(392, 100)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(392, 100)" end="(392, 101)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(392, 102)" end="(393, 77)">
            <AtomNode start="(392, 102)" end="(392, 103)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(393, 5)" end="(393, 77)" kind="«term_=_»">
              <OtherNode start="(393, 5)" end="(393, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(393, 5)" end="(393, 15)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(393, 16)" end="(393, 31)">
                  <IdentNode start="(393, 16)" end="(393, 17)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(393, 18)" end="(393, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <OtherNode start="(393, 21)" end="(393, 31)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(393, 21)" end="(393, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(393, 22)" end="(393, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(393, 22)" end="(393, 28)" leading="" trailing=" " raw_val="l₂.map" val="l₂.map"/>
                      <NullNode start="(393, 29)" end="(393, 30)">
                        <IdentNode start="(393, 29)" end="(393, 30)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(393, 30)" end="(393, 31)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(393, 32)" end="(393, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(393, 34)" end="(393, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(393, 34)" end="(393, 44)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(393, 45)" end="(393, 77)">
                  <OtherNode start="(393, 45)" end="(393, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(393, 45)" end="(393, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(393, 46)" end="(393, 70)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(393, 46)" end="(393, 49)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(393, 50)" end="(393, 70)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(393, 50)" end="(393, 53)">
                          <IdentNode start="(393, 50)" end="(393, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(393, 52)" end="(393, 53)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(393, 54)" end="(393, 56)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(393, 57)" end="(393, 70)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(393, 57)" end="(393, 58)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(393, 59)" end="(393, 70)">
                            <IdentNode start="(393, 59)" end="(393, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(393, 61)" end="(393, 70)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(393, 61)" end="(393, 62)" leading="" trailing="" val="("/>
                              <OtherNode start="(393, 62)" end="(393, 69)" kind="«term_&amp;lt;$&amp;gt;_»">
                                <IdentNode start="(393, 62)" end="(393, 63)" leading="" trailing=" " raw_val="f" val="f"/>
                                <AtomNode start="(393, 64)" end="(393, 67)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                                <IdentNode start="(393, 68)" end="(393, 69)" leading="" trailing="" raw_val="b" val="b"/>
                              </OtherNode>
                              <AtomNode start="(393, 69)" end="(393, 70)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(393, 70)" end="(393, 71)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(393, 72)" end="(393, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(393, 75)" end="(393, 77)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(393, 78)" end="(394, 57)">
          <AtomNode start="(393, 78)" end="(393, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(393, 81)" end="(394, 57)">
            <AtomNode start="(393, 81)" end="(393, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(394, 3)" end="(394, 57)">
              <TacticTacticseq1IndentedNode start="(394, 3)" end="(394, 57)">
                <NullNode start="(394, 3)" end="(394, 57)">
                  <OtherNode start="(394, 3)" end="(394, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β β' : Type u_2&#10;γ : Type u_3&#10;l₁ : List α&#10;l₂ : List β&#10;f : β → β'&#10;g : Option α → Option β' → γ&#10;⊢ zipWithAll g l₁ (map f l₂) = zipWithAll (fun a b =&amp;gt; g a (f &amp;lt;$&amp;gt; b)) l₁ l₂" state_after="no goals" tactic="induction l₁ generalizing l₂ &amp;lt;;&amp;gt; cases l₂ &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(394, 3)" end="(394, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(394, 3)" end="(394, 31)" kind="Lean.Parser.Tactic.induction">
                        <AtomNode start="(394, 3)" end="(394, 12)" leading="" trailing=" " val="induction"/>
                        <NullNode start="(394, 13)" end="(394, 15)">
                          <OtherNode start="(394, 13)" end="(394, 15)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(394, 13)" end="(394, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode start="(394, 16)" end="(394, 31)">
                          <AtomNode start="(394, 16)" end="(394, 28)" leading="" trailing=" " val="generalizing"/>
                          <NullNode start="(394, 29)" end="(394, 31)">
                            <IdentNode start="(394, 29)" end="(394, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(394, 32)" end="(394, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(394, 36)" end="(394, 44)" kind="Lean.Parser.Tactic.cases">
                        <AtomNode start="(394, 36)" end="(394, 41)" leading="" trailing=" " val="cases"/>
                        <NullNode start="(394, 42)" end="(394, 44)">
                          <OtherNode start="(394, 42)" end="(394, 44)" kind="Lean.Parser.Tactic.elimTarget">
                            <NullNode/>
                            <IdentNode start="(394, 42)" end="(394, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(394, 45)" end="(394, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(394, 49)" end="(394, 57)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(394, 49)" end="(394, 57)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(396, 1)" end="(401, 26)" name="map_zipWithAll" full_name="List.map_zipWithAll">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(396, 1)" end="(401, 26)" name="map_zipWithAll" full_name="List.map_zipWithAll" _is_private_decl="False">
        <AtomNode start="(396, 1)" end="(396, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(396, 9)" end="(396, 23)">
          <IdentNode start="(396, 9)" end="(396, 23)" leading="" trailing=" " raw_val="map_zipWithAll" val="map_zipWithAll"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(396, 24)" end="(397, 71)">
          <NullNode start="(396, 24)" end="(396, 105)">
            <OtherNode start="(396, 24)" end="(396, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(396, 24)" end="(396, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(396, 25)" end="(396, 26)">
                <IdentNode start="(396, 25)" end="(396, 26)" leading="" trailing=" " raw_val="δ" val="δ"/>
              </NullNode>
              <NullNode start="(396, 27)" end="(396, 35)">
                <AtomNode start="(396, 27)" end="(396, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(396, 29)" end="(396, 35)" kind="Lean.Parser.Term.type">
                  <AtomNode start="(396, 29)" end="(396, 33)" leading="" trailing=" " val="Type"/>
                  <NullNode start="(396, 34)" end="(396, 35)">
                    <OtherNode start="(396, 34)" end="(396, 35)" kind="Lean.Parser.Level.hole">
                      <AtomNode start="(396, 34)" end="(396, 35)" leading="" trailing="" val="_"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(396, 35)" end="(396, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(396, 37)" end="(396, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(396, 37)" end="(396, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(396, 38)" end="(396, 39)">
                <IdentNode start="(396, 38)" end="(396, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(396, 40)" end="(396, 47)">
                <AtomNode start="(396, 40)" end="(396, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(396, 42)" end="(396, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(396, 42)" end="(396, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(396, 44)" end="(396, 45)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(396, 46)" end="(396, 47)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(396, 47)" end="(396, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(396, 49)" end="(396, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(396, 49)" end="(396, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(396, 50)" end="(396, 51)">
                <IdentNode start="(396, 50)" end="(396, 51)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(396, 52)" end="(396, 77)">
                <AtomNode start="(396, 52)" end="(396, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(396, 54)" end="(396, 77)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(396, 54)" end="(396, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(396, 54)" end="(396, 60)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(396, 61)" end="(396, 62)">
                      <IdentNode start="(396, 61)" end="(396, 62)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(396, 63)" end="(396, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(396, 65)" end="(396, 77)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(396, 65)" end="(396, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(396, 65)" end="(396, 71)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(396, 72)" end="(396, 73)">
                        <IdentNode start="(396, 72)" end="(396, 73)" leading="" trailing=" " raw_val="δ" val="δ"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(396, 74)" end="(396, 75)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(396, 76)" end="(396, 77)" leading="" trailing="" raw_val="α" val="α"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(396, 77)" end="(396, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(396, 79)" end="(396, 91)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(396, 79)" end="(396, 80)" leading="" trailing="" val="{"/>
              <NullNode start="(396, 80)" end="(396, 81)">
                <IdentNode start="(396, 80)" end="(396, 81)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(396, 82)" end="(396, 90)">
                <AtomNode start="(396, 82)" end="(396, 83)" leading="" trailing=" " val=":"/>
                <OtherNode start="(396, 84)" end="(396, 90)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(396, 84)" end="(396, 88)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(396, 89)" end="(396, 90)">
                    <IdentNode start="(396, 89)" end="(396, 90)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(396, 90)" end="(396, 91)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(396, 92)" end="(396, 105)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(396, 92)" end="(396, 93)" leading="" trailing="" val="{"/>
              <NullNode start="(396, 93)" end="(396, 95)">
                <IdentNode start="(396, 93)" end="(396, 95)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(396, 96)" end="(396, 104)">
                <AtomNode start="(396, 96)" end="(396, 97)" leading="" trailing=" " val=":"/>
                <OtherNode start="(396, 98)" end="(396, 104)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(396, 98)" end="(396, 102)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(396, 103)" end="(396, 104)">
                    <IdentNode start="(396, 103)" end="(396, 104)" leading="" trailing="" raw_val="δ" val="δ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(396, 104)" end="(396, 105)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(396, 106)" end="(397, 71)">
            <AtomNode start="(396, 106)" end="(396, 107)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(397, 5)" end="(397, 71)" kind="«term_=_»">
              <OtherNode start="(397, 5)" end="(397, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(397, 5)" end="(397, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(397, 9)" end="(397, 30)">
                  <IdentNode start="(397, 9)" end="(397, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(397, 11)" end="(397, 30)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(397, 11)" end="(397, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(397, 12)" end="(397, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(397, 12)" end="(397, 22)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(397, 23)" end="(397, 29)">
                        <IdentNode start="(397, 23)" end="(397, 24)" leading="" trailing=" " raw_val="g" val="g"/>
                        <IdentNode start="(397, 25)" end="(397, 26)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(397, 27)" end="(397, 29)" leading="" trailing="" raw_val="l'" val="l'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(397, 29)" end="(397, 30)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(397, 31)" end="(397, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(397, 33)" end="(397, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(397, 33)" end="(397, 43)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(397, 44)" end="(397, 71)">
                  <OtherNode start="(397, 44)" end="(397, 66)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(397, 44)" end="(397, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(397, 45)" end="(397, 65)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(397, 45)" end="(397, 48)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(397, 49)" end="(397, 65)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(397, 49)" end="(397, 52)">
                          <IdentNode start="(397, 49)" end="(397, 50)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(397, 51)" end="(397, 52)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(397, 53)" end="(397, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(397, 56)" end="(397, 65)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(397, 56)" end="(397, 57)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(397, 58)" end="(397, 65)">
                            <OtherNode start="(397, 58)" end="(397, 65)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(397, 58)" end="(397, 59)" leading="" trailing="" val="("/>
                              <OtherNode start="(397, 59)" end="(397, 64)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(397, 59)" end="(397, 60)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(397, 61)" end="(397, 64)">
                                  <IdentNode start="(397, 61)" end="(397, 62)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(397, 63)" end="(397, 64)" leading="" trailing="" raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(397, 64)" end="(397, 65)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(397, 65)" end="(397, 66)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(397, 67)" end="(397, 68)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(397, 69)" end="(397, 71)" leading="" trailing=" " raw_val="l'" val="l'"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(397, 72)" end="(401, 26)">
          <AtomNode start="(397, 72)" end="(397, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(397, 75)" end="(401, 26)">
            <AtomNode start="(397, 75)" end="(397, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(398, 3)" end="(401, 26)">
              <TacticTacticseq1IndentedNode start="(398, 3)" end="(401, 26)">
                <NullNode start="(398, 3)" end="(401, 26)">
                  <OtherNode start="(398, 3)" end="(401, 26)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : Option γ → Option δ → α&#10;l : List γ&#10;l' : List δ&#10;⊢ map f (zipWithAll g l l') = zipWithAll (fun x y =&amp;gt; f (g x y)) l l'" state_after="no goals" tactic="induction l generalizing l' with&#10;| nil =&amp;gt; simp&#10;| cons hd tl hl =&amp;gt;&#10;  cases l' &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(398, 3)" end="(398, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(398, 13)" end="(398, 14)">
                      <OtherNode start="(398, 13)" end="(398, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(398, 13)" end="(398, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(398, 15)" end="(398, 30)">
                      <AtomNode start="(398, 15)" end="(398, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(398, 28)" end="(398, 30)">
                        <IdentNode start="(398, 28)" end="(398, 30)" leading="" trailing=" " raw_val="l'" val="l'"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(398, 31)" end="(401, 26)">
                      <OtherNode start="(398, 31)" end="(401, 26)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(398, 31)" end="(398, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(399, 3)" end="(401, 26)">
                          <OtherNode start="(399, 3)" end="(399, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(399, 3)" end="(399, 8)">
                              <OtherNode start="(399, 3)" end="(399, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(399, 3)" end="(399, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(399, 5)" end="(399, 8)">
                                  <NullNode/>
                                  <IdentNode start="(399, 5)" end="(399, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(399, 9)" end="(399, 16)">
                              <AtomNode start="(399, 9)" end="(399, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(399, 12)" end="(399, 16)">
                                <TacticTacticseq1IndentedNode start="(399, 12)" end="(399, 16)">
                                  <NullNode start="(399, 12)" end="(399, 16)">
                                    <OtherNode start="(399, 12)" end="(399, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : Option γ → Option δ → α&#10;l' : List δ&#10;⊢ map f (zipWithAll g [] l') = zipWithAll (fun x y =&amp;gt; f (g x y)) [] l'" state_after="no goals" tactic="simp">
                                      <AtomNode start="(399, 12)" end="(399, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(400, 3)" end="(401, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(400, 3)" end="(400, 18)">
                              <OtherNode start="(400, 3)" end="(400, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(400, 3)" end="(400, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(400, 5)" end="(400, 9)">
                                  <NullNode/>
                                  <IdentNode start="(400, 5)" end="(400, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(400, 10)" end="(400, 18)">
                                  <IdentNode start="(400, 10)" end="(400, 12)" leading="" trailing=" " raw_val="hd" val="hd"/>
                                  <IdentNode start="(400, 13)" end="(400, 15)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                  <IdentNode start="(400, 16)" end="(400, 18)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(400, 19)" end="(401, 26)">
                              <AtomNode start="(400, 19)" end="(400, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(401, 5)" end="(401, 26)">
                                <TacticTacticseq1IndentedNode start="(401, 5)" end="(401, 26)">
                                  <NullNode start="(401, 5)" end="(401, 26)">
                                    <OtherNode start="(401, 5)" end="(401, 26)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : Option γ → Option δ → α&#10;hd : γ&#10;tl : List γ&#10;hl : ∀ {l' : List δ}, map f (zipWithAll g tl l') = zipWithAll (fun x y =&amp;gt; f (g x y)) tl l'&#10;l' : List δ&#10;⊢ map f (zipWithAll g (hd :: tl) l') = zipWithAll (fun x y =&amp;gt; f (g x y)) (hd :: tl) l'" state_after="no goals" tactic="cases l' &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(401, 5)" end="(401, 13)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(401, 5)" end="(401, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(401, 11)" end="(401, 13)">
                                          <OtherNode start="(401, 11)" end="(401, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(401, 11)" end="(401, 13)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(401, 14)" end="(401, 17)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(401, 18)" end="(401, 26)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(401, 18)" end="(401, 26)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(403, 1)" end="(407, 43)" name="zipWithAll_replicate" full_name="List.zipWithAll_replicate">
      <CommandDeclmodifiersNode start="(403, 1)" end="(403, 8)">
        <NullNode/>
        <NullNode start="(403, 1)" end="(403, 8)">
          <OtherNode start="(403, 1)" end="(403, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(403, 1)" end="(403, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(403, 3)" end="(403, 7)">
              <OtherNode start="(403, 3)" end="(403, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(403, 3)" end="(403, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(403, 3)" end="(403, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(403, 7)" end="(403, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(403, 9)" end="(407, 43)" name="zipWithAll_replicate" full_name="List.zipWithAll_replicate" _is_private_decl="False">
        <AtomNode start="(403, 9)" end="(403, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(403, 17)" end="(403, 37)">
          <IdentNode start="(403, 17)" end="(403, 37)" leading="" trailing=" " raw_val="zipWithAll_replicate" val="zipWithAll_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(403, 38)" end="(404, 85)">
          <NullNode start="(403, 38)" end="(403, 63)">
            <OtherNode start="(403, 38)" end="(403, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(403, 38)" end="(403, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(403, 39)" end="(403, 40)">
                <IdentNode start="(403, 39)" end="(403, 40)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(403, 41)" end="(403, 44)">
                <AtomNode start="(403, 41)" end="(403, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(403, 43)" end="(403, 44)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(403, 44)" end="(403, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(403, 46)" end="(403, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(403, 46)" end="(403, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(403, 47)" end="(403, 48)">
                <IdentNode start="(403, 47)" end="(403, 48)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(403, 49)" end="(403, 52)">
                <AtomNode start="(403, 49)" end="(403, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(403, 51)" end="(403, 52)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(403, 52)" end="(403, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(403, 54)" end="(403, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(403, 54)" end="(403, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(403, 55)" end="(403, 56)">
                <IdentNode start="(403, 55)" end="(403, 56)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(403, 57)" end="(403, 62)">
                <AtomNode start="(403, 57)" end="(403, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(403, 59)" end="(403, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(403, 62)" end="(403, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(403, 64)" end="(404, 85)">
            <AtomNode start="(403, 64)" end="(403, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(404, 5)" end="(404, 85)" kind="«term_=_»">
              <OtherNode start="(404, 5)" end="(404, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(404, 5)" end="(404, 15)" leading="" trailing=" " raw_val="zipWithAll" val="zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(404, 16)" end="(404, 49)">
                  <IdentNode start="(404, 16)" end="(404, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(404, 18)" end="(404, 33)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(404, 18)" end="(404, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(404, 19)" end="(404, 32)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(404, 19)" end="(404, 28)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(404, 29)" end="(404, 32)">
                        <IdentNode start="(404, 29)" end="(404, 30)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(404, 31)" end="(404, 32)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(404, 32)" end="(404, 33)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(404, 34)" end="(404, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(404, 34)" end="(404, 35)" leading="" trailing="" val="("/>
                    <OtherNode start="(404, 35)" end="(404, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(404, 35)" end="(404, 44)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(404, 45)" end="(404, 48)">
                        <IdentNode start="(404, 45)" end="(404, 46)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(404, 47)" end="(404, 48)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(404, 48)" end="(404, 49)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(404, 50)" end="(404, 51)" leading="" trailing=" " val="="/>
              <OtherNode start="(404, 52)" end="(404, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(404, 52)" end="(404, 61)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(404, 62)" end="(404, 85)">
                  <IdentNode start="(404, 62)" end="(404, 63)" leading="" trailing=" " raw_val="n" val="n"/>
                  <OtherNode start="(404, 64)" end="(404, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(404, 64)" end="(404, 65)" leading="" trailing="" val="("/>
                    <OtherNode start="(404, 65)" end="(404, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(404, 65)" end="(404, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(404, 67)" end="(404, 84)">
                        <OtherNode start="(404, 67)" end="(404, 75)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(404, 67)" end="(404, 68)" leading="" trailing="" val="("/>
                          <OtherNode start="(404, 68)" end="(404, 74)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(404, 68)" end="(404, 72)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(404, 73)" end="(404, 74)">
                              <IdentNode start="(404, 73)" end="(404, 74)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(404, 74)" end="(404, 75)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(404, 76)" end="(404, 84)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(404, 76)" end="(404, 77)" leading="" trailing="" val="("/>
                          <OtherNode start="(404, 77)" end="(404, 83)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(404, 77)" end="(404, 81)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(404, 82)" end="(404, 83)">
                              <IdentNode start="(404, 82)" end="(404, 83)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(404, 83)" end="(404, 84)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(404, 84)" end="(404, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(404, 86)" end="(407, 43)">
          <AtomNode start="(404, 86)" end="(404, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(404, 89)" end="(407, 43)">
            <AtomNode start="(404, 89)" end="(404, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(405, 3)" end="(407, 43)">
              <TacticTacticseq1IndentedNode start="(405, 3)" end="(407, 43)">
                <NullNode start="(405, 3)" end="(407, 43)">
                  <OtherNode start="(405, 3)" end="(407, 43)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : Option α → Option β → α✝&#10;a : α&#10;b : β&#10;n : Nat&#10;⊢ zipWithAll f (replicate n a) (replicate n b) = replicate n (f (some a) (some b))" state_after="no goals" tactic="induction n with&#10;| zero =&amp;gt; rfl&#10;| succ n ih =&amp;gt; simp [replicate_succ, ih]">
                    <AtomNode start="(405, 3)" end="(405, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(405, 13)" end="(405, 14)">
                      <OtherNode start="(405, 13)" end="(405, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(405, 13)" end="(405, 14)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(405, 15)" end="(407, 43)">
                      <OtherNode start="(405, 15)" end="(407, 43)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(405, 15)" end="(405, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(406, 3)" end="(407, 43)">
                          <OtherNode start="(406, 3)" end="(406, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(406, 3)" end="(406, 9)">
                              <OtherNode start="(406, 3)" end="(406, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(406, 3)" end="(406, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(406, 5)" end="(406, 9)">
                                  <NullNode/>
                                  <IdentNode start="(406, 5)" end="(406, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(406, 10)" end="(406, 16)">
                              <AtomNode start="(406, 10)" end="(406, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(406, 13)" end="(406, 16)">
                                <TacticTacticseq1IndentedNode start="(406, 13)" end="(406, 16)">
                                  <NullNode start="(406, 13)" end="(406, 16)">
                                    <OtherNode start="(406, 13)" end="(406, 16)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case zero&#10;α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : Option α → Option β → α✝&#10;a : α&#10;b : β&#10;⊢ zipWithAll f (replicate 0 a) (replicate 0 b) = replicate 0 (f (some a) (some b))" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(406, 13)" end="(406, 16)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(407, 3)" end="(407, 43)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(407, 3)" end="(407, 14)">
                              <OtherNode start="(407, 3)" end="(407, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(407, 3)" end="(407, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(407, 5)" end="(407, 9)">
                                  <NullNode/>
                                  <IdentNode start="(407, 5)" end="(407, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(407, 10)" end="(407, 14)">
                                  <IdentNode start="(407, 10)" end="(407, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                  <IdentNode start="(407, 12)" end="(407, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(407, 15)" end="(407, 43)">
                              <AtomNode start="(407, 15)" end="(407, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(407, 18)" end="(407, 43)">
                                <TacticTacticseq1IndentedNode start="(407, 18)" end="(407, 43)">
                                  <NullNode start="(407, 18)" end="(407, 43)">
                                    <OtherNode start="(407, 18)" end="(407, 43)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : Option α → Option β → α✝&#10;a : α&#10;b : β&#10;n : Nat&#10;ih : zipWithAll f (replicate n a) (replicate n b) = replicate n (f (some a) (some b))&#10;⊢ zipWithAll f (replicate (n + 1) a) (replicate (n + 1) b) = replicate (n + 1) (f (some a) (some b))" state_after="no goals" tactic="simp [replicate_succ, ih]">
                                      <AtomNode start="(407, 18)" end="(407, 22)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(407, 23)" end="(407, 43)">
                                        <AtomNode start="(407, 23)" end="(407, 24)" leading="" trailing="" val="["/>
                                        <NullNode start="(407, 24)" end="(407, 42)">
                                          <OtherNode start="(407, 24)" end="(407, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(407, 24)" end="(407, 38)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(407, 38)" end="(407, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(407, 40)" end="(407, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(407, 40)" end="(407, 42)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(407, 42)" end="(407, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(409, 1)" end="(409, 17)" comment="### unzip -/">
      <AtomNode start="(409, 1)" end="(409, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(409, 5)" end="(409, 17)" leading="" trailing="&#10;&#10;" val="### unzip -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(411, 1)" end="(412, 27)" name="unzip_fst" full_name="List.unzip_fst">
      <CommandDeclmodifiersNode start="(411, 1)" end="(411, 8)">
        <NullNode/>
        <NullNode start="(411, 1)" end="(411, 8)">
          <OtherNode start="(411, 1)" end="(411, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(411, 1)" end="(411, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(411, 3)" end="(411, 7)">
              <OtherNode start="(411, 3)" end="(411, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(411, 3)" end="(411, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(411, 3)" end="(411, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(411, 7)" end="(411, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(411, 9)" end="(412, 27)" name="unzip_fst" full_name="List.unzip_fst" _is_private_decl="False">
        <AtomNode start="(411, 9)" end="(411, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(411, 17)" end="(411, 26)">
          <IdentNode start="(411, 17)" end="(411, 26)" leading="" trailing=" " raw_val="unzip_fst" val="unzip_fst"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(411, 27)" end="(411, 59)">
          <NullNode/>
          <TermTypespecNode start="(411, 27)" end="(411, 59)">
            <AtomNode start="(411, 27)" end="(411, 28)" leading="" trailing=" " val=":"/>
            <OtherNode start="(411, 29)" end="(411, 59)" kind="«term_=_»">
              <OtherNode start="(411, 29)" end="(411, 42)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(411, 29)" end="(411, 38)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(411, 29)" end="(411, 30)" leading="" trailing="" val="("/>
                  <OtherNode start="(411, 30)" end="(411, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(411, 30)" end="(411, 35)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(411, 36)" end="(411, 37)">
                      <IdentNode start="(411, 36)" end="(411, 37)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(411, 37)" end="(411, 38)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(411, 38)" end="(411, 39)" leading="" trailing="" val="."/>
                <IdentNode start="(411, 39)" end="(411, 42)" leading="" trailing=" " raw_val="fst" val="fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(411, 43)" end="(411, 44)" leading="" trailing=" " val="="/>
              <OtherNode start="(411, 45)" end="(411, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(411, 45)" end="(411, 50)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                <NullNode start="(411, 51)" end="(411, 59)">
                  <IdentNode start="(411, 51)" end="(411, 59)" leading="" trailing=" " raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(411, 60)" end="(412, 27)">
          <AtomNode start="(411, 60)" end="(411, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(411, 63)" end="(412, 27)">
            <AtomNode start="(411, 63)" end="(411, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(412, 3)" end="(412, 27)">
              <TacticTacticseq1IndentedNode start="(412, 3)" end="(412, 27)">
                <NullNode start="(412, 3)" end="(412, 27)">
                  <OtherNode start="(412, 3)" end="(412, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;β✝ : Type u_2&#10;l : List (α✝ × β✝)&#10;⊢ l.unzip.fst = map Prod.fst l" state_after="no goals" tactic="induction l &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(412, 3)" end="(412, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(412, 3)" end="(412, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(412, 13)" end="(412, 14)">
                        <OtherNode start="(412, 13)" end="(412, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(412, 13)" end="(412, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(412, 15)" end="(412, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(412, 19)" end="(412, 27)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(412, 19)" end="(412, 27)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(414, 1)" end="(415, 27)" name="unzip_snd" full_name="List.unzip_snd">
      <CommandDeclmodifiersNode start="(414, 1)" end="(414, 8)">
        <NullNode/>
        <NullNode start="(414, 1)" end="(414, 8)">
          <OtherNode start="(414, 1)" end="(414, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(414, 1)" end="(414, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(414, 3)" end="(414, 7)">
              <OtherNode start="(414, 3)" end="(414, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(414, 3)" end="(414, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(414, 3)" end="(414, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(414, 7)" end="(414, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(414, 9)" end="(415, 27)" name="unzip_snd" full_name="List.unzip_snd" _is_private_decl="False">
        <AtomNode start="(414, 9)" end="(414, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(414, 17)" end="(414, 26)">
          <IdentNode start="(414, 17)" end="(414, 26)" leading="" trailing=" " raw_val="unzip_snd" val="unzip_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(414, 27)" end="(414, 59)">
          <NullNode/>
          <TermTypespecNode start="(414, 27)" end="(414, 59)">
            <AtomNode start="(414, 27)" end="(414, 28)" leading="" trailing=" " val=":"/>
            <OtherNode start="(414, 29)" end="(414, 59)" kind="«term_=_»">
              <OtherNode start="(414, 29)" end="(414, 42)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(414, 29)" end="(414, 38)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(414, 29)" end="(414, 30)" leading="" trailing="" val="("/>
                  <OtherNode start="(414, 30)" end="(414, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(414, 30)" end="(414, 35)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(414, 36)" end="(414, 37)">
                      <IdentNode start="(414, 36)" end="(414, 37)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(414, 37)" end="(414, 38)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(414, 38)" end="(414, 39)" leading="" trailing="" val="."/>
                <IdentNode start="(414, 39)" end="(414, 42)" leading="" trailing=" " raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(414, 43)" end="(414, 44)" leading="" trailing=" " val="="/>
              <OtherNode start="(414, 45)" end="(414, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(414, 45)" end="(414, 50)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                <NullNode start="(414, 51)" end="(414, 59)">
                  <IdentNode start="(414, 51)" end="(414, 59)" leading="" trailing=" " raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(414, 60)" end="(415, 27)">
          <AtomNode start="(414, 60)" end="(414, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(414, 63)" end="(415, 27)">
            <AtomNode start="(414, 63)" end="(414, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(415, 3)" end="(415, 27)">
              <TacticTacticseq1IndentedNode start="(415, 3)" end="(415, 27)">
                <NullNode start="(415, 3)" end="(415, 27)">
                  <OtherNode start="(415, 3)" end="(415, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;β✝ : Type u_2&#10;l : List (α✝ × β✝)&#10;⊢ l.unzip.snd = map Prod.snd l" state_after="no goals" tactic="induction l &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(415, 3)" end="(415, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(415, 3)" end="(415, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(415, 13)" end="(415, 14)">
                        <OtherNode start="(415, 13)" end="(415, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(415, 13)" end="(415, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(415, 15)" end="(415, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(415, 19)" end="(415, 27)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(415, 19)" end="(415, 27)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(417, 1)" end="(419, 78)" name="unzip_eq_map" full_name="List.unzip_eq_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(417, 1)" end="(419, 78)" name="unzip_eq_map" full_name="List.unzip_eq_map" _is_private_decl="False">
        <AtomNode start="(417, 1)" end="(417, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(417, 9)" end="(417, 21)">
          <IdentNode start="(417, 9)" end="(417, 21)" leading="" trailing=" " raw_val="unzip_eq_map" val="unzip_eq_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(417, 22)" end="(417, 88)">
          <NullNode/>
          <TermTypespecNode start="(417, 22)" end="(417, 88)">
            <AtomNode start="(417, 22)" end="(417, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(417, 24)" end="(417, 88)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(417, 24)" end="(417, 25)" leading="" trailing=" " val="∀"/>
              <NullNode start="(417, 26)" end="(417, 44)">
                <OtherNode start="(417, 26)" end="(417, 44)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(417, 26)" end="(417, 27)" leading="" trailing="" val="{"/>
                  <NullNode start="(417, 27)" end="(417, 28)">
                    <IdentNode start="(417, 27)" end="(417, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(417, 29)" end="(417, 43)">
                    <AtomNode start="(417, 29)" end="(417, 30)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(417, 31)" end="(417, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(417, 31)" end="(417, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(417, 36)" end="(417, 43)">
                        <OtherNode start="(417, 36)" end="(417, 43)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(417, 36)" end="(417, 37)" leading="" trailing="" val="("/>
                          <OtherNode start="(417, 37)" end="(417, 42)" kind="«term_×_»">
                            <IdentNode start="(417, 37)" end="(417, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                            <AtomNode start="(417, 39)" end="(417, 40)" leading="" trailing=" " val="×"/>
                            <IdentNode start="(417, 41)" end="(417, 42)" leading="" trailing="" raw_val="β" val="β"/>
                          </OtherNode>
                          <AtomNode start="(417, 42)" end="(417, 43)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(417, 43)" end="(417, 44)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(417, 44)" end="(417, 45)" leading="" trailing=" " val=","/>
              <OtherNode start="(417, 46)" end="(417, 88)" kind="«term_=_»">
                <OtherNode start="(417, 46)" end="(417, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(417, 46)" end="(417, 51)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(417, 52)" end="(417, 53)">
                    <IdentNode start="(417, 52)" end="(417, 53)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(417, 54)" end="(417, 55)" leading="" trailing=" " val="="/>
                <OtherNode start="(417, 56)" end="(417, 88)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(417, 56)" end="(417, 57)" leading="" trailing="" val="("/>
                  <NullNode start="(417, 57)" end="(417, 87)">
                    <OtherNode start="(417, 57)" end="(417, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(417, 57)" end="(417, 62)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(417, 63)" end="(417, 71)">
                        <IdentNode start="(417, 63)" end="(417, 71)" leading="" trailing="" raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(417, 71)" end="(417, 72)" leading="" trailing=" " val=","/>
                    <NullNode start="(417, 73)" end="(417, 87)">
                      <OtherNode start="(417, 73)" end="(417, 87)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(417, 73)" end="(417, 78)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                        <NullNode start="(417, 79)" end="(417, 87)">
                          <IdentNode start="(417, 79)" end="(417, 87)" leading="" trailing="" raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(417, 87)" end="(417, 88)" leading="" trailing="&#10;  " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(418, 3)" end="(419, 78)">
          <OtherNode start="(418, 3)" end="(419, 78)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(418, 3)" end="(419, 78)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(418, 3)" end="(419, 78)">
                <OtherNode start="(418, 3)" end="(418, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(418, 3)" end="(418, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(418, 5)" end="(418, 7)">
                    <NullNode start="(418, 5)" end="(418, 7)">
                      <OtherNode start="(418, 5)" end="(418, 7)" kind="«term[_]»">
                        <AtomNode start="(418, 5)" end="(418, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(418, 6)" end="(418, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(418, 8)" end="(418, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(418, 11)" end="(418, 14)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(419, 3)" end="(419, 78)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(419, 3)" end="(419, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(419, 5)" end="(419, 16)">
                    <NullNode start="(419, 5)" end="(419, 16)">
                      <OtherNode start="(419, 5)" end="(419, 16)" kind="«term_::_»">
                        <OtherNode start="(419, 5)" end="(419, 11)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(419, 5)" end="(419, 6)" leading="" trailing="" val="("/>
                          <NullNode start="(419, 6)" end="(419, 10)">
                            <IdentNode start="(419, 6)" end="(419, 7)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(419, 7)" end="(419, 8)" leading="" trailing=" " val=","/>
                            <NullNode start="(419, 9)" end="(419, 10)">
                              <IdentNode start="(419, 9)" end="(419, 10)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(419, 10)" end="(419, 11)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(419, 12)" end="(419, 14)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(419, 15)" end="(419, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(419, 17)" end="(419, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(419, 20)" end="(419, 78)">
                    <AtomNode start="(419, 20)" end="(419, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(419, 23)" end="(419, 78)">
                      <TacticTacticseq1IndentedNode start="(419, 23)" end="(419, 78)">
                        <NullNode start="(419, 23)" end="(419, 78)">
                          <OtherNode start="(419, 23)" end="(419, 78)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;⊢ ((a, b) :: l).unzip = (map Prod.fst ((a, b) :: l), map Prod.snd ((a, b) :: l))" state_after="no goals" tactic="simp only [unzip_cons, map_cons, unzip_eq_map (l := l)]">
                            <AtomNode start="(419, 23)" end="(419, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(419, 28)" end="(419, 32)">
                              <AtomNode start="(419, 28)" end="(419, 32)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(419, 33)" end="(419, 78)">
                              <AtomNode start="(419, 33)" end="(419, 34)" leading="" trailing="" val="["/>
                              <NullNode start="(419, 34)" end="(419, 77)">
                                <OtherNode start="(419, 34)" end="(419, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(419, 34)" end="(419, 44)" leading="" trailing="" raw_val="unzip_cons" val="unzip_cons" full_name="List.unzip_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(419, 44)" end="(419, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(419, 46)" end="(419, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(419, 46)" end="(419, 54)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(419, 54)" end="(419, 55)" leading="" trailing=" " val=","/>
                                <OtherNode start="(419, 56)" end="(419, 77)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(419, 56)" end="(419, 77)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(419, 56)" end="(419, 68)" leading="" trailing=" " raw_val="unzip_eq_map" val="unzip_eq_map"/>
                                    <NullNode start="(419, 69)" end="(419, 77)">
                                      <OtherNode start="(419, 69)" end="(419, 77)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(419, 69)" end="(419, 70)" leading="" trailing="" val="("/>
                                        <IdentNode start="(419, 70)" end="(419, 71)" leading="" trailing=" " raw_val="l" val="l"/>
                                        <AtomNode start="(419, 72)" end="(419, 74)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(419, 75)" end="(419, 76)" leading="" trailing="" raw_val="l" val="l"/>
                                        <AtomNode start="(419, 76)" end="(419, 77)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(419, 77)" end="(419, 78)" leading="" trailing="&#10;&#10;-- The argument `l` is explicit so we can rewrite from right to left.&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(422, 1)" end="(424, 73)" name="zip_unzip" full_name="List.zip_unzip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(422, 1)" end="(424, 73)" name="zip_unzip" full_name="List.zip_unzip" _is_private_decl="False">
        <AtomNode start="(422, 1)" end="(422, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(422, 9)" end="(422, 18)">
          <IdentNode start="(422, 9)" end="(422, 18)" leading="" trailing=" " raw_val="zip_unzip" val="zip_unzip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(422, 19)" end="(422, 72)">
          <NullNode/>
          <TermTypespecNode start="(422, 19)" end="(422, 72)">
            <AtomNode start="(422, 19)" end="(422, 20)" leading="" trailing=" " val=":"/>
            <OtherNode start="(422, 21)" end="(422, 72)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(422, 21)" end="(422, 22)" leading="" trailing=" " val="∀"/>
              <NullNode start="(422, 23)" end="(422, 24)">
                <IdentNode start="(422, 23)" end="(422, 24)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(422, 25)" end="(422, 39)">
                <TermTypespecNode start="(422, 25)" end="(422, 39)">
                  <AtomNode start="(422, 25)" end="(422, 26)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(422, 27)" end="(422, 39)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(422, 27)" end="(422, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(422, 32)" end="(422, 39)">
                      <OtherNode start="(422, 32)" end="(422, 39)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(422, 32)" end="(422, 33)" leading="" trailing="" val="("/>
                        <OtherNode start="(422, 33)" end="(422, 38)" kind="«term_×_»">
                          <IdentNode start="(422, 33)" end="(422, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(422, 35)" end="(422, 36)" leading="" trailing=" " val="×"/>
                          <IdentNode start="(422, 37)" end="(422, 38)" leading="" trailing="" raw_val="β" val="β"/>
                        </OtherNode>
                        <AtomNode start="(422, 38)" end="(422, 39)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </TermTypespecNode>
              </NullNode>
              <AtomNode start="(422, 39)" end="(422, 40)" leading="" trailing=" " val=","/>
              <OtherNode start="(422, 41)" end="(422, 72)" kind="«term_=_»">
                <OtherNode start="(422, 41)" end="(422, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(422, 41)" end="(422, 44)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(422, 45)" end="(422, 68)">
                    <OtherNode start="(422, 45)" end="(422, 56)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(422, 45)" end="(422, 54)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(422, 45)" end="(422, 46)" leading="" trailing="" val="("/>
                        <OtherNode start="(422, 46)" end="(422, 53)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(422, 46)" end="(422, 51)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          <NullNode start="(422, 52)" end="(422, 53)">
                            <IdentNode start="(422, 52)" end="(422, 53)" leading="" trailing="" raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(422, 53)" end="(422, 54)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(422, 54)" end="(422, 55)" leading="" trailing="" val="."/>
                      <OtherNode start="(422, 55)" end="(422, 56)" kind="fieldIdx">
                        <AtomNode start="(422, 55)" end="(422, 56)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(422, 57)" end="(422, 68)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(422, 57)" end="(422, 66)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(422, 57)" end="(422, 58)" leading="" trailing="" val="("/>
                        <OtherNode start="(422, 58)" end="(422, 65)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(422, 58)" end="(422, 63)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          <NullNode start="(422, 64)" end="(422, 65)">
                            <IdentNode start="(422, 64)" end="(422, 65)" leading="" trailing="" raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(422, 65)" end="(422, 66)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(422, 66)" end="(422, 67)" leading="" trailing="" val="."/>
                      <OtherNode start="(422, 67)" end="(422, 68)" kind="fieldIdx">
                        <AtomNode start="(422, 67)" end="(422, 68)" leading="" trailing=" " val="2"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(422, 69)" end="(422, 70)" leading="" trailing=" " val="="/>
                <IdentNode start="(422, 71)" end="(422, 72)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(423, 3)" end="(424, 73)">
          <OtherNode start="(423, 3)" end="(424, 73)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(423, 3)" end="(424, 73)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(423, 3)" end="(424, 73)">
                <OtherNode start="(423, 3)" end="(423, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(423, 3)" end="(423, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(423, 5)" end="(423, 7)">
                    <NullNode start="(423, 5)" end="(423, 7)">
                      <OtherNode start="(423, 5)" end="(423, 7)" kind="«term[_]»">
                        <AtomNode start="(423, 5)" end="(423, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(423, 6)" end="(423, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(423, 8)" end="(423, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(423, 11)" end="(423, 14)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(424, 3)" end="(424, 73)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(424, 3)" end="(424, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(424, 5)" end="(424, 16)">
                    <NullNode start="(424, 5)" end="(424, 16)">
                      <OtherNode start="(424, 5)" end="(424, 16)" kind="«term_::_»">
                        <OtherNode start="(424, 5)" end="(424, 11)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(424, 5)" end="(424, 6)" leading="" trailing="" val="("/>
                          <NullNode start="(424, 6)" end="(424, 10)">
                            <IdentNode start="(424, 6)" end="(424, 7)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(424, 7)" end="(424, 8)" leading="" trailing=" " val=","/>
                            <NullNode start="(424, 9)" end="(424, 10)">
                              <IdentNode start="(424, 9)" end="(424, 10)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(424, 10)" end="(424, 11)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(424, 12)" end="(424, 14)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(424, 15)" end="(424, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(424, 17)" end="(424, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(424, 20)" end="(424, 73)">
                    <AtomNode start="(424, 20)" end="(424, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(424, 23)" end="(424, 73)">
                      <TacticTacticseq1IndentedNode start="(424, 23)" end="(424, 73)">
                        <NullNode start="(424, 23)" end="(424, 73)">
                          <OtherNode start="(424, 23)" end="(424, 73)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;l : List (α × β)&#10;⊢ ((a, b) :: l).unzip.fst.zip ((a, b) :: l).unzip.snd = (a, b) :: l" state_after="no goals" tactic="simp only [unzip_cons, zip_cons_cons, zip_unzip l]">
                            <AtomNode start="(424, 23)" end="(424, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(424, 28)" end="(424, 32)">
                              <AtomNode start="(424, 28)" end="(424, 32)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(424, 33)" end="(424, 73)">
                              <AtomNode start="(424, 33)" end="(424, 34)" leading="" trailing="" val="["/>
                              <NullNode start="(424, 34)" end="(424, 72)">
                                <OtherNode start="(424, 34)" end="(424, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(424, 34)" end="(424, 44)" leading="" trailing="" raw_val="unzip_cons" val="unzip_cons" full_name="List.unzip_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(424, 44)" end="(424, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(424, 46)" end="(424, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(424, 46)" end="(424, 59)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(424, 59)" end="(424, 60)" leading="" trailing=" " val=","/>
                                <OtherNode start="(424, 61)" end="(424, 72)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(424, 61)" end="(424, 72)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(424, 61)" end="(424, 70)" leading="" trailing=" " raw_val="zip_unzip" val="zip_unzip"/>
                                    <NullNode start="(424, 71)" end="(424, 72)">
                                      <IdentNode start="(424, 71)" end="(424, 72)" leading="" trailing="" raw_val="l" val="l"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(424, 72)" end="(424, 73)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(426, 1)" end="(431, 81)" name="unzip_zip_left" full_name="List.unzip_zip_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(426, 1)" end="(431, 81)" name="unzip_zip_left" full_name="List.unzip_zip_left" _is_private_decl="False">
        <AtomNode start="(426, 1)" end="(426, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(426, 9)" end="(426, 23)">
          <IdentNode start="(426, 9)" end="(426, 23)" leading="" trailing=" " raw_val="unzip_zip_left" val="unzip_zip_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(426, 24)" end="(427, 86)">
          <NullNode/>
          <TermTypespecNode start="(426, 24)" end="(427, 86)">
            <AtomNode start="(426, 24)" end="(426, 25)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(427, 5)" end="(427, 86)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(427, 5)" end="(427, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(427, 7)" end="(427, 34)">
                <OtherNode start="(427, 7)" end="(427, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(427, 7)" end="(427, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(427, 8)" end="(427, 10)">
                    <IdentNode start="(427, 8)" end="(427, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(427, 11)" end="(427, 19)">
                    <AtomNode start="(427, 11)" end="(427, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(427, 13)" end="(427, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(427, 13)" end="(427, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(427, 18)" end="(427, 19)">
                        <IdentNode start="(427, 18)" end="(427, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(427, 19)" end="(427, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(427, 21)" end="(427, 34)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(427, 21)" end="(427, 22)" leading="" trailing="" val="{"/>
                  <NullNode start="(427, 22)" end="(427, 24)">
                    <IdentNode start="(427, 22)" end="(427, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(427, 25)" end="(427, 33)">
                    <AtomNode start="(427, 25)" end="(427, 26)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(427, 27)" end="(427, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(427, 27)" end="(427, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(427, 32)" end="(427, 33)">
                        <IdentNode start="(427, 32)" end="(427, 33)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(427, 33)" end="(427, 34)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(427, 34)" end="(427, 35)" leading="" trailing=" " val=","/>
              <OtherNode start="(427, 36)" end="(427, 86)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(427, 36)" end="(427, 57)" kind="«term_≤_»">
                  <OtherNode start="(427, 36)" end="(427, 45)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(427, 36)" end="(427, 42)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(427, 43)" end="(427, 45)">
                      <IdentNode start="(427, 43)" end="(427, 45)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(427, 46)" end="(427, 47)" leading="" trailing=" " val="≤"/>
                  <OtherNode start="(427, 48)" end="(427, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(427, 48)" end="(427, 54)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(427, 55)" end="(427, 57)">
                      <IdentNode start="(427, 55)" end="(427, 57)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(427, 58)" end="(427, 59)" leading="" trailing=" " val="→"/>
                <OtherNode start="(427, 60)" end="(427, 86)" kind="«term_=_»">
                  <OtherNode start="(427, 60)" end="(427, 81)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(427, 60)" end="(427, 79)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(427, 60)" end="(427, 61)" leading="" trailing="" val="("/>
                      <OtherNode start="(427, 61)" end="(427, 78)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(427, 61)" end="(427, 66)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(427, 67)" end="(427, 78)">
                          <OtherNode start="(427, 67)" end="(427, 78)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(427, 67)" end="(427, 68)" leading="" trailing="" val="("/>
                            <OtherNode start="(427, 68)" end="(427, 77)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(427, 68)" end="(427, 71)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              <NullNode start="(427, 72)" end="(427, 77)">
                                <IdentNode start="(427, 72)" end="(427, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                <IdentNode start="(427, 75)" end="(427, 77)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(427, 77)" end="(427, 78)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(427, 78)" end="(427, 79)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(427, 79)" end="(427, 80)" leading="" trailing="" val="."/>
                    <OtherNode start="(427, 80)" end="(427, 81)" kind="fieldIdx">
                      <AtomNode start="(427, 80)" end="(427, 81)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(427, 82)" end="(427, 83)" leading="" trailing=" " val="="/>
                  <IdentNode start="(427, 84)" end="(427, 86)" leading="" trailing="&#10;  " raw_val="l₁" val="l₁"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(428, 3)" end="(431, 81)">
          <OtherNode start="(428, 3)" end="(431, 81)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(428, 3)" end="(431, 81)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(428, 3)" end="(431, 81)">
                <OtherNode start="(428, 3)" end="(428, 20)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(428, 3)" end="(428, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(428, 5)" end="(428, 13)">
                    <NullNode start="(428, 5)" end="(428, 13)">
                      <OtherNode start="(428, 5)" end="(428, 7)" kind="«term[_]»">
                        <AtomNode start="(428, 5)" end="(428, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(428, 6)" end="(428, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(428, 7)" end="(428, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(428, 9)" end="(428, 10)">
                        <AtomNode start="(428, 9)" end="(428, 10)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(428, 10)" end="(428, 11)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(428, 12)" end="(428, 13)">
                        <AtomNode start="(428, 12)" end="(428, 13)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(428, 14)" end="(428, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(428, 17)" end="(428, 20)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(429, 3)" end="(429, 81)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(429, 3)" end="(429, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(429, 5)" end="(429, 13)">
                    <NullNode start="(429, 5)" end="(429, 13)">
                      <TermHoleNode start="(429, 5)" end="(429, 6)">
                        <AtomNode start="(429, 5)" end="(429, 6)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(429, 6)" end="(429, 7)" leading="" trailing=" " val=","/>
                      <OtherNode start="(429, 8)" end="(429, 10)" kind="«term[_]»">
                        <AtomNode start="(429, 8)" end="(429, 9)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(429, 9)" end="(429, 10)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(429, 10)" end="(429, 11)" leading="" trailing=" " val=","/>
                      <IdentNode start="(429, 12)" end="(429, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(429, 14)" end="(429, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(429, 17)" end="(429, 81)">
                    <AtomNode start="(429, 17)" end="(429, 19)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(429, 20)" end="(429, 81)">
                      <TacticTacticseq1IndentedNode start="(429, 20)" end="(429, 81)">
                        <NullNode start="(429, 20)" end="(429, 81)">
                          <OtherNode start="(429, 20)" end="(429, 76)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝ : List α&#10;h : x✝.length ≤ [].length&#10;⊢ (x✝.zip []).unzip.fst = x✝" state_after="α : Type u_1&#10;β : Type u_2&#10;x✝ : List α&#10;h : x✝.length ≤ [].length&#10;⊢ ([].zip []).unzip.fst = []" tactic="rw [eq_nil_of_length_eq_zero (Nat.eq_zero_of_le_zero h)]">
                            <AtomNode start="(429, 20)" end="(429, 22)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(429, 23)" end="(429, 76)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(429, 23)" end="(429, 24)" leading="" trailing="" val="["/>
                              <NullNode start="(429, 24)" end="(429, 75)">
                                <OtherNode start="(429, 24)" end="(429, 75)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(429, 24)" end="(429, 75)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(429, 24)" end="(429, 48)" leading="" trailing=" " raw_val="eq_nil_of_length_eq_zero" val="eq_nil_of_length_eq_zero" full_name="List.eq_nil_of_length_eq_zero" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                    <NullNode start="(429, 49)" end="(429, 75)">
                                      <OtherNode start="(429, 49)" end="(429, 75)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(429, 49)" end="(429, 50)" leading="" trailing="" val="("/>
                                        <OtherNode start="(429, 50)" end="(429, 74)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(429, 50)" end="(429, 72)" leading="" trailing=" " raw_val="Nat.eq_zero_of_le_zero" val="Nat.eq_zero_of_le_zero" full_name="Nat.eq_zero_of_le_zero" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          <NullNode start="(429, 73)" end="(429, 74)">
                                            <IdentNode start="(429, 73)" end="(429, 74)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(429, 74)" end="(429, 75)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(429, 75)" end="(429, 76)" leading="" trailing="" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(429, 76)" end="(429, 77)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(429, 78)" end="(429, 81)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;x✝ : List α&#10;h : x✝.length ≤ [].length&#10;⊢ ([].zip []).unzip.fst = []" state_after="no goals" tactic="rfl">
                            <AtomNode start="(429, 78)" end="(429, 81)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(430, 3)" end="(431, 81)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(430, 3)" end="(430, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(430, 5)" end="(430, 22)">
                    <NullNode start="(430, 5)" end="(430, 22)">
                      <OtherNode start="(430, 5)" end="(430, 11)" kind="«term_::_»">
                        <TermHoleNode start="(430, 5)" end="(430, 6)">
                          <AtomNode start="(430, 5)" end="(430, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(430, 7)" end="(430, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(430, 10)" end="(430, 11)">
                          <AtomNode start="(430, 10)" end="(430, 11)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(430, 11)" end="(430, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(430, 13)" end="(430, 19)" kind="«term_::_»">
                        <TermHoleNode start="(430, 13)" end="(430, 14)">
                          <AtomNode start="(430, 13)" end="(430, 14)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(430, 15)" end="(430, 17)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(430, 18)" end="(430, 19)">
                          <AtomNode start="(430, 18)" end="(430, 19)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(430, 19)" end="(430, 20)" leading="" trailing=" " val=","/>
                      <IdentNode start="(430, 21)" end="(430, 22)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(430, 23)" end="(430, 25)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(430, 26)" end="(431, 81)">
                    <AtomNode start="(430, 26)" end="(430, 28)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(431, 5)" end="(431, 81)">
                      <TacticTacticseq1IndentedNode start="(431, 5)" end="(431, 81)">
                        <NullNode start="(431, 5)" end="(431, 81)">
                          <OtherNode start="(431, 5)" end="(431, 81)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : β&#10;tail✝ : List β&#10;h : (head✝¹ :: tail✝¹).length ≤ (head✝ :: tail✝).length&#10;⊢ ((head✝¹ :: tail✝¹).zip (head✝ :: tail✝)).unzip.fst = head✝¹ :: tail✝¹" state_after="no goals" tactic="simp only [zip_cons_cons, unzip_cons, unzip_zip_left (le_of_succ_le_succ h)]">
                            <AtomNode start="(431, 5)" end="(431, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(431, 10)" end="(431, 14)">
                              <AtomNode start="(431, 10)" end="(431, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(431, 15)" end="(431, 81)">
                              <AtomNode start="(431, 15)" end="(431, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(431, 16)" end="(431, 80)">
                                <OtherNode start="(431, 16)" end="(431, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(431, 16)" end="(431, 29)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(431, 29)" end="(431, 30)" leading="" trailing=" " val=","/>
                                <OtherNode start="(431, 31)" end="(431, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(431, 31)" end="(431, 41)" leading="" trailing="" raw_val="unzip_cons" val="unzip_cons" full_name="List.unzip_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(431, 41)" end="(431, 42)" leading="" trailing=" " val=","/>
                                <OtherNode start="(431, 43)" end="(431, 80)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(431, 43)" end="(431, 80)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(431, 43)" end="(431, 57)" leading="" trailing=" " raw_val="unzip_zip_left" val="unzip_zip_left"/>
                                    <NullNode start="(431, 58)" end="(431, 80)">
                                      <OtherNode start="(431, 58)" end="(431, 80)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(431, 58)" end="(431, 59)" leading="" trailing="" val="("/>
                                        <OtherNode start="(431, 59)" end="(431, 79)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(431, 59)" end="(431, 77)" leading="" trailing=" " raw_val="le_of_succ_le_succ" val="le_of_succ_le_succ" full_name="Nat.le_of_succ_le_succ" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          <NullNode start="(431, 78)" end="(431, 79)">
                                            <IdentNode start="(431, 78)" end="(431, 79)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(431, 79)" end="(431, 80)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(431, 80)" end="(431, 81)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(433, 1)" end="(438, 82)" name="unzip_zip_right" full_name="List.unzip_zip_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(433, 1)" end="(438, 82)" name="unzip_zip_right" full_name="List.unzip_zip_right" _is_private_decl="False">
        <AtomNode start="(433, 1)" end="(433, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(433, 9)" end="(433, 24)">
          <IdentNode start="(433, 9)" end="(433, 24)" leading="" trailing=" " raw_val="unzip_zip_right" val="unzip_zip_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(433, 25)" end="(434, 86)">
          <NullNode/>
          <TermTypespecNode start="(433, 25)" end="(434, 86)">
            <AtomNode start="(433, 25)" end="(433, 26)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(434, 5)" end="(434, 86)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(434, 5)" end="(434, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(434, 7)" end="(434, 34)">
                <OtherNode start="(434, 7)" end="(434, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(434, 7)" end="(434, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(434, 8)" end="(434, 10)">
                    <IdentNode start="(434, 8)" end="(434, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(434, 11)" end="(434, 19)">
                    <AtomNode start="(434, 11)" end="(434, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(434, 13)" end="(434, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(434, 13)" end="(434, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(434, 18)" end="(434, 19)">
                        <IdentNode start="(434, 18)" end="(434, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(434, 19)" end="(434, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(434, 21)" end="(434, 34)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(434, 21)" end="(434, 22)" leading="" trailing="" val="{"/>
                  <NullNode start="(434, 22)" end="(434, 24)">
                    <IdentNode start="(434, 22)" end="(434, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(434, 25)" end="(434, 33)">
                    <AtomNode start="(434, 25)" end="(434, 26)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(434, 27)" end="(434, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(434, 27)" end="(434, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(434, 32)" end="(434, 33)">
                        <IdentNode start="(434, 32)" end="(434, 33)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(434, 33)" end="(434, 34)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(434, 34)" end="(434, 35)" leading="" trailing=" " val=","/>
              <OtherNode start="(434, 36)" end="(434, 86)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(434, 36)" end="(434, 57)" kind="«term_≤_»">
                  <OtherNode start="(434, 36)" end="(434, 45)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 36)" end="(434, 42)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(434, 43)" end="(434, 45)">
                      <IdentNode start="(434, 43)" end="(434, 45)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(434, 46)" end="(434, 47)" leading="" trailing=" " val="≤"/>
                  <OtherNode start="(434, 48)" end="(434, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 48)" end="(434, 54)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(434, 55)" end="(434, 57)">
                      <IdentNode start="(434, 55)" end="(434, 57)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(434, 58)" end="(434, 59)" leading="" trailing=" " val="→"/>
                <OtherNode start="(434, 60)" end="(434, 86)" kind="«term_=_»">
                  <OtherNode start="(434, 60)" end="(434, 81)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(434, 60)" end="(434, 79)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(434, 60)" end="(434, 61)" leading="" trailing="" val="("/>
                      <OtherNode start="(434, 61)" end="(434, 78)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(434, 61)" end="(434, 66)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(434, 67)" end="(434, 78)">
                          <OtherNode start="(434, 67)" end="(434, 78)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(434, 67)" end="(434, 68)" leading="" trailing="" val="("/>
                            <OtherNode start="(434, 68)" end="(434, 77)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(434, 68)" end="(434, 71)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              <NullNode start="(434, 72)" end="(434, 77)">
                                <IdentNode start="(434, 72)" end="(434, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                <IdentNode start="(434, 75)" end="(434, 77)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(434, 77)" end="(434, 78)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(434, 78)" end="(434, 79)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(434, 79)" end="(434, 80)" leading="" trailing="" val="."/>
                    <OtherNode start="(434, 80)" end="(434, 81)" kind="fieldIdx">
                      <AtomNode start="(434, 80)" end="(434, 81)" leading="" trailing=" " val="2"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(434, 82)" end="(434, 83)" leading="" trailing=" " val="="/>
                  <IdentNode start="(434, 84)" end="(434, 86)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(435, 3)" end="(438, 82)">
          <OtherNode start="(435, 3)" end="(438, 82)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(435, 3)" end="(438, 82)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(435, 3)" end="(438, 82)">
                <OtherNode start="(435, 3)" end="(435, 29)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(435, 3)" end="(435, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(435, 5)" end="(435, 14)">
                    <NullNode start="(435, 5)" end="(435, 14)">
                      <OtherNode start="(435, 5)" end="(435, 7)" kind="«term[_]»">
                        <AtomNode start="(435, 5)" end="(435, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(435, 6)" end="(435, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(435, 7)" end="(435, 8)" leading="" trailing=" " val=","/>
                      <IdentNode start="(435, 9)" end="(435, 11)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      <AtomNode start="(435, 11)" end="(435, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(435, 13)" end="(435, 14)">
                        <AtomNode start="(435, 13)" end="(435, 14)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(435, 15)" end="(435, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(435, 18)" end="(435, 29)">
                    <AtomNode start="(435, 18)" end="(435, 20)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(435, 21)" end="(435, 29)">
                      <TacticTacticseq1IndentedNode start="(435, 21)" end="(435, 29)">
                        <NullNode start="(435, 21)" end="(435, 29)">
                          <OtherNode start="(435, 21)" end="(435, 29)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;x✝ : l₂.length ≤ [].length&#10;⊢ ([].zip l₂).unzip.snd = l₂" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(435, 21)" end="(435, 29)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(436, 3)" end="(436, 25)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(436, 3)" end="(436, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(436, 5)" end="(436, 14)">
                    <NullNode start="(436, 5)" end="(436, 14)">
                      <IdentNode start="(436, 5)" end="(436, 7)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      <AtomNode start="(436, 7)" end="(436, 8)" leading="" trailing=" " val=","/>
                      <OtherNode start="(436, 9)" end="(436, 11)" kind="«term[_]»">
                        <AtomNode start="(436, 9)" end="(436, 10)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(436, 10)" end="(436, 11)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(436, 11)" end="(436, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(436, 13)" end="(436, 14)">
                        <AtomNode start="(436, 13)" end="(436, 14)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(436, 15)" end="(436, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(436, 18)" end="(436, 25)">
                    <AtomNode start="(436, 18)" end="(436, 20)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(436, 21)" end="(436, 25)">
                      <TacticTacticseq1IndentedNode start="(436, 21)" end="(436, 25)">
                        <NullNode start="(436, 21)" end="(436, 25)">
                          <OtherNode start="(436, 21)" end="(436, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;x✝ : [].length ≤ l₁.length&#10;⊢ (l₁.zip []).unzip.snd = []" state_after="no goals" tactic="simp">
                            <AtomNode start="(436, 21)" end="(436, 25)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(437, 3)" end="(438, 82)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(437, 3)" end="(437, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(437, 5)" end="(437, 24)">
                    <NullNode start="(437, 5)" end="(437, 24)">
                      <OtherNode start="(437, 5)" end="(437, 12)" kind="«term_::_»">
                        <IdentNode start="(437, 5)" end="(437, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(437, 7)" end="(437, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(437, 10)" end="(437, 12)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(437, 12)" end="(437, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(437, 14)" end="(437, 21)" kind="«term_::_»">
                        <IdentNode start="(437, 14)" end="(437, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(437, 16)" end="(437, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(437, 19)" end="(437, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </OtherNode>
                      <AtomNode start="(437, 21)" end="(437, 22)" leading="" trailing=" " val=","/>
                      <IdentNode start="(437, 23)" end="(437, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(437, 25)" end="(437, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(437, 28)" end="(438, 82)">
                    <AtomNode start="(437, 28)" end="(437, 30)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(438, 5)" end="(438, 82)">
                      <TacticTacticseq1IndentedNode start="(438, 5)" end="(438, 82)">
                        <NullNode start="(438, 5)" end="(438, 82)">
                          <OtherNode start="(438, 5)" end="(438, 82)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;l₁ : List α&#10;b : β&#10;l₂ : List β&#10;h : (b :: l₂).length ≤ (a :: l₁).length&#10;⊢ ((a :: l₁).zip (b :: l₂)).unzip.snd = b :: l₂" state_after="no goals" tactic="simp only [zip_cons_cons, unzip_cons, unzip_zip_right (le_of_succ_le_succ h)]">
                            <AtomNode start="(438, 5)" end="(438, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(438, 10)" end="(438, 14)">
                              <AtomNode start="(438, 10)" end="(438, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(438, 15)" end="(438, 82)">
                              <AtomNode start="(438, 15)" end="(438, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(438, 16)" end="(438, 81)">
                                <OtherNode start="(438, 16)" end="(438, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(438, 16)" end="(438, 29)" leading="" trailing="" raw_val="zip_cons_cons" val="zip_cons_cons" full_name="List.zip_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(438, 29)" end="(438, 30)" leading="" trailing=" " val=","/>
                                <OtherNode start="(438, 31)" end="(438, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(438, 31)" end="(438, 41)" leading="" trailing="" raw_val="unzip_cons" val="unzip_cons" full_name="List.unzip_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(438, 41)" end="(438, 42)" leading="" trailing=" " val=","/>
                                <OtherNode start="(438, 43)" end="(438, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(438, 43)" end="(438, 81)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(438, 43)" end="(438, 58)" leading="" trailing=" " raw_val="unzip_zip_right" val="unzip_zip_right"/>
                                    <NullNode start="(438, 59)" end="(438, 81)">
                                      <OtherNode start="(438, 59)" end="(438, 81)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(438, 59)" end="(438, 60)" leading="" trailing="" val="("/>
                                        <OtherNode start="(438, 60)" end="(438, 80)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(438, 60)" end="(438, 78)" leading="" trailing=" " raw_val="le_of_succ_le_succ" val="le_of_succ_le_succ" full_name="Nat.le_of_succ_le_succ" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          <NullNode start="(438, 79)" end="(438, 80)">
                                            <IdentNode start="(438, 79)" end="(438, 80)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(438, 80)" end="(438, 81)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(438, 81)" end="(438, 82)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(440, 1)" end="(444, 47)" name="unzip_zip" full_name="List.unzip_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(440, 1)" end="(444, 47)" name="unzip_zip" full_name="List.unzip_zip" _is_private_decl="False">
        <AtomNode start="(440, 1)" end="(440, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(440, 9)" end="(440, 18)">
          <IdentNode start="(440, 9)" end="(440, 18)" leading="" trailing=" " raw_val="unzip_zip" val="unzip_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(440, 19)" end="(441, 33)">
          <NullNode start="(440, 19)" end="(440, 74)">
            <OtherNode start="(440, 19)" end="(440, 32)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(440, 19)" end="(440, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(440, 20)" end="(440, 22)">
                <IdentNode start="(440, 20)" end="(440, 22)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(440, 23)" end="(440, 31)">
                <AtomNode start="(440, 23)" end="(440, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(440, 25)" end="(440, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(440, 25)" end="(440, 29)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(440, 30)" end="(440, 31)">
                    <IdentNode start="(440, 30)" end="(440, 31)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(440, 31)" end="(440, 32)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(440, 33)" end="(440, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(440, 33)" end="(440, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(440, 34)" end="(440, 36)">
                <IdentNode start="(440, 34)" end="(440, 36)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(440, 37)" end="(440, 45)">
                <AtomNode start="(440, 37)" end="(440, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(440, 39)" end="(440, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(440, 39)" end="(440, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(440, 44)" end="(440, 45)">
                    <IdentNode start="(440, 44)" end="(440, 45)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(440, 45)" end="(440, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(440, 47)" end="(440, 74)">
              <AtomNode start="(440, 47)" end="(440, 48)" leading="" trailing="" val="("/>
              <NullNode start="(440, 48)" end="(440, 49)">
                <IdentNode start="(440, 48)" end="(440, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(440, 50)" end="(440, 73)">
                <AtomNode start="(440, 50)" end="(440, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(440, 52)" end="(440, 73)" kind="«term_=_»">
                  <OtherNode start="(440, 52)" end="(440, 61)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(440, 52)" end="(440, 58)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(440, 59)" end="(440, 61)">
                      <IdentNode start="(440, 59)" end="(440, 61)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(440, 62)" end="(440, 63)" leading="" trailing=" " val="="/>
                  <OtherNode start="(440, 64)" end="(440, 73)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(440, 64)" end="(440, 70)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(440, 71)" end="(440, 73)">
                      <IdentNode start="(440, 71)" end="(440, 73)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(440, 73)" end="(440, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(440, 75)" end="(441, 33)">
            <AtomNode start="(440, 75)" end="(440, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(441, 5)" end="(441, 33)" kind="«term_=_»">
              <OtherNode start="(441, 5)" end="(441, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(441, 5)" end="(441, 10)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(441, 11)" end="(441, 22)">
                  <OtherNode start="(441, 11)" end="(441, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(441, 11)" end="(441, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(441, 12)" end="(441, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(441, 12)" end="(441, 15)" leading="" trailing=" " raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(441, 16)" end="(441, 21)">
                        <IdentNode start="(441, 16)" end="(441, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(441, 19)" end="(441, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(441, 21)" end="(441, 22)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(441, 23)" end="(441, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(441, 25)" end="(441, 33)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(441, 25)" end="(441, 26)" leading="" trailing="" val="("/>
                <NullNode start="(441, 26)" end="(441, 32)">
                  <IdentNode start="(441, 26)" end="(441, 28)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                  <AtomNode start="(441, 28)" end="(441, 29)" leading="" trailing=" " val=","/>
                  <NullNode start="(441, 30)" end="(441, 32)">
                    <IdentNode start="(441, 30)" end="(441, 32)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </NullNode>
                </NullNode>
                <AtomNode start="(441, 32)" end="(441, 33)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(441, 34)" end="(444, 47)">
          <AtomNode start="(441, 34)" end="(441, 36)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(441, 37)" end="(444, 47)">
            <AtomNode start="(441, 37)" end="(441, 39)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(442, 3)" end="(444, 47)">
              <TacticTacticseq1IndentedNode start="(442, 3)" end="(444, 47)">
                <NullNode start="(442, 3)" end="(444, 47)">
                  <OtherNode start="(442, 3)" end="(442, 6)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;⊢ (l₁.zip l₂).unzip = (l₁, l₂)" state_after="case fst.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : α&#10;⊢ (l₁.zip l₂).unzip.fst[i✝]? = some a✝ ↔ (l₁, l₂).fst[i✝]? = some a✝&#10;&#10;case snd.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : β&#10;⊢ (l₁.zip l₂).unzip.snd[i✝]? = some a✝ ↔ (l₁, l₂).snd[i✝]? = some a✝" tactic="ext">
                    <AtomNode start="(442, 3)" end="(442, 6)" leading="" trailing="&#10;  " val="ext"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(443, 3)" end="(443, 41)" kind="Lean.cdot" state_before="case fst.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : α&#10;⊢ (l₁.zip l₂).unzip.fst[i✝]? = some a✝ ↔ (l₁, l₂).fst[i✝]? = some a✝&#10;&#10;case snd.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : β&#10;⊢ (l₁.zip l₂).unzip.snd[i✝]? = some a✝ ↔ (l₁, l₂).snd[i✝]? = some a✝" state_after="case snd.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : β&#10;⊢ (l₁.zip l₂).unzip.snd[i✝]? = some a✝ ↔ (l₁, l₂).snd[i✝]? = some a✝" tactic="· rw [unzip_zip_left (Nat.le_of_eq h)]">
                    <OtherNode start="(443, 3)" end="(443, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(443, 3)" end="(443, 4)" kind="patternIgnore">
                        <OtherNode start="(443, 3)" end="(443, 4)" kind="token.«· »">
                          <AtomNode start="(443, 3)" end="(443, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(443, 5)" end="(443, 41)">
                      <TacticTacticseq1IndentedNode start="(443, 5)" end="(443, 41)">
                        <NullNode start="(443, 5)" end="(443, 41)">
                          <OtherNode start="(443, 5)" end="(443, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="case fst.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : α&#10;⊢ (l₁.zip l₂).unzip.fst[i✝]? = some a✝ ↔ (l₁, l₂).fst[i✝]? = some a✝" state_after="no goals" tactic="rw [unzip_zip_left (Nat.le_of_eq h)]">
                            <AtomNode start="(443, 5)" end="(443, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(443, 8)" end="(443, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(443, 8)" end="(443, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(443, 9)" end="(443, 40)">
                                <OtherNode start="(443, 9)" end="(443, 40)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(443, 9)" end="(443, 40)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(443, 9)" end="(443, 23)" leading="" trailing=" " raw_val="unzip_zip_left" val="unzip_zip_left" full_name="List.unzip_zip_left" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(426, 9)" def_end="(426, 23)"/>
                                    <NullNode start="(443, 24)" end="(443, 40)">
                                      <OtherNode start="(443, 24)" end="(443, 40)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(443, 24)" end="(443, 25)" leading="" trailing="" val="("/>
                                        <OtherNode start="(443, 25)" end="(443, 39)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(443, 25)" end="(443, 37)" leading="" trailing=" " raw_val="Nat.le_of_eq" val="Nat.le_of_eq" full_name="Nat.le_of_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          <NullNode start="(443, 38)" end="(443, 39)">
                                            <IdentNode start="(443, 38)" end="(443, 39)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(443, 39)" end="(443, 40)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(443, 40)" end="(443, 41)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(444, 3)" end="(444, 47)" kind="Lean.cdot" state_before="case snd.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : β&#10;⊢ (l₁.zip l₂).unzip.snd[i✝]? = some a✝ ↔ (l₁, l₂).snd[i✝]? = some a✝" state_after="no goals" tactic="· rw [unzip_zip_right (Nat.le_of_eq h.symm)]">
                    <OtherNode start="(444, 3)" end="(444, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(444, 3)" end="(444, 4)" kind="patternIgnore">
                        <OtherNode start="(444, 3)" end="(444, 4)" kind="token.«· »">
                          <AtomNode start="(444, 3)" end="(444, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(444, 5)" end="(444, 47)">
                      <TacticTacticseq1IndentedNode start="(444, 5)" end="(444, 47)">
                        <NullNode start="(444, 5)" end="(444, 47)">
                          <OtherNode start="(444, 5)" end="(444, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="case snd.h.a&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ : List α&#10;l₂ : List β&#10;h : l₁.length = l₂.length&#10;i✝ : Nat&#10;a✝ : β&#10;⊢ (l₁.zip l₂).unzip.snd[i✝]? = some a✝ ↔ (l₁, l₂).snd[i✝]? = some a✝" state_after="no goals" tactic="rw [unzip_zip_right (Nat.le_of_eq h.symm)]">
                            <AtomNode start="(444, 5)" end="(444, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(444, 8)" end="(444, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(444, 8)" end="(444, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(444, 9)" end="(444, 46)">
                                <OtherNode start="(444, 9)" end="(444, 46)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(444, 9)" end="(444, 46)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(444, 9)" end="(444, 24)" leading="" trailing=" " raw_val="unzip_zip_right" val="unzip_zip_right" full_name="List.unzip_zip_right" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(433, 9)" def_end="(433, 24)"/>
                                    <NullNode start="(444, 25)" end="(444, 46)">
                                      <OtherNode start="(444, 25)" end="(444, 46)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(444, 25)" end="(444, 26)" leading="" trailing="" val="("/>
                                        <OtherNode start="(444, 26)" end="(444, 45)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(444, 26)" end="(444, 38)" leading="" trailing=" " raw_val="Nat.le_of_eq" val="Nat.le_of_eq" full_name="Nat.le_of_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          <NullNode start="(444, 39)" end="(444, 45)">
                                            <IdentNode start="(444, 39)" end="(444, 45)" leading="" trailing="" raw_val="h.symm" val="h.symm"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(444, 45)" end="(444, 46)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(444, 46)" end="(444, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(446, 1)" end="(448, 82)" name="zip_of_prod" full_name="List.zip_of_prod">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(446, 1)" end="(448, 82)" name="zip_of_prod" full_name="List.zip_of_prod" _is_private_decl="False">
        <AtomNode start="(446, 1)" end="(446, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(446, 9)" end="(446, 20)">
          <IdentNode start="(446, 9)" end="(446, 20)" leading="" trailing=" " raw_val="zip_of_prod" val="zip_of_prod"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(446, 21)" end="(447, 48)">
          <NullNode start="(446, 21)" end="(447, 32)">
            <OtherNode start="(446, 21)" end="(446, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(446, 21)" end="(446, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(446, 22)" end="(446, 23)">
                <IdentNode start="(446, 22)" end="(446, 23)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(446, 24)" end="(446, 32)">
                <AtomNode start="(446, 24)" end="(446, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 26)" end="(446, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(446, 26)" end="(446, 30)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(446, 31)" end="(446, 32)">
                    <IdentNode start="(446, 31)" end="(446, 32)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(446, 32)" end="(446, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(446, 34)" end="(446, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(446, 34)" end="(446, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(446, 35)" end="(446, 37)">
                <IdentNode start="(446, 35)" end="(446, 37)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(446, 38)" end="(446, 46)">
                <AtomNode start="(446, 38)" end="(446, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 40)" end="(446, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(446, 40)" end="(446, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(446, 45)" end="(446, 46)">
                    <IdentNode start="(446, 45)" end="(446, 46)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(446, 46)" end="(446, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(446, 48)" end="(446, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(446, 48)" end="(446, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(446, 49)" end="(446, 51)">
                <IdentNode start="(446, 49)" end="(446, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(446, 52)" end="(446, 66)">
                <AtomNode start="(446, 52)" end="(446, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 54)" end="(446, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(446, 54)" end="(446, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(446, 59)" end="(446, 66)">
                    <OtherNode start="(446, 59)" end="(446, 66)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(446, 59)" end="(446, 60)" leading="" trailing="" val="("/>
                      <OtherNode start="(446, 60)" end="(446, 65)" kind="«term_×_»">
                        <IdentNode start="(446, 60)" end="(446, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(446, 62)" end="(446, 63)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(446, 64)" end="(446, 65)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(446, 65)" end="(446, 66)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(446, 66)" end="(446, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(446, 68)" end="(446, 94)">
              <AtomNode start="(446, 68)" end="(446, 69)" leading="" trailing="" val="("/>
              <NullNode start="(446, 69)" end="(446, 71)">
                <IdentNode start="(446, 69)" end="(446, 71)" leading="" trailing=" " raw_val="hl" val="hl"/>
              </NullNode>
              <NullNode start="(446, 72)" end="(446, 93)">
                <AtomNode start="(446, 72)" end="(446, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 74)" end="(446, 93)" kind="«term_=_»">
                  <OtherNode start="(446, 74)" end="(446, 89)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(446, 74)" end="(446, 80)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                    <NullNode start="(446, 81)" end="(446, 89)">
                      <IdentNode start="(446, 81)" end="(446, 89)" leading="" trailing=" " raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(446, 90)" end="(446, 91)" leading="" trailing=" " val="="/>
                  <IdentNode start="(446, 92)" end="(446, 93)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(446, 93)" end="(446, 94)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(447, 5)" end="(447, 32)">
              <AtomNode start="(447, 5)" end="(447, 6)" leading="" trailing="" val="("/>
              <NullNode start="(447, 6)" end="(447, 8)">
                <IdentNode start="(447, 6)" end="(447, 8)" leading="" trailing=" " raw_val="hr" val="hr"/>
              </NullNode>
              <NullNode start="(447, 9)" end="(447, 31)">
                <AtomNode start="(447, 9)" end="(447, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(447, 11)" end="(447, 31)" kind="«term_=_»">
                  <OtherNode start="(447, 11)" end="(447, 26)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(447, 11)" end="(447, 17)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                    <NullNode start="(447, 18)" end="(447, 26)">
                      <IdentNode start="(447, 18)" end="(447, 26)" leading="" trailing=" " raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(447, 27)" end="(447, 28)" leading="" trailing=" " val="="/>
                  <IdentNode start="(447, 29)" end="(447, 31)" leading="" trailing="" raw_val="l'" val="l'"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(447, 31)" end="(447, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(447, 33)" end="(447, 48)">
            <AtomNode start="(447, 33)" end="(447, 34)" leading="" trailing=" " val=":"/>
            <OtherNode start="(447, 35)" end="(447, 48)" kind="«term_=_»">
              <IdentNode start="(447, 35)" end="(447, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              <AtomNode start="(447, 38)" end="(447, 39)" leading="" trailing=" " val="="/>
              <OtherNode start="(447, 40)" end="(447, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(447, 40)" end="(447, 45)" leading="" trailing=" " raw_val="l.zip" val="l.zip"/>
                <NullNode start="(447, 46)" end="(447, 48)">
                  <IdentNode start="(447, 46)" end="(447, 48)" leading="" trailing=" " raw_val="l'" val="l'"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(447, 49)" end="(448, 82)">
          <AtomNode start="(447, 49)" end="(447, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(447, 52)" end="(448, 82)">
            <AtomNode start="(447, 52)" end="(447, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(448, 3)" end="(448, 82)">
              <TacticTacticseq1IndentedNode start="(448, 3)" end="(448, 82)">
                <NullNode start="(448, 3)" end="(448, 82)">
                  <OtherNode start="(448, 3)" end="(448, 82)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;l' : List β&#10;xs : List (α × β)&#10;hl : map Prod.fst xs = l&#10;hr : map Prod.snd xs = l'&#10;⊢ xs = l.zip l'" state_after="no goals" tactic="rw [← hl, ← hr, ← zip_unzip xs, ← unzip_fst, ← unzip_snd, zip_unzip, zip_unzip]">
                    <AtomNode start="(448, 3)" end="(448, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(448, 6)" end="(448, 82)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(448, 6)" end="(448, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(448, 7)" end="(448, 81)">
                        <OtherNode start="(448, 7)" end="(448, 11)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(448, 7)" end="(448, 8)">
                            <OtherNode start="(448, 7)" end="(448, 8)" kind="patternIgnore">
                              <OtherNode start="(448, 7)" end="(448, 8)" kind="token.«← »">
                                <AtomNode start="(448, 7)" end="(448, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(448, 9)" end="(448, 11)" leading="" trailing="" raw_val="hl" val="hl"/>
                        </OtherNode>
                        <AtomNode start="(448, 11)" end="(448, 12)" leading="" trailing=" " val=","/>
                        <OtherNode start="(448, 13)" end="(448, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(448, 13)" end="(448, 14)">
                            <OtherNode start="(448, 13)" end="(448, 14)" kind="patternIgnore">
                              <OtherNode start="(448, 13)" end="(448, 14)" kind="token.«← »">
                                <AtomNode start="(448, 13)" end="(448, 14)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(448, 15)" end="(448, 17)" leading="" trailing="" raw_val="hr" val="hr"/>
                        </OtherNode>
                        <AtomNode start="(448, 17)" end="(448, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(448, 19)" end="(448, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(448, 19)" end="(448, 20)">
                            <OtherNode start="(448, 19)" end="(448, 20)" kind="patternIgnore">
                              <OtherNode start="(448, 19)" end="(448, 20)" kind="token.«← »">
                                <AtomNode start="(448, 19)" end="(448, 20)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <OtherNode start="(448, 21)" end="(448, 33)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(448, 21)" end="(448, 30)" leading="" trailing=" " raw_val="zip_unzip" val="zip_unzip" full_name="List.zip_unzip" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(422, 9)" def_end="(422, 18)"/>
                            <NullNode start="(448, 31)" end="(448, 33)">
                              <IdentNode start="(448, 31)" end="(448, 33)" leading="" trailing="" raw_val="xs" val="xs"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(448, 33)" end="(448, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(448, 35)" end="(448, 46)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(448, 35)" end="(448, 36)">
                            <OtherNode start="(448, 35)" end="(448, 36)" kind="patternIgnore">
                              <OtherNode start="(448, 35)" end="(448, 36)" kind="token.«← »">
                                <AtomNode start="(448, 35)" end="(448, 36)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(448, 37)" end="(448, 46)" leading="" trailing="" raw_val="unzip_fst" val="unzip_fst" full_name="List.unzip_fst" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(411, 17)" def_end="(411, 26)"/>
                        </OtherNode>
                        <AtomNode start="(448, 46)" end="(448, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(448, 48)" end="(448, 59)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(448, 48)" end="(448, 49)">
                            <OtherNode start="(448, 48)" end="(448, 49)" kind="patternIgnore">
                              <OtherNode start="(448, 48)" end="(448, 49)" kind="token.«← »">
                                <AtomNode start="(448, 48)" end="(448, 49)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(448, 50)" end="(448, 59)" leading="" trailing="" raw_val="unzip_snd" val="unzip_snd" full_name="List.unzip_snd" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(414, 17)" def_end="(414, 26)"/>
                        </OtherNode>
                        <AtomNode start="(448, 59)" end="(448, 60)" leading="" trailing=" " val=","/>
                        <OtherNode start="(448, 61)" end="(448, 70)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(448, 61)" end="(448, 70)" leading="" trailing="" raw_val="zip_unzip" val="zip_unzip" full_name="List.zip_unzip" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(422, 9)" def_end="(422, 18)"/>
                        </OtherNode>
                        <AtomNode start="(448, 70)" end="(448, 71)" leading="" trailing=" " val=","/>
                        <OtherNode start="(448, 72)" end="(448, 81)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(448, 72)" end="(448, 81)" leading="" trailing="" raw_val="zip_unzip" val="zip_unzip" full_name="List.zip_unzip" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean" def_start="(422, 9)" def_end="(422, 18)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(448, 81)" end="(448, 82)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(450, 1)" end="(451, 7)" name="tail_zip_fst" full_name="List.tail_zip_fst">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(450, 1)" end="(451, 7)" name="tail_zip_fst" full_name="List.tail_zip_fst" _is_private_decl="False">
        <AtomNode start="(450, 1)" end="(450, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(450, 9)" end="(450, 21)">
          <IdentNode start="(450, 9)" end="(450, 21)" leading="" trailing=" " raw_val="tail_zip_fst" val="tail_zip_fst"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(450, 22)" end="(450, 74)">
          <NullNode start="(450, 22)" end="(450, 40)">
            <OtherNode start="(450, 22)" end="(450, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(450, 22)" end="(450, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(450, 23)" end="(450, 24)">
                <IdentNode start="(450, 23)" end="(450, 24)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(450, 25)" end="(450, 39)">
                <AtomNode start="(450, 25)" end="(450, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(450, 27)" end="(450, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(450, 27)" end="(450, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(450, 32)" end="(450, 39)">
                    <OtherNode start="(450, 32)" end="(450, 39)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(450, 32)" end="(450, 33)" leading="" trailing="" val="("/>
                      <OtherNode start="(450, 33)" end="(450, 38)" kind="«term_×_»">
                        <IdentNode start="(450, 33)" end="(450, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(450, 35)" end="(450, 36)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(450, 37)" end="(450, 38)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(450, 38)" end="(450, 39)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(450, 39)" end="(450, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(450, 41)" end="(450, 74)">
            <AtomNode start="(450, 41)" end="(450, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(450, 43)" end="(450, 74)" kind="«term_=_»">
              <OtherNode start="(450, 43)" end="(450, 57)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(450, 43)" end="(450, 52)" kind="Lean.Parser.Term.proj">
                  <IdentNode start="(450, 43)" end="(450, 50)" leading="" trailing="" raw_val="l.unzip" val="l.unzip"/>
                  <AtomNode start="(450, 50)" end="(450, 51)" leading="" trailing="" val="."/>
                  <OtherNode start="(450, 51)" end="(450, 52)" kind="fieldIdx">
                    <AtomNode start="(450, 51)" end="(450, 52)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(450, 52)" end="(450, 53)" leading="" trailing="" val="."/>
                <IdentNode start="(450, 53)" end="(450, 57)" leading="" trailing=" " raw_val="tail" val="tail" full_name="List.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(450, 58)" end="(450, 59)" leading="" trailing=" " val="="/>
              <OtherNode start="(450, 60)" end="(450, 74)" kind="Lean.Parser.Term.proj">
                <IdentNode start="(450, 60)" end="(450, 72)" leading="" trailing="" raw_val="l.tail.unzip" val="l.tail.unzip"/>
                <AtomNode start="(450, 72)" end="(450, 73)" leading="" trailing="" val="."/>
                <OtherNode start="(450, 73)" end="(450, 74)" kind="fieldIdx">
                  <AtomNode start="(450, 73)" end="(450, 74)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(450, 75)" end="(451, 7)">
          <AtomNode start="(450, 75)" end="(450, 77)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(450, 78)" end="(451, 7)">
            <AtomNode start="(450, 78)" end="(450, 80)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(451, 3)" end="(451, 7)">
              <TacticTacticseq1IndentedNode start="(451, 3)" end="(451, 7)">
                <NullNode start="(451, 3)" end="(451, 7)">
                  <OtherNode start="(451, 3)" end="(451, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List (α × β)&#10;⊢ l.unzip.fst.tail = l.tail.unzip.fst" state_after="no goals" tactic="simp">
                    <AtomNode start="(451, 3)" end="(451, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(453, 1)" end="(454, 7)" name="tail_zip_snd" full_name="List.tail_zip_snd">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(453, 1)" end="(454, 7)" name="tail_zip_snd" full_name="List.tail_zip_snd" _is_private_decl="False">
        <AtomNode start="(453, 1)" end="(453, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(453, 9)" end="(453, 21)">
          <IdentNode start="(453, 9)" end="(453, 21)" leading="" trailing=" " raw_val="tail_zip_snd" val="tail_zip_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(453, 22)" end="(453, 74)">
          <NullNode start="(453, 22)" end="(453, 40)">
            <OtherNode start="(453, 22)" end="(453, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(453, 22)" end="(453, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(453, 23)" end="(453, 24)">
                <IdentNode start="(453, 23)" end="(453, 24)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(453, 25)" end="(453, 39)">
                <AtomNode start="(453, 25)" end="(453, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(453, 27)" end="(453, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(453, 27)" end="(453, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(453, 32)" end="(453, 39)">
                    <OtherNode start="(453, 32)" end="(453, 39)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(453, 32)" end="(453, 33)" leading="" trailing="" val="("/>
                      <OtherNode start="(453, 33)" end="(453, 38)" kind="«term_×_»">
                        <IdentNode start="(453, 33)" end="(453, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(453, 35)" end="(453, 36)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(453, 37)" end="(453, 38)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(453, 38)" end="(453, 39)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(453, 39)" end="(453, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(453, 41)" end="(453, 74)">
            <AtomNode start="(453, 41)" end="(453, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(453, 43)" end="(453, 74)" kind="«term_=_»">
              <OtherNode start="(453, 43)" end="(453, 57)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(453, 43)" end="(453, 52)" kind="Lean.Parser.Term.proj">
                  <IdentNode start="(453, 43)" end="(453, 50)" leading="" trailing="" raw_val="l.unzip" val="l.unzip"/>
                  <AtomNode start="(453, 50)" end="(453, 51)" leading="" trailing="" val="."/>
                  <OtherNode start="(453, 51)" end="(453, 52)" kind="fieldIdx">
                    <AtomNode start="(453, 51)" end="(453, 52)" leading="" trailing="" val="2"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(453, 52)" end="(453, 53)" leading="" trailing="" val="."/>
                <IdentNode start="(453, 53)" end="(453, 57)" leading="" trailing=" " raw_val="tail" val="tail" full_name="List.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(453, 58)" end="(453, 59)" leading="" trailing=" " val="="/>
              <OtherNode start="(453, 60)" end="(453, 74)" kind="Lean.Parser.Term.proj">
                <IdentNode start="(453, 60)" end="(453, 72)" leading="" trailing="" raw_val="l.tail.unzip" val="l.tail.unzip"/>
                <AtomNode start="(453, 72)" end="(453, 73)" leading="" trailing="" val="."/>
                <OtherNode start="(453, 73)" end="(453, 74)" kind="fieldIdx">
                  <AtomNode start="(453, 73)" end="(453, 74)" leading="" trailing=" " val="2"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(453, 75)" end="(454, 7)">
          <AtomNode start="(453, 75)" end="(453, 77)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(453, 78)" end="(454, 7)">
            <AtomNode start="(453, 78)" end="(453, 80)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(454, 3)" end="(454, 7)">
              <TacticTacticseq1IndentedNode start="(454, 3)" end="(454, 7)">
                <NullNode start="(454, 3)" end="(454, 7)">
                  <OtherNode start="(454, 3)" end="(454, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List (α × β)&#10;⊢ l.unzip.snd.tail = l.tail.unzip.snd" state_after="no goals" tactic="simp">
                    <AtomNode start="(454, 3)" end="(454, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(456, 1)" end="(458, 16)" name="unzip_replicate" full_name="List.unzip_replicate">
      <CommandDeclmodifiersNode start="(456, 1)" end="(456, 8)">
        <NullNode/>
        <NullNode start="(456, 1)" end="(456, 8)">
          <OtherNode start="(456, 1)" end="(456, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(456, 1)" end="(456, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(456, 3)" end="(456, 7)">
              <OtherNode start="(456, 3)" end="(456, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(456, 3)" end="(456, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(456, 3)" end="(456, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(456, 7)" end="(456, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(456, 9)" end="(458, 16)" name="unzip_replicate" full_name="List.unzip_replicate" _is_private_decl="False">
        <AtomNode start="(456, 9)" end="(456, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(456, 17)" end="(456, 32)">
          <IdentNode start="(456, 17)" end="(456, 32)" leading="" trailing=" " raw_val="unzip_replicate" val="unzip_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(456, 33)" end="(457, 64)">
          <NullNode start="(456, 33)" end="(456, 58)">
            <OtherNode start="(456, 33)" end="(456, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(456, 33)" end="(456, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(456, 34)" end="(456, 35)">
                <IdentNode start="(456, 34)" end="(456, 35)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(456, 36)" end="(456, 41)">
                <AtomNode start="(456, 36)" end="(456, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(456, 38)" end="(456, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(456, 41)" end="(456, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(456, 43)" end="(456, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(456, 43)" end="(456, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(456, 44)" end="(456, 45)">
                <IdentNode start="(456, 44)" end="(456, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(456, 46)" end="(456, 49)">
                <AtomNode start="(456, 46)" end="(456, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(456, 48)" end="(456, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(456, 49)" end="(456, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(456, 51)" end="(456, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(456, 51)" end="(456, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(456, 52)" end="(456, 53)">
                <IdentNode start="(456, 52)" end="(456, 53)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(456, 54)" end="(456, 57)">
                <AtomNode start="(456, 54)" end="(456, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(456, 56)" end="(456, 57)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(456, 57)" end="(456, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(456, 59)" end="(457, 64)">
            <AtomNode start="(456, 59)" end="(456, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(457, 5)" end="(457, 64)" kind="«term_=_»">
              <OtherNode start="(457, 5)" end="(457, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(457, 5)" end="(457, 10)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="List.unzip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(457, 11)" end="(457, 31)">
                  <OtherNode start="(457, 11)" end="(457, 31)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(457, 11)" end="(457, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(457, 12)" end="(457, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(457, 12)" end="(457, 21)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(457, 22)" end="(457, 30)">
                        <IdentNode start="(457, 22)" end="(457, 23)" leading="" trailing=" " raw_val="n" val="n"/>
                        <OtherNode start="(457, 24)" end="(457, 30)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(457, 24)" end="(457, 25)" leading="" trailing="" val="("/>
                          <NullNode start="(457, 25)" end="(457, 29)">
                            <IdentNode start="(457, 25)" end="(457, 26)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(457, 26)" end="(457, 27)" leading="" trailing=" " val=","/>
                            <NullNode start="(457, 28)" end="(457, 29)">
                              <IdentNode start="(457, 28)" end="(457, 29)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(457, 29)" end="(457, 30)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(457, 30)" end="(457, 31)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(457, 32)" end="(457, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(457, 34)" end="(457, 64)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(457, 34)" end="(457, 35)" leading="" trailing="" val="("/>
                <NullNode start="(457, 35)" end="(457, 63)">
                  <OtherNode start="(457, 35)" end="(457, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(457, 35)" end="(457, 44)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(457, 45)" end="(457, 48)">
                      <IdentNode start="(457, 45)" end="(457, 46)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(457, 47)" end="(457, 48)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(457, 48)" end="(457, 49)" leading="" trailing=" " val=","/>
                  <NullNode start="(457, 50)" end="(457, 63)">
                    <OtherNode start="(457, 50)" end="(457, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(457, 50)" end="(457, 59)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(457, 60)" end="(457, 63)">
                        <IdentNode start="(457, 60)" end="(457, 61)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(457, 62)" end="(457, 63)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </NullNode>
                <AtomNode start="(457, 63)" end="(457, 64)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(457, 65)" end="(458, 16)">
          <AtomNode start="(457, 65)" end="(457, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(457, 68)" end="(458, 16)">
            <AtomNode start="(457, 68)" end="(457, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(458, 3)" end="(458, 16)">
              <TacticTacticseq1IndentedNode start="(458, 3)" end="(458, 16)">
                <NullNode start="(458, 3)" end="(458, 16)">
                  <OtherNode start="(458, 3)" end="(458, 16)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;a : α&#10;b : β&#10;⊢ (replicate n (a, b)).unzip = (replicate n a, replicate n b)" state_after="no goals" tactic="ext1 &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(458, 3)" end="(458, 7)" kind="Lean.Elab.Tactic.Ext.tacticExt1___">
                      <AtomNode start="(458, 3)" end="(458, 7)" leading="" trailing=" " val="ext1"/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(458, 8)" end="(458, 11)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(458, 12)" end="(458, 16)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(458, 12)" end="(458, 16)" leading="" trailing="&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 1)" end="(14, 3)" text="# Lemmas about `List.zip`, `List.zipWith`, `List.zipWithAll`, and `List.unzip`.&#10;-/"/>
    <Comment start="(16, 38)" end="(17, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(17, 39)" end="(19, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(23, 1)" end="(23, 18)" text="## Zippers -/"/>
    <Comment start="(25, 1)" end="(25, 19)" text="### zipWith -/"/>
    <Comment start="(45, 1)" end="(48, 3)" text="See also `getElem?_zipWith'` for a variant&#10;using `Option.map` and `Option.bind` rather than a `match`.&#10;-/"/>
    <Comment start="(60, 1)" end="(60, 97)" text="Variant of `getElem?_zipWith` using `Option.map` and `Option.bind` rather than a `match`. -/"/>
    <Comment start="(227, 1)" end="(227, 115)" text="See also `List.zipWith_replicate` in `Init.Data.List.TakeDrop` for a generalization with different lengths. -/"/>
    <Comment start="(250, 1)" end="(250, 15)" text="### zip -/"/>
    <Comment start="(347, 1)" end="(347, 111)" text="See also `List.zip_replicate` in `Init.Data.List.TakeDrop` for a generalization with different lengths. -/"/>
    <Comment start="(354, 1)" end="(354, 22)" text="### zipWithAll -/"/>
    <Comment start="(409, 1)" end="(409, 17)" text="### unzip -/"/>
    <Comment start="(421, 1)" end="(422, 1)" text="-- The argument `l` is explicit so we can rewrite from right to left.&#10;"/>
  </Comments>
</TracedFile>
