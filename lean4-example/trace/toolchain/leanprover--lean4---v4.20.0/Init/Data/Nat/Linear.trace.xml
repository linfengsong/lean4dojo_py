<TracedFile path="src/lean/Init/Data/Nat/Linear.lean" md5="8f9dfabcfc1e6271220764b2f620fca6">
  <FileNode start="(1, 1)" end="(560, 8)">
    <ModuleHeaderNode start="(6, 1)" end="(11, 24)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(11, 24)">
        <ModuleImportNode start="(9, 1)" end="(9, 20)" module="Init.ByCases" path="src/lean/Init/ByCases.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 20)" leading="" trailing="&#10;" raw_val="Init.ByCases" val="Init.ByCases"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 22)" module="Init.Data.Prod" path="src/lean/Init/Data/Prod.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 22)" leading="" trailing="&#10;" raw_val="Init.Data.Prod" val="Init.Data.Prod"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 24)" module="Init.Data.RArray" path="src/lean/Init/Data/RArray.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 24)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.RArray" val="Init.Data.RArray"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandNamespaceNode start="(13, 1)" end="(13, 21)" name="Nat.Linear">
      <AtomNode start="(13, 1)" end="(13, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(13, 11)" end="(13, 21)" leading="" trailing="&#10;&#10;" raw_val="Nat.Linear" val="Nat.Linear"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(15, 1)" end="(17, 3)" comment="Helper definitions and theorems for constructing linear arithmetic proofs.&#10;-/">
      <AtomNode start="(15, 1)" end="(15, 4)" leading="" trailing="&#10;  " val="/-!"/>
      <AtomNode start="(16, 3)" end="(17, 3)" leading="" trailing="&#10;&#10;" val="Helper definitions and theorems for constructing linear arithmetic proofs.&#10;-/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(19, 1)" end="(19, 18)" name="Var" full_name="Nat.Linear.Var">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(19, 1)" end="(19, 18)" name="Var">
        <AtomNode start="(19, 1)" end="(19, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(19, 8)" end="(19, 11)">
          <IdentNode start="(19, 8)" end="(19, 11)" leading="" trailing=" " raw_val="Var" val="Var"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(19, 12)" end="(19, 18)">
          <AtomNode start="(19, 12)" end="(19, 14)" leading="" trailing=" " val=":="/>
          <IdentNode start="(19, 15)" end="(19, 18)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(21, 1)" end="(21, 34)" name="Context" full_name="Nat.Linear.Context">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(21, 1)" end="(21, 34)" name="Context">
        <AtomNode start="(21, 1)" end="(21, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(21, 8)" end="(21, 15)">
          <IdentNode start="(21, 8)" end="(21, 15)" leading="" trailing=" " raw_val="Context" val="Context"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(21, 16)" end="(21, 34)">
          <AtomNode start="(21, 16)" end="(21, 18)" leading="" trailing=" " val=":="/>
          <OtherNode start="(21, 19)" end="(21, 34)" kind="Lean.Parser.Term.app">
            <IdentNode start="(21, 19)" end="(21, 30)" leading="" trailing=" " raw_val="Lean.RArray" val="Lean.RArray" full_name="Lean.RArray" mod_name="Init.Data.RArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/RArray.lean"/>
            <NullNode start="(21, 31)" end="(21, 34)">
              <IdentNode start="(21, 31)" end="(21, 34)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(23, 1)" end="(26, 26)" name="fixedVar" full_name="Nat.Linear.fixedVar">
      <CommandDeclmodifiersNode start="(23, 1)" end="(25, 49)">
        <NullNode start="(23, 1)" end="(25, 49)">
          <CommandDoccommentNode start="(23, 1)" end="(25, 49)" comment="When encoding polynomials. We use `fixedVar` for encoding numerals.&#10;  The denotation of `fixedVar` is always `1`. -/">
            <AtomNode start="(23, 1)" end="(23, 4)" leading="" trailing="&#10;  " val="/--"/>
            <AtomNode start="(24, 3)" end="(25, 49)" leading="" trailing="&#10;" val="When encoding polynomials. We use `fixedVar` for encoding numerals.&#10;  The denotation of `fixedVar` is always `1`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(26, 1)" end="(26, 26)" name="fixedVar">
        <AtomNode start="(26, 1)" end="(26, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(26, 5)" end="(26, 13)">
          <IdentNode start="(26, 5)" end="(26, 13)" leading="" trailing=" " raw_val="fixedVar" val="fixedVar"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(26, 14)" end="(26, 26)">
          <AtomNode start="(26, 14)" end="(26, 16)" leading="" trailing=" " val=":="/>
          <OtherNode start="(26, 17)" end="(26, 26)" kind="num">
            <AtomNode start="(26, 17)" end="(26, 26)" leading="" trailing=" -- Any big number should work here&#10;&#10;" val="100000000"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(28, 1)" end="(29, 42)" name="Var.denote" full_name="Nat.Linear.Var.denote">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(28, 1)" end="(29, 42)" name="Var.denote">
        <AtomNode start="(28, 1)" end="(28, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(28, 5)" end="(28, 15)">
          <IdentNode start="(28, 5)" end="(28, 15)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(28, 16)" end="(28, 47)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(28, 16)" end="(28, 41)">
            <TermExplicitbinderNode start="(28, 16)" end="(28, 31)">
              <AtomNode start="(28, 16)" end="(28, 17)" leading="" trailing="" val="("/>
              <NullNode start="(28, 17)" end="(28, 20)">
                <IdentNode start="(28, 17)" end="(28, 20)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(28, 21)" end="(28, 30)">
                <AtomNode start="(28, 21)" end="(28, 22)" leading="" trailing=" " val=":"/>
                <IdentNode start="(28, 23)" end="(28, 30)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(28, 30)" end="(28, 31)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(28, 32)" end="(28, 41)">
              <AtomNode start="(28, 32)" end="(28, 33)" leading="" trailing="" val="("/>
              <NullNode start="(28, 33)" end="(28, 34)">
                <IdentNode start="(28, 33)" end="(28, 34)" leading="" trailing=" " raw_val="v" val="v"/>
              </NullNode>
              <NullNode start="(28, 35)" end="(28, 40)">
                <AtomNode start="(28, 35)" end="(28, 36)" leading="" trailing=" " val=":"/>
                <IdentNode start="(28, 37)" end="(28, 40)" leading="" trailing="" raw_val="Var" val="Var" full_name="Nat.Linear.Var" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(19, 8)" def_end="(19, 11)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(28, 40)" end="(28, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(28, 42)" end="(28, 47)">
            <TermTypespecNode start="(28, 42)" end="(28, 47)">
              <AtomNode start="(28, 42)" end="(28, 43)" leading="" trailing=" " val=":"/>
              <IdentNode start="(28, 44)" end="(28, 47)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(28, 48)" end="(29, 42)">
          <AtomNode start="(28, 48)" end="(28, 50)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(29, 3)" end="(29, 42)" kind="boolIfThenElse">
            <AtomNode start="(29, 3)" end="(29, 6)" leading="" trailing=" " val="bif"/>
            <OtherNode start="(29, 7)" end="(29, 20)" kind="«term_==_»">
              <IdentNode start="(29, 7)" end="(29, 8)" leading="" trailing=" " raw_val="v" val="v"/>
              <AtomNode start="(29, 9)" end="(29, 11)" leading="" trailing=" " val="=="/>
              <IdentNode start="(29, 12)" end="(29, 20)" leading="" trailing=" " raw_val="fixedVar" val="fixedVar" full_name="Nat.Linear.fixedVar" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(26, 5)" def_end="(26, 13)"/>
            </OtherNode>
            <AtomNode start="(29, 21)" end="(29, 25)" leading="" trailing=" " val="then"/>
            <OtherNode start="(29, 26)" end="(29, 27)" kind="num">
              <AtomNode start="(29, 26)" end="(29, 27)" leading="" trailing=" " val="1"/>
            </OtherNode>
            <AtomNode start="(29, 28)" end="(29, 32)" leading="" trailing=" " val="else"/>
            <OtherNode start="(29, 33)" end="(29, 42)" kind="Lean.Parser.Term.app">
              <IdentNode start="(29, 33)" end="(29, 40)" leading="" trailing=" " raw_val="ctx.get" val="ctx.get"/>
              <NullNode start="(29, 41)" end="(29, 42)">
                <IdentNode start="(29, 41)" end="(29, 42)" leading="" trailing="&#10;&#10;" raw_val="v" val="v"/>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(31, 1)" end="(37, 26)" name="Expr" full_name="Nat.Linear.Expr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInductiveNode start="(31, 1)" end="(37, 26)" name="Expr">
        <AtomNode start="(31, 1)" end="(31, 10)" leading="" trailing=" " val="inductive"/>
        <CommandDeclidNode start="(31, 11)" end="(31, 15)">
          <IdentNode start="(31, 11)" end="(31, 15)" leading="" trailing=" " raw_val="Expr" val="Expr"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <NullNode start="(31, 16)" end="(31, 21)">
          <AtomNode start="(31, 16)" end="(31, 21)" leading="" trailing="&#10;  " val="where"/>
        </NullNode>
        <NullNode start="(32, 3)" end="(36, 30)">
          <OtherNode start="(32, 3)" end="(32, 19)" kind="Lean.Parser.Command.ctor">
            <NullNode/>
            <AtomNode start="(32, 3)" end="(32, 4)" leading="" trailing=" " val="|"/>
            <CommandDeclmodifiersNode>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </CommandDeclmodifiersNode>
            <IdentNode start="(32, 5)" end="(32, 8)" leading="" trailing="  " raw_val="num" val="num"/>
            <OtherNode start="(32, 10)" end="(32, 19)" kind="Lean.Parser.Command.optDeclSig">
              <NullNode start="(32, 10)" end="(32, 19)">
                <TermExplicitbinderNode start="(32, 10)" end="(32, 19)">
                  <AtomNode start="(32, 10)" end="(32, 11)" leading="" trailing="" val="("/>
                  <NullNode start="(32, 11)" end="(32, 12)">
                    <IdentNode start="(32, 11)" end="(32, 12)" leading="" trailing=" " raw_val="v" val="v"/>
                  </NullNode>
                  <NullNode start="(32, 13)" end="(32, 18)">
                    <AtomNode start="(32, 13)" end="(32, 14)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(32, 15)" end="(32, 18)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(32, 18)" end="(32, 19)" leading="" trailing="&#10;  " val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(33, 3)" end="(33, 19)" kind="Lean.Parser.Command.ctor">
            <NullNode/>
            <AtomNode start="(33, 3)" end="(33, 4)" leading="" trailing=" " val="|"/>
            <CommandDeclmodifiersNode>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </CommandDeclmodifiersNode>
            <IdentNode start="(33, 5)" end="(33, 8)" leading="" trailing="  " raw_val="var" val="var"/>
            <OtherNode start="(33, 10)" end="(33, 19)" kind="Lean.Parser.Command.optDeclSig">
              <NullNode start="(33, 10)" end="(33, 19)">
                <TermExplicitbinderNode start="(33, 10)" end="(33, 19)">
                  <AtomNode start="(33, 10)" end="(33, 11)" leading="" trailing="" val="("/>
                  <NullNode start="(33, 11)" end="(33, 12)">
                    <IdentNode start="(33, 11)" end="(33, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                  <NullNode start="(33, 13)" end="(33, 18)">
                    <AtomNode start="(33, 13)" end="(33, 14)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(33, 15)" end="(33, 18)" leading="" trailing="" raw_val="Var" val="Var" full_name="Nat.Linear.Var" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(19, 8)" def_end="(19, 11)"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(33, 18)" end="(33, 19)" leading="" trailing="&#10;  " val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(34, 3)" end="(34, 22)" kind="Lean.Parser.Command.ctor">
            <NullNode/>
            <AtomNode start="(34, 3)" end="(34, 4)" leading="" trailing=" " val="|"/>
            <CommandDeclmodifiersNode>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </CommandDeclmodifiersNode>
            <IdentNode start="(34, 5)" end="(34, 8)" leading="" trailing="  " raw_val="add" val="add"/>
            <OtherNode start="(34, 10)" end="(34, 22)" kind="Lean.Parser.Command.optDeclSig">
              <NullNode start="(34, 10)" end="(34, 22)">
                <TermExplicitbinderNode start="(34, 10)" end="(34, 22)">
                  <AtomNode start="(34, 10)" end="(34, 11)" leading="" trailing="" val="("/>
                  <NullNode start="(34, 11)" end="(34, 14)">
                    <IdentNode start="(34, 11)" end="(34, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(34, 13)" end="(34, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                  <NullNode start="(34, 15)" end="(34, 21)">
                    <AtomNode start="(34, 15)" end="(34, 16)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(34, 17)" end="(34, 21)" leading="" trailing="" raw_val="Expr" val="Expr"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(34, 21)" end="(34, 22)" leading="" trailing="&#10;  " val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(35, 3)" end="(35, 30)" kind="Lean.Parser.Command.ctor">
            <NullNode/>
            <AtomNode start="(35, 3)" end="(35, 4)" leading="" trailing=" " val="|"/>
            <CommandDeclmodifiersNode>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </CommandDeclmodifiersNode>
            <IdentNode start="(35, 5)" end="(35, 9)" leading="" trailing=" " raw_val="mulL" val="mulL"/>
            <OtherNode start="(35, 10)" end="(35, 30)" kind="Lean.Parser.Command.optDeclSig">
              <NullNode start="(35, 10)" end="(35, 30)">
                <TermExplicitbinderNode start="(35, 10)" end="(35, 19)">
                  <AtomNode start="(35, 10)" end="(35, 11)" leading="" trailing="" val="("/>
                  <NullNode start="(35, 11)" end="(35, 12)">
                    <IdentNode start="(35, 11)" end="(35, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                  <NullNode start="(35, 13)" end="(35, 18)">
                    <AtomNode start="(35, 13)" end="(35, 14)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(35, 15)" end="(35, 18)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(35, 18)" end="(35, 19)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(35, 20)" end="(35, 30)">
                  <AtomNode start="(35, 20)" end="(35, 21)" leading="" trailing="" val="("/>
                  <NullNode start="(35, 21)" end="(35, 22)">
                    <IdentNode start="(35, 21)" end="(35, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode start="(35, 23)" end="(35, 29)">
                    <AtomNode start="(35, 23)" end="(35, 24)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(35, 25)" end="(35, 29)" leading="" trailing="" raw_val="Expr" val="Expr"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(35, 29)" end="(35, 30)" leading="" trailing="&#10;  " val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(36, 3)" end="(36, 30)" kind="Lean.Parser.Command.ctor">
            <NullNode/>
            <AtomNode start="(36, 3)" end="(36, 4)" leading="" trailing=" " val="|"/>
            <CommandDeclmodifiersNode>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </CommandDeclmodifiersNode>
            <IdentNode start="(36, 5)" end="(36, 9)" leading="" trailing=" " raw_val="mulR" val="mulR"/>
            <OtherNode start="(36, 10)" end="(36, 30)" kind="Lean.Parser.Command.optDeclSig">
              <NullNode start="(36, 10)" end="(36, 30)">
                <TermExplicitbinderNode start="(36, 10)" end="(36, 20)">
                  <AtomNode start="(36, 10)" end="(36, 11)" leading="" trailing="" val="("/>
                  <NullNode start="(36, 11)" end="(36, 12)">
                    <IdentNode start="(36, 11)" end="(36, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode start="(36, 13)" end="(36, 19)">
                    <AtomNode start="(36, 13)" end="(36, 14)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(36, 15)" end="(36, 19)" leading="" trailing="" raw_val="Expr" val="Expr"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(36, 19)" end="(36, 20)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(36, 21)" end="(36, 30)">
                  <AtomNode start="(36, 21)" end="(36, 22)" leading="" trailing="" val="("/>
                  <NullNode start="(36, 22)" end="(36, 23)">
                    <IdentNode start="(36, 22)" end="(36, 23)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                  <NullNode start="(36, 24)" end="(36, 29)">
                    <AtomNode start="(36, 24)" end="(36, 25)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(36, 26)" end="(36, 29)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(36, 29)" end="(36, 30)" leading="" trailing="&#10;  " val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <OtherNode start="(37, 3)" end="(37, 26)" kind="Lean.Parser.Command.optDeriving">
          <NullNode start="(37, 3)" end="(37, 26)">
            <AtomNode start="(37, 3)" end="(37, 11)" leading="" trailing=" " val="deriving"/>
            <NullNode start="(37, 12)" end="(37, 26)">
              <IdentNode start="(37, 12)" end="(37, 21)" leading="" trailing="" raw_val="Inhabited" val="Inhabited" full_name="Inhabited.default" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <AtomNode start="(37, 21)" end="(37, 22)" leading="" trailing=" " val=","/>
              <IdentNode start="(37, 23)" end="(37, 26)" leading="" trailing="&#10;&#10;" raw_val="BEq" val="BEq" full_name="BEq.mk" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </NullNode>
          </NullNode>
        </OtherNode>
      </CommandInductiveNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(39, 1)" end="(44, 42)" name="Expr.denote" full_name="Nat.Linear.Expr.denote">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(39, 1)" end="(44, 42)" name="Expr.denote">
        <AtomNode start="(39, 1)" end="(39, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(39, 5)" end="(39, 16)">
          <IdentNode start="(39, 5)" end="(39, 16)" leading="" trailing=" " raw_val="Expr.denote" val="Expr.denote"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(39, 17)" end="(39, 45)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(39, 17)" end="(39, 32)">
            <TermExplicitbinderNode start="(39, 17)" end="(39, 32)">
              <AtomNode start="(39, 17)" end="(39, 18)" leading="" trailing="" val="("/>
              <NullNode start="(39, 18)" end="(39, 21)">
                <IdentNode start="(39, 18)" end="(39, 21)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(39, 22)" end="(39, 31)">
                <AtomNode start="(39, 22)" end="(39, 23)" leading="" trailing=" " val=":"/>
                <IdentNode start="(39, 24)" end="(39, 31)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(39, 31)" end="(39, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(39, 33)" end="(39, 45)">
            <TermTypespecNode start="(39, 33)" end="(39, 45)">
              <AtomNode start="(39, 33)" end="(39, 34)" leading="" trailing=" " val=":"/>
              <OtherNode start="(39, 35)" end="(39, 45)" kind="Lean.Parser.Term.arrow">
                <IdentNode start="(39, 35)" end="(39, 39)" leading="" trailing=" " raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
                <AtomNode start="(39, 40)" end="(39, 41)" leading="" trailing=" " val="→"/>
                <IdentNode start="(39, 42)" end="(39, 45)" leading="" trailing="&#10;  " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvaleqnsNode start="(40, 3)" end="(44, 42)">
          <OtherNode start="(40, 3)" end="(44, 42)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(40, 3)" end="(44, 42)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(40, 3)" end="(44, 42)">
                <OtherNode start="(40, 3)" end="(40, 55)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(40, 3)" end="(40, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(40, 5)" end="(40, 13)">
                    <NullNode start="(40, 5)" end="(40, 13)">
                      <OtherNode start="(40, 5)" end="(40, 13)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(40, 5)" end="(40, 9)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(40, 5)" end="(40, 6)" leading="" trailing="" val="."/>
                          <IdentNode start="(40, 6)" end="(40, 9)" leading="" trailing=" " raw_val="add" val="add"/>
                        </OtherNode>
                        <NullNode start="(40, 10)" end="(40, 13)">
                          <IdentNode start="(40, 10)" end="(40, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(40, 12)" end="(40, 13)" leading="" trailing="  " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(40, 15)" end="(40, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(40, 18)" end="(40, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 18)" end="(40, 25)" leading="" trailing=" " raw_val="Nat.add" val="Nat.add" full_name="Nat.add" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(40, 26)" end="(40, 55)">
                      <OtherNode start="(40, 26)" end="(40, 40)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(40, 26)" end="(40, 27)" leading="" trailing="" val="("/>
                        <OtherNode start="(40, 27)" end="(40, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(40, 27)" end="(40, 33)" leading="" trailing=" " raw_val="denote" val="denote"/>
                          <NullNode start="(40, 34)" end="(40, 39)">
                            <IdentNode start="(40, 34)" end="(40, 37)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(40, 38)" end="(40, 39)" leading="" trailing="" raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(40, 39)" end="(40, 40)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(40, 41)" end="(40, 55)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(40, 41)" end="(40, 42)" leading="" trailing="" val="("/>
                        <OtherNode start="(40, 42)" end="(40, 54)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(40, 42)" end="(40, 48)" leading="" trailing=" " raw_val="denote" val="denote"/>
                          <NullNode start="(40, 49)" end="(40, 54)">
                            <IdentNode start="(40, 49)" end="(40, 52)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(40, 53)" end="(40, 54)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(40, 54)" end="(40, 55)" leading="" trailing="&#10;  " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(41, 3)" end="(41, 19)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(41, 3)" end="(41, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(41, 5)" end="(41, 11)">
                    <NullNode start="(41, 5)" end="(41, 11)">
                      <OtherNode start="(41, 5)" end="(41, 11)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(41, 5)" end="(41, 9)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(41, 5)" end="(41, 6)" leading="" trailing="" val="."/>
                          <IdentNode start="(41, 6)" end="(41, 9)" leading="" trailing=" " raw_val="num" val="num"/>
                        </OtherNode>
                        <NullNode start="(41, 10)" end="(41, 11)">
                          <IdentNode start="(41, 10)" end="(41, 11)" leading="" trailing="    " raw_val="k" val="k"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(41, 15)" end="(41, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(41, 18)" end="(41, 19)" leading="" trailing="&#10;  " raw_val="k" val="k"/>
                </OtherNode>
                <OtherNode start="(42, 3)" end="(42, 30)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(42, 3)" end="(42, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(42, 5)" end="(42, 11)">
                    <NullNode start="(42, 5)" end="(42, 11)">
                      <OtherNode start="(42, 5)" end="(42, 11)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(42, 5)" end="(42, 9)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(42, 5)" end="(42, 6)" leading="" trailing="" val="."/>
                          <IdentNode start="(42, 6)" end="(42, 9)" leading="" trailing=" " raw_val="var" val="var"/>
                        </OtherNode>
                        <NullNode start="(42, 10)" end="(42, 11)">
                          <IdentNode start="(42, 10)" end="(42, 11)" leading="" trailing="    " raw_val="v" val="v"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(42, 15)" end="(42, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(42, 18)" end="(42, 30)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(42, 18)" end="(42, 26)" leading="" trailing=" " raw_val="v.denote" val="v.denote"/>
                    <NullNode start="(42, 27)" end="(42, 30)">
                      <IdentNode start="(42, 27)" end="(42, 30)" leading="" trailing="&#10;  " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(43, 3)" end="(43, 42)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(43, 3)" end="(43, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(43, 5)" end="(43, 14)">
                    <NullNode start="(43, 5)" end="(43, 14)">
                      <OtherNode start="(43, 5)" end="(43, 14)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(43, 5)" end="(43, 10)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(43, 5)" end="(43, 6)" leading="" trailing="" val="."/>
                          <IdentNode start="(43, 6)" end="(43, 10)" leading="" trailing=" " raw_val="mulL" val="mulL"/>
                        </OtherNode>
                        <NullNode start="(43, 11)" end="(43, 14)">
                          <IdentNode start="(43, 11)" end="(43, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                          <IdentNode start="(43, 13)" end="(43, 14)" leading="" trailing=" " raw_val="e" val="e"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(43, 15)" end="(43, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(43, 18)" end="(43, 42)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(43, 18)" end="(43, 25)" leading="" trailing=" " raw_val="Nat.mul" val="Nat.mul" full_name="Nat.mul" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(43, 26)" end="(43, 42)">
                      <IdentNode start="(43, 26)" end="(43, 27)" leading="" trailing=" " raw_val="k" val="k"/>
                      <OtherNode start="(43, 28)" end="(43, 42)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(43, 28)" end="(43, 29)" leading="" trailing="" val="("/>
                        <OtherNode start="(43, 29)" end="(43, 41)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(43, 29)" end="(43, 35)" leading="" trailing=" " raw_val="denote" val="denote"/>
                          <NullNode start="(43, 36)" end="(43, 41)">
                            <IdentNode start="(43, 36)" end="(43, 39)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(43, 40)" end="(43, 41)" leading="" trailing="" raw_val="e" val="e"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(43, 41)" end="(43, 42)" leading="" trailing="&#10;  " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(44, 3)" end="(44, 42)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(44, 3)" end="(44, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(44, 5)" end="(44, 14)">
                    <NullNode start="(44, 5)" end="(44, 14)">
                      <OtherNode start="(44, 5)" end="(44, 14)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(44, 5)" end="(44, 10)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(44, 5)" end="(44, 6)" leading="" trailing="" val="."/>
                          <IdentNode start="(44, 6)" end="(44, 10)" leading="" trailing=" " raw_val="mulR" val="mulR"/>
                        </OtherNode>
                        <NullNode start="(44, 11)" end="(44, 14)">
                          <IdentNode start="(44, 11)" end="(44, 12)" leading="" trailing=" " raw_val="e" val="e"/>
                          <IdentNode start="(44, 13)" end="(44, 14)" leading="" trailing=" " raw_val="k" val="k"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(44, 15)" end="(44, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(44, 18)" end="(44, 42)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(44, 18)" end="(44, 25)" leading="" trailing=" " raw_val="Nat.mul" val="Nat.mul" full_name="Nat.mul" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(44, 26)" end="(44, 42)">
                      <OtherNode start="(44, 26)" end="(44, 40)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(44, 26)" end="(44, 27)" leading="" trailing="" val="("/>
                        <OtherNode start="(44, 27)" end="(44, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(44, 27)" end="(44, 33)" leading="" trailing=" " raw_val="denote" val="denote"/>
                          <NullNode start="(44, 34)" end="(44, 39)">
                            <IdentNode start="(44, 34)" end="(44, 37)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(44, 38)" end="(44, 39)" leading="" trailing="" raw_val="e" val="e"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(44, 39)" end="(44, 40)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(44, 41)" end="(44, 42)" leading="" trailing="&#10;&#10;" raw_val="k" val="k"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(46, 1)" end="(46, 32)" name="Poly" full_name="Nat.Linear.Poly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(46, 1)" end="(46, 32)" name="Poly">
        <AtomNode start="(46, 1)" end="(46, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(46, 8)" end="(46, 12)">
          <IdentNode start="(46, 8)" end="(46, 12)" leading="" trailing=" " raw_val="Poly" val="Poly"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(46, 13)" end="(46, 32)">
          <AtomNode start="(46, 13)" end="(46, 15)" leading="" trailing=" " val=":="/>
          <OtherNode start="(46, 16)" end="(46, 32)" kind="Lean.Parser.Term.app">
            <IdentNode start="(46, 16)" end="(46, 20)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(46, 21)" end="(46, 32)">
              <OtherNode start="(46, 21)" end="(46, 32)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(46, 21)" end="(46, 22)" leading="" trailing="" val="("/>
                <OtherNode start="(46, 22)" end="(46, 31)" kind="«term_×_»">
                  <IdentNode start="(46, 22)" end="(46, 25)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(46, 26)" end="(46, 27)" leading="" trailing=" " val="×"/>
                  <IdentNode start="(46, 28)" end="(46, 31)" leading="" trailing="" raw_val="Var" val="Var" full_name="Nat.Linear.Var" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(19, 8)" def_end="(19, 11)"/>
                </OtherNode>
                <AtomNode start="(46, 31)" end="(46, 32)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(48, 1)" end="(51, 69)" name="Poly.denote" full_name="Nat.Linear.Poly.denote">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(48, 1)" end="(51, 69)" name="Poly.denote">
        <AtomNode start="(48, 1)" end="(48, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(48, 5)" end="(48, 16)">
          <IdentNode start="(48, 5)" end="(48, 16)" leading="" trailing=" " raw_val="Poly.denote" val="Poly.denote"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(48, 17)" end="(48, 49)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(48, 17)" end="(48, 43)">
            <TermExplicitbinderNode start="(48, 17)" end="(48, 32)">
              <AtomNode start="(48, 17)" end="(48, 18)" leading="" trailing="" val="("/>
              <NullNode start="(48, 18)" end="(48, 21)">
                <IdentNode start="(48, 18)" end="(48, 21)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(48, 22)" end="(48, 31)">
                <AtomNode start="(48, 22)" end="(48, 23)" leading="" trailing=" " val=":"/>
                <IdentNode start="(48, 24)" end="(48, 31)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(48, 31)" end="(48, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(48, 33)" end="(48, 43)">
              <AtomNode start="(48, 33)" end="(48, 34)" leading="" trailing="" val="("/>
              <NullNode start="(48, 34)" end="(48, 35)">
                <IdentNode start="(48, 34)" end="(48, 35)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(48, 36)" end="(48, 42)">
                <AtomNode start="(48, 36)" end="(48, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(48, 38)" end="(48, 42)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(48, 42)" end="(48, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(48, 44)" end="(48, 49)">
            <TermTypespecNode start="(48, 44)" end="(48, 49)">
              <AtomNode start="(48, 44)" end="(48, 45)" leading="" trailing=" " val=":"/>
              <IdentNode start="(48, 46)" end="(48, 49)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(48, 50)" end="(51, 69)">
          <AtomNode start="(48, 50)" end="(48, 52)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(49, 3)" end="(51, 69)" kind="Lean.Parser.Term.match">
            <AtomNode start="(49, 3)" end="(49, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(49, 9)" end="(49, 10)">
              <OtherNode start="(49, 9)" end="(49, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(49, 9)" end="(49, 10)" leading="" trailing=" " raw_val="p" val="p"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(49, 11)" end="(49, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(50, 3)" end="(51, 69)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(50, 3)" end="(51, 69)">
                <OtherNode start="(50, 3)" end="(50, 12)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(50, 3)" end="(50, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(50, 5)" end="(50, 7)">
                    <NullNode start="(50, 5)" end="(50, 7)">
                      <OtherNode start="(50, 5)" end="(50, 7)" kind="«term[_]»">
                        <AtomNode start="(50, 5)" end="(50, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(50, 6)" end="(50, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(50, 8)" end="(50, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(50, 11)" end="(50, 12)" kind="num">
                    <AtomNode start="(50, 11)" end="(50, 12)" leading="" trailing="&#10;  " val="0"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(51, 3)" end="(51, 69)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(51, 3)" end="(51, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(51, 5)" end="(51, 16)">
                    <NullNode start="(51, 5)" end="(51, 16)">
                      <OtherNode start="(51, 5)" end="(51, 16)" kind="«term_::_»">
                        <OtherNode start="(51, 5)" end="(51, 11)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(51, 5)" end="(51, 6)" leading="" trailing="" val="("/>
                          <NullNode start="(51, 6)" end="(51, 10)">
                            <IdentNode start="(51, 6)" end="(51, 7)" leading="" trailing="" raw_val="k" val="k"/>
                            <AtomNode start="(51, 7)" end="(51, 8)" leading="" trailing=" " val=","/>
                            <NullNode start="(51, 9)" end="(51, 10)">
                              <IdentNode start="(51, 9)" end="(51, 10)" leading="" trailing="" raw_val="v" val="v"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(51, 10)" end="(51, 11)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(51, 12)" end="(51, 14)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(51, 15)" end="(51, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(51, 17)" end="(51, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(51, 20)" end="(51, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(51, 20)" end="(51, 27)" leading="" trailing=" " raw_val="Nat.add" val="Nat.add" full_name="Nat.add" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(51, 28)" end="(51, 69)">
                      <OtherNode start="(51, 28)" end="(51, 54)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(51, 28)" end="(51, 29)" leading="" trailing="" val="("/>
                        <OtherNode start="(51, 29)" end="(51, 53)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(51, 29)" end="(51, 36)" leading="" trailing=" " raw_val="Nat.mul" val="Nat.mul" full_name="Nat.mul" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(51, 37)" end="(51, 53)">
                            <IdentNode start="(51, 37)" end="(51, 38)" leading="" trailing=" " raw_val="k" val="k"/>
                            <OtherNode start="(51, 39)" end="(51, 53)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(51, 39)" end="(51, 40)" leading="" trailing="" val="("/>
                              <OtherNode start="(51, 40)" end="(51, 52)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(51, 40)" end="(51, 48)" leading="" trailing=" " raw_val="v.denote" val="v.denote"/>
                                <NullNode start="(51, 49)" end="(51, 52)">
                                  <IdentNode start="(51, 49)" end="(51, 52)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(51, 52)" end="(51, 53)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(51, 53)" end="(51, 54)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(51, 55)" end="(51, 69)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(51, 55)" end="(51, 56)" leading="" trailing="" val="("/>
                        <OtherNode start="(51, 56)" end="(51, 68)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(51, 56)" end="(51, 62)" leading="" trailing=" " raw_val="denote" val="denote"/>
                          <NullNode start="(51, 63)" end="(51, 68)">
                            <IdentNode start="(51, 63)" end="(51, 66)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(51, 67)" end="(51, 68)" leading="" trailing="" raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(51, 68)" end="(51, 69)" leading="" trailing="&#10;&#10;" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(53, 1)" end="(62, 31)" name="Poly.insert" full_name="Nat.Linear.Poly.insert">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(53, 1)" end="(62, 31)" name="Poly.insert">
        <AtomNode start="(53, 1)" end="(53, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(53, 5)" end="(53, 16)">
          <IdentNode start="(53, 5)" end="(53, 16)" leading="" trailing=" " raw_val="Poly.insert" val="Poly.insert"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(53, 17)" end="(53, 54)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(53, 17)" end="(53, 47)">
            <TermExplicitbinderNode start="(53, 17)" end="(53, 26)">
              <AtomNode start="(53, 17)" end="(53, 18)" leading="" trailing="" val="("/>
              <NullNode start="(53, 18)" end="(53, 19)">
                <IdentNode start="(53, 18)" end="(53, 19)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(53, 20)" end="(53, 25)">
                <AtomNode start="(53, 20)" end="(53, 21)" leading="" trailing=" " val=":"/>
                <IdentNode start="(53, 22)" end="(53, 25)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(53, 25)" end="(53, 26)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(53, 27)" end="(53, 36)">
              <AtomNode start="(53, 27)" end="(53, 28)" leading="" trailing="" val="("/>
              <NullNode start="(53, 28)" end="(53, 29)">
                <IdentNode start="(53, 28)" end="(53, 29)" leading="" trailing=" " raw_val="v" val="v"/>
              </NullNode>
              <NullNode start="(53, 30)" end="(53, 35)">
                <AtomNode start="(53, 30)" end="(53, 31)" leading="" trailing=" " val=":"/>
                <IdentNode start="(53, 32)" end="(53, 35)" leading="" trailing="" raw_val="Var" val="Var" full_name="Nat.Linear.Var" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(19, 8)" def_end="(19, 11)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(53, 35)" end="(53, 36)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(53, 37)" end="(53, 47)">
              <AtomNode start="(53, 37)" end="(53, 38)" leading="" trailing="" val="("/>
              <NullNode start="(53, 38)" end="(53, 39)">
                <IdentNode start="(53, 38)" end="(53, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(53, 40)" end="(53, 46)">
                <AtomNode start="(53, 40)" end="(53, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(53, 42)" end="(53, 46)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(53, 46)" end="(53, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(53, 48)" end="(53, 54)">
            <TermTypespecNode start="(53, 48)" end="(53, 54)">
              <AtomNode start="(53, 48)" end="(53, 49)" leading="" trailing=" " val=":"/>
              <IdentNode start="(53, 50)" end="(53, 54)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(53, 55)" end="(62, 31)">
          <AtomNode start="(53, 55)" end="(53, 57)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(54, 3)" end="(62, 31)" kind="Lean.Parser.Term.match">
            <AtomNode start="(54, 3)" end="(54, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(54, 9)" end="(54, 10)">
              <OtherNode start="(54, 9)" end="(54, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(54, 9)" end="(54, 10)" leading="" trailing=" " raw_val="p" val="p"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(54, 11)" end="(54, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(55, 3)" end="(62, 31)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(55, 3)" end="(62, 31)">
                <OtherNode start="(55, 3)" end="(55, 19)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(55, 3)" end="(55, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(55, 5)" end="(55, 7)">
                    <NullNode start="(55, 5)" end="(55, 7)">
                      <OtherNode start="(55, 5)" end="(55, 7)" kind="«term[_]»">
                        <AtomNode start="(55, 5)" end="(55, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(55, 6)" end="(55, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(55, 8)" end="(55, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(55, 11)" end="(55, 19)" kind="«term[_]»">
                    <AtomNode start="(55, 11)" end="(55, 12)" leading="" trailing="" val="["/>
                    <NullNode start="(55, 12)" end="(55, 18)">
                      <OtherNode start="(55, 12)" end="(55, 18)" kind="Lean.Parser.Term.tuple">
                        <AtomNode start="(55, 12)" end="(55, 13)" leading="" trailing="" val="("/>
                        <NullNode start="(55, 13)" end="(55, 17)">
                          <IdentNode start="(55, 13)" end="(55, 14)" leading="" trailing="" raw_val="k" val="k"/>
                          <AtomNode start="(55, 14)" end="(55, 15)" leading="" trailing=" " val=","/>
                          <NullNode start="(55, 16)" end="(55, 17)">
                            <IdentNode start="(55, 16)" end="(55, 17)" leading="" trailing="" raw_val="v" val="v"/>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(55, 17)" end="(55, 18)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(55, 18)" end="(55, 19)" leading="" trailing="&#10;  " val="]"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(56, 3)" end="(62, 31)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(56, 3)" end="(56, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(56, 5)" end="(56, 18)">
                    <NullNode start="(56, 5)" end="(56, 18)">
                      <OtherNode start="(56, 5)" end="(56, 18)" kind="«term_::_»">
                        <OtherNode start="(56, 5)" end="(56, 13)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(56, 5)" end="(56, 6)" leading="" trailing="" val="("/>
                          <NullNode start="(56, 6)" end="(56, 12)">
                            <IdentNode start="(56, 6)" end="(56, 8)" leading="" trailing="" raw_val="k'" val="k'"/>
                            <AtomNode start="(56, 8)" end="(56, 9)" leading="" trailing=" " val=","/>
                            <NullNode start="(56, 10)" end="(56, 12)">
                              <IdentNode start="(56, 10)" end="(56, 12)" leading="" trailing="" raw_val="v'" val="v'"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(56, 12)" end="(56, 13)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(56, 14)" end="(56, 16)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(56, 17)" end="(56, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(56, 19)" end="(56, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(57, 5)" end="(62, 31)" kind="boolIfThenElse">
                    <AtomNode start="(57, 5)" end="(57, 8)" leading="" trailing=" " val="bif"/>
                    <OtherNode start="(57, 9)" end="(57, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(57, 9)" end="(57, 16)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                      <NullNode start="(57, 17)" end="(57, 21)">
                        <IdentNode start="(57, 17)" end="(57, 18)" leading="" trailing=" " raw_val="v" val="v"/>
                        <IdentNode start="(57, 19)" end="(57, 21)" leading="" trailing=" " raw_val="v'" val="v'"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(57, 22)" end="(57, 26)" leading="" trailing="&#10;      " val="then"/>
                    <OtherNode start="(58, 7)" end="(58, 30)" kind="«term_::_»">
                      <OtherNode start="(58, 7)" end="(58, 13)" kind="Lean.Parser.Term.tuple">
                        <AtomNode start="(58, 7)" end="(58, 8)" leading="" trailing="" val="("/>
                        <NullNode start="(58, 8)" end="(58, 12)">
                          <IdentNode start="(58, 8)" end="(58, 9)" leading="" trailing="" raw_val="k" val="k"/>
                          <AtomNode start="(58, 9)" end="(58, 10)" leading="" trailing=" " val=","/>
                          <NullNode start="(58, 11)" end="(58, 12)">
                            <IdentNode start="(58, 11)" end="(58, 12)" leading="" trailing="" raw_val="v" val="v"/>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(58, 12)" end="(58, 13)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(58, 14)" end="(58, 16)" leading="" trailing=" " val="::"/>
                      <OtherNode start="(58, 17)" end="(58, 30)" kind="«term_::_»">
                        <OtherNode start="(58, 17)" end="(58, 25)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(58, 17)" end="(58, 18)" leading="" trailing="" val="("/>
                          <NullNode start="(58, 18)" end="(58, 24)">
                            <IdentNode start="(58, 18)" end="(58, 20)" leading="" trailing="" raw_val="k'" val="k'"/>
                            <AtomNode start="(58, 20)" end="(58, 21)" leading="" trailing=" " val=","/>
                            <NullNode start="(58, 22)" end="(58, 24)">
                              <IdentNode start="(58, 22)" end="(58, 24)" leading="" trailing="" raw_val="v'" val="v'"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(58, 24)" end="(58, 25)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(58, 26)" end="(58, 28)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(58, 29)" end="(58, 30)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(59, 5)" end="(59, 9)" leading="" trailing=" " val="else"/>
                    <OtherNode start="(59, 10)" end="(62, 31)" kind="boolIfThenElse">
                      <AtomNode start="(59, 10)" end="(59, 13)" leading="" trailing=" " val="bif"/>
                      <OtherNode start="(59, 14)" end="(59, 26)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(59, 14)" end="(59, 21)" leading="" trailing=" " raw_val="Nat.beq" val="Nat.beq" full_name="Nat.beq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(59, 22)" end="(59, 26)">
                          <IdentNode start="(59, 22)" end="(59, 23)" leading="" trailing=" " raw_val="v" val="v"/>
                          <IdentNode start="(59, 24)" end="(59, 26)" leading="" trailing=" " raw_val="v'" val="v'"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(59, 27)" end="(59, 31)" leading="" trailing="&#10;      " val="then"/>
                      <OtherNode start="(60, 7)" end="(60, 24)" kind="«term_::_»">
                        <OtherNode start="(60, 7)" end="(60, 19)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(60, 7)" end="(60, 8)" leading="" trailing="" val="("/>
                          <NullNode start="(60, 8)" end="(60, 18)">
                            <OtherNode start="(60, 8)" end="(60, 14)" kind="«term_+_»">
                              <IdentNode start="(60, 8)" end="(60, 9)" leading="" trailing=" " raw_val="k" val="k"/>
                              <AtomNode start="(60, 10)" end="(60, 11)" leading="" trailing=" " val="+"/>
                              <IdentNode start="(60, 12)" end="(60, 14)" leading="" trailing="" raw_val="k'" val="k'"/>
                            </OtherNode>
                            <AtomNode start="(60, 14)" end="(60, 15)" leading="" trailing=" " val=","/>
                            <NullNode start="(60, 16)" end="(60, 18)">
                              <IdentNode start="(60, 16)" end="(60, 18)" leading="" trailing="" raw_val="v'" val="v'"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(60, 18)" end="(60, 19)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(60, 20)" end="(60, 22)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(60, 23)" end="(60, 24)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                      </OtherNode>
                      <AtomNode start="(61, 5)" end="(61, 9)" leading="" trailing="&#10;      " val="else"/>
                      <OtherNode start="(62, 7)" end="(62, 31)" kind="«term_::_»">
                        <OtherNode start="(62, 7)" end="(62, 15)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(62, 7)" end="(62, 8)" leading="" trailing="" val="("/>
                          <NullNode start="(62, 8)" end="(62, 14)">
                            <IdentNode start="(62, 8)" end="(62, 10)" leading="" trailing="" raw_val="k'" val="k'"/>
                            <AtomNode start="(62, 10)" end="(62, 11)" leading="" trailing=" " val=","/>
                            <NullNode start="(62, 12)" end="(62, 14)">
                              <IdentNode start="(62, 12)" end="(62, 14)" leading="" trailing="" raw_val="v'" val="v'"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(62, 14)" end="(62, 15)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(62, 16)" end="(62, 18)" leading="" trailing=" " val="::"/>
                        <OtherNode start="(62, 19)" end="(62, 31)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(62, 19)" end="(62, 25)" leading="" trailing=" " raw_val="insert" val="insert"/>
                          <NullNode start="(62, 26)" end="(62, 31)">
                            <IdentNode start="(62, 26)" end="(62, 27)" leading="" trailing=" " raw_val="k" val="k"/>
                            <IdentNode start="(62, 28)" end="(62, 29)" leading="" trailing=" " raw_val="v" val="v"/>
                            <IdentNode start="(62, 30)" end="(62, 31)" leading="" trailing="&#10;&#10;" raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(64, 1)" end="(69, 41)" name="Poly.norm" full_name="Nat.Linear.Poly.norm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(64, 1)" end="(69, 41)" name="Poly.norm">
        <AtomNode start="(64, 1)" end="(64, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(64, 5)" end="(64, 14)">
          <IdentNode start="(64, 5)" end="(64, 14)" leading="" trailing=" " raw_val="Poly.norm" val="Poly.norm"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(64, 15)" end="(64, 32)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(64, 15)" end="(64, 25)">
            <TermExplicitbinderNode start="(64, 15)" end="(64, 25)">
              <AtomNode start="(64, 15)" end="(64, 16)" leading="" trailing="" val="("/>
              <NullNode start="(64, 16)" end="(64, 17)">
                <IdentNode start="(64, 16)" end="(64, 17)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(64, 18)" end="(64, 24)">
                <AtomNode start="(64, 18)" end="(64, 19)" leading="" trailing=" " val=":"/>
                <IdentNode start="(64, 20)" end="(64, 24)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(64, 24)" end="(64, 25)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(64, 26)" end="(64, 32)">
            <TermTypespecNode start="(64, 26)" end="(64, 32)">
              <AtomNode start="(64, 26)" end="(64, 27)" leading="" trailing=" " val=":"/>
              <IdentNode start="(64, 28)" end="(64, 32)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(64, 33)" end="(69, 41)">
          <AtomNode start="(64, 33)" end="(64, 35)" leading="" trailing=" " val=":="/>
          <OtherNode start="(64, 36)" end="(64, 43)" kind="Lean.Parser.Term.app">
            <IdentNode start="(64, 36)" end="(64, 38)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(64, 39)" end="(64, 43)">
              <IdentNode start="(64, 39)" end="(64, 40)" leading="" trailing=" " raw_val="p" val="p"/>
              <OtherNode start="(64, 41)" end="(64, 43)" kind="«term[_]»">
                <AtomNode start="(64, 41)" end="(64, 42)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(64, 42)" end="(64, 43)" leading="" trailing="&#10;" val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(65, 1)" end="(69, 41)">
            <OtherNode start="(65, 1)" end="(69, 41)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(65, 1)" end="(65, 6)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(66, 3)" end="(69, 41)">
                <OtherNode start="(66, 3)" end="(69, 41)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(66, 3)" end="(69, 41)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(66, 3)" end="(69, 41)" kind="Lean.Parser.Term.letIdDecl">
                      <IdentNode start="(66, 3)" end="(66, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode start="(66, 6)" end="(66, 27)">
                        <TermExplicitbinderNode start="(66, 6)" end="(66, 16)">
                          <AtomNode start="(66, 6)" end="(66, 7)" leading="" trailing="" val="("/>
                          <NullNode start="(66, 7)" end="(66, 8)">
                            <IdentNode start="(66, 7)" end="(66, 8)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                          <NullNode start="(66, 9)" end="(66, 15)">
                            <AtomNode start="(66, 9)" end="(66, 10)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(66, 11)" end="(66, 15)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(66, 15)" end="(66, 16)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                        <TermExplicitbinderNode start="(66, 17)" end="(66, 27)">
                          <AtomNode start="(66, 17)" end="(66, 18)" leading="" trailing="" val="("/>
                          <NullNode start="(66, 18)" end="(66, 19)">
                            <IdentNode start="(66, 18)" end="(66, 19)" leading="" trailing=" " raw_val="r" val="r"/>
                          </NullNode>
                          <NullNode start="(66, 20)" end="(66, 26)">
                            <AtomNode start="(66, 20)" end="(66, 21)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(66, 22)" end="(66, 26)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(66, 26)" end="(66, 27)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                      </NullNode>
                      <NullNode start="(66, 28)" end="(66, 34)">
                        <TermTypespecNode start="(66, 28)" end="(66, 34)">
                          <AtomNode start="(66, 28)" end="(66, 29)" leading="" trailing=" " val=":"/>
                          <IdentNode start="(66, 30)" end="(66, 34)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                        </TermTypespecNode>
                      </NullNode>
                      <AtomNode start="(66, 35)" end="(66, 37)" leading="" trailing="&#10;    " val=":="/>
                      <OtherNode start="(67, 5)" end="(69, 41)" kind="Lean.Parser.Term.match">
                        <AtomNode start="(67, 5)" end="(67, 10)" leading="" trailing=" " val="match"/>
                        <NullNode/>
                        <NullNode/>
                        <NullNode start="(67, 11)" end="(67, 12)">
                          <OtherNode start="(67, 11)" end="(67, 12)" kind="Lean.Parser.Term.matchDiscr">
                            <NullNode/>
                            <IdentNode start="(67, 11)" end="(67, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(67, 13)" end="(67, 17)" leading="" trailing="&#10;    " val="with"/>
                        <OtherNode start="(68, 5)" end="(69, 41)" kind="Lean.Parser.Term.matchAlts">
                          <NullNode start="(68, 5)" end="(69, 41)">
                            <OtherNode start="(68, 5)" end="(68, 14)" kind="Lean.Parser.Term.matchAlt">
                              <AtomNode start="(68, 5)" end="(68, 6)" leading="" trailing=" " val="|"/>
                              <NullNode start="(68, 7)" end="(68, 9)">
                                <NullNode start="(68, 7)" end="(68, 9)">
                                  <OtherNode start="(68, 7)" end="(68, 9)" kind="«term[_]»">
                                    <AtomNode start="(68, 7)" end="(68, 8)" leading="" trailing="" val="["/>
                                    <NullNode/>
                                    <AtomNode start="(68, 8)" end="(68, 9)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(68, 10)" end="(68, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <IdentNode start="(68, 13)" end="(68, 14)" leading="" trailing="&#10;    " raw_val="r" val="r"/>
                            </OtherNode>
                            <OtherNode start="(69, 5)" end="(69, 41)" kind="Lean.Parser.Term.matchAlt">
                              <AtomNode start="(69, 5)" end="(69, 6)" leading="" trailing=" " val="|"/>
                              <NullNode start="(69, 7)" end="(69, 18)">
                                <NullNode start="(69, 7)" end="(69, 18)">
                                  <OtherNode start="(69, 7)" end="(69, 18)" kind="«term_::_»">
                                    <OtherNode start="(69, 7)" end="(69, 13)" kind="Lean.Parser.Term.tuple">
                                      <AtomNode start="(69, 7)" end="(69, 8)" leading="" trailing="" val="("/>
                                      <NullNode start="(69, 8)" end="(69, 12)">
                                        <IdentNode start="(69, 8)" end="(69, 9)" leading="" trailing="" raw_val="k" val="k"/>
                                        <AtomNode start="(69, 9)" end="(69, 10)" leading="" trailing=" " val=","/>
                                        <NullNode start="(69, 11)" end="(69, 12)">
                                          <IdentNode start="(69, 11)" end="(69, 12)" leading="" trailing="" raw_val="v" val="v"/>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(69, 12)" end="(69, 13)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(69, 14)" end="(69, 16)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(69, 17)" end="(69, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                                  </OtherNode>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(69, 19)" end="(69, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(69, 22)" end="(69, 41)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(69, 22)" end="(69, 24)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(69, 25)" end="(69, 41)">
                                  <IdentNode start="(69, 25)" end="(69, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <OtherNode start="(69, 27)" end="(69, 41)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(69, 27)" end="(69, 28)" leading="" trailing="" val="("/>
                                    <OtherNode start="(69, 28)" end="(69, 40)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(69, 28)" end="(69, 36)" leading="" trailing=" " raw_val="r.insert" val="r.insert"/>
                                      <NullNode start="(69, 37)" end="(69, 40)">
                                        <IdentNode start="(69, 37)" end="(69, 38)" leading="" trailing=" " raw_val="k" val="k"/>
                                        <IdentNode start="(69, 39)" end="(69, 40)" leading="" trailing="" raw_val="v" val="v"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(69, 40)" end="(69, 41)" leading="" trailing="&#10;&#10;" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(71, 1)" end="(88, 35)" name="Poly.cancelAux" full_name="Nat.Linear.Poly.cancelAux">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(71, 1)" end="(88, 35)" name="Poly.cancelAux">
        <AtomNode start="(71, 1)" end="(71, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(71, 5)" end="(71, 19)">
          <IdentNode start="(71, 5)" end="(71, 19)" leading="" trailing=" " raw_val="Poly.cancelAux" val="Poly.cancelAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(71, 20)" end="(71, 67)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(71, 20)" end="(71, 53)">
            <TermExplicitbinderNode start="(71, 20)" end="(71, 32)">
              <AtomNode start="(71, 20)" end="(71, 21)" leading="" trailing="" val="("/>
              <NullNode start="(71, 21)" end="(71, 25)">
                <IdentNode start="(71, 21)" end="(71, 25)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
              </NullNode>
              <NullNode start="(71, 26)" end="(71, 31)">
                <AtomNode start="(71, 26)" end="(71, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(71, 28)" end="(71, 31)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(71, 31)" end="(71, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(71, 33)" end="(71, 53)">
              <AtomNode start="(71, 33)" end="(71, 34)" leading="" trailing="" val="("/>
              <NullNode start="(71, 34)" end="(71, 45)">
                <IdentNode start="(71, 34)" end="(71, 36)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(71, 37)" end="(71, 39)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                <IdentNode start="(71, 40)" end="(71, 42)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                <IdentNode start="(71, 43)" end="(71, 45)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
              </NullNode>
              <NullNode start="(71, 46)" end="(71, 52)">
                <AtomNode start="(71, 46)" end="(71, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(71, 48)" end="(71, 52)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(71, 52)" end="(71, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(71, 54)" end="(71, 67)">
            <TermTypespecNode start="(71, 54)" end="(71, 67)">
              <AtomNode start="(71, 54)" end="(71, 55)" leading="" trailing=" " val=":"/>
              <OtherNode start="(71, 56)" end="(71, 67)" kind="«term_×_»">
                <IdentNode start="(71, 56)" end="(71, 60)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                <AtomNode start="(71, 61)" end="(71, 62)" leading="" trailing=" " val="×"/>
                <IdentNode start="(71, 63)" end="(71, 67)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(71, 68)" end="(88, 35)">
          <AtomNode start="(71, 68)" end="(71, 70)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(72, 3)" end="(88, 35)" kind="Lean.Parser.Term.match">
            <AtomNode start="(72, 3)" end="(72, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(72, 9)" end="(72, 13)">
              <OtherNode start="(72, 9)" end="(72, 13)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(72, 9)" end="(72, 13)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(72, 14)" end="(72, 18)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(73, 3)" end="(88, 35)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(73, 3)" end="(88, 35)">
                <OtherNode start="(73, 3)" end="(73, 46)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(73, 3)" end="(73, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(73, 5)" end="(73, 6)">
                    <NullNode start="(73, 5)" end="(73, 6)">
                      <OtherNode start="(73, 5)" end="(73, 6)" kind="num">
                        <AtomNode start="(73, 5)" end="(73, 6)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(73, 7)" end="(73, 9)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(73, 10)" end="(73, 46)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(73, 10)" end="(73, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(73, 11)" end="(73, 45)">
                      <OtherNode start="(73, 11)" end="(73, 27)" kind="«term_++_»">
                        <IdentNode start="(73, 11)" end="(73, 21)" leading="" trailing=" " raw_val="r₁.reverse" val="r₁.reverse"/>
                        <AtomNode start="(73, 22)" end="(73, 24)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(73, 25)" end="(73, 27)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                      </OtherNode>
                      <AtomNode start="(73, 27)" end="(73, 28)" leading="" trailing=" " val=","/>
                      <NullNode start="(73, 29)" end="(73, 45)">
                        <OtherNode start="(73, 29)" end="(73, 45)" kind="«term_++_»">
                          <IdentNode start="(73, 29)" end="(73, 39)" leading="" trailing=" " raw_val="r₂.reverse" val="r₂.reverse"/>
                          <AtomNode start="(73, 40)" end="(73, 42)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(73, 43)" end="(73, 45)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(73, 45)" end="(73, 46)" leading="" trailing="&#10;  " val=")"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(74, 3)" end="(88, 35)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(74, 3)" end="(74, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(74, 5)" end="(74, 13)">
                    <NullNode start="(74, 5)" end="(74, 13)">
                      <OtherNode start="(74, 5)" end="(74, 13)" kind="«term_+_»">
                        <IdentNode start="(74, 5)" end="(74, 9)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                        <AtomNode start="(74, 10)" end="(74, 11)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(74, 12)" end="(74, 13)" kind="num">
                          <AtomNode start="(74, 12)" end="(74, 13)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(74, 14)" end="(74, 16)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(75, 5)" end="(88, 35)" kind="Lean.Parser.Term.match">
                    <AtomNode start="(75, 5)" end="(75, 10)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(75, 11)" end="(75, 17)">
                      <OtherNode start="(75, 11)" end="(75, 13)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(75, 11)" end="(75, 13)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                      </OtherNode>
                      <AtomNode start="(75, 13)" end="(75, 14)" leading="" trailing=" " val=","/>
                      <OtherNode start="(75, 15)" end="(75, 17)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(75, 15)" end="(75, 17)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(75, 18)" end="(75, 22)" leading="" trailing="&#10;    " val="with"/>
                    <OtherNode start="(76, 5)" end="(88, 35)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(76, 5)" end="(88, 35)">
                        <OtherNode start="(76, 5)" end="(76, 47)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(76, 5)" end="(76, 6)" leading="" trailing=" " val="|"/>
                          <NullNode start="(76, 7)" end="(76, 13)">
                            <NullNode start="(76, 7)" end="(76, 13)">
                              <IdentNode start="(76, 7)" end="(76, 9)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                              <AtomNode start="(76, 9)" end="(76, 10)" leading="" trailing=" " val=","/>
                              <OtherNode start="(76, 11)" end="(76, 13)" kind="«term[_]»">
                                <AtomNode start="(76, 11)" end="(76, 12)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(76, 12)" end="(76, 13)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(76, 14)" end="(76, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(76, 17)" end="(76, 47)" kind="Lean.Parser.Term.tuple">
                            <AtomNode start="(76, 17)" end="(76, 18)" leading="" trailing="" val="("/>
                            <NullNode start="(76, 18)" end="(76, 46)">
                              <OtherNode start="(76, 18)" end="(76, 34)" kind="«term_++_»">
                                <IdentNode start="(76, 18)" end="(76, 28)" leading="" trailing=" " raw_val="r₁.reverse" val="r₁.reverse"/>
                                <AtomNode start="(76, 29)" end="(76, 31)" leading="" trailing=" " val="++"/>
                                <IdentNode start="(76, 32)" end="(76, 34)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                              </OtherNode>
                              <AtomNode start="(76, 34)" end="(76, 35)" leading="" trailing=" " val=","/>
                              <NullNode start="(76, 36)" end="(76, 46)">
                                <IdentNode start="(76, 36)" end="(76, 46)" leading="" trailing="" raw_val="r₂.reverse" val="r₂.reverse"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(76, 46)" end="(76, 47)" leading="" trailing="&#10;    " val=")"/>
                          </OtherNode>
                        </OtherNode>
                        <OtherNode start="(77, 5)" end="(77, 47)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(77, 5)" end="(77, 6)" leading="" trailing=" " val="|"/>
                          <NullNode start="(77, 7)" end="(77, 13)">
                            <NullNode start="(77, 7)" end="(77, 13)">
                              <OtherNode start="(77, 7)" end="(77, 9)" kind="«term[_]»">
                                <AtomNode start="(77, 7)" end="(77, 8)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(77, 8)" end="(77, 9)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(77, 9)" end="(77, 10)" leading="" trailing=" " val=","/>
                              <IdentNode start="(77, 11)" end="(77, 13)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(77, 14)" end="(77, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(77, 17)" end="(77, 47)" kind="Lean.Parser.Term.tuple">
                            <AtomNode start="(77, 17)" end="(77, 18)" leading="" trailing="" val="("/>
                            <NullNode start="(77, 18)" end="(77, 46)">
                              <IdentNode start="(77, 18)" end="(77, 28)" leading="" trailing="" raw_val="r₁.reverse" val="r₁.reverse"/>
                              <AtomNode start="(77, 28)" end="(77, 29)" leading="" trailing=" " val=","/>
                              <NullNode start="(77, 30)" end="(77, 46)">
                                <OtherNode start="(77, 30)" end="(77, 46)" kind="«term_++_»">
                                  <IdentNode start="(77, 30)" end="(77, 40)" leading="" trailing=" " raw_val="r₂.reverse" val="r₂.reverse"/>
                                  <AtomNode start="(77, 41)" end="(77, 43)" leading="" trailing=" " val="++"/>
                                  <IdentNode start="(77, 44)" end="(77, 46)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(77, 46)" end="(77, 47)" leading="" trailing="&#10;    " val=")"/>
                          </OtherNode>
                        </OtherNode>
                        <OtherNode start="(78, 5)" end="(88, 35)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(78, 5)" end="(78, 6)" leading="" trailing=" " val="|"/>
                          <NullNode start="(78, 7)" end="(78, 37)">
                            <NullNode start="(78, 7)" end="(78, 37)">
                              <OtherNode start="(78, 7)" end="(78, 21)" kind="«term_::_»">
                                <OtherNode start="(78, 7)" end="(78, 15)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(78, 7)" end="(78, 8)" leading="" trailing="" val="("/>
                                  <NullNode start="(78, 8)" end="(78, 14)">
                                    <IdentNode start="(78, 8)" end="(78, 10)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                                    <AtomNode start="(78, 10)" end="(78, 11)" leading="" trailing=" " val=","/>
                                    <NullNode start="(78, 12)" end="(78, 14)">
                                      <IdentNode start="(78, 12)" end="(78, 14)" leading="" trailing="" raw_val="v₁" val="v₁"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(78, 14)" end="(78, 15)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(78, 16)" end="(78, 18)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(78, 19)" end="(78, 21)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                              </OtherNode>
                              <AtomNode start="(78, 21)" end="(78, 22)" leading="" trailing=" " val=","/>
                              <OtherNode start="(78, 23)" end="(78, 37)" kind="«term_::_»">
                                <OtherNode start="(78, 23)" end="(78, 31)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(78, 23)" end="(78, 24)" leading="" trailing="" val="("/>
                                  <NullNode start="(78, 24)" end="(78, 30)">
                                    <IdentNode start="(78, 24)" end="(78, 26)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                                    <AtomNode start="(78, 26)" end="(78, 27)" leading="" trailing=" " val=","/>
                                    <NullNode start="(78, 28)" end="(78, 30)">
                                      <IdentNode start="(78, 28)" end="(78, 30)" leading="" trailing="" raw_val="v₂" val="v₂"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(78, 30)" end="(78, 31)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(78, 32)" end="(78, 34)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(78, 35)" end="(78, 37)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(78, 38)" end="(78, 40)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                          <OtherNode start="(79, 7)" end="(88, 35)" kind="boolIfThenElse">
                            <AtomNode start="(79, 7)" end="(79, 10)" leading="" trailing=" " val="bif"/>
                            <OtherNode start="(79, 11)" end="(79, 24)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(79, 11)" end="(79, 18)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                              <NullNode start="(79, 19)" end="(79, 24)">
                                <IdentNode start="(79, 19)" end="(79, 21)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                <IdentNode start="(79, 22)" end="(79, 24)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(79, 25)" end="(79, 29)" leading="" trailing="&#10;        " val="then"/>
                            <OtherNode start="(80, 9)" end="(80, 63)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(80, 9)" end="(80, 18)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux"/>
                              <NullNode start="(80, 19)" end="(80, 63)">
                                <IdentNode start="(80, 19)" end="(80, 23)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                <IdentNode start="(80, 24)" end="(80, 26)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                <OtherNode start="(80, 27)" end="(80, 43)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(80, 27)" end="(80, 28)" leading="" trailing="" val="("/>
                                  <OtherNode start="(80, 28)" end="(80, 42)" kind="«term_::_»">
                                    <OtherNode start="(80, 28)" end="(80, 36)" kind="Lean.Parser.Term.tuple">
                                      <AtomNode start="(80, 28)" end="(80, 29)" leading="" trailing="" val="("/>
                                      <NullNode start="(80, 29)" end="(80, 35)">
                                        <IdentNode start="(80, 29)" end="(80, 31)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                                        <AtomNode start="(80, 31)" end="(80, 32)" leading="" trailing=" " val=","/>
                                        <NullNode start="(80, 33)" end="(80, 35)">
                                          <IdentNode start="(80, 33)" end="(80, 35)" leading="" trailing="" raw_val="v₂" val="v₂"/>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(80, 35)" end="(80, 36)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(80, 37)" end="(80, 39)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(80, 40)" end="(80, 42)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                                  </OtherNode>
                                  <AtomNode start="(80, 42)" end="(80, 43)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <OtherNode start="(80, 44)" end="(80, 60)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(80, 44)" end="(80, 45)" leading="" trailing="" val="("/>
                                  <OtherNode start="(80, 45)" end="(80, 59)" kind="«term_::_»">
                                    <OtherNode start="(80, 45)" end="(80, 53)" kind="Lean.Parser.Term.tuple">
                                      <AtomNode start="(80, 45)" end="(80, 46)" leading="" trailing="" val="("/>
                                      <NullNode start="(80, 46)" end="(80, 52)">
                                        <IdentNode start="(80, 46)" end="(80, 48)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                                        <AtomNode start="(80, 48)" end="(80, 49)" leading="" trailing=" " val=","/>
                                        <NullNode start="(80, 50)" end="(80, 52)">
                                          <IdentNode start="(80, 50)" end="(80, 52)" leading="" trailing="" raw_val="v₁" val="v₁"/>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(80, 52)" end="(80, 53)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(80, 54)" end="(80, 56)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(80, 57)" end="(80, 59)" leading="" trailing="" raw_val="r₁" val="r₁"/>
                                  </OtherNode>
                                  <AtomNode start="(80, 59)" end="(80, 60)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(80, 61)" end="(80, 63)" leading="" trailing="&#10;      " raw_val="r₂" val="r₂"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(81, 7)" end="(81, 11)" leading="" trailing=" " val="else"/>
                            <OtherNode start="(81, 12)" end="(88, 35)" kind="boolIfThenElse">
                              <AtomNode start="(81, 12)" end="(81, 15)" leading="" trailing=" " val="bif"/>
                              <OtherNode start="(81, 16)" end="(81, 29)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(81, 16)" end="(81, 23)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                <NullNode start="(81, 24)" end="(81, 29)">
                                  <IdentNode start="(81, 24)" end="(81, 26)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                  <IdentNode start="(81, 27)" end="(81, 29)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(81, 30)" end="(81, 34)" leading="" trailing="&#10;        " val="then"/>
                              <OtherNode start="(82, 9)" end="(82, 63)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(82, 9)" end="(82, 18)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux"/>
                                <NullNode start="(82, 19)" end="(82, 63)">
                                  <IdentNode start="(82, 19)" end="(82, 23)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                  <OtherNode start="(82, 24)" end="(82, 40)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(82, 24)" end="(82, 25)" leading="" trailing="" val="("/>
                                    <OtherNode start="(82, 25)" end="(82, 39)" kind="«term_::_»">
                                      <OtherNode start="(82, 25)" end="(82, 33)" kind="Lean.Parser.Term.tuple">
                                        <AtomNode start="(82, 25)" end="(82, 26)" leading="" trailing="" val="("/>
                                        <NullNode start="(82, 26)" end="(82, 32)">
                                          <IdentNode start="(82, 26)" end="(82, 28)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                                          <AtomNode start="(82, 28)" end="(82, 29)" leading="" trailing=" " val=","/>
                                          <NullNode start="(82, 30)" end="(82, 32)">
                                            <IdentNode start="(82, 30)" end="(82, 32)" leading="" trailing="" raw_val="v₁" val="v₁"/>
                                          </NullNode>
                                        </NullNode>
                                        <AtomNode start="(82, 32)" end="(82, 33)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(82, 34)" end="(82, 36)" leading="" trailing=" " val="::"/>
                                      <IdentNode start="(82, 37)" end="(82, 39)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                                    </OtherNode>
                                    <AtomNode start="(82, 39)" end="(82, 40)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(82, 41)" end="(82, 43)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                                  <IdentNode start="(82, 44)" end="(82, 46)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                                  <OtherNode start="(82, 47)" end="(82, 63)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(82, 47)" end="(82, 48)" leading="" trailing="" val="("/>
                                    <OtherNode start="(82, 48)" end="(82, 62)" kind="«term_::_»">
                                      <OtherNode start="(82, 48)" end="(82, 56)" kind="Lean.Parser.Term.tuple">
                                        <AtomNode start="(82, 48)" end="(82, 49)" leading="" trailing="" val="("/>
                                        <NullNode start="(82, 49)" end="(82, 55)">
                                          <IdentNode start="(82, 49)" end="(82, 51)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                                          <AtomNode start="(82, 51)" end="(82, 52)" leading="" trailing=" " val=","/>
                                          <NullNode start="(82, 53)" end="(82, 55)">
                                            <IdentNode start="(82, 53)" end="(82, 55)" leading="" trailing="" raw_val="v₂" val="v₂"/>
                                          </NullNode>
                                        </NullNode>
                                        <AtomNode start="(82, 55)" end="(82, 56)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(82, 57)" end="(82, 59)" leading="" trailing=" " val="::"/>
                                      <IdentNode start="(82, 60)" end="(82, 62)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                                    </OtherNode>
                                    <AtomNode start="(82, 62)" end="(82, 63)" leading="" trailing="&#10;      " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(83, 7)" end="(83, 11)" leading="" trailing=" " val="else"/>
                              <OtherNode start="(83, 12)" end="(88, 35)" kind="boolIfThenElse">
                                <AtomNode start="(83, 12)" end="(83, 15)" leading="" trailing=" " val="bif"/>
                                <OtherNode start="(83, 16)" end="(83, 29)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(83, 16)" end="(83, 23)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                  <NullNode start="(83, 24)" end="(83, 29)">
                                    <IdentNode start="(83, 24)" end="(83, 26)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                    <IdentNode start="(83, 27)" end="(83, 29)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(83, 30)" end="(83, 34)" leading="" trailing="&#10;        " val="then"/>
                                <OtherNode start="(84, 9)" end="(84, 60)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(84, 9)" end="(84, 18)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux"/>
                                  <NullNode start="(84, 19)" end="(84, 60)">
                                    <IdentNode start="(84, 19)" end="(84, 23)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                    <IdentNode start="(84, 24)" end="(84, 26)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                    <IdentNode start="(84, 27)" end="(84, 29)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                                    <IdentNode start="(84, 30)" end="(84, 32)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                                    <OtherNode start="(84, 33)" end="(84, 60)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(84, 33)" end="(84, 34)" leading="" trailing="" val="("/>
                                      <OtherNode start="(84, 34)" end="(84, 59)" kind="«term_::_»">
                                        <OtherNode start="(84, 34)" end="(84, 53)" kind="Lean.Parser.Term.tuple">
                                          <AtomNode start="(84, 34)" end="(84, 35)" leading="" trailing="" val="("/>
                                          <NullNode start="(84, 35)" end="(84, 52)">
                                            <OtherNode start="(84, 35)" end="(84, 48)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(84, 35)" end="(84, 42)" leading="" trailing=" " raw_val="Nat.sub" val="Nat.sub" full_name="Nat.sub" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              <NullNode start="(84, 43)" end="(84, 48)">
                                                <IdentNode start="(84, 43)" end="(84, 45)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                <IdentNode start="(84, 46)" end="(84, 48)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(84, 48)" end="(84, 49)" leading="" trailing=" " val=","/>
                                            <NullNode start="(84, 50)" end="(84, 52)">
                                              <IdentNode start="(84, 50)" end="(84, 52)" leading="" trailing="" raw_val="v₁" val="v₁"/>
                                            </NullNode>
                                          </NullNode>
                                          <AtomNode start="(84, 52)" end="(84, 53)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <AtomNode start="(84, 54)" end="(84, 56)" leading="" trailing=" " val="::"/>
                                        <IdentNode start="(84, 57)" end="(84, 59)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                                      </OtherNode>
                                      <AtomNode start="(84, 59)" end="(84, 60)" leading="" trailing="&#10;      " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(85, 7)" end="(85, 11)" leading="" trailing=" " val="else"/>
                                <OtherNode start="(85, 12)" end="(88, 35)" kind="boolIfThenElse">
                                  <AtomNode start="(85, 12)" end="(85, 15)" leading="" trailing=" " val="bif"/>
                                  <OtherNode start="(85, 16)" end="(85, 29)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(85, 16)" end="(85, 23)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                    <NullNode start="(85, 24)" end="(85, 29)">
                                      <IdentNode start="(85, 24)" end="(85, 26)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                      <IdentNode start="(85, 27)" end="(85, 29)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(85, 30)" end="(85, 34)" leading="" trailing="&#10;        " val="then"/>
                                  <OtherNode start="(86, 9)" end="(86, 60)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(86, 9)" end="(86, 18)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux"/>
                                    <NullNode start="(86, 19)" end="(86, 60)">
                                      <IdentNode start="(86, 19)" end="(86, 23)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                      <IdentNode start="(86, 24)" end="(86, 26)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                      <IdentNode start="(86, 27)" end="(86, 29)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                                      <OtherNode start="(86, 30)" end="(86, 57)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(86, 30)" end="(86, 31)" leading="" trailing="" val="("/>
                                        <OtherNode start="(86, 31)" end="(86, 56)" kind="«term_::_»">
                                          <OtherNode start="(86, 31)" end="(86, 50)" kind="Lean.Parser.Term.tuple">
                                            <AtomNode start="(86, 31)" end="(86, 32)" leading="" trailing="" val="("/>
                                            <NullNode start="(86, 32)" end="(86, 49)">
                                              <OtherNode start="(86, 32)" end="(86, 45)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(86, 32)" end="(86, 39)" leading="" trailing=" " raw_val="Nat.sub" val="Nat.sub" full_name="Nat.sub" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                <NullNode start="(86, 40)" end="(86, 45)">
                                                  <IdentNode start="(86, 40)" end="(86, 42)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                  <IdentNode start="(86, 43)" end="(86, 45)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(86, 45)" end="(86, 46)" leading="" trailing=" " val=","/>
                                              <NullNode start="(86, 47)" end="(86, 49)">
                                                <IdentNode start="(86, 47)" end="(86, 49)" leading="" trailing="" raw_val="v₁" val="v₁"/>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(86, 49)" end="(86, 50)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                          <AtomNode start="(86, 51)" end="(86, 53)" leading="" trailing=" " val="::"/>
                                          <IdentNode start="(86, 54)" end="(86, 56)" leading="" trailing="" raw_val="r₁" val="r₁"/>
                                        </OtherNode>
                                        <AtomNode start="(86, 56)" end="(86, 57)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <IdentNode start="(86, 58)" end="(86, 60)" leading="" trailing="&#10;      " raw_val="r₂" val="r₂"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(87, 7)" end="(87, 11)" leading="" trailing="&#10;        " val="else"/>
                                  <OtherNode start="(88, 9)" end="(88, 35)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(88, 9)" end="(88, 18)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux"/>
                                    <NullNode start="(88, 19)" end="(88, 35)">
                                      <IdentNode start="(88, 19)" end="(88, 23)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                      <IdentNode start="(88, 24)" end="(88, 26)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                      <IdentNode start="(88, 27)" end="(88, 29)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                                      <IdentNode start="(88, 30)" end="(88, 32)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                                      <IdentNode start="(88, 33)" end="(88, 35)" leading="" trailing="&#10;&#10;" raw_val="r₂" val="r₂"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(90, 1)" end="(90, 24)" name="hugeFuel" full_name="Nat.Linear.hugeFuel">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(90, 1)" end="(90, 24)" name="hugeFuel">
        <AtomNode start="(90, 1)" end="(90, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(90, 5)" end="(90, 13)">
          <IdentNode start="(90, 5)" end="(90, 13)" leading="" trailing=" " raw_val="hugeFuel" val="hugeFuel"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(90, 14)" end="(90, 24)">
          <AtomNode start="(90, 14)" end="(90, 16)" leading="" trailing=" " val=":="/>
          <OtherNode start="(90, 17)" end="(90, 24)" kind="num">
            <AtomNode start="(90, 17)" end="(90, 24)" leading="" trailing=" -- any big number should work&#10;&#10;" val="1000000"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(92, 1)" end="(93, 33)" name="Poly.cancel" full_name="Nat.Linear.Poly.cancel">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(92, 1)" end="(93, 33)" name="Poly.cancel">
        <AtomNode start="(92, 1)" end="(92, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(92, 5)" end="(92, 16)">
          <IdentNode start="(92, 5)" end="(92, 16)" leading="" trailing=" " raw_val="Poly.cancel" val="Poly.cancel"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(92, 17)" end="(92, 45)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(92, 17)" end="(92, 31)">
            <TermExplicitbinderNode start="(92, 17)" end="(92, 31)">
              <AtomNode start="(92, 17)" end="(92, 18)" leading="" trailing="" val="("/>
              <NullNode start="(92, 18)" end="(92, 23)">
                <IdentNode start="(92, 18)" end="(92, 20)" leading="" trailing=" " raw_val="p₁" val="p₁"/>
                <IdentNode start="(92, 21)" end="(92, 23)" leading="" trailing=" " raw_val="p₂" val="p₂"/>
              </NullNode>
              <NullNode start="(92, 24)" end="(92, 30)">
                <AtomNode start="(92, 24)" end="(92, 25)" leading="" trailing=" " val=":"/>
                <IdentNode start="(92, 26)" end="(92, 30)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(92, 30)" end="(92, 31)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(92, 32)" end="(92, 45)">
            <TermTypespecNode start="(92, 32)" end="(92, 45)">
              <AtomNode start="(92, 32)" end="(92, 33)" leading="" trailing=" " val=":"/>
              <OtherNode start="(92, 34)" end="(92, 45)" kind="«term_×_»">
                <IdentNode start="(92, 34)" end="(92, 38)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                <AtomNode start="(92, 39)" end="(92, 40)" leading="" trailing=" " val="×"/>
                <IdentNode start="(92, 41)" end="(92, 45)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(92, 46)" end="(93, 33)">
          <AtomNode start="(92, 46)" end="(92, 48)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(93, 3)" end="(93, 33)" kind="Lean.Parser.Term.app">
            <IdentNode start="(93, 3)" end="(93, 12)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux" full_name="Nat.Linear.Poly.cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(71, 5)" def_end="(71, 19)"/>
            <NullNode start="(93, 13)" end="(93, 33)">
              <IdentNode start="(93, 13)" end="(93, 21)" leading="" trailing=" " raw_val="hugeFuel" val="hugeFuel" full_name="Nat.Linear.hugeFuel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(90, 5)" def_end="(90, 13)"/>
              <IdentNode start="(93, 22)" end="(93, 24)" leading="" trailing=" " raw_val="p₁" val="p₁"/>
              <IdentNode start="(93, 25)" end="(93, 27)" leading="" trailing=" " raw_val="p₂" val="p₂"/>
              <OtherNode start="(93, 28)" end="(93, 30)" kind="«term[_]»">
                <AtomNode start="(93, 28)" end="(93, 29)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(93, 29)" end="(93, 30)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <OtherNode start="(93, 31)" end="(93, 33)" kind="«term[_]»">
                <AtomNode start="(93, 31)" end="(93, 32)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(93, 32)" end="(93, 33)" leading="" trailing="&#10;&#10;" val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(95, 1)" end="(99, 14)" name="Poly.isNum?" full_name="Nat.Linear.Poly.isNum?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(95, 1)" end="(99, 14)" name="Poly.isNum?">
        <AtomNode start="(95, 1)" end="(95, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(95, 5)" end="(95, 16)">
          <IdentNode start="(95, 5)" end="(95, 16)" leading="" trailing=" " raw_val="Poly.isNum?" val="Poly.isNum?"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(95, 17)" end="(95, 40)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(95, 17)" end="(95, 27)">
            <TermExplicitbinderNode start="(95, 17)" end="(95, 27)">
              <AtomNode start="(95, 17)" end="(95, 18)" leading="" trailing="" val="("/>
              <NullNode start="(95, 18)" end="(95, 19)">
                <IdentNode start="(95, 18)" end="(95, 19)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(95, 20)" end="(95, 26)">
                <AtomNode start="(95, 20)" end="(95, 21)" leading="" trailing=" " val=":"/>
                <IdentNode start="(95, 22)" end="(95, 26)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(95, 26)" end="(95, 27)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(95, 28)" end="(95, 40)">
            <TermTypespecNode start="(95, 28)" end="(95, 40)">
              <AtomNode start="(95, 28)" end="(95, 29)" leading="" trailing=" " val=":"/>
              <OtherNode start="(95, 30)" end="(95, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(95, 30)" end="(95, 36)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(95, 37)" end="(95, 40)">
                  <IdentNode start="(95, 37)" end="(95, 40)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(95, 41)" end="(99, 14)">
          <AtomNode start="(95, 41)" end="(95, 43)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(96, 3)" end="(99, 14)" kind="Lean.Parser.Term.match">
            <AtomNode start="(96, 3)" end="(96, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(96, 9)" end="(96, 10)">
              <OtherNode start="(96, 9)" end="(96, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(96, 9)" end="(96, 10)" leading="" trailing=" " raw_val="p" val="p"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(96, 11)" end="(96, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(97, 3)" end="(99, 14)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(97, 3)" end="(99, 14)">
                <OtherNode start="(97, 3)" end="(97, 17)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(97, 3)" end="(97, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(97, 5)" end="(97, 7)">
                    <NullNode start="(97, 5)" end="(97, 7)">
                      <OtherNode start="(97, 5)" end="(97, 7)" kind="«term[_]»">
                        <AtomNode start="(97, 5)" end="(97, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(97, 6)" end="(97, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(97, 8)" end="(97, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(97, 11)" end="(97, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(97, 11)" end="(97, 15)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(97, 16)" end="(97, 17)">
                      <OtherNode start="(97, 16)" end="(97, 17)" kind="num">
                        <AtomNode start="(97, 16)" end="(97, 17)" leading="" trailing="&#10;  " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(98, 3)" end="(98, 56)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(98, 3)" end="(98, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(98, 5)" end="(98, 13)">
                    <NullNode start="(98, 5)" end="(98, 13)">
                      <OtherNode start="(98, 5)" end="(98, 13)" kind="«term[_]»">
                        <AtomNode start="(98, 5)" end="(98, 6)" leading="" trailing="" val="["/>
                        <NullNode start="(98, 6)" end="(98, 12)">
                          <OtherNode start="(98, 6)" end="(98, 12)" kind="Lean.Parser.Term.tuple">
                            <AtomNode start="(98, 6)" end="(98, 7)" leading="" trailing="" val="("/>
                            <NullNode start="(98, 7)" end="(98, 11)">
                              <IdentNode start="(98, 7)" end="(98, 8)" leading="" trailing="" raw_val="k" val="k"/>
                              <AtomNode start="(98, 8)" end="(98, 9)" leading="" trailing=" " val=","/>
                              <NullNode start="(98, 10)" end="(98, 11)">
                                <IdentNode start="(98, 10)" end="(98, 11)" leading="" trailing="" raw_val="v" val="v"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(98, 11)" end="(98, 12)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(98, 12)" end="(98, 13)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(98, 14)" end="(98, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(98, 17)" end="(98, 56)" kind="boolIfThenElse">
                    <AtomNode start="(98, 17)" end="(98, 20)" leading="" trailing=" " val="bif"/>
                    <OtherNode start="(98, 21)" end="(98, 34)" kind="«term_==_»">
                      <IdentNode start="(98, 21)" end="(98, 22)" leading="" trailing=" " raw_val="v" val="v"/>
                      <AtomNode start="(98, 23)" end="(98, 25)" leading="" trailing=" " val="=="/>
                      <IdentNode start="(98, 26)" end="(98, 34)" leading="" trailing=" " raw_val="fixedVar" val="fixedVar" full_name="Nat.Linear.fixedVar" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(26, 5)" def_end="(26, 13)"/>
                    </OtherNode>
                    <AtomNode start="(98, 35)" end="(98, 39)" leading="" trailing=" " val="then"/>
                    <OtherNode start="(98, 40)" end="(98, 46)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(98, 40)" end="(98, 44)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(98, 45)" end="(98, 46)">
                        <IdentNode start="(98, 45)" end="(98, 46)" leading="" trailing=" " raw_val="k" val="k"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(98, 47)" end="(98, 51)" leading="" trailing=" " val="else"/>
                    <IdentNode start="(98, 52)" end="(98, 56)" leading="" trailing="&#10;  " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(99, 3)" end="(99, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(99, 3)" end="(99, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(99, 5)" end="(99, 6)">
                    <NullNode start="(99, 5)" end="(99, 6)">
                      <TermHoleNode start="(99, 5)" end="(99, 6)">
                        <AtomNode start="(99, 5)" end="(99, 6)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(99, 7)" end="(99, 9)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(99, 10)" end="(99, 14)" leading="" trailing="&#10;&#10;" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(101, 1)" end="(104, 16)" name="Poly.isZero" full_name="Nat.Linear.Poly.isZero">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(101, 1)" end="(104, 16)" name="Poly.isZero">
        <AtomNode start="(101, 1)" end="(101, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(101, 5)" end="(101, 16)">
          <IdentNode start="(101, 5)" end="(101, 16)" leading="" trailing=" " raw_val="Poly.isZero" val="Poly.isZero"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(101, 17)" end="(101, 34)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(101, 17)" end="(101, 27)">
            <TermExplicitbinderNode start="(101, 17)" end="(101, 27)">
              <AtomNode start="(101, 17)" end="(101, 18)" leading="" trailing="" val="("/>
              <NullNode start="(101, 18)" end="(101, 19)">
                <IdentNode start="(101, 18)" end="(101, 19)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(101, 20)" end="(101, 26)">
                <AtomNode start="(101, 20)" end="(101, 21)" leading="" trailing=" " val=":"/>
                <IdentNode start="(101, 22)" end="(101, 26)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(101, 26)" end="(101, 27)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(101, 28)" end="(101, 34)">
            <TermTypespecNode start="(101, 28)" end="(101, 34)">
              <AtomNode start="(101, 28)" end="(101, 29)" leading="" trailing=" " val=":"/>
              <IdentNode start="(101, 30)" end="(101, 34)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(101, 35)" end="(104, 16)">
          <AtomNode start="(101, 35)" end="(101, 37)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(102, 3)" end="(104, 16)" kind="Lean.Parser.Term.match">
            <AtomNode start="(102, 3)" end="(102, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(102, 9)" end="(102, 10)">
              <OtherNode start="(102, 9)" end="(102, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(102, 9)" end="(102, 10)" leading="" trailing=" " raw_val="p" val="p"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(102, 11)" end="(102, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(103, 3)" end="(104, 16)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(103, 3)" end="(104, 16)">
                <OtherNode start="(103, 3)" end="(103, 15)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(103, 3)" end="(103, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(103, 5)" end="(103, 7)">
                    <NullNode start="(103, 5)" end="(103, 7)">
                      <OtherNode start="(103, 5)" end="(103, 7)" kind="«term[_]»">
                        <AtomNode start="(103, 5)" end="(103, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(103, 6)" end="(103, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(103, 8)" end="(103, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(103, 11)" end="(103, 15)" leading="" trailing="&#10;  " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(104, 3)" end="(104, 16)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(104, 3)" end="(104, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(104, 5)" end="(104, 6)">
                    <NullNode start="(104, 5)" end="(104, 6)">
                      <TermHoleNode start="(104, 5)" end="(104, 6)">
                        <AtomNode start="(104, 5)" end="(104, 6)" leading="" trailing="  " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(104, 8)" end="(104, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(104, 11)" end="(104, 16)" leading="" trailing="&#10;&#10;" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(106, 1)" end="(109, 65)" name="Poly.isNonZero" full_name="Nat.Linear.Poly.isNonZero">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(106, 1)" end="(109, 65)" name="Poly.isNonZero">
        <AtomNode start="(106, 1)" end="(106, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(106, 5)" end="(106, 19)">
          <IdentNode start="(106, 5)" end="(106, 19)" leading="" trailing=" " raw_val="Poly.isNonZero" val="Poly.isNonZero"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(106, 20)" end="(106, 37)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(106, 20)" end="(106, 30)">
            <TermExplicitbinderNode start="(106, 20)" end="(106, 30)">
              <AtomNode start="(106, 20)" end="(106, 21)" leading="" trailing="" val="("/>
              <NullNode start="(106, 21)" end="(106, 22)">
                <IdentNode start="(106, 21)" end="(106, 22)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(106, 23)" end="(106, 29)">
                <AtomNode start="(106, 23)" end="(106, 24)" leading="" trailing=" " val=":"/>
                <IdentNode start="(106, 25)" end="(106, 29)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(106, 29)" end="(106, 30)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(106, 31)" end="(106, 37)">
            <TermTypespecNode start="(106, 31)" end="(106, 37)">
              <AtomNode start="(106, 31)" end="(106, 32)" leading="" trailing=" " val=":"/>
              <IdentNode start="(106, 33)" end="(106, 37)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(106, 38)" end="(109, 65)">
          <AtomNode start="(106, 38)" end="(106, 40)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(107, 3)" end="(109, 65)" kind="Lean.Parser.Term.match">
            <AtomNode start="(107, 3)" end="(107, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(107, 9)" end="(107, 10)">
              <OtherNode start="(107, 9)" end="(107, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(107, 9)" end="(107, 10)" leading="" trailing=" " raw_val="p" val="p"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(107, 11)" end="(107, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(108, 3)" end="(109, 65)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(108, 3)" end="(109, 65)">
                <OtherNode start="(108, 3)" end="(108, 16)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(108, 3)" end="(108, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(108, 5)" end="(108, 7)">
                    <NullNode start="(108, 5)" end="(108, 7)">
                      <OtherNode start="(108, 5)" end="(108, 7)" kind="«term[_]»">
                        <AtomNode start="(108, 5)" end="(108, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(108, 6)" end="(108, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(108, 8)" end="(108, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(108, 11)" end="(108, 16)" leading="" trailing="&#10;  " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(109, 3)" end="(109, 65)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(109, 3)" end="(109, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(109, 5)" end="(109, 16)">
                    <NullNode start="(109, 5)" end="(109, 16)">
                      <OtherNode start="(109, 5)" end="(109, 16)" kind="«term_::_»">
                        <OtherNode start="(109, 5)" end="(109, 11)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing="" val="("/>
                          <NullNode start="(109, 6)" end="(109, 10)">
                            <IdentNode start="(109, 6)" end="(109, 7)" leading="" trailing="" raw_val="k" val="k"/>
                            <AtomNode start="(109, 7)" end="(109, 8)" leading="" trailing=" " val=","/>
                            <NullNode start="(109, 9)" end="(109, 10)">
                              <IdentNode start="(109, 9)" end="(109, 10)" leading="" trailing="" raw_val="v" val="v"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(109, 10)" end="(109, 11)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(109, 12)" end="(109, 14)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(109, 15)" end="(109, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(109, 17)" end="(109, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(109, 20)" end="(109, 65)" kind="boolIfThenElse">
                    <AtomNode start="(109, 20)" end="(109, 23)" leading="" trailing=" " val="bif"/>
                    <OtherNode start="(109, 24)" end="(109, 37)" kind="«term_==_»">
                      <IdentNode start="(109, 24)" end="(109, 25)" leading="" trailing=" " raw_val="v" val="v"/>
                      <AtomNode start="(109, 26)" end="(109, 28)" leading="" trailing=" " val="=="/>
                      <IdentNode start="(109, 29)" end="(109, 37)" leading="" trailing=" " raw_val="fixedVar" val="fixedVar" full_name="Nat.Linear.fixedVar" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(26, 5)" def_end="(26, 13)"/>
                    </OtherNode>
                    <AtomNode start="(109, 38)" end="(109, 42)" leading="" trailing=" " val="then"/>
                    <OtherNode start="(109, 43)" end="(109, 48)" kind="«term_&amp;gt;_»">
                      <IdentNode start="(109, 43)" end="(109, 44)" leading="" trailing=" " raw_val="k" val="k"/>
                      <AtomNode start="(109, 45)" end="(109, 46)" leading="" trailing=" " val="&amp;gt;"/>
                      <OtherNode start="(109, 47)" end="(109, 48)" kind="num">
                        <AtomNode start="(109, 47)" end="(109, 48)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(109, 49)" end="(109, 53)" leading="" trailing=" " val="else"/>
                    <OtherNode start="(109, 54)" end="(109, 65)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(109, 54)" end="(109, 63)" leading="" trailing=" " raw_val="isNonZero" val="isNonZero"/>
                      <NullNode start="(109, 64)" end="(109, 65)">
                        <IdentNode start="(109, 64)" end="(109, 65)" leading="" trailing="&#10;&#10;" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(111, 1)" end="(111, 98)" name="Poly.denote_eq" full_name="Nat.Linear.Poly.denote_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(111, 1)" end="(111, 98)" name="Poly.denote_eq">
        <AtomNode start="(111, 1)" end="(111, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(111, 5)" end="(111, 19)">
          <IdentNode start="(111, 5)" end="(111, 19)" leading="" trailing=" " raw_val="Poly.denote_eq" val="Poly.denote_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(111, 20)" end="(111, 61)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(111, 20)" end="(111, 54)">
            <TermExplicitbinderNode start="(111, 20)" end="(111, 35)">
              <AtomNode start="(111, 20)" end="(111, 21)" leading="" trailing="" val="("/>
              <NullNode start="(111, 21)" end="(111, 24)">
                <IdentNode start="(111, 21)" end="(111, 24)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(111, 25)" end="(111, 34)">
                <AtomNode start="(111, 25)" end="(111, 26)" leading="" trailing=" " val=":"/>
                <IdentNode start="(111, 27)" end="(111, 34)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(111, 34)" end="(111, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(111, 36)" end="(111, 54)">
              <AtomNode start="(111, 36)" end="(111, 37)" leading="" trailing="" val="("/>
              <NullNode start="(111, 37)" end="(111, 39)">
                <IdentNode start="(111, 37)" end="(111, 39)" leading="" trailing=" " raw_val="mp" val="mp"/>
              </NullNode>
              <NullNode start="(111, 40)" end="(111, 53)">
                <AtomNode start="(111, 40)" end="(111, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(111, 42)" end="(111, 53)" kind="«term_×_»">
                  <IdentNode start="(111, 42)" end="(111, 46)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                  <AtomNode start="(111, 47)" end="(111, 48)" leading="" trailing=" " val="×"/>
                  <IdentNode start="(111, 49)" end="(111, 53)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(111, 53)" end="(111, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(111, 55)" end="(111, 61)">
            <TermTypespecNode start="(111, 55)" end="(111, 61)">
              <AtomNode start="(111, 55)" end="(111, 56)" leading="" trailing=" " val=":"/>
              <OtherNode start="(111, 57)" end="(111, 61)" kind="Lean.Parser.Term.prop">
                <AtomNode start="(111, 57)" end="(111, 61)" leading="" trailing=" " val="Prop"/>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(111, 62)" end="(111, 98)">
          <AtomNode start="(111, 62)" end="(111, 64)" leading="" trailing=" " val=":="/>
          <OtherNode start="(111, 65)" end="(111, 98)" kind="«term_=_»">
            <OtherNode start="(111, 65)" end="(111, 80)" kind="Lean.Parser.Term.app">
              <OtherNode start="(111, 65)" end="(111, 76)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(111, 65)" end="(111, 69)" kind="Lean.Parser.Term.proj">
                  <IdentNode start="(111, 65)" end="(111, 67)" leading="" trailing="" raw_val="mp" val="mp"/>
                  <AtomNode start="(111, 67)" end="(111, 68)" leading="" trailing="" val="."/>
                  <OtherNode start="(111, 68)" end="(111, 69)" kind="fieldIdx">
                    <AtomNode start="(111, 68)" end="(111, 69)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(111, 69)" end="(111, 70)" leading="" trailing="" val="."/>
                <IdentNode start="(111, 70)" end="(111, 76)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
              </OtherNode>
              <NullNode start="(111, 77)" end="(111, 80)">
                <IdentNode start="(111, 77)" end="(111, 80)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
            </OtherNode>
            <AtomNode start="(111, 81)" end="(111, 82)" leading="" trailing=" " val="="/>
            <OtherNode start="(111, 83)" end="(111, 98)" kind="Lean.Parser.Term.app">
              <OtherNode start="(111, 83)" end="(111, 94)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(111, 83)" end="(111, 87)" kind="Lean.Parser.Term.proj">
                  <IdentNode start="(111, 83)" end="(111, 85)" leading="" trailing="" raw_val="mp" val="mp"/>
                  <AtomNode start="(111, 85)" end="(111, 86)" leading="" trailing="" val="."/>
                  <OtherNode start="(111, 86)" end="(111, 87)" kind="fieldIdx">
                    <AtomNode start="(111, 86)" end="(111, 87)" leading="" trailing="" val="2"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(111, 87)" end="(111, 88)" leading="" trailing="" val="."/>
                <IdentNode start="(111, 88)" end="(111, 94)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
              </OtherNode>
              <NullNode start="(111, 95)" end="(111, 98)">
                <IdentNode start="(111, 95)" end="(111, 98)" leading="" trailing="&#10;&#10;" raw_val="ctx" val="ctx"/>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(113, 1)" end="(113, 98)" name="Poly.denote_le" full_name="Nat.Linear.Poly.denote_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(113, 1)" end="(113, 98)" name="Poly.denote_le">
        <AtomNode start="(113, 1)" end="(113, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(113, 5)" end="(113, 19)">
          <IdentNode start="(113, 5)" end="(113, 19)" leading="" trailing=" " raw_val="Poly.denote_le" val="Poly.denote_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(113, 20)" end="(113, 61)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(113, 20)" end="(113, 54)">
            <TermExplicitbinderNode start="(113, 20)" end="(113, 35)">
              <AtomNode start="(113, 20)" end="(113, 21)" leading="" trailing="" val="("/>
              <NullNode start="(113, 21)" end="(113, 24)">
                <IdentNode start="(113, 21)" end="(113, 24)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(113, 25)" end="(113, 34)">
                <AtomNode start="(113, 25)" end="(113, 26)" leading="" trailing=" " val=":"/>
                <IdentNode start="(113, 27)" end="(113, 34)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(113, 34)" end="(113, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(113, 36)" end="(113, 54)">
              <AtomNode start="(113, 36)" end="(113, 37)" leading="" trailing="" val="("/>
              <NullNode start="(113, 37)" end="(113, 39)">
                <IdentNode start="(113, 37)" end="(113, 39)" leading="" trailing=" " raw_val="mp" val="mp"/>
              </NullNode>
              <NullNode start="(113, 40)" end="(113, 53)">
                <AtomNode start="(113, 40)" end="(113, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(113, 42)" end="(113, 53)" kind="«term_×_»">
                  <IdentNode start="(113, 42)" end="(113, 46)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                  <AtomNode start="(113, 47)" end="(113, 48)" leading="" trailing=" " val="×"/>
                  <IdentNode start="(113, 49)" end="(113, 53)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(113, 53)" end="(113, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(113, 55)" end="(113, 61)">
            <TermTypespecNode start="(113, 55)" end="(113, 61)">
              <AtomNode start="(113, 55)" end="(113, 56)" leading="" trailing=" " val=":"/>
              <OtherNode start="(113, 57)" end="(113, 61)" kind="Lean.Parser.Term.prop">
                <AtomNode start="(113, 57)" end="(113, 61)" leading="" trailing=" " val="Prop"/>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(113, 62)" end="(113, 98)">
          <AtomNode start="(113, 62)" end="(113, 64)" leading="" trailing=" " val=":="/>
          <OtherNode start="(113, 65)" end="(113, 98)" kind="«term_≤_»">
            <OtherNode start="(113, 65)" end="(113, 80)" kind="Lean.Parser.Term.app">
              <OtherNode start="(113, 65)" end="(113, 76)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(113, 65)" end="(113, 69)" kind="Lean.Parser.Term.proj">
                  <IdentNode start="(113, 65)" end="(113, 67)" leading="" trailing="" raw_val="mp" val="mp"/>
                  <AtomNode start="(113, 67)" end="(113, 68)" leading="" trailing="" val="."/>
                  <OtherNode start="(113, 68)" end="(113, 69)" kind="fieldIdx">
                    <AtomNode start="(113, 68)" end="(113, 69)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(113, 69)" end="(113, 70)" leading="" trailing="" val="."/>
                <IdentNode start="(113, 70)" end="(113, 76)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
              </OtherNode>
              <NullNode start="(113, 77)" end="(113, 80)">
                <IdentNode start="(113, 77)" end="(113, 80)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
            </OtherNode>
            <AtomNode start="(113, 81)" end="(113, 82)" leading="" trailing=" " val="≤"/>
            <OtherNode start="(113, 83)" end="(113, 98)" kind="Lean.Parser.Term.app">
              <OtherNode start="(113, 83)" end="(113, 94)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(113, 83)" end="(113, 87)" kind="Lean.Parser.Term.proj">
                  <IdentNode start="(113, 83)" end="(113, 85)" leading="" trailing="" raw_val="mp" val="mp"/>
                  <AtomNode start="(113, 85)" end="(113, 86)" leading="" trailing="" val="."/>
                  <OtherNode start="(113, 86)" end="(113, 87)" kind="fieldIdx">
                    <AtomNode start="(113, 86)" end="(113, 87)" leading="" trailing="" val="2"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(113, 87)" end="(113, 88)" leading="" trailing="" val="."/>
                <IdentNode start="(113, 88)" end="(113, 94)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
              </OtherNode>
              <NullNode start="(113, 95)" end="(113, 98)">
                <IdentNode start="(113, 95)" end="(113, 98)" leading="" trailing="&#10;&#10;" raw_val="ctx" val="ctx"/>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(115, 1)" end="(125, 60)" name="Expr.toPoly" full_name="Nat.Linear.Expr.toPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(115, 1)" end="(125, 60)" name="Expr.toPoly">
        <AtomNode start="(115, 1)" end="(115, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(115, 5)" end="(115, 16)">
          <IdentNode start="(115, 5)" end="(115, 16)" leading="" trailing=" " raw_val="Expr.toPoly" val="Expr.toPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(115, 17)" end="(115, 27)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(115, 17)" end="(115, 27)">
            <TermExplicitbinderNode start="(115, 17)" end="(115, 27)">
              <AtomNode start="(115, 17)" end="(115, 18)" leading="" trailing="" val="("/>
              <NullNode start="(115, 18)" end="(115, 19)">
                <IdentNode start="(115, 18)" end="(115, 19)" leading="" trailing=" " raw_val="e" val="e"/>
              </NullNode>
              <NullNode start="(115, 20)" end="(115, 26)">
                <AtomNode start="(115, 20)" end="(115, 21)" leading="" trailing=" " val=":"/>
                <IdentNode start="(115, 22)" end="(115, 26)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(115, 26)" end="(115, 27)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(115, 28)" end="(125, 60)">
          <AtomNode start="(115, 28)" end="(115, 30)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(116, 3)" end="(116, 12)" kind="Lean.Parser.Term.app">
            <IdentNode start="(116, 3)" end="(116, 5)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(116, 6)" end="(116, 12)">
              <OtherNode start="(116, 6)" end="(116, 7)" kind="num">
                <AtomNode start="(116, 6)" end="(116, 7)" leading="" trailing=" " val="1"/>
              </OtherNode>
              <IdentNode start="(116, 8)" end="(116, 9)" leading="" trailing=" " raw_val="e" val="e"/>
              <OtherNode start="(116, 10)" end="(116, 12)" kind="«term[_]»">
                <AtomNode start="(116, 10)" end="(116, 11)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(116, 11)" end="(116, 12)" leading="" trailing="&#10;" val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(117, 1)" end="(125, 60)">
            <OtherNode start="(117, 1)" end="(125, 60)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(117, 1)" end="(117, 6)" leading="" trailing="&#10;  -- Implementation note: This assembles the result using difference lists&#10;  -- to avoid `++` on lists.&#10;  " val="where"/>
              <NullNode start="(120, 3)" end="(125, 60)">
                <OtherNode start="(120, 3)" end="(125, 60)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(120, 3)" end="(125, 60)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(120, 3)" end="(125, 60)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(120, 3)" end="(120, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode start="(120, 6)" end="(120, 19)">
                        <TermExplicitbinderNode start="(120, 6)" end="(120, 19)">
                          <AtomNode start="(120, 6)" end="(120, 7)" leading="" trailing="" val="("/>
                          <NullNode start="(120, 7)" end="(120, 12)">
                            <IdentNode start="(120, 7)" end="(120, 12)" leading="" trailing=" " raw_val="coeff" val="coeff"/>
                          </NullNode>
                          <NullNode start="(120, 13)" end="(120, 18)">
                            <AtomNode start="(120, 13)" end="(120, 14)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(120, 15)" end="(120, 18)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(120, 18)" end="(120, 19)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                      </NullNode>
                      <NullNode start="(120, 20)" end="(120, 42)">
                        <TermTypespecNode start="(120, 20)" end="(120, 42)">
                          <AtomNode start="(120, 20)" end="(120, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(120, 22)" end="(120, 42)" kind="Lean.Parser.Term.arrow">
                            <IdentNode start="(120, 22)" end="(120, 26)" leading="" trailing=" " raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
                            <AtomNode start="(120, 27)" end="(120, 28)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(120, 29)" end="(120, 42)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(120, 29)" end="(120, 30)" leading="" trailing="" val="("/>
                              <OtherNode start="(120, 30)" end="(120, 41)" kind="Lean.Parser.Term.arrow">
                                <IdentNode start="(120, 30)" end="(120, 34)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                                <AtomNode start="(120, 35)" end="(120, 36)" leading="" trailing=" " val="→"/>
                                <IdentNode start="(120, 37)" end="(120, 41)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                              </OtherNode>
                              <AtomNode start="(120, 41)" end="(120, 42)" leading="" trailing="&#10;    " val=")"/>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(121, 5)" end="(125, 60)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(121, 5)" end="(125, 60)">
                          <OtherNode start="(121, 5)" end="(121, 72)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(121, 5)" end="(121, 6)" leading="" trailing=" " val="|"/>
                            <NullNode start="(121, 7)" end="(121, 13)">
                              <NullNode start="(121, 7)" end="(121, 13)">
                                <OtherNode start="(121, 7)" end="(121, 13)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(121, 7)" end="(121, 11)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(121, 7)" end="(121, 8)" leading="" trailing="" val="."/>
                                    <IdentNode start="(121, 8)" end="(121, 11)" leading="" trailing=" " raw_val="num" val="num"/>
                                  </OtherNode>
                                  <NullNode start="(121, 12)" end="(121, 13)">
                                    <IdentNode start="(121, 12)" end="(121, 13)" leading="" trailing="    " raw_val="k" val="k"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(121, 17)" end="(121, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(121, 20)" end="(121, 72)" kind="boolIfThenElse">
                              <AtomNode start="(121, 20)" end="(121, 23)" leading="" trailing=" " val="bif"/>
                              <OtherNode start="(121, 24)" end="(121, 30)" kind="«term_==_»">
                                <IdentNode start="(121, 24)" end="(121, 25)" leading="" trailing=" " raw_val="k" val="k"/>
                                <AtomNode start="(121, 26)" end="(121, 28)" leading="" trailing=" " val="=="/>
                                <OtherNode start="(121, 29)" end="(121, 30)" kind="num">
                                  <AtomNode start="(121, 29)" end="(121, 30)" leading="" trailing=" " val="0"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(121, 31)" end="(121, 35)" leading="" trailing=" " val="then"/>
                              <IdentNode start="(121, 36)" end="(121, 38)" leading="" trailing=" " raw_val="id" val="id" full_name="id" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(121, 39)" end="(121, 43)" leading="" trailing=" " val="else"/>
                              <OtherNode start="(121, 44)" end="(121, 72)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(121, 44)" end="(121, 45)" leading="" trailing="" val="("/>
                                <OtherNode start="(121, 45)" end="(121, 71)" kind="«term_::_»">
                                  <OtherNode start="(121, 45)" end="(121, 66)" kind="Lean.Parser.Term.tuple">
                                    <AtomNode start="(121, 45)" end="(121, 46)" leading="" trailing="" val="("/>
                                    <NullNode start="(121, 46)" end="(121, 65)">
                                      <OtherNode start="(121, 46)" end="(121, 55)" kind="«term_*_»">
                                        <IdentNode start="(121, 46)" end="(121, 51)" leading="" trailing=" " raw_val="coeff" val="coeff"/>
                                        <AtomNode start="(121, 52)" end="(121, 53)" leading="" trailing=" " val="*"/>
                                        <IdentNode start="(121, 54)" end="(121, 55)" leading="" trailing="" raw_val="k" val="k"/>
                                      </OtherNode>
                                      <AtomNode start="(121, 55)" end="(121, 56)" leading="" trailing=" " val=","/>
                                      <NullNode start="(121, 57)" end="(121, 65)">
                                        <IdentNode start="(121, 57)" end="(121, 65)" leading="" trailing="" raw_val="fixedVar" val="fixedVar" full_name="Nat.Linear.fixedVar" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(26, 5)" def_end="(26, 13)"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(121, 65)" end="(121, 66)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(121, 67)" end="(121, 69)" leading="" trailing=" " val="::"/>
                                  <OtherNode start="(121, 70)" end="(121, 71)" kind="Lean.Parser.Term.cdot">
                                    <AtomNode start="(121, 70)" end="(121, 71)" leading="" trailing="" val="·"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(121, 71)" end="(121, 72)" leading="" trailing="&#10;    " val=")"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(122, 5)" end="(122, 37)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(122, 5)" end="(122, 6)" leading="" trailing=" " val="|"/>
                            <NullNode start="(122, 7)" end="(122, 13)">
                              <NullNode start="(122, 7)" end="(122, 13)">
                                <OtherNode start="(122, 7)" end="(122, 13)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(122, 7)" end="(122, 11)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(122, 7)" end="(122, 8)" leading="" trailing="" val="."/>
                                    <IdentNode start="(122, 8)" end="(122, 11)" leading="" trailing=" " raw_val="var" val="var"/>
                                  </OtherNode>
                                  <NullNode start="(122, 12)" end="(122, 13)">
                                    <IdentNode start="(122, 12)" end="(122, 13)" leading="" trailing="    " raw_val="i" val="i"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(122, 17)" end="(122, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(122, 20)" end="(122, 37)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(122, 20)" end="(122, 21)" leading="" trailing="" val="("/>
                              <OtherNode start="(122, 21)" end="(122, 36)" kind="«term_::_»">
                                <OtherNode start="(122, 21)" end="(122, 31)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(122, 21)" end="(122, 22)" leading="" trailing="" val="("/>
                                  <NullNode start="(122, 22)" end="(122, 30)">
                                    <IdentNode start="(122, 22)" end="(122, 27)" leading="" trailing="" raw_val="coeff" val="coeff"/>
                                    <AtomNode start="(122, 27)" end="(122, 28)" leading="" trailing=" " val=","/>
                                    <NullNode start="(122, 29)" end="(122, 30)">
                                      <IdentNode start="(122, 29)" end="(122, 30)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(122, 30)" end="(122, 31)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(122, 32)" end="(122, 34)" leading="" trailing=" " val="::"/>
                                <OtherNode start="(122, 35)" end="(122, 36)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(122, 35)" end="(122, 36)" leading="" trailing="" val="·"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(122, 36)" end="(122, 37)" leading="" trailing="&#10;    " val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(123, 5)" end="(123, 43)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(123, 5)" end="(123, 6)" leading="" trailing=" " val="|"/>
                            <NullNode start="(123, 7)" end="(123, 15)">
                              <NullNode start="(123, 7)" end="(123, 15)">
                                <OtherNode start="(123, 7)" end="(123, 15)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(123, 7)" end="(123, 11)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(123, 7)" end="(123, 8)" leading="" trailing="" val="."/>
                                    <IdentNode start="(123, 8)" end="(123, 11)" leading="" trailing=" " raw_val="add" val="add"/>
                                  </OtherNode>
                                  <NullNode start="(123, 12)" end="(123, 15)">
                                    <IdentNode start="(123, 12)" end="(123, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <IdentNode start="(123, 14)" end="(123, 15)" leading="" trailing="  " raw_val="b" val="b"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(123, 17)" end="(123, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(123, 20)" end="(123, 43)" kind="«term_∘_»">
                              <OtherNode start="(123, 20)" end="(123, 30)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(123, 20)" end="(123, 22)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(123, 23)" end="(123, 30)">
                                  <IdentNode start="(123, 23)" end="(123, 28)" leading="" trailing=" " raw_val="coeff" val="coeff"/>
                                  <IdentNode start="(123, 29)" end="(123, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(123, 31)" end="(123, 32)" leading="" trailing=" " val="∘"/>
                              <OtherNode start="(123, 33)" end="(123, 43)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(123, 33)" end="(123, 35)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(123, 36)" end="(123, 43)">
                                  <IdentNode start="(123, 36)" end="(123, 41)" leading="" trailing=" " raw_val="coeff" val="coeff"/>
                                  <IdentNode start="(123, 42)" end="(123, 43)" leading="" trailing="&#10;    " raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(124, 5)" end="(125, 60)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(124, 5)" end="(124, 6)" leading="" trailing=" " val="|"/>
                            <NullNode start="(124, 7)" end="(125, 16)">
                              <NullNode start="(124, 7)" end="(124, 16)">
                                <OtherNode start="(124, 7)" end="(124, 16)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(124, 7)" end="(124, 12)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(124, 7)" end="(124, 8)" leading="" trailing="" val="."/>
                                    <IdentNode start="(124, 8)" end="(124, 12)" leading="" trailing=" " raw_val="mulL" val="mulL"/>
                                  </OtherNode>
                                  <NullNode start="(124, 13)" end="(124, 16)">
                                    <IdentNode start="(124, 13)" end="(124, 14)" leading="" trailing=" " raw_val="k" val="k"/>
                                    <IdentNode start="(124, 15)" end="(124, 16)" leading="" trailing="&#10;    " raw_val="a" val="a"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(125, 5)" end="(125, 6)" leading="" trailing=" " val="|"/>
                              <NullNode start="(125, 7)" end="(125, 16)">
                                <OtherNode start="(125, 7)" end="(125, 16)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(125, 7)" end="(125, 12)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(125, 7)" end="(125, 8)" leading="" trailing="" val="."/>
                                    <IdentNode start="(125, 8)" end="(125, 12)" leading="" trailing=" " raw_val="mulR" val="mulR"/>
                                  </OtherNode>
                                  <NullNode start="(125, 13)" end="(125, 16)">
                                    <IdentNode start="(125, 13)" end="(125, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <IdentNode start="(125, 15)" end="(125, 16)" leading="" trailing=" " raw_val="k" val="k"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(125, 17)" end="(125, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(125, 20)" end="(125, 60)" kind="boolIfThenElse">
                              <AtomNode start="(125, 20)" end="(125, 23)" leading="" trailing=" " val="bif"/>
                              <OtherNode start="(125, 24)" end="(125, 30)" kind="«term_==_»">
                                <IdentNode start="(125, 24)" end="(125, 25)" leading="" trailing=" " raw_val="k" val="k"/>
                                <AtomNode start="(125, 26)" end="(125, 28)" leading="" trailing=" " val="=="/>
                                <OtherNode start="(125, 29)" end="(125, 30)" kind="num">
                                  <AtomNode start="(125, 29)" end="(125, 30)" leading="" trailing=" " val="0"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(125, 31)" end="(125, 35)" leading="" trailing=" " val="then"/>
                              <IdentNode start="(125, 36)" end="(125, 38)" leading="" trailing=" " raw_val="id" val="id" full_name="id" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(125, 39)" end="(125, 43)" leading="" trailing=" " val="else"/>
                              <OtherNode start="(125, 44)" end="(125, 60)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(125, 44)" end="(125, 46)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(125, 47)" end="(125, 60)">
                                  <OtherNode start="(125, 47)" end="(125, 58)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(125, 47)" end="(125, 48)" leading="" trailing="" val="("/>
                                    <OtherNode start="(125, 48)" end="(125, 57)" kind="«term_*_»">
                                      <IdentNode start="(125, 48)" end="(125, 53)" leading="" trailing=" " raw_val="coeff" val="coeff"/>
                                      <AtomNode start="(125, 54)" end="(125, 55)" leading="" trailing=" " val="*"/>
                                      <IdentNode start="(125, 56)" end="(125, 57)" leading="" trailing="" raw_val="k" val="k"/>
                                    </OtherNode>
                                    <AtomNode start="(125, 57)" end="(125, 58)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(125, 59)" end="(125, 60)" leading="" trailing="&#10;&#10;" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(127, 1)" end="(128, 16)" name="Expr.toNormPoly" full_name="Nat.Linear.Expr.toNormPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(127, 1)" end="(128, 16)" name="Expr.toNormPoly">
        <AtomNode start="(127, 1)" end="(127, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(127, 5)" end="(127, 20)">
          <IdentNode start="(127, 5)" end="(127, 20)" leading="" trailing=" " raw_val="Expr.toNormPoly" val="Expr.toNormPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(127, 21)" end="(127, 38)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(127, 21)" end="(127, 31)">
            <TermExplicitbinderNode start="(127, 21)" end="(127, 31)">
              <AtomNode start="(127, 21)" end="(127, 22)" leading="" trailing="" val="("/>
              <NullNode start="(127, 22)" end="(127, 23)">
                <IdentNode start="(127, 22)" end="(127, 23)" leading="" trailing=" " raw_val="e" val="e"/>
              </NullNode>
              <NullNode start="(127, 24)" end="(127, 30)">
                <AtomNode start="(127, 24)" end="(127, 25)" leading="" trailing=" " val=":"/>
                <IdentNode start="(127, 26)" end="(127, 30)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(127, 30)" end="(127, 31)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(127, 32)" end="(127, 38)">
            <TermTypespecNode start="(127, 32)" end="(127, 38)">
              <AtomNode start="(127, 32)" end="(127, 33)" leading="" trailing=" " val=":"/>
              <IdentNode start="(127, 34)" end="(127, 38)" leading="" trailing=" " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(127, 39)" end="(128, 16)">
          <AtomNode start="(127, 39)" end="(127, 41)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(128, 3)" end="(128, 16)" leading="" trailing="&#10;&#10;" raw_val="e.toPoly.norm" val="e.toPoly.norm"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(130, 1)" end="(131, 19)" name="Expr.inc" full_name="Nat.Linear.Expr.inc">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(130, 1)" end="(131, 19)" name="Expr.inc">
        <AtomNode start="(130, 1)" end="(130, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(130, 5)" end="(130, 13)">
          <IdentNode start="(130, 5)" end="(130, 13)" leading="" trailing=" " raw_val="Expr.inc" val="Expr.inc"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(130, 14)" end="(130, 31)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(130, 14)" end="(130, 24)">
            <TermExplicitbinderNode start="(130, 14)" end="(130, 24)">
              <AtomNode start="(130, 14)" end="(130, 15)" leading="" trailing="" val="("/>
              <NullNode start="(130, 15)" end="(130, 16)">
                <IdentNode start="(130, 15)" end="(130, 16)" leading="" trailing=" " raw_val="e" val="e"/>
              </NullNode>
              <NullNode start="(130, 17)" end="(130, 23)">
                <AtomNode start="(130, 17)" end="(130, 18)" leading="" trailing=" " val=":"/>
                <IdentNode start="(130, 19)" end="(130, 23)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(130, 23)" end="(130, 24)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(130, 25)" end="(130, 31)">
            <TermTypespecNode start="(130, 25)" end="(130, 31)">
              <AtomNode start="(130, 25)" end="(130, 26)" leading="" trailing=" " val=":"/>
              <IdentNode start="(130, 27)" end="(130, 31)" leading="" trailing=" " raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(130, 32)" end="(131, 19)">
          <AtomNode start="(130, 32)" end="(130, 34)" leading="" trailing="&#10;   " val=":="/>
          <OtherNode start="(131, 4)" end="(131, 19)" kind="Lean.Parser.Term.app">
            <OtherNode start="(131, 4)" end="(131, 8)" kind="Lean.Parser.Term.dotIdent">
              <AtomNode start="(131, 4)" end="(131, 5)" leading="" trailing="" val="."/>
              <IdentNode start="(131, 5)" end="(131, 8)" leading="" trailing=" " raw_val="add" val="add"/>
            </OtherNode>
            <NullNode start="(131, 9)" end="(131, 19)">
              <IdentNode start="(131, 9)" end="(131, 10)" leading="" trailing=" " raw_val="e" val="e"/>
              <OtherNode start="(131, 11)" end="(131, 19)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(131, 11)" end="(131, 12)" leading="" trailing="" val="("/>
                <OtherNode start="(131, 12)" end="(131, 18)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(131, 12)" end="(131, 16)" kind="Lean.Parser.Term.dotIdent">
                    <AtomNode start="(131, 12)" end="(131, 13)" leading="" trailing="" val="."/>
                    <IdentNode start="(131, 13)" end="(131, 16)" leading="" trailing=" " raw_val="num" val="num"/>
                  </OtherNode>
                  <NullNode start="(131, 17)" end="(131, 18)">
                    <OtherNode start="(131, 17)" end="(131, 18)" kind="num">
                      <AtomNode start="(131, 17)" end="(131, 18)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(131, 18)" end="(131, 19)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(133, 1)" end="(137, 15)" name="PolyCnstr" full_name="Nat.Linear.PolyCnstr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandStructureNode start="(133, 1)" end="(137, 15)" name="PolyCnstr">
        <CommandStructuretkNode start="(133, 1)" end="(133, 10)">
          <AtomNode start="(133, 1)" end="(133, 10)" leading="" trailing=" " val="structure"/>
        </CommandStructuretkNode>
        <CommandDeclidNode start="(133, 11)" end="(133, 20)">
          <IdentNode start="(133, 11)" end="(133, 20)" leading="" trailing="  " raw_val="PolyCnstr" val="PolyCnstr"/>
          <NullNode/>
        </CommandDeclidNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode start="(133, 22)" end="(136, 13)">
          <AtomNode start="(133, 22)" end="(133, 27)" leading="" trailing="&#10;  " val="where"/>
          <NullNode/>
          <OtherNode start="(134, 3)" end="(136, 13)" kind="Lean.Parser.Command.structFields">
            <NullNode start="(134, 3)" end="(136, 13)">
              <OtherNode start="(134, 3)" end="(134, 13)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(134, 3)" end="(134, 5)" leading="" trailing="  " raw_val="eq" val="eq"/>
                <OtherNode start="(134, 7)" end="(134, 13)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(134, 7)" end="(134, 13)">
                    <TermTypespecNode start="(134, 7)" end="(134, 13)">
                      <AtomNode start="(134, 7)" end="(134, 8)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(134, 9)" end="(134, 13)" leading="" trailing="&#10;  " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(135, 3)" end="(135, 13)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(135, 3)" end="(135, 6)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                <OtherNode start="(135, 7)" end="(135, 13)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(135, 7)" end="(135, 13)">
                    <TermTypespecNode start="(135, 7)" end="(135, 13)">
                      <AtomNode start="(135, 7)" end="(135, 8)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(135, 9)" end="(135, 13)" leading="" trailing="&#10;  " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(136, 3)" end="(136, 13)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(136, 3)" end="(136, 6)" leading="" trailing=" " raw_val="rhs" val="rhs"/>
                <OtherNode start="(136, 7)" end="(136, 13)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(136, 7)" end="(136, 13)">
                    <TermTypespecNode start="(136, 7)" end="(136, 13)">
                      <AtomNode start="(136, 7)" end="(136, 8)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(136, 9)" end="(136, 13)" leading="" trailing="&#10;  " raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode/>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </NullNode>
        <OtherNode start="(137, 3)" end="(137, 15)" kind="Lean.Parser.Command.optDeriving">
          <NullNode start="(137, 3)" end="(137, 15)">
            <AtomNode start="(137, 3)" end="(137, 11)" leading="" trailing=" " val="deriving"/>
            <NullNode start="(137, 12)" end="(137, 15)">
              <IdentNode start="(137, 12)" end="(137, 15)" leading="" trailing="&#10;&#10;-- TODO: implement LawfulBEq generator companion for BEq&#10;" raw_val="BEq" val="BEq" full_name="BEq.mk" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </NullNode>
          </NullNode>
        </OtherNode>
      </CommandStructureNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(140, 1)" end="(151, 9)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(140, 1)" end="(151, 9)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(140, 1)" end="(140, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(140, 10)" end="(140, 31)">
          <NullNode/>
          <TermTypespecNode start="(140, 10)" end="(140, 31)">
            <AtomNode start="(140, 10)" end="(140, 11)" leading="" trailing=" " val=":"/>
            <OtherNode start="(140, 12)" end="(140, 31)" kind="Lean.Parser.Term.app">
              <IdentNode start="(140, 12)" end="(140, 21)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(140, 22)" end="(140, 31)">
                <IdentNode start="(140, 22)" end="(140, 31)" leading="" trailing=" " raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(140, 32)" end="(151, 9)">
          <AtomNode start="(140, 32)" end="(140, 37)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(141, 3)" end="(151, 9)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(141, 3)" end="(151, 9)">
              <OtherNode start="(141, 3)" end="(147, 20)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(141, 3)" end="(141, 12)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(141, 3)" end="(141, 12)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(141, 13)" end="(147, 20)">
                  <NullNode start="(141, 13)" end="(141, 20)">
                    <OtherNode start="(141, 13)" end="(141, 18)" kind="Lean.Parser.Term.implicitBinder">
                      <AtomNode start="(141, 13)" end="(141, 14)" leading="" trailing="" val="{"/>
                      <NullNode start="(141, 14)" end="(141, 17)">
                        <IdentNode start="(141, 14)" end="(141, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(141, 16)" end="(141, 17)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(141, 17)" end="(141, 18)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <IdentNode start="(141, 19)" end="(141, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(141, 21)" end="(147, 20)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(141, 21)" end="(141, 23)" leading="" trailing=" " val=":="/>
                    <TermBytacticNode start="(141, 24)" end="(147, 20)">
                      <AtomNode start="(141, 24)" end="(141, 26)" leading="" trailing="&#10;    " val="by"/>
                      <TacticTacticseqNode start="(142, 5)" end="(147, 20)">
                        <TacticTacticseq1IndentedNode start="(142, 5)" end="(147, 20)">
                          <NullNode start="(142, 5)" end="(147, 20)">
                            <OtherNode start="(142, 5)" end="(142, 12)" kind="Lean.Parser.Tactic.cases" state_before="a b : PolyCnstr&#10;h : (a == b) = true&#10;⊢ a = b" state_after="case mk&#10;b : PolyCnstr&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;h : ({ eq := eq✝, lhs := lhs✝, rhs := rhs✝ } == b) = true&#10;⊢ { eq := eq✝, lhs := lhs✝, rhs := rhs✝ } = b" tactic="cases a">
                              <AtomNode start="(142, 5)" end="(142, 10)" leading="" trailing=" " val="cases"/>
                              <NullNode start="(142, 11)" end="(142, 12)">
                                <OtherNode start="(142, 11)" end="(142, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                  <NullNode/>
                                  <IdentNode start="(142, 11)" end="(142, 12)" leading="" trailing="" raw_val="a" val="a"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(142, 12)" end="(142, 13)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(142, 14)" end="(142, 36)" kind="Lean.Parser.Tactic.renameI" state_before="case mk&#10;b : PolyCnstr&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;h : ({ eq := eq✝, lhs := lhs✝, rhs := rhs✝ } == b) = true&#10;⊢ { eq := eq✝, lhs := lhs✝, rhs := rhs✝ } = b" state_after="case mk&#10;b : PolyCnstr&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;h : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == b) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = b" tactic="rename_i eq₁ lhs₁ rhs₁">
                              <AtomNode start="(142, 14)" end="(142, 22)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(142, 23)" end="(142, 36)">
                                <LeanBinderidentNode start="(142, 23)" end="(142, 26)">
                                  <IdentNode start="(142, 23)" end="(142, 26)" leading="" trailing=" " raw_val="eq₁" val="eq₁"/>
                                </LeanBinderidentNode>
                                <LeanBinderidentNode start="(142, 27)" end="(142, 31)">
                                  <IdentNode start="(142, 27)" end="(142, 31)" leading="" trailing=" " raw_val="lhs₁" val="lhs₁"/>
                                </LeanBinderidentNode>
                                <LeanBinderidentNode start="(142, 32)" end="(142, 36)">
                                  <IdentNode start="(142, 32)" end="(142, 36)" leading="" trailing="&#10;    " raw_val="rhs₁" val="rhs₁"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(143, 5)" end="(143, 12)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;b : PolyCnstr&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;h : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == b) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = b" state_after="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;h : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }" tactic="cases b">
                              <AtomNode start="(143, 5)" end="(143, 10)" leading="" trailing=" " val="cases"/>
                              <NullNode start="(143, 11)" end="(143, 12)">
                                <OtherNode start="(143, 11)" end="(143, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                  <NullNode/>
                                  <IdentNode start="(143, 11)" end="(143, 12)" leading="" trailing="" raw_val="b" val="b"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(143, 12)" end="(143, 13)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(143, 14)" end="(143, 36)" kind="Lean.Parser.Tactic.renameI" state_before="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;h : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }" state_after="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" tactic="rename_i eq₂ lhs₂ rhs₂">
                              <AtomNode start="(143, 14)" end="(143, 22)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(143, 23)" end="(143, 36)">
                                <LeanBinderidentNode start="(143, 23)" end="(143, 26)">
                                  <IdentNode start="(143, 23)" end="(143, 26)" leading="" trailing=" " raw_val="eq₂" val="eq₂"/>
                                </LeanBinderidentNode>
                                <LeanBinderidentNode start="(143, 27)" end="(143, 31)">
                                  <IdentNode start="(143, 27)" end="(143, 31)" leading="" trailing=" " raw_val="lhs₂" val="lhs₂"/>
                                </LeanBinderidentNode>
                                <LeanBinderidentNode start="(143, 32)" end="(143, 36)">
                                  <IdentNode start="(143, 32)" end="(143, 36)" leading="" trailing="&#10;    " raw_val="rhs₂" val="rhs₂"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(144, 5)" end="(144, 63)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" state_after="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h✝ : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;h : (eq₁ == eq₂ &amp;amp;&amp;amp; (lhs₁ == lhs₂ &amp;amp;&amp;amp; rhs₁ == rhs₂)) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" tactic="have h : eq₁ == eq₂ &amp;amp;&amp;amp; (lhs₁ == lhs₂ &amp;amp;&amp;amp; rhs₁ == rhs₂) := h">
                              <AtomNode start="(144, 5)" end="(144, 9)" leading="" trailing=" " val="have"/>
                              <OtherNode start="(144, 10)" end="(144, 63)" kind="Lean.Parser.Term.haveDecl">
                                <OtherNode start="(144, 10)" end="(144, 63)" kind="Lean.Parser.Term.haveIdDecl">
                                  <OtherNode start="(144, 10)" end="(144, 11)" kind="Lean.Parser.Term.haveId">
                                    <IdentNode start="(144, 10)" end="(144, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(144, 12)" end="(144, 58)">
                                    <TermTypespecNode start="(144, 12)" end="(144, 58)">
                                      <AtomNode start="(144, 12)" end="(144, 13)" leading="" trailing=" " val=":"/>
                                      <OtherNode start="(144, 14)" end="(144, 58)" kind="«term_&amp;amp;&amp;amp;_»">
                                        <OtherNode start="(144, 14)" end="(144, 24)" kind="«term_==_»">
                                          <IdentNode start="(144, 14)" end="(144, 17)" leading="" trailing=" " raw_val="eq₁" val="eq₁"/>
                                          <AtomNode start="(144, 18)" end="(144, 20)" leading="" trailing=" " val="=="/>
                                          <IdentNode start="(144, 21)" end="(144, 24)" leading="" trailing=" " raw_val="eq₂" val="eq₂"/>
                                        </OtherNode>
                                        <AtomNode start="(144, 25)" end="(144, 27)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                                        <OtherNode start="(144, 28)" end="(144, 58)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(144, 28)" end="(144, 29)" leading="" trailing="" val="("/>
                                          <OtherNode start="(144, 29)" end="(144, 57)" kind="«term_&amp;amp;&amp;amp;_»">
                                            <OtherNode start="(144, 29)" end="(144, 41)" kind="«term_==_»">
                                              <IdentNode start="(144, 29)" end="(144, 33)" leading="" trailing=" " raw_val="lhs₁" val="lhs₁"/>
                                              <AtomNode start="(144, 34)" end="(144, 36)" leading="" trailing=" " val="=="/>
                                              <IdentNode start="(144, 37)" end="(144, 41)" leading="" trailing=" " raw_val="lhs₂" val="lhs₂"/>
                                            </OtherNode>
                                            <AtomNode start="(144, 42)" end="(144, 44)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                                            <OtherNode start="(144, 45)" end="(144, 57)" kind="«term_==_»">
                                              <IdentNode start="(144, 45)" end="(144, 49)" leading="" trailing=" " raw_val="rhs₁" val="rhs₁"/>
                                              <AtomNode start="(144, 50)" end="(144, 52)" leading="" trailing=" " val="=="/>
                                              <IdentNode start="(144, 53)" end="(144, 57)" leading="" trailing="" raw_val="rhs₂" val="rhs₂"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(144, 57)" end="(144, 58)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </TermTypespecNode>
                                  </NullNode>
                                  <AtomNode start="(144, 59)" end="(144, 61)" leading="" trailing=" " val=":="/>
                                  <IdentNode start="(144, 62)" end="(144, 63)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(145, 5)" end="(145, 14)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h✝ : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;h : (eq₁ == eq₂ &amp;amp;&amp;amp; (lhs₁ == lhs₂ &amp;amp;&amp;amp; rhs₁ == rhs₂)) = true&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" state_after="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h✝ : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;h : eq₁ = eq₂ ∧ lhs₁ = lhs₂ ∧ rhs₁ = rhs₂&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" tactic="simp at h">
                              <AtomNode start="(145, 5)" end="(145, 9)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(145, 10)" end="(145, 14)">
                                <OtherNode start="(145, 10)" end="(145, 14)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(145, 10)" end="(145, 12)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(145, 13)" end="(145, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(145, 13)" end="(145, 14)">
                                      <IdentNode start="(145, 13)" end="(145, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(146, 5)" end="(146, 27)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h✝ : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;h : eq₁ = eq₂ ∧ lhs₁ = lhs₂ ∧ rhs₁ = rhs₂&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" state_after="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h✝ : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;h : eq₁ = eq₂ ∧ lhs₁ = lhs₂ ∧ rhs₁ = rhs₂&#10;h₁ : eq₁ = eq₂&#10;h₂ : lhs₁ = lhs₂&#10;h₃ : rhs₁ = rhs₂&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" tactic="have ⟨h₁, h₂, h₃⟩ := h">
                              <AtomNode start="(146, 5)" end="(146, 9)" leading="" trailing=" " val="have"/>
                              <OtherNode start="(146, 10)" end="(146, 27)" kind="Lean.Parser.Term.haveDecl">
                                <OtherNode start="(146, 10)" end="(146, 27)" kind="Lean.Parser.Term.letPatDecl">
                                  <OtherNode start="(146, 10)" end="(146, 22)" kind="Lean.Parser.Term.anonymousCtor">
                                    <AtomNode start="(146, 10)" end="(146, 11)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(146, 11)" end="(146, 21)">
                                      <IdentNode start="(146, 11)" end="(146, 13)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                      <AtomNode start="(146, 13)" end="(146, 14)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(146, 15)" end="(146, 17)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                      <AtomNode start="(146, 17)" end="(146, 18)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(146, 19)" end="(146, 21)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                    </NullNode>
                                    <AtomNode start="(146, 21)" end="(146, 22)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(146, 23)" end="(146, 25)" leading="" trailing=" " val=":="/>
                                  <IdentNode start="(146, 26)" end="(146, 27)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(147, 5)" end="(147, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk.mk&#10;eq₁ : Bool&#10;lhs₁ rhs₁ : Poly&#10;eq₂ : Bool&#10;lhs₂ rhs₂ : Poly&#10;h✝ : ({ eq := eq₁, lhs := lhs₁, rhs := rhs₁ } == { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }) = true&#10;h : eq₁ = eq₂ ∧ lhs₁ = lhs₂ ∧ rhs₁ = rhs₂&#10;h₁ : eq₁ = eq₂&#10;h₂ : lhs₁ = lhs₂&#10;h₃ : rhs₁ = rhs₂&#10;⊢ { eq := eq₁, lhs := lhs₁, rhs := rhs₁ } = { eq := eq₂, lhs := lhs₂, rhs := rhs₂ }" state_after="no goals" tactic="rw [h₁, h₂, h₃]">
                              <AtomNode start="(147, 5)" end="(147, 7)" leading="" trailing=" " val="rw"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <OtherNode start="(147, 8)" end="(147, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                <AtomNode start="(147, 8)" end="(147, 9)" leading="" trailing="" val="["/>
                                <NullNode start="(147, 9)" end="(147, 19)">
                                  <OtherNode start="(147, 9)" end="(147, 11)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(147, 9)" end="(147, 11)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                  </OtherNode>
                                  <AtomNode start="(147, 11)" end="(147, 12)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(147, 13)" end="(147, 15)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(147, 13)" end="(147, 15)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                  </OtherNode>
                                  <AtomNode start="(147, 15)" end="(147, 16)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(147, 17)" end="(147, 19)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(147, 17)" end="(147, 19)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(147, 19)" end="(147, 20)" leading="" trailing="&#10;  " val="]"/>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <NullNode/>
              <OtherNode start="(148, 3)" end="(151, 9)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(148, 3)" end="(148, 6)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(148, 3)" end="(148, 6)" leading="" trailing=" " raw_val="rfl" val="rfl"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(148, 7)" end="(151, 9)">
                  <NullNode start="(148, 7)" end="(148, 10)">
                    <OtherNode start="(148, 7)" end="(148, 10)" kind="Lean.Parser.Term.implicitBinder">
                      <AtomNode start="(148, 7)" end="(148, 8)" leading="" trailing="" val="{"/>
                      <NullNode start="(148, 8)" end="(148, 9)">
                        <IdentNode start="(148, 8)" end="(148, 9)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(148, 9)" end="(148, 10)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(148, 11)" end="(151, 9)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(148, 11)" end="(148, 13)" leading="" trailing=" " val=":="/>
                    <TermBytacticNode start="(148, 14)" end="(151, 9)">
                      <AtomNode start="(148, 14)" end="(148, 16)" leading="" trailing="&#10;    " val="by"/>
                      <TacticTacticseqNode start="(149, 5)" end="(151, 9)">
                        <TacticTacticseq1IndentedNode start="(149, 5)" end="(151, 9)">
                          <NullNode start="(149, 5)" end="(151, 9)">
                            <OtherNode start="(149, 5)" end="(149, 12)" kind="Lean.Parser.Tactic.cases" state_before="a : PolyCnstr&#10;⊢ (a == a) = true" state_after="case mk&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;⊢ ({ eq := eq✝, lhs := lhs✝, rhs := rhs✝ } == { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }) = true" tactic="cases a">
                              <AtomNode start="(149, 5)" end="(149, 10)" leading="" trailing=" " val="cases"/>
                              <NullNode start="(149, 11)" end="(149, 12)">
                                <OtherNode start="(149, 11)" end="(149, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                  <NullNode/>
                                  <IdentNode start="(149, 11)" end="(149, 12)" leading="" trailing="" raw_val="a" val="a"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(149, 12)" end="(149, 13)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(149, 14)" end="(149, 33)" kind="Lean.Parser.Tactic.renameI" state_before="case mk&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;⊢ ({ eq := eq✝, lhs := lhs✝, rhs := rhs✝ } == { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }) = true" state_after="case mk&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ ({ eq := eq, lhs := lhs, rhs := rhs } == { eq := eq, lhs := lhs, rhs := rhs }) = true" tactic="rename_i eq lhs rhs">
                              <AtomNode start="(149, 14)" end="(149, 22)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(149, 23)" end="(149, 33)">
                                <LeanBinderidentNode start="(149, 23)" end="(149, 25)">
                                  <IdentNode start="(149, 23)" end="(149, 25)" leading="" trailing=" " raw_val="eq" val="eq"/>
                                </LeanBinderidentNode>
                                <LeanBinderidentNode start="(149, 26)" end="(149, 29)">
                                  <IdentNode start="(149, 26)" end="(149, 29)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                                </LeanBinderidentNode>
                                <LeanBinderidentNode start="(149, 30)" end="(149, 33)">
                                  <IdentNode start="(149, 30)" end="(149, 33)" leading="" trailing="&#10;    " raw_val="rhs" val="rhs"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(150, 5)" end="(150, 57)" kind="Lean.Parser.Tactic.tacticShow_" state_before="case mk&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ ({ eq := eq, lhs := lhs, rhs := rhs } == { eq := eq, lhs := lhs, rhs := rhs }) = true" state_after="case mk&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ (eq == eq &amp;amp;&amp;amp; (lhs == lhs &amp;amp;&amp;amp; rhs == rhs)) = true" tactic="show (eq == eq &amp;amp;&amp;amp; (lhs == lhs &amp;amp;&amp;amp; rhs == rhs)) = true">
                              <AtomNode start="(150, 5)" end="(150, 9)" leading="" trailing=" " val="show"/>
                              <OtherNode start="(150, 10)" end="(150, 57)" kind="«term_=_»">
                                <OtherNode start="(150, 10)" end="(150, 50)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(150, 10)" end="(150, 11)" leading="" trailing="" val="("/>
                                  <OtherNode start="(150, 11)" end="(150, 49)" kind="«term_&amp;amp;&amp;amp;_»">
                                    <OtherNode start="(150, 11)" end="(150, 19)" kind="«term_==_»">
                                      <IdentNode start="(150, 11)" end="(150, 13)" leading="" trailing=" " raw_val="eq" val="eq"/>
                                      <AtomNode start="(150, 14)" end="(150, 16)" leading="" trailing=" " val="=="/>
                                      <IdentNode start="(150, 17)" end="(150, 19)" leading="" trailing=" " raw_val="eq" val="eq"/>
                                    </OtherNode>
                                    <AtomNode start="(150, 20)" end="(150, 22)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                                    <OtherNode start="(150, 23)" end="(150, 49)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(150, 23)" end="(150, 24)" leading="" trailing="" val="("/>
                                      <OtherNode start="(150, 24)" end="(150, 48)" kind="«term_&amp;amp;&amp;amp;_»">
                                        <OtherNode start="(150, 24)" end="(150, 34)" kind="«term_==_»">
                                          <IdentNode start="(150, 24)" end="(150, 27)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                                          <AtomNode start="(150, 28)" end="(150, 30)" leading="" trailing=" " val="=="/>
                                          <IdentNode start="(150, 31)" end="(150, 34)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                                        </OtherNode>
                                        <AtomNode start="(150, 35)" end="(150, 37)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                                        <OtherNode start="(150, 38)" end="(150, 48)" kind="«term_==_»">
                                          <IdentNode start="(150, 38)" end="(150, 41)" leading="" trailing=" " raw_val="rhs" val="rhs"/>
                                          <AtomNode start="(150, 42)" end="(150, 44)" leading="" trailing=" " val="=="/>
                                          <IdentNode start="(150, 45)" end="(150, 48)" leading="" trailing="" raw_val="rhs" val="rhs"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(150, 48)" end="(150, 49)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(150, 49)" end="(150, 50)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(150, 51)" end="(150, 52)" leading="" trailing=" " val="="/>
                                <IdentNode start="(150, 53)" end="(150, 57)" leading="" trailing="&#10;    " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </OtherNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(151, 5)" end="(151, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ (eq == eq &amp;amp;&amp;amp; (lhs == lhs &amp;amp;&amp;amp; rhs == rhs)) = true" state_after="no goals" tactic="simp">
                              <AtomNode start="(151, 5)" end="(151, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(156, 13)" name="ExprCnstr" full_name="Nat.Linear.ExprCnstr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandStructureNode start="(153, 1)" end="(156, 13)" name="ExprCnstr">
        <CommandStructuretkNode start="(153, 1)" end="(153, 10)">
          <AtomNode start="(153, 1)" end="(153, 10)" leading="" trailing=" " val="structure"/>
        </CommandStructuretkNode>
        <CommandDeclidNode start="(153, 11)" end="(153, 20)">
          <IdentNode start="(153, 11)" end="(153, 20)" leading="" trailing=" " raw_val="ExprCnstr" val="ExprCnstr"/>
          <NullNode/>
        </CommandDeclidNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode start="(153, 21)" end="(156, 13)">
          <AtomNode start="(153, 21)" end="(153, 26)" leading="" trailing="&#10;  " val="where"/>
          <NullNode/>
          <OtherNode start="(154, 3)" end="(156, 13)" kind="Lean.Parser.Command.structFields">
            <NullNode start="(154, 3)" end="(156, 13)">
              <OtherNode start="(154, 3)" end="(154, 13)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(154, 3)" end="(154, 5)" leading="" trailing="  " raw_val="eq" val="eq"/>
                <OtherNode start="(154, 7)" end="(154, 13)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(154, 7)" end="(154, 13)">
                    <TermTypespecNode start="(154, 7)" end="(154, 13)">
                      <AtomNode start="(154, 7)" end="(154, 8)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(154, 9)" end="(154, 13)" leading="" trailing="&#10;  " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(155, 3)" end="(155, 13)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(155, 3)" end="(155, 6)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                <OtherNode start="(155, 7)" end="(155, 13)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(155, 7)" end="(155, 13)">
                    <TermTypespecNode start="(155, 7)" end="(155, 13)">
                      <AtomNode start="(155, 7)" end="(155, 8)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(155, 9)" end="(155, 13)" leading="" trailing="&#10;  " raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(156, 3)" end="(156, 13)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(156, 3)" end="(156, 6)" leading="" trailing=" " raw_val="rhs" val="rhs"/>
                <OtherNode start="(156, 7)" end="(156, 13)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(156, 7)" end="(156, 13)">
                    <TermTypespecNode start="(156, 7)" end="(156, 13)">
                      <AtomNode start="(156, 7)" end="(156, 8)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(156, 9)" end="(156, 13)" leading="" trailing="&#10;&#10;" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode/>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </NullNode>
        <OtherNode kind="Lean.Parser.Command.optDeriving">
          <NullNode/>
        </OtherNode>
      </CommandStructureNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(158, 1)" end="(162, 38)" name="PolyCnstr.denote" full_name="Nat.Linear.PolyCnstr.denote">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(158, 1)" end="(162, 38)" name="PolyCnstr.denote">
        <AtomNode start="(158, 1)" end="(158, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(158, 5)" end="(158, 21)">
          <IdentNode start="(158, 5)" end="(158, 21)" leading="" trailing=" " raw_val="PolyCnstr.denote" val="PolyCnstr.denote"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(158, 22)" end="(158, 60)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(158, 22)" end="(158, 53)">
            <TermExplicitbinderNode start="(158, 22)" end="(158, 37)">
              <AtomNode start="(158, 22)" end="(158, 23)" leading="" trailing="" val="("/>
              <NullNode start="(158, 23)" end="(158, 26)">
                <IdentNode start="(158, 23)" end="(158, 26)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(158, 27)" end="(158, 36)">
                <AtomNode start="(158, 27)" end="(158, 28)" leading="" trailing=" " val=":"/>
                <IdentNode start="(158, 29)" end="(158, 36)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(158, 36)" end="(158, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(158, 38)" end="(158, 53)">
              <AtomNode start="(158, 38)" end="(158, 39)" leading="" trailing="" val="("/>
              <NullNode start="(158, 39)" end="(158, 40)">
                <IdentNode start="(158, 39)" end="(158, 40)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(158, 41)" end="(158, 52)">
                <AtomNode start="(158, 41)" end="(158, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(158, 43)" end="(158, 52)" leading="" trailing="" raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(158, 52)" end="(158, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(158, 54)" end="(158, 60)">
            <TermTypespecNode start="(158, 54)" end="(158, 60)">
              <AtomNode start="(158, 54)" end="(158, 55)" leading="" trailing=" " val=":"/>
              <OtherNode start="(158, 56)" end="(158, 60)" kind="Lean.Parser.Term.prop">
                <AtomNode start="(158, 56)" end="(158, 60)" leading="" trailing=" " val="Prop"/>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(158, 61)" end="(162, 38)">
          <AtomNode start="(158, 61)" end="(158, 63)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(159, 3)" end="(162, 38)" kind="boolIfThenElse">
            <AtomNode start="(159, 3)" end="(159, 6)" leading="" trailing=" " val="bif"/>
            <IdentNode start="(159, 7)" end="(159, 11)" leading="" trailing=" " raw_val="c.eq" val="c.eq"/>
            <AtomNode start="(159, 12)" end="(159, 16)" leading="" trailing="&#10;    " val="then"/>
            <OtherNode start="(160, 5)" end="(160, 38)" kind="Lean.Parser.Term.app">
              <IdentNode start="(160, 5)" end="(160, 19)" leading="" trailing=" " raw_val="Poly.denote_eq" val="Poly.denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
              <NullNode start="(160, 20)" end="(160, 38)">
                <IdentNode start="(160, 20)" end="(160, 23)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(160, 24)" end="(160, 38)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(160, 24)" end="(160, 25)" leading="" trailing="" val="("/>
                  <NullNode start="(160, 25)" end="(160, 37)">
                    <IdentNode start="(160, 25)" end="(160, 30)" leading="" trailing="" raw_val="c.lhs" val="c.lhs"/>
                    <AtomNode start="(160, 30)" end="(160, 31)" leading="" trailing=" " val=","/>
                    <NullNode start="(160, 32)" end="(160, 37)">
                      <IdentNode start="(160, 32)" end="(160, 37)" leading="" trailing="" raw_val="c.rhs" val="c.rhs"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(160, 37)" end="(160, 38)" leading="" trailing="&#10;  " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <AtomNode start="(161, 3)" end="(161, 7)" leading="" trailing="&#10;    " val="else"/>
            <OtherNode start="(162, 5)" end="(162, 38)" kind="Lean.Parser.Term.app">
              <IdentNode start="(162, 5)" end="(162, 19)" leading="" trailing=" " raw_val="Poly.denote_le" val="Poly.denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
              <NullNode start="(162, 20)" end="(162, 38)">
                <IdentNode start="(162, 20)" end="(162, 23)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(162, 24)" end="(162, 38)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(162, 24)" end="(162, 25)" leading="" trailing="" val="("/>
                  <NullNode start="(162, 25)" end="(162, 37)">
                    <IdentNode start="(162, 25)" end="(162, 30)" leading="" trailing="" raw_val="c.lhs" val="c.lhs"/>
                    <AtomNode start="(162, 30)" end="(162, 31)" leading="" trailing=" " val=","/>
                    <NullNode start="(162, 32)" end="(162, 37)">
                      <IdentNode start="(162, 32)" end="(162, 37)" leading="" trailing="" raw_val="c.rhs" val="c.rhs"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(162, 37)" end="(162, 38)" leading="" trailing="&#10;&#10;" val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(164, 1)" end="(166, 27)" name="PolyCnstr.norm" full_name="Nat.Linear.PolyCnstr.norm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(164, 1)" end="(166, 27)" name="PolyCnstr.norm">
        <AtomNode start="(164, 1)" end="(164, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(164, 5)" end="(164, 19)">
          <IdentNode start="(164, 5)" end="(164, 19)" leading="" trailing=" " raw_val="PolyCnstr.norm" val="PolyCnstr.norm"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(164, 20)" end="(164, 47)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(164, 20)" end="(164, 35)">
            <TermExplicitbinderNode start="(164, 20)" end="(164, 35)">
              <AtomNode start="(164, 20)" end="(164, 21)" leading="" trailing="" val="("/>
              <NullNode start="(164, 21)" end="(164, 22)">
                <IdentNode start="(164, 21)" end="(164, 22)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(164, 23)" end="(164, 34)">
                <AtomNode start="(164, 23)" end="(164, 24)" leading="" trailing=" " val=":"/>
                <IdentNode start="(164, 25)" end="(164, 34)" leading="" trailing="" raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(164, 34)" end="(164, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(164, 36)" end="(164, 47)">
            <TermTypespecNode start="(164, 36)" end="(164, 47)">
              <AtomNode start="(164, 36)" end="(164, 37)" leading="" trailing=" " val=":"/>
              <IdentNode start="(164, 38)" end="(164, 47)" leading="" trailing=" " raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(164, 48)" end="(166, 27)">
          <AtomNode start="(164, 48)" end="(164, 50)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(165, 3)" end="(166, 27)" kind="Lean.Parser.Term.let">
            <AtomNode start="(165, 3)" end="(165, 6)" leading="" trailing=" " val="let"/>
            <OtherNode start="(165, 7)" end="(165, 54)" kind="Lean.Parser.Term.letDecl">
              <OtherNode start="(165, 7)" end="(165, 54)" kind="Lean.Parser.Term.letPatDecl">
                <OtherNode start="(165, 7)" end="(165, 17)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(165, 7)" end="(165, 8)" leading="" trailing="" val="("/>
                  <NullNode start="(165, 8)" end="(165, 16)">
                    <IdentNode start="(165, 8)" end="(165, 11)" leading="" trailing="" raw_val="lhs" val="lhs"/>
                    <AtomNode start="(165, 11)" end="(165, 12)" leading="" trailing=" " val=","/>
                    <NullNode start="(165, 13)" end="(165, 16)">
                      <IdentNode start="(165, 13)" end="(165, 16)" leading="" trailing="" raw_val="rhs" val="rhs"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(165, 16)" end="(165, 17)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <NullNode/>
                <NullNode/>
                <AtomNode start="(165, 18)" end="(165, 20)" leading="" trailing=" " val=":="/>
                <OtherNode start="(165, 21)" end="(165, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(165, 21)" end="(165, 32)" leading="" trailing=" " raw_val="Poly.cancel" val="Poly.cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                  <NullNode start="(165, 33)" end="(165, 54)">
                    <IdentNode start="(165, 33)" end="(165, 43)" leading="" trailing=" " raw_val="c.lhs.norm" val="c.lhs.norm"/>
                    <IdentNode start="(165, 44)" end="(165, 54)" leading="" trailing="&#10;  " raw_val="c.rhs.norm" val="c.rhs.norm"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <NullNode/>
            <OtherNode start="(166, 3)" end="(166, 27)" kind="Lean.Parser.Term.structInst">
              <AtomNode start="(166, 3)" end="(166, 4)" leading="" trailing=" " val="{"/>
              <NullNode/>
              <OtherNode start="(166, 5)" end="(166, 25)" kind="Lean.Parser.Term.structInstFields">
                <NullNode start="(166, 5)" end="(166, 25)">
                  <OtherNode start="(166, 5)" end="(166, 15)" kind="Lean.Parser.Term.structInstField">
                    <OtherNode start="(166, 5)" end="(166, 7)" kind="Lean.Parser.Term.structInstLVal">
                      <IdentNode start="(166, 5)" end="(166, 7)" leading="" trailing=" " raw_val="eq" val="eq"/>
                      <NullNode/>
                    </OtherNode>
                    <NullNode start="(166, 8)" end="(166, 15)">
                      <NullNode/>
                      <NullNode/>
                      <OtherNode start="(166, 8)" end="(166, 15)" kind="Lean.Parser.Term.structInstFieldDef">
                        <AtomNode start="(166, 8)" end="(166, 10)" leading="" trailing=" " val=":="/>
                        <IdentNode start="(166, 11)" end="(166, 15)" leading="" trailing="" raw_val="c.eq" val="c.eq"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(166, 15)" end="(166, 16)" leading="" trailing=" " val=","/>
                  <OtherNode start="(166, 17)" end="(166, 20)" kind="Lean.Parser.Term.structInstField">
                    <OtherNode start="(166, 17)" end="(166, 20)" kind="Lean.Parser.Term.structInstLVal">
                      <IdentNode start="(166, 17)" end="(166, 20)" leading="" trailing="" raw_val="lhs" val="lhs"/>
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(166, 20)" end="(166, 21)" leading="" trailing=" " val=","/>
                  <OtherNode start="(166, 22)" end="(166, 25)" kind="Lean.Parser.Term.structInstField">
                    <OtherNode start="(166, 22)" end="(166, 25)" kind="Lean.Parser.Term.structInstLVal">
                      <IdentNode start="(166, 22)" end="(166, 25)" leading="" trailing=" " raw_val="rhs" val="rhs"/>
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <OtherNode kind="Lean.Parser.Term.optEllipsis">
                <NullNode/>
              </OtherNode>
              <NullNode/>
              <AtomNode start="(166, 26)" end="(166, 27)" leading="" trailing="&#10;&#10;" val="}"/>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(168, 1)" end="(172, 36)" name="PolyCnstr.isUnsat" full_name="Nat.Linear.PolyCnstr.isUnsat">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(168, 1)" end="(172, 36)" name="PolyCnstr.isUnsat">
        <AtomNode start="(168, 1)" end="(168, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(168, 5)" end="(168, 22)">
          <IdentNode start="(168, 5)" end="(168, 22)" leading="" trailing=" " raw_val="PolyCnstr.isUnsat" val="PolyCnstr.isUnsat"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(168, 23)" end="(168, 45)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(168, 23)" end="(168, 38)">
            <TermExplicitbinderNode start="(168, 23)" end="(168, 38)">
              <AtomNode start="(168, 23)" end="(168, 24)" leading="" trailing="" val="("/>
              <NullNode start="(168, 24)" end="(168, 25)">
                <IdentNode start="(168, 24)" end="(168, 25)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(168, 26)" end="(168, 37)">
                <AtomNode start="(168, 26)" end="(168, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(168, 28)" end="(168, 37)" leading="" trailing="" raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(168, 37)" end="(168, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(168, 39)" end="(168, 45)">
            <TermTypespecNode start="(168, 39)" end="(168, 45)">
              <AtomNode start="(168, 39)" end="(168, 40)" leading="" trailing=" " val=":"/>
              <IdentNode start="(168, 41)" end="(168, 45)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(168, 46)" end="(172, 36)">
          <AtomNode start="(168, 46)" end="(168, 48)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(169, 3)" end="(172, 36)" kind="boolIfThenElse">
            <AtomNode start="(169, 3)" end="(169, 6)" leading="" trailing=" " val="bif"/>
            <IdentNode start="(169, 7)" end="(169, 11)" leading="" trailing=" " raw_val="c.eq" val="c.eq"/>
            <AtomNode start="(169, 12)" end="(169, 16)" leading="" trailing="&#10;    " val="then"/>
            <OtherNode start="(170, 5)" end="(170, 75)" kind="«term_||_»">
              <OtherNode start="(170, 5)" end="(170, 38)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(170, 5)" end="(170, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(170, 6)" end="(170, 37)" kind="«term_&amp;amp;&amp;amp;_»">
                  <IdentNode start="(170, 6)" end="(170, 18)" leading="" trailing=" " raw_val="c.lhs.isZero" val="c.lhs.isZero"/>
                  <AtomNode start="(170, 19)" end="(170, 21)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                  <IdentNode start="(170, 22)" end="(170, 37)" leading="" trailing="" raw_val="c.rhs.isNonZero" val="c.rhs.isNonZero"/>
                </OtherNode>
                <AtomNode start="(170, 37)" end="(170, 38)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(170, 39)" end="(170, 41)" leading="" trailing=" " val="||"/>
              <OtherNode start="(170, 42)" end="(170, 75)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(170, 42)" end="(170, 43)" leading="" trailing="" val="("/>
                <OtherNode start="(170, 43)" end="(170, 74)" kind="«term_&amp;amp;&amp;amp;_»">
                  <IdentNode start="(170, 43)" end="(170, 58)" leading="" trailing=" " raw_val="c.lhs.isNonZero" val="c.lhs.isNonZero"/>
                  <AtomNode start="(170, 59)" end="(170, 61)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                  <IdentNode start="(170, 62)" end="(170, 74)" leading="" trailing="" raw_val="c.rhs.isZero" val="c.rhs.isZero"/>
                </OtherNode>
                <AtomNode start="(170, 74)" end="(170, 75)" leading="" trailing="&#10;  " val=")"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(171, 3)" end="(171, 7)" leading="" trailing="&#10;    " val="else"/>
            <OtherNode start="(172, 5)" end="(172, 36)" kind="«term_&amp;amp;&amp;amp;_»">
              <IdentNode start="(172, 5)" end="(172, 20)" leading="" trailing=" " raw_val="c.lhs.isNonZero" val="c.lhs.isNonZero"/>
              <AtomNode start="(172, 21)" end="(172, 23)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
              <IdentNode start="(172, 24)" end="(172, 36)" leading="" trailing="&#10;&#10;" raw_val="c.rhs.isZero" val="c.rhs.isZero"/>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(174, 1)" end="(178, 17)" name="PolyCnstr.isValid" full_name="Nat.Linear.PolyCnstr.isValid">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(174, 1)" end="(178, 17)" name="PolyCnstr.isValid">
        <AtomNode start="(174, 1)" end="(174, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(174, 5)" end="(174, 22)">
          <IdentNode start="(174, 5)" end="(174, 22)" leading="" trailing=" " raw_val="PolyCnstr.isValid" val="PolyCnstr.isValid"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(174, 23)" end="(174, 45)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(174, 23)" end="(174, 38)">
            <TermExplicitbinderNode start="(174, 23)" end="(174, 38)">
              <AtomNode start="(174, 23)" end="(174, 24)" leading="" trailing="" val="("/>
              <NullNode start="(174, 24)" end="(174, 25)">
                <IdentNode start="(174, 24)" end="(174, 25)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(174, 26)" end="(174, 37)">
                <AtomNode start="(174, 26)" end="(174, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(174, 28)" end="(174, 37)" leading="" trailing="" raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(174, 37)" end="(174, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(174, 39)" end="(174, 45)">
            <TermTypespecNode start="(174, 39)" end="(174, 45)">
              <AtomNode start="(174, 39)" end="(174, 40)" leading="" trailing=" " val=":"/>
              <IdentNode start="(174, 41)" end="(174, 45)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(174, 46)" end="(178, 17)">
          <AtomNode start="(174, 46)" end="(174, 48)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(175, 3)" end="(178, 17)" kind="boolIfThenElse">
            <AtomNode start="(175, 3)" end="(175, 6)" leading="" trailing=" " val="bif"/>
            <IdentNode start="(175, 7)" end="(175, 11)" leading="" trailing=" " raw_val="c.eq" val="c.eq"/>
            <AtomNode start="(175, 12)" end="(175, 16)" leading="" trailing="&#10;    " val="then"/>
            <OtherNode start="(176, 5)" end="(176, 33)" kind="«term_&amp;amp;&amp;amp;_»">
              <IdentNode start="(176, 5)" end="(176, 17)" leading="" trailing=" " raw_val="c.lhs.isZero" val="c.lhs.isZero"/>
              <AtomNode start="(176, 18)" end="(176, 20)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
              <IdentNode start="(176, 21)" end="(176, 33)" leading="" trailing="&#10;  " raw_val="c.rhs.isZero" val="c.rhs.isZero"/>
            </OtherNode>
            <AtomNode start="(177, 3)" end="(177, 7)" leading="" trailing="&#10;    " val="else"/>
            <IdentNode start="(178, 5)" end="(178, 17)" leading="" trailing="&#10;&#10;" raw_val="c.lhs.isZero" val="c.lhs.isZero"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(180, 1)" end="(184, 40)" name="ExprCnstr.denote" full_name="Nat.Linear.ExprCnstr.denote">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(180, 1)" end="(184, 40)" name="ExprCnstr.denote">
        <AtomNode start="(180, 1)" end="(180, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(180, 5)" end="(180, 21)">
          <IdentNode start="(180, 5)" end="(180, 21)" leading="" trailing=" " raw_val="ExprCnstr.denote" val="ExprCnstr.denote"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(180, 22)" end="(180, 60)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(180, 22)" end="(180, 53)">
            <TermExplicitbinderNode start="(180, 22)" end="(180, 37)">
              <AtomNode start="(180, 22)" end="(180, 23)" leading="" trailing="" val="("/>
              <NullNode start="(180, 23)" end="(180, 26)">
                <IdentNode start="(180, 23)" end="(180, 26)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(180, 27)" end="(180, 36)">
                <AtomNode start="(180, 27)" end="(180, 28)" leading="" trailing=" " val=":"/>
                <IdentNode start="(180, 29)" end="(180, 36)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(180, 36)" end="(180, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(180, 38)" end="(180, 53)">
              <AtomNode start="(180, 38)" end="(180, 39)" leading="" trailing="" val="("/>
              <NullNode start="(180, 39)" end="(180, 40)">
                <IdentNode start="(180, 39)" end="(180, 40)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(180, 41)" end="(180, 52)">
                <AtomNode start="(180, 41)" end="(180, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(180, 43)" end="(180, 52)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(180, 52)" end="(180, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(180, 54)" end="(180, 60)">
            <TermTypespecNode start="(180, 54)" end="(180, 60)">
              <AtomNode start="(180, 54)" end="(180, 55)" leading="" trailing=" " val=":"/>
              <OtherNode start="(180, 56)" end="(180, 60)" kind="Lean.Parser.Term.prop">
                <AtomNode start="(180, 56)" end="(180, 60)" leading="" trailing=" " val="Prop"/>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(180, 61)" end="(184, 40)">
          <AtomNode start="(180, 61)" end="(180, 63)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(181, 3)" end="(184, 40)" kind="boolIfThenElse">
            <AtomNode start="(181, 3)" end="(181, 6)" leading="" trailing=" " val="bif"/>
            <IdentNode start="(181, 7)" end="(181, 11)" leading="" trailing=" " raw_val="c.eq" val="c.eq"/>
            <AtomNode start="(181, 12)" end="(181, 16)" leading="" trailing="&#10;    " val="then"/>
            <OtherNode start="(182, 5)" end="(182, 40)" kind="«term_=_»">
              <OtherNode start="(182, 5)" end="(182, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(182, 5)" end="(182, 17)" leading="" trailing=" " raw_val="c.lhs.denote" val="c.lhs.denote"/>
                <NullNode start="(182, 18)" end="(182, 21)">
                  <IdentNode start="(182, 18)" end="(182, 21)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(182, 22)" end="(182, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(182, 24)" end="(182, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(182, 24)" end="(182, 36)" leading="" trailing=" " raw_val="c.rhs.denote" val="c.rhs.denote"/>
                <NullNode start="(182, 37)" end="(182, 40)">
                  <IdentNode start="(182, 37)" end="(182, 40)" leading="" trailing="&#10;  " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(183, 3)" end="(183, 7)" leading="" trailing="&#10;    " val="else"/>
            <OtherNode start="(184, 5)" end="(184, 40)" kind="«term_≤_»">
              <OtherNode start="(184, 5)" end="(184, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(184, 5)" end="(184, 17)" leading="" trailing=" " raw_val="c.lhs.denote" val="c.lhs.denote"/>
                <NullNode start="(184, 18)" end="(184, 21)">
                  <IdentNode start="(184, 18)" end="(184, 21)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(184, 22)" end="(184, 23)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(184, 24)" end="(184, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(184, 24)" end="(184, 36)" leading="" trailing=" " raw_val="c.rhs.denote" val="c.rhs.denote"/>
                <NullNode start="(184, 37)" end="(184, 40)">
                  <IdentNode start="(184, 37)" end="(184, 40)" leading="" trailing="&#10;&#10;" raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(186, 1)" end="(187, 54)" name="ExprCnstr.toPoly" full_name="Nat.Linear.ExprCnstr.toPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(186, 1)" end="(187, 54)" name="ExprCnstr.toPoly">
        <AtomNode start="(186, 1)" end="(186, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(186, 5)" end="(186, 21)">
          <IdentNode start="(186, 5)" end="(186, 21)" leading="" trailing=" " raw_val="ExprCnstr.toPoly" val="ExprCnstr.toPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(186, 22)" end="(186, 49)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(186, 22)" end="(186, 37)">
            <TermExplicitbinderNode start="(186, 22)" end="(186, 37)">
              <AtomNode start="(186, 22)" end="(186, 23)" leading="" trailing="" val="("/>
              <NullNode start="(186, 23)" end="(186, 24)">
                <IdentNode start="(186, 23)" end="(186, 24)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(186, 25)" end="(186, 36)">
                <AtomNode start="(186, 25)" end="(186, 26)" leading="" trailing=" " val=":"/>
                <IdentNode start="(186, 27)" end="(186, 36)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(186, 36)" end="(186, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(186, 38)" end="(186, 49)">
            <TermTypespecNode start="(186, 38)" end="(186, 49)">
              <AtomNode start="(186, 38)" end="(186, 39)" leading="" trailing=" " val=":"/>
              <IdentNode start="(186, 40)" end="(186, 49)" leading="" trailing=" " raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(186, 50)" end="(187, 54)">
          <AtomNode start="(186, 50)" end="(186, 52)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(187, 3)" end="(187, 54)" kind="Lean.Parser.Term.structInst">
            <AtomNode start="(187, 3)" end="(187, 4)" leading="" trailing=" " val="{"/>
            <NullNode start="(187, 5)" end="(187, 11)">
              <NullNode start="(187, 5)" end="(187, 6)">
                <IdentNode start="(187, 5)" end="(187, 6)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <AtomNode start="(187, 7)" end="(187, 11)" leading="" trailing=" " val="with"/>
            </NullNode>
            <OtherNode start="(187, 12)" end="(187, 52)" kind="Lean.Parser.Term.structInstFields">
              <NullNode start="(187, 12)" end="(187, 52)">
                <OtherNode start="(187, 12)" end="(187, 31)" kind="Lean.Parser.Term.structInstField">
                  <OtherNode start="(187, 12)" end="(187, 15)" kind="Lean.Parser.Term.structInstLVal">
                    <IdentNode start="(187, 12)" end="(187, 15)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode start="(187, 16)" end="(187, 31)">
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(187, 16)" end="(187, 31)" kind="Lean.Parser.Term.structInstFieldDef">
                      <AtomNode start="(187, 16)" end="(187, 18)" leading="" trailing=" " val=":="/>
                      <IdentNode start="(187, 19)" end="(187, 31)" leading="" trailing="" raw_val="c.lhs.toPoly" val="c.lhs.toPoly"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(187, 31)" end="(187, 32)" leading="" trailing=" " val=","/>
                <OtherNode start="(187, 33)" end="(187, 52)" kind="Lean.Parser.Term.structInstField">
                  <OtherNode start="(187, 33)" end="(187, 36)" kind="Lean.Parser.Term.structInstLVal">
                    <IdentNode start="(187, 33)" end="(187, 36)" leading="" trailing=" " raw_val="rhs" val="rhs"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode start="(187, 37)" end="(187, 52)">
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(187, 37)" end="(187, 52)" kind="Lean.Parser.Term.structInstFieldDef">
                      <AtomNode start="(187, 37)" end="(187, 39)" leading="" trailing=" " val=":="/>
                      <IdentNode start="(187, 40)" end="(187, 52)" leading="" trailing=" " raw_val="c.rhs.toPoly" val="c.rhs.toPoly"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Term.optEllipsis">
              <NullNode/>
            </OtherNode>
            <NullNode/>
            <AtomNode start="(187, 53)" end="(187, 54)" leading="" trailing="&#10;&#10;" val="}"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(189, 1)" end="(191, 22)" name="ExprCnstr.toNormPoly" full_name="Nat.Linear.ExprCnstr.toNormPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(189, 1)" end="(191, 22)" name="ExprCnstr.toNormPoly">
        <AtomNode start="(189, 1)" end="(189, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(189, 5)" end="(189, 25)">
          <IdentNode start="(189, 5)" end="(189, 25)" leading="" trailing=" " raw_val="ExprCnstr.toNormPoly" val="ExprCnstr.toNormPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(189, 26)" end="(189, 53)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(189, 26)" end="(189, 41)">
            <TermExplicitbinderNode start="(189, 26)" end="(189, 41)">
              <AtomNode start="(189, 26)" end="(189, 27)" leading="" trailing="" val="("/>
              <NullNode start="(189, 27)" end="(189, 28)">
                <IdentNode start="(189, 27)" end="(189, 28)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(189, 29)" end="(189, 40)">
                <AtomNode start="(189, 29)" end="(189, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(189, 31)" end="(189, 40)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(189, 40)" end="(189, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(189, 42)" end="(189, 53)">
            <TermTypespecNode start="(189, 42)" end="(189, 53)">
              <AtomNode start="(189, 42)" end="(189, 43)" leading="" trailing=" " val=":"/>
              <IdentNode start="(189, 44)" end="(189, 53)" leading="" trailing=" " raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(189, 54)" end="(191, 22)">
          <AtomNode start="(189, 54)" end="(189, 56)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(190, 3)" end="(191, 22)" kind="Lean.Parser.Term.let">
            <AtomNode start="(190, 3)" end="(190, 6)" leading="" trailing=" " val="let"/>
            <OtherNode start="(190, 7)" end="(190, 66)" kind="Lean.Parser.Term.letDecl">
              <OtherNode start="(190, 7)" end="(190, 66)" kind="Lean.Parser.Term.letPatDecl">
                <OtherNode start="(190, 7)" end="(190, 17)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(190, 7)" end="(190, 8)" leading="" trailing="" val="("/>
                  <NullNode start="(190, 8)" end="(190, 16)">
                    <IdentNode start="(190, 8)" end="(190, 11)" leading="" trailing="" raw_val="lhs" val="lhs"/>
                    <AtomNode start="(190, 11)" end="(190, 12)" leading="" trailing=" " val=","/>
                    <NullNode start="(190, 13)" end="(190, 16)">
                      <IdentNode start="(190, 13)" end="(190, 16)" leading="" trailing="" raw_val="rhs" val="rhs"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(190, 16)" end="(190, 17)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <NullNode/>
                <NullNode/>
                <AtomNode start="(190, 18)" end="(190, 20)" leading="" trailing=" " val=":="/>
                <OtherNode start="(190, 21)" end="(190, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(190, 21)" end="(190, 32)" leading="" trailing=" " raw_val="Poly.cancel" val="Poly.cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                  <NullNode start="(190, 33)" end="(190, 66)">
                    <IdentNode start="(190, 33)" end="(190, 49)" leading="" trailing=" " raw_val="c.lhs.toNormPoly" val="c.lhs.toNormPoly"/>
                    <IdentNode start="(190, 50)" end="(190, 66)" leading="" trailing="&#10;  " raw_val="c.rhs.toNormPoly" val="c.rhs.toNormPoly"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <NullNode/>
            <OtherNode start="(191, 3)" end="(191, 22)" kind="Lean.Parser.Term.structInst">
              <AtomNode start="(191, 3)" end="(191, 4)" leading="" trailing=" " val="{"/>
              <NullNode start="(191, 5)" end="(191, 11)">
                <NullNode start="(191, 5)" end="(191, 6)">
                  <IdentNode start="(191, 5)" end="(191, 6)" leading="" trailing=" " raw_val="c" val="c"/>
                </NullNode>
                <AtomNode start="(191, 7)" end="(191, 11)" leading="" trailing=" " val="with"/>
              </NullNode>
              <OtherNode start="(191, 12)" end="(191, 20)" kind="Lean.Parser.Term.structInstFields">
                <NullNode start="(191, 12)" end="(191, 20)">
                  <OtherNode start="(191, 12)" end="(191, 15)" kind="Lean.Parser.Term.structInstField">
                    <OtherNode start="(191, 12)" end="(191, 15)" kind="Lean.Parser.Term.structInstLVal">
                      <IdentNode start="(191, 12)" end="(191, 15)" leading="" trailing="" raw_val="lhs" val="lhs"/>
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(191, 15)" end="(191, 16)" leading="" trailing=" " val=","/>
                  <OtherNode start="(191, 17)" end="(191, 20)" kind="Lean.Parser.Term.structInstField">
                    <OtherNode start="(191, 17)" end="(191, 20)" kind="Lean.Parser.Term.structInstLVal">
                      <IdentNode start="(191, 17)" end="(191, 20)" leading="" trailing=" " raw_val="rhs" val="rhs"/>
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <OtherNode kind="Lean.Parser.Term.optEllipsis">
                <NullNode/>
              </OtherNode>
              <NullNode/>
              <AtomNode start="(191, 21)" end="(191, 22)" leading="" trailing="&#10;&#10;" val="}"/>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(193, 1)" end="(199, 21)" name="monomialToExpr" full_name="Nat.Linear.monomialToExpr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(193, 1)" end="(199, 21)" name="monomialToExpr">
        <AtomNode start="(193, 1)" end="(193, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(193, 5)" end="(193, 19)">
          <IdentNode start="(193, 5)" end="(193, 19)" leading="" trailing=" " raw_val="monomialToExpr" val="monomialToExpr"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(193, 20)" end="(193, 46)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(193, 20)" end="(193, 39)">
            <TermExplicitbinderNode start="(193, 20)" end="(193, 29)">
              <AtomNode start="(193, 20)" end="(193, 21)" leading="" trailing="" val="("/>
              <NullNode start="(193, 21)" end="(193, 22)">
                <IdentNode start="(193, 21)" end="(193, 22)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(193, 23)" end="(193, 28)">
                <AtomNode start="(193, 23)" end="(193, 24)" leading="" trailing=" " val=":"/>
                <IdentNode start="(193, 25)" end="(193, 28)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(193, 28)" end="(193, 29)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(193, 30)" end="(193, 39)">
              <AtomNode start="(193, 30)" end="(193, 31)" leading="" trailing="" val="("/>
              <NullNode start="(193, 31)" end="(193, 32)">
                <IdentNode start="(193, 31)" end="(193, 32)" leading="" trailing=" " raw_val="v" val="v"/>
              </NullNode>
              <NullNode start="(193, 33)" end="(193, 38)">
                <AtomNode start="(193, 33)" end="(193, 34)" leading="" trailing=" " val=":"/>
                <IdentNode start="(193, 35)" end="(193, 38)" leading="" trailing="" raw_val="Var" val="Var" full_name="Nat.Linear.Var" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(19, 8)" def_end="(19, 11)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(193, 38)" end="(193, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(193, 40)" end="(193, 46)">
            <TermTypespecNode start="(193, 40)" end="(193, 46)">
              <AtomNode start="(193, 40)" end="(193, 41)" leading="" trailing=" " val=":"/>
              <IdentNode start="(193, 42)" end="(193, 46)" leading="" trailing=" " raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(193, 47)" end="(199, 21)">
          <AtomNode start="(193, 47)" end="(193, 49)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(194, 3)" end="(199, 21)" kind="boolIfThenElse">
            <AtomNode start="(194, 3)" end="(194, 6)" leading="" trailing=" " val="bif"/>
            <OtherNode start="(194, 7)" end="(194, 20)" kind="«term_==_»">
              <IdentNode start="(194, 7)" end="(194, 8)" leading="" trailing=" " raw_val="v" val="v"/>
              <AtomNode start="(194, 9)" end="(194, 11)" leading="" trailing=" " val="=="/>
              <IdentNode start="(194, 12)" end="(194, 20)" leading="" trailing=" " raw_val="fixedVar" val="fixedVar" full_name="Nat.Linear.fixedVar" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(26, 5)" def_end="(26, 13)"/>
            </OtherNode>
            <AtomNode start="(194, 21)" end="(194, 25)" leading="" trailing="&#10;    " val="then"/>
            <OtherNode start="(195, 5)" end="(195, 11)" kind="Lean.Parser.Term.app">
              <OtherNode start="(195, 5)" end="(195, 9)" kind="Lean.Parser.Term.dotIdent">
                <AtomNode start="(195, 5)" end="(195, 6)" leading="" trailing="" val="."/>
                <IdentNode start="(195, 6)" end="(195, 9)" leading="" trailing=" " raw_val="num" val="num"/>
              </OtherNode>
              <NullNode start="(195, 10)" end="(195, 11)">
                <IdentNode start="(195, 10)" end="(195, 11)" leading="" trailing="&#10;  " raw_val="k" val="k"/>
              </NullNode>
            </OtherNode>
            <AtomNode start="(196, 3)" end="(196, 7)" leading="" trailing=" " val="else"/>
            <OtherNode start="(196, 8)" end="(199, 21)" kind="boolIfThenElse">
              <AtomNode start="(196, 8)" end="(196, 11)" leading="" trailing=" " val="bif"/>
              <OtherNode start="(196, 12)" end="(196, 18)" kind="«term_==_»">
                <IdentNode start="(196, 12)" end="(196, 13)" leading="" trailing=" " raw_val="k" val="k"/>
                <AtomNode start="(196, 14)" end="(196, 16)" leading="" trailing=" " val="=="/>
                <OtherNode start="(196, 17)" end="(196, 18)" kind="num">
                  <AtomNode start="(196, 17)" end="(196, 18)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(196, 19)" end="(196, 23)" leading="" trailing="&#10;    " val="then"/>
              <OtherNode start="(197, 5)" end="(197, 11)" kind="Lean.Parser.Term.app">
                <OtherNode start="(197, 5)" end="(197, 9)" kind="Lean.Parser.Term.dotIdent">
                  <AtomNode start="(197, 5)" end="(197, 6)" leading="" trailing="" val="."/>
                  <IdentNode start="(197, 6)" end="(197, 9)" leading="" trailing=" " raw_val="var" val="var"/>
                </OtherNode>
                <NullNode start="(197, 10)" end="(197, 11)">
                  <IdentNode start="(197, 10)" end="(197, 11)" leading="" trailing="&#10;  " raw_val="v" val="v"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(198, 3)" end="(198, 7)" leading="" trailing="&#10;    " val="else"/>
              <OtherNode start="(199, 5)" end="(199, 21)" kind="Lean.Parser.Term.app">
                <OtherNode start="(199, 5)" end="(199, 10)" kind="Lean.Parser.Term.dotIdent">
                  <AtomNode start="(199, 5)" end="(199, 6)" leading="" trailing="" val="."/>
                  <IdentNode start="(199, 6)" end="(199, 10)" leading="" trailing=" " raw_val="mulL" val="mulL"/>
                </OtherNode>
                <NullNode start="(199, 11)" end="(199, 21)">
                  <IdentNode start="(199, 11)" end="(199, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                  <OtherNode start="(199, 13)" end="(199, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(199, 13)" end="(199, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(199, 14)" end="(199, 20)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(199, 14)" end="(199, 18)" kind="Lean.Parser.Term.dotIdent">
                        <AtomNode start="(199, 14)" end="(199, 15)" leading="" trailing="" val="."/>
                        <IdentNode start="(199, 15)" end="(199, 18)" leading="" trailing=" " raw_val="var" val="var"/>
                      </OtherNode>
                      <NullNode start="(199, 19)" end="(199, 20)">
                        <IdentNode start="(199, 19)" end="(199, 20)" leading="" trailing="" raw_val="v" val="v"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(199, 20)" end="(199, 21)" leading="" trailing="&#10;&#10;" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(201, 1)" end="(209, 56)" name="Poly.toExpr" full_name="Nat.Linear.Poly.toExpr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(201, 1)" end="(209, 56)" name="Poly.toExpr">
        <AtomNode start="(201, 1)" end="(201, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(201, 5)" end="(201, 16)">
          <IdentNode start="(201, 5)" end="(201, 16)" leading="" trailing=" " raw_val="Poly.toExpr" val="Poly.toExpr"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(201, 17)" end="(201, 34)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(201, 17)" end="(201, 27)">
            <TermExplicitbinderNode start="(201, 17)" end="(201, 27)">
              <AtomNode start="(201, 17)" end="(201, 18)" leading="" trailing="" val="("/>
              <NullNode start="(201, 18)" end="(201, 19)">
                <IdentNode start="(201, 18)" end="(201, 19)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(201, 20)" end="(201, 26)">
                <AtomNode start="(201, 20)" end="(201, 21)" leading="" trailing=" " val=":"/>
                <IdentNode start="(201, 22)" end="(201, 26)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(201, 26)" end="(201, 27)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(201, 28)" end="(201, 34)">
            <TermTypespecNode start="(201, 28)" end="(201, 34)">
              <AtomNode start="(201, 28)" end="(201, 29)" leading="" trailing=" " val=":"/>
              <IdentNode start="(201, 30)" end="(201, 34)" leading="" trailing=" " raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(201, 35)" end="(209, 56)">
          <AtomNode start="(201, 35)" end="(201, 37)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(202, 3)" end="(204, 45)" kind="Lean.Parser.Term.match">
            <AtomNode start="(202, 3)" end="(202, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(202, 9)" end="(202, 10)">
              <OtherNode start="(202, 9)" end="(202, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(202, 9)" end="(202, 10)" leading="" trailing=" " raw_val="p" val="p"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(202, 11)" end="(202, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(203, 3)" end="(204, 45)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(203, 3)" end="(204, 45)">
                <OtherNode start="(203, 3)" end="(203, 17)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(203, 3)" end="(203, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(203, 5)" end="(203, 7)">
                    <NullNode start="(203, 5)" end="(203, 7)">
                      <OtherNode start="(203, 5)" end="(203, 7)" kind="«term[_]»">
                        <AtomNode start="(203, 5)" end="(203, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(203, 6)" end="(203, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(203, 8)" end="(203, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(203, 11)" end="(203, 17)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(203, 11)" end="(203, 15)" kind="Lean.Parser.Term.dotIdent">
                      <AtomNode start="(203, 11)" end="(203, 12)" leading="" trailing="" val="."/>
                      <IdentNode start="(203, 12)" end="(203, 15)" leading="" trailing=" " raw_val="num" val="num"/>
                    </OtherNode>
                    <NullNode start="(203, 16)" end="(203, 17)">
                      <OtherNode start="(203, 16)" end="(203, 17)" kind="num">
                        <AtomNode start="(203, 16)" end="(203, 17)" leading="" trailing="&#10;  " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(204, 3)" end="(204, 45)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(204, 3)" end="(204, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(204, 5)" end="(204, 16)">
                    <NullNode start="(204, 5)" end="(204, 16)">
                      <OtherNode start="(204, 5)" end="(204, 16)" kind="«term_::_»">
                        <OtherNode start="(204, 5)" end="(204, 11)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(204, 5)" end="(204, 6)" leading="" trailing="" val="("/>
                          <NullNode start="(204, 6)" end="(204, 10)">
                            <IdentNode start="(204, 6)" end="(204, 7)" leading="" trailing="" raw_val="k" val="k"/>
                            <AtomNode start="(204, 7)" end="(204, 8)" leading="" trailing=" " val=","/>
                            <NullNode start="(204, 9)" end="(204, 10)">
                              <IdentNode start="(204, 9)" end="(204, 10)" leading="" trailing="" raw_val="v" val="v"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(204, 10)" end="(204, 11)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(204, 12)" end="(204, 14)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(204, 15)" end="(204, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(204, 17)" end="(204, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(204, 20)" end="(204, 45)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(204, 20)" end="(204, 22)" leading="" trailing=" " raw_val="go" val="go"/>
                    <NullNode start="(204, 23)" end="(204, 45)">
                      <OtherNode start="(204, 23)" end="(204, 43)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(204, 23)" end="(204, 24)" leading="" trailing="" val="("/>
                        <OtherNode start="(204, 24)" end="(204, 42)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(204, 24)" end="(204, 38)" leading="" trailing=" " raw_val="monomialToExpr" val="monomialToExpr" full_name="Nat.Linear.monomialToExpr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(193, 5)" def_end="(193, 19)"/>
                          <NullNode start="(204, 39)" end="(204, 42)">
                            <IdentNode start="(204, 39)" end="(204, 40)" leading="" trailing=" " raw_val="k" val="k"/>
                            <IdentNode start="(204, 41)" end="(204, 42)" leading="" trailing="" raw_val="v" val="v"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(204, 42)" end="(204, 43)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(204, 44)" end="(204, 45)" leading="" trailing="&#10;" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(205, 1)" end="(209, 56)">
            <OtherNode start="(205, 1)" end="(209, 56)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(205, 1)" end="(205, 6)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(206, 3)" end="(209, 56)">
                <OtherNode start="(206, 3)" end="(209, 56)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(206, 3)" end="(209, 56)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(206, 3)" end="(209, 56)" kind="Lean.Parser.Term.letIdDecl">
                      <IdentNode start="(206, 3)" end="(206, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode start="(206, 6)" end="(206, 27)">
                        <TermExplicitbinderNode start="(206, 6)" end="(206, 16)">
                          <AtomNode start="(206, 6)" end="(206, 7)" leading="" trailing="" val="("/>
                          <NullNode start="(206, 7)" end="(206, 8)">
                            <IdentNode start="(206, 7)" end="(206, 8)" leading="" trailing=" " raw_val="e" val="e"/>
                          </NullNode>
                          <NullNode start="(206, 9)" end="(206, 15)">
                            <AtomNode start="(206, 9)" end="(206, 10)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(206, 11)" end="(206, 15)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(206, 15)" end="(206, 16)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                        <TermExplicitbinderNode start="(206, 17)" end="(206, 27)">
                          <AtomNode start="(206, 17)" end="(206, 18)" leading="" trailing="" val="("/>
                          <NullNode start="(206, 18)" end="(206, 19)">
                            <IdentNode start="(206, 18)" end="(206, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                          <NullNode start="(206, 20)" end="(206, 26)">
                            <AtomNode start="(206, 20)" end="(206, 21)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(206, 22)" end="(206, 26)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(206, 26)" end="(206, 27)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                      </NullNode>
                      <NullNode start="(206, 28)" end="(206, 34)">
                        <TermTypespecNode start="(206, 28)" end="(206, 34)">
                          <AtomNode start="(206, 28)" end="(206, 29)" leading="" trailing=" " val=":"/>
                          <IdentNode start="(206, 30)" end="(206, 34)" leading="" trailing=" " raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
                        </TermTypespecNode>
                      </NullNode>
                      <AtomNode start="(206, 35)" end="(206, 37)" leading="" trailing="&#10;    " val=":="/>
                      <OtherNode start="(207, 5)" end="(209, 56)" kind="Lean.Parser.Term.match">
                        <AtomNode start="(207, 5)" end="(207, 10)" leading="" trailing=" " val="match"/>
                        <NullNode/>
                        <NullNode/>
                        <NullNode start="(207, 11)" end="(207, 12)">
                          <OtherNode start="(207, 11)" end="(207, 12)" kind="Lean.Parser.Term.matchDiscr">
                            <NullNode/>
                            <IdentNode start="(207, 11)" end="(207, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(207, 13)" end="(207, 17)" leading="" trailing="&#10;    " val="with"/>
                        <OtherNode start="(208, 5)" end="(209, 56)" kind="Lean.Parser.Term.matchAlts">
                          <NullNode start="(208, 5)" end="(209, 56)">
                            <OtherNode start="(208, 5)" end="(208, 14)" kind="Lean.Parser.Term.matchAlt">
                              <AtomNode start="(208, 5)" end="(208, 6)" leading="" trailing=" " val="|"/>
                              <NullNode start="(208, 7)" end="(208, 9)">
                                <NullNode start="(208, 7)" end="(208, 9)">
                                  <OtherNode start="(208, 7)" end="(208, 9)" kind="«term[_]»">
                                    <AtomNode start="(208, 7)" end="(208, 8)" leading="" trailing="" val="["/>
                                    <NullNode/>
                                    <AtomNode start="(208, 8)" end="(208, 9)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(208, 10)" end="(208, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <IdentNode start="(208, 13)" end="(208, 14)" leading="" trailing="&#10;    " raw_val="e" val="e"/>
                            </OtherNode>
                            <OtherNode start="(209, 5)" end="(209, 56)" kind="Lean.Parser.Term.matchAlt">
                              <AtomNode start="(209, 5)" end="(209, 6)" leading="" trailing=" " val="|"/>
                              <NullNode start="(209, 7)" end="(209, 18)">
                                <NullNode start="(209, 7)" end="(209, 18)">
                                  <OtherNode start="(209, 7)" end="(209, 18)" kind="«term_::_»">
                                    <OtherNode start="(209, 7)" end="(209, 13)" kind="Lean.Parser.Term.tuple">
                                      <AtomNode start="(209, 7)" end="(209, 8)" leading="" trailing="" val="("/>
                                      <NullNode start="(209, 8)" end="(209, 12)">
                                        <IdentNode start="(209, 8)" end="(209, 9)" leading="" trailing="" raw_val="k" val="k"/>
                                        <AtomNode start="(209, 9)" end="(209, 10)" leading="" trailing=" " val=","/>
                                        <NullNode start="(209, 11)" end="(209, 12)">
                                          <IdentNode start="(209, 11)" end="(209, 12)" leading="" trailing="" raw_val="v" val="v"/>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(209, 12)" end="(209, 13)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(209, 14)" end="(209, 16)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(209, 17)" end="(209, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                                  </OtherNode>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(209, 19)" end="(209, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(209, 22)" end="(209, 56)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(209, 22)" end="(209, 24)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(209, 25)" end="(209, 56)">
                                  <OtherNode start="(209, 25)" end="(209, 54)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(209, 25)" end="(209, 26)" leading="" trailing="" val="("/>
                                    <OtherNode start="(209, 26)" end="(209, 53)" kind="Lean.Parser.Term.app">
                                      <OtherNode start="(209, 26)" end="(209, 30)" kind="Lean.Parser.Term.dotIdent">
                                        <AtomNode start="(209, 26)" end="(209, 27)" leading="" trailing="" val="."/>
                                        <IdentNode start="(209, 27)" end="(209, 30)" leading="" trailing=" " raw_val="add" val="add"/>
                                      </OtherNode>
                                      <NullNode start="(209, 31)" end="(209, 53)">
                                        <IdentNode start="(209, 31)" end="(209, 32)" leading="" trailing=" " raw_val="e" val="e"/>
                                        <OtherNode start="(209, 33)" end="(209, 53)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(209, 33)" end="(209, 34)" leading="" trailing="" val="("/>
                                          <OtherNode start="(209, 34)" end="(209, 52)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(209, 34)" end="(209, 48)" leading="" trailing=" " raw_val="monomialToExpr" val="monomialToExpr" full_name="Nat.Linear.monomialToExpr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(193, 5)" def_end="(193, 19)"/>
                                            <NullNode start="(209, 49)" end="(209, 52)">
                                              <IdentNode start="(209, 49)" end="(209, 50)" leading="" trailing=" " raw_val="k" val="k"/>
                                              <IdentNode start="(209, 51)" end="(209, 52)" leading="" trailing="" raw_val="v" val="v"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(209, 52)" end="(209, 53)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(209, 53)" end="(209, 54)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(209, 55)" end="(209, 56)" leading="" trailing="&#10;&#10;" raw_val="p" val="p"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(211, 1)" end="(212, 54)" name="PolyCnstr.toExpr" full_name="Nat.Linear.PolyCnstr.toExpr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(211, 1)" end="(212, 54)" name="PolyCnstr.toExpr">
        <AtomNode start="(211, 1)" end="(211, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(211, 5)" end="(211, 21)">
          <IdentNode start="(211, 5)" end="(211, 21)" leading="" trailing=" " raw_val="PolyCnstr.toExpr" val="PolyCnstr.toExpr"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(211, 22)" end="(211, 49)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(211, 22)" end="(211, 37)">
            <TermExplicitbinderNode start="(211, 22)" end="(211, 37)">
              <AtomNode start="(211, 22)" end="(211, 23)" leading="" trailing="" val="("/>
              <NullNode start="(211, 23)" end="(211, 24)">
                <IdentNode start="(211, 23)" end="(211, 24)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(211, 25)" end="(211, 36)">
                <AtomNode start="(211, 25)" end="(211, 26)" leading="" trailing=" " val=":"/>
                <IdentNode start="(211, 27)" end="(211, 36)" leading="" trailing="" raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(211, 36)" end="(211, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(211, 38)" end="(211, 49)">
            <TermTypespecNode start="(211, 38)" end="(211, 49)">
              <AtomNode start="(211, 38)" end="(211, 39)" leading="" trailing=" " val=":"/>
              <IdentNode start="(211, 40)" end="(211, 49)" leading="" trailing=" " raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(211, 50)" end="(212, 54)">
          <AtomNode start="(211, 50)" end="(211, 52)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(212, 3)" end="(212, 54)" kind="Lean.Parser.Term.structInst">
            <AtomNode start="(212, 3)" end="(212, 4)" leading="" trailing=" " val="{"/>
            <NullNode start="(212, 5)" end="(212, 11)">
              <NullNode start="(212, 5)" end="(212, 6)">
                <IdentNode start="(212, 5)" end="(212, 6)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <AtomNode start="(212, 7)" end="(212, 11)" leading="" trailing=" " val="with"/>
            </NullNode>
            <OtherNode start="(212, 12)" end="(212, 52)" kind="Lean.Parser.Term.structInstFields">
              <NullNode start="(212, 12)" end="(212, 52)">
                <OtherNode start="(212, 12)" end="(212, 31)" kind="Lean.Parser.Term.structInstField">
                  <OtherNode start="(212, 12)" end="(212, 15)" kind="Lean.Parser.Term.structInstLVal">
                    <IdentNode start="(212, 12)" end="(212, 15)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode start="(212, 16)" end="(212, 31)">
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(212, 16)" end="(212, 31)" kind="Lean.Parser.Term.structInstFieldDef">
                      <AtomNode start="(212, 16)" end="(212, 18)" leading="" trailing=" " val=":="/>
                      <IdentNode start="(212, 19)" end="(212, 31)" leading="" trailing="" raw_val="c.lhs.toExpr" val="c.lhs.toExpr"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(212, 31)" end="(212, 32)" leading="" trailing=" " val=","/>
                <OtherNode start="(212, 33)" end="(212, 52)" kind="Lean.Parser.Term.structInstField">
                  <OtherNode start="(212, 33)" end="(212, 36)" kind="Lean.Parser.Term.structInstLVal">
                    <IdentNode start="(212, 33)" end="(212, 36)" leading="" trailing=" " raw_val="rhs" val="rhs"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode start="(212, 37)" end="(212, 52)">
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(212, 37)" end="(212, 52)" kind="Lean.Parser.Term.structInstFieldDef">
                      <AtomNode start="(212, 37)" end="(212, 39)" leading="" trailing=" " val=":="/>
                      <IdentNode start="(212, 40)" end="(212, 52)" leading="" trailing=" " raw_val="c.rhs.toExpr" val="c.rhs.toExpr"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Term.optEllipsis">
              <NullNode/>
            </OtherNode>
            <NullNode/>
            <AtomNode start="(212, 53)" end="(212, 54)" leading="" trailing="&#10;&#10;" val="}"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <OtherNode start="(214, 1)" end="(214, 130)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(214, 1)" end="(214, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(214, 11)" end="(214, 12)" leading="" trailing="" val="["/>
      <NullNode start="(214, 12)" end="(214, 22)">
        <OtherNode start="(214, 12)" end="(214, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(214, 12)" end="(214, 17)">
            <NullNode start="(214, 12)" end="(214, 17)">
              <OtherNode start="(214, 12)" end="(214, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(214, 12)" end="(214, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(214, 18)" end="(214, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(214, 18)" end="(214, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(214, 22)" end="(214, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(214, 24)" end="(214, 130)">
        <IdentNode start="(214, 24)" end="(214, 36)" leading="" trailing=" " raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        <IdentNode start="(214, 37)" end="(214, 50)" leading="" trailing=" " raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        <IdentNode start="(214, 51)" end="(214, 68)" leading="" trailing=" " raw_val="Nat.add_left_comm" val="Nat.add_left_comm" full_name="Nat.add_left_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        <IdentNode start="(214, 69)" end="(214, 86)" leading="" trailing=" " raw_val="Nat.right_distrib" val="Nat.right_distrib" full_name="Nat.right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        <IdentNode start="(214, 87)" end="(214, 103)" leading="" trailing=" " raw_val="Nat.left_distrib" val="Nat.left_distrib" full_name="Nat.left_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        <IdentNode start="(214, 104)" end="(214, 117)" leading="" trailing=" " raw_val="Nat.mul_assoc" val="Nat.mul_assoc" full_name="Nat.mul_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        <IdentNode start="(214, 118)" end="(214, 130)" leading="" trailing="&#10;" raw_val="Nat.mul_comm" val="Nat.mul_comm" full_name="Nat.mul_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
      </NullNode>
    </OtherNode>
    <OtherNode start="(215, 1)" end="(215, 97)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(215, 1)" end="(215, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(215, 11)" end="(215, 12)" leading="" trailing="" val="["/>
      <NullNode start="(215, 12)" end="(215, 22)">
        <OtherNode start="(215, 12)" end="(215, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(215, 12)" end="(215, 17)">
            <NullNode start="(215, 12)" end="(215, 17)">
              <OtherNode start="(215, 12)" end="(215, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(215, 12)" end="(215, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(215, 18)" end="(215, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(215, 18)" end="(215, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(215, 22)" end="(215, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(215, 24)" end="(215, 97)">
        <IdentNode start="(215, 24)" end="(215, 35)" leading="" trailing=" " raw_val="Poly.denote" val="Poly.denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
        <IdentNode start="(215, 36)" end="(215, 47)" leading="" trailing=" " raw_val="Expr.denote" val="Expr.denote" full_name="Nat.Linear.Expr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(39, 5)" def_end="(39, 16)"/>
        <IdentNode start="(215, 48)" end="(215, 59)" leading="" trailing=" " raw_val="Poly.insert" val="Poly.insert" full_name="Nat.Linear.Poly.insert" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(53, 5)" def_end="(53, 16)"/>
        <IdentNode start="(215, 60)" end="(215, 69)" leading="" trailing=" " raw_val="Poly.norm" val="Poly.norm" full_name="Nat.Linear.Poly.norm" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(64, 5)" def_end="(64, 14)"/>
        <IdentNode start="(215, 70)" end="(215, 82)" leading="" trailing=" " raw_val="Poly.norm.go" val="Poly.norm.go" full_name="Nat.Linear.Poly.norm.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(66, 3)" def_end="(66, 5)"/>
        <IdentNode start="(215, 83)" end="(215, 97)" leading="" trailing="&#10;&#10;" raw_val="Poly.cancelAux" val="Poly.cancelAux" full_name="Nat.Linear.Poly.cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(71, 5)" def_end="(71, 19)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(217, 1)" end="(228, 29)" name="Poly.denote_insert" full_name="Nat.Linear.Poly.denote_insert">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(217, 1)" end="(228, 29)" name="Poly.denote_insert" full_name="Nat.Linear.Poly.denote_insert" _is_private_decl="False">
        <AtomNode start="(217, 1)" end="(217, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(217, 9)" end="(217, 27)">
          <IdentNode start="(217, 9)" end="(217, 27)" leading="" trailing=" " raw_val="Poly.denote_insert" val="Poly.denote_insert"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(217, 28)" end="(218, 64)">
          <NullNode start="(217, 28)" end="(217, 74)">
            <TermExplicitbinderNode start="(217, 28)" end="(217, 43)">
              <AtomNode start="(217, 28)" end="(217, 29)" leading="" trailing="" val="("/>
              <NullNode start="(217, 29)" end="(217, 32)">
                <IdentNode start="(217, 29)" end="(217, 32)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(217, 33)" end="(217, 42)">
                <AtomNode start="(217, 33)" end="(217, 34)" leading="" trailing=" " val=":"/>
                <IdentNode start="(217, 35)" end="(217, 42)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(217, 42)" end="(217, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(217, 44)" end="(217, 53)">
              <AtomNode start="(217, 44)" end="(217, 45)" leading="" trailing="" val="("/>
              <NullNode start="(217, 45)" end="(217, 46)">
                <IdentNode start="(217, 45)" end="(217, 46)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(217, 47)" end="(217, 52)">
                <AtomNode start="(217, 47)" end="(217, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(217, 49)" end="(217, 52)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(217, 52)" end="(217, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(217, 54)" end="(217, 63)">
              <AtomNode start="(217, 54)" end="(217, 55)" leading="" trailing="" val="("/>
              <NullNode start="(217, 55)" end="(217, 56)">
                <IdentNode start="(217, 55)" end="(217, 56)" leading="" trailing=" " raw_val="v" val="v"/>
              </NullNode>
              <NullNode start="(217, 57)" end="(217, 62)">
                <AtomNode start="(217, 57)" end="(217, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(217, 59)" end="(217, 62)" leading="" trailing="" raw_val="Var" val="Var" full_name="Nat.Linear.Var" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(19, 8)" def_end="(19, 11)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(217, 62)" end="(217, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(217, 64)" end="(217, 74)">
              <AtomNode start="(217, 64)" end="(217, 65)" leading="" trailing="" val="("/>
              <NullNode start="(217, 65)" end="(217, 66)">
                <IdentNode start="(217, 65)" end="(217, 66)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(217, 67)" end="(217, 73)">
                <AtomNode start="(217, 67)" end="(217, 68)" leading="" trailing=" " val=":"/>
                <IdentNode start="(217, 69)" end="(217, 73)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(217, 73)" end="(217, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(217, 75)" end="(218, 64)">
            <AtomNode start="(217, 75)" end="(217, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(218, 5)" end="(218, 64)" kind="«term_=_»">
              <OtherNode start="(218, 5)" end="(218, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(218, 5)" end="(218, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(218, 5)" end="(218, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(218, 5)" end="(218, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(218, 6)" end="(218, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(218, 6)" end="(218, 14)" leading="" trailing=" " raw_val="p.insert" val="p.insert"/>
                      <NullNode start="(218, 15)" end="(218, 18)">
                        <IdentNode start="(218, 15)" end="(218, 16)" leading="" trailing=" " raw_val="k" val="k"/>
                        <IdentNode start="(218, 17)" end="(218, 18)" leading="" trailing="" raw_val="v" val="v"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(218, 18)" end="(218, 19)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(218, 19)" end="(218, 20)" leading="" trailing="" val="."/>
                  <IdentNode start="(218, 20)" end="(218, 26)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                </OtherNode>
                <NullNode start="(218, 27)" end="(218, 30)">
                  <IdentNode start="(218, 27)" end="(218, 30)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(218, 31)" end="(218, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(218, 33)" end="(218, 64)" kind="«term_+_»">
                <OtherNode start="(218, 33)" end="(218, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(218, 33)" end="(218, 41)" leading="" trailing=" " raw_val="p.denote" val="p.denote"/>
                  <NullNode start="(218, 42)" end="(218, 45)">
                    <IdentNode start="(218, 42)" end="(218, 45)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(218, 46)" end="(218, 47)" leading="" trailing=" " val="+"/>
                <OtherNode start="(218, 48)" end="(218, 64)" kind="«term_*_»">
                  <IdentNode start="(218, 48)" end="(218, 49)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(218, 50)" end="(218, 51)" leading="" trailing=" " val="*"/>
                  <OtherNode start="(218, 52)" end="(218, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(218, 52)" end="(218, 60)" leading="" trailing=" " raw_val="v.denote" val="v.denote"/>
                    <NullNode start="(218, 61)" end="(218, 64)">
                      <IdentNode start="(218, 61)" end="(218, 64)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(218, 65)" end="(228, 29)">
          <AtomNode start="(218, 65)" end="(218, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(218, 68)" end="(228, 29)">
            <AtomNode start="(218, 68)" end="(218, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(219, 3)" end="(228, 29)">
              <TacticTacticseq1IndentedNode start="(219, 3)" end="(228, 29)">
                <NullNode start="(219, 3)" end="(228, 29)">
                  <OtherNode start="(219, 3)" end="(228, 29)" kind="Lean.Parser.Tactic.match" state_before="ctx : Context&#10;k : Nat&#10;v : Var&#10;p : Poly&#10;⊢ denote ctx (insert k v p) = denote ctx p + k * Var.denote ctx v" state_after="no goals" tactic="match p with&#10;| [] =&amp;gt; simp&#10;| (k', v') :: p =&amp;gt;&#10;  by_cases h₁ : Nat.blt v v'&#10;  · simp [h₁]&#10;  · by_cases h₂ : Nat.beq v v'&#10;    · simp only [insert, h₁, h₂, cond_false, cond_true]&#10;      simp [Nat.eq_of_beq_eq_true h₂]&#10;    · simp only [insert, h₁, h₂, cond_false, cond_true]&#10;      simp [denote_insert]">
                    <AtomNode start="(219, 3)" end="(219, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(219, 9)" end="(219, 10)">
                      <OtherNode start="(219, 9)" end="(219, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(219, 9)" end="(219, 10)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(219, 11)" end="(219, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(220, 3)" end="(228, 29)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(220, 3)" end="(228, 29)">
                        <OtherNode start="(220, 3)" end="(220, 15)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(220, 3)" end="(220, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(220, 5)" end="(220, 7)">
                            <NullNode start="(220, 5)" end="(220, 7)">
                              <OtherNode start="(220, 5)" end="(220, 7)" kind="«term[_]»">
                                <AtomNode start="(220, 5)" end="(220, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(220, 6)" end="(220, 7)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(220, 8)" end="(220, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(220, 11)" end="(220, 15)">
                            <TacticTacticseq1IndentedNode start="(220, 11)" end="(220, 15)">
                              <NullNode start="(220, 11)" end="(220, 15)">
                                <OtherNode start="(220, 11)" end="(220, 15)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;k : Nat&#10;v : Var&#10;p : Poly&#10;⊢ denote ctx (insert k v []) = denote ctx [] + k * Var.denote ctx v" state_after="no goals" tactic="simp">
                                  <AtomNode start="(220, 11)" end="(220, 15)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(221, 3)" end="(228, 29)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(221, 3)" end="(221, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(221, 5)" end="(221, 18)">
                            <NullNode start="(221, 5)" end="(221, 18)">
                              <OtherNode start="(221, 5)" end="(221, 18)" kind="«term_::_»">
                                <OtherNode start="(221, 5)" end="(221, 13)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(221, 5)" end="(221, 6)" leading="" trailing="" val="("/>
                                  <NullNode start="(221, 6)" end="(221, 12)">
                                    <IdentNode start="(221, 6)" end="(221, 8)" leading="" trailing="" raw_val="k'" val="k'"/>
                                    <AtomNode start="(221, 8)" end="(221, 9)" leading="" trailing=" " val=","/>
                                    <NullNode start="(221, 10)" end="(221, 12)">
                                      <IdentNode start="(221, 10)" end="(221, 12)" leading="" trailing="" raw_val="v'" val="v'"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(221, 12)" end="(221, 13)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(221, 14)" end="(221, 16)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(221, 17)" end="(221, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(221, 19)" end="(221, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(222, 5)" end="(228, 29)">
                            <TacticTacticseq1IndentedNode start="(222, 5)" end="(228, 29)">
                              <NullNode start="(222, 5)" end="(228, 29)">
                                <OtherNode start="(222, 5)" end="(222, 31)" kind="«tacticBy_cases_:_»" state_before="ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v&#10;&#10;case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" tactic="by_cases h₁ : Nat.blt v v'">
                                  <AtomNode start="(222, 5)" end="(222, 13)" leading="" trailing=" " val="by_cases"/>
                                  <NullNode start="(222, 14)" end="(222, 18)">
                                    <IdentNode start="(222, 14)" end="(222, 16)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <AtomNode start="(222, 17)" end="(222, 18)" leading="" trailing=" " val=":"/>
                                  </NullNode>
                                  <OtherNode start="(222, 19)" end="(222, 31)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(222, 19)" end="(222, 26)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                    <NullNode start="(222, 27)" end="(222, 31)">
                                      <IdentNode start="(222, 27)" end="(222, 28)" leading="" trailing=" " raw_val="v" val="v"/>
                                      <IdentNode start="(222, 29)" end="(222, 31)" leading="" trailing="&#10;    " raw_val="v'" val="v'"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(223, 5)" end="(223, 16)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v&#10;&#10;case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" tactic="· simp [h₁]">
                                  <OtherNode start="(223, 5)" end="(223, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(223, 5)" end="(223, 6)" kind="patternIgnore">
                                      <OtherNode start="(223, 5)" end="(223, 6)" kind="token.«· »">
                                        <AtomNode start="(223, 5)" end="(223, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(223, 7)" end="(223, 16)">
                                    <TacticTacticseq1IndentedNode start="(223, 7)" end="(223, 16)">
                                      <NullNode start="(223, 7)" end="(223, 16)">
                                        <OtherNode start="(223, 7)" end="(223, 16)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="no goals" tactic="simp [h₁]">
                                          <AtomNode start="(223, 7)" end="(223, 11)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(223, 12)" end="(223, 16)">
                                            <AtomNode start="(223, 12)" end="(223, 13)" leading="" trailing="" val="["/>
                                            <NullNode start="(223, 13)" end="(223, 15)">
                                              <OtherNode start="(223, 13)" end="(223, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(223, 13)" end="(223, 15)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(223, 15)" end="(223, 16)" leading="" trailing="&#10;    " val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(224, 5)" end="(228, 29)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="no goals" tactic="· by_cases h₂ : Nat.beq v v'&#10;  · simp only [insert, h₁, h₂, cond_false, cond_true]&#10;    simp [Nat.eq_of_beq_eq_true h₂]&#10;  · simp only [insert, h₁, h₂, cond_false, cond_true]&#10;    simp [denote_insert]">
                                  <OtherNode start="(224, 5)" end="(224, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(224, 5)" end="(224, 6)" kind="patternIgnore">
                                      <OtherNode start="(224, 5)" end="(224, 6)" kind="token.«· »">
                                        <AtomNode start="(224, 5)" end="(224, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(224, 7)" end="(228, 29)">
                                    <TacticTacticseq1IndentedNode start="(224, 7)" end="(228, 29)">
                                      <NullNode start="(224, 7)" end="(228, 29)">
                                        <OtherNode start="(224, 7)" end="(224, 33)" kind="«tacticBy_cases_:_»" state_before="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v&#10;&#10;case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : ¬beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" tactic="by_cases h₂ : Nat.beq v v'">
                                          <AtomNode start="(224, 7)" end="(224, 15)" leading="" trailing=" " val="by_cases"/>
                                          <NullNode start="(224, 16)" end="(224, 20)">
                                            <IdentNode start="(224, 16)" end="(224, 18)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                            <AtomNode start="(224, 19)" end="(224, 20)" leading="" trailing=" " val=":"/>
                                          </NullNode>
                                          <OtherNode start="(224, 21)" end="(224, 33)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(224, 21)" end="(224, 28)" leading="" trailing=" " raw_val="Nat.beq" val="Nat.beq" full_name="Nat.beq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            <NullNode start="(224, 29)" end="(224, 33)">
                                              <IdentNode start="(224, 29)" end="(224, 30)" leading="" trailing=" " raw_val="v" val="v"/>
                                              <IdentNode start="(224, 31)" end="(224, 33)" leading="" trailing="&#10;      " raw_val="v'" val="v'"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(225, 7)" end="(226, 40)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v&#10;&#10;case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : ¬beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : ¬beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" tactic="· simp only [insert, h₁, h₂, cond_false, cond_true]&#10;  simp [Nat.eq_of_beq_eq_true h₂]">
                                          <OtherNode start="(225, 7)" end="(225, 8)" kind="Lean.cdotTk">
                                            <OtherNode start="(225, 7)" end="(225, 8)" kind="patternIgnore">
                                              <OtherNode start="(225, 7)" end="(225, 8)" kind="token.«· »">
                                                <AtomNode start="(225, 7)" end="(225, 8)" leading="" trailing=" " val="·"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <TacticTacticseqNode start="(225, 9)" end="(226, 40)">
                                            <TacticTacticseq1IndentedNode start="(225, 9)" end="(226, 40)">
                                              <NullNode start="(225, 9)" end="(226, 40)">
                                                <OtherNode start="(225, 9)" end="(225, 58)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : beq v v' = true&#10;⊢ denote ctx ((k + k', v') :: p) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" tactic="simp only [insert, h₁, h₂, cond_false, cond_true]">
                                                  <AtomNode start="(225, 9)" end="(225, 13)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(225, 14)" end="(225, 18)">
                                                    <AtomNode start="(225, 14)" end="(225, 18)" leading="" trailing=" " val="only"/>
                                                  </NullNode>
                                                  <NullNode start="(225, 19)" end="(225, 58)">
                                                    <AtomNode start="(225, 19)" end="(225, 20)" leading="" trailing="" val="["/>
                                                    <NullNode start="(225, 20)" end="(225, 57)">
                                                      <OtherNode start="(225, 20)" end="(225, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(225, 20)" end="(225, 26)" leading="" trailing="" raw_val="insert" val="insert" full_name="Nat.Linear.Poly.insert" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(53, 5)" def_end="(53, 16)"/>
                                                      </OtherNode>
                                                      <AtomNode start="(225, 26)" end="(225, 27)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(225, 28)" end="(225, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(225, 28)" end="(225, 30)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                      </OtherNode>
                                                      <AtomNode start="(225, 30)" end="(225, 31)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(225, 32)" end="(225, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(225, 32)" end="(225, 34)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                      </OtherNode>
                                                      <AtomNode start="(225, 34)" end="(225, 35)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(225, 36)" end="(225, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(225, 36)" end="(225, 46)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                      </OtherNode>
                                                      <AtomNode start="(225, 46)" end="(225, 47)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(225, 48)" end="(225, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(225, 48)" end="(225, 57)" leading="" trailing="" raw_val="cond_true" val="cond_true" full_name="cond_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(225, 57)" end="(225, 58)" leading="" trailing="&#10;        " val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <OtherNode start="(226, 9)" end="(226, 40)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : beq v v' = true&#10;⊢ denote ctx ((k + k', v') :: p) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="no goals" tactic="simp [Nat.eq_of_beq_eq_true h₂]">
                                                  <AtomNode start="(226, 9)" end="(226, 13)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode start="(226, 14)" end="(226, 40)">
                                                    <AtomNode start="(226, 14)" end="(226, 15)" leading="" trailing="" val="["/>
                                                    <NullNode start="(226, 15)" end="(226, 39)">
                                                      <OtherNode start="(226, 15)" end="(226, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <OtherNode start="(226, 15)" end="(226, 39)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(226, 15)" end="(226, 36)" leading="" trailing=" " raw_val="Nat.eq_of_beq_eq_true" val="Nat.eq_of_beq_eq_true" full_name="Nat.eq_of_beq_eq_true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          <NullNode start="(226, 37)" end="(226, 39)">
                                                            <IdentNode start="(226, 37)" end="(226, 39)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(226, 39)" end="(226, 40)" leading="" trailing="&#10;      " val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(227, 7)" end="(228, 29)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : ¬beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="no goals" tactic="· simp only [insert, h₁, h₂, cond_false, cond_true]&#10;  simp [denote_insert]">
                                          <OtherNode start="(227, 7)" end="(227, 8)" kind="Lean.cdotTk">
                                            <OtherNode start="(227, 7)" end="(227, 8)" kind="patternIgnore">
                                              <OtherNode start="(227, 7)" end="(227, 8)" kind="token.«· »">
                                                <AtomNode start="(227, 7)" end="(227, 8)" leading="" trailing=" " val="·"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <TacticTacticseqNode start="(227, 9)" end="(228, 29)">
                                            <TacticTacticseq1IndentedNode start="(227, 9)" end="(228, 29)">
                                              <NullNode start="(227, 9)" end="(228, 29)">
                                                <OtherNode start="(227, 9)" end="(227, 58)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : ¬beq v v' = true&#10;⊢ denote ctx (insert k v ((k', v') :: p)) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : ¬beq v v' = true&#10;⊢ denote ctx ((k', v') :: insert k v p) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" tactic="simp only [insert, h₁, h₂, cond_false, cond_true]">
                                                  <AtomNode start="(227, 9)" end="(227, 13)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(227, 14)" end="(227, 18)">
                                                    <AtomNode start="(227, 14)" end="(227, 18)" leading="" trailing=" " val="only"/>
                                                  </NullNode>
                                                  <NullNode start="(227, 19)" end="(227, 58)">
                                                    <AtomNode start="(227, 19)" end="(227, 20)" leading="" trailing="" val="["/>
                                                    <NullNode start="(227, 20)" end="(227, 57)">
                                                      <OtherNode start="(227, 20)" end="(227, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(227, 20)" end="(227, 26)" leading="" trailing="" raw_val="insert" val="insert" full_name="Nat.Linear.Poly.insert" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(53, 5)" def_end="(53, 16)"/>
                                                      </OtherNode>
                                                      <AtomNode start="(227, 26)" end="(227, 27)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(227, 28)" end="(227, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(227, 28)" end="(227, 30)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                      </OtherNode>
                                                      <AtomNode start="(227, 30)" end="(227, 31)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(227, 32)" end="(227, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(227, 32)" end="(227, 34)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                      </OtherNode>
                                                      <AtomNode start="(227, 34)" end="(227, 35)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(227, 36)" end="(227, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(227, 36)" end="(227, 46)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                      </OtherNode>
                                                      <AtomNode start="(227, 46)" end="(227, 47)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(227, 48)" end="(227, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(227, 48)" end="(227, 57)" leading="" trailing="" raw_val="cond_true" val="cond_true" full_name="cond_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(227, 57)" end="(227, 58)" leading="" trailing="&#10;        " val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <OtherNode start="(228, 9)" end="(228, 29)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;k : Nat&#10;v : Var&#10;p✝ : Poly&#10;k' : Nat&#10;v' : Var&#10;p : List (Nat × Var)&#10;h₁ : ¬blt v v' = true&#10;h₂ : ¬beq v v' = true&#10;⊢ denote ctx ((k', v') :: insert k v p) = denote ctx ((k', v') :: p) + k * Var.denote ctx v" state_after="no goals" tactic="simp [denote_insert]">
                                                  <AtomNode start="(228, 9)" end="(228, 13)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode start="(228, 14)" end="(228, 29)">
                                                    <AtomNode start="(228, 14)" end="(228, 15)" leading="" trailing="" val="["/>
                                                    <NullNode start="(228, 15)" end="(228, 28)">
                                                      <OtherNode start="(228, 15)" end="(228, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(228, 15)" end="(228, 28)" leading="" trailing="" raw_val="denote_insert" val="denote_insert"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(228, 28)" end="(228, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(230, 1)" end="(230, 42)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(230, 1)" end="(230, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(230, 11)" end="(230, 12)" leading="" trailing="" val="["/>
      <NullNode start="(230, 12)" end="(230, 22)">
        <OtherNode start="(230, 12)" end="(230, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(230, 12)" end="(230, 17)">
            <NullNode start="(230, 12)" end="(230, 17)">
              <OtherNode start="(230, 12)" end="(230, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(230, 12)" end="(230, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(230, 18)" end="(230, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(230, 18)" end="(230, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(230, 22)" end="(230, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(230, 24)" end="(230, 42)">
        <IdentNode start="(230, 24)" end="(230, 42)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_insert" val="Poly.denote_insert" full_name="Nat.Linear.Poly.denote_insert" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(217, 9)" def_end="(217, 27)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(232, 1)" end="(235, 40)" name="Poly.denote_norm_go" full_name="Nat.Linear.Poly.denote_norm_go">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(232, 1)" end="(235, 40)" name="Poly.denote_norm_go" full_name="Nat.Linear.Poly.denote_norm_go" _is_private_decl="False">
        <AtomNode start="(232, 1)" end="(232, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(232, 9)" end="(232, 28)">
          <IdentNode start="(232, 9)" end="(232, 28)" leading="" trailing=" " raw_val="Poly.denote_norm_go" val="Poly.denote_norm_go"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(232, 29)" end="(232, 123)">
          <NullNode start="(232, 29)" end="(232, 66)">
            <TermExplicitbinderNode start="(232, 29)" end="(232, 44)">
              <AtomNode start="(232, 29)" end="(232, 30)" leading="" trailing="" val="("/>
              <NullNode start="(232, 30)" end="(232, 33)">
                <IdentNode start="(232, 30)" end="(232, 33)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(232, 34)" end="(232, 43)">
                <AtomNode start="(232, 34)" end="(232, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(232, 36)" end="(232, 43)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(232, 43)" end="(232, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(232, 45)" end="(232, 55)">
              <AtomNode start="(232, 45)" end="(232, 46)" leading="" trailing="" val="("/>
              <NullNode start="(232, 46)" end="(232, 47)">
                <IdentNode start="(232, 46)" end="(232, 47)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(232, 48)" end="(232, 54)">
                <AtomNode start="(232, 48)" end="(232, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(232, 50)" end="(232, 54)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(232, 54)" end="(232, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(232, 56)" end="(232, 66)">
              <AtomNode start="(232, 56)" end="(232, 57)" leading="" trailing="" val="("/>
              <NullNode start="(232, 57)" end="(232, 58)">
                <IdentNode start="(232, 57)" end="(232, 58)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(232, 59)" end="(232, 65)">
                <AtomNode start="(232, 59)" end="(232, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(232, 61)" end="(232, 65)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(232, 65)" end="(232, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(232, 67)" end="(232, 123)">
            <AtomNode start="(232, 67)" end="(232, 68)" leading="" trailing=" " val=":"/>
            <OtherNode start="(232, 69)" end="(232, 123)" kind="«term_=_»">
              <OtherNode start="(232, 69)" end="(232, 93)" kind="Lean.Parser.Term.app">
                <OtherNode start="(232, 69)" end="(232, 89)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(232, 69)" end="(232, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(232, 69)" end="(232, 70)" leading="" trailing="" val="("/>
                    <OtherNode start="(232, 70)" end="(232, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(232, 70)" end="(232, 77)" leading="" trailing=" " raw_val="norm.go" val="norm.go" full_name="Nat.Linear.Poly.norm.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(66, 3)" def_end="(66, 5)"/>
                      <NullNode start="(232, 78)" end="(232, 81)">
                        <IdentNode start="(232, 78)" end="(232, 79)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(232, 80)" end="(232, 81)" leading="" trailing="" raw_val="r" val="r"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(232, 81)" end="(232, 82)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(232, 82)" end="(232, 83)" leading="" trailing="" val="."/>
                  <IdentNode start="(232, 83)" end="(232, 89)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                </OtherNode>
                <NullNode start="(232, 90)" end="(232, 93)">
                  <IdentNode start="(232, 90)" end="(232, 93)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(232, 94)" end="(232, 95)" leading="" trailing=" " val="="/>
              <OtherNode start="(232, 96)" end="(232, 123)" kind="«term_+_»">
                <OtherNode start="(232, 96)" end="(232, 108)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(232, 96)" end="(232, 104)" leading="" trailing=" " raw_val="p.denote" val="p.denote"/>
                  <NullNode start="(232, 105)" end="(232, 108)">
                    <IdentNode start="(232, 105)" end="(232, 108)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(232, 109)" end="(232, 110)" leading="" trailing=" " val="+"/>
                <OtherNode start="(232, 111)" end="(232, 123)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(232, 111)" end="(232, 119)" leading="" trailing=" " raw_val="r.denote" val="r.denote"/>
                  <NullNode start="(232, 120)" end="(232, 123)">
                    <IdentNode start="(232, 120)" end="(232, 123)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(232, 124)" end="(235, 40)">
          <AtomNode start="(232, 124)" end="(232, 126)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(232, 127)" end="(235, 40)">
            <AtomNode start="(232, 127)" end="(232, 129)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(233, 3)" end="(235, 40)">
              <TacticTacticseq1IndentedNode start="(233, 3)" end="(235, 40)">
                <NullNode start="(233, 3)" end="(235, 40)">
                  <OtherNode start="(233, 3)" end="(235, 40)" kind="Lean.Parser.Tactic.match" state_before="ctx : Context&#10;p r : Poly&#10;⊢ denote ctx (norm.go p r) = denote ctx p + denote ctx r" state_after="no goals" tactic="match p with&#10;| [] =&amp;gt; simp&#10;| (k, v):: p =&amp;gt; simp [denote_norm_go]">
                    <AtomNode start="(233, 3)" end="(233, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(233, 9)" end="(233, 10)">
                      <OtherNode start="(233, 9)" end="(233, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(233, 9)" end="(233, 10)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(233, 11)" end="(233, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(234, 3)" end="(235, 40)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(234, 3)" end="(235, 40)">
                        <OtherNode start="(234, 3)" end="(234, 15)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(234, 3)" end="(234, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(234, 5)" end="(234, 7)">
                            <NullNode start="(234, 5)" end="(234, 7)">
                              <OtherNode start="(234, 5)" end="(234, 7)" kind="«term[_]»">
                                <AtomNode start="(234, 5)" end="(234, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(234, 6)" end="(234, 7)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(234, 8)" end="(234, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(234, 11)" end="(234, 15)">
                            <TacticTacticseq1IndentedNode start="(234, 11)" end="(234, 15)">
                              <NullNode start="(234, 11)" end="(234, 15)">
                                <OtherNode start="(234, 11)" end="(234, 15)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p r : Poly&#10;⊢ denote ctx (norm.go [] r) = denote ctx [] + denote ctx r" state_after="no goals" tactic="simp">
                                  <AtomNode start="(234, 11)" end="(234, 15)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(235, 3)" end="(235, 40)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(235, 3)" end="(235, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(235, 5)" end="(235, 15)">
                            <NullNode start="(235, 5)" end="(235, 15)">
                              <OtherNode start="(235, 5)" end="(235, 15)" kind="«term_::_»">
                                <OtherNode start="(235, 5)" end="(235, 11)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(235, 5)" end="(235, 6)" leading="" trailing="" val="("/>
                                  <NullNode start="(235, 6)" end="(235, 10)">
                                    <IdentNode start="(235, 6)" end="(235, 7)" leading="" trailing="" raw_val="k" val="k"/>
                                    <AtomNode start="(235, 7)" end="(235, 8)" leading="" trailing=" " val=","/>
                                    <NullNode start="(235, 9)" end="(235, 10)">
                                      <IdentNode start="(235, 9)" end="(235, 10)" leading="" trailing="" raw_val="v" val="v"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(235, 10)" end="(235, 11)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(235, 11)" end="(235, 13)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(235, 14)" end="(235, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(235, 16)" end="(235, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(235, 19)" end="(235, 40)">
                            <TacticTacticseq1IndentedNode start="(235, 19)" end="(235, 40)">
                              <NullNode start="(235, 19)" end="(235, 40)">
                                <OtherNode start="(235, 19)" end="(235, 40)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p✝ r : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;⊢ denote ctx (norm.go ((k, v) :: p) r) = denote ctx ((k, v) :: p) + denote ctx r" state_after="no goals" tactic="simp [denote_norm_go]">
                                  <AtomNode start="(235, 19)" end="(235, 23)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(235, 24)" end="(235, 40)">
                                    <AtomNode start="(235, 24)" end="(235, 25)" leading="" trailing="" val="["/>
                                    <NullNode start="(235, 25)" end="(235, 39)">
                                      <OtherNode start="(235, 25)" end="(235, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(235, 25)" end="(235, 39)" leading="" trailing="" raw_val="denote_norm_go" val="denote_norm_go"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(235, 39)" end="(235, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(237, 1)" end="(237, 43)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(237, 1)" end="(237, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(237, 11)" end="(237, 12)" leading="" trailing="" val="["/>
      <NullNode start="(237, 12)" end="(237, 22)">
        <OtherNode start="(237, 12)" end="(237, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(237, 12)" end="(237, 17)">
            <NullNode start="(237, 12)" end="(237, 17)">
              <OtherNode start="(237, 12)" end="(237, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(237, 12)" end="(237, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(237, 18)" end="(237, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(237, 18)" end="(237, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(237, 22)" end="(237, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(237, 24)" end="(237, 43)">
        <IdentNode start="(237, 24)" end="(237, 43)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_norm_go" val="Poly.denote_norm_go" full_name="Nat.Linear.Poly.denote_norm_go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(232, 9)" def_end="(232, 28)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(239, 1)" end="(240, 7)" name="Poly.denote_sort" full_name="Nat.Linear.Poly.denote_sort">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(239, 1)" end="(240, 7)" name="Poly.denote_sort" full_name="Nat.Linear.Poly.denote_sort" _is_private_decl="False">
        <AtomNode start="(239, 1)" end="(239, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(239, 9)" end="(239, 25)">
          <IdentNode start="(239, 9)" end="(239, 25)" leading="" trailing=" " raw_val="Poly.denote_sort" val="Poly.denote_sort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(239, 26)" end="(239, 87)">
          <NullNode start="(239, 26)" end="(239, 52)">
            <TermExplicitbinderNode start="(239, 26)" end="(239, 41)">
              <AtomNode start="(239, 26)" end="(239, 27)" leading="" trailing="" val="("/>
              <NullNode start="(239, 27)" end="(239, 30)">
                <IdentNode start="(239, 27)" end="(239, 30)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(239, 31)" end="(239, 40)">
                <AtomNode start="(239, 31)" end="(239, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(239, 33)" end="(239, 40)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(239, 40)" end="(239, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(239, 42)" end="(239, 52)">
              <AtomNode start="(239, 42)" end="(239, 43)" leading="" trailing="" val="("/>
              <NullNode start="(239, 43)" end="(239, 44)">
                <IdentNode start="(239, 43)" end="(239, 44)" leading="" trailing=" " raw_val="m" val="m"/>
              </NullNode>
              <NullNode start="(239, 45)" end="(239, 51)">
                <AtomNode start="(239, 45)" end="(239, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(239, 47)" end="(239, 51)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(239, 51)" end="(239, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(239, 53)" end="(239, 87)">
            <AtomNode start="(239, 53)" end="(239, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(239, 55)" end="(239, 87)" kind="«term_=_»">
              <OtherNode start="(239, 55)" end="(239, 72)" kind="Lean.Parser.Term.app">
                <IdentNode start="(239, 55)" end="(239, 68)" leading="" trailing=" " raw_val="m.norm.denote" val="m.norm.denote"/>
                <NullNode start="(239, 69)" end="(239, 72)">
                  <IdentNode start="(239, 69)" end="(239, 72)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(239, 73)" end="(239, 74)" leading="" trailing=" " val="="/>
              <OtherNode start="(239, 75)" end="(239, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(239, 75)" end="(239, 83)" leading="" trailing=" " raw_val="m.denote" val="m.denote"/>
                <NullNode start="(239, 84)" end="(239, 87)">
                  <IdentNode start="(239, 84)" end="(239, 87)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(239, 88)" end="(240, 7)">
          <AtomNode start="(239, 88)" end="(239, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(239, 91)" end="(240, 7)">
            <AtomNode start="(239, 91)" end="(239, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(240, 3)" end="(240, 7)">
              <TacticTacticseq1IndentedNode start="(240, 3)" end="(240, 7)">
                <NullNode start="(240, 3)" end="(240, 7)">
                  <OtherNode start="(240, 3)" end="(240, 7)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;m : Poly&#10;⊢ denote ctx m.norm = denote ctx m" state_after="no goals" tactic="simp">
                    <AtomNode start="(240, 3)" end="(240, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(242, 1)" end="(242, 40)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(242, 1)" end="(242, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(242, 11)" end="(242, 12)" leading="" trailing="" val="["/>
      <NullNode start="(242, 12)" end="(242, 22)">
        <OtherNode start="(242, 12)" end="(242, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(242, 12)" end="(242, 17)">
            <NullNode start="(242, 12)" end="(242, 17)">
              <OtherNode start="(242, 12)" end="(242, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(242, 12)" end="(242, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(242, 18)" end="(242, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(242, 18)" end="(242, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(242, 22)" end="(242, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(242, 24)" end="(242, 40)">
        <IdentNode start="(242, 24)" end="(242, 40)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_sort" val="Poly.denote_sort" full_name="Nat.Linear.Poly.denote_sort" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(239, 9)" def_end="(239, 25)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(244, 1)" end="(247, 40)" name="Poly.denote_append" full_name="Nat.Linear.Poly.denote_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(244, 1)" end="(247, 40)" name="Poly.denote_append" full_name="Nat.Linear.Poly.denote_append" _is_private_decl="False">
        <AtomNode start="(244, 1)" end="(244, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(244, 9)" end="(244, 27)">
          <IdentNode start="(244, 9)" end="(244, 27)" leading="" trailing=" " raw_val="Poly.denote_append" val="Poly.denote_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(244, 28)" end="(244, 108)">
          <NullNode start="(244, 28)" end="(244, 56)">
            <TermExplicitbinderNode start="(244, 28)" end="(244, 43)">
              <AtomNode start="(244, 28)" end="(244, 29)" leading="" trailing="" val="("/>
              <NullNode start="(244, 29)" end="(244, 32)">
                <IdentNode start="(244, 29)" end="(244, 32)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(244, 33)" end="(244, 42)">
                <AtomNode start="(244, 33)" end="(244, 34)" leading="" trailing=" " val=":"/>
                <IdentNode start="(244, 35)" end="(244, 42)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(244, 42)" end="(244, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(244, 44)" end="(244, 56)">
              <AtomNode start="(244, 44)" end="(244, 45)" leading="" trailing="" val="("/>
              <NullNode start="(244, 45)" end="(244, 48)">
                <IdentNode start="(244, 45)" end="(244, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(244, 47)" end="(244, 48)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(244, 49)" end="(244, 55)">
                <AtomNode start="(244, 49)" end="(244, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(244, 51)" end="(244, 55)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(244, 55)" end="(244, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(244, 57)" end="(244, 108)">
            <AtomNode start="(244, 57)" end="(244, 58)" leading="" trailing=" " val=":"/>
            <OtherNode start="(244, 59)" end="(244, 108)" kind="«term_=_»">
              <OtherNode start="(244, 59)" end="(244, 78)" kind="Lean.Parser.Term.app">
                <OtherNode start="(244, 59)" end="(244, 74)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(244, 59)" end="(244, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(244, 59)" end="(244, 60)" leading="" trailing="" val="("/>
                    <OtherNode start="(244, 60)" end="(244, 66)" kind="«term_++_»">
                      <IdentNode start="(244, 60)" end="(244, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                      <AtomNode start="(244, 62)" end="(244, 64)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(244, 65)" end="(244, 66)" leading="" trailing="" raw_val="q" val="q"/>
                    </OtherNode>
                    <AtomNode start="(244, 66)" end="(244, 67)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(244, 67)" end="(244, 68)" leading="" trailing="" val="."/>
                  <IdentNode start="(244, 68)" end="(244, 74)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                </OtherNode>
                <NullNode start="(244, 75)" end="(244, 78)">
                  <IdentNode start="(244, 75)" end="(244, 78)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(244, 79)" end="(244, 80)" leading="" trailing=" " val="="/>
              <OtherNode start="(244, 81)" end="(244, 108)" kind="«term_+_»">
                <OtherNode start="(244, 81)" end="(244, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(244, 81)" end="(244, 89)" leading="" trailing=" " raw_val="p.denote" val="p.denote"/>
                  <NullNode start="(244, 90)" end="(244, 93)">
                    <IdentNode start="(244, 90)" end="(244, 93)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(244, 94)" end="(244, 95)" leading="" trailing=" " val="+"/>
                <OtherNode start="(244, 96)" end="(244, 108)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(244, 96)" end="(244, 104)" leading="" trailing=" " raw_val="q.denote" val="q.denote"/>
                  <NullNode start="(244, 105)" end="(244, 108)">
                    <IdentNode start="(244, 105)" end="(244, 108)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(244, 109)" end="(247, 40)">
          <AtomNode start="(244, 109)" end="(244, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(244, 112)" end="(247, 40)">
            <AtomNode start="(244, 112)" end="(244, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(245, 3)" end="(247, 40)">
              <TacticTacticseq1IndentedNode start="(245, 3)" end="(247, 40)">
                <NullNode start="(245, 3)" end="(247, 40)">
                  <OtherNode start="(245, 3)" end="(247, 40)" kind="Lean.Parser.Tactic.match" state_before="ctx : Context&#10;p q : Poly&#10;⊢ denote ctx (p ++ q) = denote ctx p + denote ctx q" state_after="no goals" tactic="match p with&#10;| []  =&amp;gt; simp&#10;| (k, v) :: p =&amp;gt; simp [denote_append]">
                    <AtomNode start="(245, 3)" end="(245, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(245, 9)" end="(245, 10)">
                      <OtherNode start="(245, 9)" end="(245, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(245, 9)" end="(245, 10)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(245, 11)" end="(245, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(246, 3)" end="(247, 40)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(246, 3)" end="(247, 40)">
                        <OtherNode start="(246, 3)" end="(246, 16)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(246, 3)" end="(246, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(246, 5)" end="(246, 7)">
                            <NullNode start="(246, 5)" end="(246, 7)">
                              <OtherNode start="(246, 5)" end="(246, 7)" kind="«term[_]»">
                                <AtomNode start="(246, 5)" end="(246, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(246, 6)" end="(246, 7)" leading="" trailing="  " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(246, 9)" end="(246, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(246, 12)" end="(246, 16)">
                            <TacticTacticseq1IndentedNode start="(246, 12)" end="(246, 16)">
                              <NullNode start="(246, 12)" end="(246, 16)">
                                <OtherNode start="(246, 12)" end="(246, 16)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p q : Poly&#10;⊢ denote ctx ([] ++ q) = denote ctx [] + denote ctx q" state_after="no goals" tactic="simp">
                                  <AtomNode start="(246, 12)" end="(246, 16)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(247, 3)" end="(247, 40)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(247, 3)" end="(247, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(247, 5)" end="(247, 16)">
                            <NullNode start="(247, 5)" end="(247, 16)">
                              <OtherNode start="(247, 5)" end="(247, 16)" kind="«term_::_»">
                                <OtherNode start="(247, 5)" end="(247, 11)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(247, 5)" end="(247, 6)" leading="" trailing="" val="("/>
                                  <NullNode start="(247, 6)" end="(247, 10)">
                                    <IdentNode start="(247, 6)" end="(247, 7)" leading="" trailing="" raw_val="k" val="k"/>
                                    <AtomNode start="(247, 7)" end="(247, 8)" leading="" trailing=" " val=","/>
                                    <NullNode start="(247, 9)" end="(247, 10)">
                                      <IdentNode start="(247, 9)" end="(247, 10)" leading="" trailing="" raw_val="v" val="v"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(247, 10)" end="(247, 11)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(247, 12)" end="(247, 14)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(247, 15)" end="(247, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(247, 17)" end="(247, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(247, 20)" end="(247, 40)">
                            <TacticTacticseq1IndentedNode start="(247, 20)" end="(247, 40)">
                              <NullNode start="(247, 20)" end="(247, 40)">
                                <OtherNode start="(247, 20)" end="(247, 40)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p✝ q : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;⊢ denote ctx ((k, v) :: p ++ q) = denote ctx ((k, v) :: p) + denote ctx q" state_after="no goals" tactic="simp [denote_append]">
                                  <AtomNode start="(247, 20)" end="(247, 24)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(247, 25)" end="(247, 40)">
                                    <AtomNode start="(247, 25)" end="(247, 26)" leading="" trailing="" val="["/>
                                    <NullNode start="(247, 26)" end="(247, 39)">
                                      <OtherNode start="(247, 26)" end="(247, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(247, 26)" end="(247, 39)" leading="" trailing="" raw_val="denote_append" val="denote_append"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(247, 39)" end="(247, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(249, 1)" end="(249, 42)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(249, 1)" end="(249, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(249, 11)" end="(249, 12)" leading="" trailing="" val="["/>
      <NullNode start="(249, 12)" end="(249, 22)">
        <OtherNode start="(249, 12)" end="(249, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(249, 12)" end="(249, 17)">
            <NullNode start="(249, 12)" end="(249, 17)">
              <OtherNode start="(249, 12)" end="(249, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(249, 12)" end="(249, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(249, 18)" end="(249, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(249, 18)" end="(249, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(249, 22)" end="(249, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(249, 24)" end="(249, 42)">
        <IdentNode start="(249, 24)" end="(249, 42)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_append" val="Poly.denote_append" full_name="Nat.Linear.Poly.denote_append" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(244, 9)" def_end="(244, 27)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(251, 1)" end="(254, 33)" name="Poly.denote_cons" full_name="Nat.Linear.Poly.denote_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(251, 1)" end="(254, 33)" name="Poly.denote_cons" full_name="Nat.Linear.Poly.denote_cons" _is_private_decl="False">
        <AtomNode start="(251, 1)" end="(251, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(251, 9)" end="(251, 25)">
          <IdentNode start="(251, 9)" end="(251, 25)" leading="" trailing=" " raw_val="Poly.denote_cons" val="Poly.denote_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(251, 26)" end="(251, 133)">
          <NullNode start="(251, 26)" end="(251, 72)">
            <TermExplicitbinderNode start="(251, 26)" end="(251, 41)">
              <AtomNode start="(251, 26)" end="(251, 27)" leading="" trailing="" val="("/>
              <NullNode start="(251, 27)" end="(251, 30)">
                <IdentNode start="(251, 27)" end="(251, 30)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(251, 31)" end="(251, 40)">
                <AtomNode start="(251, 31)" end="(251, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(251, 33)" end="(251, 40)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(251, 40)" end="(251, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(251, 42)" end="(251, 51)">
              <AtomNode start="(251, 42)" end="(251, 43)" leading="" trailing="" val="("/>
              <NullNode start="(251, 43)" end="(251, 44)">
                <IdentNode start="(251, 43)" end="(251, 44)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(251, 45)" end="(251, 50)">
                <AtomNode start="(251, 45)" end="(251, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(251, 47)" end="(251, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(251, 50)" end="(251, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(251, 52)" end="(251, 61)">
              <AtomNode start="(251, 52)" end="(251, 53)" leading="" trailing="" val="("/>
              <NullNode start="(251, 53)" end="(251, 54)">
                <IdentNode start="(251, 53)" end="(251, 54)" leading="" trailing=" " raw_val="v" val="v"/>
              </NullNode>
              <NullNode start="(251, 55)" end="(251, 60)">
                <AtomNode start="(251, 55)" end="(251, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(251, 57)" end="(251, 60)" leading="" trailing="" raw_val="Var" val="Var" full_name="Nat.Linear.Var" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(19, 8)" def_end="(19, 11)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(251, 60)" end="(251, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(251, 62)" end="(251, 72)">
              <AtomNode start="(251, 62)" end="(251, 63)" leading="" trailing="" val="("/>
              <NullNode start="(251, 63)" end="(251, 64)">
                <IdentNode start="(251, 63)" end="(251, 64)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(251, 65)" end="(251, 71)">
                <AtomNode start="(251, 65)" end="(251, 66)" leading="" trailing=" " val=":"/>
                <IdentNode start="(251, 67)" end="(251, 71)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(251, 71)" end="(251, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(251, 73)" end="(251, 133)">
            <AtomNode start="(251, 73)" end="(251, 74)" leading="" trailing=" " val=":"/>
            <OtherNode start="(251, 75)" end="(251, 133)" kind="«term_=_»">
              <OtherNode start="(251, 75)" end="(251, 99)" kind="Lean.Parser.Term.app">
                <IdentNode start="(251, 75)" end="(251, 81)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                <NullNode start="(251, 82)" end="(251, 99)">
                  <IdentNode start="(251, 82)" end="(251, 85)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(251, 86)" end="(251, 99)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(251, 86)" end="(251, 87)" leading="" trailing="" val="("/>
                    <OtherNode start="(251, 87)" end="(251, 98)" kind="«term_::_»">
                      <OtherNode start="(251, 87)" end="(251, 93)" kind="Lean.Parser.Term.tuple">
                        <AtomNode start="(251, 87)" end="(251, 88)" leading="" trailing="" val="("/>
                        <NullNode start="(251, 88)" end="(251, 92)">
                          <IdentNode start="(251, 88)" end="(251, 89)" leading="" trailing="" raw_val="k" val="k"/>
                          <AtomNode start="(251, 89)" end="(251, 90)" leading="" trailing=" " val=","/>
                          <NullNode start="(251, 91)" end="(251, 92)">
                            <IdentNode start="(251, 91)" end="(251, 92)" leading="" trailing="" raw_val="v" val="v"/>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(251, 92)" end="(251, 93)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(251, 94)" end="(251, 96)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(251, 97)" end="(251, 98)" leading="" trailing="" raw_val="p" val="p"/>
                    </OtherNode>
                    <AtomNode start="(251, 98)" end="(251, 99)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(251, 100)" end="(251, 101)" leading="" trailing=" " val="="/>
              <OtherNode start="(251, 102)" end="(251, 133)" kind="«term_+_»">
                <OtherNode start="(251, 102)" end="(251, 118)" kind="«term_*_»">
                  <IdentNode start="(251, 102)" end="(251, 103)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(251, 104)" end="(251, 105)" leading="" trailing=" " val="*"/>
                  <OtherNode start="(251, 106)" end="(251, 118)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(251, 106)" end="(251, 114)" leading="" trailing=" " raw_val="v.denote" val="v.denote"/>
                    <NullNode start="(251, 115)" end="(251, 118)">
                      <IdentNode start="(251, 115)" end="(251, 118)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(251, 119)" end="(251, 120)" leading="" trailing=" " val="+"/>
                <OtherNode start="(251, 121)" end="(251, 133)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(251, 121)" end="(251, 129)" leading="" trailing=" " raw_val="p.denote" val="p.denote"/>
                  <NullNode start="(251, 130)" end="(251, 133)">
                    <IdentNode start="(251, 130)" end="(251, 133)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(251, 134)" end="(254, 33)">
          <AtomNode start="(251, 134)" end="(251, 136)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(251, 137)" end="(254, 33)">
            <AtomNode start="(251, 137)" end="(251, 139)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(252, 3)" end="(254, 33)">
              <TacticTacticseq1IndentedNode start="(252, 3)" end="(254, 33)">
                <NullNode start="(252, 3)" end="(254, 33)">
                  <OtherNode start="(252, 3)" end="(254, 33)" kind="Lean.Parser.Tactic.match" state_before="ctx : Context&#10;k : Nat&#10;v : Var&#10;p : Poly&#10;⊢ denote ctx ((k, v) :: p) = k * Var.denote ctx v + denote ctx p" state_after="no goals" tactic="match p with&#10;| []     =&amp;gt; simp&#10;| _ :: m =&amp;gt; simp [denote_cons]">
                    <AtomNode start="(252, 3)" end="(252, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(252, 9)" end="(252, 10)">
                      <OtherNode start="(252, 9)" end="(252, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(252, 9)" end="(252, 10)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(252, 11)" end="(252, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(253, 3)" end="(254, 33)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(253, 3)" end="(254, 33)">
                        <OtherNode start="(253, 3)" end="(253, 19)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(253, 3)" end="(253, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(253, 5)" end="(253, 7)">
                            <NullNode start="(253, 5)" end="(253, 7)">
                              <OtherNode start="(253, 5)" end="(253, 7)" kind="«term[_]»">
                                <AtomNode start="(253, 5)" end="(253, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(253, 6)" end="(253, 7)" leading="" trailing="     " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(253, 12)" end="(253, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(253, 15)" end="(253, 19)">
                            <TacticTacticseq1IndentedNode start="(253, 15)" end="(253, 19)">
                              <NullNode start="(253, 15)" end="(253, 19)">
                                <OtherNode start="(253, 15)" end="(253, 19)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;k : Nat&#10;v : Var&#10;p : Poly&#10;⊢ denote ctx [(k, v)] = k * Var.denote ctx v + denote ctx []" state_after="no goals" tactic="simp">
                                  <AtomNode start="(253, 15)" end="(253, 19)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(254, 3)" end="(254, 33)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(254, 3)" end="(254, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(254, 5)" end="(254, 11)">
                            <NullNode start="(254, 5)" end="(254, 11)">
                              <OtherNode start="(254, 5)" end="(254, 11)" kind="«term_::_»">
                                <TermHoleNode start="(254, 5)" end="(254, 6)">
                                  <AtomNode start="(254, 5)" end="(254, 6)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(254, 7)" end="(254, 9)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(254, 10)" end="(254, 11)" leading="" trailing=" " raw_val="m" val="m"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(254, 12)" end="(254, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(254, 15)" end="(254, 33)">
                            <TacticTacticseq1IndentedNode start="(254, 15)" end="(254, 33)">
                              <NullNode start="(254, 15)" end="(254, 33)">
                                <OtherNode start="(254, 15)" end="(254, 33)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;k : Nat&#10;v : Var&#10;p : Poly&#10;head✝ : Nat × Var&#10;m : List (Nat × Var)&#10;⊢ denote ctx ((k, v) :: head✝ :: m) = k * Var.denote ctx v + denote ctx (head✝ :: m)" state_after="no goals" tactic="simp [denote_cons]">
                                  <AtomNode start="(254, 15)" end="(254, 19)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(254, 20)" end="(254, 33)">
                                    <AtomNode start="(254, 20)" end="(254, 21)" leading="" trailing="" val="["/>
                                    <NullNode start="(254, 21)" end="(254, 32)">
                                      <OtherNode start="(254, 21)" end="(254, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(254, 21)" end="(254, 32)" leading="" trailing="" raw_val="denote_cons" val="denote_cons"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(254, 32)" end="(254, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(256, 1)" end="(256, 40)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(256, 1)" end="(256, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(256, 11)" end="(256, 12)" leading="" trailing="" val="["/>
      <NullNode start="(256, 12)" end="(256, 22)">
        <OtherNode start="(256, 12)" end="(256, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(256, 12)" end="(256, 17)">
            <NullNode start="(256, 12)" end="(256, 17)">
              <OtherNode start="(256, 12)" end="(256, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(256, 12)" end="(256, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(256, 18)" end="(256, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(256, 18)" end="(256, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(256, 22)" end="(256, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(256, 24)" end="(256, 40)">
        <IdentNode start="(256, 24)" end="(256, 40)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_cons" val="Poly.denote_cons" full_name="Nat.Linear.Poly.denote_cons" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(251, 9)" def_end="(251, 25)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(258, 1)" end="(261, 61)" name="Poly.denote_reverseAux" full_name="Nat.Linear.Poly.denote_reverseAux">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(258, 1)" end="(261, 61)" name="Poly.denote_reverseAux" full_name="Nat.Linear.Poly.denote_reverseAux" _is_private_decl="False">
        <AtomNode start="(258, 1)" end="(258, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(258, 9)" end="(258, 31)">
          <IdentNode start="(258, 9)" end="(258, 31)" leading="" trailing=" " raw_val="Poly.denote_reverseAux" val="Poly.denote_reverseAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(258, 32)" end="(258, 117)">
          <NullNode start="(258, 32)" end="(258, 60)">
            <TermExplicitbinderNode start="(258, 32)" end="(258, 47)">
              <AtomNode start="(258, 32)" end="(258, 33)" leading="" trailing="" val="("/>
              <NullNode start="(258, 33)" end="(258, 36)">
                <IdentNode start="(258, 33)" end="(258, 36)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(258, 37)" end="(258, 46)">
                <AtomNode start="(258, 37)" end="(258, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(258, 39)" end="(258, 46)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(258, 46)" end="(258, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(258, 48)" end="(258, 60)">
              <AtomNode start="(258, 48)" end="(258, 49)" leading="" trailing="" val="("/>
              <NullNode start="(258, 49)" end="(258, 52)">
                <IdentNode start="(258, 49)" end="(258, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(258, 51)" end="(258, 52)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(258, 53)" end="(258, 59)">
                <AtomNode start="(258, 53)" end="(258, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(258, 55)" end="(258, 59)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(258, 59)" end="(258, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(258, 61)" end="(258, 117)">
            <AtomNode start="(258, 61)" end="(258, 62)" leading="" trailing=" " val=":"/>
            <OtherNode start="(258, 63)" end="(258, 117)" kind="«term_=_»">
              <OtherNode start="(258, 63)" end="(258, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(258, 63)" end="(258, 69)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                <NullNode start="(258, 70)" end="(258, 95)">
                  <IdentNode start="(258, 70)" end="(258, 73)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(258, 74)" end="(258, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(258, 74)" end="(258, 75)" leading="" trailing="" val="("/>
                    <OtherNode start="(258, 75)" end="(258, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(258, 75)" end="(258, 90)" leading="" trailing=" " raw_val="List.reverseAux" val="List.reverseAux" full_name="List.reverseAux" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(258, 91)" end="(258, 94)">
                        <IdentNode start="(258, 91)" end="(258, 92)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(258, 93)" end="(258, 94)" leading="" trailing="" raw_val="q" val="q"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(258, 94)" end="(258, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(258, 96)" end="(258, 97)" leading="" trailing=" " val="="/>
              <OtherNode start="(258, 98)" end="(258, 117)" kind="Lean.Parser.Term.app">
                <IdentNode start="(258, 98)" end="(258, 104)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                <NullNode start="(258, 105)" end="(258, 117)">
                  <IdentNode start="(258, 105)" end="(258, 108)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(258, 109)" end="(258, 117)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(258, 109)" end="(258, 110)" leading="" trailing="" val="("/>
                    <OtherNode start="(258, 110)" end="(258, 116)" kind="«term_++_»">
                      <IdentNode start="(258, 110)" end="(258, 111)" leading="" trailing=" " raw_val="p" val="p"/>
                      <AtomNode start="(258, 112)" end="(258, 114)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(258, 115)" end="(258, 116)" leading="" trailing="" raw_val="q" val="q"/>
                    </OtherNode>
                    <AtomNode start="(258, 116)" end="(258, 117)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(258, 118)" end="(261, 61)">
          <AtomNode start="(258, 118)" end="(258, 120)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(258, 121)" end="(261, 61)">
            <AtomNode start="(258, 121)" end="(258, 123)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(259, 3)" end="(261, 61)">
              <TacticTacticseq1IndentedNode start="(259, 3)" end="(261, 61)">
                <NullNode start="(259, 3)" end="(261, 61)">
                  <OtherNode start="(259, 3)" end="(261, 61)" kind="Lean.Parser.Tactic.match" state_before="ctx : Context&#10;p q : Poly&#10;⊢ denote ctx (List.reverseAux p q) = denote ctx (p ++ q)" state_after="no goals" tactic="match p with&#10;| [] =&amp;gt; simp [List.reverseAux]&#10;| (k, v) :: p =&amp;gt; simp [List.reverseAux, denote_reverseAux]">
                    <AtomNode start="(259, 3)" end="(259, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(259, 9)" end="(259, 10)">
                      <OtherNode start="(259, 9)" end="(259, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(259, 9)" end="(259, 10)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(259, 11)" end="(259, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(260, 3)" end="(261, 61)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(260, 3)" end="(261, 61)">
                        <OtherNode start="(260, 3)" end="(260, 33)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(260, 3)" end="(260, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(260, 5)" end="(260, 7)">
                            <NullNode start="(260, 5)" end="(260, 7)">
                              <OtherNode start="(260, 5)" end="(260, 7)" kind="«term[_]»">
                                <AtomNode start="(260, 5)" end="(260, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(260, 6)" end="(260, 7)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(260, 8)" end="(260, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(260, 11)" end="(260, 33)">
                            <TacticTacticseq1IndentedNode start="(260, 11)" end="(260, 33)">
                              <NullNode start="(260, 11)" end="(260, 33)">
                                <OtherNode start="(260, 11)" end="(260, 33)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p q : Poly&#10;⊢ denote ctx ([].reverseAux q) = denote ctx ([] ++ q)" state_after="no goals" tactic="simp [List.reverseAux]">
                                  <AtomNode start="(260, 11)" end="(260, 15)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(260, 16)" end="(260, 33)">
                                    <AtomNode start="(260, 16)" end="(260, 17)" leading="" trailing="" val="["/>
                                    <NullNode start="(260, 17)" end="(260, 32)">
                                      <OtherNode start="(260, 17)" end="(260, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(260, 17)" end="(260, 32)" leading="" trailing="" raw_val="List.reverseAux" val="List.reverseAux" full_name="List.reverseAux" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(260, 32)" end="(260, 33)" leading="" trailing="&#10;  " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(261, 3)" end="(261, 61)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(261, 3)" end="(261, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(261, 5)" end="(261, 16)">
                            <NullNode start="(261, 5)" end="(261, 16)">
                              <OtherNode start="(261, 5)" end="(261, 16)" kind="«term_::_»">
                                <OtherNode start="(261, 5)" end="(261, 11)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(261, 5)" end="(261, 6)" leading="" trailing="" val="("/>
                                  <NullNode start="(261, 6)" end="(261, 10)">
                                    <IdentNode start="(261, 6)" end="(261, 7)" leading="" trailing="" raw_val="k" val="k"/>
                                    <AtomNode start="(261, 7)" end="(261, 8)" leading="" trailing=" " val=","/>
                                    <NullNode start="(261, 9)" end="(261, 10)">
                                      <IdentNode start="(261, 9)" end="(261, 10)" leading="" trailing="" raw_val="v" val="v"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(261, 10)" end="(261, 11)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(261, 12)" end="(261, 14)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(261, 15)" end="(261, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(261, 17)" end="(261, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(261, 20)" end="(261, 61)">
                            <TacticTacticseq1IndentedNode start="(261, 20)" end="(261, 61)">
                              <NullNode start="(261, 20)" end="(261, 61)">
                                <OtherNode start="(261, 20)" end="(261, 61)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p✝ q : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;⊢ denote ctx (((k, v) :: p).reverseAux q) = denote ctx ((k, v) :: p ++ q)" state_after="no goals" tactic="simp [List.reverseAux, denote_reverseAux]">
                                  <AtomNode start="(261, 20)" end="(261, 24)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(261, 25)" end="(261, 61)">
                                    <AtomNode start="(261, 25)" end="(261, 26)" leading="" trailing="" val="["/>
                                    <NullNode start="(261, 26)" end="(261, 60)">
                                      <OtherNode start="(261, 26)" end="(261, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(261, 26)" end="(261, 41)" leading="" trailing="" raw_val="List.reverseAux" val="List.reverseAux" full_name="List.reverseAux" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(261, 41)" end="(261, 42)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(261, 43)" end="(261, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(261, 43)" end="(261, 60)" leading="" trailing="" raw_val="denote_reverseAux" val="denote_reverseAux"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(261, 60)" end="(261, 61)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(263, 1)" end="(263, 46)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(263, 1)" end="(263, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(263, 11)" end="(263, 12)" leading="" trailing="" val="["/>
      <NullNode start="(263, 12)" end="(263, 22)">
        <OtherNode start="(263, 12)" end="(263, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(263, 12)" end="(263, 17)">
            <NullNode start="(263, 12)" end="(263, 17)">
              <OtherNode start="(263, 12)" end="(263, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(263, 12)" end="(263, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(263, 18)" end="(263, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(263, 18)" end="(263, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(263, 22)" end="(263, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(263, 24)" end="(263, 46)">
        <IdentNode start="(263, 24)" end="(263, 46)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_reverseAux" val="Poly.denote_reverseAux" full_name="Nat.Linear.Poly.denote_reverseAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(258, 9)" def_end="(258, 31)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(265, 1)" end="(266, 22)" name="Poly.denote_reverse" full_name="Nat.Linear.Poly.denote_reverse">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(265, 1)" end="(266, 22)" name="Poly.denote_reverse" full_name="Nat.Linear.Poly.denote_reverse" _is_private_decl="False">
        <AtomNode start="(265, 1)" end="(265, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(265, 9)" end="(265, 28)">
          <IdentNode start="(265, 9)" end="(265, 28)" leading="" trailing=" " raw_val="Poly.denote_reverse" val="Poly.denote_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(265, 29)" end="(265, 100)">
          <NullNode start="(265, 29)" end="(265, 55)">
            <TermExplicitbinderNode start="(265, 29)" end="(265, 44)">
              <AtomNode start="(265, 29)" end="(265, 30)" leading="" trailing="" val="("/>
              <NullNode start="(265, 30)" end="(265, 33)">
                <IdentNode start="(265, 30)" end="(265, 33)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(265, 34)" end="(265, 43)">
                <AtomNode start="(265, 34)" end="(265, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(265, 36)" end="(265, 43)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(265, 43)" end="(265, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(265, 45)" end="(265, 55)">
              <AtomNode start="(265, 45)" end="(265, 46)" leading="" trailing="" val="("/>
              <NullNode start="(265, 46)" end="(265, 47)">
                <IdentNode start="(265, 46)" end="(265, 47)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(265, 48)" end="(265, 54)">
                <AtomNode start="(265, 48)" end="(265, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(265, 50)" end="(265, 54)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(265, 54)" end="(265, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(265, 56)" end="(265, 100)">
            <AtomNode start="(265, 56)" end="(265, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(265, 58)" end="(265, 100)" kind="«term_=_»">
              <OtherNode start="(265, 58)" end="(265, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(265, 58)" end="(265, 64)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                <NullNode start="(265, 65)" end="(265, 85)">
                  <IdentNode start="(265, 65)" end="(265, 68)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(265, 69)" end="(265, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(265, 69)" end="(265, 70)" leading="" trailing="" val="("/>
                    <OtherNode start="(265, 70)" end="(265, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(265, 70)" end="(265, 82)" leading="" trailing=" " raw_val="List.reverse" val="List.reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(265, 83)" end="(265, 84)">
                        <IdentNode start="(265, 83)" end="(265, 84)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(265, 84)" end="(265, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(265, 86)" end="(265, 87)" leading="" trailing=" " val="="/>
              <OtherNode start="(265, 88)" end="(265, 100)" kind="Lean.Parser.Term.app">
                <IdentNode start="(265, 88)" end="(265, 94)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                <NullNode start="(265, 95)" end="(265, 100)">
                  <IdentNode start="(265, 95)" end="(265, 98)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <IdentNode start="(265, 99)" end="(265, 100)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(265, 101)" end="(266, 22)">
          <AtomNode start="(265, 101)" end="(265, 103)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(265, 104)" end="(266, 22)">
            <AtomNode start="(265, 104)" end="(265, 106)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(266, 3)" end="(266, 22)">
              <TacticTacticseq1IndentedNode start="(266, 3)" end="(266, 22)">
                <NullNode start="(266, 3)" end="(266, 22)">
                  <OtherNode start="(266, 3)" end="(266, 22)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p : Poly&#10;⊢ denote ctx (List.reverse p) = denote ctx p" state_after="no goals" tactic="simp [List.reverse]">
                    <AtomNode start="(266, 3)" end="(266, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(266, 8)" end="(266, 22)">
                      <AtomNode start="(266, 8)" end="(266, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(266, 9)" end="(266, 21)">
                        <OtherNode start="(266, 9)" end="(266, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(266, 9)" end="(266, 21)" leading="" trailing="" raw_val="List.reverse" val="List.reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(266, 21)" end="(266, 22)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(268, 1)" end="(268, 43)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(268, 1)" end="(268, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(268, 11)" end="(268, 12)" leading="" trailing="" val="["/>
      <NullNode start="(268, 12)" end="(268, 22)">
        <OtherNode start="(268, 12)" end="(268, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(268, 12)" end="(268, 17)">
            <NullNode start="(268, 12)" end="(268, 17)">
              <OtherNode start="(268, 12)" end="(268, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(268, 12)" end="(268, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(268, 18)" end="(268, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(268, 18)" end="(268, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(268, 22)" end="(268, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(268, 24)" end="(268, 43)">
        <IdentNode start="(268, 24)" end="(268, 43)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_reverse" val="Poly.denote_reverse" full_name="Nat.Linear.Poly.denote_reverse" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(265, 9)" def_end="(265, 28)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(270, 1)" end="(273, 62)" name="eq_of_not_blt_eq_true" full_name="Nat.Linear.eq_of_not_blt_eq_true">
      <CommandDeclmodifiersNode start="(270, 1)" end="(270, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(270, 1)" end="(270, 8)">
          <CommandPrivateNode start="(270, 1)" end="(270, 8)">
            <AtomNode start="(270, 1)" end="(270, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(270, 9)" end="(273, 62)" name="eq_of_not_blt_eq_true" full_name="Nat.Linear.eq_of_not_blt_eq_true" _is_private_decl="True">
        <AtomNode start="(270, 9)" end="(270, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(270, 17)" end="(270, 38)">
          <IdentNode start="(270, 17)" end="(270, 38)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(270, 39)" end="(270, 106)">
          <NullNode start="(270, 39)" end="(270, 98)">
            <TermExplicitbinderNode start="(270, 39)" end="(270, 68)">
              <AtomNode start="(270, 39)" end="(270, 40)" leading="" trailing="" val="("/>
              <NullNode start="(270, 40)" end="(270, 42)">
                <IdentNode start="(270, 40)" end="(270, 42)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
              </NullNode>
              <NullNode start="(270, 43)" end="(270, 67)">
                <AtomNode start="(270, 43)" end="(270, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(270, 45)" end="(270, 67)" kind="«term¬_»">
                  <AtomNode start="(270, 45)" end="(270, 46)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(270, 47)" end="(270, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(270, 47)" end="(270, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(270, 48)" end="(270, 66)" kind="«term_=_»">
                      <OtherNode start="(270, 48)" end="(270, 59)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(270, 48)" end="(270, 55)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        <NullNode start="(270, 56)" end="(270, 59)">
                          <IdentNode start="(270, 56)" end="(270, 57)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(270, 58)" end="(270, 59)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(270, 60)" end="(270, 61)" leading="" trailing=" " val="="/>
                      <IdentNode start="(270, 62)" end="(270, 66)" leading="" trailing="" raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(270, 66)" end="(270, 67)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(270, 67)" end="(270, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(270, 69)" end="(270, 98)">
              <AtomNode start="(270, 69)" end="(270, 70)" leading="" trailing="" val="("/>
              <NullNode start="(270, 70)" end="(270, 72)">
                <IdentNode start="(270, 70)" end="(270, 72)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
              </NullNode>
              <NullNode start="(270, 73)" end="(270, 97)">
                <AtomNode start="(270, 73)" end="(270, 74)" leading="" trailing=" " val=":"/>
                <OtherNode start="(270, 75)" end="(270, 97)" kind="«term¬_»">
                  <AtomNode start="(270, 75)" end="(270, 76)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(270, 77)" end="(270, 97)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(270, 77)" end="(270, 78)" leading="" trailing="" val="("/>
                    <OtherNode start="(270, 78)" end="(270, 96)" kind="«term_=_»">
                      <OtherNode start="(270, 78)" end="(270, 89)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(270, 78)" end="(270, 85)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        <NullNode start="(270, 86)" end="(270, 89)">
                          <IdentNode start="(270, 86)" end="(270, 87)" leading="" trailing=" " raw_val="y" val="y"/>
                          <IdentNode start="(270, 88)" end="(270, 89)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(270, 90)" end="(270, 91)" leading="" trailing=" " val="="/>
                      <IdentNode start="(270, 92)" end="(270, 96)" leading="" trailing="" raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(270, 96)" end="(270, 97)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(270, 97)" end="(270, 98)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(270, 99)" end="(270, 106)">
            <AtomNode start="(270, 99)" end="(270, 100)" leading="" trailing=" " val=":"/>
            <OtherNode start="(270, 101)" end="(270, 106)" kind="«term_=_»">
              <IdentNode start="(270, 101)" end="(270, 102)" leading="" trailing=" " raw_val="x" val="x"/>
              <AtomNode start="(270, 103)" end="(270, 104)" leading="" trailing=" " val="="/>
              <IdentNode start="(270, 105)" end="(270, 106)" leading="" trailing=" " raw_val="y" val="y"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(270, 107)" end="(273, 62)">
          <AtomNode start="(270, 107)" end="(270, 109)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(271, 3)" end="(273, 62)" kind="Lean.Parser.Term.have">
            <AtomNode start="(271, 3)" end="(271, 7)" leading="" trailing=" " val="have"/>
            <OtherNode start="(271, 8)" end="(271, 54)" kind="Lean.Parser.Term.haveDecl">
              <OtherNode start="(271, 8)" end="(271, 54)" kind="Lean.Parser.Term.haveIdDecl">
                <OtherNode start="(271, 8)" end="(271, 10)" kind="Lean.Parser.Term.haveId">
                  <IdentNode start="(271, 8)" end="(271, 10)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                </OtherNode>
                <NullNode/>
                <NullNode start="(271, 11)" end="(271, 20)">
                  <TermTypespecNode start="(271, 11)" end="(271, 20)">
                    <AtomNode start="(271, 11)" end="(271, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(271, 13)" end="(271, 20)" kind="«term¬_»">
                      <AtomNode start="(271, 13)" end="(271, 14)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(271, 15)" end="(271, 20)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(271, 15)" end="(271, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(271, 17)" end="(271, 18)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(271, 19)" end="(271, 20)" leading="" trailing=" " raw_val="y" val="y"/>
                      </OtherNode>
                    </OtherNode>
                  </TermTypespecNode>
                </NullNode>
                <AtomNode start="(271, 21)" end="(271, 23)" leading="" trailing=" " val=":="/>
                <OtherNode start="(271, 24)" end="(271, 54)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(271, 24)" end="(271, 27)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(271, 28)" end="(271, 54)" kind="Lean.Parser.Term.basicFun">
                    <NullNode start="(271, 28)" end="(271, 29)">
                      <IdentNode start="(271, 28)" end="(271, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(271, 30)" end="(271, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(271, 33)" end="(271, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(271, 33)" end="(271, 35)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                      <NullNode start="(271, 36)" end="(271, 54)">
                        <OtherNode start="(271, 36)" end="(271, 54)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(271, 36)" end="(271, 37)" leading="" trailing="" val="("/>
                          <OtherNode start="(271, 37)" end="(271, 53)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(271, 37)" end="(271, 51)" leading="" trailing=" " raw_val="Nat.blt_eq.mpr" val="Nat.blt_eq.mpr"/>
                            <NullNode start="(271, 52)" end="(271, 53)">
                              <IdentNode start="(271, 52)" end="(271, 53)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(271, 53)" end="(271, 54)" leading="" trailing="&#10;  " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <NullNode/>
            <OtherNode start="(272, 3)" end="(273, 62)" kind="Lean.Parser.Term.have">
              <AtomNode start="(272, 3)" end="(272, 7)" leading="" trailing=" " val="have"/>
              <OtherNode start="(272, 8)" end="(272, 54)" kind="Lean.Parser.Term.haveDecl">
                <OtherNode start="(272, 8)" end="(272, 54)" kind="Lean.Parser.Term.haveIdDecl">
                  <OtherNode start="(272, 8)" end="(272, 10)" kind="Lean.Parser.Term.haveId">
                    <IdentNode start="(272, 8)" end="(272, 10)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                  </OtherNode>
                  <NullNode/>
                  <NullNode start="(272, 11)" end="(272, 20)">
                    <TermTypespecNode start="(272, 11)" end="(272, 20)">
                      <AtomNode start="(272, 11)" end="(272, 12)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(272, 13)" end="(272, 20)" kind="«term¬_»">
                        <AtomNode start="(272, 13)" end="(272, 14)" leading="" trailing=" " val="¬"/>
                        <OtherNode start="(272, 15)" end="(272, 20)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(272, 15)" end="(272, 16)" leading="" trailing=" " raw_val="y" val="y"/>
                          <AtomNode start="(272, 17)" end="(272, 18)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(272, 19)" end="(272, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                        </OtherNode>
                      </OtherNode>
                    </TermTypespecNode>
                  </NullNode>
                  <AtomNode start="(272, 21)" end="(272, 23)" leading="" trailing=" " val=":="/>
                  <OtherNode start="(272, 24)" end="(272, 54)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(272, 24)" end="(272, 27)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(272, 28)" end="(272, 54)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(272, 28)" end="(272, 29)">
                        <IdentNode start="(272, 28)" end="(272, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(272, 30)" end="(272, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(272, 33)" end="(272, 54)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(272, 33)" end="(272, 35)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                        <NullNode start="(272, 36)" end="(272, 54)">
                          <OtherNode start="(272, 36)" end="(272, 54)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(272, 36)" end="(272, 37)" leading="" trailing="" val="("/>
                            <OtherNode start="(272, 37)" end="(272, 53)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(272, 37)" end="(272, 51)" leading="" trailing=" " raw_val="Nat.blt_eq.mpr" val="Nat.blt_eq.mpr"/>
                              <NullNode start="(272, 52)" end="(272, 53)">
                                <IdentNode start="(272, 52)" end="(272, 53)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(272, 53)" end="(272, 54)" leading="" trailing="&#10;  " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
              <NullNode/>
              <OtherNode start="(273, 3)" end="(273, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(273, 3)" end="(273, 18)" leading="" trailing=" " raw_val="Nat.le_antisymm" val="Nat.le_antisymm" full_name="Nat.le_antisymm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(273, 19)" end="(273, 62)">
                  <OtherNode start="(273, 19)" end="(273, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(273, 19)" end="(273, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(273, 20)" end="(273, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(273, 20)" end="(273, 36)" leading="" trailing=" " raw_val="Nat.ge_of_not_lt" val="Nat.ge_of_not_lt" full_name="Nat.ge_of_not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                      <NullNode start="(273, 37)" end="(273, 39)">
                        <IdentNode start="(273, 37)" end="(273, 39)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(273, 39)" end="(273, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(273, 41)" end="(273, 62)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(273, 41)" end="(273, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(273, 42)" end="(273, 61)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(273, 42)" end="(273, 58)" leading="" trailing=" " raw_val="Nat.ge_of_not_lt" val="Nat.ge_of_not_lt" full_name="Nat.ge_of_not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                      <NullNode start="(273, 59)" end="(273, 61)">
                        <IdentNode start="(273, 59)" end="(273, 61)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(273, 61)" end="(273, 62)" leading="" trailing="&#10;&#10;" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(275, 1)" end="(307, 41)" name="Poly.denote_eq_cancelAux" full_name="Nat.Linear.Poly.denote_eq_cancelAux">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(275, 1)" end="(307, 41)" name="Poly.denote_eq_cancelAux" full_name="Nat.Linear.Poly.denote_eq_cancelAux" _is_private_decl="False">
        <AtomNode start="(275, 1)" end="(275, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(275, 9)" end="(275, 33)">
          <IdentNode start="(275, 9)" end="(275, 33)" leading="" trailing=" " raw_val="Poly.denote_eq_cancelAux" val="Poly.denote_eq_cancelAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(275, 34)" end="(276, 106)">
          <NullNode start="(275, 34)" end="(276, 61)">
            <TermExplicitbinderNode start="(275, 34)" end="(275, 49)">
              <AtomNode start="(275, 34)" end="(275, 35)" leading="" trailing="" val="("/>
              <NullNode start="(275, 35)" end="(275, 38)">
                <IdentNode start="(275, 35)" end="(275, 38)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(275, 39)" end="(275, 48)">
                <AtomNode start="(275, 39)" end="(275, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(275, 41)" end="(275, 48)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(275, 48)" end="(275, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(275, 50)" end="(275, 62)">
              <AtomNode start="(275, 50)" end="(275, 51)" leading="" trailing="" val="("/>
              <NullNode start="(275, 51)" end="(275, 55)">
                <IdentNode start="(275, 51)" end="(275, 55)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
              </NullNode>
              <NullNode start="(275, 56)" end="(275, 61)">
                <AtomNode start="(275, 56)" end="(275, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(275, 58)" end="(275, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(275, 61)" end="(275, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(275, 63)" end="(275, 83)">
              <AtomNode start="(275, 63)" end="(275, 64)" leading="" trailing="" val="("/>
              <NullNode start="(275, 64)" end="(275, 75)">
                <IdentNode start="(275, 64)" end="(275, 66)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(275, 67)" end="(275, 69)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                <IdentNode start="(275, 70)" end="(275, 72)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                <IdentNode start="(275, 73)" end="(275, 75)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
              </NullNode>
              <NullNode start="(275, 76)" end="(275, 82)">
                <AtomNode start="(275, 76)" end="(275, 77)" leading="" trailing=" " val=":"/>
                <IdentNode start="(275, 78)" end="(275, 82)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(275, 82)" end="(275, 83)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(276, 5)" end="(276, 61)">
              <AtomNode start="(276, 5)" end="(276, 6)" leading="" trailing="" val="("/>
              <NullNode start="(276, 6)" end="(276, 7)">
                <IdentNode start="(276, 6)" end="(276, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(276, 8)" end="(276, 60)">
                <AtomNode start="(276, 8)" end="(276, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(276, 10)" end="(276, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(276, 10)" end="(276, 19)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                  <NullNode start="(276, 20)" end="(276, 60)">
                    <IdentNode start="(276, 20)" end="(276, 23)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(276, 24)" end="(276, 60)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(276, 24)" end="(276, 25)" leading="" trailing="" val="("/>
                      <NullNode start="(276, 25)" end="(276, 59)">
                        <OtherNode start="(276, 25)" end="(276, 41)" kind="«term_++_»">
                          <IdentNode start="(276, 25)" end="(276, 35)" leading="" trailing=" " raw_val="r₁.reverse" val="r₁.reverse"/>
                          <AtomNode start="(276, 36)" end="(276, 38)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(276, 39)" end="(276, 41)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                        </OtherNode>
                        <AtomNode start="(276, 41)" end="(276, 42)" leading="" trailing=" " val=","/>
                        <NullNode start="(276, 43)" end="(276, 59)">
                          <OtherNode start="(276, 43)" end="(276, 59)" kind="«term_++_»">
                            <IdentNode start="(276, 43)" end="(276, 53)" leading="" trailing=" " raw_val="r₂.reverse" val="r₂.reverse"/>
                            <AtomNode start="(276, 54)" end="(276, 56)" leading="" trailing=" " val="++"/>
                            <IdentNode start="(276, 57)" end="(276, 59)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(276, 59)" end="(276, 60)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(276, 60)" end="(276, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(276, 62)" end="(276, 106)">
            <AtomNode start="(276, 62)" end="(276, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(276, 64)" end="(276, 106)" kind="Lean.Parser.Term.app">
              <IdentNode start="(276, 64)" end="(276, 73)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
              <NullNode start="(276, 74)" end="(276, 106)">
                <IdentNode start="(276, 74)" end="(276, 77)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(276, 78)" end="(276, 106)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(276, 78)" end="(276, 79)" leading="" trailing="" val="("/>
                  <OtherNode start="(276, 79)" end="(276, 105)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(276, 79)" end="(276, 88)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux" full_name="Nat.Linear.Poly.cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(71, 5)" def_end="(71, 19)"/>
                    <NullNode start="(276, 89)" end="(276, 105)">
                      <IdentNode start="(276, 89)" end="(276, 93)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                      <IdentNode start="(276, 94)" end="(276, 96)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                      <IdentNode start="(276, 97)" end="(276, 99)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                      <IdentNode start="(276, 100)" end="(276, 102)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                      <IdentNode start="(276, 103)" end="(276, 105)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(276, 105)" end="(276, 106)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(276, 107)" end="(307, 41)">
          <AtomNode start="(276, 107)" end="(276, 109)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(276, 110)" end="(307, 41)">
            <AtomNode start="(276, 110)" end="(276, 112)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(277, 3)" end="(307, 41)">
              <TacticTacticseq1IndentedNode start="(277, 3)" end="(307, 41)">
                <NullNode start="(277, 3)" end="(307, 41)">
                  <OtherNode start="(277, 3)" end="(307, 41)" kind="Lean.Parser.Tactic.induction" state_before="ctx : Context&#10;fuel : Nat&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="induction fuel generalizing m₁ m₂ r₁ r₂ with&#10;| zero =&amp;gt; assumption&#10;| succ fuel ih =&amp;gt;&#10;  simp&#10;  split &amp;lt;;&amp;gt; try (simp at h; try assumption)&#10;  rename_i k₁ v₁ m₁ k₂ v₂ m₂&#10;  by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv]&#10;  · apply ih; simp [denote_eq] at h |-; assumption&#10;  · by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv]&#10;    · apply ih; simp [denote_eq] at h |-; assumption&#10;    · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;      by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]&#10;      · apply ih&#10;        simp [denote_eq] at h |-&#10;        have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;        apply Eq.symm&#10;        apply Nat.sub_eq_of_eq_add&#10;        simp [h]&#10;      · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;        · apply ih&#10;          simp [denote_eq] at h |-&#10;          have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;          rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;          apply Nat.sub_eq_of_eq_add&#10;          simp [h]&#10;        · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;          apply ih&#10;          simp [denote_eq] at h |-&#10;          rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;          exact Nat.add_right_cancel h">
                    <AtomNode start="(277, 3)" end="(277, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(277, 13)" end="(277, 17)">
                      <OtherNode start="(277, 13)" end="(277, 17)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(277, 13)" end="(277, 17)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(277, 18)" end="(277, 42)">
                      <AtomNode start="(277, 18)" end="(277, 30)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(277, 31)" end="(277, 42)">
                        <IdentNode start="(277, 31)" end="(277, 33)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                        <IdentNode start="(277, 34)" end="(277, 36)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                        <IdentNode start="(277, 37)" end="(277, 39)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                        <IdentNode start="(277, 40)" end="(277, 42)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(277, 43)" end="(307, 41)">
                      <OtherNode start="(277, 43)" end="(307, 41)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(277, 43)" end="(277, 47)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(278, 3)" end="(307, 41)">
                          <OtherNode start="(278, 3)" end="(278, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(278, 3)" end="(278, 9)">
                              <OtherNode start="(278, 3)" end="(278, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(278, 3)" end="(278, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(278, 5)" end="(278, 9)">
                                  <NullNode/>
                                  <IdentNode start="(278, 5)" end="(278, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(278, 10)" end="(278, 23)">
                              <AtomNode start="(278, 10)" end="(278, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(278, 13)" end="(278, 23)">
                                <TacticTacticseq1IndentedNode start="(278, 13)" end="(278, 23)">
                                  <NullNode start="(278, 13)" end="(278, 23)">
                                    <OtherNode start="(278, 13)" end="(278, 23)" kind="Lean.Parser.Tactic.assumption" state_before="case zero&#10;ctx : Context&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (cancelAux 0 m₁ m₂ r₁ r₂)" state_after="no goals" tactic="assumption">
                                      <AtomNode start="(278, 13)" end="(278, 23)" leading="" trailing="&#10;  " val="assumption"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(279, 3)" end="(307, 41)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(279, 3)" end="(279, 17)">
                              <OtherNode start="(279, 3)" end="(279, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(279, 3)" end="(279, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(279, 5)" end="(279, 9)">
                                  <NullNode/>
                                  <IdentNode start="(279, 5)" end="(279, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(279, 10)" end="(279, 17)">
                                  <IdentNode start="(279, 10)" end="(279, 14)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                  <IdentNode start="(279, 15)" end="(279, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(279, 18)" end="(307, 41)">
                              <AtomNode start="(279, 18)" end="(279, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(280, 5)" end="(307, 41)">
                                <TacticTacticseq1IndentedNode start="(280, 5)" end="(307, 41)">
                                  <NullNode start="(280, 5)" end="(307, 41)">
                                    <OtherNode start="(280, 5)" end="(280, 9)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (cancelAux (fuel + 1) m₁ m₂ r₁ r₂)" state_after="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="simp">
                                      <AtomNode start="(280, 5)" end="(280, 9)" leading="" trailing="&#10;    " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(281, 5)" end="(281, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)&#10;⊢ denote_eq ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)" tactic="split &amp;lt;;&amp;gt; try (simp at h; try assumption)">
                                      <OtherNode start="(281, 5)" end="(281, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(281, 5)" end="(281, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(281, 11)" end="(281, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(281, 15)" end="(281, 46)" kind="Lean.Parser.Tactic.tacticTry_">
                                        <AtomNode start="(281, 15)" end="(281, 18)" leading="" trailing=" " val="try"/>
                                        <TacticTacticseqNode start="(281, 19)" end="(281, 46)">
                                          <TacticTacticseq1IndentedNode start="(281, 19)" end="(281, 46)">
                                            <NullNode start="(281, 19)" end="(281, 46)">
                                              <OtherNode start="(281, 19)" end="(281, 46)" kind="Lean.Parser.Tactic.paren" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;h : denote_eq ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)&#10;x✝ : m₂ = [] → False&#10;⊢ denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="(simp at h; try assumption)">
                                                <AtomNode start="(281, 19)" end="(281, 20)" leading="" trailing="" val="("/>
                                                <TacticTacticseqNode start="(281, 20)" end="(281, 45)">
                                                  <TacticTacticseq1IndentedNode start="(281, 20)" end="(281, 45)">
                                                    <NullNode start="(281, 20)" end="(281, 45)">
                                                      <OtherNode start="(281, 20)" end="(281, 29)" kind="Lean.Parser.Tactic.simp" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;h : denote_eq ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)&#10;x✝ : m₂ = [] → False&#10;⊢ denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" tactic="simp at h">
                                                        <AtomNode start="(281, 20)" end="(281, 24)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(281, 25)" end="(281, 29)">
                                                          <OtherNode start="(281, 25)" end="(281, 29)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(281, 25)" end="(281, 27)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(281, 28)" end="(281, 29)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(281, 28)" end="(281, 29)">
                                                            <IdentNode start="(281, 28)" end="(281, 29)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(281, 29)" end="(281, 30)" leading="" trailing=" " val=";"/>
                                                      <OtherNode start="(281, 31)" end="(281, 45)" kind="Lean.Parser.Tactic.tacticTry_" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="try assumption">
                                                        <AtomNode start="(281, 31)" end="(281, 34)" leading="" trailing=" " val="try"/>
                                                        <TacticTacticseqNode start="(281, 35)" end="(281, 45)">
                                                          <TacticTacticseq1IndentedNode start="(281, 35)" end="(281, 45)">
                                                            <NullNode start="(281, 35)" end="(281, 45)">
                                                            <OtherNode start="(281, 35)" end="(281, 45)" kind="Lean.Parser.Tactic.assumption" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="assumption">
                                                            <AtomNode start="(281, 35)" end="(281, 45)" leading="" trailing="" val="assumption"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                                <AtomNode start="(281, 45)" end="(281, 46)" leading="" trailing="&#10;    " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(282, 5)" end="(282, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)&#10;⊢ denote_eq ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_eq ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="rename_i k₁ v₁ m₁ k₂ v₂ m₂">
                                      <AtomNode start="(282, 5)" end="(282, 13)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(282, 14)" end="(282, 31)">
                                        <LeanBinderidentNode start="(282, 14)" end="(282, 16)">
                                          <IdentNode start="(282, 14)" end="(282, 16)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(282, 17)" end="(282, 19)">
                                          <IdentNode start="(282, 17)" end="(282, 19)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(282, 20)" end="(282, 22)">
                                          <IdentNode start="(282, 20)" end="(282, 22)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(282, 23)" end="(282, 25)">
                                          <IdentNode start="(282, 23)" end="(282, 25)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(282, 26)" end="(282, 28)">
                                          <IdentNode start="(282, 26)" end="(282, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(282, 29)" end="(282, 31)">
                                          <IdentNode start="(282, 29)" end="(282, 31)" leading="" trailing="&#10;    " raw_val="m₂" val="m₂"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(283, 5)" end="(283, 50)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_eq ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv]">
                                      <OtherNode start="(283, 5)" end="(283, 34)" kind="«tacticBy_cases_:_»">
                                        <AtomNode start="(283, 5)" end="(283, 13)" leading="" trailing=" " val="by_cases"/>
                                        <NullNode start="(283, 14)" end="(283, 20)">
                                          <IdentNode start="(283, 14)" end="(283, 18)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                          <AtomNode start="(283, 19)" end="(283, 20)" leading="" trailing=" " val=":"/>
                                        </NullNode>
                                        <OtherNode start="(283, 21)" end="(283, 34)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(283, 21)" end="(283, 28)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          <NullNode start="(283, 29)" end="(283, 34)">
                                            <IdentNode start="(283, 29)" end="(283, 31)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                            <IdentNode start="(283, 32)" end="(283, 34)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(283, 35)" end="(283, 38)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(283, 39)" end="(283, 50)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(283, 39)" end="(283, 43)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(283, 44)" end="(283, 50)">
                                          <AtomNode start="(283, 44)" end="(283, 45)" leading="" trailing="" val="["/>
                                          <NullNode start="(283, 45)" end="(283, 49)">
                                            <OtherNode start="(283, 45)" end="(283, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(283, 45)" end="(283, 49)" leading="" trailing="" raw_val="hltv" val="hltv"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(283, 49)" end="(283, 50)" leading="" trailing="&#10;    " val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(284, 5)" end="(284, 53)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih; simp [denote_eq] at h |-; assumption">
                                      <OtherNode start="(284, 5)" end="(284, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(284, 5)" end="(284, 6)" kind="patternIgnore">
                                          <OtherNode start="(284, 5)" end="(284, 6)" kind="token.«· »">
                                            <AtomNode start="(284, 5)" end="(284, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(284, 7)" end="(284, 53)">
                                        <TacticTacticseq1IndentedNode start="(284, 7)" end="(284, 53)">
                                          <NullNode start="(284, 7)" end="(284, 53)">
                                            <OtherNode start="(284, 7)" end="(284, 15)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_eq ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="apply ih">
                                              <AtomNode start="(284, 7)" end="(284, 12)" leading="" trailing=" " val="apply"/>
                                              <IdentNode start="(284, 13)" end="(284, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                            <AtomNode start="(284, 15)" end="(284, 16)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(284, 17)" end="(284, 41)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_eq ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_eq] at h |-">
                                              <AtomNode start="(284, 17)" end="(284, 21)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(284, 22)" end="(284, 33)">
                                                <AtomNode start="(284, 22)" end="(284, 23)" leading="" trailing="" val="["/>
                                                <NullNode start="(284, 23)" end="(284, 32)">
                                                  <OtherNode start="(284, 23)" end="(284, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(284, 23)" end="(284, 32)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(284, 32)" end="(284, 33)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(284, 34)" end="(284, 41)">
                                                <OtherNode start="(284, 34)" end="(284, 41)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(284, 34)" end="(284, 36)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(284, 37)" end="(284, 41)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(284, 37)" end="(284, 41)">
                                                      <IdentNode start="(284, 37)" end="(284, 38)" leading="" trailing=" " raw_val="h" val="h"/>
                                                      <OtherNode start="(284, 39)" end="(284, 41)" kind="Lean.Parser.Tactic.locationType">
                                                        <OtherNode start="(284, 39)" end="(284, 41)" kind="patternIgnore">
                                                          <GroupNode start="(284, 39)" end="(284, 41)">
                                                            <AtomNode start="(284, 39)" end="(284, 40)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(284, 40)" end="(284, 41)" leading="" trailing="" val="-"/>
                                                          </GroupNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(284, 41)" end="(284, 42)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(284, 43)" end="(284, 53)" kind="Lean.Parser.Tactic.assumption" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                              <AtomNode start="(284, 43)" end="(284, 53)" leading="" trailing="&#10;    " val="assumption"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(285, 5)" end="(307, 41)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv]&#10;  · apply ih; simp [denote_eq] at h |-; assumption&#10;  · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;    by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]&#10;    · apply ih&#10;      simp [denote_eq] at h |-&#10;      have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;      apply Eq.symm&#10;      apply Nat.sub_eq_of_eq_add&#10;      simp [h]&#10;    · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;      · apply ih&#10;        simp [denote_eq] at h |-&#10;        have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;        apply Nat.sub_eq_of_eq_add&#10;        simp [h]&#10;      · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;        apply ih&#10;        simp [denote_eq] at h |-&#10;        rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;        exact Nat.add_right_cancel h">
                                      <OtherNode start="(285, 5)" end="(285, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(285, 5)" end="(285, 6)" kind="patternIgnore">
                                          <OtherNode start="(285, 5)" end="(285, 6)" kind="token.«· »">
                                            <AtomNode start="(285, 5)" end="(285, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(285, 7)" end="(307, 41)">
                                        <TacticTacticseq1IndentedNode start="(285, 7)" end="(307, 41)">
                                          <NullNode start="(285, 7)" end="(307, 41)">
                                            <OtherNode start="(285, 7)" end="(285, 52)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv]">
                                              <OtherNode start="(285, 7)" end="(285, 36)" kind="«tacticBy_cases_:_»">
                                                <AtomNode start="(285, 7)" end="(285, 15)" leading="" trailing=" " val="by_cases"/>
                                                <NullNode start="(285, 16)" end="(285, 22)">
                                                  <IdentNode start="(285, 16)" end="(285, 20)" leading="" trailing=" " raw_val="hgtv" val="hgtv"/>
                                                  <AtomNode start="(285, 21)" end="(285, 22)" leading="" trailing=" " val=":"/>
                                                </NullNode>
                                                <OtherNode start="(285, 23)" end="(285, 36)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(285, 23)" end="(285, 30)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  <NullNode start="(285, 31)" end="(285, 36)">
                                                    <IdentNode start="(285, 31)" end="(285, 33)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                    <IdentNode start="(285, 34)" end="(285, 36)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(285, 37)" end="(285, 40)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(285, 41)" end="(285, 52)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(285, 41)" end="(285, 45)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(285, 46)" end="(285, 52)">
                                                  <AtomNode start="(285, 46)" end="(285, 47)" leading="" trailing="" val="["/>
                                                  <NullNode start="(285, 47)" end="(285, 51)">
                                                    <OtherNode start="(285, 47)" end="(285, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(285, 47)" end="(285, 51)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(285, 51)" end="(285, 52)" leading="" trailing="&#10;      " val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(286, 7)" end="(286, 55)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih; simp [denote_eq] at h |-; assumption">
                                              <OtherNode start="(286, 7)" end="(286, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(286, 7)" end="(286, 8)" kind="patternIgnore">
                                                  <OtherNode start="(286, 7)" end="(286, 8)" kind="token.«· »">
                                                    <AtomNode start="(286, 7)" end="(286, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(286, 9)" end="(286, 55)">
                                                <TacticTacticseq1IndentedNode start="(286, 9)" end="(286, 55)">
                                                  <NullNode start="(286, 9)" end="(286, 55)">
                                                    <OtherNode start="(286, 9)" end="(286, 17)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)" tactic="apply ih">
                                                      <AtomNode start="(286, 9)" end="(286, 14)" leading="" trailing=" " val="apply"/>
                                                      <IdentNode start="(286, 15)" end="(286, 17)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                    </OtherNode>
                                                    <AtomNode start="(286, 17)" end="(286, 18)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(286, 19)" end="(286, 43)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_eq] at h |-">
                                                      <AtomNode start="(286, 19)" end="(286, 23)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(286, 24)" end="(286, 35)">
                                                        <AtomNode start="(286, 24)" end="(286, 25)" leading="" trailing="" val="["/>
                                                        <NullNode start="(286, 25)" end="(286, 34)">
                                                          <OtherNode start="(286, 25)" end="(286, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(286, 25)" end="(286, 34)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(286, 34)" end="(286, 35)" leading="" trailing=" " val="]"/>
                                                      </NullNode>
                                                      <NullNode start="(286, 36)" end="(286, 43)">
                                                        <OtherNode start="(286, 36)" end="(286, 43)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(286, 36)" end="(286, 38)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(286, 39)" end="(286, 43)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(286, 39)" end="(286, 43)">
                                                            <IdentNode start="(286, 39)" end="(286, 40)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(286, 41)" end="(286, 43)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(286, 41)" end="(286, 43)" kind="patternIgnore">
                                                            <GroupNode start="(286, 41)" end="(286, 43)">
                                                            <AtomNode start="(286, 41)" end="(286, 42)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(286, 42)" end="(286, 43)" leading="" trailing="" val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(286, 43)" end="(286, 44)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(286, 45)" end="(286, 55)" kind="Lean.Parser.Tactic.assumption" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                                      <AtomNode start="(286, 45)" end="(286, 55)" leading="" trailing="&#10;      " val="assumption"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(287, 7)" end="(307, 41)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;  by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]&#10;  · apply ih&#10;    simp [denote_eq] at h |-&#10;    have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;    apply Eq.symm&#10;    apply Nat.sub_eq_of_eq_add&#10;    simp [h]&#10;  · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;    · apply ih&#10;      simp [denote_eq] at h |-&#10;      have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;      apply Nat.sub_eq_of_eq_add&#10;      simp [h]&#10;    · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;      apply ih&#10;      simp [denote_eq] at h |-&#10;      rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;      exact Nat.add_right_cancel h">
                                              <OtherNode start="(287, 7)" end="(287, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(287, 7)" end="(287, 8)" kind="patternIgnore">
                                                  <OtherNode start="(287, 7)" end="(287, 8)" kind="token.«· »">
                                                    <AtomNode start="(287, 7)" end="(287, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(287, 9)" end="(307, 41)">
                                                <TacticTacticseq1IndentedNode start="(287, 9)" end="(307, 41)">
                                                  <NullNode start="(287, 9)" end="(307, 41)">
                                                    <OtherNode start="(287, 9)" end="(287, 63)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;heqv : v₁ = v₂&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv">
                                                      <AtomNode start="(287, 9)" end="(287, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(287, 14)" end="(287, 63)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(287, 14)" end="(287, 63)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(287, 14)" end="(287, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(287, 14)" end="(287, 18)" leading="" trailing=" " raw_val="heqv" val="heqv"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(287, 19)" end="(287, 28)">
                                                            <TermTypespecNode start="(287, 19)" end="(287, 28)">
                                                            <AtomNode start="(287, 19)" end="(287, 20)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(287, 21)" end="(287, 28)" kind="«term_=_»">
                                                            <IdentNode start="(287, 21)" end="(287, 23)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            <AtomNode start="(287, 24)" end="(287, 25)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(287, 26)" end="(287, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                          </NullNode>
                                                          <AtomNode start="(287, 29)" end="(287, 31)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(287, 32)" end="(287, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(287, 32)" end="(287, 53)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(287, 54)" end="(287, 63)">
                                                            <IdentNode start="(287, 54)" end="(287, 58)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                                            <IdentNode start="(287, 59)" end="(287, 63)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(287, 63)" end="(287, 64)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(287, 65)" end="(287, 75)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;heqv : v₁ = v₂&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="subst heqv">
                                                      <AtomNode start="(287, 65)" end="(287, 70)" leading="" trailing=" " val="subst"/>
                                                      <NullNode start="(287, 71)" end="(287, 75)">
                                                        <IdentNode start="(287, 71)" end="(287, 75)" leading="" trailing="&#10;        " raw_val="heqv" val="heqv"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(288, 9)" end="(288, 54)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]">
                                                      <OtherNode start="(288, 9)" end="(288, 38)" kind="«tacticBy_cases_:_»">
                                                        <AtomNode start="(288, 9)" end="(288, 17)" leading="" trailing=" " val="by_cases"/>
                                                        <NullNode start="(288, 18)" end="(288, 24)">
                                                          <IdentNode start="(288, 18)" end="(288, 22)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                          <AtomNode start="(288, 23)" end="(288, 24)" leading="" trailing=" " val=":"/>
                                                        </NullNode>
                                                        <OtherNode start="(288, 25)" end="(288, 38)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(288, 25)" end="(288, 32)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          <NullNode start="(288, 33)" end="(288, 38)">
                                                            <IdentNode start="(288, 33)" end="(288, 35)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <IdentNode start="(288, 36)" end="(288, 38)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(288, 39)" end="(288, 42)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                      <OtherNode start="(288, 43)" end="(288, 54)" kind="Lean.Parser.Tactic.simp">
                                                        <AtomNode start="(288, 43)" end="(288, 47)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(288, 48)" end="(288, 54)">
                                                          <AtomNode start="(288, 48)" end="(288, 49)" leading="" trailing="" val="["/>
                                                          <NullNode start="(288, 49)" end="(288, 53)">
                                                            <OtherNode start="(288, 49)" end="(288, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(288, 49)" end="(288, 53)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(288, 53)" end="(288, 54)" leading="" trailing="&#10;        " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(289, 9)" end="(295, 19)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih&#10;  simp [denote_eq] at h |-&#10;  have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;  apply Eq.symm&#10;  apply Nat.sub_eq_of_eq_add&#10;  simp [h]">
                                                      <OtherNode start="(289, 9)" end="(289, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(289, 9)" end="(289, 10)" kind="patternIgnore">
                                                          <OtherNode start="(289, 9)" end="(289, 10)" kind="token.«· »">
                                                            <AtomNode start="(289, 9)" end="(289, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(289, 11)" end="(295, 19)">
                                                        <TacticTacticseq1IndentedNode start="(289, 11)" end="(295, 19)">
                                                          <NullNode start="(289, 11)" end="(295, 19)">
                                                            <OtherNode start="(289, 11)" end="(289, 19)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)" tactic="apply ih">
                                                            <AtomNode start="(289, 11)" end="(289, 16)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(289, 17)" end="(289, 19)" leading="" trailing="&#10;          " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(290, 11)" end="(290, 35)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" tactic="simp [denote_eq] at h |-">
                                                            <AtomNode start="(290, 11)" end="(290, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(290, 16)" end="(290, 27)">
                                                            <AtomNode start="(290, 16)" end="(290, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(290, 17)" end="(290, 26)">
                                                            <OtherNode start="(290, 17)" end="(290, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(290, 17)" end="(290, 26)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(290, 26)" end="(290, 27)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(290, 28)" end="(290, 35)">
                                                            <OtherNode start="(290, 28)" end="(290, 35)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(290, 28)" end="(290, 30)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(290, 31)" end="(290, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(290, 31)" end="(290, 35)">
                                                            <IdentNode start="(290, 31)" end="(290, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(290, 33)" end="(290, 35)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(290, 33)" end="(290, 35)" kind="patternIgnore">
                                                            <GroupNode start="(290, 33)" end="(290, 35)">
                                                            <AtomNode start="(290, 33)" end="(290, 34)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(290, 34)" end="(290, 35)" leading="" trailing="&#10;          " val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(291, 11)" end="(291, 132)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" tactic="have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))">
                                                            <AtomNode start="(291, 11)" end="(291, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(291, 16)" end="(291, 132)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(291, 16)" end="(291, 132)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(291, 16)" end="(291, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(291, 16)" end="(291, 20)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(291, 21)" end="(291, 70)">
                                                            <TermTypespecNode start="(291, 21)" end="(291, 70)">
                                                            <AtomNode start="(291, 21)" end="(291, 22)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(291, 23)" end="(291, 70)" kind="«term_≤_»">
                                                            <OtherNode start="(291, 23)" end="(291, 45)" kind="«term_*_»">
                                                            <IdentNode start="(291, 23)" end="(291, 25)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(291, 26)" end="(291, 27)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(291, 28)" end="(291, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(291, 28)" end="(291, 38)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(291, 39)" end="(291, 45)">
                                                            <IdentNode start="(291, 39)" end="(291, 42)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(291, 43)" end="(291, 45)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(291, 46)" end="(291, 47)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(291, 48)" end="(291, 70)" kind="«term_*_»">
                                                            <IdentNode start="(291, 48)" end="(291, 50)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(291, 51)" end="(291, 52)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(291, 53)" end="(291, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(291, 53)" end="(291, 63)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(291, 64)" end="(291, 70)">
                                                            <IdentNode start="(291, 64)" end="(291, 67)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(291, 68)" end="(291, 70)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(291, 71)" end="(291, 73)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(291, 74)" end="(291, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(291, 74)" end="(291, 94)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(291, 95)" end="(291, 132)">
                                                            <TermHoleNode start="(291, 95)" end="(291, 96)">
                                                            <AtomNode start="(291, 95)" end="(291, 96)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(291, 97)" end="(291, 132)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(291, 97)" end="(291, 98)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(291, 98)" end="(291, 131)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(291, 98)" end="(291, 110)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(291, 111)" end="(291, 131)">
                                                            <OtherNode start="(291, 111)" end="(291, 131)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(291, 111)" end="(291, 112)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(291, 112)" end="(291, 130)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(291, 112)" end="(291, 125)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(291, 126)" end="(291, 130)">
                                                            <IdentNode start="(291, 126)" end="(291, 130)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(291, 130)" end="(291, 131)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(291, 131)" end="(291, 132)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(292, 11)" end="(292, 84)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]">
                                                            <AtomNode start="(292, 11)" end="(292, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(292, 14)" end="(292, 84)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(292, 14)" end="(292, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(292, 15)" end="(292, 83)">
                                                            <OtherNode start="(292, 15)" end="(292, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(292, 15)" end="(292, 40)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(292, 40)" end="(292, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(292, 42)" end="(292, 57)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(292, 42)" end="(292, 43)">
                                                            <OtherNode start="(292, 42)" end="(292, 43)" kind="patternIgnore">
                                                            <OtherNode start="(292, 42)" end="(292, 43)" kind="token.«← »">
                                                            <AtomNode start="(292, 42)" end="(292, 43)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(292, 44)" end="(292, 57)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(292, 57)" end="(292, 58)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(292, 59)" end="(292, 83)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(292, 59)" end="(292, 60)">
                                                            <OtherNode start="(292, 59)" end="(292, 60)" kind="patternIgnore">
                                                            <OtherNode start="(292, 59)" end="(292, 60)" kind="token.«← »">
                                                            <AtomNode start="(292, 59)" end="(292, 60)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(292, 61)" end="(292, 83)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(292, 61)" end="(292, 78)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(292, 79)" end="(292, 83)">
                                                            <IdentNode start="(292, 79)" end="(292, 83)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(292, 83)" end="(292, 84)" leading="" trailing="&#10;          " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(293, 11)" end="(293, 24)" kind="Lean.Parser.Tactic.apply" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁" state_after="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁ = denote ctx r₁ + denote ctx m₁" tactic="apply Eq.symm">
                                                            <AtomNode start="(293, 11)" end="(293, 16)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(293, 17)" end="(293, 24)" leading="" trailing="&#10;          " raw_val="Eq.symm" val="Eq.symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(294, 11)" end="(294, 37)" kind="Lean.Parser.Tactic.apply" state_before="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁ = denote ctx r₁ + denote ctx m₁" state_after="case pos.h.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ = denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁" tactic="apply Nat.sub_eq_of_eq_add">
                                                            <AtomNode start="(294, 11)" end="(294, 16)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(294, 17)" end="(294, 37)" leading="" trailing="&#10;          " raw_val="Nat.sub_eq_of_eq_add" val="Nat.sub_eq_of_eq_add" full_name="Nat.sub_eq_of_eq_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(295, 11)" end="(295, 19)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ = denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁" state_after="no goals" tactic="simp [h]">
                                                            <AtomNode start="(295, 11)" end="(295, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(295, 16)" end="(295, 19)">
                                                            <AtomNode start="(295, 16)" end="(295, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(295, 17)" end="(295, 18)">
                                                            <OtherNode start="(295, 17)" end="(295, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(295, 17)" end="(295, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(295, 18)" end="(295, 19)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(296, 9)" end="(307, 41)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;  · apply ih&#10;    simp [denote_eq] at h |-&#10;    have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;    apply Nat.sub_eq_of_eq_add&#10;    simp [h]&#10;  · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;    apply ih&#10;    simp [denote_eq] at h |-&#10;    rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;    exact Nat.add_right_cancel h">
                                                      <OtherNode start="(296, 9)" end="(296, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(296, 9)" end="(296, 10)" kind="patternIgnore">
                                                          <OtherNode start="(296, 9)" end="(296, 10)" kind="token.«· »">
                                                            <AtomNode start="(296, 9)" end="(296, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(296, 11)" end="(307, 41)">
                                                        <TacticTacticseq1IndentedNode start="(296, 11)" end="(307, 41)">
                                                          <NullNode start="(296, 11)" end="(307, 41)">
                                                            <OtherNode start="(296, 11)" end="(296, 56)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]">
                                                            <OtherNode start="(296, 11)" end="(296, 40)" kind="«tacticBy_cases_:_»">
                                                            <AtomNode start="(296, 11)" end="(296, 19)" leading="" trailing=" " val="by_cases"/>
                                                            <NullNode start="(296, 20)" end="(296, 26)">
                                                            <IdentNode start="(296, 20)" end="(296, 24)" leading="" trailing=" " raw_val="hgtk" val="hgtk"/>
                                                            <AtomNode start="(296, 25)" end="(296, 26)" leading="" trailing=" " val=":"/>
                                                            </NullNode>
                                                            <OtherNode start="(296, 27)" end="(296, 40)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(296, 27)" end="(296, 34)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(296, 35)" end="(296, 40)">
                                                            <IdentNode start="(296, 35)" end="(296, 37)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <IdentNode start="(296, 38)" end="(296, 40)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(296, 41)" end="(296, 44)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                            <OtherNode start="(296, 45)" end="(296, 56)" kind="Lean.Parser.Tactic.simp">
                                                            <AtomNode start="(296, 45)" end="(296, 49)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(296, 50)" end="(296, 56)">
                                                            <AtomNode start="(296, 50)" end="(296, 51)" leading="" trailing="" val="["/>
                                                            <NullNode start="(296, 51)" end="(296, 55)">
                                                            <OtherNode start="(296, 51)" end="(296, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(296, 51)" end="(296, 55)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(296, 55)" end="(296, 56)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(297, 11)" end="(302, 21)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih&#10;  simp [denote_eq] at h |-&#10;  have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;  apply Nat.sub_eq_of_eq_add&#10;  simp [h]">
                                                            <OtherNode start="(297, 11)" end="(297, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(297, 11)" end="(297, 12)" kind="patternIgnore">
                                                            <OtherNode start="(297, 11)" end="(297, 12)" kind="token.«· »">
                                                            <AtomNode start="(297, 11)" end="(297, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(297, 13)" end="(302, 21)">
                                                            <TacticTacticseq1IndentedNode start="(297, 13)" end="(302, 21)">
                                                            <NullNode start="(297, 13)" end="(302, 21)">
                                                            <OtherNode start="(297, 13)" end="(297, 21)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_eq ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)" tactic="apply ih">
                                                            <AtomNode start="(297, 13)" end="(297, 18)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(297, 19)" end="(297, 21)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(298, 13)" end="(298, 37)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_eq ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂" tactic="simp [denote_eq] at h |-">
                                                            <AtomNode start="(298, 13)" end="(298, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(298, 18)" end="(298, 29)">
                                                            <AtomNode start="(298, 18)" end="(298, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(298, 19)" end="(298, 28)">
                                                            <OtherNode start="(298, 19)" end="(298, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(298, 19)" end="(298, 28)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(298, 28)" end="(298, 29)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(298, 30)" end="(298, 37)">
                                                            <OtherNode start="(298, 30)" end="(298, 37)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(298, 30)" end="(298, 32)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(298, 33)" end="(298, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(298, 33)" end="(298, 37)">
                                                            <IdentNode start="(298, 33)" end="(298, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(298, 35)" end="(298, 37)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(298, 35)" end="(298, 37)" kind="patternIgnore">
                                                            <GroupNode start="(298, 35)" end="(298, 37)">
                                                            <AtomNode start="(298, 35)" end="(298, 36)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(298, 36)" end="(298, 37)" leading="" trailing="&#10;            " val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(299, 13)" end="(299, 134)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂" tactic="have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))">
                                                            <AtomNode start="(299, 13)" end="(299, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(299, 18)" end="(299, 134)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(299, 18)" end="(299, 134)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(299, 18)" end="(299, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(299, 18)" end="(299, 22)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(299, 23)" end="(299, 72)">
                                                            <TermTypespecNode start="(299, 23)" end="(299, 72)">
                                                            <AtomNode start="(299, 23)" end="(299, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(299, 25)" end="(299, 72)" kind="«term_≤_»">
                                                            <OtherNode start="(299, 25)" end="(299, 47)" kind="«term_*_»">
                                                            <IdentNode start="(299, 25)" end="(299, 27)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(299, 28)" end="(299, 29)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(299, 30)" end="(299, 47)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(299, 30)" end="(299, 40)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(299, 41)" end="(299, 47)">
                                                            <IdentNode start="(299, 41)" end="(299, 44)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(299, 45)" end="(299, 47)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(299, 48)" end="(299, 49)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(299, 50)" end="(299, 72)" kind="«term_*_»">
                                                            <IdentNode start="(299, 50)" end="(299, 52)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(299, 53)" end="(299, 54)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(299, 55)" end="(299, 72)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(299, 55)" end="(299, 65)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(299, 66)" end="(299, 72)">
                                                            <IdentNode start="(299, 66)" end="(299, 69)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(299, 70)" end="(299, 72)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(299, 73)" end="(299, 75)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(299, 76)" end="(299, 134)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(299, 76)" end="(299, 96)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(299, 97)" end="(299, 134)">
                                                            <TermHoleNode start="(299, 97)" end="(299, 98)">
                                                            <AtomNode start="(299, 97)" end="(299, 98)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(299, 99)" end="(299, 134)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(299, 99)" end="(299, 100)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(299, 100)" end="(299, 133)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(299, 100)" end="(299, 112)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(299, 113)" end="(299, 133)">
                                                            <OtherNode start="(299, 113)" end="(299, 133)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(299, 113)" end="(299, 114)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(299, 114)" end="(299, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(299, 114)" end="(299, 127)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(299, 128)" end="(299, 132)">
                                                            <IdentNode start="(299, 128)" end="(299, 132)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(299, 132)" end="(299, 133)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(299, 133)" end="(299, 134)" leading="" trailing="&#10;            " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(300, 13)" end="(300, 86)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]">
                                                            <AtomNode start="(300, 13)" end="(300, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(300, 16)" end="(300, 86)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(300, 16)" end="(300, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(300, 17)" end="(300, 85)">
                                                            <OtherNode start="(300, 17)" end="(300, 42)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(300, 17)" end="(300, 42)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(300, 42)" end="(300, 43)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(300, 44)" end="(300, 59)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(300, 44)" end="(300, 45)">
                                                            <OtherNode start="(300, 44)" end="(300, 45)" kind="patternIgnore">
                                                            <OtherNode start="(300, 44)" end="(300, 45)" kind="token.«← »">
                                                            <AtomNode start="(300, 44)" end="(300, 45)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(300, 46)" end="(300, 59)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(300, 59)" end="(300, 60)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(300, 61)" end="(300, 85)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(300, 61)" end="(300, 62)">
                                                            <OtherNode start="(300, 61)" end="(300, 62)" kind="patternIgnore">
                                                            <OtherNode start="(300, 61)" end="(300, 62)" kind="token.«← »">
                                                            <AtomNode start="(300, 61)" end="(300, 62)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(300, 63)" end="(300, 85)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(300, 63)" end="(300, 80)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(300, 81)" end="(300, 85)">
                                                            <IdentNode start="(300, 81)" end="(300, 85)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(300, 85)" end="(300, 86)" leading="" trailing="&#10;            " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(301, 13)" end="(301, 39)" kind="Lean.Parser.Tactic.apply" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂" state_after="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁" tactic="apply Nat.sub_eq_of_eq_add">
                                                            <AtomNode start="(301, 13)" end="(301, 18)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(301, 19)" end="(301, 39)" leading="" trailing="&#10;            " raw_val="Nat.sub_eq_of_eq_add" val="Nat.sub_eq_of_eq_add" full_name="Nat.sub_eq_of_eq_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(302, 13)" end="(302, 21)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁" state_after="no goals" tactic="simp [h]">
                                                            <AtomNode start="(302, 13)" end="(302, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(302, 18)" end="(302, 21)">
                                                            <AtomNode start="(302, 18)" end="(302, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(302, 19)" end="(302, 20)">
                                                            <OtherNode start="(302, 19)" end="(302, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(302, 19)" end="(302, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(302, 20)" end="(302, 21)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(303, 11)" end="(307, 41)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;  apply ih&#10;  simp [denote_eq] at h |-&#10;  rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;  exact Nat.add_right_cancel h">
                                                            <OtherNode start="(303, 11)" end="(303, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(303, 11)" end="(303, 12)" kind="patternIgnore">
                                                            <OtherNode start="(303, 11)" end="(303, 12)" kind="token.«· »">
                                                            <AtomNode start="(303, 11)" end="(303, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(303, 13)" end="(307, 41)">
                                                            <TacticTacticseq1IndentedNode start="(303, 13)" end="(307, 41)">
                                                            <NullNode start="(303, 13)" end="(307, 41)">
                                                            <OtherNode start="(303, 13)" end="(303, 67)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;heqk : k₁ = k₂&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk">
                                                            <AtomNode start="(303, 13)" end="(303, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(303, 18)" end="(303, 67)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(303, 18)" end="(303, 67)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(303, 18)" end="(303, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(303, 18)" end="(303, 22)" leading="" trailing=" " raw_val="heqk" val="heqk"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(303, 23)" end="(303, 32)">
                                                            <TermTypespecNode start="(303, 23)" end="(303, 32)">
                                                            <AtomNode start="(303, 23)" end="(303, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(303, 25)" end="(303, 32)" kind="«term_=_»">
                                                            <IdentNode start="(303, 25)" end="(303, 27)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(303, 28)" end="(303, 29)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(303, 30)" end="(303, 32)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(303, 33)" end="(303, 35)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(303, 36)" end="(303, 67)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(303, 36)" end="(303, 57)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(303, 58)" end="(303, 67)">
                                                            <IdentNode start="(303, 58)" end="(303, 62)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                            <IdentNode start="(303, 63)" end="(303, 67)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(303, 67)" end="(303, 68)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(303, 69)" end="(303, 79)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;heqk : k₁ = k₂&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="subst heqk">
                                                            <AtomNode start="(303, 69)" end="(303, 74)" leading="" trailing=" " val="subst"/>
                                                            <NullNode start="(303, 75)" end="(303, 79)">
                                                            <IdentNode start="(303, 75)" end="(303, 79)" leading="" trailing="&#10;            " raw_val="heqk" val="heqk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(304, 13)" end="(304, 21)" kind="Lean.Parser.Tactic.apply" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" tactic="apply ih">
                                                            <AtomNode start="(304, 13)" end="(304, 18)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(304, 19)" end="(304, 21)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(305, 13)" end="(305, 37)" kind="Lean.Parser.Tactic.simp" state_before="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂" tactic="simp [denote_eq] at h |-">
                                                            <AtomNode start="(305, 13)" end="(305, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(305, 18)" end="(305, 29)">
                                                            <AtomNode start="(305, 18)" end="(305, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(305, 19)" end="(305, 28)">
                                                            <OtherNode start="(305, 19)" end="(305, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(305, 19)" end="(305, 28)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(305, 28)" end="(305, 29)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(305, 30)" end="(305, 37)">
                                                            <OtherNode start="(305, 30)" end="(305, 37)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(305, 30)" end="(305, 32)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(305, 33)" end="(305, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(305, 33)" end="(305, 37)">
                                                            <IdentNode start="(305, 33)" end="(305, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(305, 35)" end="(305, 37)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(305, 35)" end="(305, 37)" kind="patternIgnore">
                                                            <GroupNode start="(305, 35)" end="(305, 37)">
                                                            <AtomNode start="(305, 35)" end="(305, 36)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(305, 36)" end="(305, 37)" leading="" trailing="&#10;            " val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(306, 13)" end="(306, 55)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂" state_after="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂" tactic="rw [← Nat.add_assoc, ← Nat.add_assoc] at h">
                                                            <AtomNode start="(306, 13)" end="(306, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(306, 16)" end="(306, 50)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(306, 16)" end="(306, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(306, 17)" end="(306, 49)">
                                                            <OtherNode start="(306, 17)" end="(306, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(306, 17)" end="(306, 18)">
                                                            <OtherNode start="(306, 17)" end="(306, 18)" kind="patternIgnore">
                                                            <OtherNode start="(306, 17)" end="(306, 18)" kind="token.«← »">
                                                            <AtomNode start="(306, 17)" end="(306, 18)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(306, 19)" end="(306, 32)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(306, 32)" end="(306, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(306, 34)" end="(306, 49)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(306, 34)" end="(306, 35)">
                                                            <OtherNode start="(306, 34)" end="(306, 35)" kind="patternIgnore">
                                                            <OtherNode start="(306, 34)" end="(306, 35)" kind="token.«← »">
                                                            <AtomNode start="(306, 34)" end="(306, 35)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(306, 36)" end="(306, 49)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(306, 49)" end="(306, 50)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(306, 51)" end="(306, 55)">
                                                            <OtherNode start="(306, 51)" end="(306, 55)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(306, 51)" end="(306, 53)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(306, 54)" end="(306, 55)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(306, 54)" end="(306, 55)">
                                                            <IdentNode start="(306, 54)" end="(306, 55)" leading="" trailing="&#10;            " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(307, 13)" end="(307, 41)" kind="Lean.Parser.Tactic.exact" state_before="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂" state_after="no goals" tactic="exact Nat.add_right_cancel h">
                                                            <AtomNode start="(307, 13)" end="(307, 18)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(307, 19)" end="(307, 41)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(307, 19)" end="(307, 39)" leading="" trailing=" " raw_val="Nat.add_right_cancel" val="Nat.add_right_cancel" full_name="Nat.add_right_cancel" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(307, 40)" end="(307, 41)">
                                                            <IdentNode start="(307, 40)" end="(307, 41)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(309, 1)" end="(338, 52)" name="Poly.of_denote_eq_cancelAux" full_name="Nat.Linear.Poly.of_denote_eq_cancelAux">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(309, 1)" end="(338, 52)" name="Poly.of_denote_eq_cancelAux" full_name="Nat.Linear.Poly.of_denote_eq_cancelAux" _is_private_decl="False">
        <AtomNode start="(309, 1)" end="(309, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(309, 9)" end="(309, 36)">
          <IdentNode start="(309, 9)" end="(309, 36)" leading="" trailing=" " raw_val="Poly.of_denote_eq_cancelAux" val="Poly.of_denote_eq_cancelAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(309, 37)" end="(310, 106)">
          <NullNode start="(309, 37)" end="(310, 53)">
            <TermExplicitbinderNode start="(309, 37)" end="(309, 52)">
              <AtomNode start="(309, 37)" end="(309, 38)" leading="" trailing="" val="("/>
              <NullNode start="(309, 38)" end="(309, 41)">
                <IdentNode start="(309, 38)" end="(309, 41)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(309, 42)" end="(309, 51)">
                <AtomNode start="(309, 42)" end="(309, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(309, 44)" end="(309, 51)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(309, 51)" end="(309, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(309, 53)" end="(309, 65)">
              <AtomNode start="(309, 53)" end="(309, 54)" leading="" trailing="" val="("/>
              <NullNode start="(309, 54)" end="(309, 58)">
                <IdentNode start="(309, 54)" end="(309, 58)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
              </NullNode>
              <NullNode start="(309, 59)" end="(309, 64)">
                <AtomNode start="(309, 59)" end="(309, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(309, 61)" end="(309, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(309, 64)" end="(309, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(309, 66)" end="(309, 86)">
              <AtomNode start="(309, 66)" end="(309, 67)" leading="" trailing="" val="("/>
              <NullNode start="(309, 67)" end="(309, 78)">
                <IdentNode start="(309, 67)" end="(309, 69)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(309, 70)" end="(309, 72)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                <IdentNode start="(309, 73)" end="(309, 75)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                <IdentNode start="(309, 76)" end="(309, 78)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
              </NullNode>
              <NullNode start="(309, 79)" end="(309, 85)">
                <AtomNode start="(309, 79)" end="(309, 80)" leading="" trailing=" " val=":"/>
                <IdentNode start="(309, 81)" end="(309, 85)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(309, 85)" end="(309, 86)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(310, 5)" end="(310, 53)">
              <AtomNode start="(310, 5)" end="(310, 6)" leading="" trailing="" val="("/>
              <NullNode start="(310, 6)" end="(310, 7)">
                <IdentNode start="(310, 6)" end="(310, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(310, 8)" end="(310, 52)">
                <AtomNode start="(310, 8)" end="(310, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 10)" end="(310, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(310, 10)" end="(310, 19)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                  <NullNode start="(310, 20)" end="(310, 52)">
                    <IdentNode start="(310, 20)" end="(310, 23)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(310, 24)" end="(310, 52)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(310, 24)" end="(310, 25)" leading="" trailing="" val="("/>
                      <OtherNode start="(310, 25)" end="(310, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(310, 25)" end="(310, 34)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux" full_name="Nat.Linear.Poly.cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(71, 5)" def_end="(71, 19)"/>
                        <NullNode start="(310, 35)" end="(310, 51)">
                          <IdentNode start="(310, 35)" end="(310, 39)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                          <IdentNode start="(310, 40)" end="(310, 42)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                          <IdentNode start="(310, 43)" end="(310, 45)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                          <IdentNode start="(310, 46)" end="(310, 48)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                          <IdentNode start="(310, 49)" end="(310, 51)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(310, 51)" end="(310, 52)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(310, 52)" end="(310, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(310, 54)" end="(310, 106)">
            <AtomNode start="(310, 54)" end="(310, 55)" leading="" trailing=" " val=":"/>
            <OtherNode start="(310, 56)" end="(310, 106)" kind="Lean.Parser.Term.app">
              <IdentNode start="(310, 56)" end="(310, 65)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
              <NullNode start="(310, 66)" end="(310, 106)">
                <IdentNode start="(310, 66)" end="(310, 69)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(310, 70)" end="(310, 106)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(310, 70)" end="(310, 71)" leading="" trailing="" val="("/>
                  <NullNode start="(310, 71)" end="(310, 105)">
                    <OtherNode start="(310, 71)" end="(310, 87)" kind="«term_++_»">
                      <IdentNode start="(310, 71)" end="(310, 81)" leading="" trailing=" " raw_val="r₁.reverse" val="r₁.reverse"/>
                      <AtomNode start="(310, 82)" end="(310, 84)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(310, 85)" end="(310, 87)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                    </OtherNode>
                    <AtomNode start="(310, 87)" end="(310, 88)" leading="" trailing=" " val=","/>
                    <NullNode start="(310, 89)" end="(310, 105)">
                      <OtherNode start="(310, 89)" end="(310, 105)" kind="«term_++_»">
                        <IdentNode start="(310, 89)" end="(310, 99)" leading="" trailing=" " raw_val="r₂.reverse" val="r₂.reverse"/>
                        <AtomNode start="(310, 100)" end="(310, 102)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(310, 103)" end="(310, 105)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(310, 105)" end="(310, 106)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(310, 107)" end="(338, 52)">
          <AtomNode start="(310, 107)" end="(310, 109)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(310, 110)" end="(338, 52)">
            <AtomNode start="(310, 110)" end="(310, 112)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(311, 3)" end="(338, 52)">
              <TacticTacticseq1IndentedNode start="(311, 3)" end="(338, 52)">
                <NullNode start="(311, 3)" end="(338, 52)">
                  <OtherNode start="(311, 3)" end="(338, 52)" kind="Lean.Parser.Tactic.induction" state_before="ctx : Context&#10;fuel : Nat&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="induction fuel generalizing m₁ m₂ r₁ r₂ with&#10;| zero =&amp;gt; assumption&#10;| succ fuel ih =&amp;gt;&#10;  simp at h&#10;  split at h &amp;lt;;&amp;gt; (try simp; assumption)&#10;  rename_i k₁ v₁ m₁ k₂ v₂ m₂&#10;  by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv] at h&#10;  · have ih := ih (h := h); simp [denote_eq] at ih ⊢; assumption&#10;  · by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv] at h&#10;    · have ih := ih (h := h); simp [denote_eq] at ih ⊢; assumption&#10;    · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;      by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h&#10;      · have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;        have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;        have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih.symm&#10;        simp at ih&#10;        rw [ih]&#10;      · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;        · have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;          have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;          rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;          have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;          simp at ih&#10;          rw [ih]&#10;        · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;          have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;          rw [← Nat.add_assoc, ih, Nat.add_assoc]">
                    <AtomNode start="(311, 3)" end="(311, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(311, 13)" end="(311, 17)">
                      <OtherNode start="(311, 13)" end="(311, 17)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(311, 13)" end="(311, 17)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(311, 18)" end="(311, 42)">
                      <AtomNode start="(311, 18)" end="(311, 30)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(311, 31)" end="(311, 42)">
                        <IdentNode start="(311, 31)" end="(311, 33)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                        <IdentNode start="(311, 34)" end="(311, 36)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                        <IdentNode start="(311, 37)" end="(311, 39)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                        <IdentNode start="(311, 40)" end="(311, 42)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(311, 43)" end="(338, 52)">
                      <OtherNode start="(311, 43)" end="(338, 52)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(311, 43)" end="(311, 47)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(312, 3)" end="(338, 52)">
                          <OtherNode start="(312, 3)" end="(312, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(312, 3)" end="(312, 9)">
                              <OtherNode start="(312, 3)" end="(312, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(312, 3)" end="(312, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(312, 5)" end="(312, 9)">
                                  <NullNode/>
                                  <IdentNode start="(312, 5)" end="(312, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(312, 10)" end="(312, 23)">
                              <AtomNode start="(312, 10)" end="(312, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(312, 13)" end="(312, 23)">
                                <TacticTacticseq1IndentedNode start="(312, 13)" end="(312, 23)">
                                  <NullNode start="(312, 13)" end="(312, 23)">
                                    <OtherNode start="(312, 13)" end="(312, 23)" kind="Lean.Parser.Tactic.assumption" state_before="case zero&#10;ctx : Context&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (cancelAux 0 m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="assumption">
                                      <AtomNode start="(312, 13)" end="(312, 23)" leading="" trailing="&#10;  " val="assumption"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(313, 3)" end="(338, 52)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(313, 3)" end="(313, 17)">
                              <OtherNode start="(313, 3)" end="(313, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(313, 3)" end="(313, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(313, 5)" end="(313, 9)">
                                  <NullNode/>
                                  <IdentNode start="(313, 5)" end="(313, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(313, 10)" end="(313, 17)">
                                  <IdentNode start="(313, 10)" end="(313, 14)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                  <IdentNode start="(313, 15)" end="(313, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(313, 18)" end="(338, 52)">
                              <AtomNode start="(313, 18)" end="(313, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(314, 5)" end="(338, 52)">
                                <TacticTacticseq1IndentedNode start="(314, 5)" end="(338, 52)">
                                  <NullNode start="(314, 5)" end="(338, 52)">
                                    <OtherNode start="(314, 5)" end="(314, 14)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_eq ctx (cancelAux (fuel + 1) m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h :&#10;  denote_eq ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" tactic="simp at h">
                                      <AtomNode start="(314, 5)" end="(314, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(314, 10)" end="(314, 14)">
                                        <OtherNode start="(314, 10)" end="(314, 14)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(314, 10)" end="(314, 12)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(314, 13)" end="(314, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(314, 13)" end="(314, 14)">
                                              <IdentNode start="(314, 13)" end="(314, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(315, 5)" end="(315, 42)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h :&#10;  denote_eq ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)" tactic="split at h &amp;lt;;&amp;gt; (try simp; assumption)">
                                      <OtherNode start="(315, 5)" end="(315, 15)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(315, 5)" end="(315, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode start="(315, 11)" end="(315, 15)">
                                          <OtherNode start="(315, 11)" end="(315, 15)" kind="Lean.Parser.Tactic.location">
                                            <AtomNode start="(315, 11)" end="(315, 13)" leading="" trailing=" " val="at"/>
                                            <OtherNode start="(315, 14)" end="(315, 15)" kind="Lean.Parser.Tactic.locationHyp">
                                              <NullNode start="(315, 14)" end="(315, 15)">
                                                <IdentNode start="(315, 14)" end="(315, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(315, 16)" end="(315, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(315, 20)" end="(315, 42)" kind="Lean.Parser.Tactic.paren">
                                        <AtomNode start="(315, 20)" end="(315, 21)" leading="" trailing="" val="("/>
                                        <TacticTacticseqNode start="(315, 21)" end="(315, 41)">
                                          <TacticTacticseq1IndentedNode start="(315, 21)" end="(315, 41)">
                                            <NullNode start="(315, 21)" end="(315, 41)">
                                              <OtherNode start="(315, 21)" end="(315, 41)" kind="Lean.Parser.Tactic.tacticTry_" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)" state_after="no goals" tactic="try simp; assumption">
                                                <AtomNode start="(315, 21)" end="(315, 24)" leading="" trailing=" " val="try"/>
                                                <TacticTacticseqNode start="(315, 25)" end="(315, 41)">
                                                  <TacticTacticseq1IndentedNode start="(315, 25)" end="(315, 41)">
                                                    <NullNode start="(315, 25)" end="(315, 41)">
                                                      <OtherNode start="(315, 25)" end="(315, 29)" kind="Lean.Parser.Tactic.simp" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)" state_after="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" tactic="simp">
                                                        <AtomNode start="(315, 25)" end="(315, 29)" leading="" trailing="" val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(315, 29)" end="(315, 30)" leading="" trailing=" " val=";"/>
                                                      <OtherNode start="(315, 31)" end="(315, 41)" kind="Lean.Parser.Tactic.assumption" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="assumption">
                                                        <AtomNode start="(315, 31)" end="(315, 41)" leading="" trailing="" val="assumption"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                        <AtomNode start="(315, 41)" end="(315, 42)" leading="" trailing="&#10;    " val=")"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(316, 5)" end="(316, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="rename_i k₁ v₁ m₁ k₂ v₂ m₂">
                                      <AtomNode start="(316, 5)" end="(316, 13)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(316, 14)" end="(316, 31)">
                                        <LeanBinderidentNode start="(316, 14)" end="(316, 16)">
                                          <IdentNode start="(316, 14)" end="(316, 16)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(316, 17)" end="(316, 19)">
                                          <IdentNode start="(316, 17)" end="(316, 19)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(316, 20)" end="(316, 22)">
                                          <IdentNode start="(316, 20)" end="(316, 22)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(316, 23)" end="(316, 25)">
                                          <IdentNode start="(316, 23)" end="(316, 25)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(316, 26)" end="(316, 28)">
                                          <IdentNode start="(316, 26)" end="(316, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(316, 29)" end="(316, 31)">
                                          <IdentNode start="(316, 29)" end="(316, 31)" leading="" trailing="&#10;    " raw_val="m₂" val="m₂"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(317, 5)" end="(317, 55)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv] at h">
                                      <OtherNode start="(317, 5)" end="(317, 34)" kind="«tacticBy_cases_:_»">
                                        <AtomNode start="(317, 5)" end="(317, 13)" leading="" trailing=" " val="by_cases"/>
                                        <NullNode start="(317, 14)" end="(317, 20)">
                                          <IdentNode start="(317, 14)" end="(317, 18)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                          <AtomNode start="(317, 19)" end="(317, 20)" leading="" trailing=" " val=":"/>
                                        </NullNode>
                                        <OtherNode start="(317, 21)" end="(317, 34)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(317, 21)" end="(317, 28)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          <NullNode start="(317, 29)" end="(317, 34)">
                                            <IdentNode start="(317, 29)" end="(317, 31)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                            <IdentNode start="(317, 32)" end="(317, 34)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(317, 35)" end="(317, 38)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(317, 39)" end="(317, 55)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(317, 39)" end="(317, 43)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(317, 44)" end="(317, 50)">
                                          <AtomNode start="(317, 44)" end="(317, 45)" leading="" trailing="" val="["/>
                                          <NullNode start="(317, 45)" end="(317, 49)">
                                            <OtherNode start="(317, 45)" end="(317, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(317, 45)" end="(317, 49)" leading="" trailing="" raw_val="hltv" val="hltv"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(317, 49)" end="(317, 50)" leading="" trailing=" " val="]"/>
                                        </NullNode>
                                        <NullNode start="(317, 51)" end="(317, 55)">
                                          <OtherNode start="(317, 51)" end="(317, 55)" kind="Lean.Parser.Tactic.location">
                                            <AtomNode start="(317, 51)" end="(317, 53)" leading="" trailing=" " val="at"/>
                                            <OtherNode start="(317, 54)" end="(317, 55)" kind="Lean.Parser.Tactic.locationHyp">
                                              <NullNode start="(317, 54)" end="(317, 55)">
                                                <IdentNode start="(317, 54)" end="(317, 55)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(318, 5)" end="(318, 67)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_eq] at ih ⊢; assumption">
                                      <OtherNode start="(318, 5)" end="(318, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(318, 5)" end="(318, 6)" kind="patternIgnore">
                                          <OtherNode start="(318, 5)" end="(318, 6)" kind="token.«· »">
                                            <AtomNode start="(318, 5)" end="(318, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(318, 7)" end="(318, 67)">
                                        <TacticTacticseq1IndentedNode start="(318, 7)" end="(318, 67)">
                                          <NullNode start="(318, 7)" end="(318, 67)">
                                            <OtherNode start="(318, 7)" end="(318, 29)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote_eq ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="have ih := ih (h := h)">
                                              <AtomNode start="(318, 7)" end="(318, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(318, 12)" end="(318, 29)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(318, 12)" end="(318, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(318, 12)" end="(318, 14)" kind="Lean.Parser.Term.haveId">
                                                    <IdentNode start="(318, 12)" end="(318, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <AtomNode start="(318, 15)" end="(318, 17)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(318, 18)" end="(318, 29)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(318, 18)" end="(318, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                    <NullNode start="(318, 21)" end="(318, 29)">
                                                      <OtherNode start="(318, 21)" end="(318, 29)" kind="Lean.Parser.Term.namedArgument">
                                                        <AtomNode start="(318, 21)" end="(318, 22)" leading="" trailing="" val="("/>
                                                        <IdentNode start="(318, 22)" end="(318, 23)" leading="" trailing=" " raw_val="h" val="h"/>
                                                        <AtomNode start="(318, 24)" end="(318, 26)" leading="" trailing=" " val=":="/>
                                                        <IdentNode start="(318, 27)" end="(318, 28)" leading="" trailing="" raw_val="h" val="h"/>
                                                        <AtomNode start="(318, 28)" end="(318, 29)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(318, 29)" end="(318, 30)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(318, 31)" end="(318, 55)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote_eq ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_eq] at ih ⊢">
                                              <AtomNode start="(318, 31)" end="(318, 35)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(318, 36)" end="(318, 47)">
                                                <AtomNode start="(318, 36)" end="(318, 37)" leading="" trailing="" val="["/>
                                                <NullNode start="(318, 37)" end="(318, 46)">
                                                  <OtherNode start="(318, 37)" end="(318, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(318, 37)" end="(318, 46)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(318, 46)" end="(318, 47)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(318, 48)" end="(318, 55)">
                                                <OtherNode start="(318, 48)" end="(318, 55)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(318, 48)" end="(318, 50)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(318, 51)" end="(318, 55)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(318, 51)" end="(318, 55)">
                                                      <IdentNode start="(318, 51)" end="(318, 53)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <OtherNode start="(318, 54)" end="(318, 55)" kind="Lean.Parser.Tactic.locationType">
                                                        <OtherNode start="(318, 54)" end="(318, 55)" kind="patternIgnore">
                                                          <OtherNode start="(318, 54)" end="(318, 55)" kind="token.«⊢»">
                                                            <AtomNode start="(318, 54)" end="(318, 55)" leading="" trailing="" val="⊢"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(318, 55)" end="(318, 56)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(318, 57)" end="(318, 67)" kind="Lean.Parser.Tactic.assumption" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                              <AtomNode start="(318, 57)" end="(318, 67)" leading="" trailing="&#10;    " val="assumption"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(319, 5)" end="(338, 52)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="no goals" tactic="· by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv] at h&#10;  · have ih := ih (h := h); simp [denote_eq] at ih ⊢; assumption&#10;  · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;    by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h&#10;    · have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;      have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;      have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih.symm&#10;      simp at ih&#10;      rw [ih]&#10;    · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;      · have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;        have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;        have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;        simp at ih&#10;        rw [ih]&#10;      · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;        have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;        rw [← Nat.add_assoc, ih, Nat.add_assoc]">
                                      <OtherNode start="(319, 5)" end="(319, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(319, 5)" end="(319, 6)" kind="patternIgnore">
                                          <OtherNode start="(319, 5)" end="(319, 6)" kind="token.«· »">
                                            <AtomNode start="(319, 5)" end="(319, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(319, 7)" end="(338, 52)">
                                        <TacticTacticseq1IndentedNode start="(319, 7)" end="(338, 52)">
                                          <NullNode start="(319, 7)" end="(338, 52)">
                                            <OtherNode start="(319, 7)" end="(319, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv] at h">
                                              <OtherNode start="(319, 7)" end="(319, 36)" kind="«tacticBy_cases_:_»">
                                                <AtomNode start="(319, 7)" end="(319, 15)" leading="" trailing=" " val="by_cases"/>
                                                <NullNode start="(319, 16)" end="(319, 22)">
                                                  <IdentNode start="(319, 16)" end="(319, 20)" leading="" trailing=" " raw_val="hgtv" val="hgtv"/>
                                                  <AtomNode start="(319, 21)" end="(319, 22)" leading="" trailing=" " val=":"/>
                                                </NullNode>
                                                <OtherNode start="(319, 23)" end="(319, 36)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(319, 23)" end="(319, 30)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  <NullNode start="(319, 31)" end="(319, 36)">
                                                    <IdentNode start="(319, 31)" end="(319, 33)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                    <IdentNode start="(319, 34)" end="(319, 36)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(319, 37)" end="(319, 40)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(319, 41)" end="(319, 57)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(319, 41)" end="(319, 45)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(319, 46)" end="(319, 52)">
                                                  <AtomNode start="(319, 46)" end="(319, 47)" leading="" trailing="" val="["/>
                                                  <NullNode start="(319, 47)" end="(319, 51)">
                                                    <OtherNode start="(319, 47)" end="(319, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(319, 47)" end="(319, 51)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(319, 51)" end="(319, 52)" leading="" trailing=" " val="]"/>
                                                </NullNode>
                                                <NullNode start="(319, 53)" end="(319, 57)">
                                                  <OtherNode start="(319, 53)" end="(319, 57)" kind="Lean.Parser.Tactic.location">
                                                    <AtomNode start="(319, 53)" end="(319, 55)" leading="" trailing=" " val="at"/>
                                                    <OtherNode start="(319, 56)" end="(319, 57)" kind="Lean.Parser.Tactic.locationHyp">
                                                      <NullNode start="(319, 56)" end="(319, 57)">
                                                        <IdentNode start="(319, 56)" end="(319, 57)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(320, 7)" end="(320, 69)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_eq] at ih ⊢; assumption">
                                              <OtherNode start="(320, 7)" end="(320, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(320, 7)" end="(320, 8)" kind="patternIgnore">
                                                  <OtherNode start="(320, 7)" end="(320, 8)" kind="token.«· »">
                                                    <AtomNode start="(320, 7)" end="(320, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(320, 9)" end="(320, 69)">
                                                <TacticTacticseq1IndentedNode start="(320, 9)" end="(320, 69)">
                                                  <NullNode start="(320, 9)" end="(320, 69)">
                                                    <OtherNode start="(320, 9)" end="(320, 31)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="have ih := ih (h := h)">
                                                      <AtomNode start="(320, 9)" end="(320, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(320, 14)" end="(320, 31)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(320, 14)" end="(320, 31)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(320, 14)" end="(320, 16)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(320, 14)" end="(320, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <AtomNode start="(320, 17)" end="(320, 19)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(320, 20)" end="(320, 31)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(320, 20)" end="(320, 22)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(320, 23)" end="(320, 31)">
                                                            <OtherNode start="(320, 23)" end="(320, 31)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(320, 23)" end="(320, 24)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(320, 24)" end="(320, 25)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(320, 26)" end="(320, 28)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(320, 29)" end="(320, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(320, 30)" end="(320, 31)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(320, 31)" end="(320, 32)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(320, 33)" end="(320, 57)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_eq] at ih ⊢">
                                                      <AtomNode start="(320, 33)" end="(320, 37)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(320, 38)" end="(320, 49)">
                                                        <AtomNode start="(320, 38)" end="(320, 39)" leading="" trailing="" val="["/>
                                                        <NullNode start="(320, 39)" end="(320, 48)">
                                                          <OtherNode start="(320, 39)" end="(320, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(320, 39)" end="(320, 48)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(320, 48)" end="(320, 49)" leading="" trailing=" " val="]"/>
                                                      </NullNode>
                                                      <NullNode start="(320, 50)" end="(320, 57)">
                                                        <OtherNode start="(320, 50)" end="(320, 57)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(320, 50)" end="(320, 52)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(320, 53)" end="(320, 57)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(320, 53)" end="(320, 57)">
                                                            <IdentNode start="(320, 53)" end="(320, 55)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(320, 56)" end="(320, 57)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(320, 56)" end="(320, 57)" kind="patternIgnore">
                                                            <OtherNode start="(320, 56)" end="(320, 57)" kind="token.«⊢»">
                                                            <AtomNode start="(320, 56)" end="(320, 57)" leading="" trailing="" val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(320, 57)" end="(320, 58)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(320, 59)" end="(320, 69)" kind="Lean.Parser.Tactic.assumption" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                                      <AtomNode start="(320, 59)" end="(320, 69)" leading="" trailing="&#10;      " val="assumption"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(321, 7)" end="(338, 52)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="no goals" tactic="· have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;  by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h&#10;  · have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;    have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;    have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih.symm&#10;    simp at ih&#10;    rw [ih]&#10;  · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;    · have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;      have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;      have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;      simp at ih&#10;      rw [ih]&#10;    · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;      have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;      rw [← Nat.add_assoc, ih, Nat.add_assoc]">
                                              <OtherNode start="(321, 7)" end="(321, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(321, 7)" end="(321, 8)" kind="patternIgnore">
                                                  <OtherNode start="(321, 7)" end="(321, 8)" kind="token.«· »">
                                                    <AtomNode start="(321, 7)" end="(321, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(321, 9)" end="(338, 52)">
                                                <TacticTacticseq1IndentedNode start="(321, 9)" end="(338, 52)">
                                                  <NullNode start="(321, 9)" end="(338, 52)">
                                                    <OtherNode start="(321, 9)" end="(321, 63)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqv : v₁ = v₂&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv">
                                                      <AtomNode start="(321, 9)" end="(321, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(321, 14)" end="(321, 63)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(321, 14)" end="(321, 63)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(321, 14)" end="(321, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(321, 14)" end="(321, 18)" leading="" trailing=" " raw_val="heqv" val="heqv"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(321, 19)" end="(321, 28)">
                                                            <TermTypespecNode start="(321, 19)" end="(321, 28)">
                                                            <AtomNode start="(321, 19)" end="(321, 20)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(321, 21)" end="(321, 28)" kind="«term_=_»">
                                                            <IdentNode start="(321, 21)" end="(321, 23)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            <AtomNode start="(321, 24)" end="(321, 25)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(321, 26)" end="(321, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                          </NullNode>
                                                          <AtomNode start="(321, 29)" end="(321, 31)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(321, 32)" end="(321, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(321, 32)" end="(321, 53)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(321, 54)" end="(321, 63)">
                                                            <IdentNode start="(321, 54)" end="(321, 58)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                                            <IdentNode start="(321, 59)" end="(321, 63)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(321, 63)" end="(321, 64)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(321, 65)" end="(321, 75)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqv : v₁ = v₂&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="subst heqv">
                                                      <AtomNode start="(321, 65)" end="(321, 70)" leading="" trailing=" " val="subst"/>
                                                      <NullNode start="(321, 71)" end="(321, 75)">
                                                        <IdentNode start="(321, 71)" end="(321, 75)" leading="" trailing="&#10;        " raw_val="heqv" val="heqv"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(322, 9)" end="(322, 59)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_eq ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h">
                                                      <OtherNode start="(322, 9)" end="(322, 38)" kind="«tacticBy_cases_:_»">
                                                        <AtomNode start="(322, 9)" end="(322, 17)" leading="" trailing=" " val="by_cases"/>
                                                        <NullNode start="(322, 18)" end="(322, 24)">
                                                          <IdentNode start="(322, 18)" end="(322, 22)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                          <AtomNode start="(322, 23)" end="(322, 24)" leading="" trailing=" " val=":"/>
                                                        </NullNode>
                                                        <OtherNode start="(322, 25)" end="(322, 38)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(322, 25)" end="(322, 32)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          <NullNode start="(322, 33)" end="(322, 38)">
                                                            <IdentNode start="(322, 33)" end="(322, 35)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <IdentNode start="(322, 36)" end="(322, 38)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(322, 39)" end="(322, 42)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                      <OtherNode start="(322, 43)" end="(322, 59)" kind="Lean.Parser.Tactic.simp">
                                                        <AtomNode start="(322, 43)" end="(322, 47)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(322, 48)" end="(322, 54)">
                                                          <AtomNode start="(322, 48)" end="(322, 49)" leading="" trailing="" val="["/>
                                                          <NullNode start="(322, 49)" end="(322, 53)">
                                                            <OtherNode start="(322, 49)" end="(322, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(322, 49)" end="(322, 53)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(322, 53)" end="(322, 54)" leading="" trailing=" " val="]"/>
                                                        </NullNode>
                                                        <NullNode start="(322, 55)" end="(322, 59)">
                                                          <OtherNode start="(322, 55)" end="(322, 59)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(322, 55)" end="(322, 57)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(322, 58)" end="(322, 59)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(322, 58)" end="(322, 59)">
                                                            <IdentNode start="(322, 58)" end="(322, 59)" leading="" trailing="&#10;        " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(323, 9)" end="(328, 18)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;  have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;  have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih.symm&#10;  simp at ih&#10;  rw [ih]">
                                                      <OtherNode start="(323, 9)" end="(323, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(323, 9)" end="(323, 10)" kind="patternIgnore">
                                                          <OtherNode start="(323, 9)" end="(323, 10)" kind="token.«· »">
                                                            <AtomNode start="(323, 9)" end="(323, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(323, 11)" end="(328, 18)">
                                                        <TacticTacticseq1IndentedNode start="(323, 11)" end="(328, 18)">
                                                          <NullNode start="(323, 11)" end="(328, 18)">
                                                            <OtherNode start="(323, 11)" end="(323, 33)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote_eq ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="have ih := ih (h := h)">
                                                            <AtomNode start="(323, 11)" end="(323, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(323, 16)" end="(323, 33)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(323, 16)" end="(323, 33)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(323, 16)" end="(323, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(323, 16)" end="(323, 18)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(323, 19)" end="(323, 21)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(323, 22)" end="(323, 33)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(323, 22)" end="(323, 24)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(323, 25)" end="(323, 33)">
                                                            <OtherNode start="(323, 25)" end="(323, 33)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(323, 25)" end="(323, 26)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(323, 26)" end="(323, 27)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(323, 28)" end="(323, 30)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(323, 31)" end="(323, 32)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(323, 32)" end="(323, 33)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(323, 33)" end="(323, 34)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(323, 35)" end="(323, 59)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote_eq ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp [denote_eq] at ih ⊢">
                                                            <AtomNode start="(323, 35)" end="(323, 39)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(323, 40)" end="(323, 51)">
                                                            <AtomNode start="(323, 40)" end="(323, 41)" leading="" trailing="" val="["/>
                                                            <NullNode start="(323, 41)" end="(323, 50)">
                                                            <OtherNode start="(323, 41)" end="(323, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(323, 41)" end="(323, 50)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(323, 50)" end="(323, 51)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(323, 52)" end="(323, 59)">
                                                            <OtherNode start="(323, 52)" end="(323, 59)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(323, 52)" end="(323, 54)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(323, 55)" end="(323, 59)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(323, 55)" end="(323, 59)">
                                                            <IdentNode start="(323, 55)" end="(323, 57)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(323, 58)" end="(323, 59)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(323, 58)" end="(323, 59)" kind="patternIgnore">
                                                            <OtherNode start="(323, 58)" end="(323, 59)" kind="token.«⊢»">
                                                            <AtomNode start="(323, 58)" end="(323, 59)" leading="" trailing="&#10;          " val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(324, 11)" end="(324, 132)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))">
                                                            <AtomNode start="(324, 11)" end="(324, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(324, 16)" end="(324, 132)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(324, 16)" end="(324, 132)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(324, 16)" end="(324, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(324, 16)" end="(324, 20)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(324, 21)" end="(324, 70)">
                                                            <TermTypespecNode start="(324, 21)" end="(324, 70)">
                                                            <AtomNode start="(324, 21)" end="(324, 22)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(324, 23)" end="(324, 70)" kind="«term_≤_»">
                                                            <OtherNode start="(324, 23)" end="(324, 45)" kind="«term_*_»">
                                                            <IdentNode start="(324, 23)" end="(324, 25)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(324, 26)" end="(324, 27)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(324, 28)" end="(324, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(324, 28)" end="(324, 38)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(324, 39)" end="(324, 45)">
                                                            <IdentNode start="(324, 39)" end="(324, 42)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(324, 43)" end="(324, 45)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(324, 46)" end="(324, 47)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(324, 48)" end="(324, 70)" kind="«term_*_»">
                                                            <IdentNode start="(324, 48)" end="(324, 50)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(324, 51)" end="(324, 52)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(324, 53)" end="(324, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(324, 53)" end="(324, 63)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(324, 64)" end="(324, 70)">
                                                            <IdentNode start="(324, 64)" end="(324, 67)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(324, 68)" end="(324, 70)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(324, 71)" end="(324, 73)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(324, 74)" end="(324, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(324, 74)" end="(324, 94)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(324, 95)" end="(324, 132)">
                                                            <TermHoleNode start="(324, 95)" end="(324, 96)">
                                                            <AtomNode start="(324, 95)" end="(324, 96)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(324, 97)" end="(324, 132)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(324, 97)" end="(324, 98)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(324, 98)" end="(324, 131)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(324, 98)" end="(324, 110)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(324, 111)" end="(324, 131)">
                                                            <OtherNode start="(324, 111)" end="(324, 131)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(324, 111)" end="(324, 112)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(324, 112)" end="(324, 130)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(324, 112)" end="(324, 125)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(324, 126)" end="(324, 130)">
                                                            <IdentNode start="(324, 126)" end="(324, 130)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(324, 130)" end="(324, 131)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(324, 131)" end="(324, 132)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(325, 11)" end="(325, 90)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih">
                                                            <AtomNode start="(325, 11)" end="(325, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(325, 14)" end="(325, 84)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(325, 14)" end="(325, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(325, 15)" end="(325, 83)">
                                                            <OtherNode start="(325, 15)" end="(325, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(325, 15)" end="(325, 40)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(325, 40)" end="(325, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(325, 42)" end="(325, 57)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(325, 42)" end="(325, 43)">
                                                            <OtherNode start="(325, 42)" end="(325, 43)" kind="patternIgnore">
                                                            <OtherNode start="(325, 42)" end="(325, 43)" kind="token.«← »">
                                                            <AtomNode start="(325, 42)" end="(325, 43)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(325, 44)" end="(325, 57)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(325, 57)" end="(325, 58)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(325, 59)" end="(325, 83)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(325, 59)" end="(325, 60)">
                                                            <OtherNode start="(325, 59)" end="(325, 60)" kind="patternIgnore">
                                                            <OtherNode start="(325, 59)" end="(325, 60)" kind="token.«← »">
                                                            <AtomNode start="(325, 59)" end="(325, 60)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(325, 61)" end="(325, 83)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(325, 61)" end="(325, 78)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(325, 79)" end="(325, 83)">
                                                            <IdentNode start="(325, 79)" end="(325, 83)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(325, 83)" end="(325, 84)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(325, 85)" end="(325, 90)">
                                                            <OtherNode start="(325, 85)" end="(325, 90)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(325, 85)" end="(325, 87)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(325, 88)" end="(325, 90)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(325, 88)" end="(325, 90)">
                                                            <IdentNode start="(325, 88)" end="(325, 90)" leading="" trailing="&#10;          " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(326, 11)" end="(326, 91)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih✝ : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;ih : denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ = denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih.symm">
                                                            <AtomNode start="(326, 11)" end="(326, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(326, 16)" end="(326, 91)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(326, 16)" end="(326, 91)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(326, 16)" end="(326, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(326, 16)" end="(326, 18)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(326, 19)" end="(326, 21)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(326, 22)" end="(326, 91)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(326, 22)" end="(326, 42)" leading="" trailing=" " raw_val="Nat.eq_add_of_sub_eq" val="Nat.eq_add_of_sub_eq" full_name="Nat.eq_add_of_sub_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(326, 43)" end="(326, 91)">
                                                            <OtherNode start="(326, 43)" end="(326, 83)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(326, 43)" end="(326, 44)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(326, 44)" end="(326, 82)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(326, 44)" end="(326, 56)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            <NullNode start="(326, 57)" end="(326, 82)">
                                                            <IdentNode start="(326, 57)" end="(326, 61)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            <OtherNode start="(326, 62)" end="(326, 82)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(326, 62)" end="(326, 63)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(326, 63)" end="(326, 81)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(326, 63)" end="(326, 78)" leading="" trailing=" " raw_val="Nat.le_add_left" val="Nat.le_add_left" full_name="Nat.le_add_left" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(326, 79)" end="(326, 81)">
                                                            <OtherNode start="(326, 79)" end="(326, 81)" kind="Lean.Parser.Term.ellipsis">
                                                            <AtomNode start="(326, 79)" end="(326, 81)" leading="" trailing="" val=".."/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(326, 81)" end="(326, 82)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(326, 82)" end="(326, 83)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(326, 84)" end="(326, 91)" leading="" trailing="&#10;          " raw_val="ih.symm" val="ih.symm"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(327, 11)" end="(327, 21)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih✝ : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;ih : denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ = denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih✝ : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;ih : denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁) = denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp at ih">
                                                            <AtomNode start="(327, 11)" end="(327, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(327, 16)" end="(327, 21)">
                                                            <OtherNode start="(327, 16)" end="(327, 21)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(327, 16)" end="(327, 18)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(327, 19)" end="(327, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(327, 19)" end="(327, 21)">
                                                            <IdentNode start="(327, 19)" end="(327, 21)" leading="" trailing="&#10;          " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(328, 11)" end="(328, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih✝ : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;ih : denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁) = denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="no goals" tactic="rw [ih]">
                                                            <AtomNode start="(328, 11)" end="(328, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(328, 14)" end="(328, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(328, 14)" end="(328, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(328, 15)" end="(328, 17)">
                                                            <OtherNode start="(328, 15)" end="(328, 17)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(328, 15)" end="(328, 17)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(328, 17)" end="(328, 18)" leading="" trailing="&#10;        " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(329, 9)" end="(338, 52)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="no goals" tactic="· by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;  · have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;    have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;    have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;    simp at ih&#10;    rw [ih]&#10;  · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;    have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;    rw [← Nat.add_assoc, ih, Nat.add_assoc]">
                                                      <OtherNode start="(329, 9)" end="(329, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(329, 9)" end="(329, 10)" kind="patternIgnore">
                                                          <OtherNode start="(329, 9)" end="(329, 10)" kind="token.«· »">
                                                            <AtomNode start="(329, 9)" end="(329, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(329, 11)" end="(338, 52)">
                                                        <TacticTacticseq1IndentedNode start="(329, 11)" end="(338, 52)">
                                                          <NullNode start="(329, 11)" end="(338, 52)">
                                                            <OtherNode start="(329, 11)" end="(329, 61)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_eq ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h">
                                                            <OtherNode start="(329, 11)" end="(329, 40)" kind="«tacticBy_cases_:_»">
                                                            <AtomNode start="(329, 11)" end="(329, 19)" leading="" trailing=" " val="by_cases"/>
                                                            <NullNode start="(329, 20)" end="(329, 26)">
                                                            <IdentNode start="(329, 20)" end="(329, 24)" leading="" trailing=" " raw_val="hgtk" val="hgtk"/>
                                                            <AtomNode start="(329, 25)" end="(329, 26)" leading="" trailing=" " val=":"/>
                                                            </NullNode>
                                                            <OtherNode start="(329, 27)" end="(329, 40)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(329, 27)" end="(329, 34)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(329, 35)" end="(329, 40)">
                                                            <IdentNode start="(329, 35)" end="(329, 37)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <IdentNode start="(329, 38)" end="(329, 40)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(329, 41)" end="(329, 44)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                            <OtherNode start="(329, 45)" end="(329, 61)" kind="Lean.Parser.Tactic.simp">
                                                            <AtomNode start="(329, 45)" end="(329, 49)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(329, 50)" end="(329, 56)">
                                                            <AtomNode start="(329, 50)" end="(329, 51)" leading="" trailing="" val="["/>
                                                            <NullNode start="(329, 51)" end="(329, 55)">
                                                            <OtherNode start="(329, 51)" end="(329, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(329, 51)" end="(329, 55)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(329, 55)" end="(329, 56)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(329, 57)" end="(329, 61)">
                                                            <OtherNode start="(329, 57)" end="(329, 61)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(329, 57)" end="(329, 59)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(329, 60)" end="(329, 61)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(329, 60)" end="(329, 61)">
                                                            <IdentNode start="(329, 60)" end="(329, 61)" leading="" trailing="&#10;          " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(330, 11)" end="(335, 20)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;  have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;  have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;  simp at ih&#10;  rw [ih]">
                                                            <OtherNode start="(330, 11)" end="(330, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(330, 11)" end="(330, 12)" kind="patternIgnore">
                                                            <OtherNode start="(330, 11)" end="(330, 12)" kind="token.«· »">
                                                            <AtomNode start="(330, 11)" end="(330, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(330, 13)" end="(335, 20)">
                                                            <TacticTacticseq1IndentedNode start="(330, 13)" end="(335, 20)">
                                                            <NullNode start="(330, 13)" end="(335, 20)">
                                                            <OtherNode start="(330, 13)" end="(330, 35)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote_eq ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="have ih := ih (h := h)">
                                                            <AtomNode start="(330, 13)" end="(330, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(330, 18)" end="(330, 35)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(330, 18)" end="(330, 35)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(330, 18)" end="(330, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(330, 18)" end="(330, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(330, 21)" end="(330, 23)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(330, 24)" end="(330, 35)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(330, 24)" end="(330, 26)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(330, 27)" end="(330, 35)">
                                                            <OtherNode start="(330, 27)" end="(330, 35)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(330, 27)" end="(330, 28)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(330, 28)" end="(330, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(330, 30)" end="(330, 32)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(330, 33)" end="(330, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(330, 34)" end="(330, 35)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(330, 35)" end="(330, 36)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(330, 37)" end="(330, 61)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote_eq ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp [denote_eq] at ih ⊢">
                                                            <AtomNode start="(330, 37)" end="(330, 41)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(330, 42)" end="(330, 53)">
                                                            <AtomNode start="(330, 42)" end="(330, 43)" leading="" trailing="" val="["/>
                                                            <NullNode start="(330, 43)" end="(330, 52)">
                                                            <OtherNode start="(330, 43)" end="(330, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(330, 43)" end="(330, 52)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(330, 52)" end="(330, 53)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(330, 54)" end="(330, 61)">
                                                            <OtherNode start="(330, 54)" end="(330, 61)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(330, 54)" end="(330, 56)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(330, 57)" end="(330, 61)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(330, 57)" end="(330, 61)">
                                                            <IdentNode start="(330, 57)" end="(330, 59)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(330, 60)" end="(330, 61)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(330, 60)" end="(330, 61)" kind="patternIgnore">
                                                            <OtherNode start="(330, 60)" end="(330, 61)" kind="token.«⊢»">
                                                            <AtomNode start="(330, 60)" end="(330, 61)" leading="" trailing="&#10;            " val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(331, 13)" end="(331, 134)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))">
                                                            <AtomNode start="(331, 13)" end="(331, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(331, 18)" end="(331, 134)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(331, 18)" end="(331, 134)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(331, 18)" end="(331, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(331, 18)" end="(331, 22)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(331, 23)" end="(331, 72)">
                                                            <TermTypespecNode start="(331, 23)" end="(331, 72)">
                                                            <AtomNode start="(331, 23)" end="(331, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(331, 25)" end="(331, 72)" kind="«term_≤_»">
                                                            <OtherNode start="(331, 25)" end="(331, 47)" kind="«term_*_»">
                                                            <IdentNode start="(331, 25)" end="(331, 27)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(331, 28)" end="(331, 29)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(331, 30)" end="(331, 47)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(331, 30)" end="(331, 40)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(331, 41)" end="(331, 47)">
                                                            <IdentNode start="(331, 41)" end="(331, 44)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(331, 45)" end="(331, 47)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(331, 48)" end="(331, 49)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(331, 50)" end="(331, 72)" kind="«term_*_»">
                                                            <IdentNode start="(331, 50)" end="(331, 52)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(331, 53)" end="(331, 54)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(331, 55)" end="(331, 72)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(331, 55)" end="(331, 65)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(331, 66)" end="(331, 72)">
                                                            <IdentNode start="(331, 66)" end="(331, 69)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(331, 70)" end="(331, 72)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(331, 73)" end="(331, 75)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(331, 76)" end="(331, 134)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(331, 76)" end="(331, 96)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(331, 97)" end="(331, 134)">
                                                            <TermHoleNode start="(331, 97)" end="(331, 98)">
                                                            <AtomNode start="(331, 97)" end="(331, 98)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(331, 99)" end="(331, 134)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(331, 99)" end="(331, 100)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(331, 100)" end="(331, 133)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(331, 100)" end="(331, 112)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(331, 113)" end="(331, 133)">
                                                            <OtherNode start="(331, 113)" end="(331, 133)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(331, 113)" end="(331, 114)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(331, 114)" end="(331, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(331, 114)" end="(331, 127)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(331, 128)" end="(331, 132)">
                                                            <IdentNode start="(331, 128)" end="(331, 132)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(331, 132)" end="(331, 133)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(331, 133)" end="(331, 134)" leading="" trailing="&#10;            " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(332, 13)" end="(332, 92)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih">
                                                            <AtomNode start="(332, 13)" end="(332, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(332, 16)" end="(332, 86)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(332, 16)" end="(332, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(332, 17)" end="(332, 85)">
                                                            <OtherNode start="(332, 17)" end="(332, 42)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(332, 17)" end="(332, 42)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(332, 42)" end="(332, 43)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(332, 44)" end="(332, 59)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(332, 44)" end="(332, 45)">
                                                            <OtherNode start="(332, 44)" end="(332, 45)" kind="patternIgnore">
                                                            <OtherNode start="(332, 44)" end="(332, 45)" kind="token.«← »">
                                                            <AtomNode start="(332, 44)" end="(332, 45)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(332, 46)" end="(332, 59)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(332, 59)" end="(332, 60)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(332, 61)" end="(332, 85)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(332, 61)" end="(332, 62)">
                                                            <OtherNode start="(332, 61)" end="(332, 62)" kind="patternIgnore">
                                                            <OtherNode start="(332, 61)" end="(332, 62)" kind="token.«← »">
                                                            <AtomNode start="(332, 61)" end="(332, 62)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(332, 63)" end="(332, 85)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(332, 63)" end="(332, 80)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(332, 81)" end="(332, 85)">
                                                            <IdentNode start="(332, 81)" end="(332, 85)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(332, 85)" end="(332, 86)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(332, 87)" end="(332, 92)">
                                                            <OtherNode start="(332, 87)" end="(332, 92)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(332, 87)" end="(332, 89)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(332, 90)" end="(332, 92)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(332, 90)" end="(332, 92)">
                                                            <IdentNode start="(332, 90)" end="(332, 92)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(333, 13)" end="(333, 88)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih✝ : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have ih := Nat.eq_add_of_sub_eq (Nat.le_trans haux (Nat.le_add_left ..)) ih">
                                                            <AtomNode start="(333, 13)" end="(333, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(333, 18)" end="(333, 88)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(333, 18)" end="(333, 88)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(333, 18)" end="(333, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(333, 18)" end="(333, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(333, 21)" end="(333, 23)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(333, 24)" end="(333, 88)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(333, 24)" end="(333, 44)" leading="" trailing=" " raw_val="Nat.eq_add_of_sub_eq" val="Nat.eq_add_of_sub_eq" full_name="Nat.eq_add_of_sub_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(333, 45)" end="(333, 88)">
                                                            <OtherNode start="(333, 45)" end="(333, 85)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(333, 45)" end="(333, 46)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(333, 46)" end="(333, 84)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(333, 46)" end="(333, 58)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            <NullNode start="(333, 59)" end="(333, 84)">
                                                            <IdentNode start="(333, 59)" end="(333, 63)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            <OtherNode start="(333, 64)" end="(333, 84)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(333, 64)" end="(333, 65)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(333, 65)" end="(333, 83)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(333, 65)" end="(333, 80)" leading="" trailing=" " raw_val="Nat.le_add_left" val="Nat.le_add_left" full_name="Nat.le_add_left" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(333, 81)" end="(333, 83)">
                                                            <OtherNode start="(333, 81)" end="(333, 83)" kind="Lean.Parser.Term.ellipsis">
                                                            <AtomNode start="(333, 81)" end="(333, 83)" leading="" trailing="" val=".."/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(333, 83)" end="(333, 84)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(333, 84)" end="(333, 85)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(333, 86)" end="(333, 88)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(334, 13)" end="(334, 23)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih✝ : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih✝ : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp at ih">
                                                            <AtomNode start="(334, 13)" end="(334, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(334, 18)" end="(334, 23)">
                                                            <OtherNode start="(334, 18)" end="(334, 23)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(334, 18)" end="(334, 20)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(334, 21)" end="(334, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(334, 21)" end="(334, 23)">
                                                            <IdentNode start="(334, 21)" end="(334, 23)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(335, 13)" end="(335, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝¹ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih✝ : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ = denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="no goals" tactic="rw [ih]">
                                                            <AtomNode start="(335, 13)" end="(335, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(335, 16)" end="(335, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(335, 16)" end="(335, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(335, 17)" end="(335, 19)">
                                                            <OtherNode start="(335, 17)" end="(335, 19)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(335, 17)" end="(335, 19)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(335, 19)" end="(335, 20)" leading="" trailing="&#10;          " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(336, 11)" end="(338, 52)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="no goals" tactic="· have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;  have ih := ih (h := h); simp [denote_eq] at ih ⊢&#10;  rw [← Nat.add_assoc, ih, Nat.add_assoc]">
                                                            <OtherNode start="(336, 11)" end="(336, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(336, 11)" end="(336, 12)" kind="patternIgnore">
                                                            <OtherNode start="(336, 11)" end="(336, 12)" kind="token.«· »">
                                                            <AtomNode start="(336, 11)" end="(336, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(336, 13)" end="(338, 52)">
                                                            <TacticTacticseq1IndentedNode start="(336, 13)" end="(338, 52)">
                                                            <NullNode start="(336, 13)" end="(338, 52)">
                                                            <OtherNode start="(336, 13)" end="(336, 67)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqk : k₁ = k₂&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk">
                                                            <AtomNode start="(336, 13)" end="(336, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(336, 18)" end="(336, 67)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(336, 18)" end="(336, 67)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(336, 18)" end="(336, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(336, 18)" end="(336, 22)" leading="" trailing=" " raw_val="heqk" val="heqk"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(336, 23)" end="(336, 32)">
                                                            <TermTypespecNode start="(336, 23)" end="(336, 32)">
                                                            <AtomNode start="(336, 23)" end="(336, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(336, 25)" end="(336, 32)" kind="«term_=_»">
                                                            <IdentNode start="(336, 25)" end="(336, 27)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(336, 28)" end="(336, 29)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(336, 30)" end="(336, 32)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(336, 33)" end="(336, 35)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(336, 36)" end="(336, 67)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(336, 36)" end="(336, 57)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(336, 58)" end="(336, 67)">
                                                            <IdentNode start="(336, 58)" end="(336, 62)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                            <IdentNode start="(336, 63)" end="(336, 67)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(336, 67)" end="(336, 68)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(336, 69)" end="(336, 79)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqk : k₁ = k₂&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" tactic="subst heqk">
                                                            <AtomNode start="(336, 69)" end="(336, 74)" leading="" trailing=" " val="subst"/>
                                                            <NullNode start="(336, 75)" end="(336, 79)">
                                                            <IdentNode start="(336, 75)" end="(336, 79)" leading="" trailing="&#10;            " raw_val="heqk" val="heqk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(337, 13)" end="(337, 35)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" tactic="have ih := ih (h := h)">
                                                            <AtomNode start="(337, 13)" end="(337, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(337, 18)" end="(337, 35)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(337, 18)" end="(337, 35)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(337, 18)" end="(337, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(337, 18)" end="(337, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(337, 21)" end="(337, 23)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(337, 24)" end="(337, 35)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(337, 24)" end="(337, 26)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(337, 27)" end="(337, 35)">
                                                            <OtherNode start="(337, 27)" end="(337, 35)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(337, 27)" end="(337, 28)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(337, 28)" end="(337, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(337, 30)" end="(337, 32)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(337, 33)" end="(337, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(337, 34)" end="(337, 35)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(337, 35)" end="(337, 36)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(337, 37)" end="(337, 61)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_eq ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" tactic="simp [denote_eq] at ih ⊢">
                                                            <AtomNode start="(337, 37)" end="(337, 41)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(337, 42)" end="(337, 53)">
                                                            <AtomNode start="(337, 42)" end="(337, 43)" leading="" trailing="" val="["/>
                                                            <NullNode start="(337, 43)" end="(337, 52)">
                                                            <OtherNode start="(337, 43)" end="(337, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(337, 43)" end="(337, 52)" leading="" trailing="" raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(337, 52)" end="(337, 53)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(337, 54)" end="(337, 61)">
                                                            <OtherNode start="(337, 54)" end="(337, 61)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(337, 54)" end="(337, 56)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(337, 57)" end="(337, 61)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(337, 57)" end="(337, 61)">
                                                            <IdentNode start="(337, 57)" end="(337, 59)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(337, 60)" end="(337, 61)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(337, 60)" end="(337, 61)" kind="patternIgnore">
                                                            <OtherNode start="(337, 60)" end="(337, 61)" kind="token.«⊢»">
                                                            <AtomNode start="(337, 60)" end="(337, 61)" leading="" trailing="&#10;            " val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(338, 13)" end="(338, 52)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_eq ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ = denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) = denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" state_after="no goals" tactic="rw [← Nat.add_assoc, ih, Nat.add_assoc]">
                                                            <AtomNode start="(338, 13)" end="(338, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(338, 16)" end="(338, 52)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(338, 16)" end="(338, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(338, 17)" end="(338, 51)">
                                                            <OtherNode start="(338, 17)" end="(338, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(338, 17)" end="(338, 18)">
                                                            <OtherNode start="(338, 17)" end="(338, 18)" kind="patternIgnore">
                                                            <OtherNode start="(338, 17)" end="(338, 18)" kind="token.«← »">
                                                            <AtomNode start="(338, 17)" end="(338, 18)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(338, 19)" end="(338, 32)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(338, 32)" end="(338, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(338, 34)" end="(338, 36)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(338, 34)" end="(338, 36)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(338, 36)" end="(338, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(338, 38)" end="(338, 51)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(338, 38)" end="(338, 51)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(338, 51)" end="(338, 52)" leading="" trailing="&#10;&#10;" val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(340, 1)" end="(341, 38)" name="Poly.denote_eq_cancel" full_name="Nat.Linear.Poly.denote_eq_cancel">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(340, 1)" end="(341, 38)" name="Poly.denote_eq_cancel" full_name="Nat.Linear.Poly.denote_eq_cancel" _is_private_decl="False">
        <AtomNode start="(340, 1)" end="(340, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(340, 9)" end="(340, 30)">
          <IdentNode start="(340, 9)" end="(340, 30)" leading="" trailing=" " raw_val="Poly.denote_eq_cancel" val="Poly.denote_eq_cancel"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(340, 31)" end="(340, 121)">
          <NullNode start="(340, 31)" end="(340, 90)">
            <OtherNode start="(340, 31)" end="(340, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(340, 31)" end="(340, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(340, 32)" end="(340, 35)">
                <IdentNode start="(340, 32)" end="(340, 35)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(340, 36)" end="(340, 45)">
                <AtomNode start="(340, 36)" end="(340, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(340, 38)" end="(340, 45)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <AtomNode start="(340, 45)" end="(340, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(340, 47)" end="(340, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(340, 47)" end="(340, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(340, 48)" end="(340, 53)">
                <IdentNode start="(340, 48)" end="(340, 50)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(340, 51)" end="(340, 53)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
              </NullNode>
              <NullNode start="(340, 54)" end="(340, 60)">
                <AtomNode start="(340, 54)" end="(340, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(340, 56)" end="(340, 60)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <AtomNode start="(340, 60)" end="(340, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(340, 62)" end="(340, 90)">
              <AtomNode start="(340, 62)" end="(340, 63)" leading="" trailing="" val="("/>
              <NullNode start="(340, 63)" end="(340, 64)">
                <IdentNode start="(340, 63)" end="(340, 64)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(340, 65)" end="(340, 89)">
                <AtomNode start="(340, 65)" end="(340, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(340, 67)" end="(340, 89)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(340, 67)" end="(340, 76)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                  <NullNode start="(340, 77)" end="(340, 89)">
                    <IdentNode start="(340, 77)" end="(340, 80)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(340, 81)" end="(340, 89)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(340, 81)" end="(340, 82)" leading="" trailing="" val="("/>
                      <NullNode start="(340, 82)" end="(340, 88)">
                        <IdentNode start="(340, 82)" end="(340, 84)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                        <AtomNode start="(340, 84)" end="(340, 85)" leading="" trailing=" " val=","/>
                        <NullNode start="(340, 86)" end="(340, 88)">
                          <IdentNode start="(340, 86)" end="(340, 88)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(340, 88)" end="(340, 89)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(340, 89)" end="(340, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(340, 91)" end="(340, 121)">
            <AtomNode start="(340, 91)" end="(340, 92)" leading="" trailing=" " val=":"/>
            <OtherNode start="(340, 93)" end="(340, 121)" kind="Lean.Parser.Term.app">
              <IdentNode start="(340, 93)" end="(340, 102)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
              <NullNode start="(340, 103)" end="(340, 121)">
                <IdentNode start="(340, 103)" end="(340, 106)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(340, 107)" end="(340, 121)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(340, 107)" end="(340, 108)" leading="" trailing="" val="("/>
                  <OtherNode start="(340, 108)" end="(340, 120)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(340, 108)" end="(340, 114)" leading="" trailing=" " raw_val="cancel" val="cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                    <NullNode start="(340, 115)" end="(340, 120)">
                      <IdentNode start="(340, 115)" end="(340, 117)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                      <IdentNode start="(340, 118)" end="(340, 120)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(340, 120)" end="(340, 121)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(340, 122)" end="(341, 38)">
          <AtomNode start="(340, 122)" end="(340, 124)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(340, 125)" end="(341, 38)">
            <AtomNode start="(340, 125)" end="(340, 127)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(341, 3)" end="(341, 38)">
              <TacticTacticseq1IndentedNode start="(341, 3)" end="(341, 38)">
                <NullNode start="(341, 3)" end="(341, 38)">
                  <OtherNode start="(341, 3)" end="(341, 28)" kind="Lean.Parser.Tactic.apply" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁, m₂)&#10;⊢ denote_eq ctx (m₁.cancel m₂)" state_after="case h&#10;ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁, m₂)&#10;⊢ denote_eq ctx ([].reverse ++ m₁, [].reverse ++ m₂)" tactic="apply denote_eq_cancelAux">
                    <AtomNode start="(341, 3)" end="(341, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(341, 9)" end="(341, 28)" leading="" trailing="" raw_val="denote_eq_cancelAux" val="denote_eq_cancelAux" full_name="Nat.Linear.Poly.denote_eq_cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(275, 9)" def_end="(275, 33)"/>
                  </OtherNode>
                  <AtomNode start="(341, 28)" end="(341, 29)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(341, 30)" end="(341, 38)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁, m₂)&#10;⊢ denote_eq ctx ([].reverse ++ m₁, [].reverse ++ m₂)" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(341, 30)" end="(341, 34)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(341, 35)" end="(341, 38)">
                      <AtomNode start="(341, 35)" end="(341, 36)" leading="" trailing="" val="["/>
                      <NullNode start="(341, 36)" end="(341, 37)">
                        <OtherNode start="(341, 36)" end="(341, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(341, 36)" end="(341, 37)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(341, 37)" end="(341, 38)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(343, 1)" end="(346, 13)" name="Poly.of_denote_eq_cancel" full_name="Nat.Linear.Poly.of_denote_eq_cancel">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(343, 1)" end="(346, 13)" name="Poly.of_denote_eq_cancel" full_name="Nat.Linear.Poly.of_denote_eq_cancel" _is_private_decl="False">
        <AtomNode start="(343, 1)" end="(343, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(343, 9)" end="(343, 33)">
          <IdentNode start="(343, 9)" end="(343, 33)" leading="" trailing=" " raw_val="Poly.of_denote_eq_cancel" val="Poly.of_denote_eq_cancel"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(343, 34)" end="(343, 124)">
          <NullNode start="(343, 34)" end="(343, 99)">
            <OtherNode start="(343, 34)" end="(343, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(343, 34)" end="(343, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(343, 35)" end="(343, 38)">
                <IdentNode start="(343, 35)" end="(343, 38)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(343, 39)" end="(343, 48)">
                <AtomNode start="(343, 39)" end="(343, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(343, 41)" end="(343, 48)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <AtomNode start="(343, 48)" end="(343, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(343, 50)" end="(343, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(343, 50)" end="(343, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(343, 51)" end="(343, 56)">
                <IdentNode start="(343, 51)" end="(343, 53)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(343, 54)" end="(343, 56)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
              </NullNode>
              <NullNode start="(343, 57)" end="(343, 63)">
                <AtomNode start="(343, 57)" end="(343, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(343, 59)" end="(343, 63)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <AtomNode start="(343, 63)" end="(343, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(343, 65)" end="(343, 99)">
              <AtomNode start="(343, 65)" end="(343, 66)" leading="" trailing="" val="("/>
              <NullNode start="(343, 66)" end="(343, 67)">
                <IdentNode start="(343, 66)" end="(343, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(343, 68)" end="(343, 98)">
                <AtomNode start="(343, 68)" end="(343, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(343, 70)" end="(343, 98)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(343, 70)" end="(343, 79)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                  <NullNode start="(343, 80)" end="(343, 98)">
                    <IdentNode start="(343, 80)" end="(343, 83)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(343, 84)" end="(343, 98)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(343, 84)" end="(343, 85)" leading="" trailing="" val="("/>
                      <OtherNode start="(343, 85)" end="(343, 97)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(343, 85)" end="(343, 91)" leading="" trailing=" " raw_val="cancel" val="cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                        <NullNode start="(343, 92)" end="(343, 97)">
                          <IdentNode start="(343, 92)" end="(343, 94)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                          <IdentNode start="(343, 95)" end="(343, 97)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(343, 97)" end="(343, 98)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(343, 98)" end="(343, 99)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(343, 100)" end="(343, 124)">
            <AtomNode start="(343, 100)" end="(343, 101)" leading="" trailing=" " val=":"/>
            <OtherNode start="(343, 102)" end="(343, 124)" kind="Lean.Parser.Term.app">
              <IdentNode start="(343, 102)" end="(343, 111)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
              <NullNode start="(343, 112)" end="(343, 124)">
                <IdentNode start="(343, 112)" end="(343, 115)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(343, 116)" end="(343, 124)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(343, 116)" end="(343, 117)" leading="" trailing="" val="("/>
                  <NullNode start="(343, 117)" end="(343, 123)">
                    <IdentNode start="(343, 117)" end="(343, 119)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                    <AtomNode start="(343, 119)" end="(343, 120)" leading="" trailing=" " val=","/>
                    <NullNode start="(343, 121)" end="(343, 123)">
                      <IdentNode start="(343, 121)" end="(343, 123)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(343, 123)" end="(343, 124)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(343, 125)" end="(346, 13)">
          <AtomNode start="(343, 125)" end="(343, 127)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(343, 128)" end="(346, 13)">
            <AtomNode start="(343, 128)" end="(343, 130)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(344, 3)" end="(346, 13)">
              <TacticTacticseq1IndentedNode start="(344, 3)" end="(346, 13)">
                <NullNode start="(344, 3)" end="(346, 13)">
                  <OtherNode start="(344, 3)" end="(344, 47)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁.cancel m₂)&#10;⊢ denote_eq ctx (m₁, m₂)" state_after="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁.cancel m₂)&#10;this : denote_eq ctx ([].reverse ++ m₁, [].reverse ++ m₂)&#10;⊢ denote_eq ctx (m₁, m₂)" tactic="have := Poly.of_denote_eq_cancelAux (h := h)">
                    <AtomNode start="(344, 3)" end="(344, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(344, 8)" end="(344, 47)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(344, 8)" end="(344, 47)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(344, 8)" end="(344, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(344, 8)" end="(344, 8)" kind="hygieneInfo">
                            <IdentNode start="(344, 8)" end="(344, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(344, 8)" end="(344, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(344, 11)" end="(344, 47)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(344, 11)" end="(344, 38)" leading="" trailing=" " raw_val="Poly.of_denote_eq_cancelAux" val="Poly.of_denote_eq_cancelAux" full_name="Nat.Linear.Poly.of_denote_eq_cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(309, 9)" def_end="(309, 36)"/>
                          <NullNode start="(344, 39)" end="(344, 47)">
                            <OtherNode start="(344, 39)" end="(344, 47)" kind="Lean.Parser.Term.namedArgument">
                              <AtomNode start="(344, 39)" end="(344, 40)" leading="" trailing="" val="("/>
                              <IdentNode start="(344, 40)" end="(344, 41)" leading="" trailing=" " raw_val="h" val="h"/>
                              <AtomNode start="(344, 42)" end="(344, 44)" leading="" trailing=" " val=":="/>
                              <IdentNode start="(344, 45)" end="(344, 46)" leading="" trailing="" raw_val="h" val="h"/>
                              <AtomNode start="(344, 46)" end="(344, 47)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(345, 3)" end="(345, 15)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁.cancel m₂)&#10;this : denote_eq ctx ([].reverse ++ m₁, [].reverse ++ m₂)&#10;⊢ denote_eq ctx (m₁, m₂)" state_after="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁.cancel m₂)&#10;this : denote_eq ctx (m₁, m₂)&#10;⊢ denote_eq ctx (m₁, m₂)" tactic="simp at this">
                    <AtomNode start="(345, 3)" end="(345, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(345, 8)" end="(345, 15)">
                      <OtherNode start="(345, 8)" end="(345, 15)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(345, 8)" end="(345, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(345, 11)" end="(345, 15)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(345, 11)" end="(345, 15)">
                            <IdentNode start="(345, 11)" end="(345, 15)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(346, 3)" end="(346, 13)" kind="Lean.Parser.Tactic.assumption" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_eq ctx (m₁.cancel m₂)&#10;this : denote_eq ctx (m₁, m₂)&#10;⊢ denote_eq ctx (m₁, m₂)" state_after="no goals" tactic="assumption">
                    <AtomNode start="(346, 3)" end="(346, 13)" leading="" trailing="&#10;&#10;" val="assumption"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(348, 1)" end="(349, 86)" name="Poly.denote_eq_cancel_eq" full_name="Nat.Linear.Poly.denote_eq_cancel_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(348, 1)" end="(349, 86)" name="Poly.denote_eq_cancel_eq" full_name="Nat.Linear.Poly.denote_eq_cancel_eq" _is_private_decl="False">
        <AtomNode start="(348, 1)" end="(348, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(348, 9)" end="(348, 33)">
          <IdentNode start="(348, 9)" end="(348, 33)" leading="" trailing=" " raw_val="Poly.denote_eq_cancel_eq" val="Poly.denote_eq_cancel_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(348, 34)" end="(348, 120)">
          <NullNode start="(348, 34)" end="(348, 64)">
            <TermExplicitbinderNode start="(348, 34)" end="(348, 49)">
              <AtomNode start="(348, 34)" end="(348, 35)" leading="" trailing="" val="("/>
              <NullNode start="(348, 35)" end="(348, 38)">
                <IdentNode start="(348, 35)" end="(348, 38)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(348, 39)" end="(348, 48)">
                <AtomNode start="(348, 39)" end="(348, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(348, 41)" end="(348, 48)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(348, 48)" end="(348, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(348, 50)" end="(348, 64)">
              <AtomNode start="(348, 50)" end="(348, 51)" leading="" trailing="" val="("/>
              <NullNode start="(348, 51)" end="(348, 56)">
                <IdentNode start="(348, 51)" end="(348, 53)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(348, 54)" end="(348, 56)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
              </NullNode>
              <NullNode start="(348, 57)" end="(348, 63)">
                <AtomNode start="(348, 57)" end="(348, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(348, 59)" end="(348, 63)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(348, 63)" end="(348, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(348, 65)" end="(348, 120)">
            <AtomNode start="(348, 65)" end="(348, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(348, 67)" end="(348, 120)" kind="«term_=_»">
              <OtherNode start="(348, 67)" end="(348, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 67)" end="(348, 76)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                <NullNode start="(348, 77)" end="(348, 95)">
                  <IdentNode start="(348, 77)" end="(348, 80)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(348, 81)" end="(348, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(348, 81)" end="(348, 82)" leading="" trailing="" val="("/>
                    <OtherNode start="(348, 82)" end="(348, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(348, 82)" end="(348, 88)" leading="" trailing=" " raw_val="cancel" val="cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                      <NullNode start="(348, 89)" end="(348, 94)">
                        <IdentNode start="(348, 89)" end="(348, 91)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                        <IdentNode start="(348, 92)" end="(348, 94)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(348, 94)" end="(348, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(348, 96)" end="(348, 97)" leading="" trailing=" " val="="/>
              <OtherNode start="(348, 98)" end="(348, 120)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 98)" end="(348, 107)" leading="" trailing=" " raw_val="denote_eq" val="denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                <NullNode start="(348, 108)" end="(348, 120)">
                  <IdentNode start="(348, 108)" end="(348, 111)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(348, 112)" end="(348, 120)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(348, 112)" end="(348, 113)" leading="" trailing="" val="("/>
                    <NullNode start="(348, 113)" end="(348, 119)">
                      <IdentNode start="(348, 113)" end="(348, 115)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                      <AtomNode start="(348, 115)" end="(348, 116)" leading="" trailing=" " val=","/>
                      <NullNode start="(348, 117)" end="(348, 119)">
                        <IdentNode start="(348, 117)" end="(348, 119)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(348, 119)" end="(348, 120)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(348, 121)" end="(349, 86)">
          <AtomNode start="(348, 121)" end="(348, 123)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(349, 3)" end="(349, 86)" kind="«term_&amp;lt;|_»">
            <IdentNode start="(349, 3)" end="(349, 10)" leading="" trailing=" " raw_val="propext" val="propext" full_name="propext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
            <AtomNode start="(349, 11)" end="(349, 13)" leading="" trailing=" " val="&amp;lt;|"/>
            <OtherNode start="(349, 14)" end="(349, 86)" kind="Lean.Parser.Term.app">
              <IdentNode start="(349, 14)" end="(349, 23)" leading="" trailing=" " raw_val="Iff.intro" val="Iff.intro" full_name="Iff.intro" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(349, 24)" end="(349, 86)">
                <OtherNode start="(349, 24)" end="(349, 56)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(349, 24)" end="(349, 25)" leading="" trailing="" val="("/>
                  <OtherNode start="(349, 25)" end="(349, 55)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(349, 25)" end="(349, 28)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(349, 29)" end="(349, 55)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(349, 29)" end="(349, 30)">
                        <IdentNode start="(349, 29)" end="(349, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(349, 31)" end="(349, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(349, 34)" end="(349, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(349, 34)" end="(349, 53)" leading="" trailing=" " raw_val="of_denote_eq_cancel" val="of_denote_eq_cancel" full_name="Nat.Linear.Poly.of_denote_eq_cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(343, 9)" def_end="(343, 33)"/>
                        <NullNode start="(349, 54)" end="(349, 55)">
                          <IdentNode start="(349, 54)" end="(349, 55)" leading="" trailing="" raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(349, 55)" end="(349, 56)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(349, 57)" end="(349, 86)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(349, 57)" end="(349, 58)" leading="" trailing="" val="("/>
                  <OtherNode start="(349, 58)" end="(349, 85)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(349, 58)" end="(349, 61)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(349, 62)" end="(349, 85)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(349, 62)" end="(349, 63)">
                        <IdentNode start="(349, 62)" end="(349, 63)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(349, 64)" end="(349, 66)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(349, 67)" end="(349, 85)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(349, 67)" end="(349, 83)" leading="" trailing=" " raw_val="denote_eq_cancel" val="denote_eq_cancel" full_name="Nat.Linear.Poly.denote_eq_cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(340, 9)" def_end="(340, 30)"/>
                        <NullNode start="(349, 84)" end="(349, 85)">
                          <IdentNode start="(349, 84)" end="(349, 85)" leading="" trailing="" raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(349, 85)" end="(349, 86)" leading="" trailing="&#10;&#10;" val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(351, 1)" end="(351, 48)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(351, 1)" end="(351, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(351, 11)" end="(351, 12)" leading="" trailing="" val="["/>
      <NullNode start="(351, 12)" end="(351, 22)">
        <OtherNode start="(351, 12)" end="(351, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(351, 12)" end="(351, 17)">
            <NullNode start="(351, 12)" end="(351, 17)">
              <OtherNode start="(351, 12)" end="(351, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(351, 12)" end="(351, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(351, 18)" end="(351, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(351, 18)" end="(351, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(351, 22)" end="(351, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(351, 24)" end="(351, 48)">
        <IdentNode start="(351, 24)" end="(351, 48)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_eq_cancel_eq" val="Poly.denote_eq_cancel_eq" full_name="Nat.Linear.Poly.denote_eq_cancel_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(348, 9)" def_end="(348, 33)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(353, 1)" end="(385, 9)" name="Poly.denote_le_cancelAux" full_name="Nat.Linear.Poly.denote_le_cancelAux">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(353, 1)" end="(385, 9)" name="Poly.denote_le_cancelAux" full_name="Nat.Linear.Poly.denote_le_cancelAux" _is_private_decl="False">
        <AtomNode start="(353, 1)" end="(353, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(353, 9)" end="(353, 33)">
          <IdentNode start="(353, 9)" end="(353, 33)" leading="" trailing=" " raw_val="Poly.denote_le_cancelAux" val="Poly.denote_le_cancelAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(353, 34)" end="(354, 106)">
          <NullNode start="(353, 34)" end="(354, 61)">
            <TermExplicitbinderNode start="(353, 34)" end="(353, 49)">
              <AtomNode start="(353, 34)" end="(353, 35)" leading="" trailing="" val="("/>
              <NullNode start="(353, 35)" end="(353, 38)">
                <IdentNode start="(353, 35)" end="(353, 38)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(353, 39)" end="(353, 48)">
                <AtomNode start="(353, 39)" end="(353, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(353, 41)" end="(353, 48)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(353, 48)" end="(353, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(353, 50)" end="(353, 62)">
              <AtomNode start="(353, 50)" end="(353, 51)" leading="" trailing="" val="("/>
              <NullNode start="(353, 51)" end="(353, 55)">
                <IdentNode start="(353, 51)" end="(353, 55)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
              </NullNode>
              <NullNode start="(353, 56)" end="(353, 61)">
                <AtomNode start="(353, 56)" end="(353, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(353, 58)" end="(353, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(353, 61)" end="(353, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(353, 63)" end="(353, 83)">
              <AtomNode start="(353, 63)" end="(353, 64)" leading="" trailing="" val="("/>
              <NullNode start="(353, 64)" end="(353, 75)">
                <IdentNode start="(353, 64)" end="(353, 66)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(353, 67)" end="(353, 69)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                <IdentNode start="(353, 70)" end="(353, 72)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                <IdentNode start="(353, 73)" end="(353, 75)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
              </NullNode>
              <NullNode start="(353, 76)" end="(353, 82)">
                <AtomNode start="(353, 76)" end="(353, 77)" leading="" trailing=" " val=":"/>
                <IdentNode start="(353, 78)" end="(353, 82)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(353, 82)" end="(353, 83)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(354, 5)" end="(354, 61)">
              <AtomNode start="(354, 5)" end="(354, 6)" leading="" trailing="" val="("/>
              <NullNode start="(354, 6)" end="(354, 7)">
                <IdentNode start="(354, 6)" end="(354, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(354, 8)" end="(354, 60)">
                <AtomNode start="(354, 8)" end="(354, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(354, 10)" end="(354, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(354, 10)" end="(354, 19)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                  <NullNode start="(354, 20)" end="(354, 60)">
                    <IdentNode start="(354, 20)" end="(354, 23)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(354, 24)" end="(354, 60)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(354, 24)" end="(354, 25)" leading="" trailing="" val="("/>
                      <NullNode start="(354, 25)" end="(354, 59)">
                        <OtherNode start="(354, 25)" end="(354, 41)" kind="«term_++_»">
                          <IdentNode start="(354, 25)" end="(354, 35)" leading="" trailing=" " raw_val="r₁.reverse" val="r₁.reverse"/>
                          <AtomNode start="(354, 36)" end="(354, 38)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(354, 39)" end="(354, 41)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                        </OtherNode>
                        <AtomNode start="(354, 41)" end="(354, 42)" leading="" trailing=" " val=","/>
                        <NullNode start="(354, 43)" end="(354, 59)">
                          <OtherNode start="(354, 43)" end="(354, 59)" kind="«term_++_»">
                            <IdentNode start="(354, 43)" end="(354, 53)" leading="" trailing=" " raw_val="r₂.reverse" val="r₂.reverse"/>
                            <AtomNode start="(354, 54)" end="(354, 56)" leading="" trailing=" " val="++"/>
                            <IdentNode start="(354, 57)" end="(354, 59)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(354, 59)" end="(354, 60)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(354, 60)" end="(354, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(354, 62)" end="(354, 106)">
            <AtomNode start="(354, 62)" end="(354, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(354, 64)" end="(354, 106)" kind="Lean.Parser.Term.app">
              <IdentNode start="(354, 64)" end="(354, 73)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
              <NullNode start="(354, 74)" end="(354, 106)">
                <IdentNode start="(354, 74)" end="(354, 77)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(354, 78)" end="(354, 106)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(354, 78)" end="(354, 79)" leading="" trailing="" val="("/>
                  <OtherNode start="(354, 79)" end="(354, 105)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(354, 79)" end="(354, 88)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux" full_name="Nat.Linear.Poly.cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(71, 5)" def_end="(71, 19)"/>
                    <NullNode start="(354, 89)" end="(354, 105)">
                      <IdentNode start="(354, 89)" end="(354, 93)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                      <IdentNode start="(354, 94)" end="(354, 96)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                      <IdentNode start="(354, 97)" end="(354, 99)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                      <IdentNode start="(354, 100)" end="(354, 102)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                      <IdentNode start="(354, 103)" end="(354, 105)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(354, 105)" end="(354, 106)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(354, 107)" end="(385, 9)">
          <AtomNode start="(354, 107)" end="(354, 109)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(354, 110)" end="(385, 9)">
            <AtomNode start="(354, 110)" end="(354, 112)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(355, 3)" end="(385, 9)">
              <TacticTacticseq1IndentedNode start="(355, 3)" end="(385, 9)">
                <NullNode start="(355, 3)" end="(385, 9)">
                  <OtherNode start="(355, 3)" end="(385, 9)" kind="Lean.Parser.Tactic.induction" state_before="ctx : Context&#10;fuel : Nat&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="induction fuel generalizing m₁ m₂ r₁ r₂ with&#10;| zero =&amp;gt; assumption&#10;| succ fuel ih =&amp;gt;&#10;  simp&#10;  split &amp;lt;;&amp;gt; try (simp at h; assumption)&#10;  rename_i k₁ v₁ m₁ k₂ v₂ m₂&#10;  by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv]&#10;  · apply ih; simp [denote_le] at h |-; assumption&#10;  · by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv]&#10;    · apply ih; simp [denote_le] at h |-; assumption&#10;    · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;      by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]&#10;      · apply ih&#10;        simp [denote_le] at h |-&#10;        have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;        apply Nat.le_sub_of_add_le&#10;        simp [h]&#10;      · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;        · apply ih&#10;          simp [denote_le] at h |-&#10;          have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;          rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;          apply Nat.sub_le_of_le_add&#10;          simp [h]&#10;        · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;          apply ih&#10;          simp [denote_le] at h |-&#10;          rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;          apply Nat.le_of_add_le_add_right h&#10;  done">
                    <AtomNode start="(355, 3)" end="(355, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(355, 13)" end="(355, 17)">
                      <OtherNode start="(355, 13)" end="(355, 17)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(355, 13)" end="(355, 17)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(355, 18)" end="(355, 42)">
                      <AtomNode start="(355, 18)" end="(355, 30)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(355, 31)" end="(355, 42)">
                        <IdentNode start="(355, 31)" end="(355, 33)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                        <IdentNode start="(355, 34)" end="(355, 36)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                        <IdentNode start="(355, 37)" end="(355, 39)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                        <IdentNode start="(355, 40)" end="(355, 42)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(355, 43)" end="(385, 9)">
                      <OtherNode start="(355, 43)" end="(385, 9)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(355, 43)" end="(355, 47)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(356, 3)" end="(385, 9)">
                          <OtherNode start="(356, 3)" end="(356, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(356, 3)" end="(356, 9)">
                              <OtherNode start="(356, 3)" end="(356, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(356, 3)" end="(356, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(356, 5)" end="(356, 9)">
                                  <NullNode/>
                                  <IdentNode start="(356, 5)" end="(356, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(356, 10)" end="(356, 23)">
                              <AtomNode start="(356, 10)" end="(356, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(356, 13)" end="(356, 23)">
                                <TacticTacticseq1IndentedNode start="(356, 13)" end="(356, 23)">
                                  <NullNode start="(356, 13)" end="(356, 23)">
                                    <OtherNode start="(356, 13)" end="(356, 23)" kind="Lean.Parser.Tactic.assumption" state_before="case zero&#10;ctx : Context&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (cancelAux 0 m₁ m₂ r₁ r₂)" state_after="no goals" tactic="assumption">
                                      <AtomNode start="(356, 13)" end="(356, 23)" leading="" trailing="&#10;  " val="assumption"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(357, 3)" end="(385, 9)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(357, 3)" end="(357, 17)">
                              <OtherNode start="(357, 3)" end="(357, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(357, 3)" end="(357, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(357, 5)" end="(357, 9)">
                                  <NullNode/>
                                  <IdentNode start="(357, 5)" end="(357, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(357, 10)" end="(357, 17)">
                                  <IdentNode start="(357, 10)" end="(357, 14)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                  <IdentNode start="(357, 15)" end="(357, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(357, 18)" end="(385, 9)">
                              <AtomNode start="(357, 18)" end="(357, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(358, 5)" end="(385, 9)">
                                <TacticTacticseq1IndentedNode start="(358, 5)" end="(385, 9)">
                                  <NullNode start="(358, 5)" end="(385, 9)">
                                    <OtherNode start="(358, 5)" end="(358, 9)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (cancelAux (fuel + 1) m₁ m₂ r₁ r₂)" state_after="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="simp">
                                      <AtomNode start="(358, 5)" end="(358, 9)" leading="" trailing="&#10;    " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(359, 5)" end="(359, 42)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)&#10;⊢ denote_le ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)" tactic="split &amp;lt;;&amp;gt; try (simp at h; assumption)">
                                      <OtherNode start="(359, 5)" end="(359, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(359, 5)" end="(359, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(359, 11)" end="(359, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(359, 15)" end="(359, 42)" kind="Lean.Parser.Tactic.tacticTry_">
                                        <AtomNode start="(359, 15)" end="(359, 18)" leading="" trailing=" " val="try"/>
                                        <TacticTacticseqNode start="(359, 19)" end="(359, 42)">
                                          <TacticTacticseq1IndentedNode start="(359, 19)" end="(359, 42)">
                                            <NullNode start="(359, 19)" end="(359, 42)">
                                              <OtherNode start="(359, 19)" end="(359, 42)" kind="Lean.Parser.Tactic.paren" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;h : denote_le ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)&#10;x✝ : m₂ = [] → False&#10;⊢ denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="(simp at h; assumption)">
                                                <AtomNode start="(359, 19)" end="(359, 20)" leading="" trailing="" val="("/>
                                                <TacticTacticseqNode start="(359, 20)" end="(359, 41)">
                                                  <TacticTacticseq1IndentedNode start="(359, 20)" end="(359, 41)">
                                                    <NullNode start="(359, 20)" end="(359, 41)">
                                                      <OtherNode start="(359, 20)" end="(359, 29)" kind="Lean.Parser.Tactic.simp" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;h : denote_le ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)&#10;x✝ : m₂ = [] → False&#10;⊢ denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" tactic="simp at h">
                                                        <AtomNode start="(359, 20)" end="(359, 24)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(359, 25)" end="(359, 29)">
                                                          <OtherNode start="(359, 25)" end="(359, 29)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(359, 25)" end="(359, 27)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(359, 28)" end="(359, 29)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(359, 28)" end="(359, 29)">
                                                            <IdentNode start="(359, 28)" end="(359, 29)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(359, 29)" end="(359, 30)" leading="" trailing=" " val=";"/>
                                                      <OtherNode start="(359, 31)" end="(359, 41)" kind="Lean.Parser.Tactic.assumption" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="assumption">
                                                        <AtomNode start="(359, 31)" end="(359, 41)" leading="" trailing="" val="assumption"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                                <AtomNode start="(359, 41)" end="(359, 42)" leading="" trailing="&#10;    " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(360, 5)" end="(360, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)&#10;⊢ denote_le ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_le ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="rename_i k₁ v₁ m₁ k₂ v₂ m₂">
                                      <AtomNode start="(360, 5)" end="(360, 13)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(360, 14)" end="(360, 31)">
                                        <LeanBinderidentNode start="(360, 14)" end="(360, 16)">
                                          <IdentNode start="(360, 14)" end="(360, 16)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(360, 17)" end="(360, 19)">
                                          <IdentNode start="(360, 17)" end="(360, 19)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(360, 20)" end="(360, 22)">
                                          <IdentNode start="(360, 20)" end="(360, 22)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(360, 23)" end="(360, 25)">
                                          <IdentNode start="(360, 23)" end="(360, 25)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(360, 26)" end="(360, 28)">
                                          <IdentNode start="(360, 26)" end="(360, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(360, 29)" end="(360, 31)">
                                          <IdentNode start="(360, 29)" end="(360, 31)" leading="" trailing="&#10;    " raw_val="m₂" val="m₂"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(361, 5)" end="(361, 50)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_le ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv]">
                                      <OtherNode start="(361, 5)" end="(361, 34)" kind="«tacticBy_cases_:_»">
                                        <AtomNode start="(361, 5)" end="(361, 13)" leading="" trailing=" " val="by_cases"/>
                                        <NullNode start="(361, 14)" end="(361, 20)">
                                          <IdentNode start="(361, 14)" end="(361, 18)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                          <AtomNode start="(361, 19)" end="(361, 20)" leading="" trailing=" " val=":"/>
                                        </NullNode>
                                        <OtherNode start="(361, 21)" end="(361, 34)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(361, 21)" end="(361, 28)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          <NullNode start="(361, 29)" end="(361, 34)">
                                            <IdentNode start="(361, 29)" end="(361, 31)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                            <IdentNode start="(361, 32)" end="(361, 34)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(361, 35)" end="(361, 38)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(361, 39)" end="(361, 50)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(361, 39)" end="(361, 43)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(361, 44)" end="(361, 50)">
                                          <AtomNode start="(361, 44)" end="(361, 45)" leading="" trailing="" val="["/>
                                          <NullNode start="(361, 45)" end="(361, 49)">
                                            <OtherNode start="(361, 45)" end="(361, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(361, 45)" end="(361, 49)" leading="" trailing="" raw_val="hltv" val="hltv"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(361, 49)" end="(361, 50)" leading="" trailing="&#10;    " val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(362, 5)" end="(362, 53)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih; simp [denote_le] at h |-; assumption">
                                      <OtherNode start="(362, 5)" end="(362, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(362, 5)" end="(362, 6)" kind="patternIgnore">
                                          <OtherNode start="(362, 5)" end="(362, 6)" kind="token.«· »">
                                            <AtomNode start="(362, 5)" end="(362, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(362, 7)" end="(362, 53)">
                                        <TacticTacticseq1IndentedNode start="(362, 7)" end="(362, 53)">
                                          <NullNode start="(362, 7)" end="(362, 53)">
                                            <OtherNode start="(362, 7)" end="(362, 15)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_le ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="apply ih">
                                              <AtomNode start="(362, 7)" end="(362, 12)" leading="" trailing=" " val="apply"/>
                                              <IdentNode start="(362, 13)" end="(362, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                            <AtomNode start="(362, 15)" end="(362, 16)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(362, 17)" end="(362, 41)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : blt v₁ v₂ = true&#10;⊢ denote_le ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_le] at h |-">
                                              <AtomNode start="(362, 17)" end="(362, 21)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(362, 22)" end="(362, 33)">
                                                <AtomNode start="(362, 22)" end="(362, 23)" leading="" trailing="" val="["/>
                                                <NullNode start="(362, 23)" end="(362, 32)">
                                                  <OtherNode start="(362, 23)" end="(362, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(362, 23)" end="(362, 32)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(362, 32)" end="(362, 33)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(362, 34)" end="(362, 41)">
                                                <OtherNode start="(362, 34)" end="(362, 41)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(362, 34)" end="(362, 36)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(362, 37)" end="(362, 41)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(362, 37)" end="(362, 41)">
                                                      <IdentNode start="(362, 37)" end="(362, 38)" leading="" trailing=" " raw_val="h" val="h"/>
                                                      <OtherNode start="(362, 39)" end="(362, 41)" kind="Lean.Parser.Tactic.locationType">
                                                        <OtherNode start="(362, 39)" end="(362, 41)" kind="patternIgnore">
                                                          <GroupNode start="(362, 39)" end="(362, 41)">
                                                            <AtomNode start="(362, 39)" end="(362, 40)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(362, 40)" end="(362, 41)" leading="" trailing="" val="-"/>
                                                          </GroupNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(362, 41)" end="(362, 42)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(362, 43)" end="(362, 53)" kind="Lean.Parser.Tactic.assumption" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                              <AtomNode start="(362, 43)" end="(362, 53)" leading="" trailing="&#10;    " val="assumption"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(363, 5)" end="(384, 47)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv]&#10;  · apply ih; simp [denote_le] at h |-; assumption&#10;  · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;    by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]&#10;    · apply ih&#10;      simp [denote_le] at h |-&#10;      have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;      apply Nat.le_sub_of_add_le&#10;      simp [h]&#10;    · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;      · apply ih&#10;        simp [denote_le] at h |-&#10;        have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;        apply Nat.sub_le_of_le_add&#10;        simp [h]&#10;      · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;        apply ih&#10;        simp [denote_le] at h |-&#10;        rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;        apply Nat.le_of_add_le_add_right h">
                                      <OtherNode start="(363, 5)" end="(363, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(363, 5)" end="(363, 6)" kind="patternIgnore">
                                          <OtherNode start="(363, 5)" end="(363, 6)" kind="token.«· »">
                                            <AtomNode start="(363, 5)" end="(363, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(363, 7)" end="(384, 47)">
                                        <TacticTacticseq1IndentedNode start="(363, 7)" end="(384, 47)">
                                          <NullNode start="(363, 7)" end="(384, 47)">
                                            <OtherNode start="(363, 7)" end="(363, 52)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;⊢ denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv]">
                                              <OtherNode start="(363, 7)" end="(363, 36)" kind="«tacticBy_cases_:_»">
                                                <AtomNode start="(363, 7)" end="(363, 15)" leading="" trailing=" " val="by_cases"/>
                                                <NullNode start="(363, 16)" end="(363, 22)">
                                                  <IdentNode start="(363, 16)" end="(363, 20)" leading="" trailing=" " raw_val="hgtv" val="hgtv"/>
                                                  <AtomNode start="(363, 21)" end="(363, 22)" leading="" trailing=" " val=":"/>
                                                </NullNode>
                                                <OtherNode start="(363, 23)" end="(363, 36)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(363, 23)" end="(363, 30)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  <NullNode start="(363, 31)" end="(363, 36)">
                                                    <IdentNode start="(363, 31)" end="(363, 33)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                    <IdentNode start="(363, 34)" end="(363, 36)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(363, 37)" end="(363, 40)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(363, 41)" end="(363, 52)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(363, 41)" end="(363, 45)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(363, 46)" end="(363, 52)">
                                                  <AtomNode start="(363, 46)" end="(363, 47)" leading="" trailing="" val="["/>
                                                  <NullNode start="(363, 47)" end="(363, 51)">
                                                    <OtherNode start="(363, 47)" end="(363, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(363, 47)" end="(363, 51)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(363, 51)" end="(363, 52)" leading="" trailing="&#10;      " val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(364, 7)" end="(364, 55)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih; simp [denote_le] at h |-; assumption">
                                              <OtherNode start="(364, 7)" end="(364, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(364, 7)" end="(364, 8)" kind="patternIgnore">
                                                  <OtherNode start="(364, 7)" end="(364, 8)" kind="token.«· »">
                                                    <AtomNode start="(364, 7)" end="(364, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(364, 9)" end="(364, 55)">
                                                <TacticTacticseq1IndentedNode start="(364, 9)" end="(364, 55)">
                                                  <NullNode start="(364, 9)" end="(364, 55)">
                                                    <OtherNode start="(364, 9)" end="(364, 17)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)" tactic="apply ih">
                                                      <AtomNode start="(364, 9)" end="(364, 14)" leading="" trailing=" " val="apply"/>
                                                      <IdentNode start="(364, 15)" end="(364, 17)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                    </OtherNode>
                                                    <AtomNode start="(364, 17)" end="(364, 18)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(364, 19)" end="(364, 43)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_le] at h |-">
                                                      <AtomNode start="(364, 19)" end="(364, 23)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(364, 24)" end="(364, 35)">
                                                        <AtomNode start="(364, 24)" end="(364, 25)" leading="" trailing="" val="["/>
                                                        <NullNode start="(364, 25)" end="(364, 34)">
                                                          <OtherNode start="(364, 25)" end="(364, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(364, 25)" end="(364, 34)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(364, 34)" end="(364, 35)" leading="" trailing=" " val="]"/>
                                                      </NullNode>
                                                      <NullNode start="(364, 36)" end="(364, 43)">
                                                        <OtherNode start="(364, 36)" end="(364, 43)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(364, 36)" end="(364, 38)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(364, 39)" end="(364, 43)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(364, 39)" end="(364, 43)">
                                                            <IdentNode start="(364, 39)" end="(364, 40)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(364, 41)" end="(364, 43)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(364, 41)" end="(364, 43)" kind="patternIgnore">
                                                            <GroupNode start="(364, 41)" end="(364, 43)">
                                                            <AtomNode start="(364, 41)" end="(364, 42)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(364, 42)" end="(364, 43)" leading="" trailing="" val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(364, 43)" end="(364, 44)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(364, 45)" end="(364, 55)" kind="Lean.Parser.Tactic.assumption" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                                      <AtomNode start="(364, 45)" end="(364, 55)" leading="" trailing="&#10;      " val="assumption"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(365, 7)" end="(384, 47)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;  by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]&#10;  · apply ih&#10;    simp [denote_le] at h |-&#10;    have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;    apply Nat.le_sub_of_add_le&#10;    simp [h]&#10;  · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;    · apply ih&#10;      simp [denote_le] at h |-&#10;      have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;      apply Nat.sub_le_of_le_add&#10;      simp [h]&#10;    · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;      apply ih&#10;      simp [denote_le] at h |-&#10;      rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;      apply Nat.le_of_add_le_add_right h">
                                              <OtherNode start="(365, 7)" end="(365, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(365, 7)" end="(365, 8)" kind="patternIgnore">
                                                  <OtherNode start="(365, 7)" end="(365, 8)" kind="token.«· »">
                                                    <AtomNode start="(365, 7)" end="(365, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(365, 9)" end="(384, 47)">
                                                <TacticTacticseq1IndentedNode start="(365, 9)" end="(384, 47)">
                                                  <NullNode start="(365, 9)" end="(384, 47)">
                                                    <OtherNode start="(365, 9)" end="(365, 63)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;heqv : v₁ = v₂&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv">
                                                      <AtomNode start="(365, 9)" end="(365, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(365, 14)" end="(365, 63)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(365, 14)" end="(365, 63)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(365, 14)" end="(365, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(365, 14)" end="(365, 18)" leading="" trailing=" " raw_val="heqv" val="heqv"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(365, 19)" end="(365, 28)">
                                                            <TermTypespecNode start="(365, 19)" end="(365, 28)">
                                                            <AtomNode start="(365, 19)" end="(365, 20)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(365, 21)" end="(365, 28)" kind="«term_=_»">
                                                            <IdentNode start="(365, 21)" end="(365, 23)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            <AtomNode start="(365, 24)" end="(365, 25)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(365, 26)" end="(365, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                          </NullNode>
                                                          <AtomNode start="(365, 29)" end="(365, 31)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(365, 32)" end="(365, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(365, 32)" end="(365, 53)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(365, 54)" end="(365, 63)">
                                                            <IdentNode start="(365, 54)" end="(365, 58)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                                            <IdentNode start="(365, 59)" end="(365, 63)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(365, 63)" end="(365, 64)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(365, 65)" end="(365, 75)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;heqv : v₁ = v₂&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="subst heqv">
                                                      <AtomNode start="(365, 65)" end="(365, 70)" leading="" trailing=" " val="subst"/>
                                                      <NullNode start="(365, 71)" end="(365, 75)">
                                                        <IdentNode start="(365, 71)" end="(365, 75)" leading="" trailing="&#10;        " raw_val="heqv" val="heqv"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(366, 9)" end="(366, 54)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk]">
                                                      <OtherNode start="(366, 9)" end="(366, 38)" kind="«tacticBy_cases_:_»">
                                                        <AtomNode start="(366, 9)" end="(366, 17)" leading="" trailing=" " val="by_cases"/>
                                                        <NullNode start="(366, 18)" end="(366, 24)">
                                                          <IdentNode start="(366, 18)" end="(366, 22)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                          <AtomNode start="(366, 23)" end="(366, 24)" leading="" trailing=" " val=":"/>
                                                        </NullNode>
                                                        <OtherNode start="(366, 25)" end="(366, 38)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(366, 25)" end="(366, 32)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          <NullNode start="(366, 33)" end="(366, 38)">
                                                            <IdentNode start="(366, 33)" end="(366, 35)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <IdentNode start="(366, 36)" end="(366, 38)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(366, 39)" end="(366, 42)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                      <OtherNode start="(366, 43)" end="(366, 54)" kind="Lean.Parser.Tactic.simp">
                                                        <AtomNode start="(366, 43)" end="(366, 47)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(366, 48)" end="(366, 54)">
                                                          <AtomNode start="(366, 48)" end="(366, 49)" leading="" trailing="" val="["/>
                                                          <NullNode start="(366, 49)" end="(366, 53)">
                                                            <OtherNode start="(366, 49)" end="(366, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(366, 49)" end="(366, 53)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(366, 53)" end="(366, 54)" leading="" trailing="&#10;        " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(367, 9)" end="(372, 19)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih&#10;  simp [denote_le] at h |-&#10;  have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;  apply Nat.le_sub_of_add_le&#10;  simp [h]">
                                                      <OtherNode start="(367, 9)" end="(367, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(367, 9)" end="(367, 10)" kind="patternIgnore">
                                                          <OtherNode start="(367, 9)" end="(367, 10)" kind="token.«· »">
                                                            <AtomNode start="(367, 9)" end="(367, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(367, 11)" end="(372, 19)">
                                                        <TacticTacticseq1IndentedNode start="(367, 11)" end="(372, 19)">
                                                          <NullNode start="(367, 11)" end="(372, 19)">
                                                            <OtherNode start="(367, 11)" end="(367, 19)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)" tactic="apply ih">
                                                            <AtomNode start="(367, 11)" end="(367, 16)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(367, 17)" end="(367, 19)" leading="" trailing="&#10;          " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(368, 11)" end="(368, 35)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" tactic="simp [denote_le] at h |-">
                                                            <AtomNode start="(368, 11)" end="(368, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(368, 16)" end="(368, 27)">
                                                            <AtomNode start="(368, 16)" end="(368, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(368, 17)" end="(368, 26)">
                                                            <OtherNode start="(368, 17)" end="(368, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(368, 17)" end="(368, 26)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(368, 26)" end="(368, 27)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(368, 28)" end="(368, 35)">
                                                            <OtherNode start="(368, 28)" end="(368, 35)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(368, 28)" end="(368, 30)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(368, 31)" end="(368, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(368, 31)" end="(368, 35)">
                                                            <IdentNode start="(368, 31)" end="(368, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(368, 33)" end="(368, 35)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(368, 33)" end="(368, 35)" kind="patternIgnore">
                                                            <GroupNode start="(368, 33)" end="(368, 35)">
                                                            <AtomNode start="(368, 33)" end="(368, 34)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(368, 34)" end="(368, 35)" leading="" trailing="&#10;          " val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(369, 11)" end="(369, 132)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" tactic="have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))">
                                                            <AtomNode start="(369, 11)" end="(369, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(369, 16)" end="(369, 132)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(369, 16)" end="(369, 132)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(369, 16)" end="(369, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(369, 16)" end="(369, 20)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(369, 21)" end="(369, 70)">
                                                            <TermTypespecNode start="(369, 21)" end="(369, 70)">
                                                            <AtomNode start="(369, 21)" end="(369, 22)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(369, 23)" end="(369, 70)" kind="«term_≤_»">
                                                            <OtherNode start="(369, 23)" end="(369, 45)" kind="«term_*_»">
                                                            <IdentNode start="(369, 23)" end="(369, 25)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(369, 26)" end="(369, 27)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(369, 28)" end="(369, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(369, 28)" end="(369, 38)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(369, 39)" end="(369, 45)">
                                                            <IdentNode start="(369, 39)" end="(369, 42)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(369, 43)" end="(369, 45)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(369, 46)" end="(369, 47)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(369, 48)" end="(369, 70)" kind="«term_*_»">
                                                            <IdentNode start="(369, 48)" end="(369, 50)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(369, 51)" end="(369, 52)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(369, 53)" end="(369, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(369, 53)" end="(369, 63)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(369, 64)" end="(369, 70)">
                                                            <IdentNode start="(369, 64)" end="(369, 67)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(369, 68)" end="(369, 70)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(369, 71)" end="(369, 73)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(369, 74)" end="(369, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(369, 74)" end="(369, 94)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(369, 95)" end="(369, 132)">
                                                            <TermHoleNode start="(369, 95)" end="(369, 96)">
                                                            <AtomNode start="(369, 95)" end="(369, 96)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(369, 97)" end="(369, 132)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(369, 97)" end="(369, 98)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(369, 98)" end="(369, 131)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(369, 98)" end="(369, 110)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(369, 111)" end="(369, 131)">
                                                            <OtherNode start="(369, 111)" end="(369, 131)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(369, 111)" end="(369, 112)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(369, 112)" end="(369, 130)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(369, 112)" end="(369, 125)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(369, 126)" end="(369, 130)">
                                                            <IdentNode start="(369, 126)" end="(369, 130)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(369, 130)" end="(369, 131)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(369, 131)" end="(369, 132)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(370, 11)" end="(370, 84)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]">
                                                            <AtomNode start="(370, 11)" end="(370, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(370, 14)" end="(370, 84)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(370, 14)" end="(370, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(370, 15)" end="(370, 83)">
                                                            <OtherNode start="(370, 15)" end="(370, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(370, 15)" end="(370, 40)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(370, 40)" end="(370, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(370, 42)" end="(370, 57)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(370, 42)" end="(370, 43)">
                                                            <OtherNode start="(370, 42)" end="(370, 43)" kind="patternIgnore">
                                                            <OtherNode start="(370, 42)" end="(370, 43)" kind="token.«← »">
                                                            <AtomNode start="(370, 42)" end="(370, 43)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(370, 44)" end="(370, 57)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(370, 57)" end="(370, 58)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(370, 59)" end="(370, 83)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(370, 59)" end="(370, 60)">
                                                            <OtherNode start="(370, 59)" end="(370, 60)" kind="patternIgnore">
                                                            <OtherNode start="(370, 59)" end="(370, 60)" kind="token.«← »">
                                                            <AtomNode start="(370, 59)" end="(370, 60)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(370, 61)" end="(370, 83)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(370, 61)" end="(370, 78)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(370, 79)" end="(370, 83)">
                                                            <IdentNode start="(370, 79)" end="(370, 83)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(370, 83)" end="(370, 84)" leading="" trailing="&#10;          " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(371, 11)" end="(371, 37)" kind="Lean.Parser.Tactic.apply" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁" state_after="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁" tactic="apply Nat.le_sub_of_add_le">
                                                            <AtomNode start="(371, 11)" end="(371, 16)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(371, 17)" end="(371, 37)" leading="" trailing="&#10;          " raw_val="Nat.le_sub_of_add_le" val="Nat.le_sub_of_add_le" full_name="Nat.le_sub_of_add_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(372, 11)" end="(372, 19)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁" state_after="no goals" tactic="simp [h]">
                                                            <AtomNode start="(372, 11)" end="(372, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(372, 16)" end="(372, 19)">
                                                            <AtomNode start="(372, 16)" end="(372, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(372, 17)" end="(372, 18)">
                                                            <OtherNode start="(372, 17)" end="(372, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(372, 17)" end="(372, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(372, 18)" end="(372, 19)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(373, 9)" end="(384, 47)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]&#10;  · apply ih&#10;    simp [denote_le] at h |-&#10;    have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;    apply Nat.sub_le_of_le_add&#10;    simp [h]&#10;  · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;    apply ih&#10;    simp [denote_le] at h |-&#10;    rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;    apply Nat.le_of_add_le_add_right h">
                                                      <OtherNode start="(373, 9)" end="(373, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(373, 9)" end="(373, 10)" kind="patternIgnore">
                                                          <OtherNode start="(373, 9)" end="(373, 10)" kind="token.«· »">
                                                            <AtomNode start="(373, 9)" end="(373, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(373, 11)" end="(384, 47)">
                                                        <TacticTacticseq1IndentedNode start="(373, 11)" end="(384, 47)">
                                                          <NullNode start="(373, 11)" end="(384, 47)">
                                                            <OtherNode start="(373, 11)" end="(373, 56)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;⊢ denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk]">
                                                            <OtherNode start="(373, 11)" end="(373, 40)" kind="«tacticBy_cases_:_»">
                                                            <AtomNode start="(373, 11)" end="(373, 19)" leading="" trailing=" " val="by_cases"/>
                                                            <NullNode start="(373, 20)" end="(373, 26)">
                                                            <IdentNode start="(373, 20)" end="(373, 24)" leading="" trailing=" " raw_val="hgtk" val="hgtk"/>
                                                            <AtomNode start="(373, 25)" end="(373, 26)" leading="" trailing=" " val=":"/>
                                                            </NullNode>
                                                            <OtherNode start="(373, 27)" end="(373, 40)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(373, 27)" end="(373, 34)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(373, 35)" end="(373, 40)">
                                                            <IdentNode start="(373, 35)" end="(373, 37)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <IdentNode start="(373, 38)" end="(373, 40)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(373, 41)" end="(373, 44)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                            <OtherNode start="(373, 45)" end="(373, 56)" kind="Lean.Parser.Tactic.simp">
                                                            <AtomNode start="(373, 45)" end="(373, 49)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(373, 50)" end="(373, 56)">
                                                            <AtomNode start="(373, 50)" end="(373, 51)" leading="" trailing="" val="["/>
                                                            <NullNode start="(373, 51)" end="(373, 55)">
                                                            <OtherNode start="(373, 51)" end="(373, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(373, 51)" end="(373, 55)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(373, 55)" end="(373, 56)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(374, 11)" end="(379, 21)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="· apply ih&#10;  simp [denote_le] at h |-&#10;  have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]&#10;  apply Nat.sub_le_of_le_add&#10;  simp [h]">
                                                            <OtherNode start="(374, 11)" end="(374, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(374, 11)" end="(374, 12)" kind="patternIgnore">
                                                            <OtherNode start="(374, 11)" end="(374, 12)" kind="token.«· »">
                                                            <AtomNode start="(374, 11)" end="(374, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(374, 13)" end="(379, 21)">
                                                            <TacticTacticseq1IndentedNode start="(374, 13)" end="(379, 21)">
                                                            <NullNode start="(374, 13)" end="(379, 21)">
                                                            <OtherNode start="(374, 13)" end="(374, 21)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_le ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)" tactic="apply ih">
                                                            <AtomNode start="(374, 13)" end="(374, 18)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(374, 19)" end="(374, 21)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(375, 13)" end="(375, 37)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;⊢ denote_le ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂" tactic="simp [denote_le] at h |-">
                                                            <AtomNode start="(375, 13)" end="(375, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(375, 18)" end="(375, 29)">
                                                            <AtomNode start="(375, 18)" end="(375, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(375, 19)" end="(375, 28)">
                                                            <OtherNode start="(375, 19)" end="(375, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(375, 19)" end="(375, 28)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(375, 28)" end="(375, 29)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(375, 30)" end="(375, 37)">
                                                            <OtherNode start="(375, 30)" end="(375, 37)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(375, 30)" end="(375, 32)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(375, 33)" end="(375, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(375, 33)" end="(375, 37)">
                                                            <IdentNode start="(375, 33)" end="(375, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(375, 35)" end="(375, 37)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(375, 35)" end="(375, 37)" kind="patternIgnore">
                                                            <GroupNode start="(375, 35)" end="(375, 37)">
                                                            <AtomNode start="(375, 35)" end="(375, 36)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(375, 36)" end="(375, 37)" leading="" trailing="&#10;            " val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(376, 13)" end="(376, 134)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂" tactic="have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))">
                                                            <AtomNode start="(376, 13)" end="(376, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(376, 18)" end="(376, 134)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(376, 18)" end="(376, 134)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(376, 18)" end="(376, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(376, 18)" end="(376, 22)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(376, 23)" end="(376, 72)">
                                                            <TermTypespecNode start="(376, 23)" end="(376, 72)">
                                                            <AtomNode start="(376, 23)" end="(376, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(376, 25)" end="(376, 72)" kind="«term_≤_»">
                                                            <OtherNode start="(376, 25)" end="(376, 47)" kind="«term_*_»">
                                                            <IdentNode start="(376, 25)" end="(376, 27)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(376, 28)" end="(376, 29)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(376, 30)" end="(376, 47)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(376, 30)" end="(376, 40)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(376, 41)" end="(376, 47)">
                                                            <IdentNode start="(376, 41)" end="(376, 44)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(376, 45)" end="(376, 47)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(376, 48)" end="(376, 49)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(376, 50)" end="(376, 72)" kind="«term_*_»">
                                                            <IdentNode start="(376, 50)" end="(376, 52)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(376, 53)" end="(376, 54)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(376, 55)" end="(376, 72)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(376, 55)" end="(376, 65)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(376, 66)" end="(376, 72)">
                                                            <IdentNode start="(376, 66)" end="(376, 69)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(376, 70)" end="(376, 72)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(376, 73)" end="(376, 75)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(376, 76)" end="(376, 134)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(376, 76)" end="(376, 96)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(376, 97)" end="(376, 134)">
                                                            <TermHoleNode start="(376, 97)" end="(376, 98)">
                                                            <AtomNode start="(376, 97)" end="(376, 98)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(376, 99)" end="(376, 134)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(376, 99)" end="(376, 100)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(376, 100)" end="(376, 133)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(376, 100)" end="(376, 112)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(376, 113)" end="(376, 133)">
                                                            <OtherNode start="(376, 113)" end="(376, 133)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(376, 113)" end="(376, 114)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(376, 114)" end="(376, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(376, 114)" end="(376, 127)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(376, 128)" end="(376, 132)">
                                                            <IdentNode start="(376, 128)" end="(376, 132)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(376, 132)" end="(376, 133)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(376, 133)" end="(376, 134)" leading="" trailing="&#10;            " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(377, 13)" end="(377, 86)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂" state_after="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux]">
                                                            <AtomNode start="(377, 13)" end="(377, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(377, 16)" end="(377, 86)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(377, 16)" end="(377, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(377, 17)" end="(377, 85)">
                                                            <OtherNode start="(377, 17)" end="(377, 42)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(377, 17)" end="(377, 42)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(377, 42)" end="(377, 43)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(377, 44)" end="(377, 59)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(377, 44)" end="(377, 45)">
                                                            <OtherNode start="(377, 44)" end="(377, 45)" kind="patternIgnore">
                                                            <OtherNode start="(377, 44)" end="(377, 45)" kind="token.«← »">
                                                            <AtomNode start="(377, 44)" end="(377, 45)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(377, 46)" end="(377, 59)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(377, 59)" end="(377, 60)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(377, 61)" end="(377, 85)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(377, 61)" end="(377, 62)">
                                                            <OtherNode start="(377, 61)" end="(377, 62)" kind="patternIgnore">
                                                            <OtherNode start="(377, 61)" end="(377, 62)" kind="token.«← »">
                                                            <AtomNode start="(377, 61)" end="(377, 62)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(377, 63)" end="(377, 85)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(377, 63)" end="(377, 80)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(377, 81)" end="(377, 85)">
                                                            <IdentNode start="(377, 81)" end="(377, 85)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(377, 85)" end="(377, 86)" leading="" trailing="&#10;            " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(378, 13)" end="(378, 39)" kind="Lean.Parser.Tactic.apply" state_before="case pos.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂" state_after="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁" tactic="apply Nat.sub_le_of_le_add">
                                                            <AtomNode start="(378, 13)" end="(378, 18)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(378, 19)" end="(378, 39)" leading="" trailing="&#10;            " raw_val="Nat.sub_le_of_le_add" val="Nat.sub_le_of_le_add" full_name="Nat.sub_le_of_le_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(379, 13)" end="(379, 21)" kind="Lean.Parser.Tactic.simp" state_before="case pos.h.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁" state_after="no goals" tactic="simp [h]">
                                                            <AtomNode start="(379, 13)" end="(379, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(379, 18)" end="(379, 21)">
                                                            <AtomNode start="(379, 18)" end="(379, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(379, 19)" end="(379, 20)">
                                                            <OtherNode start="(379, 19)" end="(379, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(379, 19)" end="(379, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(379, 20)" end="(379, 21)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(380, 11)" end="(384, 47)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="no goals" tactic="· have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;  apply ih&#10;  simp [denote_le] at h |-&#10;  rw [← Nat.add_assoc, ← Nat.add_assoc] at h&#10;  apply Nat.le_of_add_le_add_right h">
                                                            <OtherNode start="(380, 11)" end="(380, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(380, 11)" end="(380, 12)" kind="patternIgnore">
                                                            <OtherNode start="(380, 11)" end="(380, 12)" kind="token.«· »">
                                                            <AtomNode start="(380, 11)" end="(380, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(380, 13)" end="(384, 47)">
                                                            <TacticTacticseq1IndentedNode start="(380, 13)" end="(384, 47)">
                                                            <NullNode start="(380, 13)" end="(384, 47)">
                                                            <OtherNode start="(380, 13)" end="(380, 67)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;heqk : k₁ = k₂&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk">
                                                            <AtomNode start="(380, 13)" end="(380, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(380, 18)" end="(380, 67)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(380, 18)" end="(380, 67)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(380, 18)" end="(380, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(380, 18)" end="(380, 22)" leading="" trailing=" " raw_val="heqk" val="heqk"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(380, 23)" end="(380, 32)">
                                                            <TermTypespecNode start="(380, 23)" end="(380, 32)">
                                                            <AtomNode start="(380, 23)" end="(380, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(380, 25)" end="(380, 32)" kind="«term_=_»">
                                                            <IdentNode start="(380, 25)" end="(380, 27)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(380, 28)" end="(380, 29)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(380, 30)" end="(380, 32)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(380, 33)" end="(380, 35)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(380, 36)" end="(380, 67)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(380, 36)" end="(380, 57)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(380, 58)" end="(380, 67)">
                                                            <IdentNode start="(380, 58)" end="(380, 62)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                            <IdentNode start="(380, 63)" end="(380, 67)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(380, 67)" end="(380, 68)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(380, 69)" end="(380, 79)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;heqk : k₁ = k₂&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" tactic="subst heqk">
                                                            <AtomNode start="(380, 69)" end="(380, 74)" leading="" trailing=" " val="subst"/>
                                                            <NullNode start="(380, 75)" end="(380, 79)">
                                                            <IdentNode start="(380, 75)" end="(380, 79)" leading="" trailing="&#10;            " raw_val="heqk" val="heqk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(381, 13)" end="(381, 21)" kind="Lean.Parser.Tactic.apply" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)" state_after="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" tactic="apply ih">
                                                            <AtomNode start="(381, 13)" end="(381, 18)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(381, 19)" end="(381, 21)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(382, 13)" end="(382, 37)" kind="Lean.Parser.Tactic.simp" state_before="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂" tactic="simp [denote_le] at h |-">
                                                            <AtomNode start="(382, 13)" end="(382, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(382, 18)" end="(382, 29)">
                                                            <AtomNode start="(382, 18)" end="(382, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(382, 19)" end="(382, 28)">
                                                            <OtherNode start="(382, 19)" end="(382, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(382, 19)" end="(382, 28)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(382, 28)" end="(382, 29)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(382, 30)" end="(382, 37)">
                                                            <OtherNode start="(382, 30)" end="(382, 37)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(382, 30)" end="(382, 32)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(382, 33)" end="(382, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(382, 33)" end="(382, 37)">
                                                            <IdentNode start="(382, 33)" end="(382, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(382, 35)" end="(382, 37)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(382, 35)" end="(382, 37)" kind="patternIgnore">
                                                            <GroupNode start="(382, 35)" end="(382, 37)">
                                                            <AtomNode start="(382, 35)" end="(382, 36)" leading="" trailing="" val="|"/>
                                                            <AtomNode start="(382, 36)" end="(382, 37)" leading="" trailing="&#10;            " val="-"/>
                                                            </GroupNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(383, 13)" end="(383, 55)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂" state_after="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂" tactic="rw [← Nat.add_assoc, ← Nat.add_assoc] at h">
                                                            <AtomNode start="(383, 13)" end="(383, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(383, 16)" end="(383, 50)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(383, 16)" end="(383, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(383, 17)" end="(383, 49)">
                                                            <OtherNode start="(383, 17)" end="(383, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(383, 17)" end="(383, 18)">
                                                            <OtherNode start="(383, 17)" end="(383, 18)" kind="patternIgnore">
                                                            <OtherNode start="(383, 17)" end="(383, 18)" kind="token.«← »">
                                                            <AtomNode start="(383, 17)" end="(383, 18)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(383, 19)" end="(383, 32)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(383, 32)" end="(383, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(383, 34)" end="(383, 49)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(383, 34)" end="(383, 35)">
                                                            <OtherNode start="(383, 34)" end="(383, 35)" kind="patternIgnore">
                                                            <OtherNode start="(383, 34)" end="(383, 35)" kind="token.«← »">
                                                            <AtomNode start="(383, 34)" end="(383, 35)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(383, 36)" end="(383, 49)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(383, 49)" end="(383, 50)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(383, 51)" end="(383, 55)">
                                                            <OtherNode start="(383, 51)" end="(383, 55)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(383, 51)" end="(383, 53)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(383, 54)" end="(383, 55)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(383, 54)" end="(383, 55)">
                                                            <IdentNode start="(383, 54)" end="(383, 55)" leading="" trailing="&#10;            " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(384, 13)" end="(384, 47)" kind="Lean.Parser.Tactic.apply" state_before="case neg.h&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) → denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;h : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂" state_after="no goals" tactic="apply Nat.le_of_add_le_add_right h">
                                                            <AtomNode start="(384, 13)" end="(384, 18)" leading="" trailing=" " val="apply"/>
                                                            <OtherNode start="(384, 19)" end="(384, 47)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(384, 19)" end="(384, 45)" leading="" trailing=" " raw_val="Nat.le_of_add_le_add_right" val="Nat.le_of_add_le_add_right" full_name="Nat.le_of_add_le_add_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(384, 46)" end="(384, 47)">
                                                            <IdentNode start="(384, 46)" end="(384, 47)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(385, 5)" end="(385, 9)" kind="Lean.Parser.Tactic.done">
                                      <AtomNode start="(385, 5)" end="(385, 9)" leading="" trailing="&#10;&#10;" val="done"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(387, 1)" end="(418, 23)" name="Poly.of_denote_le_cancelAux" full_name="Nat.Linear.Poly.of_denote_le_cancelAux">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(387, 1)" end="(418, 23)" name="Poly.of_denote_le_cancelAux" full_name="Nat.Linear.Poly.of_denote_le_cancelAux" _is_private_decl="False">
        <AtomNode start="(387, 1)" end="(387, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(387, 9)" end="(387, 36)">
          <IdentNode start="(387, 9)" end="(387, 36)" leading="" trailing=" " raw_val="Poly.of_denote_le_cancelAux" val="Poly.of_denote_le_cancelAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(387, 37)" end="(388, 106)">
          <NullNode start="(387, 37)" end="(388, 53)">
            <TermExplicitbinderNode start="(387, 37)" end="(387, 52)">
              <AtomNode start="(387, 37)" end="(387, 38)" leading="" trailing="" val="("/>
              <NullNode start="(387, 38)" end="(387, 41)">
                <IdentNode start="(387, 38)" end="(387, 41)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(387, 42)" end="(387, 51)">
                <AtomNode start="(387, 42)" end="(387, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(387, 44)" end="(387, 51)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(387, 51)" end="(387, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(387, 53)" end="(387, 65)">
              <AtomNode start="(387, 53)" end="(387, 54)" leading="" trailing="" val="("/>
              <NullNode start="(387, 54)" end="(387, 58)">
                <IdentNode start="(387, 54)" end="(387, 58)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
              </NullNode>
              <NullNode start="(387, 59)" end="(387, 64)">
                <AtomNode start="(387, 59)" end="(387, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(387, 61)" end="(387, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(387, 64)" end="(387, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(387, 66)" end="(387, 86)">
              <AtomNode start="(387, 66)" end="(387, 67)" leading="" trailing="" val="("/>
              <NullNode start="(387, 67)" end="(387, 78)">
                <IdentNode start="(387, 67)" end="(387, 69)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(387, 70)" end="(387, 72)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                <IdentNode start="(387, 73)" end="(387, 75)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                <IdentNode start="(387, 76)" end="(387, 78)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
              </NullNode>
              <NullNode start="(387, 79)" end="(387, 85)">
                <AtomNode start="(387, 79)" end="(387, 80)" leading="" trailing=" " val=":"/>
                <IdentNode start="(387, 81)" end="(387, 85)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(387, 85)" end="(387, 86)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(388, 5)" end="(388, 53)">
              <AtomNode start="(388, 5)" end="(388, 6)" leading="" trailing="" val="("/>
              <NullNode start="(388, 6)" end="(388, 7)">
                <IdentNode start="(388, 6)" end="(388, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(388, 8)" end="(388, 52)">
                <AtomNode start="(388, 8)" end="(388, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 10)" end="(388, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(388, 10)" end="(388, 19)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                  <NullNode start="(388, 20)" end="(388, 52)">
                    <IdentNode start="(388, 20)" end="(388, 23)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(388, 24)" end="(388, 52)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(388, 24)" end="(388, 25)" leading="" trailing="" val="("/>
                      <OtherNode start="(388, 25)" end="(388, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(388, 25)" end="(388, 34)" leading="" trailing=" " raw_val="cancelAux" val="cancelAux" full_name="Nat.Linear.Poly.cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(71, 5)" def_end="(71, 19)"/>
                        <NullNode start="(388, 35)" end="(388, 51)">
                          <IdentNode start="(388, 35)" end="(388, 39)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                          <IdentNode start="(388, 40)" end="(388, 42)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                          <IdentNode start="(388, 43)" end="(388, 45)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                          <IdentNode start="(388, 46)" end="(388, 48)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                          <IdentNode start="(388, 49)" end="(388, 51)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(388, 51)" end="(388, 52)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(388, 52)" end="(388, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(388, 54)" end="(388, 106)">
            <AtomNode start="(388, 54)" end="(388, 55)" leading="" trailing=" " val=":"/>
            <OtherNode start="(388, 56)" end="(388, 106)" kind="Lean.Parser.Term.app">
              <IdentNode start="(388, 56)" end="(388, 65)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
              <NullNode start="(388, 66)" end="(388, 106)">
                <IdentNode start="(388, 66)" end="(388, 69)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(388, 70)" end="(388, 106)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(388, 70)" end="(388, 71)" leading="" trailing="" val="("/>
                  <NullNode start="(388, 71)" end="(388, 105)">
                    <OtherNode start="(388, 71)" end="(388, 87)" kind="«term_++_»">
                      <IdentNode start="(388, 71)" end="(388, 81)" leading="" trailing=" " raw_val="r₁.reverse" val="r₁.reverse"/>
                      <AtomNode start="(388, 82)" end="(388, 84)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(388, 85)" end="(388, 87)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                    </OtherNode>
                    <AtomNode start="(388, 87)" end="(388, 88)" leading="" trailing=" " val=","/>
                    <NullNode start="(388, 89)" end="(388, 105)">
                      <OtherNode start="(388, 89)" end="(388, 105)" kind="«term_++_»">
                        <IdentNode start="(388, 89)" end="(388, 99)" leading="" trailing=" " raw_val="r₂.reverse" val="r₂.reverse"/>
                        <AtomNode start="(388, 100)" end="(388, 102)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(388, 103)" end="(388, 105)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(388, 105)" end="(388, 106)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(388, 107)" end="(418, 23)">
          <AtomNode start="(388, 107)" end="(388, 109)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(388, 110)" end="(418, 23)">
            <AtomNode start="(388, 110)" end="(388, 112)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(389, 3)" end="(418, 23)">
              <TacticTacticseq1IndentedNode start="(389, 3)" end="(418, 23)">
                <NullNode start="(389, 3)" end="(418, 23)">
                  <OtherNode start="(389, 3)" end="(418, 23)" kind="Lean.Parser.Tactic.induction" state_before="ctx : Context&#10;fuel : Nat&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="induction fuel generalizing m₁ m₂ r₁ r₂ with&#10;| zero =&amp;gt; assumption&#10;| succ fuel ih =&amp;gt;&#10;  simp at h&#10;  split at h &amp;lt;;&amp;gt; try (simp; assumption)&#10;  rename_i k₁ v₁ m₁ k₂ v₂ m₂&#10;  by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv] at h&#10;  · have ih := ih (h := h); simp [denote_le] at ih ⊢; assumption&#10;  · by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv] at h&#10;    · have ih := ih (h := h); simp [denote_le] at ih ⊢; assumption&#10;    · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;      by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h&#10;      · have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;        have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;        have := Nat.add_le_of_le_sub (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;        simp at this&#10;        exact this&#10;      · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;        · have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;          have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;          rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;          have := Nat.le_add_of_sub_le ih&#10;          simp at this&#10;          exact this&#10;        · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;          have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;          have := Nat.add_le_add_right ih (k₁ * Var.denote ctx v₁)&#10;          simp at this&#10;          exact this">
                    <AtomNode start="(389, 3)" end="(389, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(389, 13)" end="(389, 17)">
                      <OtherNode start="(389, 13)" end="(389, 17)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(389, 13)" end="(389, 17)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(389, 18)" end="(389, 42)">
                      <AtomNode start="(389, 18)" end="(389, 30)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(389, 31)" end="(389, 42)">
                        <IdentNode start="(389, 31)" end="(389, 33)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                        <IdentNode start="(389, 34)" end="(389, 36)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
                        <IdentNode start="(389, 37)" end="(389, 39)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                        <IdentNode start="(389, 40)" end="(389, 42)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(389, 43)" end="(418, 23)">
                      <OtherNode start="(389, 43)" end="(418, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(389, 43)" end="(389, 47)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(390, 3)" end="(418, 23)">
                          <OtherNode start="(390, 3)" end="(390, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(390, 3)" end="(390, 9)">
                              <OtherNode start="(390, 3)" end="(390, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(390, 3)" end="(390, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(390, 5)" end="(390, 9)">
                                  <NullNode/>
                                  <IdentNode start="(390, 5)" end="(390, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(390, 10)" end="(390, 23)">
                              <AtomNode start="(390, 10)" end="(390, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(390, 13)" end="(390, 23)">
                                <TacticTacticseq1IndentedNode start="(390, 13)" end="(390, 23)">
                                  <NullNode start="(390, 13)" end="(390, 23)">
                                    <OtherNode start="(390, 13)" end="(390, 23)" kind="Lean.Parser.Tactic.assumption" state_before="case zero&#10;ctx : Context&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (cancelAux 0 m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="assumption">
                                      <AtomNode start="(390, 13)" end="(390, 23)" leading="" trailing="&#10;  " val="assumption"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(391, 3)" end="(418, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(391, 3)" end="(391, 17)">
                              <OtherNode start="(391, 3)" end="(391, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(391, 3)" end="(391, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(391, 5)" end="(391, 9)">
                                  <NullNode/>
                                  <IdentNode start="(391, 5)" end="(391, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(391, 10)" end="(391, 17)">
                                  <IdentNode start="(391, 10)" end="(391, 14)" leading="" trailing=" " raw_val="fuel" val="fuel"/>
                                  <IdentNode start="(391, 15)" end="(391, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(391, 18)" end="(418, 23)">
                              <AtomNode start="(391, 18)" end="(391, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(392, 5)" end="(418, 23)">
                                <TacticTacticseq1IndentedNode start="(392, 5)" end="(418, 23)">
                                  <NullNode start="(392, 5)" end="(418, 23)">
                                    <OtherNode start="(392, 5)" end="(392, 14)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h : denote_le ctx (cancelAux (fuel + 1) m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h :&#10;  denote_le ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" tactic="simp at h">
                                      <AtomNode start="(392, 5)" end="(392, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(392, 10)" end="(392, 14)">
                                        <OtherNode start="(392, 10)" end="(392, 14)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(392, 10)" end="(392, 12)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(392, 13)" end="(392, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(392, 13)" end="(392, 14)">
                                              <IdentNode start="(392, 13)" end="(392, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(393, 5)" end="(393, 42)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₁ m₂ r₁ r₂ : Poly&#10;h :&#10;  denote_le ctx&#10;    (match m₁, m₂ with&#10;    | m₁, [] =&amp;gt; (List.reverse r₁ ++ m₁, List.reverse r₂)&#10;    | [], m₂ =&amp;gt; (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;    | (k₁, v₁) :: m₁, (k₂, v₂) :: m₂ =&amp;gt;&#10;      bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;      else&#10;        bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;        else&#10;          bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;          else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)" tactic="split at h &amp;lt;;&amp;gt; try (simp; assumption)">
                                      <OtherNode start="(393, 5)" end="(393, 15)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(393, 5)" end="(393, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode start="(393, 11)" end="(393, 15)">
                                          <OtherNode start="(393, 11)" end="(393, 15)" kind="Lean.Parser.Tactic.location">
                                            <AtomNode start="(393, 11)" end="(393, 13)" leading="" trailing=" " val="at"/>
                                            <OtherNode start="(393, 14)" end="(393, 15)" kind="Lean.Parser.Tactic.locationHyp">
                                              <NullNode start="(393, 14)" end="(393, 15)">
                                                <IdentNode start="(393, 14)" end="(393, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(393, 16)" end="(393, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(393, 20)" end="(393, 42)" kind="Lean.Parser.Tactic.tacticTry_">
                                        <AtomNode start="(393, 20)" end="(393, 23)" leading="" trailing=" " val="try"/>
                                        <TacticTacticseqNode start="(393, 24)" end="(393, 42)">
                                          <TacticTacticseq1IndentedNode start="(393, 24)" end="(393, 42)">
                                            <NullNode start="(393, 24)" end="(393, 42)">
                                              <OtherNode start="(393, 24)" end="(393, 42)" kind="Lean.Parser.Tactic.paren" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)" state_after="no goals" tactic="(simp; assumption)">
                                                <AtomNode start="(393, 24)" end="(393, 25)" leading="" trailing="" val="("/>
                                                <TacticTacticseqNode start="(393, 25)" end="(393, 41)">
                                                  <TacticTacticseq1IndentedNode start="(393, 25)" end="(393, 41)">
                                                    <NullNode start="(393, 25)" end="(393, 41)">
                                                      <OtherNode start="(393, 25)" end="(393, 29)" kind="Lean.Parser.Tactic.simp" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ [], List.reverse r₂ ++ m₂)" state_after="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" tactic="simp">
                                                        <AtomNode start="(393, 25)" end="(393, 29)" leading="" trailing="" val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(393, 29)" end="(393, 30)" leading="" trailing=" " val=";"/>
                                                      <OtherNode start="(393, 31)" end="(393, 41)" kind="Lean.Parser.Tactic.assumption" state_before="case succ.h_2&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;m₂ r₁ r₂ m₁✝ m₂✝ : Poly&#10;x✝ : m₂ = [] → False&#10;h : denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁, List.reverse r₂ ++ m₂)" state_after="no goals" tactic="assumption">
                                                        <AtomNode start="(393, 31)" end="(393, 41)" leading="" trailing="" val="assumption"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                                <AtomNode start="(393, 41)" end="(393, 42)" leading="" trailing="&#10;    " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(394, 5)" end="(394, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝¹ m₂✝¹ : Poly&#10;k₁✝ : Nat&#10;v₁✝ : Var&#10;m₁✝ : List (Nat × Var)&#10;k₂✝ : Nat&#10;v₂✝ : Var&#10;m₂✝ : List (Nat × Var)&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₁✝ v₂✝ then cancelAux fuel m₁✝ ((k₂✝, v₂✝) :: m₂✝) ((k₁✝, v₁✝) :: r₁) r₂&#10;    else&#10;      bif blt v₂✝ v₁✝ then cancelAux fuel ((k₁✝, v₁✝) :: m₁✝) m₂✝ r₁ ((k₂✝, v₂✝) :: r₂)&#10;      else&#10;        bif k₁✝.blt k₂✝ then cancelAux fuel m₁✝ m₂✝ r₁ ((k₂✝ - k₁✝, v₁✝) :: r₂)&#10;        else bif k₂✝.blt k₁✝ then cancelAux fuel m₁✝ m₂✝ ((k₁✝ - k₂✝, v₁✝) :: r₁) r₂ else cancelAux fuel m₁✝ m₂✝ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁✝, v₁✝) :: m₁✝, List.reverse r₂ ++ (k₂✝, v₂✝) :: m₂✝)" state_after="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="rename_i k₁ v₁ m₁ k₂ v₂ m₂">
                                      <AtomNode start="(394, 5)" end="(394, 13)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(394, 14)" end="(394, 31)">
                                        <LeanBinderidentNode start="(394, 14)" end="(394, 16)">
                                          <IdentNode start="(394, 14)" end="(394, 16)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(394, 17)" end="(394, 19)">
                                          <IdentNode start="(394, 17)" end="(394, 19)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(394, 20)" end="(394, 22)">
                                          <IdentNode start="(394, 20)" end="(394, 22)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(394, 23)" end="(394, 25)">
                                          <IdentNode start="(394, 23)" end="(394, 25)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(394, 26)" end="(394, 28)">
                                          <IdentNode start="(394, 26)" end="(394, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(394, 29)" end="(394, 31)">
                                          <IdentNode start="(394, 29)" end="(394, 31)" leading="" trailing="&#10;    " raw_val="m₂" val="m₂"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(395, 5)" end="(395, 55)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ.h_3&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₁ v₂ then cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂&#10;    else&#10;      bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;      else&#10;        bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;        else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="by_cases hltv : Nat.blt v₁ v₂ &amp;lt;;&amp;gt; simp [hltv] at h">
                                      <OtherNode start="(395, 5)" end="(395, 34)" kind="«tacticBy_cases_:_»">
                                        <AtomNode start="(395, 5)" end="(395, 13)" leading="" trailing=" " val="by_cases"/>
                                        <NullNode start="(395, 14)" end="(395, 20)">
                                          <IdentNode start="(395, 14)" end="(395, 18)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                          <AtomNode start="(395, 19)" end="(395, 20)" leading="" trailing=" " val=":"/>
                                        </NullNode>
                                        <OtherNode start="(395, 21)" end="(395, 34)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(395, 21)" end="(395, 28)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          <NullNode start="(395, 29)" end="(395, 34)">
                                            <IdentNode start="(395, 29)" end="(395, 31)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                            <IdentNode start="(395, 32)" end="(395, 34)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(395, 35)" end="(395, 38)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(395, 39)" end="(395, 55)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(395, 39)" end="(395, 43)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(395, 44)" end="(395, 50)">
                                          <AtomNode start="(395, 44)" end="(395, 45)" leading="" trailing="" val="["/>
                                          <NullNode start="(395, 45)" end="(395, 49)">
                                            <OtherNode start="(395, 45)" end="(395, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(395, 45)" end="(395, 49)" leading="" trailing="" raw_val="hltv" val="hltv"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(395, 49)" end="(395, 50)" leading="" trailing=" " val="]"/>
                                        </NullNode>
                                        <NullNode start="(395, 51)" end="(395, 55)">
                                          <OtherNode start="(395, 51)" end="(395, 55)" kind="Lean.Parser.Tactic.location">
                                            <AtomNode start="(395, 51)" end="(395, 53)" leading="" trailing=" " val="at"/>
                                            <OtherNode start="(395, 54)" end="(395, 55)" kind="Lean.Parser.Tactic.locationHyp">
                                              <NullNode start="(395, 54)" end="(395, 55)">
                                                <IdentNode start="(395, 54)" end="(395, 55)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(396, 5)" end="(396, 67)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_le] at ih ⊢; assumption">
                                      <OtherNode start="(396, 5)" end="(396, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(396, 5)" end="(396, 6)" kind="patternIgnore">
                                          <OtherNode start="(396, 5)" end="(396, 6)" kind="token.«· »">
                                            <AtomNode start="(396, 5)" end="(396, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(396, 7)" end="(396, 67)">
                                        <TacticTacticseq1IndentedNode start="(396, 7)" end="(396, 67)">
                                          <NullNode start="(396, 7)" end="(396, 67)">
                                            <OtherNode start="(396, 7)" end="(396, 29)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote_le ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="have ih := ih (h := h)">
                                              <AtomNode start="(396, 7)" end="(396, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(396, 12)" end="(396, 29)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(396, 12)" end="(396, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(396, 12)" end="(396, 14)" kind="Lean.Parser.Term.haveId">
                                                    <IdentNode start="(396, 12)" end="(396, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <AtomNode start="(396, 15)" end="(396, 17)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(396, 18)" end="(396, 29)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(396, 18)" end="(396, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                    <NullNode start="(396, 21)" end="(396, 29)">
                                                      <OtherNode start="(396, 21)" end="(396, 29)" kind="Lean.Parser.Term.namedArgument">
                                                        <AtomNode start="(396, 21)" end="(396, 22)" leading="" trailing="" val="("/>
                                                        <IdentNode start="(396, 22)" end="(396, 23)" leading="" trailing=" " raw_val="h" val="h"/>
                                                        <AtomNode start="(396, 24)" end="(396, 26)" leading="" trailing=" " val=":="/>
                                                        <IdentNode start="(396, 27)" end="(396, 28)" leading="" trailing="" raw_val="h" val="h"/>
                                                        <AtomNode start="(396, 28)" end="(396, 29)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(396, 29)" end="(396, 30)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(396, 31)" end="(396, 55)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote_le ctx (((k₁, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_le] at ih ⊢">
                                              <AtomNode start="(396, 31)" end="(396, 35)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(396, 36)" end="(396, 47)">
                                                <AtomNode start="(396, 36)" end="(396, 37)" leading="" trailing="" val="["/>
                                                <NullNode start="(396, 37)" end="(396, 46)">
                                                  <OtherNode start="(396, 37)" end="(396, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(396, 37)" end="(396, 46)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(396, 46)" end="(396, 47)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(396, 48)" end="(396, 55)">
                                                <OtherNode start="(396, 48)" end="(396, 55)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(396, 48)" end="(396, 50)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(396, 51)" end="(396, 55)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(396, 51)" end="(396, 55)">
                                                      <IdentNode start="(396, 51)" end="(396, 53)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <OtherNode start="(396, 54)" end="(396, 55)" kind="Lean.Parser.Tactic.locationType">
                                                        <OtherNode start="(396, 54)" end="(396, 55)" kind="patternIgnore">
                                                          <OtherNode start="(396, 54)" end="(396, 55)" kind="token.«⊢»">
                                                            <AtomNode start="(396, 54)" end="(396, 55)" leading="" trailing="" val="⊢"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(396, 55)" end="(396, 56)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(396, 57)" end="(396, 67)" kind="Lean.Parser.Tactic.assumption" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : blt v₁ v₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ ((k₂, v₂) :: m₂) ((k₁, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                              <AtomNode start="(396, 57)" end="(396, 67)" leading="" trailing="&#10;    " val="assumption"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(397, 5)" end="(418, 23)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="no goals" tactic="· by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv] at h&#10;  · have ih := ih (h := h); simp [denote_le] at ih ⊢; assumption&#10;  · have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;    by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h&#10;    · have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;      have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;      have := Nat.add_le_of_le_sub (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;      simp at this&#10;      exact this&#10;    · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;      · have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;        have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;        rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;        have := Nat.le_add_of_sub_le ih&#10;        simp at this&#10;        exact this&#10;      · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;        have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;        have := Nat.add_le_add_right ih (k₁ * Var.denote ctx v₁)&#10;        simp at this&#10;        exact this">
                                      <OtherNode start="(397, 5)" end="(397, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(397, 5)" end="(397, 6)" kind="patternIgnore">
                                          <OtherNode start="(397, 5)" end="(397, 6)" kind="token.«· »">
                                            <AtomNode start="(397, 5)" end="(397, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(397, 7)" end="(418, 23)">
                                        <TacticTacticseq1IndentedNode start="(397, 7)" end="(418, 23)">
                                          <NullNode start="(397, 7)" end="(418, 23)">
                                            <OtherNode start="(397, 7)" end="(397, 57)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;h :&#10;  denote_le ctx&#10;    (bif blt v₂ v₁ then cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂)&#10;    else&#10;      bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;      else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="by_cases hgtv : Nat.blt v₂ v₁ &amp;lt;;&amp;gt; simp [hgtv] at h">
                                              <OtherNode start="(397, 7)" end="(397, 36)" kind="«tacticBy_cases_:_»">
                                                <AtomNode start="(397, 7)" end="(397, 15)" leading="" trailing=" " val="by_cases"/>
                                                <NullNode start="(397, 16)" end="(397, 22)">
                                                  <IdentNode start="(397, 16)" end="(397, 20)" leading="" trailing=" " raw_val="hgtv" val="hgtv"/>
                                                  <AtomNode start="(397, 21)" end="(397, 22)" leading="" trailing=" " val=":"/>
                                                </NullNode>
                                                <OtherNode start="(397, 23)" end="(397, 36)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(397, 23)" end="(397, 30)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  <NullNode start="(397, 31)" end="(397, 36)">
                                                    <IdentNode start="(397, 31)" end="(397, 33)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                    <IdentNode start="(397, 34)" end="(397, 36)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(397, 37)" end="(397, 40)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(397, 41)" end="(397, 57)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(397, 41)" end="(397, 45)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(397, 46)" end="(397, 52)">
                                                  <AtomNode start="(397, 46)" end="(397, 47)" leading="" trailing="" val="["/>
                                                  <NullNode start="(397, 47)" end="(397, 51)">
                                                    <OtherNode start="(397, 47)" end="(397, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(397, 47)" end="(397, 51)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(397, 51)" end="(397, 52)" leading="" trailing=" " val="]"/>
                                                </NullNode>
                                                <NullNode start="(397, 53)" end="(397, 57)">
                                                  <OtherNode start="(397, 53)" end="(397, 57)" kind="Lean.Parser.Tactic.location">
                                                    <AtomNode start="(397, 53)" end="(397, 55)" leading="" trailing=" " val="at"/>
                                                    <OtherNode start="(397, 56)" end="(397, 57)" kind="Lean.Parser.Tactic.locationHyp">
                                                      <NullNode start="(397, 56)" end="(397, 57)">
                                                        <IdentNode start="(397, 56)" end="(397, 57)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(398, 7)" end="(398, 69)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_le] at ih ⊢; assumption">
                                              <OtherNode start="(398, 7)" end="(398, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(398, 7)" end="(398, 8)" kind="patternIgnore">
                                                  <OtherNode start="(398, 7)" end="(398, 8)" kind="token.«· »">
                                                    <AtomNode start="(398, 7)" end="(398, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(398, 9)" end="(398, 69)">
                                                <TacticTacticseq1IndentedNode start="(398, 9)" end="(398, 69)">
                                                  <NullNode start="(398, 9)" end="(398, 69)">
                                                    <OtherNode start="(398, 9)" end="(398, 31)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="have ih := ih (h := h)">
                                                      <AtomNode start="(398, 9)" end="(398, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(398, 14)" end="(398, 31)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(398, 14)" end="(398, 31)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(398, 14)" end="(398, 16)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(398, 14)" end="(398, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <AtomNode start="(398, 17)" end="(398, 19)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(398, 20)" end="(398, 31)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(398, 20)" end="(398, 22)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(398, 23)" end="(398, 31)">
                                                            <OtherNode start="(398, 23)" end="(398, 31)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(398, 23)" end="(398, 24)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(398, 24)" end="(398, 25)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(398, 26)" end="(398, 28)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(398, 29)" end="(398, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(398, 30)" end="(398, 31)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(398, 31)" end="(398, 32)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(398, 33)" end="(398, 57)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, ((k₂, v₂) :: r₂).reverse ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" tactic="simp [denote_le] at ih ⊢">
                                                      <AtomNode start="(398, 33)" end="(398, 37)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(398, 38)" end="(398, 49)">
                                                        <AtomNode start="(398, 38)" end="(398, 39)" leading="" trailing="" val="["/>
                                                        <NullNode start="(398, 39)" end="(398, 48)">
                                                          <OtherNode start="(398, 39)" end="(398, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(398, 39)" end="(398, 48)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(398, 48)" end="(398, 49)" leading="" trailing=" " val="]"/>
                                                      </NullNode>
                                                      <NullNode start="(398, 50)" end="(398, 57)">
                                                        <OtherNode start="(398, 50)" end="(398, 57)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(398, 50)" end="(398, 52)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(398, 53)" end="(398, 57)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(398, 53)" end="(398, 57)">
                                                            <IdentNode start="(398, 53)" end="(398, 55)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(398, 56)" end="(398, 57)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(398, 56)" end="(398, 57)" kind="patternIgnore">
                                                            <OtherNode start="(398, 56)" end="(398, 57)" kind="token.«⊢»">
                                                            <AtomNode start="(398, 56)" end="(398, 57)" leading="" trailing="" val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(398, 57)" end="(398, 58)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(398, 59)" end="(398, 69)" kind="Lean.Parser.Tactic.assumption" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : blt v₂ v₁ = true&#10;h : denote_le ctx (cancelAux fuel ((k₁, v₁) :: m₁) m₂ r₁ ((k₂, v₂) :: r₂))&#10;ih : denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₂)" state_after="no goals" tactic="assumption">
                                                      <AtomNode start="(398, 59)" end="(398, 69)" leading="" trailing="&#10;      " val="assumption"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(399, 7)" end="(418, 23)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="no goals" tactic="· have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv; subst heqv&#10;  by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h&#10;  · have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;    have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;    have := Nat.add_le_of_le_sub (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;    simp at this&#10;    exact this&#10;  · by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;    · have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;      have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;      rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;      have := Nat.le_add_of_sub_le ih&#10;      simp at this&#10;      exact this&#10;    · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;      have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;      have := Nat.add_le_add_right ih (k₁ * Var.denote ctx v₁)&#10;      simp at this&#10;      exact this">
                                              <OtherNode start="(399, 7)" end="(399, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(399, 7)" end="(399, 8)" kind="patternIgnore">
                                                  <OtherNode start="(399, 7)" end="(399, 8)" kind="token.«· »">
                                                    <AtomNode start="(399, 7)" end="(399, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(399, 9)" end="(418, 23)">
                                                <TacticTacticseq1IndentedNode start="(399, 9)" end="(418, 23)">
                                                  <NullNode start="(399, 9)" end="(418, 23)">
                                                    <OtherNode start="(399, 9)" end="(399, 63)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqv : v₁ = v₂&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" tactic="have heqv : v₁ = v₂ := eq_of_not_blt_eq_true hltv hgtv">
                                                      <AtomNode start="(399, 9)" end="(399, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(399, 14)" end="(399, 63)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(399, 14)" end="(399, 63)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(399, 14)" end="(399, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(399, 14)" end="(399, 18)" leading="" trailing=" " raw_val="heqv" val="heqv"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(399, 19)" end="(399, 28)">
                                                            <TermTypespecNode start="(399, 19)" end="(399, 28)">
                                                            <AtomNode start="(399, 19)" end="(399, 20)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(399, 21)" end="(399, 28)" kind="«term_=_»">
                                                            <IdentNode start="(399, 21)" end="(399, 23)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            <AtomNode start="(399, 24)" end="(399, 25)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(399, 26)" end="(399, 28)" leading="" trailing=" " raw_val="v₂" val="v₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                          </NullNode>
                                                          <AtomNode start="(399, 29)" end="(399, 31)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(399, 32)" end="(399, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(399, 32)" end="(399, 53)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(399, 54)" end="(399, 63)">
                                                            <IdentNode start="(399, 54)" end="(399, 58)" leading="" trailing=" " raw_val="hltv" val="hltv"/>
                                                            <IdentNode start="(399, 59)" end="(399, 63)" leading="" trailing="" raw_val="hgtv" val="hgtv"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(399, 63)" end="(399, 64)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(399, 65)" end="(399, 75)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;v₂ : Var&#10;m₂ : List (Nat × Var)&#10;hltv : ¬blt v₁ v₂ = true&#10;hgtv : ¬blt v₂ v₁ = true&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqv : v₁ = v₂&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₂) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="subst heqv">
                                                      <AtomNode start="(399, 65)" end="(399, 70)" leading="" trailing=" " val="subst"/>
                                                      <NullNode start="(399, 71)" end="(399, 75)">
                                                        <IdentNode start="(399, 71)" end="(399, 75)" leading="" trailing="&#10;        " raw_val="heqv" val="heqv"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(400, 9)" end="(400, 59)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;h :&#10;  denote_le ctx&#10;    (bif k₁.blt k₂ then cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂)&#10;    else bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="by_cases hltk : Nat.blt k₁ k₂ &amp;lt;;&amp;gt; simp [hltk] at h">
                                                      <OtherNode start="(400, 9)" end="(400, 38)" kind="«tacticBy_cases_:_»">
                                                        <AtomNode start="(400, 9)" end="(400, 17)" leading="" trailing=" " val="by_cases"/>
                                                        <NullNode start="(400, 18)" end="(400, 24)">
                                                          <IdentNode start="(400, 18)" end="(400, 22)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                          <AtomNode start="(400, 23)" end="(400, 24)" leading="" trailing=" " val=":"/>
                                                        </NullNode>
                                                        <OtherNode start="(400, 25)" end="(400, 38)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(400, 25)" end="(400, 32)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          <NullNode start="(400, 33)" end="(400, 38)">
                                                            <IdentNode start="(400, 33)" end="(400, 35)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <IdentNode start="(400, 36)" end="(400, 38)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(400, 39)" end="(400, 42)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                      <OtherNode start="(400, 43)" end="(400, 59)" kind="Lean.Parser.Tactic.simp">
                                                        <AtomNode start="(400, 43)" end="(400, 47)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(400, 48)" end="(400, 54)">
                                                          <AtomNode start="(400, 48)" end="(400, 49)" leading="" trailing="" val="["/>
                                                          <NullNode start="(400, 49)" end="(400, 53)">
                                                            <OtherNode start="(400, 49)" end="(400, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(400, 49)" end="(400, 53)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(400, 53)" end="(400, 54)" leading="" trailing=" " val="]"/>
                                                        </NullNode>
                                                        <NullNode start="(400, 55)" end="(400, 59)">
                                                          <OtherNode start="(400, 55)" end="(400, 59)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(400, 55)" end="(400, 57)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(400, 58)" end="(400, 59)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(400, 58)" end="(400, 59)">
                                                            <IdentNode start="(400, 58)" end="(400, 59)" leading="" trailing="&#10;        " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(401, 9)" end="(406, 21)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;  have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;  have := Nat.add_le_of_le_sub (Nat.le_trans haux (Nat.le_add_left ..)) ih&#10;  simp at this&#10;  exact this">
                                                      <OtherNode start="(401, 9)" end="(401, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(401, 9)" end="(401, 10)" kind="patternIgnore">
                                                          <OtherNode start="(401, 9)" end="(401, 10)" kind="token.«· »">
                                                            <AtomNode start="(401, 9)" end="(401, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(401, 11)" end="(406, 21)">
                                                        <TacticTacticseq1IndentedNode start="(401, 11)" end="(406, 21)">
                                                          <NullNode start="(401, 11)" end="(406, 21)">
                                                            <OtherNode start="(401, 11)" end="(401, 33)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote_le ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="have ih := ih (h := h)">
                                                            <AtomNode start="(401, 11)" end="(401, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(401, 16)" end="(401, 33)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(401, 16)" end="(401, 33)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(401, 16)" end="(401, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(401, 16)" end="(401, 18)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(401, 19)" end="(401, 21)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(401, 22)" end="(401, 33)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(401, 22)" end="(401, 24)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(401, 25)" end="(401, 33)">
                                                            <OtherNode start="(401, 25)" end="(401, 33)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(401, 25)" end="(401, 26)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(401, 26)" end="(401, 27)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(401, 28)" end="(401, 30)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(401, 31)" end="(401, 32)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(401, 32)" end="(401, 33)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(401, 33)" end="(401, 34)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(401, 35)" end="(401, 59)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote_le ctx (List.reverse r₁ ++ m₁, ((k₂ - k₁, v₁) :: r₂).reverse ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp [denote_le] at ih ⊢">
                                                            <AtomNode start="(401, 35)" end="(401, 39)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(401, 40)" end="(401, 51)">
                                                            <AtomNode start="(401, 40)" end="(401, 41)" leading="" trailing="" val="["/>
                                                            <NullNode start="(401, 41)" end="(401, 50)">
                                                            <OtherNode start="(401, 41)" end="(401, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(401, 41)" end="(401, 50)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(401, 50)" end="(401, 51)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(401, 52)" end="(401, 59)">
                                                            <OtherNode start="(401, 52)" end="(401, 59)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(401, 52)" end="(401, 54)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(401, 55)" end="(401, 59)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(401, 55)" end="(401, 59)">
                                                            <IdentNode start="(401, 55)" end="(401, 57)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(401, 58)" end="(401, 59)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(401, 58)" end="(401, 59)" kind="patternIgnore">
                                                            <OtherNode start="(401, 58)" end="(401, 59)" kind="token.«⊢»">
                                                            <AtomNode start="(401, 58)" end="(401, 59)" leading="" trailing="&#10;          " val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(402, 11)" end="(402, 132)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hltk))">
                                                            <AtomNode start="(402, 11)" end="(402, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(402, 16)" end="(402, 132)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(402, 16)" end="(402, 132)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(402, 16)" end="(402, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(402, 16)" end="(402, 20)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(402, 21)" end="(402, 70)">
                                                            <TermTypespecNode start="(402, 21)" end="(402, 70)">
                                                            <AtomNode start="(402, 21)" end="(402, 22)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(402, 23)" end="(402, 70)" kind="«term_≤_»">
                                                            <OtherNode start="(402, 23)" end="(402, 45)" kind="«term_*_»">
                                                            <IdentNode start="(402, 23)" end="(402, 25)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(402, 26)" end="(402, 27)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(402, 28)" end="(402, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(402, 28)" end="(402, 38)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(402, 39)" end="(402, 45)">
                                                            <IdentNode start="(402, 39)" end="(402, 42)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(402, 43)" end="(402, 45)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(402, 46)" end="(402, 47)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(402, 48)" end="(402, 70)" kind="«term_*_»">
                                                            <IdentNode start="(402, 48)" end="(402, 50)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(402, 51)" end="(402, 52)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(402, 53)" end="(402, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(402, 53)" end="(402, 63)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(402, 64)" end="(402, 70)">
                                                            <IdentNode start="(402, 64)" end="(402, 67)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(402, 68)" end="(402, 70)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(402, 71)" end="(402, 73)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(402, 74)" end="(402, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(402, 74)" end="(402, 94)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(402, 95)" end="(402, 132)">
                                                            <TermHoleNode start="(402, 95)" end="(402, 96)">
                                                            <AtomNode start="(402, 95)" end="(402, 96)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(402, 97)" end="(402, 132)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(402, 97)" end="(402, 98)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(402, 98)" end="(402, 131)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(402, 98)" end="(402, 110)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(402, 111)" end="(402, 131)">
                                                            <OtherNode start="(402, 111)" end="(402, 131)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(402, 111)" end="(402, 112)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(402, 112)" end="(402, 130)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(402, 112)" end="(402, 125)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(402, 126)" end="(402, 130)">
                                                            <IdentNode start="(402, 126)" end="(402, 130)" leading="" trailing="" raw_val="hltk" val="hltk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(402, 130)" end="(402, 131)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(402, 131)" end="(402, 132)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(403, 11)" end="(403, 90)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + (denote ctx m₂ + (k₂ - k₁) * Var.denote ctx v₁)&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih">
                                                            <AtomNode start="(403, 11)" end="(403, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(403, 14)" end="(403, 84)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(403, 14)" end="(403, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(403, 15)" end="(403, 83)">
                                                            <OtherNode start="(403, 15)" end="(403, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(403, 15)" end="(403, 40)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(403, 40)" end="(403, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(403, 42)" end="(403, 57)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(403, 42)" end="(403, 43)">
                                                            <OtherNode start="(403, 42)" end="(403, 43)" kind="patternIgnore">
                                                            <OtherNode start="(403, 42)" end="(403, 43)" kind="token.«← »">
                                                            <AtomNode start="(403, 42)" end="(403, 43)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(403, 44)" end="(403, 57)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(403, 57)" end="(403, 58)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(403, 59)" end="(403, 83)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(403, 59)" end="(403, 60)">
                                                            <OtherNode start="(403, 59)" end="(403, 60)" kind="patternIgnore">
                                                            <OtherNode start="(403, 59)" end="(403, 60)" kind="token.«← »">
                                                            <AtomNode start="(403, 59)" end="(403, 60)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(403, 61)" end="(403, 83)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(403, 61)" end="(403, 78)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(403, 79)" end="(403, 83)">
                                                            <IdentNode start="(403, 79)" end="(403, 83)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(403, 83)" end="(403, 84)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(403, 85)" end="(403, 90)">
                                                            <OtherNode start="(403, 85)" end="(403, 90)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(403, 85)" end="(403, 87)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(403, 88)" end="(403, 90)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(403, 88)" end="(403, 90)">
                                                            <IdentNode start="(403, 88)" end="(403, 90)" leading="" trailing="&#10;          " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(404, 11)" end="(404, 83)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;this : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have := Nat.add_le_of_le_sub (Nat.le_trans haux (Nat.le_add_left ..)) ih">
                                                            <AtomNode start="(404, 11)" end="(404, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(404, 16)" end="(404, 83)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(404, 16)" end="(404, 83)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(404, 16)" end="(404, 16)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(404, 16)" end="(404, 16)" kind="hygieneInfo">
                                                            <IdentNode start="(404, 16)" end="(404, 16)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(404, 16)" end="(404, 18)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(404, 19)" end="(404, 83)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(404, 19)" end="(404, 39)" leading="" trailing=" " raw_val="Nat.add_le_of_le_sub" val="Nat.add_le_of_le_sub" full_name="Nat.add_le_of_le_sub" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(404, 40)" end="(404, 83)">
                                                            <OtherNode start="(404, 40)" end="(404, 80)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(404, 40)" end="(404, 41)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(404, 41)" end="(404, 79)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(404, 41)" end="(404, 53)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            <NullNode start="(404, 54)" end="(404, 79)">
                                                            <IdentNode start="(404, 54)" end="(404, 58)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            <OtherNode start="(404, 59)" end="(404, 79)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(404, 59)" end="(404, 60)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(404, 60)" end="(404, 78)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(404, 60)" end="(404, 75)" leading="" trailing=" " raw_val="Nat.le_add_left" val="Nat.le_add_left" full_name="Nat.le_add_left" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(404, 76)" end="(404, 78)">
                                                            <OtherNode start="(404, 76)" end="(404, 78)" kind="Lean.Parser.Term.ellipsis">
                                                            <AtomNode start="(404, 76)" end="(404, 78)" leading="" trailing="" val=".."/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(404, 78)" end="(404, 79)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(404, 79)" end="(404, 80)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(404, 81)" end="(404, 83)" leading="" trailing="&#10;          " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(405, 11)" end="(405, 23)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;this : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;this :&#10;  denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp at this">
                                                            <AtomNode start="(405, 11)" end="(405, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(405, 16)" end="(405, 23)">
                                                            <OtherNode start="(405, 16)" end="(405, 23)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(405, 16)" end="(405, 18)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(405, 19)" end="(405, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(405, 19)" end="(405, 23)">
                                                            <IdentNode start="(405, 19)" end="(405, 23)" leading="" trailing="&#10;          " raw_val="this" val="this"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(406, 11)" end="(406, 21)" kind="Lean.Parser.Tactic.exact" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : k₁.blt k₂ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ ((k₂ - k₁, v₁) :: r₂))&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁ - k₁ * Var.denote ctx v₁&#10;haux : k₁ * Var.denote ctx v₁ ≤ k₂ * Var.denote ctx v₁&#10;this :&#10;  denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="no goals" tactic="exact this">
                                                            <AtomNode start="(406, 11)" end="(406, 16)" leading="" trailing=" " val="exact"/>
                                                            <IdentNode start="(406, 17)" end="(406, 21)" leading="" trailing="&#10;        " raw_val="this" val="this"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(407, 9)" end="(418, 23)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="no goals" tactic="· by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h&#10;  · have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;    have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;    rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;    have := Nat.le_add_of_sub_le ih&#10;    simp at this&#10;    exact this&#10;  · have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;    have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;    have := Nat.add_le_add_right ih (k₁ * Var.denote ctx v₁)&#10;    simp at this&#10;    exact this">
                                                      <OtherNode start="(407, 9)" end="(407, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(407, 9)" end="(407, 10)" kind="patternIgnore">
                                                          <OtherNode start="(407, 9)" end="(407, 10)" kind="token.«· »">
                                                            <AtomNode start="(407, 9)" end="(407, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(407, 11)" end="(418, 23)">
                                                        <TacticTacticseq1IndentedNode start="(407, 11)" end="(418, 23)">
                                                          <NullNode start="(407, 11)" end="(418, 23)">
                                                            <OtherNode start="(407, 11)" end="(407, 61)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;h : denote_le ctx (bif k₂.blt k₁ then cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂ else cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="by_cases hgtk : Nat.blt k₂ k₁ &amp;lt;;&amp;gt; simp [hgtk] at h">
                                                            <OtherNode start="(407, 11)" end="(407, 40)" kind="«tacticBy_cases_:_»">
                                                            <AtomNode start="(407, 11)" end="(407, 19)" leading="" trailing=" " val="by_cases"/>
                                                            <NullNode start="(407, 20)" end="(407, 26)">
                                                            <IdentNode start="(407, 20)" end="(407, 24)" leading="" trailing=" " raw_val="hgtk" val="hgtk"/>
                                                            <AtomNode start="(407, 25)" end="(407, 26)" leading="" trailing=" " val=":"/>
                                                            </NullNode>
                                                            <OtherNode start="(407, 27)" end="(407, 40)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(407, 27)" end="(407, 34)" leading="" trailing=" " raw_val="Nat.blt" val="Nat.blt" full_name="Nat.blt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(407, 35)" end="(407, 40)">
                                                            <IdentNode start="(407, 35)" end="(407, 37)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <IdentNode start="(407, 38)" end="(407, 40)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(407, 41)" end="(407, 44)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                            <OtherNode start="(407, 45)" end="(407, 61)" kind="Lean.Parser.Tactic.simp">
                                                            <AtomNode start="(407, 45)" end="(407, 49)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(407, 50)" end="(407, 56)">
                                                            <AtomNode start="(407, 50)" end="(407, 51)" leading="" trailing="" val="["/>
                                                            <NullNode start="(407, 51)" end="(407, 55)">
                                                            <OtherNode start="(407, 51)" end="(407, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(407, 51)" end="(407, 55)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(407, 55)" end="(407, 56)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(407, 57)" end="(407, 61)">
                                                            <OtherNode start="(407, 57)" end="(407, 61)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(407, 57)" end="(407, 59)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(407, 60)" end="(407, 61)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(407, 60)" end="(407, 61)">
                                                            <IdentNode start="(407, 60)" end="(407, 61)" leading="" trailing="&#10;          " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(408, 11)" end="(413, 23)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)&#10;&#10;case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="· have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;  have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))&#10;  rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih&#10;  have := Nat.le_add_of_sub_le ih&#10;  simp at this&#10;  exact this">
                                                            <OtherNode start="(408, 11)" end="(408, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(408, 11)" end="(408, 12)" kind="patternIgnore">
                                                            <OtherNode start="(408, 11)" end="(408, 12)" kind="token.«· »">
                                                            <AtomNode start="(408, 11)" end="(408, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(408, 13)" end="(413, 23)">
                                                            <TacticTacticseq1IndentedNode start="(408, 13)" end="(413, 23)">
                                                            <NullNode start="(408, 13)" end="(413, 23)">
                                                            <OtherNode start="(408, 13)" end="(408, 35)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote_le ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="have ih := ih (h := h)">
                                                            <AtomNode start="(408, 13)" end="(408, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(408, 18)" end="(408, 35)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(408, 18)" end="(408, 35)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(408, 18)" end="(408, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(408, 18)" end="(408, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(408, 21)" end="(408, 23)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(408, 24)" end="(408, 35)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(408, 24)" end="(408, 26)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(408, 27)" end="(408, 35)">
                                                            <OtherNode start="(408, 27)" end="(408, 35)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(408, 27)" end="(408, 28)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(408, 28)" end="(408, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(408, 30)" end="(408, 32)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(408, 33)" end="(408, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(408, 34)" end="(408, 35)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(408, 35)" end="(408, 36)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(408, 37)" end="(408, 61)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote_le ctx (((k₁ - k₂, v₁) :: r₁).reverse ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp [denote_le] at ih ⊢">
                                                            <AtomNode start="(408, 37)" end="(408, 41)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(408, 42)" end="(408, 53)">
                                                            <AtomNode start="(408, 42)" end="(408, 43)" leading="" trailing="" val="["/>
                                                            <NullNode start="(408, 43)" end="(408, 52)">
                                                            <OtherNode start="(408, 43)" end="(408, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(408, 43)" end="(408, 52)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(408, 52)" end="(408, 53)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(408, 54)" end="(408, 61)">
                                                            <OtherNode start="(408, 54)" end="(408, 61)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(408, 54)" end="(408, 56)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(408, 57)" end="(408, 61)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(408, 57)" end="(408, 61)">
                                                            <IdentNode start="(408, 57)" end="(408, 59)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(408, 60)" end="(408, 61)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(408, 60)" end="(408, 61)" kind="patternIgnore">
                                                            <OtherNode start="(408, 60)" end="(408, 61)" kind="token.«⊢»">
                                                            <AtomNode start="(408, 60)" end="(408, 61)" leading="" trailing="&#10;            " val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(409, 13)" end="(409, 134)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁ := Nat.mul_le_mul_right _ (Nat.le_of_lt (Nat.blt_eq.mp hgtk))">
                                                            <AtomNode start="(409, 13)" end="(409, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(409, 18)" end="(409, 134)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(409, 18)" end="(409, 134)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(409, 18)" end="(409, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(409, 18)" end="(409, 22)" leading="" trailing=" " raw_val="haux" val="haux"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(409, 23)" end="(409, 72)">
                                                            <TermTypespecNode start="(409, 23)" end="(409, 72)">
                                                            <AtomNode start="(409, 23)" end="(409, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(409, 25)" end="(409, 72)" kind="«term_≤_»">
                                                            <OtherNode start="(409, 25)" end="(409, 47)" kind="«term_*_»">
                                                            <IdentNode start="(409, 25)" end="(409, 27)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            <AtomNode start="(409, 28)" end="(409, 29)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(409, 30)" end="(409, 47)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(409, 30)" end="(409, 40)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(409, 41)" end="(409, 47)">
                                                            <IdentNode start="(409, 41)" end="(409, 44)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(409, 45)" end="(409, 47)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(409, 48)" end="(409, 49)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(409, 50)" end="(409, 72)" kind="«term_*_»">
                                                            <IdentNode start="(409, 50)" end="(409, 52)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(409, 53)" end="(409, 54)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(409, 55)" end="(409, 72)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(409, 55)" end="(409, 65)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(409, 66)" end="(409, 72)">
                                                            <IdentNode start="(409, 66)" end="(409, 69)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(409, 70)" end="(409, 72)" leading="" trailing=" " raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(409, 73)" end="(409, 75)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(409, 76)" end="(409, 134)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(409, 76)" end="(409, 96)" leading="" trailing=" " raw_val="Nat.mul_le_mul_right" val="Nat.mul_le_mul_right" full_name="Nat.mul_le_mul_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(409, 97)" end="(409, 134)">
                                                            <TermHoleNode start="(409, 97)" end="(409, 98)">
                                                            <AtomNode start="(409, 97)" end="(409, 98)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(409, 99)" end="(409, 134)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(409, 99)" end="(409, 100)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(409, 100)" end="(409, 133)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(409, 100)" end="(409, 112)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(409, 113)" end="(409, 133)">
                                                            <OtherNode start="(409, 113)" end="(409, 133)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(409, 113)" end="(409, 114)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(409, 114)" end="(409, 132)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(409, 114)" end="(409, 127)" leading="" trailing=" " raw_val="Nat.blt_eq.mp" val="Nat.blt_eq.mp"/>
                                                            <NullNode start="(409, 128)" end="(409, 132)">
                                                            <IdentNode start="(409, 128)" end="(409, 132)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(409, 132)" end="(409, 133)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(409, 133)" end="(409, 134)" leading="" trailing="&#10;            " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(410, 13)" end="(410, 92)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + (denote ctx m₁ + (k₁ - k₂) * Var.denote ctx v₁) ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="rw [Nat.mul_sub_right_distrib, ← Nat.add_assoc, ← Nat.add_sub_assoc haux] at ih">
                                                            <AtomNode start="(410, 13)" end="(410, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(410, 16)" end="(410, 86)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(410, 16)" end="(410, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(410, 17)" end="(410, 85)">
                                                            <OtherNode start="(410, 17)" end="(410, 42)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(410, 17)" end="(410, 42)" leading="" trailing="" raw_val="Nat.mul_sub_right_distrib" val="Nat.mul_sub_right_distrib" full_name="Nat.mul_sub_right_distrib" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(410, 42)" end="(410, 43)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(410, 44)" end="(410, 59)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(410, 44)" end="(410, 45)">
                                                            <OtherNode start="(410, 44)" end="(410, 45)" kind="patternIgnore">
                                                            <OtherNode start="(410, 44)" end="(410, 45)" kind="token.«← »">
                                                            <AtomNode start="(410, 44)" end="(410, 45)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(410, 46)" end="(410, 59)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(410, 59)" end="(410, 60)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(410, 61)" end="(410, 85)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(410, 61)" end="(410, 62)">
                                                            <OtherNode start="(410, 61)" end="(410, 62)" kind="patternIgnore">
                                                            <OtherNode start="(410, 61)" end="(410, 62)" kind="token.«← »">
                                                            <AtomNode start="(410, 61)" end="(410, 62)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(410, 63)" end="(410, 85)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(410, 63)" end="(410, 80)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(410, 81)" end="(410, 85)">
                                                            <IdentNode start="(410, 81)" end="(410, 85)" leading="" trailing="" raw_val="haux" val="haux"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(410, 85)" end="(410, 86)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(410, 87)" end="(410, 92)">
                                                            <OtherNode start="(410, 87)" end="(410, 92)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(410, 87)" end="(410, 89)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(410, 90)" end="(410, 92)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(410, 90)" end="(410, 92)">
                                                            <IdentNode start="(410, 90)" end="(410, 92)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(411, 13)" end="(411, 44)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;this : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="have := Nat.le_add_of_sub_le ih">
                                                            <AtomNode start="(411, 13)" end="(411, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(411, 18)" end="(411, 44)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(411, 18)" end="(411, 44)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(411, 18)" end="(411, 18)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(411, 18)" end="(411, 18)" kind="hygieneInfo">
                                                            <IdentNode start="(411, 18)" end="(411, 18)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(411, 18)" end="(411, 20)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(411, 21)" end="(411, 44)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(411, 21)" end="(411, 41)" leading="" trailing=" " raw_val="Nat.le_add_of_sub_le" val="Nat.le_add_of_sub_le" full_name="Nat.le_add_of_sub_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(411, 42)" end="(411, 44)">
                                                            <IdentNode start="(411, 42)" end="(411, 44)" leading="" trailing="&#10;            " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(412, 13)" end="(412, 25)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;this : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₂ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;this :&#10;  denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" tactic="simp at this">
                                                            <AtomNode start="(412, 13)" end="(412, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(412, 18)" end="(412, 25)">
                                                            <OtherNode start="(412, 18)" end="(412, 25)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(412, 18)" end="(412, 20)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(412, 21)" end="(412, 25)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(412, 21)" end="(412, 25)">
                                                            <IdentNode start="(412, 21)" end="(412, 25)" leading="" trailing="&#10;            " raw_val="this" val="this"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(413, 13)" end="(413, 23)" kind="Lean.Parser.Tactic.exact" state_before="case pos&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ ((k₁ - k₂, v₁) :: r₁) r₂)&#10;ih : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ - k₂ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂&#10;haux : k₂ * Var.denote ctx v₁ ≤ k₁ * Var.denote ctx v₁&#10;this :&#10;  denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₂ * Var.denote ctx v₁)" state_after="no goals" tactic="exact this">
                                                            <AtomNode start="(413, 13)" end="(413, 18)" leading="" trailing=" " val="exact"/>
                                                            <IdentNode start="(413, 19)" end="(413, 23)" leading="" trailing="&#10;          " raw_val="this" val="this"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(414, 11)" end="(418, 23)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="no goals" tactic="· have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk; subst heqk&#10;  have ih := ih (h := h); simp [denote_le] at ih ⊢&#10;  have := Nat.add_le_add_right ih (k₁ * Var.denote ctx v₁)&#10;  simp at this&#10;  exact this">
                                                            <OtherNode start="(414, 11)" end="(414, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(414, 11)" end="(414, 12)" kind="patternIgnore">
                                                            <OtherNode start="(414, 11)" end="(414, 12)" kind="token.«· »">
                                                            <AtomNode start="(414, 11)" end="(414, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(414, 13)" end="(418, 23)">
                                                            <TacticTacticseq1IndentedNode start="(414, 13)" end="(418, 23)">
                                                            <NullNode start="(414, 13)" end="(418, 23)">
                                                            <OtherNode start="(414, 13)" end="(414, 67)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqk : k₁ = k₂&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" tactic="have heqk : k₁ = k₂ := eq_of_not_blt_eq_true hltk hgtk">
                                                            <AtomNode start="(414, 13)" end="(414, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(414, 18)" end="(414, 67)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(414, 18)" end="(414, 67)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(414, 18)" end="(414, 22)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(414, 18)" end="(414, 22)" leading="" trailing=" " raw_val="heqk" val="heqk"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(414, 23)" end="(414, 32)">
                                                            <TermTypespecNode start="(414, 23)" end="(414, 32)">
                                                            <AtomNode start="(414, 23)" end="(414, 24)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(414, 25)" end="(414, 32)" kind="«term_=_»">
                                                            <IdentNode start="(414, 25)" end="(414, 27)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(414, 28)" end="(414, 29)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(414, 30)" end="(414, 32)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(414, 33)" end="(414, 35)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(414, 36)" end="(414, 67)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(414, 36)" end="(414, 57)" leading="" trailing=" " raw_val="eq_of_not_blt_eq_true" val="eq_of_not_blt_eq_true" full_name="_private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(270, 17)" def_end="(270, 38)"/>
                                                            <NullNode start="(414, 58)" end="(414, 67)">
                                                            <IdentNode start="(414, 58)" end="(414, 62)" leading="" trailing=" " raw_val="hltk" val="hltk"/>
                                                            <IdentNode start="(414, 63)" end="(414, 67)" leading="" trailing="" raw_val="hgtk" val="hgtk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(414, 67)" end="(414, 68)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(414, 69)" end="(414, 79)" kind="Lean.Parser.Tactic.subst" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ : List (Nat × Var)&#10;k₂ : Nat&#10;m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;hltk : ¬k₁.blt k₂ = true&#10;hgtk : ¬k₂.blt k₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;heqk : k₁ = k₂&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₂, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" tactic="subst heqk">
                                                            <AtomNode start="(414, 69)" end="(414, 74)" leading="" trailing=" " val="subst"/>
                                                            <NullNode start="(414, 75)" end="(414, 79)">
                                                            <IdentNode start="(414, 75)" end="(414, 79)" leading="" trailing="&#10;            " raw_val="heqk" val="heqk"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(415, 13)" end="(415, 35)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" tactic="have ih := ih (h := h)">
                                                            <AtomNode start="(415, 13)" end="(415, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(415, 18)" end="(415, 35)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(415, 18)" end="(415, 35)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(415, 18)" end="(415, 20)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(415, 18)" end="(415, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(415, 21)" end="(415, 23)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(415, 24)" end="(415, 35)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(415, 24)" end="(415, 26)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(415, 27)" end="(415, 35)">
                                                            <OtherNode start="(415, 27)" end="(415, 35)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(415, 27)" end="(415, 28)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(415, 28)" end="(415, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <AtomNode start="(415, 30)" end="(415, 32)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(415, 33)" end="(415, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(415, 34)" end="(415, 35)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(415, 35)" end="(415, 36)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(415, 37)" end="(415, 61)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;⊢ denote_le ctx (List.reverse r₁ ++ (k₁, v₁) :: m₁, List.reverse r₂ ++ (k₁, v₁) :: m₂)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" tactic="simp [denote_le] at ih ⊢">
                                                            <AtomNode start="(415, 37)" end="(415, 41)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(415, 42)" end="(415, 53)">
                                                            <AtomNode start="(415, 42)" end="(415, 43)" leading="" trailing="" val="["/>
                                                            <NullNode start="(415, 43)" end="(415, 52)">
                                                            <OtherNode start="(415, 43)" end="(415, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(415, 43)" end="(415, 52)" leading="" trailing="" raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(415, 52)" end="(415, 53)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(415, 54)" end="(415, 61)">
                                                            <OtherNode start="(415, 54)" end="(415, 61)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(415, 54)" end="(415, 56)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(415, 57)" end="(415, 61)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(415, 57)" end="(415, 61)">
                                                            <IdentNode start="(415, 57)" end="(415, 59)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(415, 60)" end="(415, 61)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(415, 60)" end="(415, 61)" kind="patternIgnore">
                                                            <OtherNode start="(415, 60)" end="(415, 61)" kind="token.«⊢»">
                                                            <AtomNode start="(415, 60)" end="(415, 61)" leading="" trailing="&#10;            " val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(416, 13)" end="(416, 69)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂&#10;this : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" tactic="have := Nat.add_le_add_right ih (k₁ * Var.denote ctx v₁)">
                                                            <AtomNode start="(416, 13)" end="(416, 17)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(416, 18)" end="(416, 69)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(416, 18)" end="(416, 69)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(416, 18)" end="(416, 18)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(416, 18)" end="(416, 18)" kind="hygieneInfo">
                                                            <IdentNode start="(416, 18)" end="(416, 18)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(416, 18)" end="(416, 20)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(416, 21)" end="(416, 69)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(416, 21)" end="(416, 41)" leading="" trailing=" " raw_val="Nat.add_le_add_right" val="Nat.add_le_add_right" full_name="Nat.add_le_add_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(416, 42)" end="(416, 69)">
                                                            <IdentNode start="(416, 42)" end="(416, 44)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <OtherNode start="(416, 45)" end="(416, 69)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(416, 45)" end="(416, 46)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(416, 46)" end="(416, 68)" kind="«term_*_»">
                                                            <IdentNode start="(416, 46)" end="(416, 48)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                                                            <AtomNode start="(416, 49)" end="(416, 50)" leading="" trailing=" " val="*"/>
                                                            <OtherNode start="(416, 51)" end="(416, 68)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(416, 51)" end="(416, 61)" leading="" trailing=" " raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                                            <NullNode start="(416, 62)" end="(416, 68)">
                                                            <IdentNode start="(416, 62)" end="(416, 65)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                            <IdentNode start="(416, 66)" end="(416, 68)" leading="" trailing="" raw_val="v₁" val="v₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(416, 68)" end="(416, 69)" leading="" trailing="&#10;            " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(417, 13)" end="(417, 25)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂&#10;this : denote ctx r₁ + denote ctx m₁ + k₁ * Var.denote ctx v₁ ≤ denote ctx r₂ + denote ctx m₂ + k₁ * Var.denote ctx v₁&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" state_after="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂&#10;this :&#10;  denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" tactic="simp at this">
                                                            <AtomNode start="(417, 13)" end="(417, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(417, 18)" end="(417, 25)">
                                                            <OtherNode start="(417, 18)" end="(417, 25)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(417, 18)" end="(417, 20)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(417, 21)" end="(417, 25)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(417, 21)" end="(417, 25)">
                                                            <IdentNode start="(417, 21)" end="(417, 25)" leading="" trailing="&#10;            " raw_val="this" val="this"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(418, 13)" end="(418, 23)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;ctx : Context&#10;fuel : Nat&#10;ih✝ :&#10;  ∀ (m₁ m₂ r₁ r₂ : Poly),&#10;    denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂) → denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)&#10;r₁ r₂ m₁✝ m₂✝ : Poly&#10;k₁ : Nat&#10;v₁ : Var&#10;m₁ m₂ : List (Nat × Var)&#10;hltv hgtv : ¬blt v₁ v₁ = true&#10;h : denote_le ctx (cancelAux fuel m₁ m₂ r₁ r₂)&#10;hltk hgtk : ¬k₁.blt k₁ = true&#10;ih : denote ctx r₁ + denote ctx m₁ ≤ denote ctx r₂ + denote ctx m₂&#10;this :&#10;  denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)&#10;⊢ denote ctx r₁ + (denote ctx m₁ + k₁ * Var.denote ctx v₁) ≤ denote ctx r₂ + (denote ctx m₂ + k₁ * Var.denote ctx v₁)" state_after="no goals" tactic="exact this">
                                                            <AtomNode start="(418, 13)" end="(418, 18)" leading="" trailing=" " val="exact"/>
                                                            <IdentNode start="(418, 19)" end="(418, 23)" leading="" trailing="&#10;&#10;" raw_val="this" val="this"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(420, 1)" end="(421, 38)" name="Poly.denote_le_cancel" full_name="Nat.Linear.Poly.denote_le_cancel">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(420, 1)" end="(421, 38)" name="Poly.denote_le_cancel" full_name="Nat.Linear.Poly.denote_le_cancel" _is_private_decl="False">
        <AtomNode start="(420, 1)" end="(420, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(420, 9)" end="(420, 30)">
          <IdentNode start="(420, 9)" end="(420, 30)" leading="" trailing=" " raw_val="Poly.denote_le_cancel" val="Poly.denote_le_cancel"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(420, 31)" end="(420, 121)">
          <NullNode start="(420, 31)" end="(420, 90)">
            <OtherNode start="(420, 31)" end="(420, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(420, 31)" end="(420, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(420, 32)" end="(420, 35)">
                <IdentNode start="(420, 32)" end="(420, 35)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(420, 36)" end="(420, 45)">
                <AtomNode start="(420, 36)" end="(420, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(420, 38)" end="(420, 45)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <AtomNode start="(420, 45)" end="(420, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(420, 47)" end="(420, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(420, 47)" end="(420, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(420, 48)" end="(420, 53)">
                <IdentNode start="(420, 48)" end="(420, 50)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(420, 51)" end="(420, 53)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
              </NullNode>
              <NullNode start="(420, 54)" end="(420, 60)">
                <AtomNode start="(420, 54)" end="(420, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(420, 56)" end="(420, 60)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <AtomNode start="(420, 60)" end="(420, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(420, 62)" end="(420, 90)">
              <AtomNode start="(420, 62)" end="(420, 63)" leading="" trailing="" val="("/>
              <NullNode start="(420, 63)" end="(420, 64)">
                <IdentNode start="(420, 63)" end="(420, 64)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(420, 65)" end="(420, 89)">
                <AtomNode start="(420, 65)" end="(420, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(420, 67)" end="(420, 89)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(420, 67)" end="(420, 76)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                  <NullNode start="(420, 77)" end="(420, 89)">
                    <IdentNode start="(420, 77)" end="(420, 80)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(420, 81)" end="(420, 89)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(420, 81)" end="(420, 82)" leading="" trailing="" val="("/>
                      <NullNode start="(420, 82)" end="(420, 88)">
                        <IdentNode start="(420, 82)" end="(420, 84)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                        <AtomNode start="(420, 84)" end="(420, 85)" leading="" trailing=" " val=","/>
                        <NullNode start="(420, 86)" end="(420, 88)">
                          <IdentNode start="(420, 86)" end="(420, 88)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(420, 88)" end="(420, 89)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(420, 89)" end="(420, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(420, 91)" end="(420, 121)">
            <AtomNode start="(420, 91)" end="(420, 92)" leading="" trailing=" " val=":"/>
            <OtherNode start="(420, 93)" end="(420, 121)" kind="Lean.Parser.Term.app">
              <IdentNode start="(420, 93)" end="(420, 102)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
              <NullNode start="(420, 103)" end="(420, 121)">
                <IdentNode start="(420, 103)" end="(420, 106)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(420, 107)" end="(420, 121)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(420, 107)" end="(420, 108)" leading="" trailing="" val="("/>
                  <OtherNode start="(420, 108)" end="(420, 120)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(420, 108)" end="(420, 114)" leading="" trailing=" " raw_val="cancel" val="cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                    <NullNode start="(420, 115)" end="(420, 120)">
                      <IdentNode start="(420, 115)" end="(420, 117)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                      <IdentNode start="(420, 118)" end="(420, 120)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(420, 120)" end="(420, 121)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(420, 122)" end="(421, 38)">
          <AtomNode start="(420, 122)" end="(420, 124)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(420, 125)" end="(421, 38)">
            <AtomNode start="(420, 125)" end="(420, 127)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(421, 3)" end="(421, 38)">
              <TacticTacticseq1IndentedNode start="(421, 3)" end="(421, 38)">
                <NullNode start="(421, 3)" end="(421, 38)">
                  <OtherNode start="(421, 3)" end="(421, 28)" kind="Lean.Parser.Tactic.apply" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁, m₂)&#10;⊢ denote_le ctx (m₁.cancel m₂)" state_after="case h&#10;ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁, m₂)&#10;⊢ denote_le ctx ([].reverse ++ m₁, [].reverse ++ m₂)" tactic="apply denote_le_cancelAux">
                    <AtomNode start="(421, 3)" end="(421, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(421, 9)" end="(421, 28)" leading="" trailing="" raw_val="denote_le_cancelAux" val="denote_le_cancelAux" full_name="Nat.Linear.Poly.denote_le_cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(353, 9)" def_end="(353, 33)"/>
                  </OtherNode>
                  <AtomNode start="(421, 28)" end="(421, 29)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(421, 30)" end="(421, 38)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁, m₂)&#10;⊢ denote_le ctx ([].reverse ++ m₁, [].reverse ++ m₂)" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(421, 30)" end="(421, 34)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(421, 35)" end="(421, 38)">
                      <AtomNode start="(421, 35)" end="(421, 36)" leading="" trailing="" val="["/>
                      <NullNode start="(421, 36)" end="(421, 37)">
                        <OtherNode start="(421, 36)" end="(421, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(421, 36)" end="(421, 37)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(421, 37)" end="(421, 38)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(423, 1)" end="(426, 13)" name="Poly.of_denote_le_cancel" full_name="Nat.Linear.Poly.of_denote_le_cancel">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(423, 1)" end="(426, 13)" name="Poly.of_denote_le_cancel" full_name="Nat.Linear.Poly.of_denote_le_cancel" _is_private_decl="False">
        <AtomNode start="(423, 1)" end="(423, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(423, 9)" end="(423, 33)">
          <IdentNode start="(423, 9)" end="(423, 33)" leading="" trailing=" " raw_val="Poly.of_denote_le_cancel" val="Poly.of_denote_le_cancel"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(423, 34)" end="(423, 124)">
          <NullNode start="(423, 34)" end="(423, 99)">
            <OtherNode start="(423, 34)" end="(423, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(423, 34)" end="(423, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(423, 35)" end="(423, 38)">
                <IdentNode start="(423, 35)" end="(423, 38)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(423, 39)" end="(423, 48)">
                <AtomNode start="(423, 39)" end="(423, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(423, 41)" end="(423, 48)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <AtomNode start="(423, 48)" end="(423, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(423, 50)" end="(423, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(423, 50)" end="(423, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(423, 51)" end="(423, 56)">
                <IdentNode start="(423, 51)" end="(423, 53)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(423, 54)" end="(423, 56)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
              </NullNode>
              <NullNode start="(423, 57)" end="(423, 63)">
                <AtomNode start="(423, 57)" end="(423, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(423, 59)" end="(423, 63)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <AtomNode start="(423, 63)" end="(423, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(423, 65)" end="(423, 99)">
              <AtomNode start="(423, 65)" end="(423, 66)" leading="" trailing="" val="("/>
              <NullNode start="(423, 66)" end="(423, 67)">
                <IdentNode start="(423, 66)" end="(423, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(423, 68)" end="(423, 98)">
                <AtomNode start="(423, 68)" end="(423, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(423, 70)" end="(423, 98)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(423, 70)" end="(423, 79)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                  <NullNode start="(423, 80)" end="(423, 98)">
                    <IdentNode start="(423, 80)" end="(423, 83)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    <OtherNode start="(423, 84)" end="(423, 98)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(423, 84)" end="(423, 85)" leading="" trailing="" val="("/>
                      <OtherNode start="(423, 85)" end="(423, 97)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(423, 85)" end="(423, 91)" leading="" trailing=" " raw_val="cancel" val="cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                        <NullNode start="(423, 92)" end="(423, 97)">
                          <IdentNode start="(423, 92)" end="(423, 94)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                          <IdentNode start="(423, 95)" end="(423, 97)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(423, 97)" end="(423, 98)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(423, 98)" end="(423, 99)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(423, 100)" end="(423, 124)">
            <AtomNode start="(423, 100)" end="(423, 101)" leading="" trailing=" " val=":"/>
            <OtherNode start="(423, 102)" end="(423, 124)" kind="Lean.Parser.Term.app">
              <IdentNode start="(423, 102)" end="(423, 111)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
              <NullNode start="(423, 112)" end="(423, 124)">
                <IdentNode start="(423, 112)" end="(423, 115)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                <OtherNode start="(423, 116)" end="(423, 124)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(423, 116)" end="(423, 117)" leading="" trailing="" val="("/>
                  <NullNode start="(423, 117)" end="(423, 123)">
                    <IdentNode start="(423, 117)" end="(423, 119)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                    <AtomNode start="(423, 119)" end="(423, 120)" leading="" trailing=" " val=","/>
                    <NullNode start="(423, 121)" end="(423, 123)">
                      <IdentNode start="(423, 121)" end="(423, 123)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(423, 123)" end="(423, 124)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(423, 125)" end="(426, 13)">
          <AtomNode start="(423, 125)" end="(423, 127)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(423, 128)" end="(426, 13)">
            <AtomNode start="(423, 128)" end="(423, 130)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(424, 3)" end="(426, 13)">
              <TacticTacticseq1IndentedNode start="(424, 3)" end="(426, 13)">
                <NullNode start="(424, 3)" end="(426, 13)">
                  <OtherNode start="(424, 3)" end="(424, 47)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁.cancel m₂)&#10;⊢ denote_le ctx (m₁, m₂)" state_after="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁.cancel m₂)&#10;this : denote_le ctx ([].reverse ++ m₁, [].reverse ++ m₂)&#10;⊢ denote_le ctx (m₁, m₂)" tactic="have := Poly.of_denote_le_cancelAux (h := h)">
                    <AtomNode start="(424, 3)" end="(424, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(424, 8)" end="(424, 47)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(424, 8)" end="(424, 47)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(424, 8)" end="(424, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(424, 8)" end="(424, 8)" kind="hygieneInfo">
                            <IdentNode start="(424, 8)" end="(424, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(424, 8)" end="(424, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(424, 11)" end="(424, 47)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(424, 11)" end="(424, 38)" leading="" trailing=" " raw_val="Poly.of_denote_le_cancelAux" val="Poly.of_denote_le_cancelAux" full_name="Nat.Linear.Poly.of_denote_le_cancelAux" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(387, 9)" def_end="(387, 36)"/>
                          <NullNode start="(424, 39)" end="(424, 47)">
                            <OtherNode start="(424, 39)" end="(424, 47)" kind="Lean.Parser.Term.namedArgument">
                              <AtomNode start="(424, 39)" end="(424, 40)" leading="" trailing="" val="("/>
                              <IdentNode start="(424, 40)" end="(424, 41)" leading="" trailing=" " raw_val="h" val="h"/>
                              <AtomNode start="(424, 42)" end="(424, 44)" leading="" trailing=" " val=":="/>
                              <IdentNode start="(424, 45)" end="(424, 46)" leading="" trailing="" raw_val="h" val="h"/>
                              <AtomNode start="(424, 46)" end="(424, 47)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(425, 3)" end="(425, 15)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁.cancel m₂)&#10;this : denote_le ctx ([].reverse ++ m₁, [].reverse ++ m₂)&#10;⊢ denote_le ctx (m₁, m₂)" state_after="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁.cancel m₂)&#10;this : denote_le ctx (m₁, m₂)&#10;⊢ denote_le ctx (m₁, m₂)" tactic="simp at this">
                    <AtomNode start="(425, 3)" end="(425, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(425, 8)" end="(425, 15)">
                      <OtherNode start="(425, 8)" end="(425, 15)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(425, 8)" end="(425, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(425, 11)" end="(425, 15)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(425, 11)" end="(425, 15)">
                            <IdentNode start="(425, 11)" end="(425, 15)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(426, 3)" end="(426, 13)" kind="Lean.Parser.Tactic.assumption" state_before="ctx : Context&#10;m₁ m₂ : Poly&#10;h : denote_le ctx (m₁.cancel m₂)&#10;this : denote_le ctx (m₁, m₂)&#10;⊢ denote_le ctx (m₁, m₂)" state_after="no goals" tactic="assumption">
                    <AtomNode start="(426, 3)" end="(426, 13)" leading="" trailing="&#10;&#10;" val="assumption"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(428, 1)" end="(429, 86)" name="Poly.denote_le_cancel_eq" full_name="Nat.Linear.Poly.denote_le_cancel_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(428, 1)" end="(429, 86)" name="Poly.denote_le_cancel_eq" full_name="Nat.Linear.Poly.denote_le_cancel_eq" _is_private_decl="False">
        <AtomNode start="(428, 1)" end="(428, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(428, 9)" end="(428, 33)">
          <IdentNode start="(428, 9)" end="(428, 33)" leading="" trailing=" " raw_val="Poly.denote_le_cancel_eq" val="Poly.denote_le_cancel_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(428, 34)" end="(428, 120)">
          <NullNode start="(428, 34)" end="(428, 64)">
            <TermExplicitbinderNode start="(428, 34)" end="(428, 49)">
              <AtomNode start="(428, 34)" end="(428, 35)" leading="" trailing="" val="("/>
              <NullNode start="(428, 35)" end="(428, 38)">
                <IdentNode start="(428, 35)" end="(428, 38)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(428, 39)" end="(428, 48)">
                <AtomNode start="(428, 39)" end="(428, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(428, 41)" end="(428, 48)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(428, 48)" end="(428, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(428, 50)" end="(428, 64)">
              <AtomNode start="(428, 50)" end="(428, 51)" leading="" trailing="" val="("/>
              <NullNode start="(428, 51)" end="(428, 56)">
                <IdentNode start="(428, 51)" end="(428, 53)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                <IdentNode start="(428, 54)" end="(428, 56)" leading="" trailing=" " raw_val="m₂" val="m₂"/>
              </NullNode>
              <NullNode start="(428, 57)" end="(428, 63)">
                <AtomNode start="(428, 57)" end="(428, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(428, 59)" end="(428, 63)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(428, 63)" end="(428, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(428, 65)" end="(428, 120)">
            <AtomNode start="(428, 65)" end="(428, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(428, 67)" end="(428, 120)" kind="«term_=_»">
              <OtherNode start="(428, 67)" end="(428, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(428, 67)" end="(428, 76)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                <NullNode start="(428, 77)" end="(428, 95)">
                  <IdentNode start="(428, 77)" end="(428, 80)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(428, 81)" end="(428, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(428, 81)" end="(428, 82)" leading="" trailing="" val="("/>
                    <OtherNode start="(428, 82)" end="(428, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(428, 82)" end="(428, 88)" leading="" trailing=" " raw_val="cancel" val="cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                      <NullNode start="(428, 89)" end="(428, 94)">
                        <IdentNode start="(428, 89)" end="(428, 91)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                        <IdentNode start="(428, 92)" end="(428, 94)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(428, 94)" end="(428, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(428, 96)" end="(428, 97)" leading="" trailing=" " val="="/>
              <OtherNode start="(428, 98)" end="(428, 120)" kind="Lean.Parser.Term.app">
                <IdentNode start="(428, 98)" end="(428, 107)" leading="" trailing=" " raw_val="denote_le" val="denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                <NullNode start="(428, 108)" end="(428, 120)">
                  <IdentNode start="(428, 108)" end="(428, 111)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  <OtherNode start="(428, 112)" end="(428, 120)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(428, 112)" end="(428, 113)" leading="" trailing="" val="("/>
                    <NullNode start="(428, 113)" end="(428, 119)">
                      <IdentNode start="(428, 113)" end="(428, 115)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                      <AtomNode start="(428, 115)" end="(428, 116)" leading="" trailing=" " val=","/>
                      <NullNode start="(428, 117)" end="(428, 119)">
                        <IdentNode start="(428, 117)" end="(428, 119)" leading="" trailing="" raw_val="m₂" val="m₂"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(428, 119)" end="(428, 120)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(428, 121)" end="(429, 86)">
          <AtomNode start="(428, 121)" end="(428, 123)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(429, 3)" end="(429, 86)" kind="«term_&amp;lt;|_»">
            <IdentNode start="(429, 3)" end="(429, 10)" leading="" trailing=" " raw_val="propext" val="propext" full_name="propext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
            <AtomNode start="(429, 11)" end="(429, 13)" leading="" trailing=" " val="&amp;lt;|"/>
            <OtherNode start="(429, 14)" end="(429, 86)" kind="Lean.Parser.Term.app">
              <IdentNode start="(429, 14)" end="(429, 23)" leading="" trailing=" " raw_val="Iff.intro" val="Iff.intro" full_name="Iff.intro" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(429, 24)" end="(429, 86)">
                <OtherNode start="(429, 24)" end="(429, 56)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(429, 24)" end="(429, 25)" leading="" trailing="" val="("/>
                  <OtherNode start="(429, 25)" end="(429, 55)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(429, 25)" end="(429, 28)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(429, 29)" end="(429, 55)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(429, 29)" end="(429, 30)">
                        <IdentNode start="(429, 29)" end="(429, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(429, 31)" end="(429, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(429, 34)" end="(429, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(429, 34)" end="(429, 53)" leading="" trailing=" " raw_val="of_denote_le_cancel" val="of_denote_le_cancel" full_name="Nat.Linear.Poly.of_denote_le_cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(423, 9)" def_end="(423, 33)"/>
                        <NullNode start="(429, 54)" end="(429, 55)">
                          <IdentNode start="(429, 54)" end="(429, 55)" leading="" trailing="" raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(429, 55)" end="(429, 56)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(429, 57)" end="(429, 86)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(429, 57)" end="(429, 58)" leading="" trailing="" val="("/>
                  <OtherNode start="(429, 58)" end="(429, 85)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(429, 58)" end="(429, 61)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(429, 62)" end="(429, 85)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(429, 62)" end="(429, 63)">
                        <IdentNode start="(429, 62)" end="(429, 63)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(429, 64)" end="(429, 66)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(429, 67)" end="(429, 85)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(429, 67)" end="(429, 83)" leading="" trailing=" " raw_val="denote_le_cancel" val="denote_le_cancel" full_name="Nat.Linear.Poly.denote_le_cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(420, 9)" def_end="(420, 30)"/>
                        <NullNode start="(429, 84)" end="(429, 85)">
                          <IdentNode start="(429, 84)" end="(429, 85)" leading="" trailing="" raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(429, 85)" end="(429, 86)" leading="" trailing="&#10;&#10;" val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(431, 1)" end="(431, 48)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(431, 1)" end="(431, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(431, 11)" end="(431, 12)" leading="" trailing="" val="["/>
      <NullNode start="(431, 12)" end="(431, 22)">
        <OtherNode start="(431, 12)" end="(431, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(431, 12)" end="(431, 17)">
            <NullNode start="(431, 12)" end="(431, 17)">
              <OtherNode start="(431, 12)" end="(431, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(431, 12)" end="(431, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(431, 18)" end="(431, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(431, 18)" end="(431, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(431, 22)" end="(431, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(431, 24)" end="(431, 48)">
        <IdentNode start="(431, 24)" end="(431, 48)" leading="" trailing="&#10;&#10;" raw_val="Poly.denote_le_cancel_eq" val="Poly.denote_le_cancel_eq" full_name="Nat.Linear.Poly.denote_le_cancel_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(428, 9)" def_end="(428, 33)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(433, 1)" end="(451, 44)" name="Expr.denote_toPoly_go" full_name="Nat.Linear.Expr.denote_toPoly_go">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(433, 1)" end="(451, 44)" name="Expr.denote_toPoly_go" full_name="Nat.Linear.Expr.denote_toPoly_go" _is_private_decl="False">
        <AtomNode start="(433, 1)" end="(433, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(433, 9)" end="(433, 30)">
          <IdentNode start="(433, 9)" end="(433, 30)" leading="" trailing=" " raw_val="Expr.denote_toPoly_go" val="Expr.denote_toPoly_go"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(433, 31)" end="(434, 65)">
          <NullNode start="(433, 31)" end="(433, 57)">
            <TermExplicitbinderNode start="(433, 31)" end="(433, 46)">
              <AtomNode start="(433, 31)" end="(433, 32)" leading="" trailing="" val="("/>
              <NullNode start="(433, 32)" end="(433, 35)">
                <IdentNode start="(433, 32)" end="(433, 35)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(433, 36)" end="(433, 45)">
                <AtomNode start="(433, 36)" end="(433, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(433, 38)" end="(433, 45)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(433, 45)" end="(433, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(433, 47)" end="(433, 57)">
              <AtomNode start="(433, 47)" end="(433, 48)" leading="" trailing="" val="("/>
              <NullNode start="(433, 48)" end="(433, 49)">
                <IdentNode start="(433, 48)" end="(433, 49)" leading="" trailing=" " raw_val="e" val="e"/>
              </NullNode>
              <NullNode start="(433, 50)" end="(433, 56)">
                <AtomNode start="(433, 50)" end="(433, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(433, 52)" end="(433, 56)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(433, 56)" end="(433, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(433, 58)" end="(434, 65)">
            <AtomNode start="(433, 58)" end="(433, 59)" leading="" trailing="&#10;  " val=":"/>
            <OtherNode start="(434, 3)" end="(434, 65)" kind="«term_=_»">
              <OtherNode start="(434, 3)" end="(434, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(434, 3)" end="(434, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(434, 3)" end="(434, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(434, 3)" end="(434, 4)" leading="" trailing="" val="("/>
                    <OtherNode start="(434, 4)" end="(434, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(434, 4)" end="(434, 13)" leading="" trailing=" " raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                      <NullNode start="(434, 14)" end="(434, 19)">
                        <IdentNode start="(434, 14)" end="(434, 15)" leading="" trailing=" " raw_val="k" val="k"/>
                        <IdentNode start="(434, 16)" end="(434, 17)" leading="" trailing=" " raw_val="e" val="e"/>
                        <IdentNode start="(434, 18)" end="(434, 19)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(434, 19)" end="(434, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(434, 20)" end="(434, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(434, 21)" end="(434, 27)" leading="" trailing=" " raw_val="denote" val="denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                </OtherNode>
                <NullNode start="(434, 28)" end="(434, 31)">
                  <IdentNode start="(434, 28)" end="(434, 31)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(434, 32)" end="(434, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(434, 34)" end="(434, 65)" kind="«term_+_»">
                <OtherNode start="(434, 34)" end="(434, 50)" kind="«term_*_»">
                  <IdentNode start="(434, 34)" end="(434, 35)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(434, 36)" end="(434, 37)" leading="" trailing=" " val="*"/>
                  <OtherNode start="(434, 38)" end="(434, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 38)" end="(434, 46)" leading="" trailing=" " raw_val="e.denote" val="e.denote"/>
                    <NullNode start="(434, 47)" end="(434, 50)">
                      <IdentNode start="(434, 47)" end="(434, 50)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(434, 51)" end="(434, 52)" leading="" trailing=" " val="+"/>
                <OtherNode start="(434, 53)" end="(434, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(434, 53)" end="(434, 61)" leading="" trailing=" " raw_val="p.denote" val="p.denote"/>
                  <NullNode start="(434, 62)" end="(434, 65)">
                    <IdentNode start="(434, 62)" end="(434, 65)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(434, 66)" end="(451, 44)">
          <AtomNode start="(434, 66)" end="(434, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(434, 69)" end="(451, 44)">
            <AtomNode start="(434, 69)" end="(434, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(435, 3)" end="(451, 44)">
              <TacticTacticseq1IndentedNode start="(435, 3)" end="(451, 44)">
                <NullNode start="(435, 3)" end="(451, 44)">
                  <OtherNode start="(435, 3)" end="(451, 44)" kind="Lean.Parser.Tactic.induction" state_before="k : Nat&#10;p : Poly&#10;ctx : Context&#10;e : Expr&#10;⊢ Poly.denote ctx (toPoly.go k e p) = k * denote ctx e + Poly.denote ctx p" state_after="no goals" tactic="induction k, e using Expr.toPoly.go.induct generalizing p with&#10;| case1 k k' h =&amp;gt;&#10;  simp [toPoly.go, eq_of_beq h]&#10;| case2 k k' h =&amp;gt;&#10;  simp [toPoly.go, h, Var.denote]&#10;| case3 k i =&amp;gt; simp [toPoly.go]&#10;| case4 k a b iha ihb =&amp;gt; simp [toPoly.go, iha, ihb]&#10;| case5 k k' a h =&amp;gt; simp [toPoly.go, h, eq_of_beq h]&#10;| case6 k a k' h ih =&amp;gt;&#10;  simp only [toPoly.go, denote, mul_eq]&#10;  simp [h, cond_false, ih, Nat.mul_assoc]&#10;| case7 k a k' h =&amp;gt;&#10;  simp only [toPoly.go, denote, mul_eq]&#10;  simp [h, eq_of_beq h]&#10;| case8 k a k' h ih =&amp;gt;&#10;  simp only [toPoly.go, denote, mul_eq]&#10;  simp [h, cond_false, ih, Nat.mul_assoc]">
                    <AtomNode start="(435, 3)" end="(435, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(435, 13)" end="(435, 17)">
                      <OtherNode start="(435, 13)" end="(435, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(435, 13)" end="(435, 14)" leading="" trailing="" raw_val="k" val="k"/>
                      </OtherNode>
                      <AtomNode start="(435, 14)" end="(435, 15)" leading="" trailing=" " val=","/>
                      <OtherNode start="(435, 16)" end="(435, 17)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(435, 16)" end="(435, 17)" leading="" trailing=" " raw_val="e" val="e"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(435, 18)" end="(435, 45)">
                      <AtomNode start="(435, 18)" end="(435, 23)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(435, 24)" end="(435, 45)" leading="" trailing=" " raw_val="Expr.toPoly.go.induct" val="Expr.toPoly.go.induct" full_name="Nat.Linear.Expr.toPoly.go.induct" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean"/>
                    </NullNode>
                    <NullNode start="(435, 46)" end="(435, 60)">
                      <AtomNode start="(435, 46)" end="(435, 58)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(435, 59)" end="(435, 60)">
                        <IdentNode start="(435, 59)" end="(435, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(435, 61)" end="(451, 44)">
                      <OtherNode start="(435, 61)" end="(451, 44)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(435, 61)" end="(435, 65)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(436, 3)" end="(451, 44)">
                          <OtherNode start="(436, 3)" end="(437, 34)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(436, 3)" end="(436, 17)">
                              <OtherNode start="(436, 3)" end="(436, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(436, 3)" end="(436, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(436, 5)" end="(436, 10)">
                                  <NullNode/>
                                  <IdentNode start="(436, 5)" end="(436, 10)" leading="" trailing=" " raw_val="case1" val="case1"/>
                                </GroupNode>
                                <NullNode start="(436, 11)" end="(436, 17)">
                                  <IdentNode start="(436, 11)" end="(436, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(436, 13)" end="(436, 15)" leading="" trailing=" " raw_val="k'" val="k'"/>
                                  <IdentNode start="(436, 16)" end="(436, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(436, 18)" end="(437, 34)">
                              <AtomNode start="(436, 18)" end="(436, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(437, 5)" end="(437, 34)">
                                <TacticTacticseq1IndentedNode start="(437, 5)" end="(437, 34)">
                                  <NullNode start="(437, 5)" end="(437, 34)">
                                    <OtherNode start="(437, 5)" end="(437, 34)" kind="Lean.Parser.Tactic.simp" state_before="case case1&#10;ctx : Context&#10;k k' : Nat&#10;h : (k' == 0) = true&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (num k') p) = k * denote ctx (num k') + Poly.denote ctx p" state_after="no goals" tactic="simp [toPoly.go, eq_of_beq h]">
                                      <AtomNode start="(437, 5)" end="(437, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(437, 10)" end="(437, 34)">
                                        <AtomNode start="(437, 10)" end="(437, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(437, 11)" end="(437, 33)">
                                          <OtherNode start="(437, 11)" end="(437, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(437, 11)" end="(437, 20)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(437, 20)" end="(437, 21)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(437, 22)" end="(437, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(437, 22)" end="(437, 33)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(437, 22)" end="(437, 31)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                              <NullNode start="(437, 32)" end="(437, 33)">
                                                <IdentNode start="(437, 32)" end="(437, 33)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(437, 33)" end="(437, 34)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(438, 3)" end="(439, 36)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(438, 3)" end="(438, 17)">
                              <OtherNode start="(438, 3)" end="(438, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(438, 3)" end="(438, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(438, 5)" end="(438, 10)">
                                  <NullNode/>
                                  <IdentNode start="(438, 5)" end="(438, 10)" leading="" trailing=" " raw_val="case2" val="case2"/>
                                </GroupNode>
                                <NullNode start="(438, 11)" end="(438, 17)">
                                  <IdentNode start="(438, 11)" end="(438, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(438, 13)" end="(438, 15)" leading="" trailing=" " raw_val="k'" val="k'"/>
                                  <IdentNode start="(438, 16)" end="(438, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(438, 18)" end="(439, 36)">
                              <AtomNode start="(438, 18)" end="(438, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(439, 5)" end="(439, 36)">
                                <TacticTacticseq1IndentedNode start="(439, 5)" end="(439, 36)">
                                  <NullNode start="(439, 5)" end="(439, 36)">
                                    <OtherNode start="(439, 5)" end="(439, 36)" kind="Lean.Parser.Tactic.simp" state_before="case case2&#10;ctx : Context&#10;k k' : Nat&#10;h : (k' == 0) = false&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (num k') p) = k * denote ctx (num k') + Poly.denote ctx p" state_after="no goals" tactic="simp [toPoly.go, h, Var.denote]">
                                      <AtomNode start="(439, 5)" end="(439, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(439, 10)" end="(439, 36)">
                                        <AtomNode start="(439, 10)" end="(439, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(439, 11)" end="(439, 35)">
                                          <OtherNode start="(439, 11)" end="(439, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(439, 11)" end="(439, 20)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(439, 20)" end="(439, 21)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(439, 22)" end="(439, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(439, 22)" end="(439, 23)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                          <AtomNode start="(439, 23)" end="(439, 24)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(439, 25)" end="(439, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(439, 25)" end="(439, 35)" leading="" trailing="" raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(439, 35)" end="(439, 36)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(440, 3)" end="(440, 34)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(440, 3)" end="(440, 14)">
                              <OtherNode start="(440, 3)" end="(440, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(440, 3)" end="(440, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(440, 5)" end="(440, 10)">
                                  <NullNode/>
                                  <IdentNode start="(440, 5)" end="(440, 10)" leading="" trailing=" " raw_val="case3" val="case3"/>
                                </GroupNode>
                                <NullNode start="(440, 11)" end="(440, 14)">
                                  <IdentNode start="(440, 11)" end="(440, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(440, 13)" end="(440, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(440, 15)" end="(440, 34)">
                              <AtomNode start="(440, 15)" end="(440, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(440, 18)" end="(440, 34)">
                                <TacticTacticseq1IndentedNode start="(440, 18)" end="(440, 34)">
                                  <NullNode start="(440, 18)" end="(440, 34)">
                                    <OtherNode start="(440, 18)" end="(440, 34)" kind="Lean.Parser.Tactic.simp" state_before="case case3&#10;ctx : Context&#10;k : Nat&#10;i : Var&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (var i) p) = k * denote ctx (var i) + Poly.denote ctx p" state_after="no goals" tactic="simp [toPoly.go]">
                                      <AtomNode start="(440, 18)" end="(440, 22)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(440, 23)" end="(440, 34)">
                                        <AtomNode start="(440, 23)" end="(440, 24)" leading="" trailing="" val="["/>
                                        <NullNode start="(440, 24)" end="(440, 33)">
                                          <OtherNode start="(440, 24)" end="(440, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(440, 24)" end="(440, 33)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(440, 33)" end="(440, 34)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(441, 3)" end="(441, 54)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(441, 3)" end="(441, 24)">
                              <OtherNode start="(441, 3)" end="(441, 24)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(441, 3)" end="(441, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(441, 5)" end="(441, 10)">
                                  <NullNode/>
                                  <IdentNode start="(441, 5)" end="(441, 10)" leading="" trailing=" " raw_val="case4" val="case4"/>
                                </GroupNode>
                                <NullNode start="(441, 11)" end="(441, 24)">
                                  <IdentNode start="(441, 11)" end="(441, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(441, 13)" end="(441, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(441, 15)" end="(441, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(441, 17)" end="(441, 20)" leading="" trailing=" " raw_val="iha" val="iha"/>
                                  <IdentNode start="(441, 21)" end="(441, 24)" leading="" trailing=" " raw_val="ihb" val="ihb"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(441, 25)" end="(441, 54)">
                              <AtomNode start="(441, 25)" end="(441, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(441, 28)" end="(441, 54)">
                                <TacticTacticseq1IndentedNode start="(441, 28)" end="(441, 54)">
                                  <NullNode start="(441, 28)" end="(441, 54)">
                                    <OtherNode start="(441, 28)" end="(441, 54)" kind="Lean.Parser.Tactic.simp" state_before="case case4&#10;ctx : Context&#10;k : Nat&#10;a b : Expr&#10;iha : ∀ {p : Poly}, Poly.denote ctx (toPoly.go k a p) = k * denote ctx a + Poly.denote ctx p&#10;ihb : ∀ {p : Poly}, Poly.denote ctx (toPoly.go k b p) = k * denote ctx b + Poly.denote ctx p&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (a.add b) p) = k * denote ctx (a.add b) + Poly.denote ctx p" state_after="no goals" tactic="simp [toPoly.go, iha, ihb]">
                                      <AtomNode start="(441, 28)" end="(441, 32)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(441, 33)" end="(441, 54)">
                                        <AtomNode start="(441, 33)" end="(441, 34)" leading="" trailing="" val="["/>
                                        <NullNode start="(441, 34)" end="(441, 53)">
                                          <OtherNode start="(441, 34)" end="(441, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(441, 34)" end="(441, 43)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(441, 43)" end="(441, 44)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(441, 45)" end="(441, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(441, 45)" end="(441, 48)" leading="" trailing="" raw_val="iha" val="iha"/>
                                          </OtherNode>
                                          <AtomNode start="(441, 48)" end="(441, 49)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(441, 50)" end="(441, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(441, 50)" end="(441, 53)" leading="" trailing="" raw_val="ihb" val="ihb"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(441, 53)" end="(441, 54)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(442, 3)" end="(442, 55)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(442, 3)" end="(442, 19)">
                              <OtherNode start="(442, 3)" end="(442, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(442, 3)" end="(442, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(442, 5)" end="(442, 10)">
                                  <NullNode/>
                                  <IdentNode start="(442, 5)" end="(442, 10)" leading="" trailing=" " raw_val="case5" val="case5"/>
                                </GroupNode>
                                <NullNode start="(442, 11)" end="(442, 19)">
                                  <IdentNode start="(442, 11)" end="(442, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(442, 13)" end="(442, 15)" leading="" trailing=" " raw_val="k'" val="k'"/>
                                  <IdentNode start="(442, 16)" end="(442, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(442, 18)" end="(442, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(442, 20)" end="(442, 55)">
                              <AtomNode start="(442, 20)" end="(442, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(442, 23)" end="(442, 55)">
                                <TacticTacticseq1IndentedNode start="(442, 23)" end="(442, 55)">
                                  <NullNode start="(442, 23)" end="(442, 55)">
                                    <OtherNode start="(442, 23)" end="(442, 55)" kind="Lean.Parser.Tactic.simp" state_before="case case5&#10;ctx : Context&#10;k k' : Nat&#10;a : Expr&#10;h : (k' == 0) = true&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (mulL k' a) p) = k * denote ctx (mulL k' a) + Poly.denote ctx p" state_after="no goals" tactic="simp [toPoly.go, h, eq_of_beq h]">
                                      <AtomNode start="(442, 23)" end="(442, 27)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(442, 28)" end="(442, 55)">
                                        <AtomNode start="(442, 28)" end="(442, 29)" leading="" trailing="" val="["/>
                                        <NullNode start="(442, 29)" end="(442, 54)">
                                          <OtherNode start="(442, 29)" end="(442, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(442, 29)" end="(442, 38)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(442, 38)" end="(442, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(442, 40)" end="(442, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(442, 40)" end="(442, 41)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                          <AtomNode start="(442, 41)" end="(442, 42)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(442, 43)" end="(442, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(442, 43)" end="(442, 54)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(442, 43)" end="(442, 52)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                              <NullNode start="(442, 53)" end="(442, 54)">
                                                <IdentNode start="(442, 53)" end="(442, 54)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(442, 54)" end="(442, 55)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(443, 3)" end="(445, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(443, 3)" end="(443, 22)">
                              <OtherNode start="(443, 3)" end="(443, 22)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(443, 3)" end="(443, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(443, 5)" end="(443, 10)">
                                  <NullNode/>
                                  <IdentNode start="(443, 5)" end="(443, 10)" leading="" trailing=" " raw_val="case6" val="case6"/>
                                </GroupNode>
                                <NullNode start="(443, 11)" end="(443, 22)">
                                  <IdentNode start="(443, 11)" end="(443, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(443, 13)" end="(443, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(443, 15)" end="(443, 17)" leading="" trailing=" " raw_val="k'" val="k'"/>
                                  <IdentNode start="(443, 18)" end="(443, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(443, 20)" end="(443, 22)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(443, 23)" end="(445, 44)">
                              <AtomNode start="(443, 23)" end="(443, 25)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(444, 5)" end="(445, 44)">
                                <TacticTacticseq1IndentedNode start="(444, 5)" end="(445, 44)">
                                  <NullNode start="(444, 5)" end="(445, 44)">
                                    <OtherNode start="(444, 5)" end="(444, 42)" kind="Lean.Parser.Tactic.simp" state_before="case case6&#10;ctx : Context&#10;k a : Nat&#10;k' : Expr&#10;h : (a == 0) = false&#10;ih : ∀ {p : Poly}, Poly.denote ctx (toPoly.go (k * a) k' p) = k * a * denote ctx k' + Poly.denote ctx p&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (mulL a k') p) = k * denote ctx (mulL a k') + Poly.denote ctx p" state_after="case case6&#10;ctx : Context&#10;k a : Nat&#10;k' : Expr&#10;h : (a == 0) = false&#10;ih : ∀ {p : Poly}, Poly.denote ctx (toPoly.go (k * a) k' p) = k * a * denote ctx k' + Poly.denote ctx p&#10;p : Poly&#10;⊢ Poly.denote ctx ((bif a == 0 then id else toPoly.go (k * a) k') p) = k * (a * denote ctx k') + Poly.denote ctx p" tactic="simp only [toPoly.go, denote, mul_eq]">
                                      <AtomNode start="(444, 5)" end="(444, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(444, 10)" end="(444, 14)">
                                        <AtomNode start="(444, 10)" end="(444, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(444, 15)" end="(444, 42)">
                                        <AtomNode start="(444, 15)" end="(444, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(444, 16)" end="(444, 41)">
                                          <OtherNode start="(444, 16)" end="(444, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(444, 16)" end="(444, 25)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(444, 25)" end="(444, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(444, 27)" end="(444, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(444, 27)" end="(444, 33)" leading="" trailing="" raw_val="denote" val="denote" full_name="Nat.Linear.Expr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(39, 5)" def_end="(39, 16)"/>
                                          </OtherNode>
                                          <AtomNode start="(444, 33)" end="(444, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(444, 35)" end="(444, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(444, 35)" end="(444, 41)" leading="" trailing="" raw_val="mul_eq" val="mul_eq" full_name="Nat.mul_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(444, 41)" end="(444, 42)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(445, 5)" end="(445, 44)" kind="Lean.Parser.Tactic.simp" state_before="case case6&#10;ctx : Context&#10;k a : Nat&#10;k' : Expr&#10;h : (a == 0) = false&#10;ih : ∀ {p : Poly}, Poly.denote ctx (toPoly.go (k * a) k' p) = k * a * denote ctx k' + Poly.denote ctx p&#10;p : Poly&#10;⊢ Poly.denote ctx ((bif a == 0 then id else toPoly.go (k * a) k') p) = k * (a * denote ctx k') + Poly.denote ctx p" state_after="no goals" tactic="simp [h, cond_false, ih, Nat.mul_assoc]">
                                      <AtomNode start="(445, 5)" end="(445, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(445, 10)" end="(445, 44)">
                                        <AtomNode start="(445, 10)" end="(445, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(445, 11)" end="(445, 43)">
                                          <OtherNode start="(445, 11)" end="(445, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(445, 11)" end="(445, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                          <AtomNode start="(445, 12)" end="(445, 13)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(445, 14)" end="(445, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(445, 14)" end="(445, 24)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(445, 24)" end="(445, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(445, 26)" end="(445, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(445, 26)" end="(445, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(445, 28)" end="(445, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(445, 30)" end="(445, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(445, 30)" end="(445, 43)" leading="" trailing="" raw_val="Nat.mul_assoc" val="Nat.mul_assoc" full_name="Nat.mul_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(445, 43)" end="(445, 44)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(446, 3)" end="(448, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(446, 3)" end="(446, 19)">
                              <OtherNode start="(446, 3)" end="(446, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(446, 3)" end="(446, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(446, 5)" end="(446, 10)">
                                  <NullNode/>
                                  <IdentNode start="(446, 5)" end="(446, 10)" leading="" trailing=" " raw_val="case7" val="case7"/>
                                </GroupNode>
                                <NullNode start="(446, 11)" end="(446, 19)">
                                  <IdentNode start="(446, 11)" end="(446, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(446, 13)" end="(446, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(446, 15)" end="(446, 17)" leading="" trailing=" " raw_val="k'" val="k'"/>
                                  <IdentNode start="(446, 18)" end="(446, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(446, 20)" end="(448, 26)">
                              <AtomNode start="(446, 20)" end="(446, 22)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(447, 5)" end="(448, 26)">
                                <TacticTacticseq1IndentedNode start="(447, 5)" end="(448, 26)">
                                  <NullNode start="(447, 5)" end="(448, 26)">
                                    <OtherNode start="(447, 5)" end="(447, 42)" kind="Lean.Parser.Tactic.simp" state_before="case case7&#10;ctx : Context&#10;k : Nat&#10;a : Expr&#10;k' : Nat&#10;h : (k' == 0) = true&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (a.mulR k') p) = k * denote ctx (a.mulR k') + Poly.denote ctx p" state_after="case case7&#10;ctx : Context&#10;k : Nat&#10;a : Expr&#10;k' : Nat&#10;h : (k' == 0) = true&#10;p : Poly&#10;⊢ Poly.denote ctx ((bif k' == 0 then id else toPoly.go (k * k') a) p) = k * (denote ctx a * k') + Poly.denote ctx p" tactic="simp only [toPoly.go, denote, mul_eq]">
                                      <AtomNode start="(447, 5)" end="(447, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(447, 10)" end="(447, 14)">
                                        <AtomNode start="(447, 10)" end="(447, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(447, 15)" end="(447, 42)">
                                        <AtomNode start="(447, 15)" end="(447, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(447, 16)" end="(447, 41)">
                                          <OtherNode start="(447, 16)" end="(447, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(447, 16)" end="(447, 25)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(447, 25)" end="(447, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(447, 27)" end="(447, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(447, 27)" end="(447, 33)" leading="" trailing="" raw_val="denote" val="denote" full_name="Nat.Linear.Expr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(39, 5)" def_end="(39, 16)"/>
                                          </OtherNode>
                                          <AtomNode start="(447, 33)" end="(447, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(447, 35)" end="(447, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(447, 35)" end="(447, 41)" leading="" trailing="" raw_val="mul_eq" val="mul_eq" full_name="Nat.mul_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(447, 41)" end="(447, 42)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(448, 5)" end="(448, 26)" kind="Lean.Parser.Tactic.simp" state_before="case case7&#10;ctx : Context&#10;k : Nat&#10;a : Expr&#10;k' : Nat&#10;h : (k' == 0) = true&#10;p : Poly&#10;⊢ Poly.denote ctx ((bif k' == 0 then id else toPoly.go (k * k') a) p) = k * (denote ctx a * k') + Poly.denote ctx p" state_after="no goals" tactic="simp [h, eq_of_beq h]">
                                      <AtomNode start="(448, 5)" end="(448, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(448, 10)" end="(448, 26)">
                                        <AtomNode start="(448, 10)" end="(448, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(448, 11)" end="(448, 25)">
                                          <OtherNode start="(448, 11)" end="(448, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(448, 11)" end="(448, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                          <AtomNode start="(448, 12)" end="(448, 13)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(448, 14)" end="(448, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(448, 14)" end="(448, 25)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(448, 14)" end="(448, 23)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                              <NullNode start="(448, 24)" end="(448, 25)">
                                                <IdentNode start="(448, 24)" end="(448, 25)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(448, 25)" end="(448, 26)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(449, 3)" end="(451, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(449, 3)" end="(449, 22)">
                              <OtherNode start="(449, 3)" end="(449, 22)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(449, 3)" end="(449, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(449, 5)" end="(449, 10)">
                                  <NullNode/>
                                  <IdentNode start="(449, 5)" end="(449, 10)" leading="" trailing=" " raw_val="case8" val="case8"/>
                                </GroupNode>
                                <NullNode start="(449, 11)" end="(449, 22)">
                                  <IdentNode start="(449, 11)" end="(449, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                  <IdentNode start="(449, 13)" end="(449, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(449, 15)" end="(449, 17)" leading="" trailing=" " raw_val="k'" val="k'"/>
                                  <IdentNode start="(449, 18)" end="(449, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(449, 20)" end="(449, 22)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(449, 23)" end="(451, 44)">
                              <AtomNode start="(449, 23)" end="(449, 25)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(450, 5)" end="(451, 44)">
                                <TacticTacticseq1IndentedNode start="(450, 5)" end="(451, 44)">
                                  <NullNode start="(450, 5)" end="(451, 44)">
                                    <OtherNode start="(450, 5)" end="(450, 42)" kind="Lean.Parser.Tactic.simp" state_before="case case8&#10;ctx : Context&#10;k : Nat&#10;a : Expr&#10;k' : Nat&#10;h : (k' == 0) = false&#10;ih : ∀ {p : Poly}, Poly.denote ctx (toPoly.go (k * k') a p) = k * k' * denote ctx a + Poly.denote ctx p&#10;p : Poly&#10;⊢ Poly.denote ctx (toPoly.go k (a.mulR k') p) = k * denote ctx (a.mulR k') + Poly.denote ctx p" state_after="case case8&#10;ctx : Context&#10;k : Nat&#10;a : Expr&#10;k' : Nat&#10;h : (k' == 0) = false&#10;ih : ∀ {p : Poly}, Poly.denote ctx (toPoly.go (k * k') a p) = k * k' * denote ctx a + Poly.denote ctx p&#10;p : Poly&#10;⊢ Poly.denote ctx ((bif k' == 0 then id else toPoly.go (k * k') a) p) = k * (denote ctx a * k') + Poly.denote ctx p" tactic="simp only [toPoly.go, denote, mul_eq]">
                                      <AtomNode start="(450, 5)" end="(450, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(450, 10)" end="(450, 14)">
                                        <AtomNode start="(450, 10)" end="(450, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(450, 15)" end="(450, 42)">
                                        <AtomNode start="(450, 15)" end="(450, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(450, 16)" end="(450, 41)">
                                          <OtherNode start="(450, 16)" end="(450, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(450, 16)" end="(450, 25)" leading="" trailing="" raw_val="toPoly.go" val="toPoly.go" full_name="Nat.Linear.Expr.toPoly.go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(120, 3)" def_end="(120, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(450, 25)" end="(450, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(450, 27)" end="(450, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(450, 27)" end="(450, 33)" leading="" trailing="" raw_val="denote" val="denote" full_name="Nat.Linear.Expr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(39, 5)" def_end="(39, 16)"/>
                                          </OtherNode>
                                          <AtomNode start="(450, 33)" end="(450, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(450, 35)" end="(450, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(450, 35)" end="(450, 41)" leading="" trailing="" raw_val="mul_eq" val="mul_eq" full_name="Nat.mul_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(450, 41)" end="(450, 42)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(451, 5)" end="(451, 44)" kind="Lean.Parser.Tactic.simp" state_before="case case8&#10;ctx : Context&#10;k : Nat&#10;a : Expr&#10;k' : Nat&#10;h : (k' == 0) = false&#10;ih : ∀ {p : Poly}, Poly.denote ctx (toPoly.go (k * k') a p) = k * k' * denote ctx a + Poly.denote ctx p&#10;p : Poly&#10;⊢ Poly.denote ctx ((bif k' == 0 then id else toPoly.go (k * k') a) p) = k * (denote ctx a * k') + Poly.denote ctx p" state_after="no goals" tactic="simp [h, cond_false, ih, Nat.mul_assoc]">
                                      <AtomNode start="(451, 5)" end="(451, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(451, 10)" end="(451, 44)">
                                        <AtomNode start="(451, 10)" end="(451, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(451, 11)" end="(451, 43)">
                                          <OtherNode start="(451, 11)" end="(451, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(451, 11)" end="(451, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                          <AtomNode start="(451, 12)" end="(451, 13)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(451, 14)" end="(451, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(451, 14)" end="(451, 24)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(451, 24)" end="(451, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(451, 26)" end="(451, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(451, 26)" end="(451, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(451, 28)" end="(451, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(451, 30)" end="(451, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(451, 30)" end="(451, 43)" leading="" trailing="" raw_val="Nat.mul_assoc" val="Nat.mul_assoc" full_name="Nat.mul_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(451, 43)" end="(451, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(453, 1)" end="(454, 39)" name="Expr.denote_toPoly" full_name="Nat.Linear.Expr.denote_toPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(453, 1)" end="(454, 39)" name="Expr.denote_toPoly" full_name="Nat.Linear.Expr.denote_toPoly" _is_private_decl="False">
        <AtomNode start="(453, 1)" end="(453, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(453, 9)" end="(453, 27)">
          <IdentNode start="(453, 9)" end="(453, 27)" leading="" trailing=" " raw_val="Expr.denote_toPoly" val="Expr.denote_toPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(453, 28)" end="(453, 91)">
          <NullNode start="(453, 28)" end="(453, 54)">
            <TermExplicitbinderNode start="(453, 28)" end="(453, 43)">
              <AtomNode start="(453, 28)" end="(453, 29)" leading="" trailing="" val="("/>
              <NullNode start="(453, 29)" end="(453, 32)">
                <IdentNode start="(453, 29)" end="(453, 32)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(453, 33)" end="(453, 42)">
                <AtomNode start="(453, 33)" end="(453, 34)" leading="" trailing=" " val=":"/>
                <IdentNode start="(453, 35)" end="(453, 42)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(453, 42)" end="(453, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(453, 44)" end="(453, 54)">
              <AtomNode start="(453, 44)" end="(453, 45)" leading="" trailing="" val="("/>
              <NullNode start="(453, 45)" end="(453, 46)">
                <IdentNode start="(453, 45)" end="(453, 46)" leading="" trailing=" " raw_val="e" val="e"/>
              </NullNode>
              <NullNode start="(453, 47)" end="(453, 53)">
                <AtomNode start="(453, 47)" end="(453, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(453, 49)" end="(453, 53)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(453, 53)" end="(453, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(453, 55)" end="(453, 91)">
            <AtomNode start="(453, 55)" end="(453, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(453, 57)" end="(453, 91)" kind="«term_=_»">
              <OtherNode start="(453, 57)" end="(453, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(453, 57)" end="(453, 72)" leading="" trailing=" " raw_val="e.toPoly.denote" val="e.toPoly.denote"/>
                <NullNode start="(453, 73)" end="(453, 76)">
                  <IdentNode start="(453, 73)" end="(453, 76)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(453, 77)" end="(453, 78)" leading="" trailing=" " val="="/>
              <OtherNode start="(453, 79)" end="(453, 91)" kind="Lean.Parser.Term.app">
                <IdentNode start="(453, 79)" end="(453, 87)" leading="" trailing=" " raw_val="e.denote" val="e.denote"/>
                <NullNode start="(453, 88)" end="(453, 91)">
                  <IdentNode start="(453, 88)" end="(453, 91)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(453, 92)" end="(454, 39)">
          <AtomNode start="(453, 92)" end="(453, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(453, 95)" end="(454, 39)">
            <AtomNode start="(453, 95)" end="(453, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(454, 3)" end="(454, 39)">
              <TacticTacticseq1IndentedNode start="(454, 3)" end="(454, 39)">
                <NullNode start="(454, 3)" end="(454, 39)">
                  <OtherNode start="(454, 3)" end="(454, 39)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;e : Expr&#10;⊢ Poly.denote ctx e.toPoly = denote ctx e" state_after="no goals" tactic="simp [toPoly, Expr.denote_toPoly_go]">
                    <AtomNode start="(454, 3)" end="(454, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(454, 8)" end="(454, 39)">
                      <AtomNode start="(454, 8)" end="(454, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(454, 9)" end="(454, 38)">
                        <OtherNode start="(454, 9)" end="(454, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(454, 9)" end="(454, 15)" leading="" trailing="" raw_val="toPoly" val="toPoly" full_name="Nat.Linear.Expr.toPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(115, 5)" def_end="(115, 16)"/>
                        </OtherNode>
                        <AtomNode start="(454, 15)" end="(454, 16)" leading="" trailing=" " val=","/>
                        <OtherNode start="(454, 17)" end="(454, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(454, 17)" end="(454, 38)" leading="" trailing="" raw_val="Expr.denote_toPoly_go" val="Expr.denote_toPoly_go" full_name="Nat.Linear.Expr.denote_toPoly_go" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(433, 9)" def_end="(433, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(454, 38)" end="(454, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(456, 1)" end="(456, 42)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(456, 1)" end="(456, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(456, 11)" end="(456, 12)" leading="" trailing="" val="["/>
      <NullNode start="(456, 12)" end="(456, 22)">
        <OtherNode start="(456, 12)" end="(456, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(456, 12)" end="(456, 17)">
            <NullNode start="(456, 12)" end="(456, 17)">
              <OtherNode start="(456, 12)" end="(456, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(456, 12)" end="(456, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(456, 18)" end="(456, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(456, 18)" end="(456, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(456, 22)" end="(456, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(456, 24)" end="(456, 42)">
        <IdentNode start="(456, 24)" end="(456, 42)" leading="" trailing="&#10;&#10;" raw_val="Expr.denote_toPoly" val="Expr.denote_toPoly" full_name="Nat.Linear.Expr.denote_toPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(453, 9)" def_end="(453, 27)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(458, 1)" end="(462, 13)" name="Expr.eq_of_toNormPoly" full_name="Nat.Linear.Expr.eq_of_toNormPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(458, 1)" end="(462, 13)" name="Expr.eq_of_toNormPoly" full_name="Nat.Linear.Expr.eq_of_toNormPoly" _is_private_decl="False">
        <AtomNode start="(458, 1)" end="(458, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(458, 9)" end="(458, 30)">
          <IdentNode start="(458, 9)" end="(458, 30)" leading="" trailing=" " raw_val="Expr.eq_of_toNormPoly" val="Expr.eq_of_toNormPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(458, 31)" end="(458, 123)">
          <NullNode start="(458, 31)" end="(458, 93)">
            <TermExplicitbinderNode start="(458, 31)" end="(458, 46)">
              <AtomNode start="(458, 31)" end="(458, 32)" leading="" trailing="" val="("/>
              <NullNode start="(458, 32)" end="(458, 35)">
                <IdentNode start="(458, 32)" end="(458, 35)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(458, 36)" end="(458, 45)">
                <AtomNode start="(458, 36)" end="(458, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(458, 38)" end="(458, 45)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(458, 45)" end="(458, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(458, 47)" end="(458, 59)">
              <AtomNode start="(458, 47)" end="(458, 48)" leading="" trailing="" val="("/>
              <NullNode start="(458, 48)" end="(458, 51)">
                <IdentNode start="(458, 48)" end="(458, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(458, 50)" end="(458, 51)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(458, 52)" end="(458, 58)">
                <AtomNode start="(458, 52)" end="(458, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(458, 54)" end="(458, 58)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(458, 58)" end="(458, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(458, 60)" end="(458, 93)">
              <AtomNode start="(458, 60)" end="(458, 61)" leading="" trailing="" val="("/>
              <NullNode start="(458, 61)" end="(458, 62)">
                <IdentNode start="(458, 61)" end="(458, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(458, 63)" end="(458, 92)">
                <AtomNode start="(458, 63)" end="(458, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(458, 65)" end="(458, 92)" kind="«term_=_»">
                  <IdentNode start="(458, 65)" end="(458, 77)" leading="" trailing=" " raw_val="a.toNormPoly" val="a.toNormPoly"/>
                  <AtomNode start="(458, 78)" end="(458, 79)" leading="" trailing=" " val="="/>
                  <IdentNode start="(458, 80)" end="(458, 92)" leading="" trailing="" raw_val="b.toNormPoly" val="b.toNormPoly"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(458, 92)" end="(458, 93)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(458, 94)" end="(458, 123)">
            <AtomNode start="(458, 94)" end="(458, 95)" leading="" trailing=" " val=":"/>
            <OtherNode start="(458, 96)" end="(458, 123)" kind="«term_=_»">
              <OtherNode start="(458, 96)" end="(458, 108)" kind="Lean.Parser.Term.app">
                <IdentNode start="(458, 96)" end="(458, 104)" leading="" trailing=" " raw_val="a.denote" val="a.denote"/>
                <NullNode start="(458, 105)" end="(458, 108)">
                  <IdentNode start="(458, 105)" end="(458, 108)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(458, 109)" end="(458, 110)" leading="" trailing=" " val="="/>
              <OtherNode start="(458, 111)" end="(458, 123)" kind="Lean.Parser.Term.app">
                <IdentNode start="(458, 111)" end="(458, 119)" leading="" trailing=" " raw_val="b.denote" val="b.denote"/>
                <NullNode start="(458, 120)" end="(458, 123)">
                  <IdentNode start="(458, 120)" end="(458, 123)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(458, 124)" end="(462, 13)">
          <AtomNode start="(458, 124)" end="(458, 126)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(458, 127)" end="(462, 13)">
            <AtomNode start="(458, 127)" end="(458, 129)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(459, 3)" end="(462, 13)">
              <TacticTacticseq1IndentedNode start="(459, 3)" end="(462, 13)">
                <NullNode start="(459, 3)" end="(462, 13)">
                  <OtherNode start="(459, 3)" end="(459, 36)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;a b : Expr&#10;h : a.toNormPoly = b.toNormPoly&#10;⊢ denote ctx a = denote ctx b" state_after="ctx : Context&#10;a b : Expr&#10;h : Poly.norm.go a.toPoly [] = Poly.norm.go b.toPoly []&#10;⊢ denote ctx a = denote ctx b" tactic="simp [toNormPoly, Poly.norm] at h">
                    <AtomNode start="(459, 3)" end="(459, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(459, 8)" end="(459, 31)">
                      <AtomNode start="(459, 8)" end="(459, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(459, 9)" end="(459, 30)">
                        <OtherNode start="(459, 9)" end="(459, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(459, 9)" end="(459, 19)" leading="" trailing="" raw_val="toNormPoly" val="toNormPoly" full_name="Nat.Linear.Expr.toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(127, 5)" def_end="(127, 20)"/>
                        </OtherNode>
                        <AtomNode start="(459, 19)" end="(459, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(459, 21)" end="(459, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(459, 21)" end="(459, 30)" leading="" trailing="" raw_val="Poly.norm" val="Poly.norm" full_name="Nat.Linear.Poly.norm" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(64, 5)" def_end="(64, 14)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(459, 30)" end="(459, 31)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(459, 32)" end="(459, 36)">
                      <OtherNode start="(459, 32)" end="(459, 36)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(459, 32)" end="(459, 34)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(459, 35)" end="(459, 36)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(459, 35)" end="(459, 36)">
                            <IdentNode start="(459, 35)" end="(459, 36)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(460, 3)" end="(460, 41)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;a b : Expr&#10;h : Poly.norm.go a.toPoly [] = Poly.norm.go b.toPoly []&#10;⊢ denote ctx a = denote ctx b" state_after="ctx : Context&#10;a b : Expr&#10;h✝ : Poly.norm.go a.toPoly [] = Poly.norm.go b.toPoly []&#10;h : Poly.denote ctx (Poly.norm.go a.toPoly []) = Poly.denote ctx (Poly.norm.go b.toPoly [])&#10;⊢ denote ctx a = denote ctx b" tactic="have h := congrArg (Poly.denote ctx) h">
                    <AtomNode start="(460, 3)" end="(460, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(460, 8)" end="(460, 41)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(460, 8)" end="(460, 41)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(460, 8)" end="(460, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(460, 8)" end="(460, 9)" leading="" trailing=" " raw_val="h" val="h"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(460, 10)" end="(460, 12)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(460, 13)" end="(460, 41)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(460, 13)" end="(460, 21)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(460, 22)" end="(460, 41)">
                            <OtherNode start="(460, 22)" end="(460, 39)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(460, 22)" end="(460, 23)" leading="" trailing="" val="("/>
                              <OtherNode start="(460, 23)" end="(460, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(460, 23)" end="(460, 34)" leading="" trailing=" " raw_val="Poly.denote" val="Poly.denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                                <NullNode start="(460, 35)" end="(460, 38)">
                                  <IdentNode start="(460, 35)" end="(460, 38)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(460, 38)" end="(460, 39)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(460, 40)" end="(460, 41)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(461, 3)" end="(461, 12)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;a b : Expr&#10;h✝ : Poly.norm.go a.toPoly [] = Poly.norm.go b.toPoly []&#10;h : Poly.denote ctx (Poly.norm.go a.toPoly []) = Poly.denote ctx (Poly.norm.go b.toPoly [])&#10;⊢ denote ctx a = denote ctx b" state_after="ctx : Context&#10;a b : Expr&#10;h✝ : Poly.norm.go a.toPoly [] = Poly.norm.go b.toPoly []&#10;h : denote ctx a = denote ctx b&#10;⊢ denote ctx a = denote ctx b" tactic="simp at h">
                    <AtomNode start="(461, 3)" end="(461, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(461, 8)" end="(461, 12)">
                      <OtherNode start="(461, 8)" end="(461, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(461, 8)" end="(461, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(461, 11)" end="(461, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(461, 11)" end="(461, 12)">
                            <IdentNode start="(461, 11)" end="(461, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(462, 3)" end="(462, 13)" kind="Lean.Parser.Tactic.assumption" state_before="ctx : Context&#10;a b : Expr&#10;h✝ : Poly.norm.go a.toPoly [] = Poly.norm.go b.toPoly []&#10;h : denote ctx a = denote ctx b&#10;⊢ denote ctx a = denote ctx b" state_after="no goals" tactic="assumption">
                    <AtomNode start="(462, 3)" end="(462, 13)" leading="" trailing="&#10;&#10;" val="assumption"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(464, 1)" end="(468, 18)" name="Expr.of_cancel_eq" full_name="Nat.Linear.Expr.of_cancel_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(464, 1)" end="(468, 18)" name="Expr.of_cancel_eq" full_name="Nat.Linear.Expr.of_cancel_eq" _is_private_decl="False">
        <AtomNode start="(464, 1)" end="(464, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(464, 9)" end="(464, 26)">
          <IdentNode start="(464, 9)" end="(464, 26)" leading="" trailing=" " raw_val="Expr.of_cancel_eq" val="Expr.of_cancel_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(464, 27)" end="(464, 190)">
          <NullNode start="(464, 27)" end="(464, 126)">
            <TermExplicitbinderNode start="(464, 27)" end="(464, 42)">
              <AtomNode start="(464, 27)" end="(464, 28)" leading="" trailing="" val="("/>
              <NullNode start="(464, 28)" end="(464, 31)">
                <IdentNode start="(464, 28)" end="(464, 31)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(464, 32)" end="(464, 41)">
                <AtomNode start="(464, 32)" end="(464, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(464, 34)" end="(464, 41)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(464, 41)" end="(464, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(464, 43)" end="(464, 59)">
              <AtomNode start="(464, 43)" end="(464, 44)" leading="" trailing="" val="("/>
              <NullNode start="(464, 44)" end="(464, 51)">
                <IdentNode start="(464, 44)" end="(464, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(464, 46)" end="(464, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(464, 48)" end="(464, 49)" leading="" trailing=" " raw_val="c" val="c"/>
                <IdentNode start="(464, 50)" end="(464, 51)" leading="" trailing=" " raw_val="d" val="d"/>
              </NullNode>
              <NullNode start="(464, 52)" end="(464, 58)">
                <AtomNode start="(464, 52)" end="(464, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(464, 54)" end="(464, 58)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(464, 58)" end="(464, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(464, 60)" end="(464, 126)">
              <AtomNode start="(464, 60)" end="(464, 61)" leading="" trailing="" val="("/>
              <NullNode start="(464, 61)" end="(464, 62)">
                <IdentNode start="(464, 61)" end="(464, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(464, 63)" end="(464, 125)">
                <AtomNode start="(464, 63)" end="(464, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 65)" end="(464, 125)" kind="«term_=_»">
                  <OtherNode start="(464, 65)" end="(464, 102)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(464, 65)" end="(464, 76)" leading="" trailing=" " raw_val="Poly.cancel" val="Poly.cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                    <NullNode start="(464, 77)" end="(464, 102)">
                      <IdentNode start="(464, 77)" end="(464, 89)" leading="" trailing=" " raw_val="a.toNormPoly" val="a.toNormPoly"/>
                      <IdentNode start="(464, 90)" end="(464, 102)" leading="" trailing=" " raw_val="b.toNormPoly" val="b.toNormPoly"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(464, 103)" end="(464, 104)" leading="" trailing=" " val="="/>
                  <OtherNode start="(464, 105)" end="(464, 125)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(464, 105)" end="(464, 106)" leading="" trailing="" val="("/>
                    <NullNode start="(464, 106)" end="(464, 124)">
                      <IdentNode start="(464, 106)" end="(464, 114)" leading="" trailing="" raw_val="c.toPoly" val="c.toPoly"/>
                      <AtomNode start="(464, 114)" end="(464, 115)" leading="" trailing=" " val=","/>
                      <NullNode start="(464, 116)" end="(464, 124)">
                        <IdentNode start="(464, 116)" end="(464, 124)" leading="" trailing="" raw_val="d.toPoly" val="d.toPoly"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(464, 124)" end="(464, 125)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(464, 125)" end="(464, 126)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(464, 127)" end="(464, 190)">
            <AtomNode start="(464, 127)" end="(464, 128)" leading="" trailing=" " val=":"/>
            <OtherNode start="(464, 129)" end="(464, 190)" kind="«term_=_»">
              <OtherNode start="(464, 129)" end="(464, 158)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(464, 129)" end="(464, 130)" leading="" trailing="" val="("/>
                <OtherNode start="(464, 130)" end="(464, 157)" kind="«term_=_»">
                  <OtherNode start="(464, 130)" end="(464, 142)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(464, 130)" end="(464, 138)" leading="" trailing=" " raw_val="a.denote" val="a.denote"/>
                    <NullNode start="(464, 139)" end="(464, 142)">
                      <IdentNode start="(464, 139)" end="(464, 142)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(464, 143)" end="(464, 144)" leading="" trailing=" " val="="/>
                  <OtherNode start="(464, 145)" end="(464, 157)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(464, 145)" end="(464, 153)" leading="" trailing=" " raw_val="b.denote" val="b.denote"/>
                    <NullNode start="(464, 154)" end="(464, 157)">
                      <IdentNode start="(464, 154)" end="(464, 157)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(464, 157)" end="(464, 158)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(464, 159)" end="(464, 160)" leading="" trailing=" " val="="/>
              <OtherNode start="(464, 161)" end="(464, 190)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(464, 161)" end="(464, 162)" leading="" trailing="" val="("/>
                <OtherNode start="(464, 162)" end="(464, 189)" kind="«term_=_»">
                  <OtherNode start="(464, 162)" end="(464, 174)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(464, 162)" end="(464, 170)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                    <NullNode start="(464, 171)" end="(464, 174)">
                      <IdentNode start="(464, 171)" end="(464, 174)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(464, 175)" end="(464, 176)" leading="" trailing=" " val="="/>
                  <OtherNode start="(464, 177)" end="(464, 189)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(464, 177)" end="(464, 185)" leading="" trailing=" " raw_val="d.denote" val="d.denote"/>
                    <NullNode start="(464, 186)" end="(464, 189)">
                      <IdentNode start="(464, 186)" end="(464, 189)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(464, 189)" end="(464, 190)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(464, 191)" end="(468, 18)">
          <AtomNode start="(464, 191)" end="(464, 193)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(464, 194)" end="(468, 18)">
            <AtomNode start="(464, 194)" end="(464, 196)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(465, 3)" end="(468, 18)">
              <TacticTacticseq1IndentedNode start="(465, 3)" end="(468, 18)">
                <NullNode start="(465, 3)" end="(468, 18)">
                  <OtherNode start="(465, 3)" end="(465, 65)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;⊢ (denote ctx a = denote ctx b) = (denote ctx c = denote ctx d)" state_after="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_eq ctx (a.toNormPoly.cancel b.toNormPoly) = Poly.denote_eq ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a = denote ctx b) = (denote ctx c = denote ctx d)" tactic="have := Poly.denote_eq_cancel_eq ctx a.toNormPoly b.toNormPoly">
                    <AtomNode start="(465, 3)" end="(465, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(465, 8)" end="(465, 65)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(465, 8)" end="(465, 65)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(465, 8)" end="(465, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(465, 8)" end="(465, 8)" kind="hygieneInfo">
                            <IdentNode start="(465, 8)" end="(465, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(465, 8)" end="(465, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(465, 11)" end="(465, 65)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(465, 11)" end="(465, 35)" leading="" trailing=" " raw_val="Poly.denote_eq_cancel_eq" val="Poly.denote_eq_cancel_eq" full_name="Nat.Linear.Poly.denote_eq_cancel_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(348, 9)" def_end="(348, 33)"/>
                          <NullNode start="(465, 36)" end="(465, 65)">
                            <IdentNode start="(465, 36)" end="(465, 39)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(465, 40)" end="(465, 52)" leading="" trailing=" " raw_val="a.toNormPoly" val="a.toNormPoly"/>
                            <IdentNode start="(465, 53)" end="(465, 65)" leading="" trailing="&#10;  " raw_val="b.toNormPoly" val="b.toNormPoly"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(466, 3)" end="(466, 17)" kind="Lean.Parser.Tactic.rwSeq" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_eq ctx (a.toNormPoly.cancel b.toNormPoly) = Poly.denote_eq ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a = denote ctx b) = (denote ctx c = denote ctx d)" state_after="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_eq ctx (c.toPoly, d.toPoly) = Poly.denote_eq ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a = denote ctx b) = (denote ctx c = denote ctx d)" tactic="rw [h] at this">
                    <AtomNode start="(466, 3)" end="(466, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(466, 6)" end="(466, 9)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(466, 6)" end="(466, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(466, 7)" end="(466, 8)">
                        <OtherNode start="(466, 7)" end="(466, 8)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(466, 7)" end="(466, 8)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(466, 8)" end="(466, 9)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(466, 10)" end="(466, 17)">
                      <OtherNode start="(466, 10)" end="(466, 17)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(466, 10)" end="(466, 12)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(466, 13)" end="(466, 17)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(466, 13)" end="(466, 17)">
                            <IdentNode start="(466, 13)" end="(466, 17)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(467, 3)" end="(467, 68)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_eq ctx (c.toPoly, d.toPoly) = Poly.denote_eq ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a = denote ctx b) = (denote ctx c = denote ctx d)" state_after="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : (denote ctx c = denote ctx d) = (denote ctx a = denote ctx b)&#10;⊢ (denote ctx a = denote ctx b) = (denote ctx c = denote ctx d)" tactic="simp [toNormPoly, Poly.norm, Poly.denote_eq, -eq_iff_iff] at this">
                    <AtomNode start="(467, 3)" end="(467, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(467, 8)" end="(467, 60)">
                      <AtomNode start="(467, 8)" end="(467, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(467, 9)" end="(467, 59)">
                        <OtherNode start="(467, 9)" end="(467, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(467, 9)" end="(467, 19)" leading="" trailing="" raw_val="toNormPoly" val="toNormPoly" full_name="Nat.Linear.Expr.toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(127, 5)" def_end="(127, 20)"/>
                        </OtherNode>
                        <AtomNode start="(467, 19)" end="(467, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(467, 21)" end="(467, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(467, 21)" end="(467, 30)" leading="" trailing="" raw_val="Poly.norm" val="Poly.norm" full_name="Nat.Linear.Poly.norm" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(64, 5)" def_end="(64, 14)"/>
                        </OtherNode>
                        <AtomNode start="(467, 30)" end="(467, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(467, 32)" end="(467, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(467, 32)" end="(467, 46)" leading="" trailing="" raw_val="Poly.denote_eq" val="Poly.denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                        </OtherNode>
                        <AtomNode start="(467, 46)" end="(467, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(467, 48)" end="(467, 59)" kind="Lean.Parser.Tactic.simpErase">
                          <AtomNode start="(467, 48)" end="(467, 49)" leading="" trailing="" val="-"/>
                          <IdentNode start="(467, 49)" end="(467, 59)" leading="" trailing="" raw_val="eq_iff_iff" val="eq_iff_iff" full_name="eq_iff_iff" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(467, 59)" end="(467, 60)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(467, 61)" end="(467, 68)">
                      <OtherNode start="(467, 61)" end="(467, 68)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(467, 61)" end="(467, 63)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(467, 64)" end="(467, 68)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(467, 64)" end="(467, 68)">
                            <IdentNode start="(467, 64)" end="(467, 68)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(468, 3)" end="(468, 18)" kind="Lean.Parser.Tactic.exact" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : (denote ctx c = denote ctx d) = (denote ctx a = denote ctx b)&#10;⊢ (denote ctx a = denote ctx b) = (denote ctx c = denote ctx d)" state_after="no goals" tactic="exact this.symm">
                    <AtomNode start="(468, 3)" end="(468, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(468, 9)" end="(468, 18)" leading="" trailing="&#10;&#10;" raw_val="this.symm" val="this.symm"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(470, 1)" end="(474, 18)" name="Expr.of_cancel_le" full_name="Nat.Linear.Expr.of_cancel_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(470, 1)" end="(474, 18)" name="Expr.of_cancel_le" full_name="Nat.Linear.Expr.of_cancel_le" _is_private_decl="False">
        <AtomNode start="(470, 1)" end="(470, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(470, 9)" end="(470, 26)">
          <IdentNode start="(470, 9)" end="(470, 26)" leading="" trailing=" " raw_val="Expr.of_cancel_le" val="Expr.of_cancel_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(470, 27)" end="(470, 190)">
          <NullNode start="(470, 27)" end="(470, 126)">
            <TermExplicitbinderNode start="(470, 27)" end="(470, 42)">
              <AtomNode start="(470, 27)" end="(470, 28)" leading="" trailing="" val="("/>
              <NullNode start="(470, 28)" end="(470, 31)">
                <IdentNode start="(470, 28)" end="(470, 31)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(470, 32)" end="(470, 41)">
                <AtomNode start="(470, 32)" end="(470, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(470, 34)" end="(470, 41)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(470, 41)" end="(470, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(470, 43)" end="(470, 59)">
              <AtomNode start="(470, 43)" end="(470, 44)" leading="" trailing="" val="("/>
              <NullNode start="(470, 44)" end="(470, 51)">
                <IdentNode start="(470, 44)" end="(470, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(470, 46)" end="(470, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(470, 48)" end="(470, 49)" leading="" trailing=" " raw_val="c" val="c"/>
                <IdentNode start="(470, 50)" end="(470, 51)" leading="" trailing=" " raw_val="d" val="d"/>
              </NullNode>
              <NullNode start="(470, 52)" end="(470, 58)">
                <AtomNode start="(470, 52)" end="(470, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(470, 54)" end="(470, 58)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(470, 58)" end="(470, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(470, 60)" end="(470, 126)">
              <AtomNode start="(470, 60)" end="(470, 61)" leading="" trailing="" val="("/>
              <NullNode start="(470, 61)" end="(470, 62)">
                <IdentNode start="(470, 61)" end="(470, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(470, 63)" end="(470, 125)">
                <AtomNode start="(470, 63)" end="(470, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(470, 65)" end="(470, 125)" kind="«term_=_»">
                  <OtherNode start="(470, 65)" end="(470, 102)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(470, 65)" end="(470, 76)" leading="" trailing=" " raw_val="Poly.cancel" val="Poly.cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                    <NullNode start="(470, 77)" end="(470, 102)">
                      <IdentNode start="(470, 77)" end="(470, 89)" leading="" trailing=" " raw_val="a.toNormPoly" val="a.toNormPoly"/>
                      <IdentNode start="(470, 90)" end="(470, 102)" leading="" trailing=" " raw_val="b.toNormPoly" val="b.toNormPoly"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(470, 103)" end="(470, 104)" leading="" trailing=" " val="="/>
                  <OtherNode start="(470, 105)" end="(470, 125)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(470, 105)" end="(470, 106)" leading="" trailing="" val="("/>
                    <NullNode start="(470, 106)" end="(470, 124)">
                      <IdentNode start="(470, 106)" end="(470, 114)" leading="" trailing="" raw_val="c.toPoly" val="c.toPoly"/>
                      <AtomNode start="(470, 114)" end="(470, 115)" leading="" trailing=" " val=","/>
                      <NullNode start="(470, 116)" end="(470, 124)">
                        <IdentNode start="(470, 116)" end="(470, 124)" leading="" trailing="" raw_val="d.toPoly" val="d.toPoly"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(470, 124)" end="(470, 125)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(470, 125)" end="(470, 126)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(470, 127)" end="(470, 190)">
            <AtomNode start="(470, 127)" end="(470, 128)" leading="" trailing=" " val=":"/>
            <OtherNode start="(470, 129)" end="(470, 190)" kind="«term_=_»">
              <OtherNode start="(470, 129)" end="(470, 158)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(470, 129)" end="(470, 130)" leading="" trailing="" val="("/>
                <OtherNode start="(470, 130)" end="(470, 157)" kind="«term_≤_»">
                  <OtherNode start="(470, 130)" end="(470, 142)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(470, 130)" end="(470, 138)" leading="" trailing=" " raw_val="a.denote" val="a.denote"/>
                    <NullNode start="(470, 139)" end="(470, 142)">
                      <IdentNode start="(470, 139)" end="(470, 142)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(470, 143)" end="(470, 144)" leading="" trailing=" " val="≤"/>
                  <OtherNode start="(470, 145)" end="(470, 157)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(470, 145)" end="(470, 153)" leading="" trailing=" " raw_val="b.denote" val="b.denote"/>
                    <NullNode start="(470, 154)" end="(470, 157)">
                      <IdentNode start="(470, 154)" end="(470, 157)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(470, 157)" end="(470, 158)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(470, 159)" end="(470, 160)" leading="" trailing=" " val="="/>
              <OtherNode start="(470, 161)" end="(470, 190)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(470, 161)" end="(470, 162)" leading="" trailing="" val="("/>
                <OtherNode start="(470, 162)" end="(470, 189)" kind="«term_≤_»">
                  <OtherNode start="(470, 162)" end="(470, 174)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(470, 162)" end="(470, 170)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                    <NullNode start="(470, 171)" end="(470, 174)">
                      <IdentNode start="(470, 171)" end="(470, 174)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(470, 175)" end="(470, 176)" leading="" trailing=" " val="≤"/>
                  <OtherNode start="(470, 177)" end="(470, 189)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(470, 177)" end="(470, 185)" leading="" trailing=" " raw_val="d.denote" val="d.denote"/>
                    <NullNode start="(470, 186)" end="(470, 189)">
                      <IdentNode start="(470, 186)" end="(470, 189)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(470, 189)" end="(470, 190)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(470, 191)" end="(474, 18)">
          <AtomNode start="(470, 191)" end="(470, 193)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(470, 194)" end="(474, 18)">
            <AtomNode start="(470, 194)" end="(470, 196)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(471, 3)" end="(474, 18)">
              <TacticTacticseq1IndentedNode start="(471, 3)" end="(474, 18)">
                <NullNode start="(471, 3)" end="(474, 18)">
                  <OtherNode start="(471, 3)" end="(471, 65)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;⊢ (denote ctx a ≤ denote ctx b) = (denote ctx c ≤ denote ctx d)" state_after="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_le ctx (a.toNormPoly.cancel b.toNormPoly) = Poly.denote_le ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a ≤ denote ctx b) = (denote ctx c ≤ denote ctx d)" tactic="have := Poly.denote_le_cancel_eq ctx a.toNormPoly b.toNormPoly">
                    <AtomNode start="(471, 3)" end="(471, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(471, 8)" end="(471, 65)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(471, 8)" end="(471, 65)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(471, 8)" end="(471, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(471, 8)" end="(471, 8)" kind="hygieneInfo">
                            <IdentNode start="(471, 8)" end="(471, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(471, 8)" end="(471, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(471, 11)" end="(471, 65)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(471, 11)" end="(471, 35)" leading="" trailing=" " raw_val="Poly.denote_le_cancel_eq" val="Poly.denote_le_cancel_eq" full_name="Nat.Linear.Poly.denote_le_cancel_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(428, 9)" def_end="(428, 33)"/>
                          <NullNode start="(471, 36)" end="(471, 65)">
                            <IdentNode start="(471, 36)" end="(471, 39)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(471, 40)" end="(471, 52)" leading="" trailing=" " raw_val="a.toNormPoly" val="a.toNormPoly"/>
                            <IdentNode start="(471, 53)" end="(471, 65)" leading="" trailing="&#10;  " raw_val="b.toNormPoly" val="b.toNormPoly"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(472, 3)" end="(472, 17)" kind="Lean.Parser.Tactic.rwSeq" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_le ctx (a.toNormPoly.cancel b.toNormPoly) = Poly.denote_le ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a ≤ denote ctx b) = (denote ctx c ≤ denote ctx d)" state_after="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_le ctx (c.toPoly, d.toPoly) = Poly.denote_le ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a ≤ denote ctx b) = (denote ctx c ≤ denote ctx d)" tactic="rw [h] at this">
                    <AtomNode start="(472, 3)" end="(472, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(472, 6)" end="(472, 9)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(472, 6)" end="(472, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(472, 7)" end="(472, 8)">
                        <OtherNode start="(472, 7)" end="(472, 8)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(472, 7)" end="(472, 8)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(472, 8)" end="(472, 9)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(472, 10)" end="(472, 17)">
                      <OtherNode start="(472, 10)" end="(472, 17)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(472, 10)" end="(472, 12)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(472, 13)" end="(472, 17)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(472, 13)" end="(472, 17)">
                            <IdentNode start="(472, 13)" end="(472, 17)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(473, 3)" end="(473, 67)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : Poly.denote_le ctx (c.toPoly, d.toPoly) = Poly.denote_le ctx (a.toNormPoly, b.toNormPoly)&#10;⊢ (denote ctx a ≤ denote ctx b) = (denote ctx c ≤ denote ctx d)" state_after="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : (denote ctx c ≤ denote ctx d) = (denote ctx a ≤ denote ctx b)&#10;⊢ (denote ctx a ≤ denote ctx b) = (denote ctx c ≤ denote ctx d)" tactic="simp [toNormPoly, Poly.norm,Poly.denote_le, -eq_iff_iff] at this">
                    <AtomNode start="(473, 3)" end="(473, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(473, 8)" end="(473, 59)">
                      <AtomNode start="(473, 8)" end="(473, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(473, 9)" end="(473, 58)">
                        <OtherNode start="(473, 9)" end="(473, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(473, 9)" end="(473, 19)" leading="" trailing="" raw_val="toNormPoly" val="toNormPoly" full_name="Nat.Linear.Expr.toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(127, 5)" def_end="(127, 20)"/>
                        </OtherNode>
                        <AtomNode start="(473, 19)" end="(473, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(473, 21)" end="(473, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(473, 21)" end="(473, 30)" leading="" trailing="" raw_val="Poly.norm" val="Poly.norm" full_name="Nat.Linear.Poly.norm" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(64, 5)" def_end="(64, 14)"/>
                        </OtherNode>
                        <AtomNode start="(473, 30)" end="(473, 31)" leading="" trailing="" val=","/>
                        <OtherNode start="(473, 31)" end="(473, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(473, 31)" end="(473, 45)" leading="" trailing="" raw_val="Poly.denote_le" val="Poly.denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                        </OtherNode>
                        <AtomNode start="(473, 45)" end="(473, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(473, 47)" end="(473, 58)" kind="Lean.Parser.Tactic.simpErase">
                          <AtomNode start="(473, 47)" end="(473, 48)" leading="" trailing="" val="-"/>
                          <IdentNode start="(473, 48)" end="(473, 58)" leading="" trailing="" raw_val="eq_iff_iff" val="eq_iff_iff" full_name="eq_iff_iff" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(473, 58)" end="(473, 59)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(473, 60)" end="(473, 67)">
                      <OtherNode start="(473, 60)" end="(473, 67)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(473, 60)" end="(473, 62)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(473, 63)" end="(473, 67)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(473, 63)" end="(473, 67)">
                            <IdentNode start="(473, 63)" end="(473, 67)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(474, 3)" end="(474, 18)" kind="Lean.Parser.Tactic.exact" state_before="ctx : Context&#10;a b c d : Expr&#10;h : a.toNormPoly.cancel b.toNormPoly = (c.toPoly, d.toPoly)&#10;this : (denote ctx c ≤ denote ctx d) = (denote ctx a ≤ denote ctx b)&#10;⊢ (denote ctx a ≤ denote ctx b) = (denote ctx c ≤ denote ctx d)" state_after="no goals" tactic="exact this.symm">
                    <AtomNode start="(474, 3)" end="(474, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(474, 9)" end="(474, 18)" leading="" trailing="&#10;&#10;" raw_val="this.symm" val="this.symm"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(476, 1)" end="(477, 37)" name="Expr.of_cancel_lt" full_name="Nat.Linear.Expr.of_cancel_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(476, 1)" end="(477, 37)" name="Expr.of_cancel_lt" full_name="Nat.Linear.Expr.of_cancel_lt" _is_private_decl="False">
        <AtomNode start="(476, 1)" end="(476, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(476, 9)" end="(476, 26)">
          <IdentNode start="(476, 9)" end="(476, 26)" leading="" trailing=" " raw_val="Expr.of_cancel_lt" val="Expr.of_cancel_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(476, 27)" end="(476, 198)">
          <NullNode start="(476, 27)" end="(476, 134)">
            <TermExplicitbinderNode start="(476, 27)" end="(476, 42)">
              <AtomNode start="(476, 27)" end="(476, 28)" leading="" trailing="" val="("/>
              <NullNode start="(476, 28)" end="(476, 31)">
                <IdentNode start="(476, 28)" end="(476, 31)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(476, 32)" end="(476, 41)">
                <AtomNode start="(476, 32)" end="(476, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(476, 34)" end="(476, 41)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(476, 41)" end="(476, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(476, 43)" end="(476, 59)">
              <AtomNode start="(476, 43)" end="(476, 44)" leading="" trailing="" val="("/>
              <NullNode start="(476, 44)" end="(476, 51)">
                <IdentNode start="(476, 44)" end="(476, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(476, 46)" end="(476, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(476, 48)" end="(476, 49)" leading="" trailing=" " raw_val="c" val="c"/>
                <IdentNode start="(476, 50)" end="(476, 51)" leading="" trailing=" " raw_val="d" val="d"/>
              </NullNode>
              <NullNode start="(476, 52)" end="(476, 58)">
                <AtomNode start="(476, 52)" end="(476, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(476, 54)" end="(476, 58)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(476, 58)" end="(476, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(476, 60)" end="(476, 134)">
              <AtomNode start="(476, 60)" end="(476, 61)" leading="" trailing="" val="("/>
              <NullNode start="(476, 61)" end="(476, 62)">
                <IdentNode start="(476, 61)" end="(476, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(476, 63)" end="(476, 133)">
                <AtomNode start="(476, 63)" end="(476, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(476, 65)" end="(476, 133)" kind="«term_=_»">
                  <OtherNode start="(476, 65)" end="(476, 106)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(476, 65)" end="(476, 76)" leading="" trailing=" " raw_val="Poly.cancel" val="Poly.cancel" full_name="Nat.Linear.Poly.cancel" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(92, 5)" def_end="(92, 16)"/>
                    <NullNode start="(476, 77)" end="(476, 106)">
                      <IdentNode start="(476, 77)" end="(476, 93)" leading="" trailing=" " raw_val="a.inc.toNormPoly" val="a.inc.toNormPoly"/>
                      <IdentNode start="(476, 94)" end="(476, 106)" leading="" trailing=" " raw_val="b.toNormPoly" val="b.toNormPoly"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(476, 107)" end="(476, 108)" leading="" trailing=" " val="="/>
                  <OtherNode start="(476, 109)" end="(476, 133)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(476, 109)" end="(476, 110)" leading="" trailing="" val="("/>
                    <NullNode start="(476, 110)" end="(476, 132)">
                      <IdentNode start="(476, 110)" end="(476, 122)" leading="" trailing="" raw_val="c.inc.toPoly" val="c.inc.toPoly"/>
                      <AtomNode start="(476, 122)" end="(476, 123)" leading="" trailing=" " val=","/>
                      <NullNode start="(476, 124)" end="(476, 132)">
                        <IdentNode start="(476, 124)" end="(476, 132)" leading="" trailing="" raw_val="d.toPoly" val="d.toPoly"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(476, 132)" end="(476, 133)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(476, 133)" end="(476, 134)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(476, 135)" end="(476, 198)">
            <AtomNode start="(476, 135)" end="(476, 136)" leading="" trailing=" " val=":"/>
            <OtherNode start="(476, 137)" end="(476, 198)" kind="«term_=_»">
              <OtherNode start="(476, 137)" end="(476, 166)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(476, 137)" end="(476, 138)" leading="" trailing="" val="("/>
                <OtherNode start="(476, 138)" end="(476, 165)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(476, 138)" end="(476, 150)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(476, 138)" end="(476, 146)" leading="" trailing=" " raw_val="a.denote" val="a.denote"/>
                    <NullNode start="(476, 147)" end="(476, 150)">
                      <IdentNode start="(476, 147)" end="(476, 150)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(476, 151)" end="(476, 152)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(476, 153)" end="(476, 165)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(476, 153)" end="(476, 161)" leading="" trailing=" " raw_val="b.denote" val="b.denote"/>
                    <NullNode start="(476, 162)" end="(476, 165)">
                      <IdentNode start="(476, 162)" end="(476, 165)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(476, 165)" end="(476, 166)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(476, 167)" end="(476, 168)" leading="" trailing=" " val="="/>
              <OtherNode start="(476, 169)" end="(476, 198)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(476, 169)" end="(476, 170)" leading="" trailing="" val="("/>
                <OtherNode start="(476, 170)" end="(476, 197)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(476, 170)" end="(476, 182)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(476, 170)" end="(476, 178)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                    <NullNode start="(476, 179)" end="(476, 182)">
                      <IdentNode start="(476, 179)" end="(476, 182)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(476, 183)" end="(476, 184)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(476, 185)" end="(476, 197)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(476, 185)" end="(476, 193)" leading="" trailing=" " raw_val="d.denote" val="d.denote"/>
                    <NullNode start="(476, 194)" end="(476, 197)">
                      <IdentNode start="(476, 194)" end="(476, 197)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(476, 197)" end="(476, 198)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(476, 199)" end="(477, 37)">
          <AtomNode start="(476, 199)" end="(476, 201)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(477, 3)" end="(477, 37)" kind="Lean.Parser.Term.app">
            <IdentNode start="(477, 3)" end="(477, 15)" leading="" trailing=" " raw_val="of_cancel_le" val="of_cancel_le" full_name="Nat.Linear.Expr.of_cancel_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(470, 9)" def_end="(470, 26)"/>
            <NullNode start="(477, 16)" end="(477, 37)">
              <IdentNode start="(477, 16)" end="(477, 19)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              <IdentNode start="(477, 20)" end="(477, 25)" leading="" trailing=" " raw_val="a.inc" val="a.inc"/>
              <IdentNode start="(477, 26)" end="(477, 27)" leading="" trailing=" " raw_val="b" val="b"/>
              <IdentNode start="(477, 28)" end="(477, 33)" leading="" trailing=" " raw_val="c.inc" val="c.inc"/>
              <IdentNode start="(477, 34)" end="(477, 35)" leading="" trailing=" " raw_val="d" val="d"/>
              <IdentNode start="(477, 36)" end="(477, 37)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(479, 1)" end="(480, 6)" name="ExprCnstr.toPoly_norm_eq" full_name="Nat.Linear.ExprCnstr.toPoly_norm_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(479, 1)" end="(480, 6)" name="ExprCnstr.toPoly_norm_eq" full_name="Nat.Linear.ExprCnstr.toPoly_norm_eq" _is_private_decl="False">
        <AtomNode start="(479, 1)" end="(479, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(479, 9)" end="(479, 33)">
          <IdentNode start="(479, 9)" end="(479, 33)" leading="" trailing=" " raw_val="ExprCnstr.toPoly_norm_eq" val="ExprCnstr.toPoly_norm_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(479, 34)" end="(479, 80)">
          <NullNode start="(479, 34)" end="(479, 49)">
            <TermExplicitbinderNode start="(479, 34)" end="(479, 49)">
              <AtomNode start="(479, 34)" end="(479, 35)" leading="" trailing="" val="("/>
              <NullNode start="(479, 35)" end="(479, 36)">
                <IdentNode start="(479, 35)" end="(479, 36)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(479, 37)" end="(479, 48)">
                <AtomNode start="(479, 37)" end="(479, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(479, 39)" end="(479, 48)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(479, 48)" end="(479, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(479, 50)" end="(479, 80)">
            <AtomNode start="(479, 50)" end="(479, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(479, 52)" end="(479, 80)" kind="«term_=_»">
              <IdentNode start="(479, 52)" end="(479, 65)" leading="" trailing=" " raw_val="c.toPoly.norm" val="c.toPoly.norm"/>
              <AtomNode start="(479, 66)" end="(479, 67)" leading="" trailing=" " val="="/>
              <IdentNode start="(479, 68)" end="(479, 80)" leading="" trailing=" " raw_val="c.toNormPoly" val="c.toNormPoly"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(479, 81)" end="(480, 6)">
          <AtomNode start="(479, 81)" end="(479, 83)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(480, 3)" end="(480, 6)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(482, 1)" end="(487, 26)" name="ExprCnstr.denote_toPoly" full_name="Nat.Linear.ExprCnstr.denote_toPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(482, 1)" end="(487, 26)" name="ExprCnstr.denote_toPoly" full_name="Nat.Linear.ExprCnstr.denote_toPoly" _is_private_decl="False">
        <AtomNode start="(482, 1)" end="(482, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(482, 9)" end="(482, 32)">
          <IdentNode start="(482, 9)" end="(482, 32)" leading="" trailing=" " raw_val="ExprCnstr.denote_toPoly" val="ExprCnstr.denote_toPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(482, 33)" end="(482, 101)">
          <NullNode start="(482, 33)" end="(482, 64)">
            <TermExplicitbinderNode start="(482, 33)" end="(482, 48)">
              <AtomNode start="(482, 33)" end="(482, 34)" leading="" trailing="" val="("/>
              <NullNode start="(482, 34)" end="(482, 37)">
                <IdentNode start="(482, 34)" end="(482, 37)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(482, 38)" end="(482, 47)">
                <AtomNode start="(482, 38)" end="(482, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(482, 40)" end="(482, 47)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(482, 47)" end="(482, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(482, 49)" end="(482, 64)">
              <AtomNode start="(482, 49)" end="(482, 50)" leading="" trailing="" val="("/>
              <NullNode start="(482, 50)" end="(482, 51)">
                <IdentNode start="(482, 50)" end="(482, 51)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(482, 52)" end="(482, 63)">
                <AtomNode start="(482, 52)" end="(482, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(482, 54)" end="(482, 63)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(482, 63)" end="(482, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(482, 65)" end="(482, 101)">
            <AtomNode start="(482, 65)" end="(482, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(482, 67)" end="(482, 101)" kind="«term_=_»">
              <OtherNode start="(482, 67)" end="(482, 86)" kind="Lean.Parser.Term.app">
                <IdentNode start="(482, 67)" end="(482, 82)" leading="" trailing=" " raw_val="c.toPoly.denote" val="c.toPoly.denote"/>
                <NullNode start="(482, 83)" end="(482, 86)">
                  <IdentNode start="(482, 83)" end="(482, 86)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(482, 87)" end="(482, 88)" leading="" trailing=" " val="="/>
              <OtherNode start="(482, 89)" end="(482, 101)" kind="Lean.Parser.Term.app">
                <IdentNode start="(482, 89)" end="(482, 97)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                <NullNode start="(482, 98)" end="(482, 101)">
                  <IdentNode start="(482, 98)" end="(482, 101)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(482, 102)" end="(487, 26)">
          <AtomNode start="(482, 102)" end="(482, 104)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(482, 105)" end="(487, 26)">
            <AtomNode start="(482, 105)" end="(482, 107)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(483, 3)" end="(487, 26)">
              <TacticTacticseq1IndentedNode start="(483, 3)" end="(487, 26)">
                <NullNode start="(483, 3)" end="(487, 26)">
                  <OtherNode start="(483, 3)" end="(483, 10)" kind="Lean.Parser.Tactic.cases" state_before="ctx : Context&#10;c : ExprCnstr&#10;⊢ PolyCnstr.denote ctx c.toPoly = denote ctx c" state_after="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.toPoly =&#10;    denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }" tactic="cases c">
                    <AtomNode start="(483, 3)" end="(483, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(483, 9)" end="(483, 10)">
                      <OtherNode start="(483, 9)" end="(483, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(483, 9)" end="(483, 10)" leading="" trailing="" raw_val="c" val="c"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(483, 10)" end="(483, 11)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(483, 12)" end="(483, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.toPoly =&#10;    denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq, lhs := lhs, rhs := rhs }.toPoly = denote ctx { eq := eq, lhs := lhs, rhs := rhs }" tactic="rename_i eq lhs rhs">
                    <AtomNode start="(483, 12)" end="(483, 20)" leading="" trailing=" " val="rename_i"/>
                    <NullNode start="(483, 21)" end="(483, 31)">
                      <LeanBinderidentNode start="(483, 21)" end="(483, 23)">
                        <IdentNode start="(483, 21)" end="(483, 23)" leading="" trailing=" " raw_val="eq" val="eq"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(483, 24)" end="(483, 27)">
                        <IdentNode start="(483, 24)" end="(483, 27)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(483, 28)" end="(483, 31)">
                        <IdentNode start="(483, 28)" end="(483, 31)" leading="" trailing="&#10;  " raw_val="rhs" val="rhs"/>
                      </LeanBinderidentNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(484, 3)" end="(484, 62)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq, lhs := lhs, rhs := rhs }.toPoly = denote ctx { eq := eq, lhs := lhs, rhs := rhs }" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ (bif eq then Poly.denote_eq ctx (lhs.toPoly, rhs.toPoly) else Poly.denote_le ctx (lhs.toPoly, rhs.toPoly)) ↔&#10;    bif eq then Expr.denote ctx lhs = Expr.denote ctx rhs else Expr.denote ctx lhs ≤ Expr.denote ctx rhs" tactic="simp [ExprCnstr.denote, PolyCnstr.denote, ExprCnstr.toPoly]">
                    <AtomNode start="(484, 3)" end="(484, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(484, 8)" end="(484, 62)">
                      <AtomNode start="(484, 8)" end="(484, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(484, 9)" end="(484, 61)">
                        <OtherNode start="(484, 9)" end="(484, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(484, 9)" end="(484, 25)" leading="" trailing="" raw_val="ExprCnstr.denote" val="ExprCnstr.denote" full_name="Nat.Linear.ExprCnstr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(180, 5)" def_end="(180, 21)"/>
                        </OtherNode>
                        <AtomNode start="(484, 25)" end="(484, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(484, 27)" end="(484, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(484, 27)" end="(484, 43)" leading="" trailing="" raw_val="PolyCnstr.denote" val="PolyCnstr.denote" full_name="Nat.Linear.PolyCnstr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(158, 5)" def_end="(158, 21)"/>
                        </OtherNode>
                        <AtomNode start="(484, 43)" end="(484, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(484, 45)" end="(484, 61)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(484, 45)" end="(484, 61)" leading="" trailing="" raw_val="ExprCnstr.toPoly" val="ExprCnstr.toPoly" full_name="Nat.Linear.ExprCnstr.toPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(186, 5)" def_end="(186, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(484, 61)" end="(484, 62)" leading="" trailing="" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(484, 62)" end="(484, 63)" leading="" trailing="&#10;  " val=";"/>
                  <OtherNode start="(485, 3)" end="(485, 38)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ (bif eq then Poly.denote_eq ctx (lhs.toPoly, rhs.toPoly) else Poly.denote_le ctx (lhs.toPoly, rhs.toPoly)) ↔&#10;    bif eq then Expr.denote ctx lhs = Expr.denote ctx rhs else Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs = Expr.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs ≤ Expr.denote ctx rhs" tactic="by_cases h : eq = true &amp;lt;;&amp;gt; simp [h]">
                    <OtherNode start="(485, 3)" end="(485, 25)" kind="«tacticBy_cases_:_»">
                      <AtomNode start="(485, 3)" end="(485, 11)" leading="" trailing=" " val="by_cases"/>
                      <NullNode start="(485, 12)" end="(485, 15)">
                        <IdentNode start="(485, 12)" end="(485, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                        <AtomNode start="(485, 14)" end="(485, 15)" leading="" trailing=" " val=":"/>
                      </NullNode>
                      <OtherNode start="(485, 16)" end="(485, 25)" kind="«term_=_»">
                        <IdentNode start="(485, 16)" end="(485, 18)" leading="" trailing=" " raw_val="eq" val="eq"/>
                        <AtomNode start="(485, 19)" end="(485, 20)" leading="" trailing=" " val="="/>
                        <IdentNode start="(485, 21)" end="(485, 25)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(485, 26)" end="(485, 29)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(485, 30)" end="(485, 38)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(485, 30)" end="(485, 34)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(485, 35)" end="(485, 38)">
                        <AtomNode start="(485, 35)" end="(485, 36)" leading="" trailing="" val="["/>
                        <NullNode start="(485, 36)" end="(485, 37)">
                          <OtherNode start="(485, 36)" end="(485, 37)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(485, 36)" end="(485, 37)" leading="" trailing="" raw_val="h" val="h"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(485, 37)" end="(485, 38)" leading="" trailing="&#10;  " val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(486, 3)" end="(486, 26)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs = Expr.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs ≤ Expr.denote ctx rhs" tactic="· simp [Poly.denote_eq]">
                    <OtherNode start="(486, 3)" end="(486, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(486, 3)" end="(486, 4)" kind="patternIgnore">
                        <OtherNode start="(486, 3)" end="(486, 4)" kind="token.«· »">
                          <AtomNode start="(486, 3)" end="(486, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(486, 5)" end="(486, 26)">
                      <TacticTacticseq1IndentedNode start="(486, 5)" end="(486, 26)">
                        <NullNode start="(486, 5)" end="(486, 26)">
                          <OtherNode start="(486, 5)" end="(486, 26)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs = Expr.denote ctx rhs" state_after="no goals" tactic="simp [Poly.denote_eq]">
                            <AtomNode start="(486, 5)" end="(486, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(486, 10)" end="(486, 26)">
                              <AtomNode start="(486, 10)" end="(486, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(486, 11)" end="(486, 25)">
                                <OtherNode start="(486, 11)" end="(486, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(486, 11)" end="(486, 25)" leading="" trailing="" raw_val="Poly.denote_eq" val="Poly.denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(486, 25)" end="(486, 26)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(487, 3)" end="(487, 26)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="no goals" tactic="· simp [Poly.denote_le]">
                    <OtherNode start="(487, 3)" end="(487, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(487, 3)" end="(487, 4)" kind="patternIgnore">
                        <OtherNode start="(487, 3)" end="(487, 4)" kind="token.«· »">
                          <AtomNode start="(487, 3)" end="(487, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(487, 5)" end="(487, 26)">
                      <TacticTacticseq1IndentedNode start="(487, 5)" end="(487, 26)">
                        <NullNode start="(487, 5)" end="(487, 26)">
                          <OtherNode start="(487, 5)" end="(487, 26)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx (lhs.toPoly, rhs.toPoly) ↔ Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="no goals" tactic="simp [Poly.denote_le]">
                            <AtomNode start="(487, 5)" end="(487, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(487, 10)" end="(487, 26)">
                              <AtomNode start="(487, 10)" end="(487, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(487, 11)" end="(487, 25)">
                                <OtherNode start="(487, 11)" end="(487, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(487, 11)" end="(487, 25)" leading="" trailing="" raw_val="Poly.denote_le" val="Poly.denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(487, 25)" end="(487, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(489, 1)" end="(489, 47)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(489, 1)" end="(489, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(489, 11)" end="(489, 12)" leading="" trailing="" val="["/>
      <NullNode start="(489, 12)" end="(489, 22)">
        <OtherNode start="(489, 12)" end="(489, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(489, 12)" end="(489, 17)">
            <NullNode start="(489, 12)" end="(489, 17)">
              <OtherNode start="(489, 12)" end="(489, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(489, 12)" end="(489, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(489, 18)" end="(489, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(489, 18)" end="(489, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(489, 22)" end="(489, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(489, 24)" end="(489, 47)">
        <IdentNode start="(489, 24)" end="(489, 47)" leading="" trailing="&#10;&#10;" raw_val="ExprCnstr.denote_toPoly" val="ExprCnstr.denote_toPoly" full_name="Nat.Linear.ExprCnstr.denote_toPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(482, 9)" def_end="(482, 32)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(491, 1)" end="(496, 85)" name="ExprCnstr.denote_toNormPoly" full_name="Nat.Linear.ExprCnstr.denote_toNormPoly">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(491, 1)" end="(496, 85)" name="ExprCnstr.denote_toNormPoly" full_name="Nat.Linear.ExprCnstr.denote_toNormPoly" _is_private_decl="False">
        <AtomNode start="(491, 1)" end="(491, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(491, 9)" end="(491, 36)">
          <IdentNode start="(491, 9)" end="(491, 36)" leading="" trailing=" " raw_val="ExprCnstr.denote_toNormPoly" val="ExprCnstr.denote_toNormPoly"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(491, 37)" end="(491, 109)">
          <NullNode start="(491, 37)" end="(491, 68)">
            <TermExplicitbinderNode start="(491, 37)" end="(491, 52)">
              <AtomNode start="(491, 37)" end="(491, 38)" leading="" trailing="" val="("/>
              <NullNode start="(491, 38)" end="(491, 41)">
                <IdentNode start="(491, 38)" end="(491, 41)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(491, 42)" end="(491, 51)">
                <AtomNode start="(491, 42)" end="(491, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(491, 44)" end="(491, 51)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(491, 51)" end="(491, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(491, 53)" end="(491, 68)">
              <AtomNode start="(491, 53)" end="(491, 54)" leading="" trailing="" val="("/>
              <NullNode start="(491, 54)" end="(491, 55)">
                <IdentNode start="(491, 54)" end="(491, 55)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(491, 56)" end="(491, 67)">
                <AtomNode start="(491, 56)" end="(491, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(491, 58)" end="(491, 67)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(491, 67)" end="(491, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(491, 69)" end="(491, 109)">
            <AtomNode start="(491, 69)" end="(491, 70)" leading="" trailing=" " val=":"/>
            <OtherNode start="(491, 71)" end="(491, 109)" kind="«term_=_»">
              <OtherNode start="(491, 71)" end="(491, 94)" kind="Lean.Parser.Term.app">
                <IdentNode start="(491, 71)" end="(491, 90)" leading="" trailing=" " raw_val="c.toNormPoly.denote" val="c.toNormPoly.denote"/>
                <NullNode start="(491, 91)" end="(491, 94)">
                  <IdentNode start="(491, 91)" end="(491, 94)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(491, 95)" end="(491, 96)" leading="" trailing=" " val="="/>
              <OtherNode start="(491, 97)" end="(491, 109)" kind="Lean.Parser.Term.app">
                <IdentNode start="(491, 97)" end="(491, 105)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                <NullNode start="(491, 106)" end="(491, 109)">
                  <IdentNode start="(491, 106)" end="(491, 109)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(491, 110)" end="(496, 85)">
          <AtomNode start="(491, 110)" end="(491, 112)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(491, 113)" end="(496, 85)">
            <AtomNode start="(491, 113)" end="(491, 115)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(492, 3)" end="(496, 85)">
              <TacticTacticseq1IndentedNode start="(492, 3)" end="(496, 85)">
                <NullNode start="(492, 3)" end="(496, 85)">
                  <OtherNode start="(492, 3)" end="(492, 10)" kind="Lean.Parser.Tactic.cases" state_before="ctx : Context&#10;c : ExprCnstr&#10;⊢ PolyCnstr.denote ctx c.toNormPoly = denote ctx c" state_after="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.toNormPoly =&#10;    denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }" tactic="cases c">
                    <AtomNode start="(492, 3)" end="(492, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(492, 9)" end="(492, 10)">
                      <OtherNode start="(492, 9)" end="(492, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(492, 9)" end="(492, 10)" leading="" trailing="" raw_val="c" val="c"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(492, 10)" end="(492, 11)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(492, 12)" end="(492, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.toNormPoly =&#10;    denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq, lhs := lhs, rhs := rhs }.toNormPoly = denote ctx { eq := eq, lhs := lhs, rhs := rhs }" tactic="rename_i eq lhs rhs">
                    <AtomNode start="(492, 12)" end="(492, 20)" leading="" trailing=" " val="rename_i"/>
                    <NullNode start="(492, 21)" end="(492, 31)">
                      <LeanBinderidentNode start="(492, 21)" end="(492, 23)">
                        <IdentNode start="(492, 21)" end="(492, 23)" leading="" trailing=" " raw_val="eq" val="eq"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(492, 24)" end="(492, 27)">
                        <IdentNode start="(492, 24)" end="(492, 27)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(492, 28)" end="(492, 31)">
                        <IdentNode start="(492, 28)" end="(492, 31)" leading="" trailing="&#10;  " raw_val="rhs" val="rhs"/>
                      </LeanBinderidentNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(493, 3)" end="(493, 66)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ PolyCnstr.denote ctx { eq := eq, lhs := lhs, rhs := rhs }.toNormPoly = denote ctx { eq := eq, lhs := lhs, rhs := rhs }" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ (bif eq then&#10;      Poly.denote_eq ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd)&#10;    else Poly.denote_le ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd)) ↔&#10;    bif eq then Expr.denote ctx lhs = Expr.denote ctx rhs else Expr.denote ctx lhs ≤ Expr.denote ctx rhs" tactic="simp [ExprCnstr.denote, PolyCnstr.denote, ExprCnstr.toNormPoly]">
                    <AtomNode start="(493, 3)" end="(493, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(493, 8)" end="(493, 66)">
                      <AtomNode start="(493, 8)" end="(493, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(493, 9)" end="(493, 65)">
                        <OtherNode start="(493, 9)" end="(493, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(493, 9)" end="(493, 25)" leading="" trailing="" raw_val="ExprCnstr.denote" val="ExprCnstr.denote" full_name="Nat.Linear.ExprCnstr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(180, 5)" def_end="(180, 21)"/>
                        </OtherNode>
                        <AtomNode start="(493, 25)" end="(493, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(493, 27)" end="(493, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(493, 27)" end="(493, 43)" leading="" trailing="" raw_val="PolyCnstr.denote" val="PolyCnstr.denote" full_name="Nat.Linear.PolyCnstr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(158, 5)" def_end="(158, 21)"/>
                        </OtherNode>
                        <AtomNode start="(493, 43)" end="(493, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(493, 45)" end="(493, 65)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(493, 45)" end="(493, 65)" leading="" trailing="" raw_val="ExprCnstr.toNormPoly" val="ExprCnstr.toNormPoly" full_name="Nat.Linear.ExprCnstr.toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(189, 5)" def_end="(189, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(493, 65)" end="(493, 66)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(494, 3)" end="(494, 38)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;⊢ (bif eq then&#10;      Poly.denote_eq ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd)&#10;    else Poly.denote_le ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd)) ↔&#10;    bif eq then Expr.denote ctx lhs = Expr.denote ctx rhs else Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs = Expr.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs ≤ Expr.denote ctx rhs" tactic="by_cases h : eq = true &amp;lt;;&amp;gt; simp [h]">
                    <OtherNode start="(494, 3)" end="(494, 25)" kind="«tacticBy_cases_:_»">
                      <AtomNode start="(494, 3)" end="(494, 11)" leading="" trailing=" " val="by_cases"/>
                      <NullNode start="(494, 12)" end="(494, 15)">
                        <IdentNode start="(494, 12)" end="(494, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                        <AtomNode start="(494, 14)" end="(494, 15)" leading="" trailing=" " val=":"/>
                      </NullNode>
                      <OtherNode start="(494, 16)" end="(494, 25)" kind="«term_=_»">
                        <IdentNode start="(494, 16)" end="(494, 18)" leading="" trailing=" " raw_val="eq" val="eq"/>
                        <AtomNode start="(494, 19)" end="(494, 20)" leading="" trailing=" " val="="/>
                        <IdentNode start="(494, 21)" end="(494, 25)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(494, 26)" end="(494, 29)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(494, 30)" end="(494, 38)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(494, 30)" end="(494, 34)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(494, 35)" end="(494, 38)">
                        <AtomNode start="(494, 35)" end="(494, 36)" leading="" trailing="" val="["/>
                        <NullNode start="(494, 36)" end="(494, 37)">
                          <OtherNode start="(494, 36)" end="(494, 37)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(494, 36)" end="(494, 37)" leading="" trailing="" raw_val="h" val="h"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(494, 37)" end="(494, 38)" leading="" trailing="&#10;  " val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(495, 3)" end="(495, 85)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs = Expr.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs ≤ Expr.denote ctx rhs" tactic="· rw [Poly.denote_eq_cancel_eq]; simp [Poly.denote_eq, Expr.toNormPoly, Poly.norm]">
                    <OtherNode start="(495, 3)" end="(495, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(495, 3)" end="(495, 4)" kind="patternIgnore">
                        <OtherNode start="(495, 3)" end="(495, 4)" kind="token.«· »">
                          <AtomNode start="(495, 3)" end="(495, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(495, 5)" end="(495, 85)">
                      <TacticTacticseq1IndentedNode start="(495, 5)" end="(495, 85)">
                        <NullNode start="(495, 5)" end="(495, 85)">
                          <OtherNode start="(495, 5)" end="(495, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs = Expr.denote ctx rhs" state_after="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx (lhs.toNormPoly, rhs.toNormPoly) ↔ Expr.denote ctx lhs = Expr.denote ctx rhs" tactic="rw [Poly.denote_eq_cancel_eq]">
                            <AtomNode start="(495, 5)" end="(495, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(495, 8)" end="(495, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(495, 8)" end="(495, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(495, 9)" end="(495, 33)">
                                <OtherNode start="(495, 9)" end="(495, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(495, 9)" end="(495, 33)" leading="" trailing="" raw_val="Poly.denote_eq_cancel_eq" val="Poly.denote_eq_cancel_eq" full_name="Nat.Linear.Poly.denote_eq_cancel_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(348, 9)" def_end="(348, 33)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(495, 33)" end="(495, 34)" leading="" trailing="" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(495, 34)" end="(495, 35)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(495, 36)" end="(495, 85)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : eq = true&#10;⊢ Poly.denote_eq ctx (lhs.toNormPoly, rhs.toNormPoly) ↔ Expr.denote ctx lhs = Expr.denote ctx rhs" state_after="no goals" tactic="simp [Poly.denote_eq, Expr.toNormPoly, Poly.norm]">
                            <AtomNode start="(495, 36)" end="(495, 40)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(495, 41)" end="(495, 85)">
                              <AtomNode start="(495, 41)" end="(495, 42)" leading="" trailing="" val="["/>
                              <NullNode start="(495, 42)" end="(495, 84)">
                                <OtherNode start="(495, 42)" end="(495, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(495, 42)" end="(495, 56)" leading="" trailing="" raw_val="Poly.denote_eq" val="Poly.denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                                </OtherNode>
                                <AtomNode start="(495, 56)" end="(495, 57)" leading="" trailing=" " val=","/>
                                <OtherNode start="(495, 58)" end="(495, 73)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(495, 58)" end="(495, 73)" leading="" trailing="" raw_val="Expr.toNormPoly" val="Expr.toNormPoly" full_name="Nat.Linear.Expr.toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(127, 5)" def_end="(127, 20)"/>
                                </OtherNode>
                                <AtomNode start="(495, 73)" end="(495, 74)" leading="" trailing=" " val=","/>
                                <OtherNode start="(495, 75)" end="(495, 84)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(495, 75)" end="(495, 84)" leading="" trailing="" raw_val="Poly.norm" val="Poly.norm" full_name="Nat.Linear.Poly.norm" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(64, 5)" def_end="(64, 14)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(495, 84)" end="(495, 85)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(496, 3)" end="(496, 85)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="no goals" tactic="· rw [Poly.denote_le_cancel_eq]; simp [Poly.denote_le, Expr.toNormPoly, Poly.norm]">
                    <OtherNode start="(496, 3)" end="(496, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(496, 3)" end="(496, 4)" kind="patternIgnore">
                        <OtherNode start="(496, 3)" end="(496, 4)" kind="token.«· »">
                          <AtomNode start="(496, 3)" end="(496, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(496, 5)" end="(496, 85)">
                      <TacticTacticseq1IndentedNode start="(496, 5)" end="(496, 85)">
                        <NullNode start="(496, 5)" end="(496, 85)">
                          <OtherNode start="(496, 5)" end="(496, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx ((lhs.toNormPoly.cancel rhs.toNormPoly).fst, (lhs.toNormPoly.cancel rhs.toNormPoly).snd) ↔&#10;    Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx (lhs.toNormPoly, rhs.toNormPoly) ↔ Expr.denote ctx lhs ≤ Expr.denote ctx rhs" tactic="rw [Poly.denote_le_cancel_eq]">
                            <AtomNode start="(496, 5)" end="(496, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(496, 8)" end="(496, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(496, 8)" end="(496, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(496, 9)" end="(496, 33)">
                                <OtherNode start="(496, 9)" end="(496, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(496, 9)" end="(496, 33)" leading="" trailing="" raw_val="Poly.denote_le_cancel_eq" val="Poly.denote_le_cancel_eq" full_name="Nat.Linear.Poly.denote_le_cancel_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(428, 9)" def_end="(428, 33)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(496, 33)" end="(496, 34)" leading="" trailing="" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(496, 34)" end="(496, 35)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(496, 36)" end="(496, 85)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Expr&#10;h : ¬eq = true&#10;⊢ Poly.denote_le ctx (lhs.toNormPoly, rhs.toNormPoly) ↔ Expr.denote ctx lhs ≤ Expr.denote ctx rhs" state_after="no goals" tactic="simp [Poly.denote_le, Expr.toNormPoly, Poly.norm]">
                            <AtomNode start="(496, 36)" end="(496, 40)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(496, 41)" end="(496, 85)">
                              <AtomNode start="(496, 41)" end="(496, 42)" leading="" trailing="" val="["/>
                              <NullNode start="(496, 42)" end="(496, 84)">
                                <OtherNode start="(496, 42)" end="(496, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(496, 42)" end="(496, 56)" leading="" trailing="" raw_val="Poly.denote_le" val="Poly.denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                                </OtherNode>
                                <AtomNode start="(496, 56)" end="(496, 57)" leading="" trailing=" " val=","/>
                                <OtherNode start="(496, 58)" end="(496, 73)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(496, 58)" end="(496, 73)" leading="" trailing="" raw_val="Expr.toNormPoly" val="Expr.toNormPoly" full_name="Nat.Linear.Expr.toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(127, 5)" def_end="(127, 20)"/>
                                </OtherNode>
                                <AtomNode start="(496, 73)" end="(496, 74)" leading="" trailing=" " val=","/>
                                <OtherNode start="(496, 75)" end="(496, 84)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(496, 75)" end="(496, 84)" leading="" trailing="" raw_val="Poly.norm" val="Poly.norm" full_name="Nat.Linear.Poly.norm" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(64, 5)" def_end="(64, 14)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(496, 84)" end="(496, 85)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(498, 1)" end="(498, 51)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(498, 1)" end="(498, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(498, 11)" end="(498, 12)" leading="" trailing="" val="["/>
      <NullNode start="(498, 12)" end="(498, 22)">
        <OtherNode start="(498, 12)" end="(498, 22)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(498, 12)" end="(498, 17)">
            <NullNode start="(498, 12)" end="(498, 17)">
              <OtherNode start="(498, 12)" end="(498, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(498, 12)" end="(498, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(498, 18)" end="(498, 22)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(498, 18)" end="(498, 22)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(498, 22)" end="(498, 23)" leading="" trailing=" " val="]"/>
      <NullNode start="(498, 24)" end="(498, 51)">
        <IdentNode start="(498, 24)" end="(498, 51)" leading="" trailing="&#10;&#10;" raw_val="ExprCnstr.denote_toNormPoly" val="ExprCnstr.denote_toNormPoly" full_name="Nat.Linear.ExprCnstr.denote_toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(491, 9)" def_end="(491, 36)"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(500, 1)" end="(504, 18)" name="Poly.of_isZero" full_name="Nat.Linear.Poly.of_isZero">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(500, 1)" end="(504, 18)" name="Poly.of_isZero" full_name="Nat.Linear.Poly.of_isZero" _is_private_decl="False">
        <AtomNode start="(500, 1)" end="(500, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(500, 9)" end="(500, 23)">
          <IdentNode start="(500, 9)" end="(500, 23)" leading="" trailing=" " raw_val="Poly.of_isZero" val="Poly.of_isZero"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(500, 24)" end="(500, 91)">
          <NullNode start="(500, 24)" end="(500, 72)">
            <TermExplicitbinderNode start="(500, 24)" end="(500, 39)">
              <AtomNode start="(500, 24)" end="(500, 25)" leading="" trailing="" val="("/>
              <NullNode start="(500, 25)" end="(500, 28)">
                <IdentNode start="(500, 25)" end="(500, 28)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(500, 29)" end="(500, 38)">
                <AtomNode start="(500, 29)" end="(500, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(500, 31)" end="(500, 38)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(500, 38)" end="(500, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(500, 40)" end="(500, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(500, 40)" end="(500, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(500, 41)" end="(500, 42)">
                <IdentNode start="(500, 41)" end="(500, 42)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(500, 43)" end="(500, 49)">
                <AtomNode start="(500, 43)" end="(500, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(500, 45)" end="(500, 49)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <AtomNode start="(500, 49)" end="(500, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(500, 51)" end="(500, 72)">
              <AtomNode start="(500, 51)" end="(500, 52)" leading="" trailing="" val="("/>
              <NullNode start="(500, 52)" end="(500, 53)">
                <IdentNode start="(500, 52)" end="(500, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(500, 54)" end="(500, 71)">
                <AtomNode start="(500, 54)" end="(500, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(500, 56)" end="(500, 71)" kind="«term_=_»">
                  <OtherNode start="(500, 56)" end="(500, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(500, 56)" end="(500, 62)" leading="" trailing=" " raw_val="isZero" val="isZero" full_name="Nat.Linear.Poly.isZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(101, 5)" def_end="(101, 16)"/>
                    <NullNode start="(500, 63)" end="(500, 64)">
                      <IdentNode start="(500, 63)" end="(500, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(500, 65)" end="(500, 66)" leading="" trailing=" " val="="/>
                  <IdentNode start="(500, 67)" end="(500, 71)" leading="" trailing="" raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(500, 71)" end="(500, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(500, 73)" end="(500, 91)">
            <AtomNode start="(500, 73)" end="(500, 74)" leading="" trailing=" " val=":"/>
            <OtherNode start="(500, 75)" end="(500, 91)" kind="«term_=_»">
              <OtherNode start="(500, 75)" end="(500, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(500, 75)" end="(500, 83)" leading="" trailing=" " raw_val="p.denote" val="p.denote"/>
                <NullNode start="(500, 84)" end="(500, 87)">
                  <IdentNode start="(500, 84)" end="(500, 87)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(500, 88)" end="(500, 89)" leading="" trailing=" " val="="/>
              <OtherNode start="(500, 90)" end="(500, 91)" kind="num">
                <AtomNode start="(500, 90)" end="(500, 91)" leading="" trailing=" " val="0"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(500, 92)" end="(504, 18)">
          <AtomNode start="(500, 92)" end="(500, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(500, 95)" end="(504, 18)">
            <AtomNode start="(500, 95)" end="(500, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(501, 3)" end="(504, 18)">
              <TacticTacticseq1IndentedNode start="(501, 3)" end="(504, 18)">
                <NullNode start="(501, 3)" end="(504, 18)">
                  <OtherNode start="(501, 3)" end="(501, 21)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;p : Poly&#10;h : p.isZero = true&#10;⊢ denote ctx p = 0" state_after="ctx : Context&#10;p : Poly&#10;h :&#10;  (match p with&#10;    | [] =&amp;gt; true&#10;    | x =&amp;gt; false) =&#10;    true&#10;⊢ denote ctx p = 0" tactic="simp [isZero] at h">
                    <AtomNode start="(501, 3)" end="(501, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(501, 8)" end="(501, 16)">
                      <AtomNode start="(501, 8)" end="(501, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(501, 9)" end="(501, 15)">
                        <OtherNode start="(501, 9)" end="(501, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(501, 9)" end="(501, 15)" leading="" trailing="" raw_val="isZero" val="isZero" full_name="Nat.Linear.Poly.isZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(101, 5)" def_end="(101, 16)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(501, 15)" end="(501, 16)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(501, 17)" end="(501, 21)">
                      <OtherNode start="(501, 17)" end="(501, 21)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(501, 17)" end="(501, 19)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(501, 20)" end="(501, 21)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(501, 20)" end="(501, 21)">
                            <IdentNode start="(501, 20)" end="(501, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(502, 3)" end="(502, 13)" kind="Lean.Parser.Tactic.split" state_before="ctx : Context&#10;p : Poly&#10;h :&#10;  (match p with&#10;    | [] =&amp;gt; true&#10;    | x =&amp;gt; false) =&#10;    true&#10;⊢ denote ctx p = 0" state_after="case h_1&#10;ctx : Context&#10;p✝ : Poly&#10;h : true = true&#10;⊢ denote ctx [] = 0&#10;&#10;case h_2&#10;ctx : Context&#10;p p✝ : Poly&#10;x✝ : p = [] → False&#10;h : false = true&#10;⊢ denote ctx p = 0" tactic="split at h">
                    <AtomNode start="(502, 3)" end="(502, 8)" leading="" trailing=" " val="split"/>
                    <NullNode/>
                    <NullNode start="(502, 9)" end="(502, 13)">
                      <OtherNode start="(502, 9)" end="(502, 13)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(502, 9)" end="(502, 11)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(502, 12)" end="(502, 13)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(502, 12)" end="(502, 13)">
                            <IdentNode start="(502, 12)" end="(502, 13)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(503, 3)" end="(503, 9)" kind="Lean.cdot" state_before="case h_1&#10;ctx : Context&#10;p✝ : Poly&#10;h : true = true&#10;⊢ denote ctx [] = 0&#10;&#10;case h_2&#10;ctx : Context&#10;p p✝ : Poly&#10;x✝ : p = [] → False&#10;h : false = true&#10;⊢ denote ctx p = 0" state_after="case h_2&#10;ctx : Context&#10;p p✝ : Poly&#10;x✝ : p = [] → False&#10;h : false = true&#10;⊢ denote ctx p = 0" tactic="· simp">
                    <OtherNode start="(503, 3)" end="(503, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(503, 3)" end="(503, 4)" kind="patternIgnore">
                        <OtherNode start="(503, 3)" end="(503, 4)" kind="token.«· »">
                          <AtomNode start="(503, 3)" end="(503, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(503, 5)" end="(503, 9)">
                      <TacticTacticseq1IndentedNode start="(503, 5)" end="(503, 9)">
                        <NullNode start="(503, 5)" end="(503, 9)">
                          <OtherNode start="(503, 5)" end="(503, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h_1&#10;ctx : Context&#10;p✝ : Poly&#10;h : true = true&#10;⊢ denote ctx [] = 0" state_after="no goals" tactic="simp">
                            <AtomNode start="(503, 5)" end="(503, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(504, 3)" end="(504, 18)" kind="Lean.cdot" state_before="case h_2&#10;ctx : Context&#10;p p✝ : Poly&#10;x✝ : p = [] → False&#10;h : false = true&#10;⊢ denote ctx p = 0" state_after="no goals" tactic="· contradiction">
                    <OtherNode start="(504, 3)" end="(504, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(504, 3)" end="(504, 4)" kind="patternIgnore">
                        <OtherNode start="(504, 3)" end="(504, 4)" kind="token.«· »">
                          <AtomNode start="(504, 3)" end="(504, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(504, 5)" end="(504, 18)">
                      <TacticTacticseq1IndentedNode start="(504, 5)" end="(504, 18)">
                        <NullNode start="(504, 5)" end="(504, 18)">
                          <OtherNode start="(504, 5)" end="(504, 18)" kind="Lean.Parser.Tactic.contradiction" state_before="case h_2&#10;ctx : Context&#10;p p✝ : Poly&#10;x✝ : p = [] → False&#10;h : false = true&#10;⊢ denote ctx p = 0" state_after="no goals" tactic="contradiction">
                            <AtomNode start="(504, 5)" end="(504, 18)" leading="" trailing="&#10;&#10;" val="contradiction"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(506, 1)" end="(513, 50)" name="Poly.of_isNonZero" full_name="Nat.Linear.Poly.of_isNonZero">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(506, 1)" end="(513, 50)" name="Poly.of_isNonZero" full_name="Nat.Linear.Poly.of_isNonZero" _is_private_decl="False">
        <AtomNode start="(506, 1)" end="(506, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(506, 9)" end="(506, 26)">
          <IdentNode start="(506, 9)" end="(506, 26)" leading="" trailing=" " raw_val="Poly.of_isNonZero" val="Poly.of_isNonZero"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(506, 27)" end="(506, 97)">
          <NullNode start="(506, 27)" end="(506, 78)">
            <TermExplicitbinderNode start="(506, 27)" end="(506, 42)">
              <AtomNode start="(506, 27)" end="(506, 28)" leading="" trailing="" val="("/>
              <NullNode start="(506, 28)" end="(506, 31)">
                <IdentNode start="(506, 28)" end="(506, 31)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(506, 32)" end="(506, 41)">
                <AtomNode start="(506, 32)" end="(506, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(506, 34)" end="(506, 41)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(506, 41)" end="(506, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(506, 43)" end="(506, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(506, 43)" end="(506, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(506, 44)" end="(506, 45)">
                <IdentNode start="(506, 44)" end="(506, 45)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(506, 46)" end="(506, 52)">
                <AtomNode start="(506, 46)" end="(506, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(506, 48)" end="(506, 52)" leading="" trailing="" raw_val="Poly" val="Poly" full_name="Nat.Linear.Poly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(46, 8)" def_end="(46, 12)"/>
              </NullNode>
              <AtomNode start="(506, 52)" end="(506, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(506, 54)" end="(506, 78)">
              <AtomNode start="(506, 54)" end="(506, 55)" leading="" trailing="" val="("/>
              <NullNode start="(506, 55)" end="(506, 56)">
                <IdentNode start="(506, 55)" end="(506, 56)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(506, 57)" end="(506, 77)">
                <AtomNode start="(506, 57)" end="(506, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(506, 59)" end="(506, 77)" kind="«term_=_»">
                  <OtherNode start="(506, 59)" end="(506, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(506, 59)" end="(506, 68)" leading="" trailing=" " raw_val="isNonZero" val="isNonZero" full_name="Nat.Linear.Poly.isNonZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(106, 5)" def_end="(106, 19)"/>
                    <NullNode start="(506, 69)" end="(506, 70)">
                      <IdentNode start="(506, 69)" end="(506, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(506, 71)" end="(506, 72)" leading="" trailing=" " val="="/>
                  <IdentNode start="(506, 73)" end="(506, 77)" leading="" trailing="" raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(506, 77)" end="(506, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(506, 79)" end="(506, 97)">
            <AtomNode start="(506, 79)" end="(506, 80)" leading="" trailing=" " val=":"/>
            <OtherNode start="(506, 81)" end="(506, 97)" kind="«term_&amp;gt;_»">
              <OtherNode start="(506, 81)" end="(506, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(506, 81)" end="(506, 89)" leading="" trailing=" " raw_val="p.denote" val="p.denote"/>
                <NullNode start="(506, 90)" end="(506, 93)">
                  <IdentNode start="(506, 90)" end="(506, 93)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(506, 94)" end="(506, 95)" leading="" trailing=" " val="&amp;gt;"/>
              <OtherNode start="(506, 96)" end="(506, 97)" kind="num">
                <AtomNode start="(506, 96)" end="(506, 97)" leading="" trailing=" " val="0"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(506, 98)" end="(513, 50)">
          <AtomNode start="(506, 98)" end="(506, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(506, 101)" end="(513, 50)">
            <AtomNode start="(506, 101)" end="(506, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(507, 3)" end="(513, 50)">
              <TacticTacticseq1IndentedNode start="(507, 3)" end="(513, 50)">
                <NullNode start="(507, 3)" end="(513, 50)">
                  <OtherNode start="(507, 3)" end="(513, 50)" kind="Lean.Parser.Tactic.match" state_before="ctx : Context&#10;p : Poly&#10;h : p.isNonZero = true&#10;⊢ denote ctx p &amp;gt; 0" state_after="no goals" tactic="match p with&#10;| [] =&amp;gt; contradiction&#10;| (k, v) :: p =&amp;gt;&#10;  by_cases he : v == fixedVar &amp;lt;;&amp;gt; simp [he, isNonZero] at h ⊢&#10;  · simp [eq_of_beq he, Var.denote]; apply Nat.lt_of_succ_le; exact Nat.le_trans h (Nat.le_add_right ..)&#10;  · have ih := of_isNonZero ctx h&#10;    exact Nat.le_trans ih (Nat.le_add_right ..)">
                    <AtomNode start="(507, 3)" end="(507, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(507, 9)" end="(507, 10)">
                      <OtherNode start="(507, 9)" end="(507, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(507, 9)" end="(507, 10)" leading="" trailing=" " raw_val="p" val="p"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(507, 11)" end="(507, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(508, 3)" end="(513, 50)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(508, 3)" end="(513, 50)">
                        <OtherNode start="(508, 3)" end="(508, 24)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(508, 3)" end="(508, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(508, 5)" end="(508, 7)">
                            <NullNode start="(508, 5)" end="(508, 7)">
                              <OtherNode start="(508, 5)" end="(508, 7)" kind="«term[_]»">
                                <AtomNode start="(508, 5)" end="(508, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(508, 6)" end="(508, 7)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(508, 8)" end="(508, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(508, 11)" end="(508, 24)">
                            <TacticTacticseq1IndentedNode start="(508, 11)" end="(508, 24)">
                              <NullNode start="(508, 11)" end="(508, 24)">
                                <OtherNode start="(508, 11)" end="(508, 24)" kind="Lean.Parser.Tactic.contradiction" state_before="ctx : Context&#10;p : Poly&#10;h : isNonZero [] = true&#10;⊢ denote ctx [] &amp;gt; 0" state_after="no goals" tactic="contradiction">
                                  <AtomNode start="(508, 11)" end="(508, 24)" leading="" trailing="&#10;  " val="contradiction"/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(509, 3)" end="(513, 50)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(509, 3)" end="(509, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(509, 5)" end="(509, 16)">
                            <NullNode start="(509, 5)" end="(509, 16)">
                              <OtherNode start="(509, 5)" end="(509, 16)" kind="«term_::_»">
                                <OtherNode start="(509, 5)" end="(509, 11)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(509, 5)" end="(509, 6)" leading="" trailing="" val="("/>
                                  <NullNode start="(509, 6)" end="(509, 10)">
                                    <IdentNode start="(509, 6)" end="(509, 7)" leading="" trailing="" raw_val="k" val="k"/>
                                    <AtomNode start="(509, 7)" end="(509, 8)" leading="" trailing=" " val=","/>
                                    <NullNode start="(509, 9)" end="(509, 10)">
                                      <IdentNode start="(509, 9)" end="(509, 10)" leading="" trailing="" raw_val="v" val="v"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(509, 10)" end="(509, 11)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(509, 12)" end="(509, 14)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(509, 15)" end="(509, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(509, 17)" end="(509, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(510, 5)" end="(513, 50)">
                            <TacticTacticseq1IndentedNode start="(510, 5)" end="(513, 50)">
                              <NullNode start="(510, 5)" end="(513, 50)">
                                <OtherNode start="(510, 5)" end="(510, 64)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;h : isNonZero ((k, v) :: p) = true&#10;⊢ denote ctx ((k, v) :: p) &amp;gt; 0" state_after="case pos&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : (v == fixedVar) = true&#10;h : 0 &amp;lt; k&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v&#10;&#10;case neg&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : ¬(v == fixedVar) = true&#10;h : isNonZero p = true&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" tactic="by_cases he : v == fixedVar &amp;lt;;&amp;gt; simp [he, isNonZero] at h ⊢">
                                  <OtherNode start="(510, 5)" end="(510, 32)" kind="«tacticBy_cases_:_»">
                                    <AtomNode start="(510, 5)" end="(510, 13)" leading="" trailing=" " val="by_cases"/>
                                    <NullNode start="(510, 14)" end="(510, 18)">
                                      <IdentNode start="(510, 14)" end="(510, 16)" leading="" trailing=" " raw_val="he" val="he"/>
                                      <AtomNode start="(510, 17)" end="(510, 18)" leading="" trailing=" " val=":"/>
                                    </NullNode>
                                    <OtherNode start="(510, 19)" end="(510, 32)" kind="«term_==_»">
                                      <IdentNode start="(510, 19)" end="(510, 20)" leading="" trailing=" " raw_val="v" val="v"/>
                                      <AtomNode start="(510, 21)" end="(510, 23)" leading="" trailing=" " val="=="/>
                                      <IdentNode start="(510, 24)" end="(510, 32)" leading="" trailing=" " raw_val="fixedVar" val="fixedVar" full_name="Nat.Linear.fixedVar" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(26, 5)" def_end="(26, 13)"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(510, 33)" end="(510, 36)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(510, 37)" end="(510, 64)" kind="Lean.Parser.Tactic.simp">
                                    <AtomNode start="(510, 37)" end="(510, 41)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(510, 42)" end="(510, 57)">
                                      <AtomNode start="(510, 42)" end="(510, 43)" leading="" trailing="" val="["/>
                                      <NullNode start="(510, 43)" end="(510, 56)">
                                        <OtherNode start="(510, 43)" end="(510, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(510, 43)" end="(510, 45)" leading="" trailing="" raw_val="he" val="he"/>
                                        </OtherNode>
                                        <AtomNode start="(510, 45)" end="(510, 46)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(510, 47)" end="(510, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(510, 47)" end="(510, 56)" leading="" trailing="" raw_val="isNonZero" val="isNonZero" full_name="Nat.Linear.Poly.isNonZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(106, 5)" def_end="(106, 19)"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(510, 56)" end="(510, 57)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(510, 58)" end="(510, 64)">
                                      <OtherNode start="(510, 58)" end="(510, 64)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(510, 58)" end="(510, 60)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(510, 61)" end="(510, 64)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(510, 61)" end="(510, 64)">
                                            <IdentNode start="(510, 61)" end="(510, 62)" leading="" trailing=" " raw_val="h" val="h"/>
                                            <OtherNode start="(510, 63)" end="(510, 64)" kind="Lean.Parser.Tactic.locationType">
                                              <OtherNode start="(510, 63)" end="(510, 64)" kind="patternIgnore">
                                                <OtherNode start="(510, 63)" end="(510, 64)" kind="token.«⊢»">
                                                  <AtomNode start="(510, 63)" end="(510, 64)" leading="" trailing="&#10;    " val="⊢"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(511, 5)" end="(511, 107)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : (v == fixedVar) = true&#10;h : 0 &amp;lt; k&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v&#10;&#10;case neg&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : ¬(v == fixedVar) = true&#10;h : isNonZero p = true&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" state_after="case neg&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : ¬(v == fixedVar) = true&#10;h : isNonZero p = true&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" tactic="· simp [eq_of_beq he, Var.denote]; apply Nat.lt_of_succ_le; exact Nat.le_trans h (Nat.le_add_right ..)">
                                  <OtherNode start="(511, 5)" end="(511, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(511, 5)" end="(511, 6)" kind="patternIgnore">
                                      <OtherNode start="(511, 5)" end="(511, 6)" kind="token.«· »">
                                        <AtomNode start="(511, 5)" end="(511, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(511, 7)" end="(511, 107)">
                                    <TacticTacticseq1IndentedNode start="(511, 7)" end="(511, 107)">
                                      <NullNode start="(511, 7)" end="(511, 107)">
                                        <OtherNode start="(511, 7)" end="(511, 38)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : (v == fixedVar) = true&#10;h : 0 &amp;lt; k&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" state_after="case pos&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : (v == fixedVar) = true&#10;h : 0 &amp;lt; k&#10;⊢ 0 &amp;lt; k + denote ctx p" tactic="simp [eq_of_beq he, Var.denote]">
                                          <AtomNode start="(511, 7)" end="(511, 11)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(511, 12)" end="(511, 38)">
                                            <AtomNode start="(511, 12)" end="(511, 13)" leading="" trailing="" val="["/>
                                            <NullNode start="(511, 13)" end="(511, 37)">
                                              <OtherNode start="(511, 13)" end="(511, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <OtherNode start="(511, 13)" end="(511, 25)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(511, 13)" end="(511, 22)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  <NullNode start="(511, 23)" end="(511, 25)">
                                                    <IdentNode start="(511, 23)" end="(511, 25)" leading="" trailing="" raw_val="he" val="he"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(511, 25)" end="(511, 26)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(511, 27)" end="(511, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(511, 27)" end="(511, 37)" leading="" trailing="" raw_val="Var.denote" val="Var.denote" full_name="Nat.Linear.Var.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(28, 5)" def_end="(28, 15)"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(511, 37)" end="(511, 38)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(511, 38)" end="(511, 39)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(511, 40)" end="(511, 63)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : (v == fixedVar) = true&#10;h : 0 &amp;lt; k&#10;⊢ 0 &amp;lt; k + denote ctx p" state_after="case pos.h&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : (v == fixedVar) = true&#10;h : 0 &amp;lt; k&#10;⊢ succ 0 ≤ k + denote ctx p" tactic="apply Nat.lt_of_succ_le">
                                          <AtomNode start="(511, 40)" end="(511, 45)" leading="" trailing=" " val="apply"/>
                                          <IdentNode start="(511, 46)" end="(511, 63)" leading="" trailing="" raw_val="Nat.lt_of_succ_le" val="Nat.lt_of_succ_le" full_name="Nat.lt_of_succ_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(511, 63)" end="(511, 64)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(511, 65)" end="(511, 107)" kind="Lean.Parser.Tactic.exact" state_before="case pos.h&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : (v == fixedVar) = true&#10;h : 0 &amp;lt; k&#10;⊢ succ 0 ≤ k + denote ctx p" state_after="no goals" tactic="exact Nat.le_trans h (Nat.le_add_right ..)">
                                          <AtomNode start="(511, 65)" end="(511, 70)" leading="" trailing=" " val="exact"/>
                                          <OtherNode start="(511, 71)" end="(511, 107)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(511, 71)" end="(511, 83)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            <NullNode start="(511, 84)" end="(511, 107)">
                                              <IdentNode start="(511, 84)" end="(511, 85)" leading="" trailing=" " raw_val="h" val="h"/>
                                              <OtherNode start="(511, 86)" end="(511, 107)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(511, 86)" end="(511, 87)" leading="" trailing="" val="("/>
                                                <OtherNode start="(511, 87)" end="(511, 106)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(511, 87)" end="(511, 103)" leading="" trailing=" " raw_val="Nat.le_add_right" val="Nat.le_add_right" full_name="Nat.le_add_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  <NullNode start="(511, 104)" end="(511, 106)">
                                                    <OtherNode start="(511, 104)" end="(511, 106)" kind="Lean.Parser.Term.ellipsis">
                                                      <AtomNode start="(511, 104)" end="(511, 106)" leading="" trailing="" val=".."/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(511, 106)" end="(511, 107)" leading="" trailing="&#10;    " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(512, 5)" end="(513, 50)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : ¬(v == fixedVar) = true&#10;h : isNonZero p = true&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" state_after="no goals" tactic="· have ih := of_isNonZero ctx h&#10;  exact Nat.le_trans ih (Nat.le_add_right ..)">
                                  <OtherNode start="(512, 5)" end="(512, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(512, 5)" end="(512, 6)" kind="patternIgnore">
                                      <OtherNode start="(512, 5)" end="(512, 6)" kind="token.«· »">
                                        <AtomNode start="(512, 5)" end="(512, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(512, 7)" end="(513, 50)">
                                    <TacticTacticseq1IndentedNode start="(512, 7)" end="(513, 50)">
                                      <NullNode start="(512, 7)" end="(513, 50)">
                                        <OtherNode start="(512, 7)" end="(512, 36)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : ¬(v == fixedVar) = true&#10;h : isNonZero p = true&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" state_after="case neg&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : ¬(v == fixedVar) = true&#10;h : isNonZero p = true&#10;ih : denote ctx p &amp;gt; 0&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" tactic="have ih := of_isNonZero ctx h">
                                          <AtomNode start="(512, 7)" end="(512, 11)" leading="" trailing=" " val="have"/>
                                          <OtherNode start="(512, 12)" end="(512, 36)" kind="Lean.Parser.Term.haveDecl">
                                            <OtherNode start="(512, 12)" end="(512, 36)" kind="Lean.Parser.Term.haveIdDecl">
                                              <OtherNode start="(512, 12)" end="(512, 14)" kind="Lean.Parser.Term.haveId">
                                                <IdentNode start="(512, 12)" end="(512, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <AtomNode start="(512, 15)" end="(512, 17)" leading="" trailing=" " val=":="/>
                                              <OtherNode start="(512, 18)" end="(512, 36)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(512, 18)" end="(512, 30)" leading="" trailing=" " raw_val="of_isNonZero" val="of_isNonZero"/>
                                                <NullNode start="(512, 31)" end="(512, 36)">
                                                  <IdentNode start="(512, 31)" end="(512, 34)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                  <IdentNode start="(512, 35)" end="(512, 36)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(513, 7)" end="(513, 50)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;ctx : Context&#10;p✝ : Poly&#10;k : Nat&#10;v : Var&#10;p : List (Nat × Var)&#10;he : ¬(v == fixedVar) = true&#10;h : isNonZero p = true&#10;ih : denote ctx p &amp;gt; 0&#10;⊢ 0 &amp;lt; denote ctx p + k * Var.denote ctx v" state_after="no goals" tactic="exact Nat.le_trans ih (Nat.le_add_right ..)">
                                          <AtomNode start="(513, 7)" end="(513, 12)" leading="" trailing=" " val="exact"/>
                                          <OtherNode start="(513, 13)" end="(513, 50)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(513, 13)" end="(513, 25)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            <NullNode start="(513, 26)" end="(513, 50)">
                                              <IdentNode start="(513, 26)" end="(513, 28)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                              <OtherNode start="(513, 29)" end="(513, 50)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(513, 29)" end="(513, 30)" leading="" trailing="" val="("/>
                                                <OtherNode start="(513, 30)" end="(513, 49)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(513, 30)" end="(513, 46)" leading="" trailing=" " raw_val="Nat.le_add_right" val="Nat.le_add_right" full_name="Nat.le_add_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  <NullNode start="(513, 47)" end="(513, 49)">
                                                    <OtherNode start="(513, 47)" end="(513, 49)" kind="Lean.Parser.Term.ellipsis">
                                                      <AtomNode start="(513, 47)" end="(513, 49)" leading="" trailing="" val=".."/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(513, 49)" end="(513, 50)" leading="" trailing="&#10;&#10;" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(515, 1)" end="(524, 35)" name="PolyCnstr.eq_false_of_isUnsat" full_name="Nat.Linear.PolyCnstr.eq_false_of_isUnsat">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(515, 1)" end="(524, 35)" name="PolyCnstr.eq_false_of_isUnsat" full_name="Nat.Linear.PolyCnstr.eq_false_of_isUnsat" _is_private_decl="False">
        <AtomNode start="(515, 1)" end="(515, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(515, 9)" end="(515, 38)">
          <IdentNode start="(515, 9)" end="(515, 38)" leading="" trailing=" " raw_val="PolyCnstr.eq_false_of_isUnsat" val="PolyCnstr.eq_false_of_isUnsat"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(515, 39)" end="(515, 105)">
          <NullNode start="(515, 39)" end="(515, 70)">
            <TermExplicitbinderNode start="(515, 39)" end="(515, 54)">
              <AtomNode start="(515, 39)" end="(515, 40)" leading="" trailing="" val="("/>
              <NullNode start="(515, 40)" end="(515, 43)">
                <IdentNode start="(515, 40)" end="(515, 43)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(515, 44)" end="(515, 53)">
                <AtomNode start="(515, 44)" end="(515, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(515, 46)" end="(515, 53)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(515, 53)" end="(515, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(515, 55)" end="(515, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(515, 55)" end="(515, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(515, 56)" end="(515, 57)">
                <IdentNode start="(515, 56)" end="(515, 57)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(515, 58)" end="(515, 69)">
                <AtomNode start="(515, 58)" end="(515, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(515, 60)" end="(515, 69)" leading="" trailing="" raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
              <AtomNode start="(515, 69)" end="(515, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(515, 71)" end="(515, 105)">
            <AtomNode start="(515, 71)" end="(515, 72)" leading="" trailing=" " val=":"/>
            <OtherNode start="(515, 73)" end="(515, 105)" kind="Lean.Parser.Term.arrow">
              <IdentNode start="(515, 73)" end="(515, 82)" leading="" trailing=" " raw_val="c.isUnsat" val="c.isUnsat"/>
              <AtomNode start="(515, 83)" end="(515, 84)" leading="" trailing=" " val="→"/>
              <OtherNode start="(515, 85)" end="(515, 105)" kind="«term_=_»">
                <OtherNode start="(515, 85)" end="(515, 97)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(515, 85)" end="(515, 93)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                  <NullNode start="(515, 94)" end="(515, 97)">
                    <IdentNode start="(515, 94)" end="(515, 97)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(515, 98)" end="(515, 99)" leading="" trailing=" " val="="/>
                <IdentNode start="(515, 100)" end="(515, 105)" leading="" trailing=" " raw_val="False" val="False" full_name="False" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(515, 106)" end="(524, 35)">
          <AtomNode start="(515, 106)" end="(515, 108)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(515, 109)" end="(524, 35)">
            <AtomNode start="(515, 109)" end="(515, 111)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(516, 3)" end="(524, 35)">
              <TacticTacticseq1IndentedNode start="(516, 3)" end="(524, 35)">
                <NullNode start="(516, 3)" end="(524, 35)">
                  <OtherNode start="(516, 3)" end="(516, 10)" kind="Lean.Parser.Tactic.cases" state_before="ctx : Context&#10;c : PolyCnstr&#10;⊢ c.isUnsat = true → denote ctx c = False" state_after="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;⊢ { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.isUnsat = true → denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ } = False" tactic="cases c">
                    <AtomNode start="(516, 3)" end="(516, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(516, 9)" end="(516, 10)">
                      <OtherNode start="(516, 9)" end="(516, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(516, 9)" end="(516, 10)" leading="" trailing="" raw_val="c" val="c"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(516, 10)" end="(516, 11)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(516, 12)" end="(516, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;⊢ { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.isUnsat = true → denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ } = False" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ { eq := eq, lhs := lhs, rhs := rhs }.isUnsat = true → denote ctx { eq := eq, lhs := lhs, rhs := rhs } = False" tactic="rename_i eq lhs rhs">
                    <AtomNode start="(516, 12)" end="(516, 20)" leading="" trailing=" " val="rename_i"/>
                    <NullNode start="(516, 21)" end="(516, 31)">
                      <LeanBinderidentNode start="(516, 21)" end="(516, 23)">
                        <IdentNode start="(516, 21)" end="(516, 23)" leading="" trailing=" " raw_val="eq" val="eq"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(516, 24)" end="(516, 27)">
                        <IdentNode start="(516, 24)" end="(516, 27)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(516, 28)" end="(516, 31)">
                        <IdentNode start="(516, 28)" end="(516, 31)" leading="" trailing="&#10;  " raw_val="rhs" val="rhs"/>
                      </LeanBinderidentNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(517, 3)" end="(517, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ { eq := eq, lhs := lhs, rhs := rhs }.isUnsat = true → denote ctx { eq := eq, lhs := lhs, rhs := rhs } = False" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ (bif eq then lhs.isZero &amp;amp;&amp;amp; rhs.isNonZero || lhs.isNonZero &amp;amp;&amp;amp; rhs.isZero else lhs.isNonZero &amp;amp;&amp;amp; rhs.isZero) = true →&#10;    ¬denote ctx { eq := eq, lhs := lhs, rhs := rhs }" tactic="simp [isUnsat]">
                    <AtomNode start="(517, 3)" end="(517, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(517, 8)" end="(517, 17)">
                      <AtomNode start="(517, 8)" end="(517, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(517, 9)" end="(517, 16)">
                        <OtherNode start="(517, 9)" end="(517, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(517, 9)" end="(517, 16)" leading="" trailing="" raw_val="isUnsat" val="isUnsat" full_name="Nat.Linear.PolyCnstr.isUnsat" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(168, 5)" def_end="(168, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(517, 16)" end="(517, 17)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(518, 3)" end="(518, 90)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ (bif eq then lhs.isZero &amp;amp;&amp;amp; rhs.isNonZero || lhs.isNonZero &amp;amp;&amp;amp; rhs.isZero else lhs.isNonZero &amp;amp;&amp;amp; rhs.isZero) = true →&#10;    ¬denote ctx { eq := eq, lhs := lhs, rhs := rhs }" state_after="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;⊢ lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true →&#10;    ¬Poly.denote ctx lhs = Poly.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isNonZero = true ∧ rhs.isZero = true → Poly.denote ctx rhs &amp;lt; Poly.denote ctx lhs" tactic="by_cases he : eq = true &amp;lt;;&amp;gt; simp [he, denote, Poly.denote_eq, Poly.denote_le, -and_imp]">
                    <OtherNode start="(518, 3)" end="(518, 26)" kind="«tacticBy_cases_:_»">
                      <AtomNode start="(518, 3)" end="(518, 11)" leading="" trailing=" " val="by_cases"/>
                      <NullNode start="(518, 12)" end="(518, 16)">
                        <IdentNode start="(518, 12)" end="(518, 14)" leading="" trailing=" " raw_val="he" val="he"/>
                        <AtomNode start="(518, 15)" end="(518, 16)" leading="" trailing=" " val=":"/>
                      </NullNode>
                      <OtherNode start="(518, 17)" end="(518, 26)" kind="«term_=_»">
                        <IdentNode start="(518, 17)" end="(518, 19)" leading="" trailing=" " raw_val="eq" val="eq"/>
                        <AtomNode start="(518, 20)" end="(518, 21)" leading="" trailing=" " val="="/>
                        <IdentNode start="(518, 22)" end="(518, 26)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(518, 27)" end="(518, 30)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(518, 31)" end="(518, 90)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(518, 31)" end="(518, 35)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(518, 36)" end="(518, 90)">
                        <AtomNode start="(518, 36)" end="(518, 37)" leading="" trailing="" val="["/>
                        <NullNode start="(518, 37)" end="(518, 89)">
                          <OtherNode start="(518, 37)" end="(518, 39)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(518, 37)" end="(518, 39)" leading="" trailing="" raw_val="he" val="he"/>
                          </OtherNode>
                          <AtomNode start="(518, 39)" end="(518, 40)" leading="" trailing=" " val=","/>
                          <OtherNode start="(518, 41)" end="(518, 47)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(518, 41)" end="(518, 47)" leading="" trailing="" raw_val="denote" val="denote" full_name="Nat.Linear.PolyCnstr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(158, 5)" def_end="(158, 21)"/>
                          </OtherNode>
                          <AtomNode start="(518, 47)" end="(518, 48)" leading="" trailing=" " val=","/>
                          <OtherNode start="(518, 49)" end="(518, 63)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(518, 49)" end="(518, 63)" leading="" trailing="" raw_val="Poly.denote_eq" val="Poly.denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                          </OtherNode>
                          <AtomNode start="(518, 63)" end="(518, 64)" leading="" trailing=" " val=","/>
                          <OtherNode start="(518, 65)" end="(518, 79)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(518, 65)" end="(518, 79)" leading="" trailing="" raw_val="Poly.denote_le" val="Poly.denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                          </OtherNode>
                          <AtomNode start="(518, 79)" end="(518, 80)" leading="" trailing=" " val=","/>
                          <OtherNode start="(518, 81)" end="(518, 89)" kind="Lean.Parser.Tactic.simpErase">
                            <AtomNode start="(518, 81)" end="(518, 82)" leading="" trailing="" val="-"/>
                            <IdentNode start="(518, 82)" end="(518, 89)" leading="" trailing="" raw_val="and_imp" val="and_imp" full_name="and_imp" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(518, 89)" end="(518, 90)" leading="" trailing="&#10;  " val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(519, 3)" end="(521, 120)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;⊢ lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true →&#10;    ¬Poly.denote ctx lhs = Poly.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isNonZero = true ∧ rhs.isZero = true → Poly.denote ctx rhs &amp;lt; Poly.denote ctx lhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isNonZero = true ∧ rhs.isZero = true → Poly.denote ctx rhs &amp;lt; Poly.denote ctx lhs" tactic="· intro&#10;    | Or.inl ⟨h₁, h₂⟩ =&amp;gt; simp [Poly.of_isZero, h₁]; have := Nat.ne_zero_of_lt (Poly.of_isNonZero ctx h₂); simp [this.symm]&#10;    | Or.inr ⟨h₁, h₂⟩ =&amp;gt; simp [Poly.of_isZero, h₂]; have := Nat.ne_zero_of_lt (Poly.of_isNonZero ctx h₁); simp [this]">
                    <OtherNode start="(519, 3)" end="(519, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(519, 3)" end="(519, 4)" kind="patternIgnore">
                        <OtherNode start="(519, 3)" end="(519, 4)" kind="token.«· »">
                          <AtomNode start="(519, 3)" end="(519, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(519, 5)" end="(521, 120)">
                      <TacticTacticseq1IndentedNode start="(519, 5)" end="(521, 120)">
                        <NullNode start="(519, 5)" end="(521, 120)">
                          <OtherNode start="(519, 5)" end="(521, 120)" kind="Lean.Parser.Tactic.introMatch" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;⊢ lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true →&#10;    ¬Poly.denote ctx lhs = Poly.denote ctx rhs" state_after="no goals" tactic="intro&#10;  | Or.inl ⟨h₁, h₂⟩ =&amp;gt; simp [Poly.of_isZero, h₁]; have := Nat.ne_zero_of_lt (Poly.of_isNonZero ctx h₂); simp [this.symm]&#10;  | Or.inr ⟨h₁, h₂⟩ =&amp;gt; simp [Poly.of_isZero, h₂]; have := Nat.ne_zero_of_lt (Poly.of_isNonZero ctx h₁); simp [this]">
                            <AtomNode start="(519, 5)" end="(519, 10)" leading="" trailing="&#10;      " val="intro"/>
                            <OtherNode start="(520, 7)" end="(521, 120)" kind="Lean.Parser.Term.matchAlts">
                              <NullNode start="(520, 7)" end="(521, 120)">
                                <OtherNode start="(520, 7)" end="(520, 125)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(520, 7)" end="(520, 8)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(520, 9)" end="(520, 24)">
                                    <NullNode start="(520, 9)" end="(520, 24)">
                                      <OtherNode start="(520, 9)" end="(520, 24)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(520, 9)" end="(520, 15)" leading="" trailing=" " raw_val="Or.inl" val="Or.inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <NullNode start="(520, 16)" end="(520, 24)">
                                          <OtherNode start="(520, 16)" end="(520, 24)" kind="Lean.Parser.Term.anonymousCtor">
                                            <AtomNode start="(520, 16)" end="(520, 17)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(520, 17)" end="(520, 23)">
                                              <IdentNode start="(520, 17)" end="(520, 19)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                              <AtomNode start="(520, 19)" end="(520, 20)" leading="" trailing=" " val=","/>
                                              <IdentNode start="(520, 21)" end="(520, 23)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                            <AtomNode start="(520, 23)" end="(520, 24)" leading="" trailing=" " val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(520, 25)" end="(520, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <TacticTacticseqNode start="(520, 28)" end="(520, 125)">
                                    <TacticTacticseq1IndentedNode start="(520, 28)" end="(520, 125)">
                                      <NullNode start="(520, 28)" end="(520, 125)">
                                        <OtherNode start="(520, 28)" end="(520, 53)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isZero = true&#10;h₂ : rhs.isNonZero = true&#10;⊢ ¬Poly.denote ctx lhs = Poly.denote ctx rhs" state_after="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isZero = true&#10;h₂ : rhs.isNonZero = true&#10;⊢ ¬0 = Poly.denote ctx rhs" tactic="simp [Poly.of_isZero, h₁]">
                                          <AtomNode start="(520, 28)" end="(520, 32)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(520, 33)" end="(520, 53)">
                                            <AtomNode start="(520, 33)" end="(520, 34)" leading="" trailing="" val="["/>
                                            <NullNode start="(520, 34)" end="(520, 52)">
                                              <OtherNode start="(520, 34)" end="(520, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(520, 34)" end="(520, 48)" leading="" trailing="" raw_val="Poly.of_isZero" val="Poly.of_isZero" full_name="Nat.Linear.Poly.of_isZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(500, 9)" def_end="(500, 23)"/>
                                              </OtherNode>
                                              <AtomNode start="(520, 48)" end="(520, 49)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(520, 50)" end="(520, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(520, 50)" end="(520, 52)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(520, 52)" end="(520, 53)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(520, 53)" end="(520, 54)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(520, 55)" end="(520, 107)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isZero = true&#10;h₂ : rhs.isNonZero = true&#10;⊢ ¬0 = Poly.denote ctx rhs" state_after="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isZero = true&#10;h₂ : rhs.isNonZero = true&#10;this : Poly.denote ctx rhs ≠ 0&#10;⊢ ¬0 = Poly.denote ctx rhs" tactic="have := Nat.ne_zero_of_lt (Poly.of_isNonZero ctx h₂)">
                                          <AtomNode start="(520, 55)" end="(520, 59)" leading="" trailing=" " val="have"/>
                                          <OtherNode start="(520, 60)" end="(520, 107)" kind="Lean.Parser.Term.haveDecl">
                                            <OtherNode start="(520, 60)" end="(520, 107)" kind="Lean.Parser.Term.haveIdDecl">
                                              <OtherNode start="(520, 60)" end="(520, 60)" kind="Lean.Parser.Term.haveId">
                                                <OtherNode start="(520, 60)" end="(520, 60)" kind="hygieneInfo">
                                                  <IdentNode start="(520, 60)" end="(520, 60)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                </OtherNode>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <AtomNode start="(520, 60)" end="(520, 62)" leading="" trailing=" " val=":="/>
                                              <OtherNode start="(520, 63)" end="(520, 107)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(520, 63)" end="(520, 80)" leading="" trailing=" " raw_val="Nat.ne_zero_of_lt" val="Nat.ne_zero_of_lt" full_name="Nat.ne_zero_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                <NullNode start="(520, 81)" end="(520, 107)">
                                                  <OtherNode start="(520, 81)" end="(520, 107)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(520, 81)" end="(520, 82)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(520, 82)" end="(520, 106)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(520, 82)" end="(520, 99)" leading="" trailing=" " raw_val="Poly.of_isNonZero" val="Poly.of_isNonZero" full_name="Nat.Linear.Poly.of_isNonZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(506, 9)" def_end="(506, 26)"/>
                                                      <NullNode start="(520, 100)" end="(520, 106)">
                                                        <IdentNode start="(520, 100)" end="(520, 103)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                        <IdentNode start="(520, 104)" end="(520, 106)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(520, 106)" end="(520, 107)" leading="" trailing="" val=")"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(520, 107)" end="(520, 108)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(520, 109)" end="(520, 125)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isZero = true&#10;h₂ : rhs.isNonZero = true&#10;this : Poly.denote ctx rhs ≠ 0&#10;⊢ ¬0 = Poly.denote ctx rhs" state_after="no goals" tactic="simp [this.symm]">
                                          <AtomNode start="(520, 109)" end="(520, 113)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(520, 114)" end="(520, 125)">
                                            <AtomNode start="(520, 114)" end="(520, 115)" leading="" trailing="" val="["/>
                                            <NullNode start="(520, 115)" end="(520, 124)">
                                              <OtherNode start="(520, 115)" end="(520, 124)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(520, 115)" end="(520, 124)" leading="" trailing="" raw_val="this.symm" val="this.symm"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(520, 124)" end="(520, 125)" leading="" trailing="&#10;      " val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                                <OtherNode start="(521, 7)" end="(521, 120)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(521, 7)" end="(521, 8)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(521, 9)" end="(521, 24)">
                                    <NullNode start="(521, 9)" end="(521, 24)">
                                      <OtherNode start="(521, 9)" end="(521, 24)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(521, 9)" end="(521, 15)" leading="" trailing=" " raw_val="Or.inr" val="Or.inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <NullNode start="(521, 16)" end="(521, 24)">
                                          <OtherNode start="(521, 16)" end="(521, 24)" kind="Lean.Parser.Term.anonymousCtor">
                                            <AtomNode start="(521, 16)" end="(521, 17)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(521, 17)" end="(521, 23)">
                                              <IdentNode start="(521, 17)" end="(521, 19)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                              <AtomNode start="(521, 19)" end="(521, 20)" leading="" trailing=" " val=","/>
                                              <IdentNode start="(521, 21)" end="(521, 23)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                            <AtomNode start="(521, 23)" end="(521, 24)" leading="" trailing=" " val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(521, 25)" end="(521, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <TacticTacticseqNode start="(521, 28)" end="(521, 120)">
                                    <TacticTacticseq1IndentedNode start="(521, 28)" end="(521, 120)">
                                      <NullNode start="(521, 28)" end="(521, 120)">
                                        <OtherNode start="(521, 28)" end="(521, 53)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ ¬Poly.denote ctx lhs = Poly.denote ctx rhs" state_after="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ ¬Poly.denote ctx lhs = 0" tactic="simp [Poly.of_isZero, h₂]">
                                          <AtomNode start="(521, 28)" end="(521, 32)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(521, 33)" end="(521, 53)">
                                            <AtomNode start="(521, 33)" end="(521, 34)" leading="" trailing="" val="["/>
                                            <NullNode start="(521, 34)" end="(521, 52)">
                                              <OtherNode start="(521, 34)" end="(521, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(521, 34)" end="(521, 48)" leading="" trailing="" raw_val="Poly.of_isZero" val="Poly.of_isZero" full_name="Nat.Linear.Poly.of_isZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(500, 9)" def_end="(500, 23)"/>
                                              </OtherNode>
                                              <AtomNode start="(521, 48)" end="(521, 49)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(521, 50)" end="(521, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(521, 50)" end="(521, 52)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(521, 52)" end="(521, 53)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(521, 53)" end="(521, 54)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(521, 55)" end="(521, 107)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ ¬Poly.denote ctx lhs = 0" state_after="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;this : Poly.denote ctx lhs ≠ 0&#10;⊢ ¬Poly.denote ctx lhs = 0" tactic="have := Nat.ne_zero_of_lt (Poly.of_isNonZero ctx h₁)">
                                          <AtomNode start="(521, 55)" end="(521, 59)" leading="" trailing=" " val="have"/>
                                          <OtherNode start="(521, 60)" end="(521, 107)" kind="Lean.Parser.Term.haveDecl">
                                            <OtherNode start="(521, 60)" end="(521, 107)" kind="Lean.Parser.Term.haveIdDecl">
                                              <OtherNode start="(521, 60)" end="(521, 60)" kind="Lean.Parser.Term.haveId">
                                                <OtherNode start="(521, 60)" end="(521, 60)" kind="hygieneInfo">
                                                  <IdentNode start="(521, 60)" end="(521, 60)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                </OtherNode>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <AtomNode start="(521, 60)" end="(521, 62)" leading="" trailing=" " val=":="/>
                                              <OtherNode start="(521, 63)" end="(521, 107)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(521, 63)" end="(521, 80)" leading="" trailing=" " raw_val="Nat.ne_zero_of_lt" val="Nat.ne_zero_of_lt" full_name="Nat.ne_zero_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                <NullNode start="(521, 81)" end="(521, 107)">
                                                  <OtherNode start="(521, 81)" end="(521, 107)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(521, 81)" end="(521, 82)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(521, 82)" end="(521, 106)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(521, 82)" end="(521, 99)" leading="" trailing=" " raw_val="Poly.of_isNonZero" val="Poly.of_isNonZero" full_name="Nat.Linear.Poly.of_isNonZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(506, 9)" def_end="(506, 26)"/>
                                                      <NullNode start="(521, 100)" end="(521, 106)">
                                                        <IdentNode start="(521, 100)" end="(521, 103)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                                        <IdentNode start="(521, 104)" end="(521, 106)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(521, 106)" end="(521, 107)" leading="" trailing="" val=")"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(521, 107)" end="(521, 108)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(521, 109)" end="(521, 120)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;x✝ : lhs.isZero = true ∧ rhs.isNonZero = true ∨ lhs.isNonZero = true ∧ rhs.isZero = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;this : Poly.denote ctx lhs ≠ 0&#10;⊢ ¬Poly.denote ctx lhs = 0" state_after="no goals" tactic="simp [this]">
                                          <AtomNode start="(521, 109)" end="(521, 113)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(521, 114)" end="(521, 120)">
                                            <AtomNode start="(521, 114)" end="(521, 115)" leading="" trailing="" val="["/>
                                            <NullNode start="(521, 115)" end="(521, 119)">
                                              <OtherNode start="(521, 115)" end="(521, 119)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(521, 115)" end="(521, 119)" leading="" trailing="" raw_val="this" val="this"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(521, 119)" end="(521, 120)" leading="" trailing="&#10;  " val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(522, 3)" end="(524, 35)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isNonZero = true ∧ rhs.isZero = true → Poly.denote ctx rhs &amp;lt; Poly.denote ctx lhs" state_after="no goals" tactic="· intro ⟨h₁, h₂⟩&#10;  simp [Poly.of_isZero, h₂]&#10;  exact Poly.of_isNonZero ctx h₁">
                    <OtherNode start="(522, 3)" end="(522, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(522, 3)" end="(522, 4)" kind="patternIgnore">
                        <OtherNode start="(522, 3)" end="(522, 4)" kind="token.«· »">
                          <AtomNode start="(522, 3)" end="(522, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(522, 5)" end="(524, 35)">
                      <TacticTacticseq1IndentedNode start="(522, 5)" end="(524, 35)">
                        <NullNode start="(522, 5)" end="(524, 35)">
                          <OtherNode start="(522, 5)" end="(522, 19)" kind="Lean.Parser.Tactic.intro" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isNonZero = true ∧ rhs.isZero = true → Poly.denote ctx rhs &amp;lt; Poly.denote ctx lhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ Poly.denote ctx rhs &amp;lt; Poly.denote ctx lhs" tactic="intro ⟨h₁, h₂⟩">
                            <AtomNode start="(522, 5)" end="(522, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(522, 11)" end="(522, 19)">
                              <OtherNode start="(522, 11)" end="(522, 19)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(522, 11)" end="(522, 12)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(522, 12)" end="(522, 18)">
                                  <IdentNode start="(522, 12)" end="(522, 14)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                  <AtomNode start="(522, 14)" end="(522, 15)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(522, 16)" end="(522, 18)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                </NullNode>
                                <AtomNode start="(522, 18)" end="(522, 19)" leading="" trailing="&#10;    " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(523, 5)" end="(523, 30)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ Poly.denote ctx rhs &amp;lt; Poly.denote ctx lhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ 0 &amp;lt; Poly.denote ctx lhs" tactic="simp [Poly.of_isZero, h₂]">
                            <AtomNode start="(523, 5)" end="(523, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(523, 10)" end="(523, 30)">
                              <AtomNode start="(523, 10)" end="(523, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(523, 11)" end="(523, 29)">
                                <OtherNode start="(523, 11)" end="(523, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(523, 11)" end="(523, 25)" leading="" trailing="" raw_val="Poly.of_isZero" val="Poly.of_isZero" full_name="Nat.Linear.Poly.of_isZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(500, 9)" def_end="(500, 23)"/>
                                </OtherNode>
                                <AtomNode start="(523, 25)" end="(523, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(523, 27)" end="(523, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(523, 27)" end="(523, 29)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(523, 29)" end="(523, 30)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(524, 5)" end="(524, 35)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;h₁ : lhs.isNonZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ 0 &amp;lt; Poly.denote ctx lhs" state_after="no goals" tactic="exact Poly.of_isNonZero ctx h₁">
                            <AtomNode start="(524, 5)" end="(524, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(524, 11)" end="(524, 35)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(524, 11)" end="(524, 28)" leading="" trailing=" " raw_val="Poly.of_isNonZero" val="Poly.of_isNonZero" full_name="Nat.Linear.Poly.of_isNonZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(506, 9)" def_end="(506, 26)"/>
                              <NullNode start="(524, 29)" end="(524, 35)">
                                <IdentNode start="(524, 29)" end="(524, 32)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                                <IdentNode start="(524, 33)" end="(524, 35)" leading="" trailing="&#10;&#10;" raw_val="h₁" val="h₁"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(526, 1)" end="(533, 29)" name="PolyCnstr.eq_true_of_isValid" full_name="Nat.Linear.PolyCnstr.eq_true_of_isValid">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(526, 1)" end="(533, 29)" name="PolyCnstr.eq_true_of_isValid" full_name="Nat.Linear.PolyCnstr.eq_true_of_isValid" _is_private_decl="False">
        <AtomNode start="(526, 1)" end="(526, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(526, 9)" end="(526, 37)">
          <IdentNode start="(526, 9)" end="(526, 37)" leading="" trailing=" " raw_val="PolyCnstr.eq_true_of_isValid" val="PolyCnstr.eq_true_of_isValid"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(526, 38)" end="(526, 103)">
          <NullNode start="(526, 38)" end="(526, 69)">
            <TermExplicitbinderNode start="(526, 38)" end="(526, 53)">
              <AtomNode start="(526, 38)" end="(526, 39)" leading="" trailing="" val="("/>
              <NullNode start="(526, 39)" end="(526, 42)">
                <IdentNode start="(526, 39)" end="(526, 42)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(526, 43)" end="(526, 52)">
                <AtomNode start="(526, 43)" end="(526, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(526, 45)" end="(526, 52)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(526, 52)" end="(526, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(526, 54)" end="(526, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(526, 54)" end="(526, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(526, 55)" end="(526, 56)">
                <IdentNode start="(526, 55)" end="(526, 56)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(526, 57)" end="(526, 68)">
                <AtomNode start="(526, 57)" end="(526, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(526, 59)" end="(526, 68)" leading="" trailing="" raw_val="PolyCnstr" val="PolyCnstr" full_name="Nat.Linear.PolyCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(133, 11)" def_end="(133, 20)"/>
              </NullNode>
              <AtomNode start="(526, 68)" end="(526, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(526, 70)" end="(526, 103)">
            <AtomNode start="(526, 70)" end="(526, 71)" leading="" trailing=" " val=":"/>
            <OtherNode start="(526, 72)" end="(526, 103)" kind="Lean.Parser.Term.arrow">
              <IdentNode start="(526, 72)" end="(526, 81)" leading="" trailing=" " raw_val="c.isValid" val="c.isValid"/>
              <AtomNode start="(526, 82)" end="(526, 83)" leading="" trailing=" " val="→"/>
              <OtherNode start="(526, 84)" end="(526, 103)" kind="«term_=_»">
                <OtherNode start="(526, 84)" end="(526, 96)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(526, 84)" end="(526, 92)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                  <NullNode start="(526, 93)" end="(526, 96)">
                    <IdentNode start="(526, 93)" end="(526, 96)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(526, 97)" end="(526, 98)" leading="" trailing=" " val="="/>
                <IdentNode start="(526, 99)" end="(526, 103)" leading="" trailing=" " raw_val="True" val="True" full_name="True" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(526, 104)" end="(533, 29)">
          <AtomNode start="(526, 104)" end="(526, 106)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(526, 107)" end="(533, 29)">
            <AtomNode start="(526, 107)" end="(526, 109)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(527, 3)" end="(533, 29)">
              <TacticTacticseq1IndentedNode start="(527, 3)" end="(533, 29)">
                <NullNode start="(527, 3)" end="(533, 29)">
                  <OtherNode start="(527, 3)" end="(527, 10)" kind="Lean.Parser.Tactic.cases" state_before="ctx : Context&#10;c : PolyCnstr&#10;⊢ c.isValid = true → denote ctx c = True" state_after="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;⊢ { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.isValid = true → denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ } = True" tactic="cases c">
                    <AtomNode start="(527, 3)" end="(527, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(527, 9)" end="(527, 10)">
                      <OtherNode start="(527, 9)" end="(527, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(527, 9)" end="(527, 10)" leading="" trailing="" raw_val="c" val="c"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(527, 10)" end="(527, 11)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(527, 12)" end="(527, 31)" kind="Lean.Parser.Tactic.renameI" state_before="case mk&#10;ctx : Context&#10;eq✝ : Bool&#10;lhs✝ rhs✝ : Poly&#10;⊢ { eq := eq✝, lhs := lhs✝, rhs := rhs✝ }.isValid = true → denote ctx { eq := eq✝, lhs := lhs✝, rhs := rhs✝ } = True" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ { eq := eq, lhs := lhs, rhs := rhs }.isValid = true → denote ctx { eq := eq, lhs := lhs, rhs := rhs } = True" tactic="rename_i eq lhs rhs">
                    <AtomNode start="(527, 12)" end="(527, 20)" leading="" trailing=" " val="rename_i"/>
                    <NullNode start="(527, 21)" end="(527, 31)">
                      <LeanBinderidentNode start="(527, 21)" end="(527, 23)">
                        <IdentNode start="(527, 21)" end="(527, 23)" leading="" trailing=" " raw_val="eq" val="eq"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(527, 24)" end="(527, 27)">
                        <IdentNode start="(527, 24)" end="(527, 27)" leading="" trailing=" " raw_val="lhs" val="lhs"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(527, 28)" end="(527, 31)">
                        <IdentNode start="(527, 28)" end="(527, 31)" leading="" trailing="&#10;  " raw_val="rhs" val="rhs"/>
                      </LeanBinderidentNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(528, 3)" end="(528, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ { eq := eq, lhs := lhs, rhs := rhs }.isValid = true → denote ctx { eq := eq, lhs := lhs, rhs := rhs } = True" state_after="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ (bif eq then lhs.isZero &amp;amp;&amp;amp; rhs.isZero else lhs.isZero) = true → denote ctx { eq := eq, lhs := lhs, rhs := rhs }" tactic="simp [isValid]">
                    <AtomNode start="(528, 3)" end="(528, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(528, 8)" end="(528, 17)">
                      <AtomNode start="(528, 8)" end="(528, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(528, 9)" end="(528, 16)">
                        <OtherNode start="(528, 9)" end="(528, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(528, 9)" end="(528, 16)" leading="" trailing="" raw_val="isValid" val="isValid" full_name="Nat.Linear.PolyCnstr.isValid" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(174, 5)" def_end="(174, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(528, 16)" end="(528, 17)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(529, 3)" end="(529, 90)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;⊢ (bif eq then lhs.isZero &amp;amp;&amp;amp; rhs.isZero else lhs.isZero) = true → denote ctx { eq := eq, lhs := lhs, rhs := rhs }" state_after="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;⊢ lhs.isZero = true ∧ rhs.isZero = true → Poly.denote ctx lhs = Poly.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isZero = true → Poly.denote ctx lhs ≤ Poly.denote ctx rhs" tactic="by_cases he : eq = true &amp;lt;;&amp;gt; simp [he, denote, Poly.denote_eq, Poly.denote_le, -and_imp]">
                    <OtherNode start="(529, 3)" end="(529, 26)" kind="«tacticBy_cases_:_»">
                      <AtomNode start="(529, 3)" end="(529, 11)" leading="" trailing=" " val="by_cases"/>
                      <NullNode start="(529, 12)" end="(529, 16)">
                        <IdentNode start="(529, 12)" end="(529, 14)" leading="" trailing=" " raw_val="he" val="he"/>
                        <AtomNode start="(529, 15)" end="(529, 16)" leading="" trailing=" " val=":"/>
                      </NullNode>
                      <OtherNode start="(529, 17)" end="(529, 26)" kind="«term_=_»">
                        <IdentNode start="(529, 17)" end="(529, 19)" leading="" trailing=" " raw_val="eq" val="eq"/>
                        <AtomNode start="(529, 20)" end="(529, 21)" leading="" trailing=" " val="="/>
                        <IdentNode start="(529, 22)" end="(529, 26)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(529, 27)" end="(529, 30)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(529, 31)" end="(529, 90)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(529, 31)" end="(529, 35)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(529, 36)" end="(529, 90)">
                        <AtomNode start="(529, 36)" end="(529, 37)" leading="" trailing="" val="["/>
                        <NullNode start="(529, 37)" end="(529, 89)">
                          <OtherNode start="(529, 37)" end="(529, 39)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(529, 37)" end="(529, 39)" leading="" trailing="" raw_val="he" val="he"/>
                          </OtherNode>
                          <AtomNode start="(529, 39)" end="(529, 40)" leading="" trailing=" " val=","/>
                          <OtherNode start="(529, 41)" end="(529, 47)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(529, 41)" end="(529, 47)" leading="" trailing="" raw_val="denote" val="denote" full_name="Nat.Linear.PolyCnstr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(158, 5)" def_end="(158, 21)"/>
                          </OtherNode>
                          <AtomNode start="(529, 47)" end="(529, 48)" leading="" trailing=" " val=","/>
                          <OtherNode start="(529, 49)" end="(529, 63)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(529, 49)" end="(529, 63)" leading="" trailing="" raw_val="Poly.denote_eq" val="Poly.denote_eq" full_name="Nat.Linear.Poly.denote_eq" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(111, 5)" def_end="(111, 19)"/>
                          </OtherNode>
                          <AtomNode start="(529, 63)" end="(529, 64)" leading="" trailing=" " val=","/>
                          <OtherNode start="(529, 65)" end="(529, 79)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(529, 65)" end="(529, 79)" leading="" trailing="" raw_val="Poly.denote_le" val="Poly.denote_le" full_name="Nat.Linear.Poly.denote_le" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(113, 5)" def_end="(113, 19)"/>
                          </OtherNode>
                          <AtomNode start="(529, 79)" end="(529, 80)" leading="" trailing=" " val=","/>
                          <OtherNode start="(529, 81)" end="(529, 89)" kind="Lean.Parser.Tactic.simpErase">
                            <AtomNode start="(529, 81)" end="(529, 82)" leading="" trailing="" val="-"/>
                            <IdentNode start="(529, 82)" end="(529, 89)" leading="" trailing="" raw_val="and_imp" val="and_imp" full_name="and_imp" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(529, 89)" end="(529, 90)" leading="" trailing="&#10;  " val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(530, 3)" end="(531, 34)" kind="Lean.cdot" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;⊢ lhs.isZero = true ∧ rhs.isZero = true → Poly.denote ctx lhs = Poly.denote ctx rhs&#10;&#10;case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isZero = true → Poly.denote ctx lhs ≤ Poly.denote ctx rhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isZero = true → Poly.denote ctx lhs ≤ Poly.denote ctx rhs" tactic="· intro ⟨h₁, h₂⟩&#10;  simp [Poly.of_isZero, h₁, h₂]">
                    <OtherNode start="(530, 3)" end="(530, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(530, 3)" end="(530, 4)" kind="patternIgnore">
                        <OtherNode start="(530, 3)" end="(530, 4)" kind="token.«· »">
                          <AtomNode start="(530, 3)" end="(530, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(530, 5)" end="(531, 34)">
                      <TacticTacticseq1IndentedNode start="(530, 5)" end="(531, 34)">
                        <NullNode start="(530, 5)" end="(531, 34)">
                          <OtherNode start="(530, 5)" end="(530, 19)" kind="Lean.Parser.Tactic.intro" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;⊢ lhs.isZero = true ∧ rhs.isZero = true → Poly.denote ctx lhs = Poly.denote ctx rhs" state_after="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;h₁ : lhs.isZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ Poly.denote ctx lhs = Poly.denote ctx rhs" tactic="intro ⟨h₁, h₂⟩">
                            <AtomNode start="(530, 5)" end="(530, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(530, 11)" end="(530, 19)">
                              <OtherNode start="(530, 11)" end="(530, 19)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(530, 11)" end="(530, 12)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(530, 12)" end="(530, 18)">
                                  <IdentNode start="(530, 12)" end="(530, 14)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                  <AtomNode start="(530, 14)" end="(530, 15)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(530, 16)" end="(530, 18)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                </NullNode>
                                <AtomNode start="(530, 18)" end="(530, 19)" leading="" trailing="&#10;    " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(531, 5)" end="(531, 34)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : eq = true&#10;h₁ : lhs.isZero = true&#10;h₂ : rhs.isZero = true&#10;⊢ Poly.denote ctx lhs = Poly.denote ctx rhs" state_after="no goals" tactic="simp [Poly.of_isZero, h₁, h₂]">
                            <AtomNode start="(531, 5)" end="(531, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(531, 10)" end="(531, 34)">
                              <AtomNode start="(531, 10)" end="(531, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(531, 11)" end="(531, 33)">
                                <OtherNode start="(531, 11)" end="(531, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(531, 11)" end="(531, 25)" leading="" trailing="" raw_val="Poly.of_isZero" val="Poly.of_isZero" full_name="Nat.Linear.Poly.of_isZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(500, 9)" def_end="(500, 23)"/>
                                </OtherNode>
                                <AtomNode start="(531, 25)" end="(531, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(531, 27)" end="(531, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(531, 27)" end="(531, 29)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                </OtherNode>
                                <AtomNode start="(531, 29)" end="(531, 30)" leading="" trailing=" " val=","/>
                                <OtherNode start="(531, 31)" end="(531, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(531, 31)" end="(531, 33)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(531, 33)" end="(531, 34)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(532, 3)" end="(533, 29)" kind="Lean.cdot" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isZero = true → Poly.denote ctx lhs ≤ Poly.denote ctx rhs" state_after="no goals" tactic="· intro h&#10;  simp [Poly.of_isZero, h]">
                    <OtherNode start="(532, 3)" end="(532, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(532, 3)" end="(532, 4)" kind="patternIgnore">
                        <OtherNode start="(532, 3)" end="(532, 4)" kind="token.«· »">
                          <AtomNode start="(532, 3)" end="(532, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(532, 5)" end="(533, 29)">
                      <TacticTacticseq1IndentedNode start="(532, 5)" end="(533, 29)">
                        <NullNode start="(532, 5)" end="(533, 29)">
                          <OtherNode start="(532, 5)" end="(532, 12)" kind="Lean.Parser.Tactic.intro" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;⊢ lhs.isZero = true → Poly.denote ctx lhs ≤ Poly.denote ctx rhs" state_after="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;h : lhs.isZero = true&#10;⊢ Poly.denote ctx lhs ≤ Poly.denote ctx rhs" tactic="intro h">
                            <AtomNode start="(532, 5)" end="(532, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(532, 11)" end="(532, 12)">
                              <IdentNode start="(532, 11)" end="(532, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(533, 5)" end="(533, 29)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;ctx : Context&#10;eq : Bool&#10;lhs rhs : Poly&#10;he : ¬eq = true&#10;h : lhs.isZero = true&#10;⊢ Poly.denote ctx lhs ≤ Poly.denote ctx rhs" state_after="no goals" tactic="simp [Poly.of_isZero, h]">
                            <AtomNode start="(533, 5)" end="(533, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(533, 10)" end="(533, 29)">
                              <AtomNode start="(533, 10)" end="(533, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(533, 11)" end="(533, 28)">
                                <OtherNode start="(533, 11)" end="(533, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(533, 11)" end="(533, 25)" leading="" trailing="" raw_val="Poly.of_isZero" val="Poly.of_isZero" full_name="Nat.Linear.Poly.of_isZero" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(500, 9)" def_end="(500, 23)"/>
                                </OtherNode>
                                <AtomNode start="(533, 25)" end="(533, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(533, 27)" end="(533, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(533, 27)" end="(533, 28)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(533, 28)" end="(533, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(535, 1)" end="(538, 13)" name="ExprCnstr.eq_false_of_isUnsat" full_name="Nat.Linear.ExprCnstr.eq_false_of_isUnsat">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(535, 1)" end="(538, 13)" name="ExprCnstr.eq_false_of_isUnsat" full_name="Nat.Linear.ExprCnstr.eq_false_of_isUnsat" _is_private_decl="False">
        <AtomNode start="(535, 1)" end="(535, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(535, 9)" end="(535, 38)">
          <IdentNode start="(535, 9)" end="(535, 38)" leading="" trailing=" " raw_val="ExprCnstr.eq_false_of_isUnsat" val="ExprCnstr.eq_false_of_isUnsat"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(535, 39)" end="(535, 120)">
          <NullNode start="(535, 39)" end="(535, 97)">
            <TermExplicitbinderNode start="(535, 39)" end="(535, 54)">
              <AtomNode start="(535, 39)" end="(535, 40)" leading="" trailing="" val="("/>
              <NullNode start="(535, 40)" end="(535, 43)">
                <IdentNode start="(535, 40)" end="(535, 43)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(535, 44)" end="(535, 53)">
                <AtomNode start="(535, 44)" end="(535, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(535, 46)" end="(535, 53)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(535, 53)" end="(535, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(535, 55)" end="(535, 70)">
              <AtomNode start="(535, 55)" end="(535, 56)" leading="" trailing="" val="("/>
              <NullNode start="(535, 56)" end="(535, 57)">
                <IdentNode start="(535, 56)" end="(535, 57)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(535, 58)" end="(535, 69)">
                <AtomNode start="(535, 58)" end="(535, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(535, 60)" end="(535, 69)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(535, 69)" end="(535, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(535, 71)" end="(535, 97)">
              <AtomNode start="(535, 71)" end="(535, 72)" leading="" trailing="" val="("/>
              <NullNode start="(535, 72)" end="(535, 73)">
                <IdentNode start="(535, 72)" end="(535, 73)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(535, 74)" end="(535, 96)">
                <AtomNode start="(535, 74)" end="(535, 75)" leading="" trailing=" " val=":"/>
                <IdentNode start="(535, 76)" end="(535, 96)" leading="" trailing="" raw_val="c.toNormPoly.isUnsat" val="c.toNormPoly.isUnsat"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(535, 96)" end="(535, 97)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(535, 98)" end="(535, 120)">
            <AtomNode start="(535, 98)" end="(535, 99)" leading="" trailing=" " val=":"/>
            <OtherNode start="(535, 100)" end="(535, 120)" kind="«term_=_»">
              <OtherNode start="(535, 100)" end="(535, 112)" kind="Lean.Parser.Term.app">
                <IdentNode start="(535, 100)" end="(535, 108)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                <NullNode start="(535, 109)" end="(535, 112)">
                  <IdentNode start="(535, 109)" end="(535, 112)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(535, 113)" end="(535, 114)" leading="" trailing=" " val="="/>
              <IdentNode start="(535, 115)" end="(535, 120)" leading="" trailing=" " raw_val="False" val="False" full_name="False" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(535, 121)" end="(538, 13)">
          <AtomNode start="(535, 121)" end="(535, 123)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(535, 124)" end="(538, 13)">
            <AtomNode start="(535, 124)" end="(535, 126)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(536, 3)" end="(538, 13)">
              <TacticTacticseq1IndentedNode start="(536, 3)" end="(538, 13)">
                <NullNode start="(536, 3)" end="(538, 13)">
                  <OtherNode start="(536, 3)" end="(536, 46)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isUnsat = true&#10;⊢ denote ctx c = False" state_after="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isUnsat = true&#10;this : PolyCnstr.denote ctx c.toNormPoly = False&#10;⊢ denote ctx c = False" tactic="have := PolyCnstr.eq_false_of_isUnsat ctx h">
                    <AtomNode start="(536, 3)" end="(536, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(536, 8)" end="(536, 46)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(536, 8)" end="(536, 46)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(536, 8)" end="(536, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(536, 8)" end="(536, 8)" kind="hygieneInfo">
                            <IdentNode start="(536, 8)" end="(536, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(536, 8)" end="(536, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(536, 11)" end="(536, 46)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(536, 11)" end="(536, 40)" leading="" trailing=" " raw_val="PolyCnstr.eq_false_of_isUnsat" val="PolyCnstr.eq_false_of_isUnsat" full_name="Nat.Linear.PolyCnstr.eq_false_of_isUnsat" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(515, 9)" def_end="(515, 38)"/>
                          <NullNode start="(536, 41)" end="(536, 46)">
                            <IdentNode start="(536, 41)" end="(536, 44)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(536, 45)" end="(536, 46)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(537, 3)" end="(537, 29)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isUnsat = true&#10;this : PolyCnstr.denote ctx c.toNormPoly = False&#10;⊢ denote ctx c = False" state_after="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isUnsat = true&#10;this : denote ctx c = False&#10;⊢ denote ctx c = False" tactic="simp [-eq_iff_iff] at this">
                    <AtomNode start="(537, 3)" end="(537, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(537, 8)" end="(537, 21)">
                      <AtomNode start="(537, 8)" end="(537, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(537, 9)" end="(537, 20)">
                        <OtherNode start="(537, 9)" end="(537, 20)" kind="Lean.Parser.Tactic.simpErase">
                          <AtomNode start="(537, 9)" end="(537, 10)" leading="" trailing="" val="-"/>
                          <IdentNode start="(537, 10)" end="(537, 20)" leading="" trailing="" raw_val="eq_iff_iff" val="eq_iff_iff" full_name="eq_iff_iff" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(537, 20)" end="(537, 21)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(537, 22)" end="(537, 29)">
                      <OtherNode start="(537, 22)" end="(537, 29)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(537, 22)" end="(537, 24)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(537, 25)" end="(537, 29)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(537, 25)" end="(537, 29)">
                            <IdentNode start="(537, 25)" end="(537, 29)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(538, 3)" end="(538, 13)" kind="Lean.Parser.Tactic.assumption" state_before="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isUnsat = true&#10;this : denote ctx c = False&#10;⊢ denote ctx c = False" state_after="no goals" tactic="assumption">
                    <AtomNode start="(538, 3)" end="(538, 13)" leading="" trailing="&#10;&#10;" val="assumption"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(540, 1)" end="(543, 13)" name="ExprCnstr.eq_true_of_isValid" full_name="Nat.Linear.ExprCnstr.eq_true_of_isValid">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(540, 1)" end="(543, 13)" name="ExprCnstr.eq_true_of_isValid" full_name="Nat.Linear.ExprCnstr.eq_true_of_isValid" _is_private_decl="False">
        <AtomNode start="(540, 1)" end="(540, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(540, 9)" end="(540, 37)">
          <IdentNode start="(540, 9)" end="(540, 37)" leading="" trailing=" " raw_val="ExprCnstr.eq_true_of_isValid" val="ExprCnstr.eq_true_of_isValid"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(540, 38)" end="(540, 118)">
          <NullNode start="(540, 38)" end="(540, 96)">
            <TermExplicitbinderNode start="(540, 38)" end="(540, 53)">
              <AtomNode start="(540, 38)" end="(540, 39)" leading="" trailing="" val="("/>
              <NullNode start="(540, 39)" end="(540, 42)">
                <IdentNode start="(540, 39)" end="(540, 42)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(540, 43)" end="(540, 52)">
                <AtomNode start="(540, 43)" end="(540, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(540, 45)" end="(540, 52)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(540, 52)" end="(540, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(540, 54)" end="(540, 69)">
              <AtomNode start="(540, 54)" end="(540, 55)" leading="" trailing="" val="("/>
              <NullNode start="(540, 55)" end="(540, 56)">
                <IdentNode start="(540, 55)" end="(540, 56)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(540, 57)" end="(540, 68)">
                <AtomNode start="(540, 57)" end="(540, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(540, 59)" end="(540, 68)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(540, 68)" end="(540, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(540, 70)" end="(540, 96)">
              <AtomNode start="(540, 70)" end="(540, 71)" leading="" trailing="" val="("/>
              <NullNode start="(540, 71)" end="(540, 72)">
                <IdentNode start="(540, 71)" end="(540, 72)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(540, 73)" end="(540, 95)">
                <AtomNode start="(540, 73)" end="(540, 74)" leading="" trailing=" " val=":"/>
                <IdentNode start="(540, 75)" end="(540, 95)" leading="" trailing="" raw_val="c.toNormPoly.isValid" val="c.toNormPoly.isValid"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(540, 95)" end="(540, 96)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(540, 97)" end="(540, 118)">
            <AtomNode start="(540, 97)" end="(540, 98)" leading="" trailing=" " val=":"/>
            <OtherNode start="(540, 99)" end="(540, 118)" kind="«term_=_»">
              <OtherNode start="(540, 99)" end="(540, 111)" kind="Lean.Parser.Term.app">
                <IdentNode start="(540, 99)" end="(540, 107)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                <NullNode start="(540, 108)" end="(540, 111)">
                  <IdentNode start="(540, 108)" end="(540, 111)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(540, 112)" end="(540, 113)" leading="" trailing=" " val="="/>
              <IdentNode start="(540, 114)" end="(540, 118)" leading="" trailing=" " raw_val="True" val="True" full_name="True" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(540, 119)" end="(543, 13)">
          <AtomNode start="(540, 119)" end="(540, 121)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(540, 122)" end="(543, 13)">
            <AtomNode start="(540, 122)" end="(540, 124)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(541, 3)" end="(543, 13)">
              <TacticTacticseq1IndentedNode start="(541, 3)" end="(543, 13)">
                <NullNode start="(541, 3)" end="(543, 13)">
                  <OtherNode start="(541, 3)" end="(541, 45)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isValid = true&#10;⊢ denote ctx c = True" state_after="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isValid = true&#10;this : PolyCnstr.denote ctx c.toNormPoly = True&#10;⊢ denote ctx c = True" tactic="have := PolyCnstr.eq_true_of_isValid ctx h">
                    <AtomNode start="(541, 3)" end="(541, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(541, 8)" end="(541, 45)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(541, 8)" end="(541, 45)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(541, 8)" end="(541, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(541, 8)" end="(541, 8)" kind="hygieneInfo">
                            <IdentNode start="(541, 8)" end="(541, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(541, 8)" end="(541, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(541, 11)" end="(541, 45)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(541, 11)" end="(541, 39)" leading="" trailing=" " raw_val="PolyCnstr.eq_true_of_isValid" val="PolyCnstr.eq_true_of_isValid" full_name="Nat.Linear.PolyCnstr.eq_true_of_isValid" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(526, 9)" def_end="(526, 37)"/>
                          <NullNode start="(541, 40)" end="(541, 45)">
                            <IdentNode start="(541, 40)" end="(541, 43)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                            <IdentNode start="(541, 44)" end="(541, 45)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(542, 3)" end="(542, 29)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isValid = true&#10;this : PolyCnstr.denote ctx c.toNormPoly = True&#10;⊢ denote ctx c = True" state_after="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isValid = true&#10;this : denote ctx c = True&#10;⊢ denote ctx c = True" tactic="simp [-eq_iff_iff] at this">
                    <AtomNode start="(542, 3)" end="(542, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(542, 8)" end="(542, 21)">
                      <AtomNode start="(542, 8)" end="(542, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(542, 9)" end="(542, 20)">
                        <OtherNode start="(542, 9)" end="(542, 20)" kind="Lean.Parser.Tactic.simpErase">
                          <AtomNode start="(542, 9)" end="(542, 10)" leading="" trailing="" val="-"/>
                          <IdentNode start="(542, 10)" end="(542, 20)" leading="" trailing="" raw_val="eq_iff_iff" val="eq_iff_iff" full_name="eq_iff_iff" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(542, 20)" end="(542, 21)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(542, 22)" end="(542, 29)">
                      <OtherNode start="(542, 22)" end="(542, 29)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(542, 22)" end="(542, 24)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(542, 25)" end="(542, 29)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(542, 25)" end="(542, 29)">
                            <IdentNode start="(542, 25)" end="(542, 29)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(543, 3)" end="(543, 13)" kind="Lean.Parser.Tactic.assumption" state_before="ctx : Context&#10;c : ExprCnstr&#10;h : c.toNormPoly.isValid = true&#10;this : denote ctx c = True&#10;⊢ denote ctx c = True" state_after="no goals" tactic="assumption">
                    <AtomNode start="(543, 3)" end="(543, 13)" leading="" trailing="&#10;&#10;" val="assumption"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(545, 1)" end="(548, 13)" name="ExprCnstr.eq_of_toNormPoly_eq" full_name="Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(545, 1)" end="(548, 13)" name="ExprCnstr.eq_of_toNormPoly_eq" full_name="Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq" _is_private_decl="False">
        <AtomNode start="(545, 1)" end="(545, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(545, 9)" end="(545, 38)">
          <IdentNode start="(545, 9)" end="(545, 38)" leading="" trailing=" " raw_val="ExprCnstr.eq_of_toNormPoly_eq" val="ExprCnstr.eq_of_toNormPoly_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(545, 39)" end="(545, 133)">
          <NullNode start="(545, 39)" end="(545, 103)">
            <TermExplicitbinderNode start="(545, 39)" end="(545, 54)">
              <AtomNode start="(545, 39)" end="(545, 40)" leading="" trailing="" val="("/>
              <NullNode start="(545, 40)" end="(545, 43)">
                <IdentNode start="(545, 40)" end="(545, 43)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(545, 44)" end="(545, 53)">
                <AtomNode start="(545, 44)" end="(545, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(545, 46)" end="(545, 53)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(545, 53)" end="(545, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(545, 55)" end="(545, 72)">
              <AtomNode start="(545, 55)" end="(545, 56)" leading="" trailing="" val="("/>
              <NullNode start="(545, 56)" end="(545, 59)">
                <IdentNode start="(545, 56)" end="(545, 57)" leading="" trailing=" " raw_val="c" val="c"/>
                <IdentNode start="(545, 58)" end="(545, 59)" leading="" trailing=" " raw_val="d" val="d"/>
              </NullNode>
              <NullNode start="(545, 60)" end="(545, 71)">
                <AtomNode start="(545, 60)" end="(545, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(545, 62)" end="(545, 71)" leading="" trailing="" raw_val="ExprCnstr" val="ExprCnstr" full_name="Nat.Linear.ExprCnstr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(153, 11)" def_end="(153, 20)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(545, 71)" end="(545, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(545, 73)" end="(545, 103)">
              <AtomNode start="(545, 73)" end="(545, 74)" leading="" trailing="" val="("/>
              <NullNode start="(545, 74)" end="(545, 75)">
                <IdentNode start="(545, 74)" end="(545, 75)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(545, 76)" end="(545, 102)">
                <AtomNode start="(545, 76)" end="(545, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(545, 78)" end="(545, 102)" kind="«term_==_»">
                  <IdentNode start="(545, 78)" end="(545, 90)" leading="" trailing=" " raw_val="c.toNormPoly" val="c.toNormPoly"/>
                  <AtomNode start="(545, 91)" end="(545, 93)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(545, 94)" end="(545, 102)" leading="" trailing="" raw_val="d.toPoly" val="d.toPoly"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(545, 102)" end="(545, 103)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(545, 104)" end="(545, 133)">
            <AtomNode start="(545, 104)" end="(545, 105)" leading="" trailing=" " val=":"/>
            <OtherNode start="(545, 106)" end="(545, 133)" kind="«term_=_»">
              <OtherNode start="(545, 106)" end="(545, 118)" kind="Lean.Parser.Term.app">
                <IdentNode start="(545, 106)" end="(545, 114)" leading="" trailing=" " raw_val="c.denote" val="c.denote"/>
                <NullNode start="(545, 115)" end="(545, 118)">
                  <IdentNode start="(545, 115)" end="(545, 118)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(545, 119)" end="(545, 120)" leading="" trailing=" " val="="/>
              <OtherNode start="(545, 121)" end="(545, 133)" kind="Lean.Parser.Term.app">
                <IdentNode start="(545, 121)" end="(545, 129)" leading="" trailing=" " raw_val="d.denote" val="d.denote"/>
                <NullNode start="(545, 130)" end="(545, 133)">
                  <IdentNode start="(545, 130)" end="(545, 133)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(545, 134)" end="(548, 13)">
          <AtomNode start="(545, 134)" end="(545, 136)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(545, 137)" end="(548, 13)">
            <AtomNode start="(545, 137)" end="(545, 139)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(546, 3)" end="(548, 13)">
              <TacticTacticseq1IndentedNode start="(546, 3)" end="(548, 13)">
                <NullNode start="(546, 3)" end="(548, 13)">
                  <OtherNode start="(546, 3)" end="(546, 58)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;c d : ExprCnstr&#10;h : (c.toNormPoly == d.toPoly) = true&#10;⊢ denote ctx c = denote ctx d" state_after="ctx : Context&#10;c d : ExprCnstr&#10;h✝ : (c.toNormPoly == d.toPoly) = true&#10;h : PolyCnstr.denote ctx c.toNormPoly = PolyCnstr.denote ctx d.toPoly&#10;⊢ denote ctx c = denote ctx d" tactic="have h := congrArg (PolyCnstr.denote ctx) (eq_of_beq h)">
                    <AtomNode start="(546, 3)" end="(546, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(546, 8)" end="(546, 58)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(546, 8)" end="(546, 58)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(546, 8)" end="(546, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(546, 8)" end="(546, 9)" leading="" trailing=" " raw_val="h" val="h"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(546, 10)" end="(546, 12)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(546, 13)" end="(546, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(546, 13)" end="(546, 21)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(546, 22)" end="(546, 58)">
                            <OtherNode start="(546, 22)" end="(546, 44)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(546, 22)" end="(546, 23)" leading="" trailing="" val="("/>
                              <OtherNode start="(546, 23)" end="(546, 43)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(546, 23)" end="(546, 39)" leading="" trailing=" " raw_val="PolyCnstr.denote" val="PolyCnstr.denote" full_name="Nat.Linear.PolyCnstr.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(158, 5)" def_end="(158, 21)"/>
                                <NullNode start="(546, 40)" end="(546, 43)">
                                  <IdentNode start="(546, 40)" end="(546, 43)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(546, 43)" end="(546, 44)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(546, 45)" end="(546, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(546, 45)" end="(546, 46)" leading="" trailing="" val="("/>
                              <OtherNode start="(546, 46)" end="(546, 57)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(546, 46)" end="(546, 55)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                <NullNode start="(546, 56)" end="(546, 57)">
                                  <IdentNode start="(546, 56)" end="(546, 57)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(546, 57)" end="(546, 58)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(547, 3)" end="(547, 26)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;c d : ExprCnstr&#10;h✝ : (c.toNormPoly == d.toPoly) = true&#10;h : PolyCnstr.denote ctx c.toNormPoly = PolyCnstr.denote ctx d.toPoly&#10;⊢ denote ctx c = denote ctx d" state_after="ctx : Context&#10;c d : ExprCnstr&#10;h✝ : (c.toNormPoly == d.toPoly) = true&#10;h : denote ctx c = denote ctx d&#10;⊢ denote ctx c = denote ctx d" tactic="simp [-eq_iff_iff] at h">
                    <AtomNode start="(547, 3)" end="(547, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(547, 8)" end="(547, 21)">
                      <AtomNode start="(547, 8)" end="(547, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(547, 9)" end="(547, 20)">
                        <OtherNode start="(547, 9)" end="(547, 20)" kind="Lean.Parser.Tactic.simpErase">
                          <AtomNode start="(547, 9)" end="(547, 10)" leading="" trailing="" val="-"/>
                          <IdentNode start="(547, 10)" end="(547, 20)" leading="" trailing="" raw_val="eq_iff_iff" val="eq_iff_iff" full_name="eq_iff_iff" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(547, 20)" end="(547, 21)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(547, 22)" end="(547, 26)">
                      <OtherNode start="(547, 22)" end="(547, 26)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(547, 22)" end="(547, 24)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(547, 25)" end="(547, 26)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(547, 25)" end="(547, 26)">
                            <IdentNode start="(547, 25)" end="(547, 26)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(548, 3)" end="(548, 13)" kind="Lean.Parser.Tactic.assumption" state_before="ctx : Context&#10;c d : ExprCnstr&#10;h✝ : (c.toNormPoly == d.toPoly) = true&#10;h : denote ctx c = denote ctx d&#10;⊢ denote ctx c = denote ctx d" state_after="no goals" tactic="assumption">
                    <AtomNode start="(548, 3)" end="(548, 13)" leading="" trailing="&#10;&#10;" val="assumption"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(550, 1)" end="(553, 13)" name="Expr.eq_of_toNormPoly_eq" full_name="Nat.Linear.Expr.eq_of_toNormPoly_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(550, 1)" end="(553, 13)" name="Expr.eq_of_toNormPoly_eq" full_name="Nat.Linear.Expr.eq_of_toNormPoly_eq" _is_private_decl="False">
        <AtomNode start="(550, 1)" end="(550, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(550, 9)" end="(550, 33)">
          <IdentNode start="(550, 9)" end="(550, 33)" leading="" trailing=" " raw_val="Expr.eq_of_toNormPoly_eq" val="Expr.eq_of_toNormPoly_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(550, 34)" end="(550, 126)">
          <NullNode start="(550, 34)" end="(550, 95)">
            <TermExplicitbinderNode start="(550, 34)" end="(550, 49)">
              <AtomNode start="(550, 34)" end="(550, 35)" leading="" trailing="" val="("/>
              <NullNode start="(550, 35)" end="(550, 38)">
                <IdentNode start="(550, 35)" end="(550, 38)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
              </NullNode>
              <NullNode start="(550, 39)" end="(550, 48)">
                <AtomNode start="(550, 39)" end="(550, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(550, 41)" end="(550, 48)" leading="" trailing="" raw_val="Context" val="Context" full_name="Nat.Linear.Context" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(21, 8)" def_end="(21, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(550, 48)" end="(550, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(550, 50)" end="(550, 63)">
              <AtomNode start="(550, 50)" end="(550, 51)" leading="" trailing="" val="("/>
              <NullNode start="(550, 51)" end="(550, 55)">
                <IdentNode start="(550, 51)" end="(550, 52)" leading="" trailing=" " raw_val="e" val="e"/>
                <IdentNode start="(550, 53)" end="(550, 55)" leading="" trailing=" " raw_val="e'" val="e'"/>
              </NullNode>
              <NullNode start="(550, 56)" end="(550, 62)">
                <AtomNode start="(550, 56)" end="(550, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(550, 58)" end="(550, 62)" leading="" trailing="" raw_val="Expr" val="Expr" full_name="Nat.Linear.Expr" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(31, 11)" def_end="(31, 15)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(550, 62)" end="(550, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(550, 64)" end="(550, 95)">
              <AtomNode start="(550, 64)" end="(550, 65)" leading="" trailing="" val="("/>
              <NullNode start="(550, 65)" end="(550, 66)">
                <IdentNode start="(550, 65)" end="(550, 66)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(550, 67)" end="(550, 94)">
                <AtomNode start="(550, 67)" end="(550, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(550, 69)" end="(550, 94)" kind="«term_==_»">
                  <IdentNode start="(550, 69)" end="(550, 81)" leading="" trailing=" " raw_val="e.toNormPoly" val="e.toNormPoly"/>
                  <AtomNode start="(550, 82)" end="(550, 84)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(550, 85)" end="(550, 94)" leading="" trailing="" raw_val="e'.toPoly" val="e'.toPoly"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(550, 94)" end="(550, 95)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(550, 96)" end="(550, 126)">
            <AtomNode start="(550, 96)" end="(550, 97)" leading="" trailing=" " val=":"/>
            <OtherNode start="(550, 98)" end="(550, 126)" kind="«term_=_»">
              <OtherNode start="(550, 98)" end="(550, 110)" kind="Lean.Parser.Term.app">
                <IdentNode start="(550, 98)" end="(550, 106)" leading="" trailing=" " raw_val="e.denote" val="e.denote"/>
                <NullNode start="(550, 107)" end="(550, 110)">
                  <IdentNode start="(550, 107)" end="(550, 110)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(550, 111)" end="(550, 112)" leading="" trailing=" " val="="/>
              <OtherNode start="(550, 113)" end="(550, 126)" kind="Lean.Parser.Term.app">
                <IdentNode start="(550, 113)" end="(550, 122)" leading="" trailing=" " raw_val="e'.denote" val="e'.denote"/>
                <NullNode start="(550, 123)" end="(550, 126)">
                  <IdentNode start="(550, 123)" end="(550, 126)" leading="" trailing=" " raw_val="ctx" val="ctx"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(550, 127)" end="(553, 13)">
          <AtomNode start="(550, 127)" end="(550, 129)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(550, 130)" end="(553, 13)">
            <AtomNode start="(550, 130)" end="(550, 132)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(551, 3)" end="(553, 13)">
              <TacticTacticseq1IndentedNode start="(551, 3)" end="(553, 13)">
                <NullNode start="(551, 3)" end="(553, 13)">
                  <OtherNode start="(551, 3)" end="(551, 53)" kind="Lean.Parser.Tactic.tacticHave_" state_before="ctx : Context&#10;e e' : Expr&#10;h : (e.toNormPoly == e'.toPoly) = true&#10;⊢ denote ctx e = denote ctx e'" state_after="ctx : Context&#10;e e' : Expr&#10;h✝ : (e.toNormPoly == e'.toPoly) = true&#10;h : Poly.denote ctx e.toNormPoly = Poly.denote ctx e'.toPoly&#10;⊢ denote ctx e = denote ctx e'" tactic="have h := congrArg (Poly.denote ctx) (eq_of_beq h)">
                    <AtomNode start="(551, 3)" end="(551, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(551, 8)" end="(551, 53)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(551, 8)" end="(551, 53)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(551, 8)" end="(551, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(551, 8)" end="(551, 9)" leading="" trailing=" " raw_val="h" val="h"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(551, 10)" end="(551, 12)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(551, 13)" end="(551, 53)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(551, 13)" end="(551, 21)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(551, 22)" end="(551, 53)">
                            <OtherNode start="(551, 22)" end="(551, 39)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(551, 22)" end="(551, 23)" leading="" trailing="" val="("/>
                              <OtherNode start="(551, 23)" end="(551, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(551, 23)" end="(551, 34)" leading="" trailing=" " raw_val="Poly.denote" val="Poly.denote" full_name="Nat.Linear.Poly.denote" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(48, 5)" def_end="(48, 16)"/>
                                <NullNode start="(551, 35)" end="(551, 38)">
                                  <IdentNode start="(551, 35)" end="(551, 38)" leading="" trailing="" raw_val="ctx" val="ctx"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(551, 38)" end="(551, 39)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(551, 40)" end="(551, 53)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(551, 40)" end="(551, 41)" leading="" trailing="" val="("/>
                              <OtherNode start="(551, 41)" end="(551, 52)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(551, 41)" end="(551, 50)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                <NullNode start="(551, 51)" end="(551, 52)">
                                  <IdentNode start="(551, 51)" end="(551, 52)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(551, 52)" end="(551, 53)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(552, 3)" end="(552, 41)" kind="Lean.Parser.Tactic.simp" state_before="ctx : Context&#10;e e' : Expr&#10;h✝ : (e.toNormPoly == e'.toPoly) = true&#10;h : Poly.denote ctx e.toNormPoly = Poly.denote ctx e'.toPoly&#10;⊢ denote ctx e = denote ctx e'" state_after="ctx : Context&#10;e e' : Expr&#10;h✝ : (e.toNormPoly == e'.toPoly) = true&#10;h : denote ctx e = denote ctx e'&#10;⊢ denote ctx e = denote ctx e'" tactic="simp [Expr.toNormPoly, Poly.norm] at h">
                    <AtomNode start="(552, 3)" end="(552, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(552, 8)" end="(552, 36)">
                      <AtomNode start="(552, 8)" end="(552, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(552, 9)" end="(552, 35)">
                        <OtherNode start="(552, 9)" end="(552, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(552, 9)" end="(552, 24)" leading="" trailing="" raw_val="Expr.toNormPoly" val="Expr.toNormPoly" full_name="Nat.Linear.Expr.toNormPoly" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(127, 5)" def_end="(127, 20)"/>
                        </OtherNode>
                        <AtomNode start="(552, 24)" end="(552, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(552, 26)" end="(552, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(552, 26)" end="(552, 35)" leading="" trailing="" raw_val="Poly.norm" val="Poly.norm" full_name="Nat.Linear.Poly.norm" mod_name="Init.Data.Nat.Linear" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Linear.lean" def_start="(64, 5)" def_end="(64, 14)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(552, 35)" end="(552, 36)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(552, 37)" end="(552, 41)">
                      <OtherNode start="(552, 37)" end="(552, 41)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(552, 37)" end="(552, 39)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(552, 40)" end="(552, 41)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(552, 40)" end="(552, 41)">
                            <IdentNode start="(552, 40)" end="(552, 41)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(553, 3)" end="(553, 13)" kind="Lean.Parser.Tactic.assumption" state_before="ctx : Context&#10;e e' : Expr&#10;h✝ : (e.toNormPoly == e'.toPoly) = true&#10;h : denote ctx e = denote ctx e'&#10;⊢ denote ctx e = denote ctx e'" state_after="no goals" tactic="assumption">
                    <AtomNode start="(553, 3)" end="(553, 13)" leading="" trailing="&#10;&#10;" val="assumption"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(555, 1)" end="(555, 11)" name="Linear">
      <AtomNode start="(555, 1)" end="(555, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(555, 5)" end="(555, 11)">
        <IdentNode start="(555, 5)" end="(555, 11)" leading="" trailing="&#10;&#10;" raw_val="Linear" val="Linear"/>
      </NullNode>
    </CommandEndNode>
    <CommandDeclarationNode start="(557, 1)" end="(558, 31)" name="elimOffset" full_name="elimOffset">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(557, 1)" end="(558, 31)" name="elimOffset">
        <AtomNode start="(557, 1)" end="(557, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(557, 5)" end="(557, 15)">
          <IdentNode start="(557, 5)" end="(557, 15)" leading="" trailing=" " raw_val="elimOffset" val="elimOffset"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(557, 16)" end="(557, 84)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(557, 16)" end="(557, 80)">
            <OtherNode start="(557, 16)" end="(557, 28)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(557, 16)" end="(557, 17)" leading="" trailing="" val="{"/>
              <NullNode start="(557, 17)" end="(557, 18)">
                <IdentNode start="(557, 17)" end="(557, 18)" leading="" trailing=" " raw_val="α" val="α"/>
              </NullNode>
              <NullNode start="(557, 19)" end="(557, 27)">
                <AtomNode start="(557, 19)" end="(557, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(557, 21)" end="(557, 27)" kind="Lean.Parser.Term.sort">
                  <AtomNode start="(557, 21)" end="(557, 25)" leading="" trailing=" " val="Sort"/>
                  <NullNode start="(557, 26)" end="(557, 27)">
                    <IdentNode start="(557, 26)" end="(557, 27)" leading="" trailing="" raw_val="u" val="u"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(557, 27)" end="(557, 28)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(557, 29)" end="(557, 42)">
              <AtomNode start="(557, 29)" end="(557, 30)" leading="" trailing="" val="("/>
              <NullNode start="(557, 30)" end="(557, 35)">
                <IdentNode start="(557, 30)" end="(557, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(557, 32)" end="(557, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(557, 34)" end="(557, 35)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(557, 36)" end="(557, 41)">
                <AtomNode start="(557, 36)" end="(557, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(557, 38)" end="(557, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(557, 41)" end="(557, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(557, 43)" end="(557, 63)">
              <AtomNode start="(557, 43)" end="(557, 44)" leading="" trailing="" val="("/>
              <NullNode start="(557, 44)" end="(557, 46)">
                <IdentNode start="(557, 44)" end="(557, 46)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
              </NullNode>
              <NullNode start="(557, 47)" end="(557, 62)">
                <AtomNode start="(557, 47)" end="(557, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(557, 49)" end="(557, 62)" kind="«term_=_»">
                  <OtherNode start="(557, 49)" end="(557, 54)" kind="«term_+_»">
                    <IdentNode start="(557, 49)" end="(557, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(557, 51)" end="(557, 52)" leading="" trailing=" " val="+"/>
                    <IdentNode start="(557, 53)" end="(557, 54)" leading="" trailing=" " raw_val="k" val="k"/>
                  </OtherNode>
                  <AtomNode start="(557, 55)" end="(557, 56)" leading="" trailing=" " val="="/>
                  <OtherNode start="(557, 57)" end="(557, 62)" kind="«term_+_»">
                    <IdentNode start="(557, 57)" end="(557, 58)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(557, 59)" end="(557, 60)" leading="" trailing=" " val="+"/>
                    <IdentNode start="(557, 61)" end="(557, 62)" leading="" trailing="" raw_val="k" val="k"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(557, 62)" end="(557, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(557, 64)" end="(557, 80)">
              <AtomNode start="(557, 64)" end="(557, 65)" leading="" trailing="" val="("/>
              <NullNode start="(557, 65)" end="(557, 67)">
                <IdentNode start="(557, 65)" end="(557, 67)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
              </NullNode>
              <NullNode start="(557, 68)" end="(557, 79)">
                <AtomNode start="(557, 68)" end="(557, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(557, 70)" end="(557, 79)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(557, 70)" end="(557, 75)" kind="«term_=_»">
                    <IdentNode start="(557, 70)" end="(557, 71)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(557, 72)" end="(557, 73)" leading="" trailing=" " val="="/>
                    <IdentNode start="(557, 74)" end="(557, 75)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                  <AtomNode start="(557, 76)" end="(557, 77)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(557, 78)" end="(557, 79)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(557, 79)" end="(557, 80)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(557, 81)" end="(557, 84)">
            <TermTypespecNode start="(557, 81)" end="(557, 84)">
              <AtomNode start="(557, 81)" end="(557, 82)" leading="" trailing=" " val=":"/>
              <IdentNode start="(557, 83)" end="(557, 84)" leading="" trailing=" " raw_val="α" val="α"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(557, 85)" end="(558, 31)">
          <AtomNode start="(557, 85)" end="(557, 87)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(558, 3)" end="(558, 31)" kind="Lean.Parser.Term.app">
            <IdentNode start="(558, 3)" end="(558, 5)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
            <NullNode start="(558, 6)" end="(558, 31)">
              <OtherNode start="(558, 6)" end="(558, 31)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(558, 6)" end="(558, 7)" leading="" trailing="" val="("/>
                <OtherNode start="(558, 7)" end="(558, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(558, 7)" end="(558, 27)" leading="" trailing=" " raw_val="Nat.add_right_cancel" val="Nat.add_right_cancel" full_name="Nat.add_right_cancel" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                  <NullNode start="(558, 28)" end="(558, 30)">
                    <IdentNode start="(558, 28)" end="(558, 30)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(558, 30)" end="(558, 31)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(560, 1)" end="(560, 8)" name="Nat">
      <AtomNode start="(560, 1)" end="(560, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(560, 5)" end="(560, 8)">
        <IdentNode start="(560, 5)" end="(560, 8)" leading="" trailing="&#10;" raw_val="Nat" val="Nat"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(15, 1)" end="(17, 3)" text="Helper definitions and theorems for constructing linear arithmetic proofs.&#10;-/"/>
    <Comment start="(23, 1)" end="(25, 49)" text="When encoding polynomials. We use `fixedVar` for encoding numerals.&#10;  The denotation of `fixedVar` is always `1`. -/"/>
    <Comment start="(26, 27)" end="(28, 1)" text="-- Any big number should work here&#10;&#10;"/>
    <Comment start="(90, 25)" end="(92, 1)" text="-- any big number should work&#10;&#10;"/>
    <Comment start="(118, 3)" end="(120, 3)" text="-- Implementation note: This assembles the result using difference lists&#10;  -- to avoid `++` on lists.&#10;  "/>
    <Comment start="(139, 1)" end="(140, 1)" text="-- TODO: implement LawfulBEq generator companion for BEq&#10;"/>
  </Comments>
</TracedFile>
