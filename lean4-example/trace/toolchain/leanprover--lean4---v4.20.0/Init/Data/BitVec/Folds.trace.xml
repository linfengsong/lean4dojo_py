<TracedFile path="src/lean/Init/Data/BitVec/Folds.lean" md5="604bd2edabfbcde1eec16c1579650990">
  <FileNode start="(1, 1)" end="(125, 11)">
    <ModuleHeaderNode start="(6, 1)" end="(11, 29)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(11, 29)">
        <ModuleImportNode start="(9, 1)" end="(9, 31)" module="Init.Data.BitVec.Lemmas" path="src/lean/Init/Data/BitVec/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 31)" leading="" trailing="&#10;" raw_val="Init.Data.BitVec.Lemmas" val="Init.Data.BitVec.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 28)" module="Init.Data.Nat.Lemmas" path="src/lean/Init/Data/Nat/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 28)" leading="" trailing="&#10;" raw_val="Init.Data.Nat.Lemmas" val="Init.Data.Nat.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 29)" module="Init.Data.Fin.Iterate" path="src/lean/Init/Data/Fin/Iterate.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 29)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Fin.Iterate" val="Init.Data.Fin.Iterate"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(13, 1)" end="(13, 35)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(13, 1)" end="(13, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(13, 12)" end="(13, 30)" leading="" trailing=" " raw_val="linter.missingDocs" val="linter.missingDocs"/>
      <NullNode/>
      <AtomNode start="(13, 31)" end="(13, 35)" leading="" trailing="&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(15, 1)" end="(15, 17)" name="BitVec">
      <AtomNode start="(15, 1)" end="(15, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(15, 11)" end="(15, 17)" leading="" trailing="&#10;&#10;" raw_val="BitVec" val="BitVec"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(17, 1)" end="(31, 53)" name="iunfoldr" full_name="BitVec.iunfoldr">
      <CommandDeclmodifiersNode start="(17, 1)" end="(28, 3)">
        <NullNode start="(17, 1)" end="(28, 3)">
          <CommandDoccommentNode start="(17, 1)" end="(28, 3)" comment="Constructs a bitvector by iteratively computing a state for each bit using the function `f`,&#10;starting with the initial state `s`. At each step, the prior state and the current bit index are&#10;passed to `f`, and it produces a bit along with the next state value. These bits are assembled into&#10;the final bitvector.&#10;&#10;It produces a sequence of state values `[s_0, s_1 .. s_w]` and a bitvector `v` where `f i s_i =&#10;(s_{i+1}, b_i)` and `b_i` is bit `i`th least-significant bit in `v` (e.g., `getLsb v i = b_i`).&#10;&#10;The theorem `iunfoldr_replace` allows uses of `BitVec.iunfoldr` to be replaced wiht declarative&#10;specifications that are easier to reason about.&#10;-/">
            <AtomNode start="(17, 1)" end="(17, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(18, 1)" end="(28, 3)" leading="" trailing="&#10;" val="Constructs a bitvector by iteratively computing a state for each bit using the function `f`,&#10;starting with the initial state `s`. At each step, the prior state and the current bit index are&#10;passed to `f`, and it produces a bit along with the next state value. These bits are assembled into&#10;the final bitvector.&#10;&#10;It produces a sequence of state values `[s_0, s_1 .. s_w]` and a bitvector `v` where `f i s_i =&#10;(s_{i+1}, b_i)` and `b_i` is bit `i`th least-significant bit in `v` (e.g., `getLsb v i = b_i`).&#10;&#10;The theorem `iunfoldr_replace` allows uses of `BitVec.iunfoldr` to be replaced wiht declarative&#10;specifications that are easier to reason about.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(29, 1)" end="(31, 53)" name="iunfoldr">
        <AtomNode start="(29, 1)" end="(29, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(29, 5)" end="(29, 13)">
          <IdentNode start="(29, 5)" end="(29, 13)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(29, 14)" end="(29, 63)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(29, 14)" end="(29, 48)">
            <TermExplicitbinderNode start="(29, 14)" end="(29, 40)">
              <AtomNode start="(29, 14)" end="(29, 15)" leading="" trailing="" val="("/>
              <NullNode start="(29, 15)" end="(29, 16)">
                <IdentNode start="(29, 15)" end="(29, 16)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(29, 17)" end="(29, 39)">
                <AtomNode start="(29, 17)" end="(29, 18)" leading="" trailing=" " val=":"/>
                <OtherNode start="(29, 19)" end="(29, 39)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(29, 19)" end="(29, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(29, 19)" end="(29, 22)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(29, 23)" end="(29, 24)">
                      <IdentNode start="(29, 23)" end="(29, 24)" leading="" trailing=" " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(29, 25)" end="(29, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(29, 27)" end="(29, 39)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(29, 27)" end="(29, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(29, 29)" end="(29, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(29, 31)" end="(29, 39)" kind="«term_×_»">
                      <IdentNode start="(29, 31)" end="(29, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(29, 33)" end="(29, 34)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(29, 35)" end="(29, 39)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(29, 39)" end="(29, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(29, 41)" end="(29, 48)">
              <AtomNode start="(29, 41)" end="(29, 42)" leading="" trailing="" val="("/>
              <NullNode start="(29, 42)" end="(29, 43)">
                <IdentNode start="(29, 42)" end="(29, 43)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(29, 44)" end="(29, 47)">
                <AtomNode start="(29, 44)" end="(29, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(29, 46)" end="(29, 47)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(29, 47)" end="(29, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(29, 49)" end="(29, 63)">
            <TermTypespecNode start="(29, 49)" end="(29, 63)">
              <AtomNode start="(29, 49)" end="(29, 50)" leading="" trailing=" " val=":"/>
              <OtherNode start="(29, 51)" end="(29, 63)" kind="«term_×_»">
                <IdentNode start="(29, 51)" end="(29, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                <AtomNode start="(29, 53)" end="(29, 54)" leading="" trailing=" " val="×"/>
                <OtherNode start="(29, 55)" end="(29, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(29, 55)" end="(29, 61)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(29, 62)" end="(29, 63)">
                    <IdentNode start="(29, 62)" end="(29, 63)" leading="" trailing=" " raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(29, 64)" end="(31, 53)">
          <AtomNode start="(29, 64)" end="(29, 66)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(30, 3)" end="(31, 53)" kind="Lean.Parser.Term.app">
            <IdentNode start="(30, 3)" end="(30, 15)" leading="" trailing=" " raw_val="Fin.hIterate" val="Fin.hIterate" full_name="Fin.hIterate" mod_name="Init.Data.Fin.Iterate" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Iterate.lean"/>
            <NullNode start="(30, 16)" end="(31, 53)">
              <OtherNode start="(30, 16)" end="(30, 39)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(30, 16)" end="(30, 17)" leading="" trailing="" val="("/>
                <OtherNode start="(30, 17)" end="(30, 38)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(30, 17)" end="(30, 20)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(30, 21)" end="(30, 38)" kind="Lean.Parser.Term.basicFun">
                    <NullNode start="(30, 21)" end="(30, 22)">
                      <IdentNode start="(30, 21)" end="(30, 22)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(30, 23)" end="(30, 25)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(30, 26)" end="(30, 38)" kind="«term_×_»">
                      <IdentNode start="(30, 26)" end="(30, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(30, 28)" end="(30, 29)" leading="" trailing=" " val="×"/>
                      <OtherNode start="(30, 30)" end="(30, 38)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(30, 30)" end="(30, 36)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(30, 37)" end="(30, 38)">
                          <IdentNode start="(30, 37)" end="(30, 38)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(30, 38)" end="(30, 39)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <OtherNode start="(30, 40)" end="(30, 48)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(30, 40)" end="(30, 41)" leading="" trailing="" val="("/>
                <NullNode start="(30, 41)" end="(30, 47)">
                  <IdentNode start="(30, 41)" end="(30, 42)" leading="" trailing="" raw_val="s" val="s"/>
                  <AtomNode start="(30, 42)" end="(30, 43)" leading="" trailing=" " val=","/>
                  <NullNode start="(30, 44)" end="(30, 47)">
                    <IdentNode start="(30, 44)" end="(30, 47)" leading="" trailing="" raw_val="nil" val="nil" full_name="BitVec.nil" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                  </NullNode>
                </NullNode>
                <AtomNode start="(30, 47)" end="(30, 48)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <OtherNode start="(30, 49)" end="(31, 53)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(30, 49)" end="(30, 52)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(30, 53)" end="(31, 53)" kind="Lean.Parser.Term.basicFun">
                  <NullNode start="(30, 53)" end="(30, 56)">
                    <IdentNode start="(30, 53)" end="(30, 54)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(30, 55)" end="(30, 56)" leading="" trailing=" " raw_val="q" val="q"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(30, 57)" end="(30, 59)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(31, 5)" end="(31, 53)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(31, 5)" end="(31, 41)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(31, 5)" end="(31, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(31, 6)" end="(31, 40)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(31, 6)" end="(31, 9)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(31, 10)" end="(31, 40)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(31, 10)" end="(31, 11)">
                            <IdentNode start="(31, 10)" end="(31, 11)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(31, 12)" end="(31, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(31, 15)" end="(31, 40)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(31, 15)" end="(31, 16)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(31, 16)" end="(31, 39)">
                              <IdentNode start="(31, 16)" end="(31, 21)" leading="" trailing="" raw_val="p.fst" val="p.fst"/>
                              <AtomNode start="(31, 21)" end="(31, 22)" leading="" trailing=" " val=","/>
                              <OtherNode start="(31, 23)" end="(31, 39)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(31, 23)" end="(31, 27)" leading="" trailing=" " raw_val="cons" val="cons" full_name="BitVec.cons" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                                <NullNode start="(31, 28)" end="(31, 39)">
                                  <IdentNode start="(31, 28)" end="(31, 33)" leading="" trailing=" " raw_val="p.snd" val="p.snd"/>
                                  <IdentNode start="(31, 34)" end="(31, 39)" leading="" trailing="" raw_val="q.snd" val="q.snd"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(31, 39)" end="(31, 40)" leading="" trailing="" val="⟩"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(31, 40)" end="(31, 41)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <NullNode start="(31, 42)" end="(31, 53)">
                      <OtherNode start="(31, 42)" end="(31, 53)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(31, 42)" end="(31, 43)" leading="" trailing="" val="("/>
                        <OtherNode start="(31, 43)" end="(31, 52)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(31, 43)" end="(31, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(31, 45)" end="(31, 52)">
                            <IdentNode start="(31, 45)" end="(31, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(31, 47)" end="(31, 52)" leading="" trailing="" raw_val="q.fst" val="q.fst"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(31, 52)" end="(31, 53)" leading="" trailing="&#10;&#10;" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(44, 21)" name="iunfoldr.fst_eq" full_name="BitVec.iunfoldr.fst_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(33, 1)" end="(44, 21)" name="iunfoldr.fst_eq" full_name="BitVec.iunfoldr.fst_eq" _is_private_decl="False">
        <AtomNode start="(33, 1)" end="(33, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(33, 9)" end="(33, 24)">
          <IdentNode start="(33, 9)" end="(33, 24)" leading="" trailing="&#10;    " raw_val="iunfoldr.fst_eq" val="iunfoldr.fst_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(34, 5)" end="(37, 33)">
          <NullNode start="(34, 5)" end="(36, 68)">
            <OtherNode start="(34, 5)" end="(34, 31)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 5)" end="(34, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 6)" end="(34, 7)">
                <IdentNode start="(34, 6)" end="(34, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(34, 8)" end="(34, 30)">
                <AtomNode start="(34, 8)" end="(34, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 10)" end="(34, 30)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(34, 10)" end="(34, 15)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(34, 10)" end="(34, 13)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(34, 14)" end="(34, 15)">
                      <IdentNode start="(34, 14)" end="(34, 15)" leading="" trailing=" " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(34, 16)" end="(34, 17)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(34, 18)" end="(34, 30)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(34, 18)" end="(34, 19)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(34, 20)" end="(34, 21)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(34, 22)" end="(34, 30)" kind="«term_×_»">
                      <IdentNode start="(34, 22)" end="(34, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(34, 24)" end="(34, 25)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(34, 26)" end="(34, 30)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(34, 30)" end="(34, 31)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(34, 32)" end="(34, 49)">
              <AtomNode start="(34, 32)" end="(34, 33)" leading="" trailing="" val="("/>
              <NullNode start="(34, 33)" end="(34, 38)">
                <IdentNode start="(34, 33)" end="(34, 38)" leading="" trailing=" " raw_val="state" val="state"/>
              </NullNode>
              <NullNode start="(34, 39)" end="(34, 48)">
                <AtomNode start="(34, 39)" end="(34, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 41)" end="(34, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(34, 41)" end="(34, 44)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(34, 45)" end="(34, 46)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(34, 47)" end="(34, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(34, 48)" end="(34, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(34, 50)" end="(34, 57)">
              <AtomNode start="(34, 50)" end="(34, 51)" leading="" trailing="" val="("/>
              <NullNode start="(34, 51)" end="(34, 52)">
                <IdentNode start="(34, 51)" end="(34, 52)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(34, 53)" end="(34, 56)">
                <AtomNode start="(34, 53)" end="(34, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(34, 55)" end="(34, 56)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(34, 56)" end="(34, 57)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(35, 5)" end="(35, 25)">
              <AtomNode start="(35, 5)" end="(35, 6)" leading="" trailing="" val="("/>
              <NullNode start="(35, 6)" end="(35, 10)">
                <IdentNode start="(35, 6)" end="(35, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(35, 11)" end="(35, 24)">
                <AtomNode start="(35, 11)" end="(35, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 13)" end="(35, 24)" kind="«term_=_»">
                  <IdentNode start="(35, 13)" end="(35, 14)" leading="" trailing=" " raw_val="s" val="s"/>
                  <AtomNode start="(35, 15)" end="(35, 16)" leading="" trailing=" " val="="/>
                  <OtherNode start="(35, 17)" end="(35, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(35, 17)" end="(35, 22)" leading="" trailing=" " raw_val="state" val="state"/>
                    <NullNode start="(35, 23)" end="(35, 24)">
                      <OtherNode start="(35, 23)" end="(35, 24)" kind="num">
                        <AtomNode start="(35, 23)" end="(35, 24)" leading="" trailing="" val="0"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(35, 24)" end="(35, 25)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(36, 5)" end="(36, 68)">
              <AtomNode start="(36, 5)" end="(36, 6)" leading="" trailing="" val="("/>
              <NullNode start="(36, 6)" end="(36, 9)">
                <IdentNode start="(36, 6)" end="(36, 9)" leading="" trailing=" " raw_val="ind" val="ind"/>
              </NullNode>
              <NullNode start="(36, 10)" end="(36, 67)">
                <AtomNode start="(36, 10)" end="(36, 11)" leading="" trailing=" " val=":"/>
                <OtherNode start="(36, 12)" end="(36, 67)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(36, 12)" end="(36, 13)" leading="" trailing="" val="∀"/>
                  <NullNode start="(36, 13)" end="(36, 24)">
                    <TermExplicitbinderNode start="(36, 13)" end="(36, 24)">
                      <AtomNode start="(36, 13)" end="(36, 14)" leading="" trailing="" val="("/>
                      <NullNode start="(36, 14)" end="(36, 15)">
                        <IdentNode start="(36, 14)" end="(36, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(36, 16)" end="(36, 23)">
                        <AtomNode start="(36, 16)" end="(36, 17)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(36, 18)" end="(36, 23)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(36, 18)" end="(36, 21)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(36, 22)" end="(36, 23)">
                            <IdentNode start="(36, 22)" end="(36, 23)" leading="" trailing="" raw_val="w" val="w"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(36, 23)" end="(36, 24)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(36, 24)" end="(36, 25)" leading="" trailing=" " val=","/>
                  <OtherNode start="(36, 26)" end="(36, 67)" kind="«term_=_»">
                    <OtherNode start="(36, 26)" end="(36, 49)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(36, 26)" end="(36, 45)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(36, 26)" end="(36, 27)" leading="" trailing="" val="("/>
                        <OtherNode start="(36, 27)" end="(36, 44)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(36, 27)" end="(36, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(36, 29)" end="(36, 44)">
                            <IdentNode start="(36, 29)" end="(36, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                            <OtherNode start="(36, 31)" end="(36, 44)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(36, 31)" end="(36, 32)" leading="" trailing="" val="("/>
                              <OtherNode start="(36, 32)" end="(36, 43)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(36, 32)" end="(36, 37)" leading="" trailing=" " raw_val="state" val="state"/>
                                <NullNode start="(36, 38)" end="(36, 43)">
                                  <IdentNode start="(36, 38)" end="(36, 43)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(36, 43)" end="(36, 44)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(36, 44)" end="(36, 45)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(36, 45)" end="(36, 46)" leading="" trailing="" val="."/>
                      <IdentNode start="(36, 46)" end="(36, 49)" leading="" trailing=" " raw_val="fst" val="fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(36, 50)" end="(36, 51)" leading="" trailing=" " val="="/>
                    <OtherNode start="(36, 52)" end="(36, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(36, 52)" end="(36, 57)" leading="" trailing=" " raw_val="state" val="state"/>
                      <NullNode start="(36, 58)" end="(36, 67)">
                        <OtherNode start="(36, 58)" end="(36, 67)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(36, 58)" end="(36, 59)" leading="" trailing="" val="("/>
                          <OtherNode start="(36, 59)" end="(36, 66)" kind="«term_+_»">
                            <IdentNode start="(36, 59)" end="(36, 64)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            <AtomNode start="(36, 64)" end="(36, 65)" leading="" trailing="" val="+"/>
                            <OtherNode start="(36, 65)" end="(36, 66)" kind="num">
                              <AtomNode start="(36, 65)" end="(36, 66)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(36, 66)" end="(36, 67)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(36, 67)" end="(36, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(36, 69)" end="(37, 33)">
            <AtomNode start="(36, 69)" end="(36, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(37, 5)" end="(37, 33)" kind="«term_=_»">
              <OtherNode start="(37, 5)" end="(37, 23)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(37, 5)" end="(37, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(37, 5)" end="(37, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(37, 6)" end="(37, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(37, 6)" end="(37, 14)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                    <NullNode start="(37, 15)" end="(37, 18)">
                      <IdentNode start="(37, 15)" end="(37, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(37, 17)" end="(37, 18)" leading="" trailing="" raw_val="s" val="s"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(37, 18)" end="(37, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(37, 19)" end="(37, 20)" leading="" trailing="" val="."/>
                <IdentNode start="(37, 20)" end="(37, 23)" leading="" trailing=" " raw_val="fst" val="fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(37, 24)" end="(37, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(37, 26)" end="(37, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(37, 26)" end="(37, 31)" leading="" trailing=" " raw_val="state" val="state"/>
                <NullNode start="(37, 32)" end="(37, 33)">
                  <IdentNode start="(37, 32)" end="(37, 33)" leading="" trailing=" " raw_val="w" val="w"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(37, 34)" end="(44, 21)">
          <AtomNode start="(37, 34)" end="(37, 36)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(37, 37)" end="(44, 21)">
            <AtomNode start="(37, 37)" end="(37, 39)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(38, 3)" end="(44, 21)">
              <TacticTacticseq1IndentedNode start="(38, 3)" end="(44, 21)">
                <NullNode start="(38, 3)" end="(44, 21)">
                  <OtherNode start="(38, 3)" end="(38, 18)" kind="Lean.Parser.Tactic.unfold" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (iunfoldr f s).fst = state w" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (s, nil) fun i q =&amp;gt; (fun p =&amp;gt; (p.fst, cons p.snd q.snd)) (f i q.fst)).fst =&#10;    state w" tactic="unfold iunfoldr">
                    <AtomNode start="(38, 3)" end="(38, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(38, 10)" end="(38, 18)">
                      <IdentNode start="(38, 10)" end="(38, 18)" leading="" trailing="&#10;  " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(39, 3)" end="(39, 72)" kind="Lean.Parser.Tactic.apply" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (s, nil) fun i q =&amp;gt; (fun p =&amp;gt; (p.fst, cons p.snd q.snd)) (f i q.fst)).fst =&#10;    state w" state_after="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (s, nil).fst = state 0&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    s.fst = state ↑k → ((fun p =&amp;gt; (p.fst, cons p.snd s.snd)) (f k s.fst)).fst = state (↑k + 1)" tactic="apply Fin.hIterate_elim (fun i (p : α × BitVec i) =&amp;gt; p.fst = state i)">
                    <AtomNode start="(39, 3)" end="(39, 8)" leading="" trailing=" " val="apply"/>
                    <OtherNode start="(39, 9)" end="(39, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(39, 9)" end="(39, 26)" leading="" trailing=" " raw_val="Fin.hIterate_elim" val="Fin.hIterate_elim" full_name="Fin.hIterate_elim" mod_name="Init.Data.Fin.Iterate" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Iterate.lean"/>
                      <NullNode start="(39, 27)" end="(39, 72)">
                        <OtherNode start="(39, 27)" end="(39, 72)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(39, 27)" end="(39, 28)" leading="" trailing="" val="("/>
                          <OtherNode start="(39, 28)" end="(39, 71)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(39, 28)" end="(39, 31)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(39, 32)" end="(39, 71)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(39, 32)" end="(39, 52)">
                                <IdentNode start="(39, 32)" end="(39, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                                <OtherNode start="(39, 34)" end="(39, 52)" kind="Lean.Parser.Term.typeAscription">
                                  <AtomNode start="(39, 34)" end="(39, 35)" leading="" trailing="" val="("/>
                                  <IdentNode start="(39, 35)" end="(39, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <AtomNode start="(39, 37)" end="(39, 38)" leading="" trailing=" " val=":"/>
                                  <NullNode start="(39, 39)" end="(39, 51)">
                                    <OtherNode start="(39, 39)" end="(39, 51)" kind="«term_×_»">
                                      <IdentNode start="(39, 39)" end="(39, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                                      <AtomNode start="(39, 41)" end="(39, 42)" leading="" trailing=" " val="×"/>
                                      <OtherNode start="(39, 43)" end="(39, 51)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(39, 43)" end="(39, 49)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <NullNode start="(39, 50)" end="(39, 51)">
                                          <IdentNode start="(39, 50)" end="(39, 51)" leading="" trailing="" raw_val="i" val="i"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(39, 51)" end="(39, 52)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(39, 53)" end="(39, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(39, 56)" end="(39, 71)" kind="«term_=_»">
                                <IdentNode start="(39, 56)" end="(39, 61)" leading="" trailing=" " raw_val="p.fst" val="p.fst"/>
                                <AtomNode start="(39, 62)" end="(39, 63)" leading="" trailing=" " val="="/>
                                <OtherNode start="(39, 64)" end="(39, 71)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(39, 64)" end="(39, 69)" leading="" trailing=" " raw_val="state" val="state"/>
                                  <NullNode start="(39, 70)" end="(39, 71)">
                                    <IdentNode start="(39, 70)" end="(39, 71)" leading="" trailing="" raw_val="i" val="i"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(39, 71)" end="(39, 72)" leading="" trailing="&#10;  " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(40, 3)" end="(41, 15)" kind="Lean.Parser.Tactic.case" state_before="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (s, nil).fst = state 0&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    s.fst = state ↑k → ((fun p =&amp;gt; (p.fst, cons p.snd s.snd)) (f k s.fst)).fst = state (↑k + 1)" state_after="case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    s.fst = state ↑k → ((fun p =&amp;gt; (p.fst, cons p.snd s.snd)) (f k s.fst)).fst = state (↑k + 1)" tactic="case init =&amp;gt;&#10;  exact init">
                    <AtomNode start="(40, 3)" end="(40, 7)" leading="" trailing=" " val="case"/>
                    <NullNode start="(40, 8)" end="(40, 12)">
                      <OtherNode start="(40, 8)" end="(40, 12)" kind="Lean.Parser.Tactic.caseArg">
                        <LeanBinderidentNode start="(40, 8)" end="(40, 12)">
                          <IdentNode start="(40, 8)" end="(40, 12)" leading="" trailing=" " raw_val="init" val="init"/>
                        </LeanBinderidentNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(40, 13)" end="(40, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                    <TacticTacticseqNode start="(41, 5)" end="(41, 15)">
                      <TacticTacticseq1IndentedNode start="(41, 5)" end="(41, 15)">
                        <NullNode start="(41, 5)" end="(41, 15)">
                          <OtherNode start="(41, 5)" end="(41, 15)" kind="Lean.Parser.Tactic.exact" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (s, nil).fst = state 0" state_after="no goals" tactic="exact init">
                            <AtomNode start="(41, 5)" end="(41, 10)" leading="" trailing=" " val="exact"/>
                            <IdentNode start="(41, 11)" end="(41, 15)" leading="" trailing="&#10;  " raw_val="init" val="init"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(42, 3)" end="(44, 21)" kind="Lean.Parser.Tactic.case" state_before="case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    s.fst = state ↑k → ((fun p =&amp;gt; (p.fst, cons p.snd s.snd)) (f k s.fst)).fst = state (↑k + 1)" state_after="no goals" tactic="case step =&amp;gt;&#10;  intro i ⟨s, v⟩ p&#10;  simp_all [ind i]">
                    <AtomNode start="(42, 3)" end="(42, 7)" leading="" trailing=" " val="case"/>
                    <NullNode start="(42, 8)" end="(42, 12)">
                      <OtherNode start="(42, 8)" end="(42, 12)" kind="Lean.Parser.Tactic.caseArg">
                        <LeanBinderidentNode start="(42, 8)" end="(42, 12)">
                          <IdentNode start="(42, 8)" end="(42, 12)" leading="" trailing=" " raw_val="step" val="step"/>
                        </LeanBinderidentNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(42, 13)" end="(42, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                    <TacticTacticseqNode start="(43, 5)" end="(44, 21)">
                      <TacticTacticseq1IndentedNode start="(43, 5)" end="(44, 21)">
                        <NullNode start="(43, 5)" end="(44, 21)">
                          <OtherNode start="(43, 5)" end="(43, 21)" kind="Lean.Parser.Tactic.intro" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s : α&#10;init : s = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    s.fst = state ↑k → ((fun p =&amp;gt; (p.fst, cons p.snd s.snd)) (f k s.fst)).fst = state (↑k + 1)" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s✝ : α&#10;init : s✝ = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;i : Fin w&#10;s : α&#10;v : BitVec ↑i&#10;p : (s, v).fst = state ↑i&#10;⊢ ((fun p =&amp;gt; (p.fst, cons p.snd (s, v).snd)) (f i (s, v).fst)).fst = state (↑i + 1)" tactic="intro i ⟨s, v⟩ p">
                            <AtomNode start="(43, 5)" end="(43, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(43, 11)" end="(43, 21)">
                              <IdentNode start="(43, 11)" end="(43, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                              <OtherNode start="(43, 13)" end="(43, 19)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(43, 13)" end="(43, 14)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(43, 14)" end="(43, 18)">
                                  <IdentNode start="(43, 14)" end="(43, 15)" leading="" trailing="" raw_val="s" val="s"/>
                                  <AtomNode start="(43, 15)" end="(43, 16)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(43, 17)" end="(43, 18)" leading="" trailing="" raw_val="v" val="v"/>
                                </NullNode>
                                <AtomNode start="(43, 18)" end="(43, 19)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                              <IdentNode start="(43, 20)" end="(43, 21)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(44, 5)" end="(44, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;s✝ : α&#10;init : s✝ = state 0&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;i : Fin w&#10;s : α&#10;v : BitVec ↑i&#10;p : (s, v).fst = state ↑i&#10;⊢ ((fun p =&amp;gt; (p.fst, cons p.snd (s, v).snd)) (f i (s, v).fst)).fst = state (↑i + 1)" state_after="no goals" tactic="simp_all [ind i]">
                            <AtomNode start="(44, 5)" end="(44, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(44, 14)" end="(44, 21)">
                              <AtomNode start="(44, 14)" end="(44, 15)" leading="" trailing="" val="["/>
                              <NullNode start="(44, 15)" end="(44, 20)">
                                <OtherNode start="(44, 15)" end="(44, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(44, 15)" end="(44, 20)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(44, 15)" end="(44, 18)" leading="" trailing=" " raw_val="ind" val="ind"/>
                                    <NullNode start="(44, 19)" end="(44, 20)">
                                      <IdentNode start="(44, 19)" end="(44, 20)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(44, 20)" end="(44, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(46, 1)" end="(56, 29)" name="iunfoldr.eq_test" full_name="BitVec.iunfoldr.eq_test">
      <CommandDeclmodifiersNode start="(46, 1)" end="(46, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(46, 1)" end="(46, 8)">
          <CommandPrivateNode start="(46, 1)" end="(46, 8)">
            <AtomNode start="(46, 1)" end="(46, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(46, 9)" end="(56, 29)" name="iunfoldr.eq_test" full_name="BitVec.iunfoldr.eq_test" _is_private_decl="True">
        <AtomNode start="(46, 9)" end="(46, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(46, 17)" end="(46, 33)">
          <IdentNode start="(46, 17)" end="(46, 33)" leading="" trailing="&#10;    " raw_val="iunfoldr.eq_test" val="iunfoldr.eq_test"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(47, 5)" end="(50, 54)">
          <NullNode start="(47, 5)" end="(49, 86)">
            <OtherNode start="(47, 5)" end="(47, 31)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(47, 5)" end="(47, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(47, 6)" end="(47, 7)">
                <IdentNode start="(47, 6)" end="(47, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(47, 8)" end="(47, 30)">
                <AtomNode start="(47, 8)" end="(47, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 10)" end="(47, 30)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(47, 10)" end="(47, 15)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(47, 10)" end="(47, 13)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(47, 14)" end="(47, 15)">
                      <IdentNode start="(47, 14)" end="(47, 15)" leading="" trailing=" " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(47, 16)" end="(47, 17)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(47, 18)" end="(47, 30)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(47, 18)" end="(47, 19)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(47, 20)" end="(47, 21)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(47, 22)" end="(47, 30)" kind="«term_×_»">
                      <IdentNode start="(47, 22)" end="(47, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(47, 24)" end="(47, 25)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(47, 26)" end="(47, 30)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(47, 30)" end="(47, 31)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(47, 32)" end="(47, 49)">
              <AtomNode start="(47, 32)" end="(47, 33)" leading="" trailing="" val="("/>
              <NullNode start="(47, 33)" end="(47, 38)">
                <IdentNode start="(47, 33)" end="(47, 38)" leading="" trailing=" " raw_val="state" val="state"/>
              </NullNode>
              <NullNode start="(47, 39)" end="(47, 48)">
                <AtomNode start="(47, 39)" end="(47, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 41)" end="(47, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(47, 41)" end="(47, 44)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(47, 45)" end="(47, 46)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(47, 47)" end="(47, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(47, 48)" end="(47, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(47, 50)" end="(47, 68)">
              <AtomNode start="(47, 50)" end="(47, 51)" leading="" trailing="" val="("/>
              <NullNode start="(47, 51)" end="(47, 56)">
                <IdentNode start="(47, 51)" end="(47, 56)" leading="" trailing=" " raw_val="value" val="value"/>
              </NullNode>
              <NullNode start="(47, 57)" end="(47, 67)">
                <AtomNode start="(47, 57)" end="(47, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 59)" end="(47, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(47, 59)" end="(47, 65)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(47, 66)" end="(47, 67)">
                    <IdentNode start="(47, 66)" end="(47, 67)" leading="" trailing="" raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(47, 67)" end="(47, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(47, 69)" end="(47, 76)">
              <AtomNode start="(47, 69)" end="(47, 70)" leading="" trailing="" val="("/>
              <NullNode start="(47, 70)" end="(47, 71)">
                <IdentNode start="(47, 70)" end="(47, 71)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(47, 72)" end="(47, 75)">
                <AtomNode start="(47, 72)" end="(47, 73)" leading="" trailing=" " val=":"/>
                <IdentNode start="(47, 74)" end="(47, 75)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(47, 75)" end="(47, 76)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(48, 5)" end="(48, 25)">
              <AtomNode start="(48, 5)" end="(48, 6)" leading="" trailing="" val="("/>
              <NullNode start="(48, 6)" end="(48, 10)">
                <IdentNode start="(48, 6)" end="(48, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(48, 11)" end="(48, 24)">
                <AtomNode start="(48, 11)" end="(48, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(48, 13)" end="(48, 24)" kind="«term_=_»">
                  <OtherNode start="(48, 13)" end="(48, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(48, 13)" end="(48, 18)" leading="" trailing=" " raw_val="state" val="state"/>
                    <NullNode start="(48, 19)" end="(48, 20)">
                      <OtherNode start="(48, 19)" end="(48, 20)" kind="num">
                        <AtomNode start="(48, 19)" end="(48, 20)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(48, 21)" end="(48, 22)" leading="" trailing=" " val="="/>
                  <IdentNode start="(48, 23)" end="(48, 24)" leading="" trailing="" raw_val="a" val="a"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(48, 24)" end="(48, 25)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(49, 5)" end="(49, 86)">
              <AtomNode start="(49, 5)" end="(49, 6)" leading="" trailing="" val="("/>
              <NullNode start="(49, 6)" end="(49, 10)">
                <IdentNode start="(49, 6)" end="(49, 10)" leading="" trailing=" " raw_val="step" val="step"/>
              </NullNode>
              <NullNode start="(49, 11)" end="(49, 85)">
                <AtomNode start="(49, 11)" end="(49, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(49, 13)" end="(49, 85)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(49, 13)" end="(49, 14)" leading="" trailing="" val="∀"/>
                  <NullNode start="(49, 14)" end="(49, 25)">
                    <TermExplicitbinderNode start="(49, 14)" end="(49, 25)">
                      <AtomNode start="(49, 14)" end="(49, 15)" leading="" trailing="" val="("/>
                      <NullNode start="(49, 15)" end="(49, 16)">
                        <IdentNode start="(49, 15)" end="(49, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(49, 17)" end="(49, 24)">
                        <AtomNode start="(49, 17)" end="(49, 18)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(49, 19)" end="(49, 24)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(49, 19)" end="(49, 22)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(49, 23)" end="(49, 24)">
                            <IdentNode start="(49, 23)" end="(49, 24)" leading="" trailing="" raw_val="w" val="w"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(49, 24)" end="(49, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(49, 25)" end="(49, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(49, 27)" end="(49, 85)" kind="«term_=_»">
                    <OtherNode start="(49, 27)" end="(49, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(49, 27)" end="(49, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(49, 29)" end="(49, 44)">
                        <IdentNode start="(49, 29)" end="(49, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(49, 31)" end="(49, 44)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(49, 31)" end="(49, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(49, 32)" end="(49, 43)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(49, 32)" end="(49, 37)" leading="" trailing=" " raw_val="state" val="state"/>
                            <NullNode start="(49, 38)" end="(49, 43)">
                              <IdentNode start="(49, 38)" end="(49, 43)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(49, 43)" end="(49, 44)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(49, 45)" end="(49, 46)" leading="" trailing=" " val="="/>
                    <OtherNode start="(49, 47)" end="(49, 85)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(49, 47)" end="(49, 48)" leading="" trailing="" val="("/>
                      <NullNode start="(49, 48)" end="(49, 84)">
                        <OtherNode start="(49, 48)" end="(49, 63)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(49, 48)" end="(49, 53)" leading="" trailing=" " raw_val="state" val="state"/>
                          <NullNode start="(49, 54)" end="(49, 63)">
                            <OtherNode start="(49, 54)" end="(49, 63)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(49, 54)" end="(49, 55)" leading="" trailing="" val="("/>
                              <OtherNode start="(49, 55)" end="(49, 62)" kind="«term_+_»">
                                <IdentNode start="(49, 55)" end="(49, 60)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                <AtomNode start="(49, 60)" end="(49, 61)" leading="" trailing="" val="+"/>
                                <OtherNode start="(49, 61)" end="(49, 62)" kind="num">
                                  <AtomNode start="(49, 61)" end="(49, 62)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(49, 62)" end="(49, 63)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(49, 63)" end="(49, 64)" leading="" trailing=" " val=","/>
                        <NullNode start="(49, 65)" end="(49, 84)">
                          <OtherNode start="(49, 65)" end="(49, 84)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(49, 65)" end="(49, 78)" leading="" trailing=" " raw_val="value.getLsbD" val="value.getLsbD"/>
                            <NullNode start="(49, 79)" end="(49, 84)">
                              <IdentNode start="(49, 79)" end="(49, 84)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(49, 84)" end="(49, 85)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(49, 85)" end="(49, 86)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(49, 87)" end="(50, 54)">
            <AtomNode start="(49, 87)" end="(49, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(50, 5)" end="(50, 54)" kind="«term_=_»">
              <OtherNode start="(50, 5)" end="(50, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(50, 5)" end="(50, 13)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                <NullNode start="(50, 14)" end="(50, 17)">
                  <IdentNode start="(50, 14)" end="(50, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(50, 16)" end="(50, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(50, 18)" end="(50, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(50, 20)" end="(50, 54)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(50, 20)" end="(50, 21)" leading="" trailing="" val="("/>
                <NullNode start="(50, 21)" end="(50, 53)">
                  <OtherNode start="(50, 21)" end="(50, 28)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(50, 21)" end="(50, 26)" leading="" trailing=" " raw_val="state" val="state"/>
                    <NullNode start="(50, 27)" end="(50, 28)">
                      <IdentNode start="(50, 27)" end="(50, 28)" leading="" trailing="" raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(50, 28)" end="(50, 29)" leading="" trailing=" " val=","/>
                  <NullNode start="(50, 30)" end="(50, 53)">
                    <OtherNode start="(50, 30)" end="(50, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(50, 30)" end="(50, 45)" leading="" trailing=" " raw_val="BitVec.truncate" val="BitVec.truncate" full_name="BitVec.truncate" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                      <NullNode start="(50, 46)" end="(50, 53)">
                        <IdentNode start="(50, 46)" end="(50, 47)" leading="" trailing=" " raw_val="w" val="w"/>
                        <IdentNode start="(50, 48)" end="(50, 53)" leading="" trailing="" raw_val="value" val="value"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </NullNode>
                <AtomNode start="(50, 53)" end="(50, 54)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(50, 55)" end="(56, 29)">
          <AtomNode start="(50, 55)" end="(50, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(50, 58)" end="(56, 29)">
            <AtomNode start="(50, 58)" end="(50, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(51, 3)" end="(56, 29)">
              <TacticTacticseq1IndentedNode start="(51, 3)" end="(56, 29)">
                <NullNode start="(51, 3)" end="(56, 29)">
                  <OtherNode start="(51, 3)" end="(51, 87)" kind="Lean.Parser.Tactic.apply" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ iunfoldr f a = (state w, truncate w value)" state_after="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ (a, nil) = (state 0, truncate 0 value)&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ ∀ (i : Fin w),&#10;    (fun p =&amp;gt; (p.fst, cons p.snd (state ↑i, truncate (↑i) value).snd)) (f i (state ↑i, truncate (↑i) value).fst) =&#10;      (state (↑i + 1), truncate (↑i + 1) value)" tactic="apply Fin.hIterate_eq (fun i =&amp;gt; ((state i, BitVec.truncate i value) : α × BitVec i))">
                    <AtomNode start="(51, 3)" end="(51, 8)" leading="" trailing=" " val="apply"/>
                    <OtherNode start="(51, 9)" end="(51, 87)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(51, 9)" end="(51, 24)" leading="" trailing=" " raw_val="Fin.hIterate_eq" val="Fin.hIterate_eq" full_name="Fin.hIterate_eq" mod_name="Init.Data.Fin.Iterate" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Iterate.lean"/>
                      <NullNode start="(51, 25)" end="(51, 87)">
                        <OtherNode start="(51, 25)" end="(51, 87)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(51, 25)" end="(51, 26)" leading="" trailing="" val="("/>
                          <OtherNode start="(51, 26)" end="(51, 86)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(51, 26)" end="(51, 29)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(51, 30)" end="(51, 86)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(51, 30)" end="(51, 31)">
                                <IdentNode start="(51, 30)" end="(51, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(51, 32)" end="(51, 34)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(51, 35)" end="(51, 86)" kind="Lean.Parser.Term.typeAscription">
                                <AtomNode start="(51, 35)" end="(51, 36)" leading="" trailing="" val="("/>
                                <OtherNode start="(51, 36)" end="(51, 70)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(51, 36)" end="(51, 37)" leading="" trailing="" val="("/>
                                  <NullNode start="(51, 37)" end="(51, 69)">
                                    <OtherNode start="(51, 37)" end="(51, 44)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(51, 37)" end="(51, 42)" leading="" trailing=" " raw_val="state" val="state"/>
                                      <NullNode start="(51, 43)" end="(51, 44)">
                                        <IdentNode start="(51, 43)" end="(51, 44)" leading="" trailing="" raw_val="i" val="i"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(51, 44)" end="(51, 45)" leading="" trailing=" " val=","/>
                                    <NullNode start="(51, 46)" end="(51, 69)">
                                      <OtherNode start="(51, 46)" end="(51, 69)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(51, 46)" end="(51, 61)" leading="" trailing=" " raw_val="BitVec.truncate" val="BitVec.truncate" full_name="BitVec.truncate" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                                        <NullNode start="(51, 62)" end="(51, 69)">
                                          <IdentNode start="(51, 62)" end="(51, 63)" leading="" trailing=" " raw_val="i" val="i"/>
                                          <IdentNode start="(51, 64)" end="(51, 69)" leading="" trailing="" raw_val="value" val="value"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(51, 69)" end="(51, 70)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(51, 71)" end="(51, 72)" leading="" trailing=" " val=":"/>
                                <NullNode start="(51, 73)" end="(51, 85)">
                                  <OtherNode start="(51, 73)" end="(51, 85)" kind="«term_×_»">
                                    <IdentNode start="(51, 73)" end="(51, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                                    <AtomNode start="(51, 75)" end="(51, 76)" leading="" trailing=" " val="×"/>
                                    <OtherNode start="(51, 77)" end="(51, 85)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(51, 77)" end="(51, 83)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(51, 84)" end="(51, 85)">
                                        <IdentNode start="(51, 84)" end="(51, 85)" leading="" trailing="" raw_val="i" val="i"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(51, 85)" end="(51, 86)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(51, 86)" end="(51, 87)" leading="" trailing="&#10;  " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(52, 3)" end="(53, 29)" kind="Lean.Parser.Tactic.case" state_before="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ (a, nil) = (state 0, truncate 0 value)&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ ∀ (i : Fin w),&#10;    (fun p =&amp;gt; (p.fst, cons p.snd (state ↑i, truncate (↑i) value).snd)) (f i (state ↑i, truncate (↑i) value).fst) =&#10;      (state (↑i + 1), truncate (↑i + 1) value)" state_after="case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ ∀ (i : Fin w),&#10;    (fun p =&amp;gt; (p.fst, cons p.snd (state ↑i, truncate (↑i) value).snd)) (f i (state ↑i, truncate (↑i) value).fst) =&#10;      (state (↑i + 1), truncate (↑i + 1) value)" tactic="case init =&amp;gt;&#10;  simp only [init, eq_nil]">
                    <AtomNode start="(52, 3)" end="(52, 7)" leading="" trailing=" " val="case"/>
                    <NullNode start="(52, 8)" end="(52, 12)">
                      <OtherNode start="(52, 8)" end="(52, 12)" kind="Lean.Parser.Tactic.caseArg">
                        <LeanBinderidentNode start="(52, 8)" end="(52, 12)">
                          <IdentNode start="(52, 8)" end="(52, 12)" leading="" trailing=" " raw_val="init" val="init"/>
                        </LeanBinderidentNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(52, 13)" end="(52, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                    <TacticTacticseqNode start="(53, 5)" end="(53, 29)">
                      <TacticTacticseq1IndentedNode start="(53, 5)" end="(53, 29)">
                        <NullNode start="(53, 5)" end="(53, 29)">
                          <OtherNode start="(53, 5)" end="(53, 29)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ (a, nil) = (state 0, truncate 0 value)" state_after="no goals" tactic="simp only [init, eq_nil]">
                            <AtomNode start="(53, 5)" end="(53, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(53, 10)" end="(53, 14)">
                              <AtomNode start="(53, 10)" end="(53, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(53, 15)" end="(53, 29)">
                              <AtomNode start="(53, 15)" end="(53, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(53, 16)" end="(53, 28)">
                                <OtherNode start="(53, 16)" end="(53, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(53, 16)" end="(53, 20)" leading="" trailing="" raw_val="init" val="init"/>
                                </OtherNode>
                                <AtomNode start="(53, 20)" end="(53, 21)" leading="" trailing=" " val=","/>
                                <OtherNode start="(53, 22)" end="(53, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(53, 22)" end="(53, 28)" leading="" trailing="" raw_val="eq_nil" val="eq_nil" full_name="BitVec.eq_nil" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(53, 28)" end="(53, 29)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(54, 3)" end="(56, 29)" kind="Lean.Parser.Tactic.case" state_before="case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ ∀ (i : Fin w),&#10;    (fun p =&amp;gt; (p.fst, cons p.snd (state ↑i, truncate (↑i) value).snd)) (f i (state ↑i, truncate (↑i) value).fst) =&#10;      (state (↑i + 1), truncate (↑i + 1) value)" state_after="no goals" tactic="case step =&amp;gt;&#10;  intro i&#10;  simp_all [setWidth_succ]">
                    <AtomNode start="(54, 3)" end="(54, 7)" leading="" trailing=" " val="case"/>
                    <NullNode start="(54, 8)" end="(54, 12)">
                      <OtherNode start="(54, 8)" end="(54, 12)" kind="Lean.Parser.Tactic.caseArg">
                        <LeanBinderidentNode start="(54, 8)" end="(54, 12)">
                          <IdentNode start="(54, 8)" end="(54, 12)" leading="" trailing=" " raw_val="step" val="step"/>
                        </LeanBinderidentNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(54, 13)" end="(54, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                    <TacticTacticseqNode start="(55, 5)" end="(56, 29)">
                      <TacticTacticseq1IndentedNode start="(55, 5)" end="(56, 29)">
                        <NullNode start="(55, 5)" end="(56, 29)">
                          <OtherNode start="(55, 5)" end="(55, 12)" kind="Lean.Parser.Tactic.intro" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;⊢ ∀ (i : Fin w),&#10;    (fun p =&amp;gt; (p.fst, cons p.snd (state ↑i, truncate (↑i) value).snd)) (f i (state ↑i, truncate (↑i) value).fst) =&#10;      (state (↑i + 1), truncate (↑i + 1) value)" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;i : Fin w&#10;⊢ (fun p =&amp;gt; (p.fst, cons p.snd (state ↑i, truncate (↑i) value).snd)) (f i (state ↑i, truncate (↑i) value).fst) =&#10;    (state (↑i + 1), truncate (↑i + 1) value)" tactic="intro i">
                            <AtomNode start="(55, 5)" end="(55, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(55, 11)" end="(55, 12)">
                              <IdentNode start="(55, 11)" end="(55, 12)" leading="" trailing="&#10;    " raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(56, 5)" end="(56, 29)" kind="Lean.Parser.Tactic.simpAll" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value.getLsbD ↑i)&#10;i : Fin w&#10;⊢ (fun p =&amp;gt; (p.fst, cons p.snd (state ↑i, truncate (↑i) value).snd)) (f i (state ↑i, truncate (↑i) value).fst) =&#10;    (state (↑i + 1), truncate (↑i + 1) value)" state_after="no goals" tactic="simp_all [setWidth_succ]">
                            <AtomNode start="(56, 5)" end="(56, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(56, 14)" end="(56, 29)">
                              <AtomNode start="(56, 14)" end="(56, 15)" leading="" trailing="" val="["/>
                              <NullNode start="(56, 15)" end="(56, 28)">
                                <OtherNode start="(56, 15)" end="(56, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(56, 15)" end="(56, 28)" leading="" trailing="" raw_val="setWidth_succ" val="setWidth_succ" full_name="BitVec.setWidth_succ" mod_name="Init.Data.BitVec.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(56, 28)" end="(56, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(58, 1)" end="(95, 33)" name="iunfoldr_getLsbD'" full_name="BitVec.iunfoldr_getLsbD'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(58, 1)" end="(95, 33)" name="iunfoldr_getLsbD'" full_name="BitVec.iunfoldr_getLsbD'" _is_private_decl="False">
        <AtomNode start="(58, 1)" end="(58, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(58, 9)" end="(58, 26)">
          <IdentNode start="(58, 9)" end="(58, 26)" leading="" trailing=" " raw_val="iunfoldr_getLsbD'" val="iunfoldr_getLsbD'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(58, 27)" end="(61, 41)">
          <NullNode start="(58, 27)" end="(59, 68)">
            <OtherNode start="(58, 27)" end="(58, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 27)" end="(58, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 28)" end="(58, 29)">
                <IdentNode start="(58, 28)" end="(58, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(58, 30)" end="(58, 52)">
                <AtomNode start="(58, 30)" end="(58, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 32)" end="(58, 52)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(58, 32)" end="(58, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(58, 32)" end="(58, 35)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(58, 36)" end="(58, 37)">
                      <IdentNode start="(58, 36)" end="(58, 37)" leading="" trailing=" " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(58, 38)" end="(58, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(58, 40)" end="(58, 52)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(58, 40)" end="(58, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(58, 42)" end="(58, 43)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(58, 44)" end="(58, 52)" kind="«term_×_»">
                      <IdentNode start="(58, 44)" end="(58, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(58, 46)" end="(58, 47)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(58, 48)" end="(58, 52)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(58, 52)" end="(58, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(58, 54)" end="(58, 71)">
              <AtomNode start="(58, 54)" end="(58, 55)" leading="" trailing="" val="("/>
              <NullNode start="(58, 55)" end="(58, 60)">
                <IdentNode start="(58, 55)" end="(58, 60)" leading="" trailing=" " raw_val="state" val="state"/>
              </NullNode>
              <NullNode start="(58, 61)" end="(58, 70)">
                <AtomNode start="(58, 61)" end="(58, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 63)" end="(58, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(58, 63)" end="(58, 66)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(58, 67)" end="(58, 68)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(58, 69)" end="(58, 70)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(58, 70)" end="(58, 71)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(59, 5)" end="(59, 68)">
              <AtomNode start="(59, 5)" end="(59, 6)" leading="" trailing="" val="("/>
              <NullNode start="(59, 6)" end="(59, 9)">
                <IdentNode start="(59, 6)" end="(59, 9)" leading="" trailing=" " raw_val="ind" val="ind"/>
              </NullNode>
              <NullNode start="(59, 10)" end="(59, 67)">
                <AtomNode start="(59, 10)" end="(59, 11)" leading="" trailing=" " val=":"/>
                <OtherNode start="(59, 12)" end="(59, 67)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(59, 12)" end="(59, 13)" leading="" trailing="" val="∀"/>
                  <NullNode start="(59, 13)" end="(59, 24)">
                    <TermExplicitbinderNode start="(59, 13)" end="(59, 24)">
                      <AtomNode start="(59, 13)" end="(59, 14)" leading="" trailing="" val="("/>
                      <NullNode start="(59, 14)" end="(59, 15)">
                        <IdentNode start="(59, 14)" end="(59, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(59, 16)" end="(59, 23)">
                        <AtomNode start="(59, 16)" end="(59, 17)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(59, 18)" end="(59, 23)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(59, 18)" end="(59, 21)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(59, 22)" end="(59, 23)">
                            <IdentNode start="(59, 22)" end="(59, 23)" leading="" trailing="" raw_val="w" val="w"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(59, 23)" end="(59, 24)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(59, 24)" end="(59, 25)" leading="" trailing=" " val=","/>
                  <OtherNode start="(59, 26)" end="(59, 67)" kind="«term_=_»">
                    <OtherNode start="(59, 26)" end="(59, 49)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(59, 26)" end="(59, 45)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(59, 26)" end="(59, 27)" leading="" trailing="" val="("/>
                        <OtherNode start="(59, 27)" end="(59, 44)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(59, 27)" end="(59, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(59, 29)" end="(59, 44)">
                            <IdentNode start="(59, 29)" end="(59, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                            <OtherNode start="(59, 31)" end="(59, 44)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(59, 31)" end="(59, 32)" leading="" trailing="" val="("/>
                              <OtherNode start="(59, 32)" end="(59, 43)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(59, 32)" end="(59, 37)" leading="" trailing=" " raw_val="state" val="state"/>
                                <NullNode start="(59, 38)" end="(59, 43)">
                                  <IdentNode start="(59, 38)" end="(59, 43)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(59, 43)" end="(59, 44)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(59, 44)" end="(59, 45)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(59, 45)" end="(59, 46)" leading="" trailing="" val="."/>
                      <IdentNode start="(59, 46)" end="(59, 49)" leading="" trailing=" " raw_val="fst" val="fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(59, 50)" end="(59, 51)" leading="" trailing=" " val="="/>
                    <OtherNode start="(59, 52)" end="(59, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(59, 52)" end="(59, 57)" leading="" trailing=" " raw_val="state" val="state"/>
                      <NullNode start="(59, 58)" end="(59, 67)">
                        <OtherNode start="(59, 58)" end="(59, 67)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(59, 58)" end="(59, 59)" leading="" trailing="" val="("/>
                          <OtherNode start="(59, 59)" end="(59, 66)" kind="«term_+_»">
                            <IdentNode start="(59, 59)" end="(59, 64)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            <AtomNode start="(59, 64)" end="(59, 65)" leading="" trailing="" val="+"/>
                            <OtherNode start="(59, 65)" end="(59, 66)" kind="num">
                              <AtomNode start="(59, 65)" end="(59, 66)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(59, 66)" end="(59, 67)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(59, 67)" end="(59, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(59, 69)" end="(61, 41)">
            <AtomNode start="(59, 69)" end="(59, 70)" leading="" trailing="&#10;  " val=":"/>
            <OtherNode start="(60, 3)" end="(61, 41)" kind="«term_∧_»">
              <OtherNode start="(60, 3)" end="(60, 84)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(60, 3)" end="(60, 4)" leading="" trailing="" val="("/>
                <OtherNode start="(60, 4)" end="(60, 83)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(60, 4)" end="(60, 5)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(60, 6)" end="(60, 7)">
                    <IdentNode start="(60, 6)" end="(60, 7)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                  <NullNode start="(60, 8)" end="(60, 15)">
                    <TermTypespecNode start="(60, 8)" end="(60, 15)">
                      <AtomNode start="(60, 8)" end="(60, 9)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(60, 10)" end="(60, 15)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(60, 10)" end="(60, 13)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(60, 14)" end="(60, 15)">
                          <IdentNode start="(60, 14)" end="(60, 15)" leading="" trailing="" raw_val="w" val="w"/>
                        </NullNode>
                      </OtherNode>
                    </TermTypespecNode>
                  </NullNode>
                  <AtomNode start="(60, 15)" end="(60, 16)" leading="" trailing=" " val=","/>
                  <OtherNode start="(60, 17)" end="(60, 83)" kind="«term_=_»">
                    <OtherNode start="(60, 17)" end="(60, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(60, 17)" end="(60, 24)" leading="" trailing=" " raw_val="getLsbD" val="getLsbD" full_name="BitVec.getLsbD" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                      <NullNode start="(60, 25)" end="(60, 57)">
                        <OtherNode start="(60, 25)" end="(60, 51)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(60, 25)" end="(60, 47)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(60, 25)" end="(60, 26)" leading="" trailing="" val="("/>
                            <OtherNode start="(60, 26)" end="(60, 46)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(60, 26)" end="(60, 34)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                              <NullNode start="(60, 35)" end="(60, 46)">
                                <IdentNode start="(60, 35)" end="(60, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                                <OtherNode start="(60, 37)" end="(60, 46)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(60, 37)" end="(60, 38)" leading="" trailing="" val="("/>
                                  <OtherNode start="(60, 38)" end="(60, 45)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(60, 38)" end="(60, 43)" leading="" trailing=" " raw_val="state" val="state"/>
                                    <NullNode start="(60, 44)" end="(60, 45)">
                                      <OtherNode start="(60, 44)" end="(60, 45)" kind="num">
                                        <AtomNode start="(60, 44)" end="(60, 45)" leading="" trailing="" val="0"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(60, 45)" end="(60, 46)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(60, 46)" end="(60, 47)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(60, 47)" end="(60, 48)" leading="" trailing="" val="."/>
                          <IdentNode start="(60, 48)" end="(60, 51)" leading="" trailing=" " raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <IdentNode start="(60, 52)" end="(60, 57)" leading="" trailing=" " raw_val="i.val" val="i.val"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(60, 58)" end="(60, 59)" leading="" trailing=" " val="="/>
                    <OtherNode start="(60, 60)" end="(60, 83)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(60, 60)" end="(60, 79)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(60, 60)" end="(60, 61)" leading="" trailing="" val="("/>
                        <OtherNode start="(60, 61)" end="(60, 78)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(60, 61)" end="(60, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(60, 63)" end="(60, 78)">
                            <IdentNode start="(60, 63)" end="(60, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                            <OtherNode start="(60, 65)" end="(60, 78)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(60, 65)" end="(60, 66)" leading="" trailing="" val="("/>
                              <OtherNode start="(60, 66)" end="(60, 77)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(60, 66)" end="(60, 71)" leading="" trailing=" " raw_val="state" val="state"/>
                                <NullNode start="(60, 72)" end="(60, 77)">
                                  <IdentNode start="(60, 72)" end="(60, 77)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(60, 77)" end="(60, 78)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(60, 78)" end="(60, 79)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(60, 79)" end="(60, 80)" leading="" trailing="" val="."/>
                      <IdentNode start="(60, 80)" end="(60, 83)" leading="" trailing="" raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(60, 83)" end="(60, 84)" leading="" trailing="&#10;  " val=")"/>
              </OtherNode>
              <AtomNode start="(61, 3)" end="(61, 4)" leading="" trailing=" " val="∧"/>
              <OtherNode start="(61, 5)" end="(61, 41)" kind="«term_=_»">
                <OtherNode start="(61, 5)" end="(61, 31)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(61, 5)" end="(61, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(61, 5)" end="(61, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(61, 6)" end="(61, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(61, 6)" end="(61, 14)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                      <NullNode start="(61, 15)" end="(61, 26)">
                        <IdentNode start="(61, 15)" end="(61, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                        <OtherNode start="(61, 17)" end="(61, 26)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(61, 17)" end="(61, 18)" leading="" trailing="" val="("/>
                          <OtherNode start="(61, 18)" end="(61, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(61, 18)" end="(61, 23)" leading="" trailing=" " raw_val="state" val="state"/>
                            <NullNode start="(61, 24)" end="(61, 25)">
                              <OtherNode start="(61, 24)" end="(61, 25)" kind="num">
                                <AtomNode start="(61, 24)" end="(61, 25)" leading="" trailing="" val="0"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(61, 25)" end="(61, 26)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(61, 26)" end="(61, 27)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(61, 27)" end="(61, 28)" leading="" trailing="" val="."/>
                  <IdentNode start="(61, 28)" end="(61, 31)" leading="" trailing=" " raw_val="fst" val="fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <AtomNode start="(61, 32)" end="(61, 33)" leading="" trailing=" " val="="/>
                <OtherNode start="(61, 34)" end="(61, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 34)" end="(61, 39)" leading="" trailing=" " raw_val="state" val="state"/>
                  <NullNode start="(61, 40)" end="(61, 41)">
                    <IdentNode start="(61, 40)" end="(61, 41)" leading="" trailing=" " raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(61, 42)" end="(95, 33)">
          <AtomNode start="(61, 42)" end="(61, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(61, 45)" end="(95, 33)">
            <AtomNode start="(61, 45)" end="(61, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(62, 3)" end="(95, 33)">
              <TacticTacticseq1IndentedNode start="(62, 3)" end="(95, 33)">
                <NullNode start="(62, 3)" end="(95, 33)">
                  <OtherNode start="(62, 3)" end="(62, 18)" kind="Lean.Parser.Tactic.unfold" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (∀ (i : Fin w), (iunfoldr f (state 0)).snd.getLsbD ↑i = (f i (state ↑i)).snd) ∧ (iunfoldr f (state 0)).fst = state w" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (∀ (i : Fin w),&#10;      (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, nil) fun i q =&amp;gt;&#10;                (fun p =&amp;gt; (p.fst, cons p.snd q.snd)) (f i q.fst)).snd.getLsbD&#10;          ↑i =&#10;        (f i (state ↑i)).snd) ∧&#10;    (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, nil) fun i q =&amp;gt;&#10;          (fun p =&amp;gt; (p.fst, cons p.snd q.snd)) (f i q.fst)).fst =&#10;      state w" tactic="unfold iunfoldr">
                    <AtomNode start="(62, 3)" end="(62, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(62, 10)" end="(62, 18)">
                      <IdentNode start="(62, 10)" end="(62, 18)" leading="" trailing="&#10;  " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(63, 3)" end="(63, 7)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (∀ (i : Fin w),&#10;      (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, nil) fun i q =&amp;gt;&#10;                (fun p =&amp;gt; (p.fst, cons p.snd q.snd)) (f i q.fst)).snd.getLsbD&#10;          ↑i =&#10;        (f i (state ↑i)).snd) ∧&#10;    (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, nil) fun i q =&amp;gt;&#10;          (fun p =&amp;gt; (p.fst, cons p.snd q.snd)) (f i q.fst)).fst =&#10;      state w" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (∀ (i : Fin w),&#10;      (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, 0#0) fun i q =&amp;gt;&#10;              ((f i q.fst).fst, cons (f i q.fst).snd q.snd)).snd[↑i] =&#10;        (f i (state ↑i)).snd) ∧&#10;    (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, 0#0) fun i q =&amp;gt; ((f i q.fst).fst, cons (f i q.fst).snd q.snd)).fst =&#10;      state w" tactic="simp">
                    <AtomNode start="(63, 3)" end="(63, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(64, 3)" end="(67, 29)" kind="Lean.Parser.Tactic.apply" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (∀ (i : Fin w),&#10;      (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, 0#0) fun i q =&amp;gt;&#10;              ((f i q.fst).fst, cons (f i q.fst).snd q.snd)).snd[↑i] =&#10;        (f i (state ↑i)).snd) ∧&#10;    (Fin.hIterate (fun i =&amp;gt; α × BitVec i) (state 0, 0#0) fun i q =&amp;gt; ((f i q.fst).fst, cons (f i q.fst).snd q.snd)).fst =&#10;      state w" state_after="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (hj : 0 ≤ w),&#10;    (∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (state 0, 0#0).fst = state 0&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    (∀ (hj : ↑k ≤ w), (∀ (i : Fin ↑k), s.snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ s.fst = state ↑k) →&#10;      ∀ (hj : ↑k + 1 ≤ w),&#10;        (∀ (i : Fin (↑k + 1)),&#10;            ((f k s.fst).fst, cons (f k s.fst).snd s.snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;          ((f k s.fst).fst, cons (f k s.fst).snd s.snd).fst = state (↑k + 1)&#10;&#10;case hj&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ w ≤ w" tactic="apply Fin.hIterate_elim&#10;      (fun j (p : α × BitVec j) =&amp;gt; (hj : j ≤ w) →&#10;       (∀ i : Fin j,  getLsbD p.snd i.val = (f ⟨i.val, Nat.lt_of_lt_of_le i.isLt hj⟩ (state i.val)).snd)&#10;        ∧ p.fst = state j)">
                    <AtomNode start="(64, 3)" end="(64, 8)" leading="" trailing=" " val="apply"/>
                    <OtherNode start="(64, 9)" end="(67, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(64, 9)" end="(64, 26)" leading="" trailing="&#10;        " raw_val="Fin.hIterate_elim" val="Fin.hIterate_elim" full_name="Fin.hIterate_elim" mod_name="Init.Data.Fin.Iterate" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Iterate.lean"/>
                      <NullNode start="(65, 9)" end="(67, 29)">
                        <OtherNode start="(65, 9)" end="(67, 29)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(65, 9)" end="(65, 10)" leading="" trailing="" val="("/>
                          <OtherNode start="(65, 10)" end="(67, 28)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(65, 10)" end="(65, 13)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(65, 14)" end="(67, 28)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(65, 14)" end="(65, 34)">
                                <IdentNode start="(65, 14)" end="(65, 15)" leading="" trailing=" " raw_val="j" val="j"/>
                                <OtherNode start="(65, 16)" end="(65, 34)" kind="Lean.Parser.Term.typeAscription">
                                  <AtomNode start="(65, 16)" end="(65, 17)" leading="" trailing="" val="("/>
                                  <IdentNode start="(65, 17)" end="(65, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <AtomNode start="(65, 19)" end="(65, 20)" leading="" trailing=" " val=":"/>
                                  <NullNode start="(65, 21)" end="(65, 33)">
                                    <OtherNode start="(65, 21)" end="(65, 33)" kind="«term_×_»">
                                      <IdentNode start="(65, 21)" end="(65, 22)" leading="" trailing=" " raw_val="α" val="α"/>
                                      <AtomNode start="(65, 23)" end="(65, 24)" leading="" trailing=" " val="×"/>
                                      <OtherNode start="(65, 25)" end="(65, 33)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(65, 25)" end="(65, 31)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <NullNode start="(65, 32)" end="(65, 33)">
                                          <IdentNode start="(65, 32)" end="(65, 33)" leading="" trailing="" raw_val="j" val="j"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(65, 33)" end="(65, 34)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(65, 35)" end="(65, 37)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(65, 38)" end="(67, 28)" kind="Lean.Parser.Term.depArrow">
                                <TermExplicitbinderNode start="(65, 38)" end="(65, 50)">
                                  <AtomNode start="(65, 38)" end="(65, 39)" leading="" trailing="" val="("/>
                                  <NullNode start="(65, 39)" end="(65, 41)">
                                    <IdentNode start="(65, 39)" end="(65, 41)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                  </NullNode>
                                  <NullNode start="(65, 42)" end="(65, 49)">
                                    <AtomNode start="(65, 42)" end="(65, 43)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(65, 44)" end="(65, 49)" kind="«term_≤_»">
                                      <IdentNode start="(65, 44)" end="(65, 45)" leading="" trailing=" " raw_val="j" val="j"/>
                                      <AtomNode start="(65, 46)" end="(65, 47)" leading="" trailing=" " val="≤"/>
                                      <IdentNode start="(65, 48)" end="(65, 49)" leading="" trailing="" raw_val="w" val="w"/>
                                    </OtherNode>
                                  </NullNode>
                                  <NullNode/>
                                  <AtomNode start="(65, 49)" end="(65, 50)" leading="" trailing=" " val=")"/>
                                </TermExplicitbinderNode>
                                <AtomNode start="(65, 51)" end="(65, 52)" leading="" trailing="&#10;         " val="→"/>
                                <OtherNode start="(66, 10)" end="(67, 28)" kind="«term_∧_»">
                                  <OtherNode start="(66, 10)" end="(66, 107)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(66, 10)" end="(66, 11)" leading="" trailing="" val="("/>
                                    <OtherNode start="(66, 11)" end="(66, 106)" kind="Lean.Parser.Term.forall">
                                      <AtomNode start="(66, 11)" end="(66, 12)" leading="" trailing=" " val="∀"/>
                                      <NullNode start="(66, 13)" end="(66, 14)">
                                        <IdentNode start="(66, 13)" end="(66, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                      </NullNode>
                                      <NullNode start="(66, 15)" end="(66, 22)">
                                        <TermTypespecNode start="(66, 15)" end="(66, 22)">
                                          <AtomNode start="(66, 15)" end="(66, 16)" leading="" trailing=" " val=":"/>
                                          <OtherNode start="(66, 17)" end="(66, 22)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(66, 17)" end="(66, 20)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            <NullNode start="(66, 21)" end="(66, 22)">
                                              <IdentNode start="(66, 21)" end="(66, 22)" leading="" trailing="" raw_val="j" val="j"/>
                                            </NullNode>
                                          </OtherNode>
                                        </TermTypespecNode>
                                      </NullNode>
                                      <AtomNode start="(66, 22)" end="(66, 23)" leading="" trailing="  " val=","/>
                                      <OtherNode start="(66, 25)" end="(66, 106)" kind="«term_=_»">
                                        <OtherNode start="(66, 25)" end="(66, 44)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(66, 25)" end="(66, 32)" leading="" trailing=" " raw_val="getLsbD" val="getLsbD" full_name="BitVec.getLsbD" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                                          <NullNode start="(66, 33)" end="(66, 44)">
                                            <IdentNode start="(66, 33)" end="(66, 38)" leading="" trailing=" " raw_val="p.snd" val="p.snd"/>
                                            <IdentNode start="(66, 39)" end="(66, 44)" leading="" trailing=" " raw_val="i.val" val="i.val"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(66, 45)" end="(66, 46)" leading="" trailing=" " val="="/>
                                        <OtherNode start="(66, 47)" end="(66, 106)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(66, 47)" end="(66, 102)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(66, 47)" end="(66, 48)" leading="" trailing="" val="("/>
                                            <OtherNode start="(66, 48)" end="(66, 101)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(66, 48)" end="(66, 49)" leading="" trailing=" " raw_val="f" val="f"/>
                                              <NullNode start="(66, 50)" end="(66, 101)">
                                                <OtherNode start="(66, 50)" end="(66, 87)" kind="Lean.Parser.Term.anonymousCtor">
                                                  <AtomNode start="(66, 50)" end="(66, 51)" leading="" trailing="" val="⟨"/>
                                                  <NullNode start="(66, 51)" end="(66, 86)">
                                                    <IdentNode start="(66, 51)" end="(66, 56)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                                    <AtomNode start="(66, 56)" end="(66, 57)" leading="" trailing=" " val=","/>
                                                    <OtherNode start="(66, 58)" end="(66, 86)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(66, 58)" end="(66, 76)" leading="" trailing=" " raw_val="Nat.lt_of_lt_of_le" val="Nat.lt_of_lt_of_le" full_name="Nat.lt_of_lt_of_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                      <NullNode start="(66, 77)" end="(66, 86)">
                                                        <IdentNode start="(66, 77)" end="(66, 83)" leading="" trailing=" " raw_val="i.isLt" val="i.isLt"/>
                                                        <IdentNode start="(66, 84)" end="(66, 86)" leading="" trailing="" raw_val="hj" val="hj"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(66, 86)" end="(66, 87)" leading="" trailing=" " val="⟩"/>
                                                </OtherNode>
                                                <OtherNode start="(66, 88)" end="(66, 101)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(66, 88)" end="(66, 89)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(66, 89)" end="(66, 100)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(66, 89)" end="(66, 94)" leading="" trailing=" " raw_val="state" val="state"/>
                                                    <NullNode start="(66, 95)" end="(66, 100)">
                                                      <IdentNode start="(66, 95)" end="(66, 100)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(66, 100)" end="(66, 101)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(66, 101)" end="(66, 102)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                          <AtomNode start="(66, 102)" end="(66, 103)" leading="" trailing="" val="."/>
                                          <IdentNode start="(66, 103)" end="(66, 106)" leading="" trailing="" raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(66, 106)" end="(66, 107)" leading="" trailing="&#10;          " val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(67, 11)" end="(67, 12)" leading="" trailing=" " val="∧"/>
                                  <OtherNode start="(67, 13)" end="(67, 28)" kind="«term_=_»">
                                    <IdentNode start="(67, 13)" end="(67, 18)" leading="" trailing=" " raw_val="p.fst" val="p.fst"/>
                                    <AtomNode start="(67, 19)" end="(67, 20)" leading="" trailing=" " val="="/>
                                    <OtherNode start="(67, 21)" end="(67, 28)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(67, 21)" end="(67, 26)" leading="" trailing=" " raw_val="state" val="state"/>
                                      <NullNode start="(67, 27)" end="(67, 28)">
                                        <IdentNode start="(67, 27)" end="(67, 28)" leading="" trailing="" raw_val="j" val="j"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(67, 28)" end="(67, 29)" leading="" trailing="&#10;  " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(68, 3)" end="(68, 18)" kind="Lean.Parser.Tactic.case" state_before="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (hj : 0 ≤ w),&#10;    (∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (state 0, 0#0).fst = state 0&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    (∀ (hj : ↑k ≤ w), (∀ (i : Fin ↑k), s.snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ s.fst = state ↑k) →&#10;      ∀ (hj : ↑k + 1 ≤ w),&#10;        (∀ (i : Fin (↑k + 1)),&#10;            ((f k s.fst).fst, cons (f k s.fst).snd s.snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;          ((f k s.fst).fst, cons (f k s.fst).snd s.snd).fst = state (↑k + 1)&#10;&#10;case hj&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ w ≤ w" state_after="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (hj : 0 ≤ w),&#10;    (∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (state 0, 0#0).fst = state 0&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    (∀ (hj : ↑k ≤ w), (∀ (i : Fin ↑k), s.snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ s.fst = state ↑k) →&#10;      ∀ (hj : ↑k + 1 ≤ w),&#10;        (∀ (i : Fin (↑k + 1)),&#10;            ((f k s.fst).fst, cons (f k s.fst).snd s.snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;          ((f k s.fst).fst, cons (f k s.fst).snd s.snd).fst = state (↑k + 1)" tactic="case hj =&amp;gt; simp">
                    <AtomNode start="(68, 3)" end="(68, 7)" leading="" trailing=" " val="case"/>
                    <NullNode start="(68, 8)" end="(68, 10)">
                      <OtherNode start="(68, 8)" end="(68, 10)" kind="Lean.Parser.Tactic.caseArg">
                        <LeanBinderidentNode start="(68, 8)" end="(68, 10)">
                          <IdentNode start="(68, 8)" end="(68, 10)" leading="" trailing=" " raw_val="hj" val="hj"/>
                        </LeanBinderidentNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(68, 11)" end="(68, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                    <TacticTacticseqNode start="(68, 14)" end="(68, 18)">
                      <TacticTacticseq1IndentedNode start="(68, 14)" end="(68, 18)">
                        <NullNode start="(68, 14)" end="(68, 18)">
                          <OtherNode start="(68, 14)" end="(68, 18)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ w ≤ w" state_after="no goals" tactic="simp">
                            <AtomNode start="(68, 14)" end="(68, 18)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(69, 3)" end="(75, 10)" kind="Lean.Parser.Tactic.case" state_before="case init&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (hj : 0 ≤ w),&#10;    (∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (state 0, 0#0).fst = state 0&#10;&#10;case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    (∀ (hj : ↑k ≤ w), (∀ (i : Fin ↑k), s.snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ s.fst = state ↑k) →&#10;      ∀ (hj : ↑k + 1 ≤ w),&#10;        (∀ (i : Fin (↑k + 1)),&#10;            ((f k s.fst).fst, cons (f k s.fst).snd s.snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;          ((f k s.fst).fst, cons (f k s.fst).snd s.snd).fst = state (↑k + 1)" state_after="case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    (∀ (hj : ↑k ≤ w), (∀ (i : Fin ↑k), s.snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ s.fst = state ↑k) →&#10;      ∀ (hj : ↑k + 1 ≤ w),&#10;        (∀ (i : Fin (↑k + 1)),&#10;            ((f k s.fst).fst, cons (f k s.fst).snd s.snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;          ((f k s.fst).fst, cons (f k s.fst).snd s.snd).fst = state (↑k + 1)" tactic="case init =&amp;gt;&#10;  intro&#10;  apply And.intro&#10;  · intro i&#10;    have := Fin.pos i&#10;    contradiction&#10;  · rfl">
                    <AtomNode start="(69, 3)" end="(69, 7)" leading="" trailing=" " val="case"/>
                    <NullNode start="(69, 8)" end="(69, 12)">
                      <OtherNode start="(69, 8)" end="(69, 12)" kind="Lean.Parser.Tactic.caseArg">
                        <LeanBinderidentNode start="(69, 8)" end="(69, 12)">
                          <IdentNode start="(69, 8)" end="(69, 12)" leading="" trailing=" " raw_val="init" val="init"/>
                        </LeanBinderidentNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(69, 13)" end="(69, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                    <TacticTacticseqNode start="(70, 5)" end="(75, 10)">
                      <TacticTacticseq1IndentedNode start="(70, 5)" end="(75, 10)">
                        <NullNode start="(70, 5)" end="(75, 10)">
                          <OtherNode start="(70, 5)" end="(70, 10)" kind="Lean.Parser.Tactic.intro" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (hj : 0 ≤ w),&#10;    (∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (state 0, 0#0).fst = state 0" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ (∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (state 0, 0#0).fst = state 0" tactic="intro">
                            <AtomNode start="(70, 5)" end="(70, 10)" leading="" trailing="&#10;    " val="intro"/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(71, 5)" end="(71, 20)" kind="Lean.Parser.Tactic.apply" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ (∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (state 0, 0#0).fst = state 0" state_after="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ ∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd&#10;&#10;case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ (state 0, 0#0).fst = state 0" tactic="apply And.intro">
                            <AtomNode start="(71, 5)" end="(71, 10)" leading="" trailing=" " val="apply"/>
                            <IdentNode start="(71, 11)" end="(71, 20)" leading="" trailing="&#10;    " raw_val="And.intro" val="And.intro" full_name="And.intro" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(72, 5)" end="(74, 20)" kind="Lean.cdot" state_before="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ ∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd&#10;&#10;case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ (state 0, 0#0).fst = state 0" state_after="case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ (state 0, 0#0).fst = state 0" tactic="· intro i&#10;  have := Fin.pos i&#10;  contradiction">
                            <OtherNode start="(72, 5)" end="(72, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(72, 5)" end="(72, 6)" kind="patternIgnore">
                                <OtherNode start="(72, 5)" end="(72, 6)" kind="token.«· »">
                                  <AtomNode start="(72, 5)" end="(72, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(72, 7)" end="(74, 20)">
                              <TacticTacticseq1IndentedNode start="(72, 7)" end="(74, 20)">
                                <NullNode start="(72, 7)" end="(74, 20)">
                                  <OtherNode start="(72, 7)" end="(72, 14)" kind="Lean.Parser.Tactic.intro" state_before="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ ∀ (i : Fin 0), (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;i : Fin 0&#10;⊢ (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" tactic="intro i">
                                    <AtomNode start="(72, 7)" end="(72, 12)" leading="" trailing=" " val="intro"/>
                                    <NullNode start="(72, 13)" end="(72, 14)">
                                      <IdentNode start="(72, 13)" end="(72, 14)" leading="" trailing="&#10;      " raw_val="i" val="i"/>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(73, 7)" end="(73, 24)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;i : Fin 0&#10;⊢ (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;i : Fin 0&#10;this : 0 &amp;lt; 0&#10;⊢ (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" tactic="have := Fin.pos i">
                                    <AtomNode start="(73, 7)" end="(73, 11)" leading="" trailing=" " val="have"/>
                                    <OtherNode start="(73, 12)" end="(73, 24)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(73, 12)" end="(73, 24)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(73, 12)" end="(73, 12)" kind="Lean.Parser.Term.haveId">
                                          <OtherNode start="(73, 12)" end="(73, 12)" kind="hygieneInfo">
                                            <IdentNode start="(73, 12)" end="(73, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <AtomNode start="(73, 12)" end="(73, 14)" leading="" trailing=" " val=":="/>
                                        <OtherNode start="(73, 15)" end="(73, 24)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(73, 15)" end="(73, 22)" leading="" trailing=" " raw_val="Fin.pos" val="Fin.pos" full_name="Fin.pos" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                                          <NullNode start="(73, 23)" end="(73, 24)">
                                            <IdentNode start="(73, 23)" end="(73, 24)" leading="" trailing="&#10;      " raw_val="i" val="i"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(74, 7)" end="(74, 20)" kind="Lean.Parser.Tactic.contradiction" state_before="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;i : Fin 0&#10;this : 0 &amp;lt; 0&#10;⊢ (state 0, 0#0).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="no goals" tactic="contradiction">
                                    <AtomNode start="(74, 7)" end="(74, 20)" leading="" trailing="&#10;    " val="contradiction"/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(75, 5)" end="(75, 10)" kind="Lean.cdot" state_before="case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ (state 0, 0#0).fst = state 0" state_after="no goals" tactic="· rfl">
                            <OtherNode start="(75, 5)" end="(75, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(75, 5)" end="(75, 6)" kind="patternIgnore">
                                <OtherNode start="(75, 5)" end="(75, 6)" kind="token.«· »">
                                  <AtomNode start="(75, 5)" end="(75, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(75, 7)" end="(75, 10)">
                              <TacticTacticseq1IndentedNode start="(75, 7)" end="(75, 10)">
                                <NullNode start="(75, 7)" end="(75, 10)">
                                  <OtherNode start="(75, 7)" end="(75, 10)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;hj✝ : 0 ≤ w&#10;⊢ (state 0, 0#0).fst = state 0" state_after="no goals" tactic="rfl">
                                    <AtomNode start="(75, 7)" end="(75, 10)" leading="" trailing="&#10;  " val="rfl"/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(76, 3)" end="(95, 33)" kind="Lean.Parser.Tactic.case" state_before="case step&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    (∀ (hj : ↑k ≤ w), (∀ (i : Fin ↑k), s.snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ s.fst = state ↑k) →&#10;      ∀ (hj : ↑k + 1 ≤ w),&#10;        (∀ (i : Fin (↑k + 1)),&#10;            ((f k s.fst).fst, cons (f k s.fst).snd s.snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;          ((f k s.fst).fst, cons (f k s.fst).snd s.snd).fst = state (↑k + 1)" state_after="no goals" tactic="case step =&amp;gt;&#10;  intro j ⟨s, v⟩ ih hj&#10;  apply And.intro&#10;  case left =&amp;gt;&#10;    intro i&#10;    simp only [getLsbD_cons]&#10;    have hj2 : j.val ≤ w := by simp&#10;    cases (Nat.lt_or_eq_of_le (Nat.lt_succ.mp i.isLt)) with&#10;    | inl h3 =&amp;gt; simp [if_neg, (Nat.ne_of_lt h3)]&#10;                exact (ih hj2).1 ⟨i.val, h3⟩&#10;    | inr h3 =&amp;gt; simp [h3, if_pos]&#10;                cases (Nat.eq_zero_or_pos j.val) with&#10;                | inl hj3 =&amp;gt; congr&#10;                             rw [← (ih hj2).2]&#10;                | inr hj3 =&amp;gt; congr&#10;                             exact (ih hj2).2&#10;  case right =&amp;gt;&#10;    simp&#10;    have hj2 : j.val ≤ w := by simp&#10;    rw [← ind j, ← (ih hj2).2]">
                    <AtomNode start="(76, 3)" end="(76, 7)" leading="" trailing=" " val="case"/>
                    <NullNode start="(76, 8)" end="(76, 12)">
                      <OtherNode start="(76, 8)" end="(76, 12)" kind="Lean.Parser.Tactic.caseArg">
                        <LeanBinderidentNode start="(76, 8)" end="(76, 12)">
                          <IdentNode start="(76, 8)" end="(76, 12)" leading="" trailing=" " raw_val="step" val="step"/>
                        </LeanBinderidentNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(76, 13)" end="(76, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                    <TacticTacticseqNode start="(77, 5)" end="(95, 33)">
                      <TacticTacticseq1IndentedNode start="(77, 5)" end="(95, 33)">
                        <NullNode start="(77, 5)" end="(95, 33)">
                          <OtherNode start="(77, 5)" end="(77, 25)" kind="Lean.Parser.Tactic.intro" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ ∀ (k : Fin w) (s : α × BitVec ↑k),&#10;    (∀ (hj : ↑k ≤ w), (∀ (i : Fin ↑k), s.snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ s.fst = state ↑k) →&#10;      ∀ (hj : ↑k + 1 ≤ w),&#10;        (∀ (i : Fin (↑k + 1)),&#10;            ((f k s.fst).fst, cons (f k s.fst).snd s.snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;          ((f k s.fst).fst, cons (f k s.fst).snd s.snd).fst = state (↑k + 1)" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ (∀ (i : Fin (↑j + 1)),&#10;      ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;    ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).fst = state (↑j + 1)" tactic="intro j ⟨s, v⟩ ih hj">
                            <AtomNode start="(77, 5)" end="(77, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(77, 11)" end="(77, 25)">
                              <IdentNode start="(77, 11)" end="(77, 12)" leading="" trailing=" " raw_val="j" val="j"/>
                              <OtherNode start="(77, 13)" end="(77, 19)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(77, 13)" end="(77, 14)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(77, 14)" end="(77, 18)">
                                  <IdentNode start="(77, 14)" end="(77, 15)" leading="" trailing="" raw_val="s" val="s"/>
                                  <AtomNode start="(77, 15)" end="(77, 16)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(77, 17)" end="(77, 18)" leading="" trailing="" raw_val="v" val="v"/>
                                </NullNode>
                                <AtomNode start="(77, 18)" end="(77, 19)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                              <IdentNode start="(77, 20)" end="(77, 22)" leading="" trailing=" " raw_val="ih" val="ih"/>
                              <IdentNode start="(77, 23)" end="(77, 25)" leading="" trailing="&#10;    " raw_val="hj" val="hj"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(78, 5)" end="(78, 20)" kind="Lean.Parser.Tactic.apply" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ (∀ (i : Fin (↑j + 1)),&#10;      ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧&#10;    ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).fst = state (↑j + 1)" state_after="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ∀ (i : Fin (↑j + 1)),&#10;    ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd&#10;&#10;case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).fst = state (↑j + 1)" tactic="apply And.intro">
                            <AtomNode start="(78, 5)" end="(78, 10)" leading="" trailing=" " val="apply"/>
                            <IdentNode start="(78, 11)" end="(78, 20)" leading="" trailing="&#10;    " raw_val="And.intro" val="And.intro" full_name="And.intro" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(79, 5)" end="(91, 48)" kind="Lean.Parser.Tactic.case" state_before="case left&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ∀ (i : Fin (↑j + 1)),&#10;    ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd&#10;&#10;case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).fst = state (↑j + 1)" state_after="case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).fst = state (↑j + 1)" tactic="case left =&amp;gt;&#10;  intro i&#10;  simp only [getLsbD_cons]&#10;  have hj2 : j.val ≤ w := by simp&#10;  cases (Nat.lt_or_eq_of_le (Nat.lt_succ.mp i.isLt)) with&#10;  | inl h3 =&amp;gt; simp [if_neg, (Nat.ne_of_lt h3)]&#10;              exact (ih hj2).1 ⟨i.val, h3⟩&#10;  | inr h3 =&amp;gt; simp [h3, if_pos]&#10;              cases (Nat.eq_zero_or_pos j.val) with&#10;              | inl hj3 =&amp;gt; congr&#10;                           rw [← (ih hj2).2]&#10;              | inr hj3 =&amp;gt; congr&#10;                           exact (ih hj2).2">
                            <AtomNode start="(79, 5)" end="(79, 9)" leading="" trailing=" " val="case"/>
                            <NullNode start="(79, 10)" end="(79, 14)">
                              <OtherNode start="(79, 10)" end="(79, 14)" kind="Lean.Parser.Tactic.caseArg">
                                <LeanBinderidentNode start="(79, 10)" end="(79, 14)">
                                  <IdentNode start="(79, 10)" end="(79, 14)" leading="" trailing=" " raw_val="left" val="left"/>
                                </LeanBinderidentNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(79, 15)" end="(79, 17)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(80, 7)" end="(91, 48)">
                              <TacticTacticseq1IndentedNode start="(80, 7)" end="(91, 48)">
                                <NullNode start="(80, 7)" end="(91, 48)">
                                  <OtherNode start="(80, 7)" end="(80, 14)" kind="Lean.Parser.Tactic.intro" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ∀ (i : Fin (↑j + 1)),&#10;    ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;⊢ ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" tactic="intro i">
                                    <AtomNode start="(80, 7)" end="(80, 12)" leading="" trailing=" " val="intro"/>
                                    <NullNode start="(80, 13)" end="(80, 14)">
                                      <IdentNode start="(80, 13)" end="(80, 14)" leading="" trailing="&#10;      " raw_val="i" val="i"/>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(81, 7)" end="(81, 31)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;⊢ ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;⊢ (if ↑i = ↑j then (f j s).snd else v.getLsbD ↑i) = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" tactic="simp only [getLsbD_cons]">
                                    <AtomNode start="(81, 7)" end="(81, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(81, 12)" end="(81, 16)">
                                      <AtomNode start="(81, 12)" end="(81, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(81, 17)" end="(81, 31)">
                                      <AtomNode start="(81, 17)" end="(81, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(81, 18)" end="(81, 30)">
                                        <OtherNode start="(81, 18)" end="(81, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(81, 18)" end="(81, 30)" leading="" trailing="" raw_val="getLsbD_cons" val="getLsbD_cons" full_name="BitVec.getLsbD_cons" mod_name="Init.Data.BitVec.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(81, 30)" end="(81, 31)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(82, 7)" end="(82, 38)" kind="Lean.Parser.Tactic.tacticHave_" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;⊢ (if ↑i = ↑j then (f j s).snd else v.getLsbD ↑i) = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;⊢ (if ↑i = ↑j then (f j s).snd else v.getLsbD ↑i) = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" tactic="have hj2 : j.val ≤ w := by simp">
                                    <AtomNode start="(82, 7)" end="(82, 11)" leading="" trailing=" " val="have"/>
                                    <OtherNode start="(82, 12)" end="(82, 38)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(82, 12)" end="(82, 38)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(82, 12)" end="(82, 15)" kind="Lean.Parser.Term.haveId">
                                          <IdentNode start="(82, 12)" end="(82, 15)" leading="" trailing=" " raw_val="hj2" val="hj2"/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(82, 16)" end="(82, 27)">
                                          <TermTypespecNode start="(82, 16)" end="(82, 27)">
                                            <AtomNode start="(82, 16)" end="(82, 17)" leading="" trailing=" " val=":"/>
                                            <OtherNode start="(82, 18)" end="(82, 27)" kind="«term_≤_»">
                                              <IdentNode start="(82, 18)" end="(82, 23)" leading="" trailing=" " raw_val="j.val" val="j.val"/>
                                              <AtomNode start="(82, 24)" end="(82, 25)" leading="" trailing=" " val="≤"/>
                                              <IdentNode start="(82, 26)" end="(82, 27)" leading="" trailing=" " raw_val="w" val="w"/>
                                            </OtherNode>
                                          </TermTypespecNode>
                                        </NullNode>
                                        <AtomNode start="(82, 28)" end="(82, 30)" leading="" trailing=" " val=":="/>
                                        <TermBytacticNode start="(82, 31)" end="(82, 38)">
                                          <AtomNode start="(82, 31)" end="(82, 33)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(82, 34)" end="(82, 38)">
                                            <TacticTacticseq1IndentedNode start="(82, 34)" end="(82, 38)">
                                              <NullNode start="(82, 34)" end="(82, 38)">
                                                <OtherNode start="(82, 34)" end="(82, 38)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;⊢ ↑j ≤ w" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(82, 34)" end="(82, 38)" leading="" trailing="&#10;      " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(83, 7)" end="(91, 48)" kind="Lean.Parser.Tactic.cases" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;⊢ (if ↑i = ↑j then (f j s).snd else v.getLsbD ↑i) = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="no goals" tactic="cases (Nat.lt_or_eq_of_le (Nat.lt_succ.mp i.isLt)) with&#10;| inl h3 =&amp;gt; simp [if_neg, (Nat.ne_of_lt h3)]&#10;            exact (ih hj2).1 ⟨i.val, h3⟩&#10;| inr h3 =&amp;gt; simp [h3, if_pos]&#10;            cases (Nat.eq_zero_or_pos j.val) with&#10;            | inl hj3 =&amp;gt; congr&#10;                         rw [← (ih hj2).2]&#10;            | inr hj3 =&amp;gt; congr&#10;                         exact (ih hj2).2">
                                    <AtomNode start="(83, 7)" end="(83, 12)" leading="" trailing=" " val="cases"/>
                                    <NullNode start="(83, 13)" end="(83, 57)">
                                      <OtherNode start="(83, 13)" end="(83, 57)" kind="Lean.Parser.Tactic.elimTarget">
                                        <NullNode/>
                                        <OtherNode start="(83, 13)" end="(83, 57)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(83, 13)" end="(83, 14)" leading="" trailing="" val="("/>
                                          <OtherNode start="(83, 14)" end="(83, 56)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(83, 14)" end="(83, 32)" leading="" trailing=" " raw_val="Nat.lt_or_eq_of_le" val="Nat.lt_or_eq_of_le" full_name="Nat.lt_or_eq_of_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                            <NullNode start="(83, 33)" end="(83, 56)">
                                              <OtherNode start="(83, 33)" end="(83, 56)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(83, 33)" end="(83, 34)" leading="" trailing="" val="("/>
                                                <OtherNode start="(83, 34)" end="(83, 55)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(83, 34)" end="(83, 48)" leading="" trailing=" " raw_val="Nat.lt_succ.mp" val="Nat.lt_succ.mp"/>
                                                  <NullNode start="(83, 49)" end="(83, 55)">
                                                    <IdentNode start="(83, 49)" end="(83, 55)" leading="" trailing="" raw_val="i.isLt" val="i.isLt"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(83, 55)" end="(83, 56)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(83, 56)" end="(83, 57)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode start="(83, 58)" end="(91, 48)">
                                      <OtherNode start="(83, 58)" end="(91, 48)" kind="Lean.Parser.Tactic.inductionAlts">
                                        <AtomNode start="(83, 58)" end="(83, 62)" leading="" trailing="&#10;      " val="with"/>
                                        <NullNode/>
                                        <NullNode start="(84, 7)" end="(91, 48)">
                                          <OtherNode start="(84, 7)" end="(85, 47)" kind="Lean.Parser.Tactic.inductionAlt">
                                            <NullNode start="(84, 7)" end="(84, 15)">
                                              <OtherNode start="(84, 7)" end="(84, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                <AtomNode start="(84, 7)" end="(84, 8)" leading="" trailing=" " val="|"/>
                                                <GroupNode start="(84, 9)" end="(84, 12)">
                                                  <NullNode/>
                                                  <IdentNode start="(84, 9)" end="(84, 12)" leading="" trailing=" " raw_val="inl" val="inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                </GroupNode>
                                                <NullNode start="(84, 13)" end="(84, 15)">
                                                  <IdentNode start="(84, 13)" end="(84, 15)" leading="" trailing=" " raw_val="h3" val="h3"/>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                            <NullNode start="(84, 16)" end="(85, 47)">
                                              <AtomNode start="(84, 16)" end="(84, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                              <TacticTacticseqNode start="(84, 19)" end="(85, 47)">
                                                <TacticTacticseq1IndentedNode start="(84, 19)" end="(85, 47)">
                                                  <NullNode start="(84, 19)" end="(85, 47)">
                                                    <OtherNode start="(84, 19)" end="(84, 51)" kind="Lean.Parser.Tactic.simp" state_before="case inl&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i &amp;lt; ↑j&#10;⊢ (if ↑i = ↑j then (f j s).snd else v.getLsbD ↑i) = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="case inl&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i &amp;lt; ↑j&#10;⊢ v.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" tactic="simp [if_neg, (Nat.ne_of_lt h3)]">
                                                      <AtomNode start="(84, 19)" end="(84, 23)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(84, 24)" end="(84, 51)">
                                                        <AtomNode start="(84, 24)" end="(84, 25)" leading="" trailing="" val="["/>
                                                        <NullNode start="(84, 25)" end="(84, 50)">
                                                          <OtherNode start="(84, 25)" end="(84, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(84, 25)" end="(84, 31)" leading="" trailing="" raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                          </OtherNode>
                                                          <AtomNode start="(84, 31)" end="(84, 32)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(84, 33)" end="(84, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(84, 33)" end="(84, 50)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(84, 33)" end="(84, 34)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(84, 34)" end="(84, 49)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(84, 34)" end="(84, 46)" leading="" trailing=" " raw_val="Nat.ne_of_lt" val="Nat.ne_of_lt" full_name="Nat.ne_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(84, 47)" end="(84, 49)">
                                                            <IdentNode start="(84, 47)" end="(84, 49)" leading="" trailing="" raw_val="h3" val="h3"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(84, 49)" end="(84, 50)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(84, 50)" end="(84, 51)" leading="" trailing="&#10;                  " val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(85, 19)" end="(85, 47)" kind="Lean.Parser.Tactic.exact" state_before="case inl&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i &amp;lt; ↑j&#10;⊢ v.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="no goals" tactic="exact (ih hj2).1 ⟨i.val, h3⟩">
                                                      <AtomNode start="(85, 19)" end="(85, 24)" leading="" trailing=" " val="exact"/>
                                                      <OtherNode start="(85, 25)" end="(85, 47)" kind="Lean.Parser.Term.app">
                                                        <OtherNode start="(85, 25)" end="(85, 35)" kind="Lean.Parser.Term.proj">
                                                          <OtherNode start="(85, 25)" end="(85, 33)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(85, 25)" end="(85, 26)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(85, 26)" end="(85, 32)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(85, 26)" end="(85, 28)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(85, 29)" end="(85, 32)">
                                                            <IdentNode start="(85, 29)" end="(85, 32)" leading="" trailing="" raw_val="hj2" val="hj2"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(85, 32)" end="(85, 33)" leading="" trailing="" val=")"/>
                                                          </OtherNode>
                                                          <AtomNode start="(85, 33)" end="(85, 34)" leading="" trailing="" val="."/>
                                                          <OtherNode start="(85, 34)" end="(85, 35)" kind="fieldIdx">
                                                            <AtomNode start="(85, 34)" end="(85, 35)" leading="" trailing=" " val="1"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <NullNode start="(85, 36)" end="(85, 47)">
                                                          <OtherNode start="(85, 36)" end="(85, 47)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(85, 36)" end="(85, 37)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(85, 37)" end="(85, 46)">
                                                            <IdentNode start="(85, 37)" end="(85, 42)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                                            <AtomNode start="(85, 42)" end="(85, 43)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(85, 44)" end="(85, 46)" leading="" trailing="" raw_val="h3" val="h3"/>
                                                            </NullNode>
                                                            <AtomNode start="(85, 46)" end="(85, 47)" leading="" trailing="&#10;      " val="⟩"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </NullNode>
                                          </OtherNode>
                                          <OtherNode start="(86, 7)" end="(91, 48)" kind="Lean.Parser.Tactic.inductionAlt">
                                            <NullNode start="(86, 7)" end="(86, 15)">
                                              <OtherNode start="(86, 7)" end="(86, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                <AtomNode start="(86, 7)" end="(86, 8)" leading="" trailing=" " val="|"/>
                                                <GroupNode start="(86, 9)" end="(86, 12)">
                                                  <NullNode/>
                                                  <IdentNode start="(86, 9)" end="(86, 12)" leading="" trailing=" " raw_val="inr" val="inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                </GroupNode>
                                                <NullNode start="(86, 13)" end="(86, 15)">
                                                  <IdentNode start="(86, 13)" end="(86, 15)" leading="" trailing=" " raw_val="h3" val="h3"/>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                            <NullNode start="(86, 16)" end="(91, 48)">
                                              <AtomNode start="(86, 16)" end="(86, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                              <TacticTacticseqNode start="(86, 19)" end="(91, 48)">
                                                <TacticTacticseq1IndentedNode start="(86, 19)" end="(91, 48)">
                                                  <NullNode start="(86, 19)" end="(91, 48)">
                                                    <OtherNode start="(86, 19)" end="(86, 36)" kind="Lean.Parser.Tactic.simp" state_before="case inr&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;⊢ (if ↑i = ↑j then (f j s).snd else v.getLsbD ↑i) = (f ⟨↑i, ⋯⟩ (state ↑i)).snd" state_after="case inr&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;⊢ (f j s).snd = (f j (state ↑j)).snd" tactic="simp [h3, if_pos]">
                                                      <AtomNode start="(86, 19)" end="(86, 23)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(86, 24)" end="(86, 36)">
                                                        <AtomNode start="(86, 24)" end="(86, 25)" leading="" trailing="" val="["/>
                                                        <NullNode start="(86, 25)" end="(86, 35)">
                                                          <OtherNode start="(86, 25)" end="(86, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(86, 25)" end="(86, 27)" leading="" trailing="" raw_val="h3" val="h3"/>
                                                          </OtherNode>
                                                          <AtomNode start="(86, 27)" end="(86, 28)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(86, 29)" end="(86, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(86, 29)" end="(86, 35)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(86, 35)" end="(86, 36)" leading="" trailing="&#10;                  " val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(87, 19)" end="(91, 48)" kind="Lean.Parser.Tactic.cases" state_before="case inr&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;⊢ (f j s).snd = (f j (state ↑j)).snd" state_after="no goals" tactic="cases (Nat.eq_zero_or_pos j.val) with&#10;| inl hj3 =&amp;gt; congr&#10;             rw [← (ih hj2).2]&#10;| inr hj3 =&amp;gt; congr&#10;             exact (ih hj2).2">
                                                      <AtomNode start="(87, 19)" end="(87, 24)" leading="" trailing=" " val="cases"/>
                                                      <NullNode start="(87, 25)" end="(87, 51)">
                                                        <OtherNode start="(87, 25)" end="(87, 51)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <OtherNode start="(87, 25)" end="(87, 51)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(87, 25)" end="(87, 26)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(87, 26)" end="(87, 50)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(87, 26)" end="(87, 44)" leading="" trailing=" " raw_val="Nat.eq_zero_or_pos" val="Nat.eq_zero_or_pos" full_name="Nat.eq_zero_or_pos" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(87, 45)" end="(87, 50)">
                                                            <IdentNode start="(87, 45)" end="(87, 50)" leading="" trailing="" raw_val="j.val" val="j.val"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(87, 50)" end="(87, 51)" leading="" trailing=" " val=")"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode start="(87, 52)" end="(91, 48)">
                                                        <OtherNode start="(87, 52)" end="(91, 48)" kind="Lean.Parser.Tactic.inductionAlts">
                                                          <AtomNode start="(87, 52)" end="(87, 56)" leading="" trailing="&#10;                  " val="with"/>
                                                          <NullNode/>
                                                          <NullNode start="(88, 19)" end="(91, 48)">
                                                            <OtherNode start="(88, 19)" end="(89, 49)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(88, 19)" end="(88, 28)">
                                                            <OtherNode start="(88, 19)" end="(88, 28)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(88, 19)" end="(88, 20)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(88, 21)" end="(88, 24)">
                                                            <NullNode/>
                                                            <IdentNode start="(88, 21)" end="(88, 24)" leading="" trailing=" " raw_val="inl" val="inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode start="(88, 25)" end="(88, 28)">
                                                            <IdentNode start="(88, 25)" end="(88, 28)" leading="" trailing=" " raw_val="hj3" val="hj3"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(88, 29)" end="(89, 49)">
                                                            <AtomNode start="(88, 29)" end="(88, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(88, 32)" end="(89, 49)">
                                                            <TacticTacticseq1IndentedNode start="(88, 32)" end="(89, 49)">
                                                            <NullNode start="(88, 32)" end="(89, 49)">
                                                            <OtherNode start="(88, 32)" end="(88, 37)" kind="Lean.Parser.Tactic.congr" state_before="case inr.inl&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;hj3 : ↑j = 0&#10;⊢ (f j s).snd = (f j (state ↑j)).snd" state_after="case inr.inl.e_self.e_a&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;hj3 : ↑j = 0&#10;⊢ s = state ↑j" tactic="congr">
                                                            <AtomNode start="(88, 32)" end="(88, 37)" leading="" trailing="&#10;                               " val="congr"/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(89, 32)" end="(89, 49)" kind="Lean.Parser.Tactic.rwSeq" state_before="case inr.inl.e_self.e_a&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;hj3 : ↑j = 0&#10;⊢ s = state ↑j" state_after="no goals" tactic="rw [← (ih hj2).2]">
                                                            <AtomNode start="(89, 32)" end="(89, 34)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(89, 35)" end="(89, 49)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(89, 35)" end="(89, 36)" leading="" trailing="" val="["/>
                                                            <NullNode start="(89, 36)" end="(89, 48)">
                                                            <OtherNode start="(89, 36)" end="(89, 48)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(89, 36)" end="(89, 37)">
                                                            <OtherNode start="(89, 36)" end="(89, 37)" kind="patternIgnore">
                                                            <OtherNode start="(89, 36)" end="(89, 37)" kind="token.«← »">
                                                            <AtomNode start="(89, 36)" end="(89, 37)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(89, 38)" end="(89, 48)" kind="Lean.Parser.Term.proj">
                                                            <OtherNode start="(89, 38)" end="(89, 46)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(89, 38)" end="(89, 39)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(89, 39)" end="(89, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(89, 39)" end="(89, 41)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(89, 42)" end="(89, 45)">
                                                            <IdentNode start="(89, 42)" end="(89, 45)" leading="" trailing="" raw_val="hj2" val="hj2"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(89, 45)" end="(89, 46)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            <AtomNode start="(89, 46)" end="(89, 47)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(89, 47)" end="(89, 48)" kind="fieldIdx">
                                                            <AtomNode start="(89, 47)" end="(89, 48)" leading="" trailing="" val="2"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(89, 48)" end="(89, 49)" leading="" trailing="&#10;                  " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(90, 19)" end="(91, 48)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(90, 19)" end="(90, 28)">
                                                            <OtherNode start="(90, 19)" end="(90, 28)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(90, 19)" end="(90, 20)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(90, 21)" end="(90, 24)">
                                                            <NullNode/>
                                                            <IdentNode start="(90, 21)" end="(90, 24)" leading="" trailing=" " raw_val="inr" val="inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode start="(90, 25)" end="(90, 28)">
                                                            <IdentNode start="(90, 25)" end="(90, 28)" leading="" trailing=" " raw_val="hj3" val="hj3"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(90, 29)" end="(91, 48)">
                                                            <AtomNode start="(90, 29)" end="(90, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(90, 32)" end="(91, 48)">
                                                            <TacticTacticseq1IndentedNode start="(90, 32)" end="(91, 48)">
                                                            <NullNode start="(90, 32)" end="(91, 48)">
                                                            <OtherNode start="(90, 32)" end="(90, 37)" kind="Lean.Parser.Tactic.congr" state_before="case inr.inr&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;hj3 : ↑j &amp;gt; 0&#10;⊢ (f j s).snd = (f j (state ↑j)).snd" state_after="case inr.inr.e_self.e_a&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;hj3 : ↑j &amp;gt; 0&#10;⊢ s = state ↑j" tactic="congr">
                                                            <AtomNode start="(90, 32)" end="(90, 37)" leading="" trailing="&#10;                               " val="congr"/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(91, 32)" end="(91, 48)" kind="Lean.Parser.Tactic.exact" state_before="case inr.inr.e_self.e_a&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;i : Fin (↑j + 1)&#10;hj2 : ↑j ≤ w&#10;h3 : ↑i = ↑j&#10;hj3 : ↑j &amp;gt; 0&#10;⊢ s = state ↑j" state_after="no goals" tactic="exact (ih hj2).2">
                                                            <AtomNode start="(91, 32)" end="(91, 37)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(91, 38)" end="(91, 48)" kind="Lean.Parser.Term.proj">
                                                            <OtherNode start="(91, 38)" end="(91, 46)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(91, 38)" end="(91, 39)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(91, 39)" end="(91, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(91, 39)" end="(91, 41)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(91, 42)" end="(91, 45)">
                                                            <IdentNode start="(91, 42)" end="(91, 45)" leading="" trailing="" raw_val="hj2" val="hj2"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(91, 45)" end="(91, 46)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            <AtomNode start="(91, 46)" end="(91, 47)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(91, 47)" end="(91, 48)" kind="fieldIdx">
                                                            <AtomNode start="(91, 47)" end="(91, 48)" leading="" trailing="&#10;    " val="2"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(92, 5)" end="(95, 33)" kind="Lean.Parser.Tactic.case" state_before="case right&#10;w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).fst = state (↑j + 1)" state_after="no goals" tactic="case right =&amp;gt;&#10;  simp&#10;  have hj2 : j.val ≤ w := by simp&#10;  rw [← ind j, ← (ih hj2).2]">
                            <AtomNode start="(92, 5)" end="(92, 9)" leading="" trailing=" " val="case"/>
                            <NullNode start="(92, 10)" end="(92, 15)">
                              <OtherNode start="(92, 10)" end="(92, 15)" kind="Lean.Parser.Tactic.caseArg">
                                <LeanBinderidentNode start="(92, 10)" end="(92, 15)">
                                  <IdentNode start="(92, 10)" end="(92, 15)" leading="" trailing=" " raw_val="right" val="right"/>
                                </LeanBinderidentNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(92, 16)" end="(92, 18)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(93, 7)" end="(95, 33)">
                              <TacticTacticseq1IndentedNode start="(93, 7)" end="(95, 33)">
                                <NullNode start="(93, 7)" end="(95, 33)">
                                  <OtherNode start="(93, 7)" end="(93, 11)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ((f j (s, v).fst).fst, cons (f j (s, v).fst).snd (s, v).snd).fst = state (↑j + 1)" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ (f j s).fst = state (↑j + 1)" tactic="simp">
                                    <AtomNode start="(93, 7)" end="(93, 11)" leading="" trailing="&#10;      " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(94, 7)" end="(94, 38)" kind="Lean.Parser.Tactic.tacticHave_" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ (f j s).fst = state (↑j + 1)" state_after="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;hj2 : ↑j ≤ w&#10;⊢ (f j s).fst = state (↑j + 1)" tactic="have hj2 : j.val ≤ w := by simp">
                                    <AtomNode start="(94, 7)" end="(94, 11)" leading="" trailing=" " val="have"/>
                                    <OtherNode start="(94, 12)" end="(94, 38)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(94, 12)" end="(94, 38)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(94, 12)" end="(94, 15)" kind="Lean.Parser.Term.haveId">
                                          <IdentNode start="(94, 12)" end="(94, 15)" leading="" trailing=" " raw_val="hj2" val="hj2"/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(94, 16)" end="(94, 27)">
                                          <TermTypespecNode start="(94, 16)" end="(94, 27)">
                                            <AtomNode start="(94, 16)" end="(94, 17)" leading="" trailing=" " val=":"/>
                                            <OtherNode start="(94, 18)" end="(94, 27)" kind="«term_≤_»">
                                              <IdentNode start="(94, 18)" end="(94, 23)" leading="" trailing=" " raw_val="j.val" val="j.val"/>
                                              <AtomNode start="(94, 24)" end="(94, 25)" leading="" trailing=" " val="≤"/>
                                              <IdentNode start="(94, 26)" end="(94, 27)" leading="" trailing=" " raw_val="w" val="w"/>
                                            </OtherNode>
                                          </TermTypespecNode>
                                        </NullNode>
                                        <AtomNode start="(94, 28)" end="(94, 30)" leading="" trailing=" " val=":="/>
                                        <TermBytacticNode start="(94, 31)" end="(94, 38)">
                                          <AtomNode start="(94, 31)" end="(94, 33)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(94, 34)" end="(94, 38)">
                                            <TacticTacticseq1IndentedNode start="(94, 34)" end="(94, 38)">
                                              <NullNode start="(94, 34)" end="(94, 38)">
                                                <OtherNode start="(94, 34)" end="(94, 38)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;⊢ ↑j ≤ w" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(94, 34)" end="(94, 38)" leading="" trailing="&#10;      " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(95, 7)" end="(95, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;j : Fin w&#10;s : α&#10;v : BitVec ↑j&#10;ih : ∀ (hj : ↑j ≤ w), (∀ (i : Fin ↑j), (s, v).snd.getLsbD ↑i = (f ⟨↑i, ⋯⟩ (state ↑i)).snd) ∧ (s, v).fst = state ↑j&#10;hj : ↑j + 1 ≤ w&#10;hj2 : ↑j ≤ w&#10;⊢ (f j s).fst = state (↑j + 1)" state_after="no goals" tactic="rw [← ind j, ← (ih hj2).2]">
                                    <AtomNode start="(95, 7)" end="(95, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(95, 10)" end="(95, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(95, 10)" end="(95, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(95, 11)" end="(95, 32)">
                                        <OtherNode start="(95, 11)" end="(95, 18)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode start="(95, 11)" end="(95, 12)">
                                            <OtherNode start="(95, 11)" end="(95, 12)" kind="patternIgnore">
                                              <OtherNode start="(95, 11)" end="(95, 12)" kind="token.«← »">
                                                <AtomNode start="(95, 11)" end="(95, 12)" leading="" trailing=" " val="←"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <OtherNode start="(95, 13)" end="(95, 18)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(95, 13)" end="(95, 16)" leading="" trailing=" " raw_val="ind" val="ind"/>
                                            <NullNode start="(95, 17)" end="(95, 18)">
                                              <IdentNode start="(95, 17)" end="(95, 18)" leading="" trailing="" raw_val="j" val="j"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(95, 18)" end="(95, 19)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(95, 20)" end="(95, 32)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode start="(95, 20)" end="(95, 21)">
                                            <OtherNode start="(95, 20)" end="(95, 21)" kind="patternIgnore">
                                              <OtherNode start="(95, 20)" end="(95, 21)" kind="token.«← »">
                                                <AtomNode start="(95, 20)" end="(95, 21)" leading="" trailing=" " val="←"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <OtherNode start="(95, 22)" end="(95, 32)" kind="Lean.Parser.Term.proj">
                                            <OtherNode start="(95, 22)" end="(95, 30)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(95, 22)" end="(95, 23)" leading="" trailing="" val="("/>
                                              <OtherNode start="(95, 23)" end="(95, 29)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(95, 23)" end="(95, 25)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(95, 26)" end="(95, 29)">
                                                  <IdentNode start="(95, 26)" end="(95, 29)" leading="" trailing="" raw_val="hj2" val="hj2"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(95, 29)" end="(95, 30)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                            <AtomNode start="(95, 30)" end="(95, 31)" leading="" trailing="" val="."/>
                                            <OtherNode start="(95, 31)" end="(95, 32)" kind="fieldIdx">
                                              <AtomNode start="(95, 31)" end="(95, 32)" leading="" trailing="" val="2"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(95, 32)" end="(95, 33)" leading="" trailing="&#10;&#10;&#10;" val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(98, 1)" end="(101, 42)" name="iunfoldr_getLsbD" full_name="BitVec.iunfoldr_getLsbD">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(98, 1)" end="(101, 42)" name="iunfoldr_getLsbD" full_name="BitVec.iunfoldr_getLsbD" _is_private_decl="False">
        <AtomNode start="(98, 1)" end="(98, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(98, 9)" end="(98, 25)">
          <IdentNode start="(98, 9)" end="(98, 25)" leading="" trailing=" " raw_val="iunfoldr_getLsbD" val="iunfoldr_getLsbD"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(98, 26)" end="(100, 69)">
          <NullNode start="(98, 26)" end="(99, 68)">
            <OtherNode start="(98, 26)" end="(98, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(98, 26)" end="(98, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(98, 27)" end="(98, 28)">
                <IdentNode start="(98, 27)" end="(98, 28)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(98, 29)" end="(98, 51)">
                <AtomNode start="(98, 29)" end="(98, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(98, 31)" end="(98, 51)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(98, 31)" end="(98, 36)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(98, 31)" end="(98, 34)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(98, 35)" end="(98, 36)">
                      <IdentNode start="(98, 35)" end="(98, 36)" leading="" trailing=" " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(98, 37)" end="(98, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(98, 39)" end="(98, 51)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(98, 39)" end="(98, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(98, 41)" end="(98, 42)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(98, 43)" end="(98, 51)" kind="«term_×_»">
                      <IdentNode start="(98, 43)" end="(98, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(98, 45)" end="(98, 46)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(98, 47)" end="(98, 51)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(98, 51)" end="(98, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(98, 53)" end="(98, 70)">
              <AtomNode start="(98, 53)" end="(98, 54)" leading="" trailing="" val="("/>
              <NullNode start="(98, 54)" end="(98, 59)">
                <IdentNode start="(98, 54)" end="(98, 59)" leading="" trailing=" " raw_val="state" val="state"/>
              </NullNode>
              <NullNode start="(98, 60)" end="(98, 69)">
                <AtomNode start="(98, 60)" end="(98, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(98, 62)" end="(98, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(98, 62)" end="(98, 65)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(98, 66)" end="(98, 67)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(98, 68)" end="(98, 69)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(98, 69)" end="(98, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(98, 71)" end="(98, 82)">
              <AtomNode start="(98, 71)" end="(98, 72)" leading="" trailing="" val="("/>
              <NullNode start="(98, 72)" end="(98, 73)">
                <IdentNode start="(98, 72)" end="(98, 73)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(98, 74)" end="(98, 81)">
                <AtomNode start="(98, 74)" end="(98, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(98, 76)" end="(98, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(98, 76)" end="(98, 79)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(98, 80)" end="(98, 81)">
                    <IdentNode start="(98, 80)" end="(98, 81)" leading="" trailing="" raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(98, 81)" end="(98, 82)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(99, 5)" end="(99, 68)">
              <AtomNode start="(99, 5)" end="(99, 6)" leading="" trailing="" val="("/>
              <NullNode start="(99, 6)" end="(99, 9)">
                <IdentNode start="(99, 6)" end="(99, 9)" leading="" trailing=" " raw_val="ind" val="ind"/>
              </NullNode>
              <NullNode start="(99, 10)" end="(99, 67)">
                <AtomNode start="(99, 10)" end="(99, 11)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 12)" end="(99, 67)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(99, 12)" end="(99, 13)" leading="" trailing="" val="∀"/>
                  <NullNode start="(99, 13)" end="(99, 24)">
                    <TermExplicitbinderNode start="(99, 13)" end="(99, 24)">
                      <AtomNode start="(99, 13)" end="(99, 14)" leading="" trailing="" val="("/>
                      <NullNode start="(99, 14)" end="(99, 15)">
                        <IdentNode start="(99, 14)" end="(99, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(99, 16)" end="(99, 23)">
                        <AtomNode start="(99, 16)" end="(99, 17)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(99, 18)" end="(99, 23)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(99, 18)" end="(99, 21)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(99, 22)" end="(99, 23)">
                            <IdentNode start="(99, 22)" end="(99, 23)" leading="" trailing="" raw_val="w" val="w"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(99, 23)" end="(99, 24)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(99, 24)" end="(99, 25)" leading="" trailing=" " val=","/>
                  <OtherNode start="(99, 26)" end="(99, 67)" kind="«term_=_»">
                    <OtherNode start="(99, 26)" end="(99, 49)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(99, 26)" end="(99, 45)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(99, 26)" end="(99, 27)" leading="" trailing="" val="("/>
                        <OtherNode start="(99, 27)" end="(99, 44)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(99, 27)" end="(99, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(99, 29)" end="(99, 44)">
                            <IdentNode start="(99, 29)" end="(99, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                            <OtherNode start="(99, 31)" end="(99, 44)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(99, 31)" end="(99, 32)" leading="" trailing="" val="("/>
                              <OtherNode start="(99, 32)" end="(99, 43)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(99, 32)" end="(99, 37)" leading="" trailing=" " raw_val="state" val="state"/>
                                <NullNode start="(99, 38)" end="(99, 43)">
                                  <IdentNode start="(99, 38)" end="(99, 43)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(99, 43)" end="(99, 44)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(99, 44)" end="(99, 45)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(99, 45)" end="(99, 46)" leading="" trailing="" val="."/>
                      <IdentNode start="(99, 46)" end="(99, 49)" leading="" trailing=" " raw_val="fst" val="fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(99, 50)" end="(99, 51)" leading="" trailing=" " val="="/>
                    <OtherNode start="(99, 52)" end="(99, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(99, 52)" end="(99, 57)" leading="" trailing=" " raw_val="state" val="state"/>
                      <NullNode start="(99, 58)" end="(99, 67)">
                        <OtherNode start="(99, 58)" end="(99, 67)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(99, 58)" end="(99, 59)" leading="" trailing="" val="("/>
                          <OtherNode start="(99, 59)" end="(99, 66)" kind="«term_+_»">
                            <IdentNode start="(99, 59)" end="(99, 64)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            <AtomNode start="(99, 64)" end="(99, 65)" leading="" trailing="" val="+"/>
                            <OtherNode start="(99, 65)" end="(99, 66)" kind="num">
                              <AtomNode start="(99, 65)" end="(99, 66)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(99, 66)" end="(99, 67)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(99, 67)" end="(99, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(99, 69)" end="(100, 69)">
            <AtomNode start="(99, 69)" end="(99, 70)" leading="" trailing="&#10;  " val=":"/>
            <OtherNode start="(100, 3)" end="(100, 69)" kind="«term_=_»">
              <OtherNode start="(100, 3)" end="(100, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(100, 3)" end="(100, 10)" leading="" trailing=" " raw_val="getLsbD" val="getLsbD" full_name="BitVec.getLsbD" mod_name="Init.Data.BitVec.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Basic.lean"/>
                <NullNode start="(100, 11)" end="(100, 43)">
                  <OtherNode start="(100, 11)" end="(100, 37)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(100, 11)" end="(100, 33)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(100, 11)" end="(100, 12)" leading="" trailing="" val="("/>
                      <OtherNode start="(100, 12)" end="(100, 32)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(100, 12)" end="(100, 20)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                        <NullNode start="(100, 21)" end="(100, 32)">
                          <IdentNode start="(100, 21)" end="(100, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                          <OtherNode start="(100, 23)" end="(100, 32)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(100, 23)" end="(100, 24)" leading="" trailing="" val="("/>
                            <OtherNode start="(100, 24)" end="(100, 31)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(100, 24)" end="(100, 29)" leading="" trailing=" " raw_val="state" val="state"/>
                              <NullNode start="(100, 30)" end="(100, 31)">
                                <OtherNode start="(100, 30)" end="(100, 31)" kind="num">
                                  <AtomNode start="(100, 30)" end="(100, 31)" leading="" trailing="" val="0"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(100, 31)" end="(100, 32)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(100, 32)" end="(100, 33)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(100, 33)" end="(100, 34)" leading="" trailing="" val="."/>
                    <IdentNode start="(100, 34)" end="(100, 37)" leading="" trailing=" " raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <IdentNode start="(100, 38)" end="(100, 43)" leading="" trailing=" " raw_val="i.val" val="i.val"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(100, 44)" end="(100, 45)" leading="" trailing=" " val="="/>
              <OtherNode start="(100, 46)" end="(100, 69)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(100, 46)" end="(100, 65)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(100, 46)" end="(100, 47)" leading="" trailing="" val="("/>
                  <OtherNode start="(100, 47)" end="(100, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(100, 47)" end="(100, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(100, 49)" end="(100, 64)">
                      <IdentNode start="(100, 49)" end="(100, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(100, 51)" end="(100, 64)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(100, 51)" end="(100, 52)" leading="" trailing="" val="("/>
                        <OtherNode start="(100, 52)" end="(100, 63)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(100, 52)" end="(100, 57)" leading="" trailing=" " raw_val="state" val="state"/>
                          <NullNode start="(100, 58)" end="(100, 63)">
                            <IdentNode start="(100, 58)" end="(100, 63)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(100, 63)" end="(100, 64)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(100, 64)" end="(100, 65)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(100, 65)" end="(100, 66)" leading="" trailing="" val="."/>
                <IdentNode start="(100, 66)" end="(100, 69)" leading="" trailing=" " raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(100, 70)" end="(101, 42)">
          <AtomNode start="(100, 70)" end="(100, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(100, 73)" end="(101, 42)">
            <AtomNode start="(100, 73)" end="(100, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(101, 3)" end="(101, 42)">
              <TacticTacticseq1IndentedNode start="(101, 3)" end="(101, 42)">
                <NullNode start="(101, 3)" end="(101, 42)">
                  <OtherNode start="(101, 3)" end="(101, 42)" kind="Lean.Parser.Tactic.exact" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;i : Fin w&#10;ind : ∀ (i : Fin w), (f i (state ↑i)).fst = state (↑i + 1)&#10;⊢ (iunfoldr f (state 0)).snd.getLsbD ↑i = (f i (state ↑i)).snd" state_after="no goals" tactic="exact (iunfoldr_getLsbD' state ind).1 i">
                    <AtomNode start="(101, 3)" end="(101, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(101, 9)" end="(101, 42)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(101, 9)" end="(101, 40)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(101, 9)" end="(101, 38)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(101, 9)" end="(101, 10)" leading="" trailing="" val="("/>
                          <OtherNode start="(101, 10)" end="(101, 37)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(101, 10)" end="(101, 27)" leading="" trailing=" " raw_val="iunfoldr_getLsbD'" val="iunfoldr_getLsbD'" full_name="BitVec.iunfoldr_getLsbD'" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(58, 9)" def_end="(58, 26)"/>
                            <NullNode start="(101, 28)" end="(101, 37)">
                              <IdentNode start="(101, 28)" end="(101, 33)" leading="" trailing=" " raw_val="state" val="state"/>
                              <IdentNode start="(101, 34)" end="(101, 37)" leading="" trailing="" raw_val="ind" val="ind"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(101, 37)" end="(101, 38)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(101, 38)" end="(101, 39)" leading="" trailing="" val="."/>
                        <OtherNode start="(101, 39)" end="(101, 40)" kind="fieldIdx">
                          <AtomNode start="(101, 39)" end="(101, 40)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <NullNode start="(101, 41)" end="(101, 42)">
                        <IdentNode start="(101, 41)" end="(101, 42)" leading="" trailing="&#10;&#10;" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(103, 1)" end="(116, 50)" name="iunfoldr_replace" full_name="BitVec.iunfoldr_replace">
      <CommandDeclmodifiersNode start="(103, 1)" end="(110, 3)">
        <NullNode start="(103, 1)" end="(110, 3)">
          <CommandDoccommentNode start="(103, 1)" end="(110, 3)" comment="Given a function `state` that provides the correct state for every potential iteration count and a&#10;function that computes these states from the correct initial state, the result of applying&#10;`BitVec.iunfoldr f` to the initial state is the state corresponding to the bitvector's width paired&#10;with the bitvector that consists of each computed bit.&#10;&#10;This theorem can be used to prove properties of functions that are defined using `BitVec.iunfoldr`.&#10;-/">
            <AtomNode start="(103, 1)" end="(103, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(104, 1)" end="(110, 3)" leading="" trailing="&#10;" val="Given a function `state` that provides the correct state for every potential iteration count and a&#10;function that computes these states from the correct initial state, the result of applying&#10;`BitVec.iunfoldr f` to the initial state is the state corresponding to the bitvector's width paired&#10;with the bitvector that consists of each computed bit.&#10;&#10;This theorem can be used to prove properties of functions that are defined using `BitVec.iunfoldr`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(111, 1)" end="(116, 50)" name="iunfoldr_replace" full_name="BitVec.iunfoldr_replace" _is_private_decl="False">
        <AtomNode start="(111, 1)" end="(111, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(111, 9)" end="(111, 25)">
          <IdentNode start="(111, 9)" end="(111, 25)" leading="" trailing="&#10;    " raw_val="iunfoldr_replace" val="iunfoldr_replace"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(112, 5)" end="(115, 36)">
          <NullNode start="(112, 5)" end="(114, 79)">
            <OtherNode start="(112, 5)" end="(112, 31)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(112, 5)" end="(112, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(112, 6)" end="(112, 7)">
                <IdentNode start="(112, 6)" end="(112, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(112, 8)" end="(112, 30)">
                <AtomNode start="(112, 8)" end="(112, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(112, 10)" end="(112, 30)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(112, 10)" end="(112, 15)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(112, 10)" end="(112, 13)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(112, 14)" end="(112, 15)">
                      <IdentNode start="(112, 14)" end="(112, 15)" leading="" trailing=" " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(112, 16)" end="(112, 17)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(112, 18)" end="(112, 30)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(112, 18)" end="(112, 19)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(112, 20)" end="(112, 21)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(112, 22)" end="(112, 30)" kind="«term_×_»">
                      <IdentNode start="(112, 22)" end="(112, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(112, 24)" end="(112, 25)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(112, 26)" end="(112, 30)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(112, 30)" end="(112, 31)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(112, 32)" end="(112, 49)">
              <AtomNode start="(112, 32)" end="(112, 33)" leading="" trailing="" val="("/>
              <NullNode start="(112, 33)" end="(112, 38)">
                <IdentNode start="(112, 33)" end="(112, 38)" leading="" trailing=" " raw_val="state" val="state"/>
              </NullNode>
              <NullNode start="(112, 39)" end="(112, 48)">
                <AtomNode start="(112, 39)" end="(112, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(112, 41)" end="(112, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(112, 41)" end="(112, 44)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(112, 45)" end="(112, 46)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(112, 47)" end="(112, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 48)" end="(112, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(112, 50)" end="(112, 68)">
              <AtomNode start="(112, 50)" end="(112, 51)" leading="" trailing="" val="("/>
              <NullNode start="(112, 51)" end="(112, 56)">
                <IdentNode start="(112, 51)" end="(112, 56)" leading="" trailing=" " raw_val="value" val="value"/>
              </NullNode>
              <NullNode start="(112, 57)" end="(112, 67)">
                <AtomNode start="(112, 57)" end="(112, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(112, 59)" end="(112, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(112, 59)" end="(112, 65)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(112, 66)" end="(112, 67)">
                    <IdentNode start="(112, 66)" end="(112, 67)" leading="" trailing="" raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 67)" end="(112, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(112, 69)" end="(112, 76)">
              <AtomNode start="(112, 69)" end="(112, 70)" leading="" trailing="" val="("/>
              <NullNode start="(112, 70)" end="(112, 71)">
                <IdentNode start="(112, 70)" end="(112, 71)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(112, 72)" end="(112, 75)">
                <AtomNode start="(112, 72)" end="(112, 73)" leading="" trailing=" " val=":"/>
                <IdentNode start="(112, 74)" end="(112, 75)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 75)" end="(112, 76)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(113, 5)" end="(113, 25)">
              <AtomNode start="(113, 5)" end="(113, 6)" leading="" trailing="" val="("/>
              <NullNode start="(113, 6)" end="(113, 10)">
                <IdentNode start="(113, 6)" end="(113, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(113, 11)" end="(113, 24)">
                <AtomNode start="(113, 11)" end="(113, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(113, 13)" end="(113, 24)" kind="«term_=_»">
                  <OtherNode start="(113, 13)" end="(113, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(113, 13)" end="(113, 18)" leading="" trailing=" " raw_val="state" val="state"/>
                    <NullNode start="(113, 19)" end="(113, 20)">
                      <OtherNode start="(113, 19)" end="(113, 20)" kind="num">
                        <AtomNode start="(113, 19)" end="(113, 20)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(113, 21)" end="(113, 22)" leading="" trailing=" " val="="/>
                  <IdentNode start="(113, 23)" end="(113, 24)" leading="" trailing="" raw_val="a" val="a"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(113, 24)" end="(113, 25)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(114, 5)" end="(114, 79)">
              <AtomNode start="(114, 5)" end="(114, 6)" leading="" trailing="" val="("/>
              <NullNode start="(114, 6)" end="(114, 10)">
                <IdentNode start="(114, 6)" end="(114, 10)" leading="" trailing=" " raw_val="step" val="step"/>
              </NullNode>
              <NullNode start="(114, 11)" end="(114, 78)">
                <AtomNode start="(114, 11)" end="(114, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(114, 13)" end="(114, 78)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(114, 13)" end="(114, 14)" leading="" trailing="" val="∀"/>
                  <NullNode start="(114, 14)" end="(114, 25)">
                    <TermExplicitbinderNode start="(114, 14)" end="(114, 25)">
                      <AtomNode start="(114, 14)" end="(114, 15)" leading="" trailing="" val="("/>
                      <NullNode start="(114, 15)" end="(114, 16)">
                        <IdentNode start="(114, 15)" end="(114, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(114, 17)" end="(114, 24)">
                        <AtomNode start="(114, 17)" end="(114, 18)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(114, 19)" end="(114, 24)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(114, 19)" end="(114, 22)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(114, 23)" end="(114, 24)">
                            <IdentNode start="(114, 23)" end="(114, 24)" leading="" trailing="" raw_val="w" val="w"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(114, 24)" end="(114, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(114, 25)" end="(114, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(114, 27)" end="(114, 78)" kind="«term_=_»">
                    <OtherNode start="(114, 27)" end="(114, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(114, 27)" end="(114, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(114, 29)" end="(114, 44)">
                        <IdentNode start="(114, 29)" end="(114, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(114, 31)" end="(114, 44)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(114, 31)" end="(114, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(114, 32)" end="(114, 43)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(114, 32)" end="(114, 37)" leading="" trailing=" " raw_val="state" val="state"/>
                            <NullNode start="(114, 38)" end="(114, 43)">
                              <IdentNode start="(114, 38)" end="(114, 43)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(114, 43)" end="(114, 44)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(114, 45)" end="(114, 46)" leading="" trailing=" " val="="/>
                    <OtherNode start="(114, 47)" end="(114, 78)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(114, 47)" end="(114, 48)" leading="" trailing="" val="("/>
                      <NullNode start="(114, 48)" end="(114, 77)">
                        <OtherNode start="(114, 48)" end="(114, 63)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(114, 48)" end="(114, 53)" leading="" trailing=" " raw_val="state" val="state"/>
                          <NullNode start="(114, 54)" end="(114, 63)">
                            <OtherNode start="(114, 54)" end="(114, 63)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(114, 54)" end="(114, 55)" leading="" trailing="" val="("/>
                              <OtherNode start="(114, 55)" end="(114, 62)" kind="«term_+_»">
                                <IdentNode start="(114, 55)" end="(114, 60)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                <AtomNode start="(114, 60)" end="(114, 61)" leading="" trailing="" val="+"/>
                                <OtherNode start="(114, 61)" end="(114, 62)" kind="num">
                                  <AtomNode start="(114, 61)" end="(114, 62)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(114, 62)" end="(114, 63)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(114, 63)" end="(114, 64)" leading="" trailing=" " val=","/>
                        <NullNode start="(114, 65)" end="(114, 77)">
                          <OtherNode start="(114, 65)" end="(114, 77)" kind="«term__[_]»">
                            <IdentNode start="(114, 65)" end="(114, 70)" leading="" trailing="" raw_val="value" val="value"/>
                            <AtomNode start="(114, 70)" end="(114, 71)" leading="" trailing="" val="["/>
                            <IdentNode start="(114, 71)" end="(114, 76)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            <AtomNode start="(114, 76)" end="(114, 77)" leading="" trailing="" val="]"/>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(114, 77)" end="(114, 78)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(114, 78)" end="(114, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(114, 80)" end="(115, 36)">
            <AtomNode start="(114, 80)" end="(114, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(115, 5)" end="(115, 36)" kind="«term_=_»">
              <OtherNode start="(115, 5)" end="(115, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(115, 5)" end="(115, 13)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                <NullNode start="(115, 14)" end="(115, 17)">
                  <IdentNode start="(115, 14)" end="(115, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(115, 16)" end="(115, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(115, 18)" end="(115, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(115, 20)" end="(115, 36)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(115, 20)" end="(115, 21)" leading="" trailing="" val="("/>
                <NullNode start="(115, 21)" end="(115, 35)">
                  <OtherNode start="(115, 21)" end="(115, 28)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(115, 21)" end="(115, 26)" leading="" trailing=" " raw_val="state" val="state"/>
                    <NullNode start="(115, 27)" end="(115, 28)">
                      <IdentNode start="(115, 27)" end="(115, 28)" leading="" trailing="" raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(115, 28)" end="(115, 29)" leading="" trailing=" " val=","/>
                  <NullNode start="(115, 30)" end="(115, 35)">
                    <IdentNode start="(115, 30)" end="(115, 35)" leading="" trailing="" raw_val="value" val="value"/>
                  </NullNode>
                </NullNode>
                <AtomNode start="(115, 35)" end="(115, 36)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(115, 37)" end="(116, 50)">
          <AtomNode start="(115, 37)" end="(115, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(115, 40)" end="(116, 50)">
            <AtomNode start="(115, 40)" end="(115, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(116, 3)" end="(116, 50)">
              <TacticTacticseq1IndentedNode start="(116, 3)" end="(116, 50)">
                <NullNode start="(116, 3)" end="(116, 50)">
                  <OtherNode start="(116, 3)" end="(116, 50)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value[↑i])&#10;⊢ iunfoldr f a = (state w, value)" state_after="no goals" tactic="simp [iunfoldr.eq_test state value a init step]">
                    <AtomNode start="(116, 3)" end="(116, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(116, 8)" end="(116, 50)">
                      <AtomNode start="(116, 8)" end="(116, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(116, 9)" end="(116, 49)">
                        <OtherNode start="(116, 9)" end="(116, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(116, 9)" end="(116, 49)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(116, 9)" end="(116, 25)" leading="" trailing=" " raw_val="iunfoldr.eq_test" val="iunfoldr.eq_test" full_name="_private.Init.Data.BitVec.Folds.0.BitVec.iunfoldr.eq_test" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(46, 17)" def_end="(46, 33)"/>
                            <NullNode start="(116, 26)" end="(116, 49)">
                              <IdentNode start="(116, 26)" end="(116, 31)" leading="" trailing=" " raw_val="state" val="state"/>
                              <IdentNode start="(116, 32)" end="(116, 37)" leading="" trailing=" " raw_val="value" val="value"/>
                              <IdentNode start="(116, 38)" end="(116, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(116, 40)" end="(116, 44)" leading="" trailing=" " raw_val="init" val="init"/>
                              <IdentNode start="(116, 45)" end="(116, 49)" leading="" trailing="" raw_val="step" val="step"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(116, 49)" end="(116, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(118, 1)" end="(123, 50)" name="iunfoldr_replace_snd" full_name="BitVec.iunfoldr_replace_snd">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(118, 1)" end="(123, 50)" name="iunfoldr_replace_snd" full_name="BitVec.iunfoldr_replace_snd" _is_private_decl="False">
        <AtomNode start="(118, 1)" end="(118, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(118, 9)" end="(118, 29)">
          <IdentNode start="(118, 9)" end="(118, 29)" leading="" trailing="&#10;  " raw_val="iunfoldr_replace_snd" val="iunfoldr_replace_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(119, 3)" end="(122, 31)">
          <NullNode start="(119, 3)" end="(121, 79)">
            <OtherNode start="(119, 3)" end="(119, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(119, 3)" end="(119, 4)" leading="" trailing="" val="{"/>
              <NullNode start="(119, 4)" end="(119, 5)">
                <IdentNode start="(119, 4)" end="(119, 5)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(119, 6)" end="(119, 28)">
                <AtomNode start="(119, 6)" end="(119, 7)" leading="" trailing=" " val=":"/>
                <OtherNode start="(119, 8)" end="(119, 28)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(119, 8)" end="(119, 13)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(119, 8)" end="(119, 11)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(119, 12)" end="(119, 13)">
                      <IdentNode start="(119, 12)" end="(119, 13)" leading="" trailing=" " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(119, 14)" end="(119, 15)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(119, 16)" end="(119, 28)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(119, 16)" end="(119, 17)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(119, 18)" end="(119, 19)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(119, 20)" end="(119, 28)" kind="«term_×_»">
                      <IdentNode start="(119, 20)" end="(119, 21)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(119, 22)" end="(119, 23)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(119, 24)" end="(119, 28)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(119, 28)" end="(119, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(119, 30)" end="(119, 47)">
              <AtomNode start="(119, 30)" end="(119, 31)" leading="" trailing="" val="("/>
              <NullNode start="(119, 31)" end="(119, 36)">
                <IdentNode start="(119, 31)" end="(119, 36)" leading="" trailing=" " raw_val="state" val="state"/>
              </NullNode>
              <NullNode start="(119, 37)" end="(119, 46)">
                <AtomNode start="(119, 37)" end="(119, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(119, 39)" end="(119, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(119, 39)" end="(119, 42)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(119, 43)" end="(119, 44)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(119, 45)" end="(119, 46)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(119, 46)" end="(119, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(119, 48)" end="(119, 66)">
              <AtomNode start="(119, 48)" end="(119, 49)" leading="" trailing="" val="("/>
              <NullNode start="(119, 49)" end="(119, 54)">
                <IdentNode start="(119, 49)" end="(119, 54)" leading="" trailing=" " raw_val="value" val="value"/>
              </NullNode>
              <NullNode start="(119, 55)" end="(119, 65)">
                <AtomNode start="(119, 55)" end="(119, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(119, 57)" end="(119, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(119, 57)" end="(119, 63)" leading="" trailing=" " raw_val="BitVec" val="BitVec" full_name="BitVec" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(119, 64)" end="(119, 65)">
                    <IdentNode start="(119, 64)" end="(119, 65)" leading="" trailing="" raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(119, 65)" end="(119, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(119, 67)" end="(119, 74)">
              <AtomNode start="(119, 67)" end="(119, 68)" leading="" trailing="" val="("/>
              <NullNode start="(119, 68)" end="(119, 69)">
                <IdentNode start="(119, 68)" end="(119, 69)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(119, 70)" end="(119, 73)">
                <AtomNode start="(119, 70)" end="(119, 71)" leading="" trailing=" " val=":"/>
                <IdentNode start="(119, 72)" end="(119, 73)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(119, 73)" end="(119, 74)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(120, 5)" end="(120, 25)">
              <AtomNode start="(120, 5)" end="(120, 6)" leading="" trailing="" val="("/>
              <NullNode start="(120, 6)" end="(120, 10)">
                <IdentNode start="(120, 6)" end="(120, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(120, 11)" end="(120, 24)">
                <AtomNode start="(120, 11)" end="(120, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(120, 13)" end="(120, 24)" kind="«term_=_»">
                  <OtherNode start="(120, 13)" end="(120, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(120, 13)" end="(120, 18)" leading="" trailing=" " raw_val="state" val="state"/>
                    <NullNode start="(120, 19)" end="(120, 20)">
                      <OtherNode start="(120, 19)" end="(120, 20)" kind="num">
                        <AtomNode start="(120, 19)" end="(120, 20)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(120, 21)" end="(120, 22)" leading="" trailing=" " val="="/>
                  <IdentNode start="(120, 23)" end="(120, 24)" leading="" trailing="" raw_val="a" val="a"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(120, 24)" end="(120, 25)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(121, 5)" end="(121, 79)">
              <AtomNode start="(121, 5)" end="(121, 6)" leading="" trailing="" val="("/>
              <NullNode start="(121, 6)" end="(121, 10)">
                <IdentNode start="(121, 6)" end="(121, 10)" leading="" trailing=" " raw_val="step" val="step"/>
              </NullNode>
              <NullNode start="(121, 11)" end="(121, 78)">
                <AtomNode start="(121, 11)" end="(121, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 13)" end="(121, 78)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(121, 13)" end="(121, 14)" leading="" trailing="" val="∀"/>
                  <NullNode start="(121, 14)" end="(121, 25)">
                    <TermExplicitbinderNode start="(121, 14)" end="(121, 25)">
                      <AtomNode start="(121, 14)" end="(121, 15)" leading="" trailing="" val="("/>
                      <NullNode start="(121, 15)" end="(121, 16)">
                        <IdentNode start="(121, 15)" end="(121, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(121, 17)" end="(121, 24)">
                        <AtomNode start="(121, 17)" end="(121, 18)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(121, 19)" end="(121, 24)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(121, 19)" end="(121, 22)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(121, 23)" end="(121, 24)">
                            <IdentNode start="(121, 23)" end="(121, 24)" leading="" trailing="" raw_val="w" val="w"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(121, 24)" end="(121, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(121, 25)" end="(121, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(121, 27)" end="(121, 78)" kind="«term_=_»">
                    <OtherNode start="(121, 27)" end="(121, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(121, 27)" end="(121, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(121, 29)" end="(121, 44)">
                        <IdentNode start="(121, 29)" end="(121, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(121, 31)" end="(121, 44)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(121, 31)" end="(121, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(121, 32)" end="(121, 43)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(121, 32)" end="(121, 37)" leading="" trailing=" " raw_val="state" val="state"/>
                            <NullNode start="(121, 38)" end="(121, 43)">
                              <IdentNode start="(121, 38)" end="(121, 43)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(121, 43)" end="(121, 44)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(121, 45)" end="(121, 46)" leading="" trailing=" " val="="/>
                    <OtherNode start="(121, 47)" end="(121, 78)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(121, 47)" end="(121, 48)" leading="" trailing="" val="("/>
                      <NullNode start="(121, 48)" end="(121, 77)">
                        <OtherNode start="(121, 48)" end="(121, 63)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(121, 48)" end="(121, 53)" leading="" trailing=" " raw_val="state" val="state"/>
                          <NullNode start="(121, 54)" end="(121, 63)">
                            <OtherNode start="(121, 54)" end="(121, 63)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(121, 54)" end="(121, 55)" leading="" trailing="" val="("/>
                              <OtherNode start="(121, 55)" end="(121, 62)" kind="«term_+_»">
                                <IdentNode start="(121, 55)" end="(121, 60)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                                <AtomNode start="(121, 60)" end="(121, 61)" leading="" trailing="" val="+"/>
                                <OtherNode start="(121, 61)" end="(121, 62)" kind="num">
                                  <AtomNode start="(121, 61)" end="(121, 62)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(121, 62)" end="(121, 63)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(121, 63)" end="(121, 64)" leading="" trailing=" " val=","/>
                        <NullNode start="(121, 65)" end="(121, 77)">
                          <OtherNode start="(121, 65)" end="(121, 77)" kind="«term__[_]»">
                            <IdentNode start="(121, 65)" end="(121, 70)" leading="" trailing="" raw_val="value" val="value"/>
                            <AtomNode start="(121, 70)" end="(121, 71)" leading="" trailing="" val="["/>
                            <IdentNode start="(121, 71)" end="(121, 76)" leading="" trailing="" raw_val="i.val" val="i.val"/>
                            <AtomNode start="(121, 76)" end="(121, 77)" leading="" trailing="" val="]"/>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(121, 77)" end="(121, 78)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(121, 78)" end="(121, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(121, 80)" end="(122, 31)">
            <AtomNode start="(121, 80)" end="(121, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(122, 5)" end="(122, 31)" kind="«term_=_»">
              <OtherNode start="(122, 5)" end="(122, 23)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(122, 5)" end="(122, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(122, 5)" end="(122, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(122, 6)" end="(122, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(122, 6)" end="(122, 14)" leading="" trailing=" " raw_val="iunfoldr" val="iunfoldr" full_name="BitVec.iunfoldr" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(29, 5)" def_end="(29, 13)"/>
                    <NullNode start="(122, 15)" end="(122, 18)">
                      <IdentNode start="(122, 15)" end="(122, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(122, 17)" end="(122, 18)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(122, 18)" end="(122, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(122, 19)" end="(122, 20)" leading="" trailing="" val="."/>
                <IdentNode start="(122, 20)" end="(122, 23)" leading="" trailing=" " raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(122, 24)" end="(122, 25)" leading="" trailing=" " val="="/>
              <IdentNode start="(122, 26)" end="(122, 31)" leading="" trailing=" " raw_val="value" val="value"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(122, 32)" end="(123, 50)">
          <AtomNode start="(122, 32)" end="(122, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(122, 35)" end="(123, 50)">
            <AtomNode start="(122, 35)" end="(122, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(123, 3)" end="(123, 50)">
              <TacticTacticseq1IndentedNode start="(123, 3)" end="(123, 50)">
                <NullNode start="(123, 3)" end="(123, 50)">
                  <OtherNode start="(123, 3)" end="(123, 50)" kind="Lean.Parser.Tactic.simp" state_before="w : Nat&#10;α : Type u_1&#10;f : Fin w → α → α × Bool&#10;state : Nat → α&#10;value : BitVec w&#10;a : α&#10;init : state 0 = a&#10;step : ∀ (i : Fin w), f i (state ↑i) = (state (↑i + 1), value[↑i])&#10;⊢ (iunfoldr f a).snd = value" state_after="no goals" tactic="simp [iunfoldr.eq_test state value a init step]">
                    <AtomNode start="(123, 3)" end="(123, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(123, 8)" end="(123, 50)">
                      <AtomNode start="(123, 8)" end="(123, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(123, 9)" end="(123, 49)">
                        <OtherNode start="(123, 9)" end="(123, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(123, 9)" end="(123, 49)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(123, 9)" end="(123, 25)" leading="" trailing=" " raw_val="iunfoldr.eq_test" val="iunfoldr.eq_test" full_name="_private.Init.Data.BitVec.Folds.0.BitVec.iunfoldr.eq_test" mod_name="Init.Data.BitVec.Folds" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BitVec/Folds.lean" def_start="(46, 17)" def_end="(46, 33)"/>
                            <NullNode start="(123, 26)" end="(123, 49)">
                              <IdentNode start="(123, 26)" end="(123, 31)" leading="" trailing=" " raw_val="state" val="state"/>
                              <IdentNode start="(123, 32)" end="(123, 37)" leading="" trailing=" " raw_val="value" val="value"/>
                              <IdentNode start="(123, 38)" end="(123, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(123, 40)" end="(123, 44)" leading="" trailing=" " raw_val="init" val="init"/>
                              <IdentNode start="(123, 45)" end="(123, 49)" leading="" trailing="" raw_val="step" val="step"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(123, 49)" end="(123, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(125, 1)" end="(125, 11)" name="BitVec">
      <AtomNode start="(125, 1)" end="(125, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(125, 5)" end="(125, 11)">
        <IdentNode start="(125, 5)" end="(125, 11)" leading="" trailing="&#10;" raw_val="BitVec" val="BitVec"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(17, 1)" end="(28, 3)" text="Constructs a bitvector by iteratively computing a state for each bit using the function `f`,&#10;starting with the initial state `s`. At each step, the prior state and the current bit index are&#10;passed to `f`, and it produces a bit along with the next state value. These bits are assembled into&#10;the final bitvector.&#10;&#10;It produces a sequence of state values `[s_0, s_1 .. s_w]` and a bitvector `v` where `f i s_i =&#10;(s_{i+1}, b_i)` and `b_i` is bit `i`th least-significant bit in `v` (e.g., `getLsb v i = b_i`).&#10;&#10;The theorem `iunfoldr_replace` allows uses of `BitVec.iunfoldr` to be replaced wiht declarative&#10;specifications that are easier to reason about.&#10;-/"/>
    <Comment start="(103, 1)" end="(110, 3)" text="Given a function `state` that provides the correct state for every potential iteration count and a&#10;function that computes these states from the correct initial state, the result of applying&#10;`BitVec.iunfoldr f` to the initial state is the state corresponding to the bitvector's width paired&#10;with the bitvector that consists of each computed bit.&#10;&#10;This theorem can be used to prove properties of functions that are defined using `BitVec.iunfoldr`.&#10;-/"/>
  </Comments>
</TracedFile>
