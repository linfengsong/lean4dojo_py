<TracedFile path="src/lean/Init/Data/Array/Extract.lean" md5="77c9de98613acffe463130ea7c8631ac">
  <FileNode start="(1, 1)" end="(447, 10)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 35)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 35)">
        <ModuleImportNode start="(9, 1)" end="(9, 30)" module="Init.Data.Array.Lemmas" path="src/lean/Init/Data/Array/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Lemmas" val="Init.Data.Array.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 35)" module="Init.Data.List.Nat.TakeDrop" path="src/lean/Init/Data/List/Nat/TakeDrop.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 35)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Nat.TakeDrop" val="Init.Data.List.Nat.TakeDrop"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(12, 1)" end="(16, 3)" comment="# Lemmas about `Array.extract`&#10;&#10;This file follows the contents of `Init.Data.List.TakeDrop` and `Init.Data.List.Nat.TakeDrop`.&#10;-/">
      <AtomNode start="(12, 1)" end="(12, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(13, 1)" end="(16, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `Array.extract`&#10;&#10;This file follows the contents of `Init.Data.List.TakeDrop` and `Init.Data.List.Nat.TakeDrop`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(18, 1)" end="(18, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(18, 1)" end="(18, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(18, 12)" end="(18, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(18, 33)" end="(18, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(19, 1)" end="(19, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(19, 1)" end="(19, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(19, 12)" end="(19, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(19, 34)" end="(19, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandOpenNode start="(21, 1)" end="(21, 9)">
      <AtomNode start="(21, 1)" end="(21, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(21, 6)" end="(21, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(21, 6)" end="(21, 9)">
          <IdentNode start="(21, 6)" end="(21, 9)" leading="" trailing="&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandNamespaceNode start="(22, 1)" end="(22, 16)" name="Array">
      <AtomNode start="(22, 1)" end="(22, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(22, 11)" end="(22, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(24, 1)" end="(24, 19)" comment="### extract -/">
      <AtomNode start="(24, 1)" end="(24, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(24, 5)" end="(24, 19)" leading="" trailing="&#10;&#10;" val="### extract -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(26, 1)" end="(32, 13)" name="extract_of_size_lt" full_name="Array.extract_of_size_lt">
      <CommandDeclmodifiersNode start="(26, 1)" end="(26, 8)">
        <NullNode/>
        <NullNode start="(26, 1)" end="(26, 8)">
          <OtherNode start="(26, 1)" end="(26, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(26, 1)" end="(26, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(26, 3)" end="(26, 7)">
              <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(26, 3)" end="(26, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(26, 7)" end="(26, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(26, 9)" end="(32, 13)" name="extract_of_size_lt" full_name="Array.extract_of_size_lt" _is_private_decl="False">
        <AtomNode start="(26, 9)" end="(26, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(26, 17)" end="(26, 35)">
          <IdentNode start="(26, 17)" end="(26, 35)" leading="" trailing=" " raw_val="extract_of_size_lt" val="extract_of_size_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(26, 36)" end="(27, 42)">
          <NullNode start="(26, 36)" end="(26, 80)">
            <OtherNode start="(26, 36)" end="(26, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(26, 36)" end="(26, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(26, 37)" end="(26, 39)">
                <IdentNode start="(26, 37)" end="(26, 39)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(26, 40)" end="(26, 49)">
                <AtomNode start="(26, 40)" end="(26, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(26, 42)" end="(26, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(26, 42)" end="(26, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(26, 48)" end="(26, 49)">
                    <IdentNode start="(26, 48)" end="(26, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(26, 49)" end="(26, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(26, 51)" end="(26, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(26, 51)" end="(26, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(26, 52)" end="(26, 55)">
                <IdentNode start="(26, 52)" end="(26, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(26, 54)" end="(26, 55)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(26, 56)" end="(26, 61)">
                <AtomNode start="(26, 56)" end="(26, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(26, 58)" end="(26, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(26, 61)" end="(26, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(26, 63)" end="(26, 80)">
              <AtomNode start="(26, 63)" end="(26, 64)" leading="" trailing="" val="("/>
              <NullNode start="(26, 64)" end="(26, 65)">
                <IdentNode start="(26, 64)" end="(26, 65)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(26, 66)" end="(26, 79)">
                <AtomNode start="(26, 66)" end="(26, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(26, 68)" end="(26, 79)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(26, 68)" end="(26, 75)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                  <AtomNode start="(26, 76)" end="(26, 77)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(26, 78)" end="(26, 79)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(26, 79)" end="(26, 80)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(26, 81)" end="(27, 42)">
            <AtomNode start="(26, 81)" end="(26, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(27, 5)" end="(27, 42)" kind="«term_=_»">
              <OtherNode start="(27, 5)" end="(27, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(27, 5)" end="(27, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(27, 16)" end="(27, 19)">
                  <IdentNode start="(27, 16)" end="(27, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(27, 18)" end="(27, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(27, 20)" end="(27, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(27, 22)" end="(27, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(27, 22)" end="(27, 32)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(27, 33)" end="(27, 42)">
                  <IdentNode start="(27, 33)" end="(27, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(27, 35)" end="(27, 42)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(27, 43)" end="(32, 13)">
          <AtomNode start="(27, 43)" end="(27, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(27, 46)" end="(32, 13)">
            <AtomNode start="(27, 46)" end="(27, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(28, 3)" end="(32, 13)">
              <TacticTacticseq1IndentedNode start="(28, 3)" end="(32, 13)">
                <NullNode start="(28, 3)" end="(32, 13)">
                  <OtherNode start="(28, 3)" end="(28, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;⊢ as.extract i j = as.extract i" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;⊢ (as.extract i j).size = (as.extract i).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i).size&#10;⊢ (as.extract i j)[l] = (as.extract i)[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(28, 3)" end="(28, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(28, 7)" end="(28, 14)">
                      <OtherNode start="(28, 7)" end="(28, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(28, 7)" end="(28, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(28, 7)" end="(28, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(28, 9)" end="(28, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(28, 9)" end="(28, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(28, 9)" end="(28, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(28, 12)" end="(28, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(28, 12)" end="(28, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(28, 12)" end="(28, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(29, 3)" end="(30, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;⊢ (as.extract i j).size = (as.extract i).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i).size&#10;⊢ (as.extract i j)[l] = (as.extract i)[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i).size&#10;⊢ (as.extract i j)[l] = (as.extract i)[l]" tactic="· simp&#10;  omega">
                    <OtherNode start="(29, 3)" end="(29, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(29, 3)" end="(29, 4)" kind="patternIgnore">
                        <OtherNode start="(29, 3)" end="(29, 4)" kind="token.«· »">
                          <AtomNode start="(29, 3)" end="(29, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(29, 5)" end="(30, 10)">
                      <TacticTacticseq1IndentedNode start="(29, 5)" end="(30, 10)">
                        <NullNode start="(29, 5)" end="(30, 10)">
                          <OtherNode start="(29, 5)" end="(29, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;⊢ (as.extract i j).size = (as.extract i).size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;⊢ min j as.size - i = as.size - i" tactic="simp">
                            <AtomNode start="(29, 5)" end="(29, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(30, 5)" end="(30, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;⊢ min j as.size - i = as.size - i" state_after="no goals" tactic="omega">
                            <AtomNode start="(30, 5)" end="(30, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(31, 3)" end="(32, 13)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i).size&#10;⊢ (as.extract i j)[l] = (as.extract i)[l]" state_after="no goals" tactic="· simp only [size_extract] at h₁ h₂&#10;  simp [h]">
                    <OtherNode start="(31, 3)" end="(31, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(31, 3)" end="(31, 4)" kind="patternIgnore">
                        <OtherNode start="(31, 3)" end="(31, 4)" kind="token.«· »">
                          <AtomNode start="(31, 3)" end="(31, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(31, 5)" end="(32, 13)">
                      <TacticTacticseq1IndentedNode start="(31, 5)" end="(32, 13)">
                        <NullNode start="(31, 5)" end="(32, 13)">
                          <OtherNode start="(31, 5)" end="(31, 38)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i).size&#10;⊢ (as.extract i j)[l] = (as.extract i)[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min as.size as.size - i&#10;⊢ (as.extract i j)[l] = (as.extract i)[l]" tactic="simp only [size_extract] at h₁ h₂">
                            <AtomNode start="(31, 5)" end="(31, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(31, 10)" end="(31, 14)">
                              <AtomNode start="(31, 10)" end="(31, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(31, 15)" end="(31, 29)">
                              <AtomNode start="(31, 15)" end="(31, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(31, 16)" end="(31, 28)">
                                <OtherNode start="(31, 16)" end="(31, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(31, 16)" end="(31, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(31, 28)" end="(31, 29)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(31, 30)" end="(31, 38)">
                              <OtherNode start="(31, 30)" end="(31, 38)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(31, 30)" end="(31, 32)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(31, 33)" end="(31, 38)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(31, 33)" end="(31, 38)">
                                    <IdentNode start="(31, 33)" end="(31, 35)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(31, 36)" end="(31, 38)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(32, 5)" end="(32, 13)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as.size &amp;lt; j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min as.size as.size - i&#10;⊢ (as.extract i j)[l] = (as.extract i)[l]" state_after="no goals" tactic="simp [h]">
                            <AtomNode start="(32, 5)" end="(32, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(32, 10)" end="(32, 13)">
                              <AtomNode start="(32, 10)" end="(32, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(32, 11)" end="(32, 12)">
                                <OtherNode start="(32, 11)" end="(32, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(32, 11)" end="(32, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(32, 12)" end="(32, 13)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(34, 1)" end="(37, 8)" name="size_extract_le" full_name="Array.size_extract_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(34, 1)" end="(37, 8)" name="size_extract_le" full_name="Array.size_extract_le" _is_private_decl="False">
        <AtomNode start="(34, 1)" end="(34, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(34, 9)" end="(34, 24)">
          <IdentNode start="(34, 9)" end="(34, 24)" leading="" trailing=" " raw_val="size_extract_le" val="size_extract_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(34, 25)" end="(35, 34)">
          <NullNode start="(34, 25)" end="(34, 51)">
            <OtherNode start="(34, 25)" end="(34, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 25)" end="(34, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 26)" end="(34, 28)">
                <IdentNode start="(34, 26)" end="(34, 28)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(34, 29)" end="(34, 38)">
                <AtomNode start="(34, 29)" end="(34, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 31)" end="(34, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(34, 31)" end="(34, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(34, 37)" end="(34, 38)">
                    <IdentNode start="(34, 37)" end="(34, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(34, 38)" end="(34, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(34, 40)" end="(34, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 40)" end="(34, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 41)" end="(34, 44)">
                <IdentNode start="(34, 41)" end="(34, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(34, 43)" end="(34, 44)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(34, 45)" end="(34, 50)">
                <AtomNode start="(34, 45)" end="(34, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(34, 47)" end="(34, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(34, 50)" end="(34, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(34, 52)" end="(35, 34)">
            <AtomNode start="(34, 52)" end="(34, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(35, 5)" end="(35, 34)" kind="«term_≤_»">
              <OtherNode start="(35, 5)" end="(35, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(35, 5)" end="(35, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(35, 5)" end="(35, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(35, 6)" end="(35, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(35, 6)" end="(35, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(35, 17)" end="(35, 20)">
                      <IdentNode start="(35, 17)" end="(35, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(35, 19)" end="(35, 20)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(35, 20)" end="(35, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(35, 21)" end="(35, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(35, 22)" end="(35, 26)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(35, 27)" end="(35, 28)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(35, 29)" end="(35, 34)" kind="«term_-_»">
                <IdentNode start="(35, 29)" end="(35, 30)" leading="" trailing=" " raw_val="j" val="j"/>
                <AtomNode start="(35, 31)" end="(35, 32)" leading="" trailing=" " val="-"/>
                <IdentNode start="(35, 33)" end="(35, 34)" leading="" trailing=" " raw_val="i" val="i"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(35, 35)" end="(37, 8)">
          <AtomNode start="(35, 35)" end="(35, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(35, 38)" end="(37, 8)">
            <AtomNode start="(35, 38)" end="(35, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(36, 3)" end="(37, 8)">
              <TacticTacticseq1IndentedNode start="(36, 3)" end="(37, 8)">
                <NullNode start="(36, 3)" end="(37, 8)">
                  <OtherNode start="(36, 3)" end="(36, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.extract i j).size ≤ j - i" state_after="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ min j as.size ≤ j - i + i" tactic="simp">
                    <AtomNode start="(36, 3)" end="(36, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(37, 3)" end="(37, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ min j as.size ≤ j - i + i" state_after="no goals" tactic="omega">
                    <AtomNode start="(37, 3)" end="(37, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(39, 1)" end="(42, 8)" name="size_extract_le'" full_name="Array.size_extract_le'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(39, 1)" end="(42, 8)" name="size_extract_le'" full_name="Array.size_extract_le'" _is_private_decl="False">
        <AtomNode start="(39, 1)" end="(39, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(39, 9)" end="(39, 25)">
          <IdentNode start="(39, 9)" end="(39, 25)" leading="" trailing=" " raw_val="size_extract_le'" val="size_extract_le'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(39, 26)" end="(40, 40)">
          <NullNode start="(39, 26)" end="(39, 52)">
            <OtherNode start="(39, 26)" end="(39, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(39, 26)" end="(39, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(39, 27)" end="(39, 29)">
                <IdentNode start="(39, 27)" end="(39, 29)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(39, 30)" end="(39, 39)">
                <AtomNode start="(39, 30)" end="(39, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 32)" end="(39, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(39, 32)" end="(39, 37)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(39, 38)" end="(39, 39)">
                    <IdentNode start="(39, 38)" end="(39, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(39, 39)" end="(39, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(39, 41)" end="(39, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(39, 41)" end="(39, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(39, 42)" end="(39, 45)">
                <IdentNode start="(39, 42)" end="(39, 43)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(39, 44)" end="(39, 45)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(39, 46)" end="(39, 51)">
                <AtomNode start="(39, 46)" end="(39, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(39, 48)" end="(39, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(39, 51)" end="(39, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(39, 53)" end="(40, 40)">
            <AtomNode start="(39, 53)" end="(39, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(40, 5)" end="(40, 40)" kind="«term_≤_»">
              <OtherNode start="(40, 5)" end="(40, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(40, 5)" end="(40, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(40, 5)" end="(40, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(40, 6)" end="(40, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 6)" end="(40, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(40, 17)" end="(40, 20)">
                      <IdentNode start="(40, 17)" end="(40, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(40, 19)" end="(40, 20)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(40, 20)" end="(40, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(40, 21)" end="(40, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(40, 22)" end="(40, 26)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(40, 27)" end="(40, 28)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(40, 29)" end="(40, 40)" kind="«term_-_»">
                <IdentNode start="(40, 29)" end="(40, 36)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                <AtomNode start="(40, 37)" end="(40, 38)" leading="" trailing=" " val="-"/>
                <IdentNode start="(40, 39)" end="(40, 40)" leading="" trailing=" " raw_val="i" val="i"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(40, 41)" end="(42, 8)">
          <AtomNode start="(40, 41)" end="(40, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(40, 44)" end="(42, 8)">
            <AtomNode start="(40, 44)" end="(40, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(41, 3)" end="(42, 8)">
              <TacticTacticseq1IndentedNode start="(41, 3)" end="(42, 8)">
                <NullNode start="(41, 3)" end="(42, 8)">
                  <OtherNode start="(41, 3)" end="(41, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.extract i j).size ≤ as.size - i" state_after="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ min j as.size ≤ as.size - i + i" tactic="simp">
                    <AtomNode start="(41, 3)" end="(41, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(42, 3)" end="(42, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ min j as.size ≤ as.size - i + i" state_after="no goals" tactic="omega">
                    <AtomNode start="(42, 3)" end="(42, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(44, 1)" end="(47, 8)" name="size_extract_of_le" full_name="Array.size_extract_of_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(44, 1)" end="(47, 8)" name="size_extract_of_le" full_name="Array.size_extract_of_le" _is_private_decl="False">
        <AtomNode start="(44, 1)" end="(44, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(44, 9)" end="(44, 27)">
          <IdentNode start="(44, 9)" end="(44, 27)" leading="" trailing=" " raw_val="size_extract_of_le" val="size_extract_of_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(44, 28)" end="(45, 34)">
          <NullNode start="(44, 28)" end="(44, 72)">
            <OtherNode start="(44, 28)" end="(44, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(44, 28)" end="(44, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(44, 29)" end="(44, 31)">
                <IdentNode start="(44, 29)" end="(44, 31)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(44, 32)" end="(44, 41)">
                <AtomNode start="(44, 32)" end="(44, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(44, 34)" end="(44, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(44, 34)" end="(44, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(44, 40)" end="(44, 41)">
                    <IdentNode start="(44, 40)" end="(44, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(44, 41)" end="(44, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(44, 43)" end="(44, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(44, 43)" end="(44, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(44, 44)" end="(44, 47)">
                <IdentNode start="(44, 44)" end="(44, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(44, 46)" end="(44, 47)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(44, 48)" end="(44, 53)">
                <AtomNode start="(44, 48)" end="(44, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(44, 50)" end="(44, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(44, 53)" end="(44, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(44, 55)" end="(44, 72)">
              <AtomNode start="(44, 55)" end="(44, 56)" leading="" trailing="" val="("/>
              <NullNode start="(44, 56)" end="(44, 57)">
                <IdentNode start="(44, 56)" end="(44, 57)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(44, 58)" end="(44, 71)">
                <AtomNode start="(44, 58)" end="(44, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(44, 60)" end="(44, 71)" kind="«term_≤_»">
                  <IdentNode start="(44, 60)" end="(44, 61)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(44, 62)" end="(44, 63)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(44, 64)" end="(44, 71)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(44, 71)" end="(44, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(44, 73)" end="(45, 34)">
            <AtomNode start="(44, 73)" end="(44, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(45, 5)" end="(45, 34)" kind="«term_=_»">
              <OtherNode start="(45, 5)" end="(45, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(45, 5)" end="(45, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(45, 5)" end="(45, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(45, 6)" end="(45, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(45, 6)" end="(45, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(45, 17)" end="(45, 20)">
                      <IdentNode start="(45, 17)" end="(45, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(45, 19)" end="(45, 20)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(45, 20)" end="(45, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(45, 21)" end="(45, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(45, 22)" end="(45, 26)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(45, 27)" end="(45, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(45, 29)" end="(45, 34)" kind="«term_-_»">
                <IdentNode start="(45, 29)" end="(45, 30)" leading="" trailing=" " raw_val="j" val="j"/>
                <AtomNode start="(45, 31)" end="(45, 32)" leading="" trailing=" " val="-"/>
                <IdentNode start="(45, 33)" end="(45, 34)" leading="" trailing=" " raw_val="i" val="i"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(45, 35)" end="(47, 8)">
          <AtomNode start="(45, 35)" end="(45, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(45, 38)" end="(47, 8)">
            <AtomNode start="(45, 38)" end="(45, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(46, 3)" end="(47, 8)">
              <TacticTacticseq1IndentedNode start="(46, 3)" end="(47, 8)">
                <NullNode start="(46, 3)" end="(47, 8)">
                  <OtherNode start="(46, 3)" end="(46, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;⊢ (as.extract i j).size = j - i" state_after="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;⊢ min j as.size - i = j - i" tactic="simp">
                    <AtomNode start="(46, 3)" end="(46, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(47, 3)" end="(47, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;⊢ min j as.size - i = j - i" state_after="no goals" tactic="omega">
                    <AtomNode start="(47, 3)" end="(47, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(49, 1)" end="(57, 28)" name="extract_push" full_name="Array.extract_push">
      <CommandDeclmodifiersNode start="(49, 1)" end="(49, 8)">
        <NullNode/>
        <NullNode start="(49, 1)" end="(49, 8)">
          <OtherNode start="(49, 1)" end="(49, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(49, 1)" end="(49, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(49, 3)" end="(49, 7)">
              <OtherNode start="(49, 3)" end="(49, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(49, 3)" end="(49, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(49, 3)" end="(49, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(49, 7)" end="(49, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(50, 1)" end="(57, 28)" name="extract_push" full_name="Array.extract_push" _is_private_decl="False">
        <AtomNode start="(50, 1)" end="(50, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(50, 9)" end="(50, 21)">
          <IdentNode start="(50, 9)" end="(50, 21)" leading="" trailing=" " raw_val="extract_push" val="extract_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(50, 22)" end="(51, 59)">
          <NullNode start="(50, 22)" end="(50, 84)">
            <OtherNode start="(50, 22)" end="(50, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 22)" end="(50, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 23)" end="(50, 25)">
                <IdentNode start="(50, 23)" end="(50, 25)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(50, 26)" end="(50, 35)">
                <AtomNode start="(50, 26)" end="(50, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 28)" end="(50, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(50, 28)" end="(50, 33)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(50, 34)" end="(50, 35)">
                    <IdentNode start="(50, 34)" end="(50, 35)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(50, 35)" end="(50, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(50, 37)" end="(50, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 37)" end="(50, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 38)" end="(50, 39)">
                <IdentNode start="(50, 38)" end="(50, 39)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(50, 40)" end="(50, 43)">
                <AtomNode start="(50, 40)" end="(50, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(50, 42)" end="(50, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(50, 43)" end="(50, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(50, 45)" end="(50, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 45)" end="(50, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 46)" end="(50, 56)">
                <IdentNode start="(50, 46)" end="(50, 51)" leading="" trailing=" " raw_val="start" val="start"/>
                <IdentNode start="(50, 52)" end="(50, 56)" leading="" trailing=" " raw_val="stop" val="stop"/>
              </NullNode>
              <NullNode start="(50, 57)" end="(50, 62)">
                <AtomNode start="(50, 57)" end="(50, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(50, 59)" end="(50, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(50, 62)" end="(50, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(50, 64)" end="(50, 84)">
              <AtomNode start="(50, 64)" end="(50, 65)" leading="" trailing="" val="("/>
              <NullNode start="(50, 65)" end="(50, 66)">
                <IdentNode start="(50, 65)" end="(50, 66)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(50, 67)" end="(50, 83)">
                <AtomNode start="(50, 67)" end="(50, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 69)" end="(50, 83)" kind="«term_≤_»">
                  <IdentNode start="(50, 69)" end="(50, 73)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(50, 74)" end="(50, 75)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(50, 76)" end="(50, 83)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(50, 83)" end="(50, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(50, 85)" end="(51, 59)">
            <AtomNode start="(50, 85)" end="(50, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(51, 5)" end="(51, 59)" kind="«term_=_»">
              <OtherNode start="(51, 5)" end="(51, 35)" kind="Lean.Parser.Term.app">
                <OtherNode start="(51, 5)" end="(51, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(51, 5)" end="(51, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(51, 5)" end="(51, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(51, 6)" end="(51, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(51, 6)" end="(51, 13)" leading="" trailing=" " raw_val="as.push" val="as.push"/>
                      <NullNode start="(51, 14)" end="(51, 15)">
                        <IdentNode start="(51, 14)" end="(51, 15)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(51, 15)" end="(51, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(51, 16)" end="(51, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(51, 17)" end="(51, 24)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(51, 25)" end="(51, 35)">
                  <IdentNode start="(51, 25)" end="(51, 30)" leading="" trailing=" " raw_val="start" val="start"/>
                  <IdentNode start="(51, 31)" end="(51, 35)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(51, 36)" end="(51, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(51, 38)" end="(51, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(51, 38)" end="(51, 48)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(51, 49)" end="(51, 59)">
                  <IdentNode start="(51, 49)" end="(51, 54)" leading="" trailing=" " raw_val="start" val="start"/>
                  <IdentNode start="(51, 55)" end="(51, 59)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(51, 60)" end="(57, 28)">
          <AtomNode start="(51, 60)" end="(51, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(51, 63)" end="(57, 28)">
            <AtomNode start="(51, 63)" end="(51, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(52, 3)" end="(57, 28)">
              <TacticTacticseq1IndentedNode start="(52, 3)" end="(57, 28)">
                <NullNode start="(52, 3)" end="(57, 28)">
                  <OtherNode start="(52, 3)" end="(52, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;⊢ (as.push b).extract start stop = as.extract start stop" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;⊢ ((as.push b).extract start stop).size = (as.extract start stop).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂ : i &amp;lt; (as.extract start stop).size&#10;⊢ ((as.push b).extract start stop)[i] = (as.extract start stop)[i]" tactic="ext i h₁ h₂">
                    <AtomNode start="(52, 3)" end="(52, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(52, 7)" end="(52, 14)">
                      <OtherNode start="(52, 7)" end="(52, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(52, 7)" end="(52, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(52, 7)" end="(52, 8)" leading="" trailing=" " raw_val="i" val="i"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(52, 9)" end="(52, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(52, 9)" end="(52, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(52, 9)" end="(52, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(52, 12)" end="(52, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(52, 12)" end="(52, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(52, 12)" end="(52, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(53, 3)" end="(54, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;⊢ ((as.push b).extract start stop).size = (as.extract start stop).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂ : i &amp;lt; (as.extract start stop).size&#10;⊢ ((as.push b).extract start stop)[i] = (as.extract start stop)[i]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂ : i &amp;lt; (as.extract start stop).size&#10;⊢ ((as.push b).extract start stop)[i] = (as.extract start stop)[i]" tactic="· simp&#10;  omega">
                    <OtherNode start="(53, 3)" end="(53, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(53, 3)" end="(53, 4)" kind="patternIgnore">
                        <OtherNode start="(53, 3)" end="(53, 4)" kind="token.«· »">
                          <AtomNode start="(53, 3)" end="(53, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(53, 5)" end="(54, 10)">
                      <TacticTacticseq1IndentedNode start="(53, 5)" end="(54, 10)">
                        <NullNode start="(53, 5)" end="(54, 10)">
                          <OtherNode start="(53, 5)" end="(53, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;⊢ ((as.push b).extract start stop).size = (as.extract start stop).size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;⊢ min stop (as.size + 1) - start = min stop as.size - start" tactic="simp">
                            <AtomNode start="(53, 5)" end="(53, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(54, 5)" end="(54, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;⊢ min stop (as.size + 1) - start = min stop as.size - start" state_after="no goals" tactic="omega">
                            <AtomNode start="(54, 5)" end="(54, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(55, 3)" end="(57, 28)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂ : i &amp;lt; (as.extract start stop).size&#10;⊢ ((as.push b).extract start stop)[i] = (as.extract start stop)[i]" state_after="no goals" tactic="· simp only [size_extract, size_push] at h₁ h₂&#10;  simp only [getElem_extract, getElem_push]&#10;  rw [dif_pos (by omega)]">
                    <OtherNode start="(55, 3)" end="(55, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(55, 3)" end="(55, 4)" kind="patternIgnore">
                        <OtherNode start="(55, 3)" end="(55, 4)" kind="token.«· »">
                          <AtomNode start="(55, 3)" end="(55, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(55, 5)" end="(57, 28)">
                      <TacticTacticseq1IndentedNode start="(55, 5)" end="(57, 28)">
                        <NullNode start="(55, 5)" end="(57, 28)">
                          <OtherNode start="(55, 5)" end="(55, 49)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂ : i &amp;lt; (as.extract start stop).size&#10;⊢ ((as.push b).extract start stop)[i] = (as.extract start stop)[i]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁✝ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂✝ : i &amp;lt; (as.extract start stop).size&#10;h₁ : i &amp;lt; min stop (as.size + 1) - start&#10;h₂ : i &amp;lt; min stop as.size - start&#10;⊢ ((as.push b).extract start stop)[i] = (as.extract start stop)[i]" tactic="simp only [size_extract, size_push] at h₁ h₂">
                            <AtomNode start="(55, 5)" end="(55, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(55, 10)" end="(55, 14)">
                              <AtomNode start="(55, 10)" end="(55, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(55, 15)" end="(55, 40)">
                              <AtomNode start="(55, 15)" end="(55, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(55, 16)" end="(55, 39)">
                                <OtherNode start="(55, 16)" end="(55, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(55, 16)" end="(55, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(55, 28)" end="(55, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(55, 30)" end="(55, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(55, 30)" end="(55, 39)" leading="" trailing="" raw_val="size_push" val="size_push" full_name="Array.size_push" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(55, 39)" end="(55, 40)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(55, 41)" end="(55, 49)">
                              <OtherNode start="(55, 41)" end="(55, 49)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(55, 41)" end="(55, 43)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(55, 44)" end="(55, 49)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(55, 44)" end="(55, 49)">
                                    <IdentNode start="(55, 44)" end="(55, 46)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(55, 47)" end="(55, 49)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(56, 5)" end="(56, 46)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁✝ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂✝ : i &amp;lt; (as.extract start stop).size&#10;h₁ : i &amp;lt; min stop (as.size + 1) - start&#10;h₂ : i &amp;lt; min stop as.size - start&#10;⊢ ((as.push b).extract start stop)[i] = (as.extract start stop)[i]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁✝ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂✝ : i &amp;lt; (as.extract start stop).size&#10;h₁ : i &amp;lt; min stop (as.size + 1) - start&#10;h₂ : i &amp;lt; min stop as.size - start&#10;⊢ (if h : start + i &amp;lt; as.size then as[start + i] else b) = as[start + i]" tactic="simp only [getElem_extract, getElem_push]">
                            <AtomNode start="(56, 5)" end="(56, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(56, 10)" end="(56, 14)">
                              <AtomNode start="(56, 10)" end="(56, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(56, 15)" end="(56, 46)">
                              <AtomNode start="(56, 15)" end="(56, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(56, 16)" end="(56, 45)">
                                <OtherNode start="(56, 16)" end="(56, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(56, 16)" end="(56, 31)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(56, 31)" end="(56, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(56, 33)" end="(56, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(56, 33)" end="(56, 45)" leading="" trailing="" raw_val="getElem_push" val="getElem_push" full_name="Array.getElem_push" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(56, 45)" end="(56, 46)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(57, 5)" end="(57, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁✝ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂✝ : i &amp;lt; (as.extract start stop).size&#10;h₁ : i &amp;lt; min stop (as.size + 1) - start&#10;h₂ : i &amp;lt; min stop as.size - start&#10;⊢ (if h : start + i &amp;lt; as.size then as[start + i] else b) = as[start + i]" state_after="no goals" tactic="rw [dif_pos (by omega)]">
                            <AtomNode start="(57, 5)" end="(57, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(57, 8)" end="(57, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(57, 8)" end="(57, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(57, 9)" end="(57, 27)">
                                <OtherNode start="(57, 9)" end="(57, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(57, 9)" end="(57, 27)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(57, 9)" end="(57, 16)" leading="" trailing=" " raw_val="dif_pos" val="dif_pos" full_name="dif_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                    <NullNode start="(57, 17)" end="(57, 27)">
                                      <OtherNode start="(57, 17)" end="(57, 27)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(57, 17)" end="(57, 18)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(57, 18)" end="(57, 26)">
                                          <AtomNode start="(57, 18)" end="(57, 20)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(57, 21)" end="(57, 26)">
                                            <TacticTacticseq1IndentedNode start="(57, 21)" end="(57, 26)">
                                              <NullNode start="(57, 21)" end="(57, 26)">
                                                <OtherNode start="(57, 21)" end="(57, 26)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;b : α&#10;start stop : Nat&#10;h : stop ≤ as.size&#10;i : Nat&#10;h₁✝ : i &amp;lt; ((as.push b).extract start stop).size&#10;h₂✝ : i &amp;lt; (as.extract start stop).size&#10;h₁ : i &amp;lt; min stop (as.size + 1) - start&#10;h₂ : i &amp;lt; min stop as.size - start&#10;⊢ start + i &amp;lt; as.size" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(57, 21)" end="(57, 26)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(57, 26)" end="(57, 27)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(57, 27)" end="(57, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(59, 1)" end="(66, 40)" name="extract_eq_pop" full_name="Array.extract_eq_pop">
      <CommandDeclmodifiersNode start="(59, 1)" end="(59, 8)">
        <NullNode/>
        <NullNode start="(59, 1)" end="(59, 8)">
          <OtherNode start="(59, 1)" end="(59, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(59, 1)" end="(59, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(59, 3)" end="(59, 7)">
              <OtherNode start="(59, 3)" end="(59, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(59, 3)" end="(59, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(59, 3)" end="(59, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(59, 7)" end="(59, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(60, 1)" end="(66, 40)" name="extract_eq_pop" full_name="Array.extract_eq_pop" _is_private_decl="False">
        <AtomNode start="(60, 1)" end="(60, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(60, 9)" end="(60, 23)">
          <IdentNode start="(60, 9)" end="(60, 23)" leading="" trailing=" " raw_val="extract_eq_pop" val="extract_eq_pop"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(60, 24)" end="(61, 31)">
          <NullNode start="(60, 24)" end="(60, 76)">
            <OtherNode start="(60, 24)" end="(60, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 24)" end="(60, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 25)" end="(60, 27)">
                <IdentNode start="(60, 25)" end="(60, 27)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(60, 28)" end="(60, 37)">
                <AtomNode start="(60, 28)" end="(60, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 30)" end="(60, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 30)" end="(60, 35)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(60, 36)" end="(60, 37)">
                    <IdentNode start="(60, 36)" end="(60, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(60, 37)" end="(60, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(60, 39)" end="(60, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 39)" end="(60, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 40)" end="(60, 44)">
                <IdentNode start="(60, 40)" end="(60, 44)" leading="" trailing=" " raw_val="stop" val="stop"/>
              </NullNode>
              <NullNode start="(60, 45)" end="(60, 50)">
                <AtomNode start="(60, 45)" end="(60, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(60, 47)" end="(60, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(60, 50)" end="(60, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(60, 52)" end="(60, 76)">
              <AtomNode start="(60, 52)" end="(60, 53)" leading="" trailing="" val="("/>
              <NullNode start="(60, 53)" end="(60, 54)">
                <IdentNode start="(60, 53)" end="(60, 54)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(60, 55)" end="(60, 75)">
                <AtomNode start="(60, 55)" end="(60, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 57)" end="(60, 75)" kind="«term_=_»">
                  <IdentNode start="(60, 57)" end="(60, 61)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(60, 62)" end="(60, 63)" leading="" trailing=" " val="="/>
                  <OtherNode start="(60, 64)" end="(60, 75)" kind="«term_-_»">
                    <IdentNode start="(60, 64)" end="(60, 71)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                    <AtomNode start="(60, 72)" end="(60, 73)" leading="" trailing=" " val="-"/>
                    <OtherNode start="(60, 74)" end="(60, 75)" kind="num">
                      <AtomNode start="(60, 74)" end="(60, 75)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(60, 75)" end="(60, 76)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(60, 77)" end="(61, 31)">
            <AtomNode start="(60, 77)" end="(60, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(61, 5)" end="(61, 31)" kind="«term_=_»">
              <OtherNode start="(61, 5)" end="(61, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(61, 5)" end="(61, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(61, 16)" end="(61, 22)">
                  <OtherNode start="(61, 16)" end="(61, 17)" kind="num">
                    <AtomNode start="(61, 16)" end="(61, 17)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(61, 18)" end="(61, 22)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(61, 23)" end="(61, 24)" leading="" trailing=" " val="="/>
              <IdentNode start="(61, 25)" end="(61, 31)" leading="" trailing=" " raw_val="as.pop" val="as.pop"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(61, 32)" end="(66, 40)">
          <AtomNode start="(61, 32)" end="(61, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(61, 35)" end="(66, 40)">
            <AtomNode start="(61, 35)" end="(61, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(62, 3)" end="(66, 40)">
              <TacticTacticseq1IndentedNode start="(62, 3)" end="(66, 40)">
                <NullNode start="(62, 3)" end="(66, 40)">
                  <OtherNode start="(62, 3)" end="(62, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;⊢ as.extract 0 stop = as.pop" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;⊢ (as.extract 0 stop).size = as.pop.size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;i : Nat&#10;h₁ : i &amp;lt; (as.extract 0 stop).size&#10;h₂ : i &amp;lt; as.pop.size&#10;⊢ (as.extract 0 stop)[i] = as.pop[i]" tactic="ext i h₁ h₂">
                    <AtomNode start="(62, 3)" end="(62, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(62, 7)" end="(62, 14)">
                      <OtherNode start="(62, 7)" end="(62, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(62, 7)" end="(62, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(62, 7)" end="(62, 8)" leading="" trailing=" " raw_val="i" val="i"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(62, 9)" end="(62, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(62, 9)" end="(62, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(62, 9)" end="(62, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(62, 12)" end="(62, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(62, 12)" end="(62, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(62, 12)" end="(62, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(63, 3)" end="(64, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;⊢ (as.extract 0 stop).size = as.pop.size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;i : Nat&#10;h₁ : i &amp;lt; (as.extract 0 stop).size&#10;h₂ : i &amp;lt; as.pop.size&#10;⊢ (as.extract 0 stop)[i] = as.pop[i]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;i : Nat&#10;h₁ : i &amp;lt; (as.extract 0 stop).size&#10;h₂ : i &amp;lt; as.pop.size&#10;⊢ (as.extract 0 stop)[i] = as.pop[i]" tactic="· simp&#10;  omega">
                    <OtherNode start="(63, 3)" end="(63, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(63, 3)" end="(63, 4)" kind="patternIgnore">
                        <OtherNode start="(63, 3)" end="(63, 4)" kind="token.«· »">
                          <AtomNode start="(63, 3)" end="(63, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(63, 5)" end="(64, 10)">
                      <TacticTacticseq1IndentedNode start="(63, 5)" end="(64, 10)">
                        <NullNode start="(63, 5)" end="(64, 10)">
                          <OtherNode start="(63, 5)" end="(63, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;⊢ (as.extract 0 stop).size = as.pop.size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;⊢ min stop as.size = as.size - 1" tactic="simp">
                            <AtomNode start="(63, 5)" end="(63, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(64, 5)" end="(64, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;⊢ min stop as.size = as.size - 1" state_after="no goals" tactic="omega">
                            <AtomNode start="(64, 5)" end="(64, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(65, 3)" end="(66, 40)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;i : Nat&#10;h₁ : i &amp;lt; (as.extract 0 stop).size&#10;h₂ : i &amp;lt; as.pop.size&#10;⊢ (as.extract 0 stop)[i] = as.pop[i]" state_after="no goals" tactic="· simp only [size_extract, size_pop] at h₁ h₂&#10;  simp [getElem_extract, getElem_pop]">
                    <OtherNode start="(65, 3)" end="(65, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(65, 3)" end="(65, 4)" kind="patternIgnore">
                        <OtherNode start="(65, 3)" end="(65, 4)" kind="token.«· »">
                          <AtomNode start="(65, 3)" end="(65, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(65, 5)" end="(66, 40)">
                      <TacticTacticseq1IndentedNode start="(65, 5)" end="(66, 40)">
                        <NullNode start="(65, 5)" end="(66, 40)">
                          <OtherNode start="(65, 5)" end="(65, 48)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;i : Nat&#10;h₁ : i &amp;lt; (as.extract 0 stop).size&#10;h₂ : i &amp;lt; as.pop.size&#10;⊢ (as.extract 0 stop)[i] = as.pop[i]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;i : Nat&#10;h₁✝ : i &amp;lt; (as.extract 0 stop).size&#10;h₂✝ : i &amp;lt; as.pop.size&#10;h₁ : i &amp;lt; min stop as.size - 0&#10;h₂ : i &amp;lt; as.size - 1&#10;⊢ (as.extract 0 stop)[i] = as.pop[i]" tactic="simp only [size_extract, size_pop] at h₁ h₂">
                            <AtomNode start="(65, 5)" end="(65, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(65, 10)" end="(65, 14)">
                              <AtomNode start="(65, 10)" end="(65, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(65, 15)" end="(65, 39)">
                              <AtomNode start="(65, 15)" end="(65, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(65, 16)" end="(65, 38)">
                                <OtherNode start="(65, 16)" end="(65, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(65, 16)" end="(65, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(65, 28)" end="(65, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(65, 30)" end="(65, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(65, 30)" end="(65, 38)" leading="" trailing="" raw_val="size_pop" val="size_pop" full_name="Array.size_pop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(65, 38)" end="(65, 39)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(65, 40)" end="(65, 48)">
                              <OtherNode start="(65, 40)" end="(65, 48)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(65, 40)" end="(65, 42)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(65, 43)" end="(65, 48)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(65, 43)" end="(65, 48)">
                                    <IdentNode start="(65, 43)" end="(65, 45)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(65, 46)" end="(65, 48)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(66, 5)" end="(66, 40)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;stop : Nat&#10;h : stop = as.size - 1&#10;i : Nat&#10;h₁✝ : i &amp;lt; (as.extract 0 stop).size&#10;h₂✝ : i &amp;lt; as.pop.size&#10;h₁ : i &amp;lt; min stop as.size - 0&#10;h₂ : i &amp;lt; as.size - 1&#10;⊢ (as.extract 0 stop)[i] = as.pop[i]" state_after="no goals" tactic="simp [getElem_extract, getElem_pop]">
                            <AtomNode start="(66, 5)" end="(66, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(66, 10)" end="(66, 40)">
                              <AtomNode start="(66, 10)" end="(66, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(66, 11)" end="(66, 39)">
                                <OtherNode start="(66, 11)" end="(66, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(66, 11)" end="(66, 26)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(66, 26)" end="(66, 27)" leading="" trailing=" " val=","/>
                                <OtherNode start="(66, 28)" end="(66, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(66, 28)" end="(66, 39)" leading="" trailing="" raw_val="getElem_pop" val="getElem_pop" full_name="Array.getElem_pop" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(66, 39)" end="(66, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(68, 1)" end="(78, 12)" name="extract_append_extract" full_name="Array.extract_append_extract">
      <CommandDeclmodifiersNode start="(68, 1)" end="(68, 8)">
        <NullNode/>
        <NullNode start="(68, 1)" end="(68, 8)">
          <OtherNode start="(68, 1)" end="(68, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(68, 1)" end="(68, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(68, 3)" end="(68, 7)">
              <OtherNode start="(68, 3)" end="(68, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(68, 3)" end="(68, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(68, 3)" end="(68, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(68, 7)" end="(68, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(69, 1)" end="(78, 12)" name="extract_append_extract" full_name="Array.extract_append_extract" _is_private_decl="False">
        <AtomNode start="(69, 1)" end="(69, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(69, 9)" end="(69, 31)">
          <IdentNode start="(69, 9)" end="(69, 31)" leading="" trailing=" " raw_val="extract_append_extract" val="extract_append_extract"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(69, 32)" end="(70, 70)">
          <NullNode start="(69, 32)" end="(69, 60)">
            <OtherNode start="(69, 32)" end="(69, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(69, 32)" end="(69, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(69, 33)" end="(69, 35)">
                <IdentNode start="(69, 33)" end="(69, 35)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(69, 36)" end="(69, 45)">
                <AtomNode start="(69, 36)" end="(69, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(69, 38)" end="(69, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(69, 38)" end="(69, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(69, 44)" end="(69, 45)">
                    <IdentNode start="(69, 44)" end="(69, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(69, 45)" end="(69, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(69, 47)" end="(69, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(69, 47)" end="(69, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(69, 48)" end="(69, 53)">
                <IdentNode start="(69, 48)" end="(69, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(69, 50)" end="(69, 51)" leading="" trailing=" " raw_val="j" val="j"/>
                <IdentNode start="(69, 52)" end="(69, 53)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(69, 54)" end="(69, 59)">
                <AtomNode start="(69, 54)" end="(69, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(69, 56)" end="(69, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(69, 59)" end="(69, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(69, 61)" end="(70, 70)">
            <AtomNode start="(69, 61)" end="(69, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(70, 5)" end="(70, 70)" kind="«term_=_»">
              <OtherNode start="(70, 5)" end="(70, 37)" kind="«term_++_»">
                <OtherNode start="(70, 5)" end="(70, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(70, 5)" end="(70, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(70, 16)" end="(70, 19)">
                    <IdentNode start="(70, 16)" end="(70, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(70, 18)" end="(70, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(70, 20)" end="(70, 22)" leading="" trailing=" " val="++"/>
                <OtherNode start="(70, 23)" end="(70, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(70, 23)" end="(70, 33)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(70, 34)" end="(70, 37)">
                    <IdentNode start="(70, 34)" end="(70, 35)" leading="" trailing=" " raw_val="j" val="j"/>
                    <IdentNode start="(70, 36)" end="(70, 37)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(70, 38)" end="(70, 39)" leading="" trailing=" " val="="/>
              <OtherNode start="(70, 40)" end="(70, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(70, 40)" end="(70, 50)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(70, 51)" end="(70, 70)">
                  <OtherNode start="(70, 51)" end="(70, 60)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(70, 51)" end="(70, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(70, 52)" end="(70, 59)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(70, 52)" end="(70, 55)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(70, 56)" end="(70, 59)">
                        <IdentNode start="(70, 56)" end="(70, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(70, 58)" end="(70, 59)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(70, 59)" end="(70, 60)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(70, 61)" end="(70, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(70, 61)" end="(70, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(70, 62)" end="(70, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(70, 62)" end="(70, 65)" leading="" trailing=" " raw_val="max" val="max" full_name="Max.max" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(70, 66)" end="(70, 69)">
                        <IdentNode start="(70, 66)" end="(70, 67)" leading="" trailing=" " raw_val="j" val="j"/>
                        <IdentNode start="(70, 68)" end="(70, 69)" leading="" trailing="" raw_val="k" val="k"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(70, 69)" end="(70, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(70, 71)" end="(78, 12)">
          <AtomNode start="(70, 71)" end="(70, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(70, 74)" end="(78, 12)">
            <AtomNode start="(70, 74)" end="(70, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(71, 3)" end="(78, 12)">
              <TacticTacticseq1IndentedNode start="(71, 3)" end="(78, 12)">
                <NullNode start="(71, 3)" end="(78, 12)">
                  <OtherNode start="(71, 3)" end="(71, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ as.extract i j ++ as.extract j k = as.extract (min i j) (max j k)" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ (as.extract i j ++ as.extract j k).size = (as.extract (min i j) (max j k)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;⊢ (as.extract i j ++ as.extract j k)[l] = (as.extract (min i j) (max j k))[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(71, 3)" end="(71, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(71, 7)" end="(71, 14)">
                      <OtherNode start="(71, 7)" end="(71, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(71, 7)" end="(71, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(71, 7)" end="(71, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(71, 9)" end="(71, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(71, 9)" end="(71, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(71, 9)" end="(71, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(71, 12)" end="(71, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(71, 12)" end="(71, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(71, 12)" end="(71, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(72, 3)" end="(73, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ (as.extract i j ++ as.extract j k).size = (as.extract (min i j) (max j k)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;⊢ (as.extract i j ++ as.extract j k)[l] = (as.extract (min i j) (max j k))[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;⊢ (as.extract i j ++ as.extract j k)[l] = (as.extract (min i j) (max j k))[l]" tactic="· simp&#10;  omega">
                    <OtherNode start="(72, 3)" end="(72, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(72, 3)" end="(72, 4)" kind="patternIgnore">
                        <OtherNode start="(72, 3)" end="(72, 4)" kind="token.«· »">
                          <AtomNode start="(72, 3)" end="(72, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(72, 5)" end="(73, 10)">
                      <TacticTacticseq1IndentedNode start="(72, 5)" end="(73, 10)">
                        <NullNode start="(72, 5)" end="(73, 10)">
                          <OtherNode start="(72, 5)" end="(72, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ (as.extract i j ++ as.extract j k).size = (as.extract (min i j) (max j k)).size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ min j as.size - i + (min k as.size - j) = min (max j k) as.size - min i j" tactic="simp">
                            <AtomNode start="(72, 5)" end="(72, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(73, 5)" end="(73, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ min j as.size - i + (min k as.size - j) = min (max j k) as.size - min i j" state_after="no goals" tactic="omega">
                            <AtomNode start="(73, 5)" end="(73, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(74, 3)" end="(78, 12)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;⊢ (as.extract i j ++ as.extract j k)[l] = (as.extract (min i j) (max j k))[l]" state_after="no goals" tactic="· simp only [size_append, size_extract] at h₁ h₂&#10;  simp only [getElem_append, size_extract, getElem_extract]&#10;  split &amp;lt;;&amp;gt;&#10;  · congr 1&#10;    omega">
                    <OtherNode start="(74, 3)" end="(74, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(74, 3)" end="(74, 4)" kind="patternIgnore">
                        <OtherNode start="(74, 3)" end="(74, 4)" kind="token.«· »">
                          <AtomNode start="(74, 3)" end="(74, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(74, 5)" end="(78, 12)">
                      <TacticTacticseq1IndentedNode start="(74, 5)" end="(78, 12)">
                        <NullNode start="(74, 5)" end="(78, 12)">
                          <OtherNode start="(74, 5)" end="(74, 51)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;⊢ (as.extract i j ++ as.extract j k)[l] = (as.extract (min i j) (max j k))[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;h₁ : l &amp;lt; min j as.size - i + (min k as.size - j)&#10;h₂ : l &amp;lt; min (max j k) as.size - min i j&#10;⊢ (as.extract i j ++ as.extract j k)[l] = (as.extract (min i j) (max j k))[l]" tactic="simp only [size_append, size_extract] at h₁ h₂">
                            <AtomNode start="(74, 5)" end="(74, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(74, 10)" end="(74, 14)">
                              <AtomNode start="(74, 10)" end="(74, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(74, 15)" end="(74, 42)">
                              <AtomNode start="(74, 15)" end="(74, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(74, 16)" end="(74, 41)">
                                <OtherNode start="(74, 16)" end="(74, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(74, 16)" end="(74, 27)" leading="" trailing="" raw_val="size_append" val="size_append" full_name="Array.size_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(74, 27)" end="(74, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(74, 29)" end="(74, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(74, 29)" end="(74, 41)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(74, 41)" end="(74, 42)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(74, 43)" end="(74, 51)">
                              <OtherNode start="(74, 43)" end="(74, 51)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(74, 43)" end="(74, 45)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(74, 46)" end="(74, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(74, 46)" end="(74, 51)">
                                    <IdentNode start="(74, 46)" end="(74, 48)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(74, 49)" end="(74, 51)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(75, 5)" end="(75, 62)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;h₁ : l &amp;lt; min j as.size - i + (min k as.size - j)&#10;h₂ : l &amp;lt; min (max j k) as.size - min i j&#10;⊢ (as.extract i j ++ as.extract j k)[l] = (as.extract (min i j) (max j k))[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;h₁ : l &amp;lt; min j as.size - i + (min k as.size - j)&#10;h₂ : l &amp;lt; min (max j k) as.size - min i j&#10;⊢ (if h : l &amp;lt; min j as.size - i then as[i + l] else as[j + (l - (min j as.size - i))]) = as[min i j + l]" tactic="simp only [getElem_append, size_extract, getElem_extract]">
                            <AtomNode start="(75, 5)" end="(75, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(75, 10)" end="(75, 14)">
                              <AtomNode start="(75, 10)" end="(75, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(75, 15)" end="(75, 62)">
                              <AtomNode start="(75, 15)" end="(75, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(75, 16)" end="(75, 61)">
                                <OtherNode start="(75, 16)" end="(75, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(75, 16)" end="(75, 30)" leading="" trailing="" raw_val="getElem_append" val="getElem_append" full_name="Array.getElem_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(75, 30)" end="(75, 31)" leading="" trailing=" " val=","/>
                                <OtherNode start="(75, 32)" end="(75, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(75, 32)" end="(75, 44)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(75, 44)" end="(75, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(75, 46)" end="(75, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(75, 46)" end="(75, 61)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(75, 61)" end="(75, 62)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(76, 5)" end="(78, 12)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;h₁ : l &amp;lt; min j as.size - i + (min k as.size - j)&#10;h₂ : l &amp;lt; min (max j k) as.size - min i j&#10;⊢ (if h : l &amp;lt; min j as.size - i then as[i + l] else as[j + (l - (min j as.size - i))]) = as[min i j + l]" state_after="no goals" tactic="split &amp;lt;;&amp;gt;&#10;· congr 1&#10;  omega">
                            <OtherNode start="(76, 5)" end="(76, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(76, 5)" end="(76, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(76, 11)" end="(76, 14)" leading="" trailing="&#10;    " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(77, 5)" end="(78, 12)" kind="Lean.cdot">
                              <OtherNode start="(77, 5)" end="(77, 6)" kind="Lean.cdotTk">
                                <OtherNode start="(77, 5)" end="(77, 6)" kind="patternIgnore">
                                  <OtherNode start="(77, 5)" end="(77, 6)" kind="token.«· »">
                                    <AtomNode start="(77, 5)" end="(77, 6)" leading="" trailing=" " val="·"/>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <TacticTacticseqNode start="(77, 7)" end="(78, 12)">
                                <TacticTacticseq1IndentedNode start="(77, 7)" end="(78, 12)">
                                  <NullNode start="(77, 7)" end="(78, 12)">
                                    <OtherNode start="(77, 7)" end="(77, 14)" kind="Lean.Parser.Tactic.congr" state_before="case h₂.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;h₁ : l &amp;lt; min j as.size - i + (min k as.size - j)&#10;h₂ : l &amp;lt; min (max j k) as.size - min i j&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ as[j + (l - (min j as.size - i))] = as[min i j + l]" state_after="case h₂.isFalse.e_i&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;h₁ : l &amp;lt; min j as.size - i + (min k as.size - j)&#10;h₂ : l &amp;lt; min (max j k) as.size - min i j&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ j + (l - (min j as.size - i)) = min i j + l" tactic="congr 1">
                                      <AtomNode start="(77, 7)" end="(77, 12)" leading="" trailing=" " val="congr"/>
                                      <NullNode start="(77, 13)" end="(77, 14)">
                                        <OtherNode start="(77, 13)" end="(77, 14)" kind="num">
                                          <AtomNode start="(77, 13)" end="(77, 14)" leading="" trailing="&#10;      " val="1"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(78, 7)" end="(78, 12)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.isFalse.e_i&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j ++ as.extract j k).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (max j k)).size&#10;h₁ : l &amp;lt; min j as.size - i + (min k as.size - j)&#10;h₂ : l &amp;lt; min (max j k) as.size - min i j&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ j + (l - (min j as.size - i)) = min i j + l" state_after="no goals" tactic="omega">
                                      <AtomNode start="(78, 7)" end="(78, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(80, 1)" end="(89, 52)" name="extract_eq_empty_iff" full_name="Array.extract_eq_empty_iff">
      <CommandDeclmodifiersNode start="(80, 1)" end="(80, 8)">
        <NullNode/>
        <NullNode start="(80, 1)" end="(80, 8)">
          <OtherNode start="(80, 1)" end="(80, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(80, 1)" end="(80, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(80, 3)" end="(80, 7)">
              <OtherNode start="(80, 3)" end="(80, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(80, 3)" end="(80, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(80, 3)" end="(80, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(80, 7)" end="(80, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(81, 1)" end="(89, 52)" name="extract_eq_empty_iff" full_name="Array.extract_eq_empty_iff" _is_private_decl="False">
        <AtomNode start="(81, 1)" end="(81, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(81, 9)" end="(81, 29)">
          <IdentNode start="(81, 9)" end="(81, 29)" leading="" trailing=" " raw_val="extract_eq_empty_iff" val="extract_eq_empty_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(81, 30)" end="(82, 45)">
          <NullNode start="(81, 30)" end="(81, 44)">
            <OtherNode start="(81, 30)" end="(81, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(81, 30)" end="(81, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(81, 31)" end="(81, 33)">
                <IdentNode start="(81, 31)" end="(81, 33)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(81, 34)" end="(81, 43)">
                <AtomNode start="(81, 34)" end="(81, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(81, 36)" end="(81, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(81, 36)" end="(81, 41)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(81, 42)" end="(81, 43)">
                    <IdentNode start="(81, 42)" end="(81, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(81, 43)" end="(81, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(81, 45)" end="(82, 45)">
            <AtomNode start="(81, 45)" end="(81, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(82, 5)" end="(82, 45)" kind="«term_↔_»">
              <OtherNode start="(82, 5)" end="(82, 25)" kind="«term_=_»">
                <OtherNode start="(82, 5)" end="(82, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(82, 5)" end="(82, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(82, 16)" end="(82, 19)">
                    <IdentNode start="(82, 16)" end="(82, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(82, 18)" end="(82, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(82, 20)" end="(82, 21)" leading="" trailing=" " val="="/>
                <OtherNode start="(82, 22)" end="(82, 25)" kind="«term#[_,]»">
                  <AtomNode start="(82, 22)" end="(82, 24)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(82, 24)" end="(82, 25)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(82, 26)" end="(82, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(82, 28)" end="(82, 45)" kind="«term_≤_»">
                <OtherNode start="(82, 28)" end="(82, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(82, 28)" end="(82, 31)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(82, 32)" end="(82, 41)">
                    <IdentNode start="(82, 32)" end="(82, 33)" leading="" trailing=" " raw_val="j" val="j"/>
                    <IdentNode start="(82, 34)" end="(82, 41)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(82, 42)" end="(82, 43)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(82, 44)" end="(82, 45)" leading="" trailing=" " raw_val="i" val="i"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(82, 46)" end="(89, 52)">
          <AtomNode start="(82, 46)" end="(82, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(82, 49)" end="(89, 52)">
            <AtomNode start="(82, 49)" end="(82, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(83, 3)" end="(89, 52)">
              <TacticTacticseq1IndentedNode start="(83, 3)" end="(89, 52)">
                <NullNode start="(83, 3)" end="(89, 52)">
                  <OtherNode start="(83, 3)" end="(83, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = #[] ↔ min j as.size ≤ i" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = #[] → min j as.size ≤ i&#10;&#10;case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ min j as.size ≤ i → as.extract i j = #[]" tactic="constructor">
                    <AtomNode start="(83, 3)" end="(83, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(84, 3)" end="(87, 10)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = #[] → min j as.size ≤ i&#10;&#10;case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ min j as.size ≤ i → as.extract i j = #[]" state_after="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ min j as.size ≤ i → as.extract i j = #[]" tactic="· intro h&#10;  replace h := congrArg Array.size h&#10;  simp at h&#10;  omega">
                    <OtherNode start="(84, 3)" end="(84, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(84, 3)" end="(84, 4)" kind="patternIgnore">
                        <OtherNode start="(84, 3)" end="(84, 4)" kind="token.«· »">
                          <AtomNode start="(84, 3)" end="(84, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(84, 5)" end="(87, 10)">
                      <TacticTacticseq1IndentedNode start="(84, 5)" end="(87, 10)">
                        <NullNode start="(84, 5)" end="(87, 10)">
                          <OtherNode start="(84, 5)" end="(84, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = #[] → min j as.size ≤ i" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.extract i j = #[]&#10;⊢ min j as.size ≤ i" tactic="intro h">
                            <AtomNode start="(84, 5)" end="(84, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(84, 11)" end="(84, 12)">
                              <IdentNode start="(84, 11)" end="(84, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(85, 5)" end="(85, 39)" kind="Lean.Parser.Tactic.replace" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.extract i j = #[]&#10;⊢ min j as.size ≤ i" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : (as.extract i j).size = #[].size&#10;⊢ min j as.size ≤ i" tactic="replace h := congrArg Array.size h">
                            <AtomNode start="(85, 5)" end="(85, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(85, 13)" end="(85, 39)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(85, 13)" end="(85, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(85, 13)" end="(85, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(85, 13)" end="(85, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(85, 15)" end="(85, 17)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(85, 18)" end="(85, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(85, 18)" end="(85, 26)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(85, 27)" end="(85, 39)">
                                    <IdentNode start="(85, 27)" end="(85, 37)" leading="" trailing=" " raw_val="Array.size" val="Array.size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <IdentNode start="(85, 38)" end="(85, 39)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(86, 5)" end="(86, 14)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : (as.extract i j).size = #[].size&#10;⊢ min j as.size ≤ i" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size - i = 0&#10;⊢ min j as.size ≤ i" tactic="simp at h">
                            <AtomNode start="(86, 5)" end="(86, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(86, 10)" end="(86, 14)">
                              <OtherNode start="(86, 10)" end="(86, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(86, 10)" end="(86, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(86, 13)" end="(86, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(86, 13)" end="(86, 14)">
                                    <IdentNode start="(86, 13)" end="(86, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(87, 5)" end="(87, 10)" kind="Lean.Parser.Tactic.omega" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size - i = 0&#10;⊢ min j as.size ≤ i" state_after="no goals" tactic="omega">
                            <AtomNode start="(87, 5)" end="(87, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(88, 3)" end="(89, 52)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ min j as.size ≤ i → as.extract i j = #[]" state_after="no goals" tactic="· intro h&#10;  exact eq_empty_of_size_eq_zero (by simp; omega)">
                    <OtherNode start="(88, 3)" end="(88, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(88, 3)" end="(88, 4)" kind="patternIgnore">
                        <OtherNode start="(88, 3)" end="(88, 4)" kind="token.«· »">
                          <AtomNode start="(88, 3)" end="(88, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(88, 5)" end="(89, 52)">
                      <TacticTacticseq1IndentedNode start="(88, 5)" end="(89, 52)">
                        <NullNode start="(88, 5)" end="(89, 52)">
                          <OtherNode start="(88, 5)" end="(88, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ min j as.size ≤ i → as.extract i j = #[]" state_after="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size ≤ i&#10;⊢ as.extract i j = #[]" tactic="intro h">
                            <AtomNode start="(88, 5)" end="(88, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(88, 11)" end="(88, 12)">
                              <IdentNode start="(88, 11)" end="(88, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(89, 5)" end="(89, 52)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size ≤ i&#10;⊢ as.extract i j = #[]" state_after="no goals" tactic="exact eq_empty_of_size_eq_zero (by simp; omega)">
                            <AtomNode start="(89, 5)" end="(89, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(89, 11)" end="(89, 52)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(89, 11)" end="(89, 35)" leading="" trailing=" " raw_val="eq_empty_of_size_eq_zero" val="eq_empty_of_size_eq_zero" full_name="Array.eq_empty_of_size_eq_zero" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                              <NullNode start="(89, 36)" end="(89, 52)">
                                <OtherNode start="(89, 36)" end="(89, 52)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(89, 36)" end="(89, 37)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(89, 37)" end="(89, 51)">
                                    <AtomNode start="(89, 37)" end="(89, 39)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(89, 40)" end="(89, 51)">
                                      <TacticTacticseq1IndentedNode start="(89, 40)" end="(89, 51)">
                                        <NullNode start="(89, 40)" end="(89, 51)">
                                          <OtherNode start="(89, 40)" end="(89, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size ≤ i&#10;⊢ (as.extract i j).size = 0" state_after="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size ≤ i&#10;⊢ min j as.size - i = 0" tactic="simp">
                                            <AtomNode start="(89, 40)" end="(89, 44)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(89, 44)" end="(89, 45)" leading="" trailing=" " val=";"/>
                                          <OtherNode start="(89, 46)" end="(89, 51)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size ≤ i&#10;⊢ min j as.size - i = 0" state_after="no goals" tactic="omega">
                                            <AtomNode start="(89, 46)" end="(89, 51)" leading="" trailing="" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(89, 51)" end="(89, 52)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(91, 1)" end="(93, 27)" name="extract_eq_empty_of_le" full_name="Array.extract_eq_empty_of_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(91, 1)" end="(93, 27)" name="extract_eq_empty_of_le" full_name="Array.extract_eq_empty_of_le" _is_private_decl="False">
        <AtomNode start="(91, 1)" end="(91, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(91, 9)" end="(91, 31)">
          <IdentNode start="(91, 9)" end="(91, 31)" leading="" trailing=" " raw_val="extract_eq_empty_of_le" val="extract_eq_empty_of_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(91, 32)" end="(92, 25)">
          <NullNode start="(91, 32)" end="(91, 70)">
            <OtherNode start="(91, 32)" end="(91, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(91, 32)" end="(91, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(91, 33)" end="(91, 35)">
                <IdentNode start="(91, 33)" end="(91, 35)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(91, 36)" end="(91, 45)">
                <AtomNode start="(91, 36)" end="(91, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(91, 38)" end="(91, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(91, 38)" end="(91, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(91, 44)" end="(91, 45)">
                    <IdentNode start="(91, 44)" end="(91, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(91, 45)" end="(91, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(91, 47)" end="(91, 70)">
              <AtomNode start="(91, 47)" end="(91, 48)" leading="" trailing="" val="("/>
              <NullNode start="(91, 48)" end="(91, 49)">
                <IdentNode start="(91, 48)" end="(91, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(91, 50)" end="(91, 69)">
                <AtomNode start="(91, 50)" end="(91, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(91, 52)" end="(91, 69)" kind="«term_≤_»">
                  <OtherNode start="(91, 52)" end="(91, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(91, 52)" end="(91, 55)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(91, 56)" end="(91, 65)">
                      <IdentNode start="(91, 56)" end="(91, 57)" leading="" trailing=" " raw_val="j" val="j"/>
                      <IdentNode start="(91, 58)" end="(91, 65)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(91, 66)" end="(91, 67)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(91, 68)" end="(91, 69)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(91, 69)" end="(91, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(91, 71)" end="(92, 25)">
            <AtomNode start="(91, 71)" end="(91, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(92, 5)" end="(92, 25)" kind="«term_=_»">
              <OtherNode start="(92, 5)" end="(92, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(92, 5)" end="(92, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(92, 16)" end="(92, 19)">
                  <IdentNode start="(92, 16)" end="(92, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(92, 18)" end="(92, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(92, 20)" end="(92, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(92, 22)" end="(92, 25)" kind="«term#[_,]»">
                <AtomNode start="(92, 22)" end="(92, 24)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(92, 24)" end="(92, 25)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(92, 26)" end="(93, 27)">
          <AtomNode start="(92, 26)" end="(92, 28)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(93, 3)" end="(93, 27)" kind="Lean.Parser.Term.app">
            <OtherNode start="(93, 3)" end="(93, 25)" kind="Lean.Parser.Term.proj">
              <IdentNode start="(93, 3)" end="(93, 23)" leading="" trailing="" raw_val="extract_eq_empty_iff" val="extract_eq_empty_iff" full_name="Array.extract_eq_empty_iff" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(81, 9)" def_end="(81, 29)"/>
              <AtomNode start="(93, 23)" end="(93, 24)" leading="" trailing="" val="."/>
              <OtherNode start="(93, 24)" end="(93, 25)" kind="fieldIdx">
                <AtomNode start="(93, 24)" end="(93, 25)" leading="" trailing=" " val="2"/>
              </OtherNode>
            </OtherNode>
            <NullNode start="(93, 26)" end="(93, 27)">
              <IdentNode start="(93, 26)" end="(93, 27)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(95, 1)" end="(97, 45)" name="lt_of_extract_ne_empty" full_name="Array.lt_of_extract_ne_empty">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(95, 1)" end="(97, 45)" name="lt_of_extract_ne_empty" full_name="Array.lt_of_extract_ne_empty" _is_private_decl="False">
        <AtomNode start="(95, 1)" end="(95, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(95, 9)" end="(95, 31)">
          <IdentNode start="(95, 9)" end="(95, 31)" leading="" trailing=" " raw_val="lt_of_extract_ne_empty" val="lt_of_extract_ne_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(95, 32)" end="(96, 22)">
          <NullNode start="(95, 32)" end="(95, 73)">
            <OtherNode start="(95, 32)" end="(95, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(95, 32)" end="(95, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(95, 33)" end="(95, 35)">
                <IdentNode start="(95, 33)" end="(95, 35)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(95, 36)" end="(95, 45)">
                <AtomNode start="(95, 36)" end="(95, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 38)" end="(95, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(95, 38)" end="(95, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(95, 44)" end="(95, 45)">
                    <IdentNode start="(95, 44)" end="(95, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(95, 45)" end="(95, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(95, 47)" end="(95, 73)">
              <AtomNode start="(95, 47)" end="(95, 48)" leading="" trailing="" val="("/>
              <NullNode start="(95, 48)" end="(95, 49)">
                <IdentNode start="(95, 48)" end="(95, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(95, 50)" end="(95, 72)">
                <AtomNode start="(95, 50)" end="(95, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 52)" end="(95, 72)" kind="«term_≠_»">
                  <OtherNode start="(95, 52)" end="(95, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(95, 52)" end="(95, 62)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(95, 63)" end="(95, 66)">
                      <IdentNode start="(95, 63)" end="(95, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(95, 65)" end="(95, 66)" leading="" trailing=" " raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(95, 67)" end="(95, 68)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(95, 69)" end="(95, 72)" kind="«term#[_,]»">
                    <AtomNode start="(95, 69)" end="(95, 71)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(95, 71)" end="(95, 72)" leading="" trailing="" val="]"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(95, 72)" end="(95, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(95, 74)" end="(96, 22)">
            <AtomNode start="(95, 74)" end="(95, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(96, 5)" end="(96, 22)" kind="«term_&amp;lt;_»">
              <IdentNode start="(96, 5)" end="(96, 6)" leading="" trailing=" " raw_val="i" val="i"/>
              <AtomNode start="(96, 7)" end="(96, 8)" leading="" trailing=" " val="&amp;lt;"/>
              <OtherNode start="(96, 9)" end="(96, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(96, 9)" end="(96, 12)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(96, 13)" end="(96, 22)">
                  <IdentNode start="(96, 13)" end="(96, 14)" leading="" trailing=" " raw_val="j" val="j"/>
                  <IdentNode start="(96, 15)" end="(96, 22)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(96, 23)" end="(97, 45)">
          <AtomNode start="(96, 23)" end="(96, 25)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(97, 3)" end="(97, 45)" kind="Lean.Parser.Term.app">
            <IdentNode start="(97, 3)" end="(97, 15)" leading="" trailing=" " raw_val="gt_of_not_le" val="gt_of_not_le" full_name="Nat.gt_of_not_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
            <NullNode start="(97, 16)" end="(97, 45)">
              <OtherNode start="(97, 16)" end="(97, 45)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(97, 16)" end="(97, 17)" leading="" trailing="" val="("/>
                <OtherNode start="(97, 17)" end="(97, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(97, 17)" end="(97, 19)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  <NullNode start="(97, 20)" end="(97, 44)">
                    <IdentNode start="(97, 20)" end="(97, 42)" leading="" trailing=" " raw_val="extract_eq_empty_of_le" val="extract_eq_empty_of_le" full_name="Array.extract_eq_empty_of_le" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(91, 9)" def_end="(91, 31)"/>
                    <IdentNode start="(97, 43)" end="(97, 44)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(97, 44)" end="(97, 45)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(99, 1)" end="(114, 12)" name="extract_eq_self_iff" full_name="Array.extract_eq_self_iff">
      <CommandDeclmodifiersNode start="(99, 1)" end="(99, 8)">
        <NullNode/>
        <NullNode start="(99, 1)" end="(99, 8)">
          <OtherNode start="(99, 1)" end="(99, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(99, 1)" end="(99, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(99, 3)" end="(99, 7)">
              <OtherNode start="(99, 3)" end="(99, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(99, 3)" end="(99, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(99, 3)" end="(99, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(99, 7)" end="(99, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(100, 1)" end="(114, 12)" name="extract_eq_self_iff" full_name="Array.extract_eq_self_iff" _is_private_decl="False">
        <AtomNode start="(100, 1)" end="(100, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(100, 9)" end="(100, 28)">
          <IdentNode start="(100, 9)" end="(100, 28)" leading="" trailing=" " raw_val="extract_eq_self_iff" val="extract_eq_self_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(100, 29)" end="(101, 60)">
          <NullNode start="(100, 29)" end="(100, 43)">
            <OtherNode start="(100, 29)" end="(100, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 29)" end="(100, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 30)" end="(100, 32)">
                <IdentNode start="(100, 30)" end="(100, 32)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(100, 33)" end="(100, 42)">
                <AtomNode start="(100, 33)" end="(100, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(100, 35)" end="(100, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(100, 35)" end="(100, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(100, 41)" end="(100, 42)">
                    <IdentNode start="(100, 41)" end="(100, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(100, 42)" end="(100, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(100, 44)" end="(101, 60)">
            <AtomNode start="(100, 44)" end="(100, 45)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(101, 5)" end="(101, 60)" kind="«term_↔_»">
              <OtherNode start="(101, 5)" end="(101, 24)" kind="«term_=_»">
                <OtherNode start="(101, 5)" end="(101, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(101, 5)" end="(101, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(101, 16)" end="(101, 19)">
                    <IdentNode start="(101, 16)" end="(101, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(101, 18)" end="(101, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(101, 20)" end="(101, 21)" leading="" trailing=" " val="="/>
                <IdentNode start="(101, 22)" end="(101, 24)" leading="" trailing=" " raw_val="as" val="as"/>
              </OtherNode>
              <AtomNode start="(101, 25)" end="(101, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(101, 27)" end="(101, 60)" kind="«term_∨_»">
                <OtherNode start="(101, 27)" end="(101, 38)" kind="«term_=_»">
                  <IdentNode start="(101, 27)" end="(101, 34)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                  <AtomNode start="(101, 35)" end="(101, 36)" leading="" trailing=" " val="="/>
                  <OtherNode start="(101, 37)" end="(101, 38)" kind="num">
                    <AtomNode start="(101, 37)" end="(101, 38)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(101, 39)" end="(101, 40)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(101, 41)" end="(101, 60)" kind="«term_∧_»">
                  <OtherNode start="(101, 41)" end="(101, 46)" kind="«term_=_»">
                    <IdentNode start="(101, 41)" end="(101, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                    <AtomNode start="(101, 43)" end="(101, 44)" leading="" trailing=" " val="="/>
                    <OtherNode start="(101, 45)" end="(101, 46)" kind="num">
                      <AtomNode start="(101, 45)" end="(101, 46)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(101, 47)" end="(101, 48)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(101, 49)" end="(101, 60)" kind="«term_≤_»">
                    <IdentNode start="(101, 49)" end="(101, 56)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                    <AtomNode start="(101, 57)" end="(101, 58)" leading="" trailing=" " val="≤"/>
                    <IdentNode start="(101, 59)" end="(101, 60)" leading="" trailing=" " raw_val="j" val="j"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(101, 61)" end="(114, 12)">
          <AtomNode start="(101, 61)" end="(101, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(101, 64)" end="(114, 12)">
            <AtomNode start="(101, 64)" end="(101, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(102, 3)" end="(114, 12)">
              <TacticTacticseq1IndentedNode start="(102, 3)" end="(114, 12)">
                <NullNode start="(102, 3)" end="(114, 12)">
                  <OtherNode start="(102, 3)" end="(102, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = as ↔ as.size = 0 ∨ i = 0 ∧ as.size ≤ j" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = as → as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;&#10;case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j → as.extract i j = as" tactic="constructor">
                    <AtomNode start="(102, 3)" end="(102, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(103, 3)" end="(106, 10)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = as → as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;&#10;case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j → as.extract i j = as" state_after="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j → as.extract i j = as" tactic="· intro h&#10;  replace h := congrArg Array.size h&#10;  simp at h&#10;  omega">
                    <OtherNode start="(103, 3)" end="(103, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(103, 3)" end="(103, 4)" kind="patternIgnore">
                        <OtherNode start="(103, 3)" end="(103, 4)" kind="token.«· »">
                          <AtomNode start="(103, 3)" end="(103, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(103, 5)" end="(106, 10)">
                      <TacticTacticseq1IndentedNode start="(103, 5)" end="(106, 10)">
                        <NullNode start="(103, 5)" end="(106, 10)">
                          <OtherNode start="(103, 5)" end="(103, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.extract i j = as → as.size = 0 ∨ i = 0 ∧ as.size ≤ j" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.extract i j = as&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j" tactic="intro h">
                            <AtomNode start="(103, 5)" end="(103, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(103, 11)" end="(103, 12)">
                              <IdentNode start="(103, 11)" end="(103, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(104, 5)" end="(104, 39)" kind="Lean.Parser.Tactic.replace" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.extract i j = as&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : (as.extract i j).size = as.size&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j" tactic="replace h := congrArg Array.size h">
                            <AtomNode start="(104, 5)" end="(104, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(104, 13)" end="(104, 39)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(104, 13)" end="(104, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(104, 13)" end="(104, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(104, 13)" end="(104, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(104, 15)" end="(104, 17)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(104, 18)" end="(104, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(104, 18)" end="(104, 26)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(104, 27)" end="(104, 39)">
                                    <IdentNode start="(104, 27)" end="(104, 37)" leading="" trailing=" " raw_val="Array.size" val="Array.size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <IdentNode start="(104, 38)" end="(104, 39)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(105, 5)" end="(105, 14)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : (as.extract i j).size = as.size&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j" state_after="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size - i = as.size&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j" tactic="simp at h">
                            <AtomNode start="(105, 5)" end="(105, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(105, 10)" end="(105, 14)">
                              <OtherNode start="(105, 10)" end="(105, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(105, 10)" end="(105, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(105, 13)" end="(105, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(105, 13)" end="(105, 14)">
                                    <IdentNode start="(105, 13)" end="(105, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(106, 5)" end="(106, 10)" kind="Lean.Parser.Tactic.omega" state_before="case mp&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size - i = as.size&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j" state_after="no goals" tactic="omega">
                            <AtomNode start="(106, 5)" end="(106, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(107, 3)" end="(114, 12)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j → as.extract i j = as" state_after="no goals" tactic="· intro h&#10;  ext l h₁ h₂&#10;  · simp&#10;    omega&#10;  · simp only [size_extract] at h₁&#10;    simp only [getElem_extract]&#10;    congr 1&#10;    omega">
                    <OtherNode start="(107, 3)" end="(107, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(107, 3)" end="(107, 4)" kind="patternIgnore">
                        <OtherNode start="(107, 3)" end="(107, 4)" kind="token.«· »">
                          <AtomNode start="(107, 3)" end="(107, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(107, 5)" end="(114, 12)">
                      <TacticTacticseq1IndentedNode start="(107, 5)" end="(114, 12)">
                        <NullNode start="(107, 5)" end="(114, 12)">
                          <OtherNode start="(107, 5)" end="(107, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;⊢ as.size = 0 ∨ i = 0 ∧ as.size ≤ j → as.extract i j = as" state_after="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;⊢ as.extract i j = as" tactic="intro h">
                            <AtomNode start="(107, 5)" end="(107, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(107, 11)" end="(107, 12)">
                              <IdentNode start="(107, 11)" end="(107, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(108, 5)" end="(108, 16)" kind="Lean.Elab.Tactic.Ext.ext" state_before="case mpr&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;⊢ as.extract i j = as" state_after="case mpr.h₁&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;⊢ (as.extract i j).size = as.size&#10;&#10;case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;⊢ (as.extract i j)[l] = as[l]" tactic="ext l h₁ h₂">
                            <AtomNode start="(108, 5)" end="(108, 8)" leading="" trailing=" " val="ext"/>
                            <NullNode start="(108, 9)" end="(108, 16)">
                              <OtherNode start="(108, 9)" end="(108, 10)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(108, 9)" end="(108, 10)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(108, 9)" end="(108, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(108, 11)" end="(108, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(108, 11)" end="(108, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(108, 11)" end="(108, 13)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(108, 14)" end="(108, 16)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(108, 14)" end="(108, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(108, 14)" end="(108, 16)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(109, 5)" end="(110, 12)" kind="Lean.cdot" state_before="case mpr.h₁&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;⊢ (as.extract i j).size = as.size&#10;&#10;case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;⊢ (as.extract i j)[l] = as[l]" state_after="case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;⊢ (as.extract i j)[l] = as[l]" tactic="· simp&#10;  omega">
                            <OtherNode start="(109, 5)" end="(109, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(109, 5)" end="(109, 6)" kind="patternIgnore">
                                <OtherNode start="(109, 5)" end="(109, 6)" kind="token.«· »">
                                  <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(109, 7)" end="(110, 12)">
                              <TacticTacticseq1IndentedNode start="(109, 7)" end="(110, 12)">
                                <NullNode start="(109, 7)" end="(110, 12)">
                                  <OtherNode start="(109, 7)" end="(109, 11)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.h₁&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;⊢ (as.extract i j).size = as.size" state_after="case mpr.h₁&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;⊢ min j as.size - i = as.size" tactic="simp">
                                    <AtomNode start="(109, 7)" end="(109, 11)" leading="" trailing="&#10;      " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(110, 7)" end="(110, 12)" kind="Lean.Parser.Tactic.omega" state_before="case mpr.h₁&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;⊢ min j as.size - i = as.size" state_after="no goals" tactic="omega">
                                    <AtomNode start="(110, 7)" end="(110, 12)" leading="" trailing="&#10;    " val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(111, 5)" end="(114, 12)" kind="Lean.cdot" state_before="case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;⊢ (as.extract i j)[l] = as[l]" state_after="no goals" tactic="· simp only [size_extract] at h₁&#10;  simp only [getElem_extract]&#10;  congr 1&#10;  omega">
                            <OtherNode start="(111, 5)" end="(111, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(111, 5)" end="(111, 6)" kind="patternIgnore">
                                <OtherNode start="(111, 5)" end="(111, 6)" kind="token.«· »">
                                  <AtomNode start="(111, 5)" end="(111, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(111, 7)" end="(114, 12)">
                              <TacticTacticseq1IndentedNode start="(111, 7)" end="(114, 12)">
                                <NullNode start="(111, 7)" end="(114, 12)">
                                  <OtherNode start="(111, 7)" end="(111, 37)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;⊢ (as.extract i j)[l] = as[l]" state_after="case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;⊢ (as.extract i j)[l] = as[l]" tactic="simp only [size_extract] at h₁">
                                    <AtomNode start="(111, 7)" end="(111, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(111, 12)" end="(111, 16)">
                                      <AtomNode start="(111, 12)" end="(111, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(111, 17)" end="(111, 31)">
                                      <AtomNode start="(111, 17)" end="(111, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(111, 18)" end="(111, 30)">
                                        <OtherNode start="(111, 18)" end="(111, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(111, 18)" end="(111, 30)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(111, 30)" end="(111, 31)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(111, 32)" end="(111, 37)">
                                      <OtherNode start="(111, 32)" end="(111, 37)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(111, 32)" end="(111, 34)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(111, 35)" end="(111, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(111, 35)" end="(111, 37)">
                                            <IdentNode start="(111, 35)" end="(111, 37)" leading="" trailing="&#10;      " raw_val="h₁" val="h₁"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(112, 7)" end="(112, 34)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;⊢ (as.extract i j)[l] = as[l]" state_after="case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = as[l]" tactic="simp only [getElem_extract]">
                                    <AtomNode start="(112, 7)" end="(112, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(112, 12)" end="(112, 16)">
                                      <AtomNode start="(112, 12)" end="(112, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(112, 17)" end="(112, 34)">
                                      <AtomNode start="(112, 17)" end="(112, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(112, 18)" end="(112, 33)">
                                        <OtherNode start="(112, 18)" end="(112, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(112, 18)" end="(112, 33)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(112, 33)" end="(112, 34)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(113, 7)" end="(113, 14)" kind="Lean.Parser.Tactic.congr" state_before="case mpr.h₂&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = as[l]" state_after="case mpr.h₂.e_i&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;⊢ i + l = l" tactic="congr 1">
                                    <AtomNode start="(113, 7)" end="(113, 12)" leading="" trailing=" " val="congr"/>
                                    <NullNode start="(113, 13)" end="(113, 14)">
                                      <OtherNode start="(113, 13)" end="(113, 14)" kind="num">
                                        <AtomNode start="(113, 13)" end="(113, 14)" leading="" trailing="&#10;      " val="1"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(114, 7)" end="(114, 12)" kind="Lean.Parser.Tactic.omega" state_before="case mpr.h₂.e_i&#10;α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.size = 0 ∨ i = 0 ∧ as.size ≤ j&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; as.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;⊢ i + l = l" state_after="no goals" tactic="omega">
                                    <AtomNode start="(114, 7)" end="(114, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(116, 1)" end="(118, 40)" name="extract_eq_self_of_le" full_name="Array.extract_eq_self_of_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(116, 1)" end="(118, 40)" name="extract_eq_self_of_le" full_name="Array.extract_eq_self_of_le" _is_private_decl="False">
        <AtomNode start="(116, 1)" end="(116, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(116, 9)" end="(116, 30)">
          <IdentNode start="(116, 9)" end="(116, 30)" leading="" trailing=" " raw_val="extract_eq_self_of_le" val="extract_eq_self_of_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(116, 31)" end="(117, 24)">
          <NullNode start="(116, 31)" end="(116, 63)">
            <OtherNode start="(116, 31)" end="(116, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(116, 31)" end="(116, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(116, 32)" end="(116, 34)">
                <IdentNode start="(116, 32)" end="(116, 34)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(116, 35)" end="(116, 44)">
                <AtomNode start="(116, 35)" end="(116, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(116, 37)" end="(116, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(116, 37)" end="(116, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(116, 43)" end="(116, 44)">
                    <IdentNode start="(116, 43)" end="(116, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(116, 44)" end="(116, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(116, 46)" end="(116, 63)">
              <AtomNode start="(116, 46)" end="(116, 47)" leading="" trailing="" val="("/>
              <NullNode start="(116, 47)" end="(116, 48)">
                <IdentNode start="(116, 47)" end="(116, 48)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(116, 49)" end="(116, 62)">
                <AtomNode start="(116, 49)" end="(116, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(116, 51)" end="(116, 62)" kind="«term_≤_»">
                  <IdentNode start="(116, 51)" end="(116, 58)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                  <AtomNode start="(116, 59)" end="(116, 60)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(116, 61)" end="(116, 62)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(116, 62)" end="(116, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(116, 64)" end="(117, 24)">
            <AtomNode start="(116, 64)" end="(116, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(117, 5)" end="(117, 24)" kind="«term_=_»">
              <OtherNode start="(117, 5)" end="(117, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(117, 5)" end="(117, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(117, 16)" end="(117, 19)">
                  <OtherNode start="(117, 16)" end="(117, 17)" kind="num">
                    <AtomNode start="(117, 16)" end="(117, 17)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(117, 18)" end="(117, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(117, 20)" end="(117, 21)" leading="" trailing=" " val="="/>
              <IdentNode start="(117, 22)" end="(117, 24)" leading="" trailing=" " raw_val="as" val="as"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(117, 25)" end="(118, 40)">
          <AtomNode start="(117, 25)" end="(117, 27)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(118, 3)" end="(118, 40)" kind="Lean.Parser.Term.app">
            <OtherNode start="(118, 3)" end="(118, 24)" kind="Lean.Parser.Term.proj">
              <IdentNode start="(118, 3)" end="(118, 22)" leading="" trailing="" raw_val="extract_eq_self_iff" val="extract_eq_self_iff" full_name="Array.extract_eq_self_iff" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(100, 9)" def_end="(100, 28)"/>
              <AtomNode start="(118, 22)" end="(118, 23)" leading="" trailing="" val="."/>
              <OtherNode start="(118, 23)" end="(118, 24)" kind="fieldIdx">
                <AtomNode start="(118, 23)" end="(118, 24)" leading="" trailing=" " val="2"/>
              </OtherNode>
            </OtherNode>
            <NullNode start="(118, 25)" end="(118, 40)">
              <OtherNode start="(118, 25)" end="(118, 40)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(118, 25)" end="(118, 26)" leading="" trailing="" val="("/>
                <OtherNode start="(118, 26)" end="(118, 39)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(118, 26)" end="(118, 30)" kind="Lean.Parser.Term.dotIdent">
                    <AtomNode start="(118, 26)" end="(118, 27)" leading="" trailing="" val="."/>
                    <IdentNode start="(118, 27)" end="(118, 30)" leading="" trailing=" " raw_val="inr" val="inr"/>
                  </OtherNode>
                  <NullNode start="(118, 31)" end="(118, 39)">
                    <OtherNode start="(118, 31)" end="(118, 39)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(118, 31)" end="(118, 32)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(118, 32)" end="(118, 38)">
                        <IdentNode start="(118, 32)" end="(118, 35)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <AtomNode start="(118, 35)" end="(118, 36)" leading="" trailing=" " val=","/>
                        <IdentNode start="(118, 37)" end="(118, 38)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                      <AtomNode start="(118, 38)" end="(118, 39)" leading="" trailing="" val="⟩"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(118, 39)" end="(118, 40)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(120, 1)" end="(124, 8)" name="le_of_extract_eq_self" full_name="Array.le_of_extract_eq_self">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(120, 1)" end="(124, 8)" name="le_of_extract_eq_self" full_name="Array.le_of_extract_eq_self" _is_private_decl="False">
        <AtomNode start="(120, 1)" end="(120, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(120, 9)" end="(120, 30)">
          <IdentNode start="(120, 9)" end="(120, 30)" leading="" trailing=" " raw_val="le_of_extract_eq_self" val="le_of_extract_eq_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(120, 31)" end="(121, 16)">
          <NullNode start="(120, 31)" end="(120, 71)">
            <OtherNode start="(120, 31)" end="(120, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(120, 31)" end="(120, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(120, 32)" end="(120, 34)">
                <IdentNode start="(120, 32)" end="(120, 34)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(120, 35)" end="(120, 44)">
                <AtomNode start="(120, 35)" end="(120, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(120, 37)" end="(120, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(120, 37)" end="(120, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(120, 43)" end="(120, 44)">
                    <IdentNode start="(120, 43)" end="(120, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(120, 44)" end="(120, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(120, 46)" end="(120, 71)">
              <AtomNode start="(120, 46)" end="(120, 47)" leading="" trailing="" val="("/>
              <NullNode start="(120, 47)" end="(120, 48)">
                <IdentNode start="(120, 47)" end="(120, 48)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(120, 49)" end="(120, 70)">
                <AtomNode start="(120, 49)" end="(120, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(120, 51)" end="(120, 70)" kind="«term_=_»">
                  <OtherNode start="(120, 51)" end="(120, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(120, 51)" end="(120, 61)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(120, 62)" end="(120, 65)">
                      <IdentNode start="(120, 62)" end="(120, 63)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(120, 64)" end="(120, 65)" leading="" trailing=" " raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(120, 66)" end="(120, 67)" leading="" trailing=" " val="="/>
                  <IdentNode start="(120, 68)" end="(120, 70)" leading="" trailing="" raw_val="as" val="as"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(120, 70)" end="(120, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(120, 72)" end="(121, 16)">
            <AtomNode start="(120, 72)" end="(120, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(121, 5)" end="(121, 16)" kind="«term_≤_»">
              <IdentNode start="(121, 5)" end="(121, 12)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
              <AtomNode start="(121, 13)" end="(121, 14)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(121, 15)" end="(121, 16)" leading="" trailing=" " raw_val="j" val="j"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(121, 17)" end="(124, 8)">
          <AtomNode start="(121, 17)" end="(121, 19)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(121, 20)" end="(124, 8)">
            <AtomNode start="(121, 20)" end="(121, 22)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(122, 3)" end="(124, 8)">
              <TacticTacticseq1IndentedNode start="(122, 3)" end="(124, 8)">
                <NullNode start="(122, 3)" end="(124, 8)">
                  <OtherNode start="(122, 3)" end="(122, 37)" kind="Lean.Parser.Tactic.replace" state_before="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : as.extract i j = as&#10;⊢ as.size ≤ j" state_after="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : (as.extract i j).size = as.size&#10;⊢ as.size ≤ j" tactic="replace h := congrArg Array.size h">
                    <AtomNode start="(122, 3)" end="(122, 10)" leading="" trailing=" " val="replace"/>
                    <OtherNode start="(122, 11)" end="(122, 37)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(122, 11)" end="(122, 37)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(122, 11)" end="(122, 12)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(122, 11)" end="(122, 12)" leading="" trailing=" " raw_val="h" val="h"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(122, 13)" end="(122, 15)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(122, 16)" end="(122, 37)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(122, 16)" end="(122, 24)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(122, 25)" end="(122, 37)">
                            <IdentNode start="(122, 25)" end="(122, 35)" leading="" trailing=" " raw_val="Array.size" val="Array.size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <IdentNode start="(122, 36)" end="(122, 37)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(123, 3)" end="(123, 12)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : (as.extract i j).size = as.size&#10;⊢ as.size ≤ j" state_after="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size - i = as.size&#10;⊢ as.size ≤ j" tactic="simp at h">
                    <AtomNode start="(123, 3)" end="(123, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(123, 8)" end="(123, 12)">
                      <OtherNode start="(123, 8)" end="(123, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(123, 8)" end="(123, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(123, 11)" end="(123, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(123, 11)" end="(123, 12)">
                            <IdentNode start="(123, 11)" end="(123, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(124, 3)" end="(124, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i j : Nat&#10;as : Array α&#10;h : min j as.size - i = as.size&#10;⊢ as.size ≤ j" state_after="no goals" tactic="omega">
                    <AtomNode start="(124, 3)" end="(124, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(126, 1)" end="(130, 8)" name="extract_size_left" full_name="Array.extract_size_left">
      <CommandDeclmodifiersNode start="(126, 1)" end="(126, 8)">
        <NullNode/>
        <NullNode start="(126, 1)" end="(126, 8)">
          <OtherNode start="(126, 1)" end="(126, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(126, 1)" end="(126, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(126, 3)" end="(126, 7)">
              <OtherNode start="(126, 3)" end="(126, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(126, 3)" end="(126, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(126, 3)" end="(126, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(126, 7)" end="(126, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(127, 1)" end="(130, 8)" name="extract_size_left" full_name="Array.extract_size_left" _is_private_decl="False">
        <AtomNode start="(127, 1)" end="(127, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(127, 9)" end="(127, 26)">
          <IdentNode start="(127, 9)" end="(127, 26)" leading="" trailing=" " raw_val="extract_size_left" val="extract_size_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(127, 27)" end="(128, 31)">
          <NullNode start="(127, 27)" end="(127, 41)">
            <OtherNode start="(127, 27)" end="(127, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(127, 27)" end="(127, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(127, 28)" end="(127, 30)">
                <IdentNode start="(127, 28)" end="(127, 30)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(127, 31)" end="(127, 40)">
                <AtomNode start="(127, 31)" end="(127, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(127, 33)" end="(127, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(127, 33)" end="(127, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(127, 39)" end="(127, 40)">
                    <IdentNode start="(127, 39)" end="(127, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(127, 40)" end="(127, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(127, 42)" end="(128, 31)">
            <AtomNode start="(127, 42)" end="(127, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(128, 5)" end="(128, 31)" kind="«term_=_»">
              <OtherNode start="(128, 5)" end="(128, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(128, 5)" end="(128, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(128, 16)" end="(128, 25)">
                  <IdentNode start="(128, 16)" end="(128, 23)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                  <IdentNode start="(128, 24)" end="(128, 25)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(128, 26)" end="(128, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(128, 28)" end="(128, 31)" kind="«term#[_,]»">
                <AtomNode start="(128, 28)" end="(128, 30)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(128, 30)" end="(128, 31)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(128, 32)" end="(130, 8)">
          <AtomNode start="(128, 32)" end="(128, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(128, 35)" end="(130, 8)">
            <AtomNode start="(128, 35)" end="(128, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(129, 3)" end="(130, 8)">
              <TacticTacticseq1IndentedNode start="(129, 3)" end="(130, 8)">
                <NullNode start="(129, 3)" end="(130, 8)">
                  <OtherNode start="(129, 3)" end="(129, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;j : Nat&#10;as : Array α&#10;⊢ as.extract as.size j = #[]" state_after="α : Type u_1&#10;j : Nat&#10;as : Array α&#10;⊢ min j as.size ≤ as.size" tactic="simp">
                    <AtomNode start="(129, 3)" end="(129, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(130, 3)" end="(130, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;j : Nat&#10;as : Array α&#10;⊢ min j as.size ≤ as.size" state_after="no goals" tactic="omega">
                    <AtomNode start="(130, 3)" end="(130, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(132, 1)" end="(142, 12)" name="push_extract_getElem" full_name="Array.push_extract_getElem">
      <CommandDeclmodifiersNode start="(132, 1)" end="(132, 8)">
        <NullNode/>
        <NullNode start="(132, 1)" end="(132, 8)">
          <OtherNode start="(132, 1)" end="(132, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(132, 1)" end="(132, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(132, 3)" end="(132, 7)">
              <OtherNode start="(132, 3)" end="(132, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(132, 3)" end="(132, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(132, 3)" end="(132, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(132, 7)" end="(132, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(133, 1)" end="(142, 12)" name="push_extract_getElem" full_name="Array.push_extract_getElem" _is_private_decl="False">
        <AtomNode start="(133, 1)" end="(133, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(133, 9)" end="(133, 29)">
          <IdentNode start="(133, 9)" end="(133, 29)" leading="" trailing=" " raw_val="push_extract_getElem" val="push_extract_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(133, 30)" end="(134, 63)">
          <NullNode start="(133, 30)" end="(133, 74)">
            <OtherNode start="(133, 30)" end="(133, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(133, 30)" end="(133, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(133, 31)" end="(133, 33)">
                <IdentNode start="(133, 31)" end="(133, 33)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(133, 34)" end="(133, 43)">
                <AtomNode start="(133, 34)" end="(133, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(133, 36)" end="(133, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(133, 36)" end="(133, 41)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(133, 42)" end="(133, 43)">
                    <IdentNode start="(133, 42)" end="(133, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(133, 43)" end="(133, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(133, 45)" end="(133, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(133, 45)" end="(133, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(133, 46)" end="(133, 49)">
                <IdentNode start="(133, 46)" end="(133, 47)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(133, 48)" end="(133, 49)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(133, 50)" end="(133, 55)">
                <AtomNode start="(133, 50)" end="(133, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(133, 52)" end="(133, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(133, 55)" end="(133, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(133, 57)" end="(133, 74)">
              <AtomNode start="(133, 57)" end="(133, 58)" leading="" trailing="" val="("/>
              <NullNode start="(133, 58)" end="(133, 59)">
                <IdentNode start="(133, 58)" end="(133, 59)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(133, 60)" end="(133, 73)">
                <AtomNode start="(133, 60)" end="(133, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(133, 62)" end="(133, 73)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(133, 62)" end="(133, 63)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(133, 64)" end="(133, 65)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(133, 66)" end="(133, 73)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(133, 73)" end="(133, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(133, 75)" end="(134, 63)">
            <AtomNode start="(133, 75)" end="(133, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(134, 5)" end="(134, 63)" kind="«term_=_»">
              <OtherNode start="(134, 5)" end="(134, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(134, 5)" end="(134, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(134, 5)" end="(134, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(134, 5)" end="(134, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(134, 6)" end="(134, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(134, 6)" end="(134, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(134, 17)" end="(134, 20)">
                        <IdentNode start="(134, 17)" end="(134, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(134, 19)" end="(134, 20)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(134, 20)" end="(134, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(134, 21)" end="(134, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(134, 22)" end="(134, 26)" leading="" trailing=" " raw_val="push" val="push" full_name="Array.push" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(134, 27)" end="(134, 32)">
                  <OtherNode start="(134, 27)" end="(134, 32)" kind="«term__[_]»">
                    <IdentNode start="(134, 27)" end="(134, 29)" leading="" trailing="" raw_val="as" val="as"/>
                    <AtomNode start="(134, 29)" end="(134, 30)" leading="" trailing="" val="["/>
                    <IdentNode start="(134, 30)" end="(134, 31)" leading="" trailing="" raw_val="j" val="j"/>
                    <AtomNode start="(134, 31)" end="(134, 32)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(134, 33)" end="(134, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(134, 35)" end="(134, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(134, 35)" end="(134, 45)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(134, 46)" end="(134, 63)">
                  <OtherNode start="(134, 46)" end="(134, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(134, 46)" end="(134, 47)" leading="" trailing="" val="("/>
                    <OtherNode start="(134, 47)" end="(134, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(134, 47)" end="(134, 50)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(134, 51)" end="(134, 54)">
                        <IdentNode start="(134, 51)" end="(134, 52)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(134, 53)" end="(134, 54)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(134, 54)" end="(134, 55)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(134, 56)" end="(134, 63)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(134, 56)" end="(134, 57)" leading="" trailing="" val="("/>
                    <OtherNode start="(134, 57)" end="(134, 62)" kind="«term_+_»">
                      <IdentNode start="(134, 57)" end="(134, 58)" leading="" trailing=" " raw_val="j" val="j"/>
                      <AtomNode start="(134, 59)" end="(134, 60)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(134, 61)" end="(134, 62)" kind="num">
                        <AtomNode start="(134, 61)" end="(134, 62)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(134, 62)" end="(134, 63)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(134, 64)" end="(142, 12)">
          <AtomNode start="(134, 64)" end="(134, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(134, 67)" end="(142, 12)">
            <AtomNode start="(134, 67)" end="(134, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(135, 3)" end="(142, 12)">
              <TacticTacticseq1IndentedNode start="(135, 3)" end="(142, 12)">
                <NullNode start="(135, 3)" end="(142, 12)">
                  <OtherNode start="(135, 3)" end="(135, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ (as.extract i j).push as[j] = as.extract (min i j) (j + 1)" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ ((as.extract i j).push as[j]).size = (as.extract (min i j) (j + 1)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;⊢ ((as.extract i j).push as[j])[l] = (as.extract (min i j) (j + 1))[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(135, 3)" end="(135, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(135, 7)" end="(135, 14)">
                      <OtherNode start="(135, 7)" end="(135, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(135, 7)" end="(135, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(135, 7)" end="(135, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(135, 9)" end="(135, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(135, 9)" end="(135, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(135, 9)" end="(135, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(135, 12)" end="(135, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(135, 12)" end="(135, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(135, 12)" end="(135, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(136, 3)" end="(137, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ ((as.extract i j).push as[j]).size = (as.extract (min i j) (j + 1)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;⊢ ((as.extract i j).push as[j])[l] = (as.extract (min i j) (j + 1))[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;⊢ ((as.extract i j).push as[j])[l] = (as.extract (min i j) (j + 1))[l]" tactic="· simp&#10;  omega">
                    <OtherNode start="(136, 3)" end="(136, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(136, 3)" end="(136, 4)" kind="patternIgnore">
                        <OtherNode start="(136, 3)" end="(136, 4)" kind="token.«· »">
                          <AtomNode start="(136, 3)" end="(136, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(136, 5)" end="(137, 10)">
                      <TacticTacticseq1IndentedNode start="(136, 5)" end="(137, 10)">
                        <NullNode start="(136, 5)" end="(137, 10)">
                          <OtherNode start="(136, 5)" end="(136, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ ((as.extract i j).push as[j]).size = (as.extract (min i j) (j + 1)).size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ min j as.size - i + 1 = min (j + 1) as.size - min i j" tactic="simp">
                            <AtomNode start="(136, 5)" end="(136, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(137, 5)" end="(137, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ min j as.size - i + 1 = min (j + 1) as.size - min i j" state_after="no goals" tactic="omega">
                            <AtomNode start="(137, 5)" end="(137, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(138, 3)" end="(142, 12)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;⊢ ((as.extract i j).push as[j])[l] = (as.extract (min i j) (j + 1))[l]" state_after="no goals" tactic="· simp only [size_push, size_extract] at h₁ h₂&#10;  simp only [getElem_push, size_extract, getElem_extract]&#10;  split &amp;lt;;&amp;gt;&#10;  · congr&#10;    omega">
                    <OtherNode start="(138, 3)" end="(138, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(138, 3)" end="(138, 4)" kind="patternIgnore">
                        <OtherNode start="(138, 3)" end="(138, 4)" kind="token.«· »">
                          <AtomNode start="(138, 3)" end="(138, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(138, 5)" end="(142, 12)">
                      <TacticTacticseq1IndentedNode start="(138, 5)" end="(142, 12)">
                        <NullNode start="(138, 5)" end="(142, 12)">
                          <OtherNode start="(138, 5)" end="(138, 49)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;⊢ ((as.extract i j).push as[j])[l] = (as.extract (min i j) (j + 1))[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;h₁ : l &amp;lt; min j as.size - i + 1&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ ((as.extract i j).push as[j])[l] = (as.extract (min i j) (j + 1))[l]" tactic="simp only [size_push, size_extract] at h₁ h₂">
                            <AtomNode start="(138, 5)" end="(138, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(138, 10)" end="(138, 14)">
                              <AtomNode start="(138, 10)" end="(138, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(138, 15)" end="(138, 40)">
                              <AtomNode start="(138, 15)" end="(138, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(138, 16)" end="(138, 39)">
                                <OtherNode start="(138, 16)" end="(138, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(138, 16)" end="(138, 25)" leading="" trailing="" raw_val="size_push" val="size_push" full_name="Array.size_push" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(138, 25)" end="(138, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(138, 27)" end="(138, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(138, 27)" end="(138, 39)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(138, 39)" end="(138, 40)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(138, 41)" end="(138, 49)">
                              <OtherNode start="(138, 41)" end="(138, 49)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(138, 41)" end="(138, 43)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(138, 44)" end="(138, 49)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(138, 44)" end="(138, 49)">
                                    <IdentNode start="(138, 44)" end="(138, 46)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(138, 47)" end="(138, 49)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(139, 5)" end="(139, 60)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;h₁ : l &amp;lt; min j as.size - i + 1&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ ((as.extract i j).push as[j])[l] = (as.extract (min i j) (j + 1))[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;h₁ : l &amp;lt; min j as.size - i + 1&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ (if h : l &amp;lt; min j as.size - i then as[i + l] else as[j]) = as[min i j + l]" tactic="simp only [getElem_push, size_extract, getElem_extract]">
                            <AtomNode start="(139, 5)" end="(139, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(139, 10)" end="(139, 14)">
                              <AtomNode start="(139, 10)" end="(139, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(139, 15)" end="(139, 60)">
                              <AtomNode start="(139, 15)" end="(139, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(139, 16)" end="(139, 59)">
                                <OtherNode start="(139, 16)" end="(139, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(139, 16)" end="(139, 28)" leading="" trailing="" raw_val="getElem_push" val="getElem_push" full_name="Array.getElem_push" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(139, 28)" end="(139, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(139, 30)" end="(139, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(139, 30)" end="(139, 42)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(139, 42)" end="(139, 43)" leading="" trailing=" " val=","/>
                                <OtherNode start="(139, 44)" end="(139, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(139, 44)" end="(139, 59)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(139, 59)" end="(139, 60)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(140, 5)" end="(142, 12)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;h₁ : l &amp;lt; min j as.size - i + 1&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ (if h : l &amp;lt; min j as.size - i then as[i + l] else as[j]) = as[min i j + l]" state_after="no goals" tactic="split &amp;lt;;&amp;gt;&#10;· congr&#10;  omega">
                            <OtherNode start="(140, 5)" end="(140, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(140, 5)" end="(140, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(140, 11)" end="(140, 14)" leading="" trailing="&#10;    " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(141, 5)" end="(142, 12)" kind="Lean.cdot">
                              <OtherNode start="(141, 5)" end="(141, 6)" kind="Lean.cdotTk">
                                <OtherNode start="(141, 5)" end="(141, 6)" kind="patternIgnore">
                                  <OtherNode start="(141, 5)" end="(141, 6)" kind="token.«· »">
                                    <AtomNode start="(141, 5)" end="(141, 6)" leading="" trailing=" " val="·"/>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <TacticTacticseqNode start="(141, 7)" end="(142, 12)">
                                <TacticTacticseq1IndentedNode start="(141, 7)" end="(142, 12)">
                                  <NullNode start="(141, 7)" end="(142, 12)">
                                    <OtherNode start="(141, 7)" end="(141, 12)" kind="Lean.Parser.Tactic.congr" state_before="case h₂.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;h₁ : l &amp;lt; min j as.size - i + 1&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ as[j] = as[min i j + l]" state_after="case h₂.isFalse.e_i&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;h₁ : l &amp;lt; min j as.size - i + 1&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ j = min i j + l" tactic="congr">
                                      <AtomNode start="(141, 7)" end="(141, 12)" leading="" trailing="&#10;      " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(142, 7)" end="(142, 12)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.isFalse.e_i&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₂✝ : l &amp;lt; (as.extract (min i j) (j + 1)).size&#10;h₁ : l &amp;lt; min j as.size - i + 1&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ j = min i j + l" state_after="no goals" tactic="omega">
                                      <AtomNode start="(142, 7)" end="(142, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(144, 1)" end="(152, 10)" name="extract_succ_right" full_name="Array.extract_succ_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(144, 1)" end="(152, 10)" name="extract_succ_right" full_name="Array.extract_succ_right" _is_private_decl="False">
        <AtomNode start="(144, 1)" end="(144, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(144, 9)" end="(144, 27)">
          <IdentNode start="(144, 9)" end="(144, 27)" leading="" trailing=" " raw_val="extract_succ_right" val="extract_succ_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(144, 28)" end="(145, 55)">
          <NullNode start="(144, 28)" end="(144, 88)">
            <OtherNode start="(144, 28)" end="(144, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 28)" end="(144, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 29)" end="(144, 31)">
                <IdentNode start="(144, 29)" end="(144, 31)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(144, 32)" end="(144, 41)">
                <AtomNode start="(144, 32)" end="(144, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 34)" end="(144, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(144, 34)" end="(144, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(144, 40)" end="(144, 41)">
                    <IdentNode start="(144, 40)" end="(144, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(144, 41)" end="(144, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(144, 43)" end="(144, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 43)" end="(144, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 44)" end="(144, 47)">
                <IdentNode start="(144, 44)" end="(144, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(144, 46)" end="(144, 47)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(144, 48)" end="(144, 53)">
                <AtomNode start="(144, 48)" end="(144, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(144, 50)" end="(144, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(144, 53)" end="(144, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(144, 55)" end="(144, 70)">
              <AtomNode start="(144, 55)" end="(144, 56)" leading="" trailing="" val="("/>
              <NullNode start="(144, 56)" end="(144, 57)">
                <IdentNode start="(144, 56)" end="(144, 57)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(144, 58)" end="(144, 69)">
                <AtomNode start="(144, 58)" end="(144, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 60)" end="(144, 69)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(144, 60)" end="(144, 61)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(144, 62)" end="(144, 63)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(144, 64)" end="(144, 69)" kind="«term_+_»">
                    <IdentNode start="(144, 64)" end="(144, 65)" leading="" trailing=" " raw_val="j" val="j"/>
                    <AtomNode start="(144, 66)" end="(144, 67)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(144, 68)" end="(144, 69)" kind="num">
                      <AtomNode start="(144, 68)" end="(144, 69)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 69)" end="(144, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(144, 71)" end="(144, 88)">
              <AtomNode start="(144, 71)" end="(144, 72)" leading="" trailing="" val="("/>
              <NullNode start="(144, 72)" end="(144, 73)">
                <IdentNode start="(144, 72)" end="(144, 73)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(144, 74)" end="(144, 87)">
                <AtomNode start="(144, 74)" end="(144, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 76)" end="(144, 87)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(144, 76)" end="(144, 77)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(144, 78)" end="(144, 79)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(144, 80)" end="(144, 87)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 87)" end="(144, 88)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(144, 89)" end="(145, 55)">
            <AtomNode start="(144, 89)" end="(144, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(145, 5)" end="(145, 55)" kind="«term_=_»">
              <OtherNode start="(145, 5)" end="(145, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(145, 5)" end="(145, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(145, 16)" end="(145, 25)">
                  <IdentNode start="(145, 16)" end="(145, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(145, 18)" end="(145, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 18)" end="(145, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(145, 19)" end="(145, 24)" kind="«term_+_»">
                      <IdentNode start="(145, 19)" end="(145, 20)" leading="" trailing=" " raw_val="j" val="j"/>
                      <AtomNode start="(145, 21)" end="(145, 22)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(145, 23)" end="(145, 24)" kind="num">
                        <AtomNode start="(145, 23)" end="(145, 24)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(145, 24)" end="(145, 25)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(145, 26)" end="(145, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(145, 28)" end="(145, 55)" kind="Lean.Parser.Term.app">
                <OtherNode start="(145, 28)" end="(145, 49)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(145, 28)" end="(145, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 28)" end="(145, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(145, 29)" end="(145, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(145, 29)" end="(145, 39)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(145, 40)" end="(145, 43)">
                        <IdentNode start="(145, 40)" end="(145, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(145, 42)" end="(145, 43)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(145, 43)" end="(145, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(145, 44)" end="(145, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(145, 45)" end="(145, 49)" leading="" trailing=" " raw_val="push" val="push" full_name="Array.push" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(145, 50)" end="(145, 55)">
                  <OtherNode start="(145, 50)" end="(145, 55)" kind="«term__[_]»">
                    <IdentNode start="(145, 50)" end="(145, 52)" leading="" trailing="" raw_val="as" val="as"/>
                    <AtomNode start="(145, 52)" end="(145, 53)" leading="" trailing="" val="["/>
                    <IdentNode start="(145, 53)" end="(145, 54)" leading="" trailing="" raw_val="j" val="j"/>
                    <AtomNode start="(145, 54)" end="(145, 55)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(145, 56)" end="(152, 10)">
          <AtomNode start="(145, 56)" end="(145, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(145, 59)" end="(152, 10)">
            <AtomNode start="(145, 59)" end="(145, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(146, 3)" end="(152, 10)">
              <TacticTacticseq1IndentedNode start="(146, 3)" end="(152, 10)">
                <NullNode start="(146, 3)" end="(152, 10)">
                  <OtherNode start="(146, 3)" end="(146, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;⊢ as.extract i (j + 1) = (as.extract i j).push as[j]" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;⊢ (as.extract i (j + 1)).size = ((as.extract i j).push as[j]).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;⊢ (as.extract i (j + 1))[l] = ((as.extract i j).push as[j])[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(146, 3)" end="(146, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(146, 7)" end="(146, 14)">
                      <OtherNode start="(146, 7)" end="(146, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(146, 7)" end="(146, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(146, 7)" end="(146, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(146, 9)" end="(146, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(146, 9)" end="(146, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(146, 9)" end="(146, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(146, 12)" end="(146, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(146, 12)" end="(146, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(146, 12)" end="(146, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(147, 3)" end="(148, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;⊢ (as.extract i (j + 1)).size = ((as.extract i j).push as[j]).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;⊢ (as.extract i (j + 1))[l] = ((as.extract i j).push as[j])[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;⊢ (as.extract i (j + 1))[l] = ((as.extract i j).push as[j])[l]" tactic="· simp&#10;  omega">
                    <OtherNode start="(147, 3)" end="(147, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(147, 3)" end="(147, 4)" kind="patternIgnore">
                        <OtherNode start="(147, 3)" end="(147, 4)" kind="token.«· »">
                          <AtomNode start="(147, 3)" end="(147, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(147, 5)" end="(148, 10)">
                      <TacticTacticseq1IndentedNode start="(147, 5)" end="(148, 10)">
                        <NullNode start="(147, 5)" end="(148, 10)">
                          <OtherNode start="(147, 5)" end="(147, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;⊢ (as.extract i (j + 1)).size = ((as.extract i j).push as[j]).size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;⊢ min (j + 1) as.size - i = min (j + 1) as.size - min i j" tactic="simp">
                            <AtomNode start="(147, 5)" end="(147, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(148, 5)" end="(148, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;⊢ min (j + 1) as.size - i = min (j + 1) as.size - min i j" state_after="no goals" tactic="omega">
                            <AtomNode start="(148, 5)" end="(148, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(149, 3)" end="(152, 10)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;⊢ (as.extract i (j + 1))[l] = ((as.extract i j).push as[j])[l]" state_after="no goals" tactic="· simp only [size_extract, push_extract_getElem] at h₁ h₂&#10;  simp only [getElem_extract, push_extract_getElem]&#10;  congr&#10;  omega">
                    <OtherNode start="(149, 3)" end="(149, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(149, 3)" end="(149, 4)" kind="patternIgnore">
                        <OtherNode start="(149, 3)" end="(149, 4)" kind="token.«· »">
                          <AtomNode start="(149, 3)" end="(149, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(149, 5)" end="(152, 10)">
                      <TacticTacticseq1IndentedNode start="(149, 5)" end="(152, 10)">
                        <NullNode start="(149, 5)" end="(152, 10)">
                          <OtherNode start="(149, 5)" end="(149, 60)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;⊢ (as.extract i (j + 1))[l] = ((as.extract i j).push as[j])[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₁ : l &amp;lt; min (j + 1) as.size - i&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ (as.extract i (j + 1))[l] = ((as.extract i j).push as[j])[l]" tactic="simp only [size_extract, push_extract_getElem] at h₁ h₂">
                            <AtomNode start="(149, 5)" end="(149, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(149, 10)" end="(149, 14)">
                              <AtomNode start="(149, 10)" end="(149, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(149, 15)" end="(149, 51)">
                              <AtomNode start="(149, 15)" end="(149, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(149, 16)" end="(149, 50)">
                                <OtherNode start="(149, 16)" end="(149, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(149, 16)" end="(149, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(149, 28)" end="(149, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(149, 30)" end="(149, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(149, 30)" end="(149, 50)" leading="" trailing="" raw_val="push_extract_getElem" val="push_extract_getElem" full_name="Array.push_extract_getElem" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(133, 9)" def_end="(133, 29)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(149, 50)" end="(149, 51)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(149, 52)" end="(149, 60)">
                              <OtherNode start="(149, 52)" end="(149, 60)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(149, 52)" end="(149, 54)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(149, 55)" end="(149, 60)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(149, 55)" end="(149, 60)">
                                    <IdentNode start="(149, 55)" end="(149, 57)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(149, 58)" end="(149, 60)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(150, 5)" end="(150, 54)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₁ : l &amp;lt; min (j + 1) as.size - i&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ (as.extract i (j + 1))[l] = ((as.extract i j).push as[j])[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₁ : l &amp;lt; min (j + 1) as.size - i&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ as[i + l] = as[min i j + l]" tactic="simp only [getElem_extract, push_extract_getElem]">
                            <AtomNode start="(150, 5)" end="(150, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(150, 10)" end="(150, 14)">
                              <AtomNode start="(150, 10)" end="(150, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(150, 15)" end="(150, 54)">
                              <AtomNode start="(150, 15)" end="(150, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(150, 16)" end="(150, 53)">
                                <OtherNode start="(150, 16)" end="(150, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(150, 16)" end="(150, 31)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(150, 31)" end="(150, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(150, 33)" end="(150, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(150, 33)" end="(150, 53)" leading="" trailing="" raw_val="push_extract_getElem" val="push_extract_getElem" full_name="Array.push_extract_getElem" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(133, 9)" def_end="(133, 29)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(150, 53)" end="(150, 54)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(151, 5)" end="(151, 10)" kind="Lean.Parser.Tactic.congr" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₁ : l &amp;lt; min (j + 1) as.size - i&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ as[i + l] = as[min i j + l]" state_after="case h₂.e_i.e_a&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₁ : l &amp;lt; min (j + 1) as.size - i&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ i = min i j" tactic="congr">
                            <AtomNode start="(151, 5)" end="(151, 10)" leading="" trailing="&#10;    " val="congr"/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(152, 5)" end="(152, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.e_i.e_a&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;w : i &amp;lt; j + 1&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j + 1)).size&#10;h₂✝ : l &amp;lt; ((as.extract i j).push as[j]).size&#10;h₁ : l &amp;lt; min (j + 1) as.size - i&#10;h₂ : l &amp;lt; min (j + 1) as.size - min i j&#10;⊢ i = min i j" state_after="no goals" tactic="omega">
                            <AtomNode start="(152, 5)" end="(152, 10)" leading="" trailing="&#10;&#10;" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(154, 1)" end="(160, 45)" name="extract_sub_one" full_name="Array.extract_sub_one">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(154, 1)" end="(160, 45)" name="extract_sub_one" full_name="Array.extract_sub_one" _is_private_decl="False">
        <AtomNode start="(154, 1)" end="(154, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(154, 9)" end="(154, 24)">
          <IdentNode start="(154, 9)" end="(154, 24)" leading="" trailing=" " raw_val="extract_sub_one" val="extract_sub_one"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(154, 25)" end="(155, 48)">
          <NullNode start="(154, 25)" end="(154, 69)">
            <OtherNode start="(154, 25)" end="(154, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(154, 25)" end="(154, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(154, 26)" end="(154, 28)">
                <IdentNode start="(154, 26)" end="(154, 28)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(154, 29)" end="(154, 38)">
                <AtomNode start="(154, 29)" end="(154, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(154, 31)" end="(154, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(154, 31)" end="(154, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(154, 37)" end="(154, 38)">
                    <IdentNode start="(154, 37)" end="(154, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(154, 38)" end="(154, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(154, 40)" end="(154, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(154, 40)" end="(154, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(154, 41)" end="(154, 44)">
                <IdentNode start="(154, 41)" end="(154, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(154, 43)" end="(154, 44)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(154, 45)" end="(154, 50)">
                <AtomNode start="(154, 45)" end="(154, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(154, 47)" end="(154, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(154, 50)" end="(154, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(154, 52)" end="(154, 69)">
              <AtomNode start="(154, 52)" end="(154, 53)" leading="" trailing="" val="("/>
              <NullNode start="(154, 53)" end="(154, 54)">
                <IdentNode start="(154, 53)" end="(154, 54)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(154, 55)" end="(154, 68)">
                <AtomNode start="(154, 55)" end="(154, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(154, 57)" end="(154, 68)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(154, 57)" end="(154, 58)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(154, 59)" end="(154, 60)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(154, 61)" end="(154, 68)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(154, 68)" end="(154, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(154, 70)" end="(155, 48)">
            <AtomNode start="(154, 70)" end="(154, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(155, 5)" end="(155, 48)" kind="«term_=_»">
              <OtherNode start="(155, 5)" end="(155, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(155, 5)" end="(155, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(155, 16)" end="(155, 25)">
                  <IdentNode start="(155, 16)" end="(155, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(155, 18)" end="(155, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(155, 18)" end="(155, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(155, 19)" end="(155, 24)" kind="«term_-_»">
                      <IdentNode start="(155, 19)" end="(155, 20)" leading="" trailing=" " raw_val="j" val="j"/>
                      <AtomNode start="(155, 21)" end="(155, 22)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(155, 23)" end="(155, 24)" kind="num">
                        <AtomNode start="(155, 23)" end="(155, 24)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(155, 24)" end="(155, 25)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(155, 26)" end="(155, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(155, 28)" end="(155, 48)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(155, 28)" end="(155, 44)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(155, 28)" end="(155, 29)" leading="" trailing="" val="("/>
                  <OtherNode start="(155, 29)" end="(155, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(155, 29)" end="(155, 39)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(155, 40)" end="(155, 43)">
                      <IdentNode start="(155, 40)" end="(155, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(155, 42)" end="(155, 43)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(155, 43)" end="(155, 44)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(155, 44)" end="(155, 45)" leading="" trailing="" val="."/>
                <IdentNode start="(155, 45)" end="(155, 48)" leading="" trailing=" " raw_val="pop" val="pop" full_name="Array.pop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(155, 49)" end="(160, 45)">
          <AtomNode start="(155, 49)" end="(155, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(155, 52)" end="(160, 45)">
            <AtomNode start="(155, 52)" end="(155, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(156, 3)" end="(160, 45)">
              <TacticTacticseq1IndentedNode start="(156, 3)" end="(160, 45)">
                <NullNode start="(156, 3)" end="(160, 45)">
                  <OtherNode start="(156, 3)" end="(156, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ as.extract i (j - 1) = (as.extract i j).pop" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ (as.extract i (j - 1)).size = (as.extract i j).pop.size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j - 1)).size&#10;h₂ : l &amp;lt; (as.extract i j).pop.size&#10;⊢ (as.extract i (j - 1))[l] = (as.extract i j).pop[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(156, 3)" end="(156, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(156, 7)" end="(156, 14)">
                      <OtherNode start="(156, 7)" end="(156, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(156, 7)" end="(156, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(156, 7)" end="(156, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(156, 9)" end="(156, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(156, 9)" end="(156, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(156, 9)" end="(156, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(156, 12)" end="(156, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(156, 12)" end="(156, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(156, 12)" end="(156, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(157, 3)" end="(158, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ (as.extract i (j - 1)).size = (as.extract i j).pop.size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j - 1)).size&#10;h₂ : l &amp;lt; (as.extract i j).pop.size&#10;⊢ (as.extract i (j - 1))[l] = (as.extract i j).pop[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j - 1)).size&#10;h₂ : l &amp;lt; (as.extract i j).pop.size&#10;⊢ (as.extract i (j - 1))[l] = (as.extract i j).pop[l]" tactic="· simp&#10;  omega">
                    <OtherNode start="(157, 3)" end="(157, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(157, 3)" end="(157, 4)" kind="patternIgnore">
                        <OtherNode start="(157, 3)" end="(157, 4)" kind="token.«· »">
                          <AtomNode start="(157, 3)" end="(157, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(157, 5)" end="(158, 10)">
                      <TacticTacticseq1IndentedNode start="(157, 5)" end="(158, 10)">
                        <NullNode start="(157, 5)" end="(158, 10)">
                          <OtherNode start="(157, 5)" end="(157, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ (as.extract i (j - 1)).size = (as.extract i j).pop.size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ min (j - 1) as.size - i = min j as.size - i - 1" tactic="simp">
                            <AtomNode start="(157, 5)" end="(157, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(158, 5)" end="(158, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;⊢ min (j - 1) as.size - i = min j as.size - i - 1" state_after="no goals" tactic="omega">
                            <AtomNode start="(158, 5)" end="(158, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(159, 3)" end="(160, 45)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j - 1)).size&#10;h₂ : l &amp;lt; (as.extract i j).pop.size&#10;⊢ (as.extract i (j - 1))[l] = (as.extract i j).pop[l]" state_after="no goals" tactic="· simp only [size_extract, size_pop] at h₁ h₂&#10;  simp only [getElem_extract, getElem_pop]">
                    <OtherNode start="(159, 3)" end="(159, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(159, 3)" end="(159, 4)" kind="patternIgnore">
                        <OtherNode start="(159, 3)" end="(159, 4)" kind="token.«· »">
                          <AtomNode start="(159, 3)" end="(159, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(159, 5)" end="(160, 45)">
                      <TacticTacticseq1IndentedNode start="(159, 5)" end="(160, 45)">
                        <NullNode start="(159, 5)" end="(160, 45)">
                          <OtherNode start="(159, 5)" end="(159, 48)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i (j - 1)).size&#10;h₂ : l &amp;lt; (as.extract i j).pop.size&#10;⊢ (as.extract i (j - 1))[l] = (as.extract i j).pop[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j - 1)).size&#10;h₂✝ : l &amp;lt; (as.extract i j).pop.size&#10;h₁ : l &amp;lt; min (j - 1) as.size - i&#10;h₂ : l &amp;lt; min j as.size - i - 1&#10;⊢ (as.extract i (j - 1))[l] = (as.extract i j).pop[l]" tactic="simp only [size_extract, size_pop] at h₁ h₂">
                            <AtomNode start="(159, 5)" end="(159, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(159, 10)" end="(159, 14)">
                              <AtomNode start="(159, 10)" end="(159, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(159, 15)" end="(159, 39)">
                              <AtomNode start="(159, 15)" end="(159, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(159, 16)" end="(159, 38)">
                                <OtherNode start="(159, 16)" end="(159, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(159, 16)" end="(159, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(159, 28)" end="(159, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(159, 30)" end="(159, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(159, 30)" end="(159, 38)" leading="" trailing="" raw_val="size_pop" val="size_pop" full_name="Array.size_pop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(159, 38)" end="(159, 39)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(159, 40)" end="(159, 48)">
                              <OtherNode start="(159, 40)" end="(159, 48)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(159, 40)" end="(159, 42)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(159, 43)" end="(159, 48)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(159, 43)" end="(159, 48)">
                                    <IdentNode start="(159, 43)" end="(159, 45)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(159, 46)" end="(159, 48)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(160, 5)" end="(160, 45)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j &amp;lt; as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i (j - 1)).size&#10;h₂✝ : l &amp;lt; (as.extract i j).pop.size&#10;h₁ : l &amp;lt; min (j - 1) as.size - i&#10;h₂ : l &amp;lt; min j as.size - i - 1&#10;⊢ (as.extract i (j - 1))[l] = (as.extract i j).pop[l]" state_after="no goals" tactic="simp only [getElem_extract, getElem_pop]">
                            <AtomNode start="(160, 5)" end="(160, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(160, 10)" end="(160, 14)">
                              <AtomNode start="(160, 10)" end="(160, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(160, 15)" end="(160, 45)">
                              <AtomNode start="(160, 15)" end="(160, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(160, 16)" end="(160, 44)">
                                <OtherNode start="(160, 16)" end="(160, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(160, 16)" end="(160, 31)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(160, 31)" end="(160, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(160, 33)" end="(160, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(160, 33)" end="(160, 44)" leading="" trailing="" raw_val="getElem_pop" val="getElem_pop" full_name="Array.getElem_pop" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(160, 44)" end="(160, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(162, 1)" end="(165, 29)" name="getElem?_extract_of_lt" full_name="Array.getElem?_extract_of_lt">
      <CommandDeclmodifiersNode start="(162, 1)" end="(162, 8)">
        <NullNode/>
        <NullNode start="(162, 1)" end="(162, 8)">
          <OtherNode start="(162, 1)" end="(162, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(162, 1)" end="(162, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(162, 3)" end="(162, 7)">
              <OtherNode start="(162, 3)" end="(162, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(162, 3)" end="(162, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(162, 3)" end="(162, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(162, 7)" end="(162, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(163, 1)" end="(165, 29)" name="getElem?_extract_of_lt" full_name="Array.getElem?_extract_of_lt" _is_private_decl="False">
        <AtomNode start="(163, 1)" end="(163, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(163, 9)" end="(163, 31)">
          <IdentNode start="(163, 9)" end="(163, 31)" leading="" trailing=" " raw_val="getElem?_extract_of_lt" val="getElem?_extract_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(163, 32)" end="(164, 55)">
          <NullNode start="(163, 32)" end="(163, 88)">
            <OtherNode start="(163, 32)" end="(163, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(163, 32)" end="(163, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(163, 33)" end="(163, 35)">
                <IdentNode start="(163, 33)" end="(163, 35)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(163, 36)" end="(163, 45)">
                <AtomNode start="(163, 36)" end="(163, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(163, 38)" end="(163, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(163, 38)" end="(163, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(163, 44)" end="(163, 45)">
                    <IdentNode start="(163, 44)" end="(163, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(163, 45)" end="(163, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(163, 47)" end="(163, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(163, 47)" end="(163, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(163, 48)" end="(163, 53)">
                <IdentNode start="(163, 48)" end="(163, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(163, 50)" end="(163, 51)" leading="" trailing=" " raw_val="j" val="j"/>
                <IdentNode start="(163, 52)" end="(163, 53)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(163, 54)" end="(163, 59)">
                <AtomNode start="(163, 54)" end="(163, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(163, 56)" end="(163, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(163, 59)" end="(163, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(163, 61)" end="(163, 88)">
              <AtomNode start="(163, 61)" end="(163, 62)" leading="" trailing="" val="("/>
              <NullNode start="(163, 62)" end="(163, 63)">
                <IdentNode start="(163, 62)" end="(163, 63)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(163, 64)" end="(163, 87)">
                <AtomNode start="(163, 64)" end="(163, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(163, 66)" end="(163, 87)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(163, 66)" end="(163, 67)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(163, 68)" end="(163, 69)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(163, 70)" end="(163, 87)" kind="«term_-_»">
                    <OtherNode start="(163, 70)" end="(163, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(163, 70)" end="(163, 73)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(163, 74)" end="(163, 83)">
                        <IdentNode start="(163, 74)" end="(163, 75)" leading="" trailing=" " raw_val="j" val="j"/>
                        <IdentNode start="(163, 76)" end="(163, 83)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(163, 84)" end="(163, 85)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(163, 86)" end="(163, 87)" leading="" trailing="" raw_val="i" val="i"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(163, 87)" end="(163, 88)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(163, 89)" end="(164, 55)">
            <AtomNode start="(163, 89)" end="(163, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(164, 5)" end="(164, 55)" kind="«term_=_»">
              <OtherNode start="(164, 5)" end="(164, 25)" kind="«term__[_]_?»">
                <OtherNode start="(164, 5)" end="(164, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(164, 5)" end="(164, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(164, 6)" end="(164, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(164, 6)" end="(164, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(164, 17)" end="(164, 20)">
                      <IdentNode start="(164, 17)" end="(164, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(164, 19)" end="(164, 20)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(164, 20)" end="(164, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(164, 21)" end="(164, 22)" leading="" trailing="" val="["/>
                <IdentNode start="(164, 22)" end="(164, 23)" leading="" trailing="" raw_val="k" val="k"/>
                <AtomNode start="(164, 23)" end="(164, 24)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(164, 24)" end="(164, 25)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(164, 26)" end="(164, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(164, 28)" end="(164, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(164, 28)" end="(164, 32)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(164, 33)" end="(164, 55)">
                  <OtherNode start="(164, 33)" end="(164, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(164, 33)" end="(164, 34)" leading="" trailing="" val="("/>
                    <OtherNode start="(164, 34)" end="(164, 54)" kind="«term__[_]'_»">
                      <IdentNode start="(164, 34)" end="(164, 36)" leading="" trailing="" raw_val="as" val="as"/>
                      <AtomNode start="(164, 36)" end="(164, 37)" leading="" trailing="" val="["/>
                      <OtherNode start="(164, 37)" end="(164, 42)" kind="«term_+_»">
                        <IdentNode start="(164, 37)" end="(164, 38)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(164, 39)" end="(164, 40)" leading="" trailing=" " val="+"/>
                        <IdentNode start="(164, 41)" end="(164, 42)" leading="" trailing="" raw_val="k" val="k"/>
                      </OtherNode>
                      <AtomNode start="(164, 42)" end="(164, 44)" leading="" trailing="" val="]'"/>
                      <OtherNode start="(164, 44)" end="(164, 54)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(164, 44)" end="(164, 45)" leading="" trailing="" val="("/>
                        <TermBytacticNode start="(164, 45)" end="(164, 53)">
                          <AtomNode start="(164, 45)" end="(164, 47)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(164, 48)" end="(164, 53)">
                            <TacticTacticseq1IndentedNode start="(164, 48)" end="(164, 53)">
                              <NullNode start="(164, 48)" end="(164, 53)">
                                <OtherNode start="(164, 48)" end="(164, 53)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.38878&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; min j as.size - i&#10;⊢ i + k &amp;lt; as.size" state_after="no goals" tactic="omega">
                                  <AtomNode start="(164, 48)" end="(164, 53)" leading="" trailing="" val="omega"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(164, 53)" end="(164, 54)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(164, 54)" end="(164, 55)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(164, 56)" end="(165, 29)">
          <AtomNode start="(164, 56)" end="(164, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(164, 59)" end="(165, 29)">
            <AtomNode start="(164, 59)" end="(164, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(165, 3)" end="(165, 29)">
              <TacticTacticseq1IndentedNode start="(165, 3)" end="(165, 29)">
                <NullNode start="(165, 3)" end="(165, 29)">
                  <OtherNode start="(165, 3)" end="(165, 29)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; min j as.size - i&#10;⊢ (as.extract i j)[k]? = some as[i + k]" state_after="no goals" tactic="simp [getElem?_extract, h]">
                    <AtomNode start="(165, 3)" end="(165, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(165, 8)" end="(165, 29)">
                      <AtomNode start="(165, 8)" end="(165, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(165, 9)" end="(165, 28)">
                        <OtherNode start="(165, 9)" end="(165, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(165, 9)" end="(165, 25)" leading="" trailing="" raw_val="getElem?_extract" val="getElem?_extract" full_name="Array.getElem?_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(165, 25)" end="(165, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(165, 27)" end="(165, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(165, 27)" end="(165, 28)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(165, 28)" end="(165, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(167, 1)" end="(170, 8)" name="getElem?_extract_of_succ" full_name="Array.getElem?_extract_of_succ">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(167, 1)" end="(170, 8)" name="getElem?_extract_of_succ" full_name="Array.getElem?_extract_of_succ" _is_private_decl="False">
        <AtomNode start="(167, 1)" end="(167, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(167, 9)" end="(167, 33)">
          <IdentNode start="(167, 9)" end="(167, 33)" leading="" trailing=" " raw_val="getElem?_extract_of_succ" val="getElem?_extract_of_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(167, 34)" end="(168, 40)">
          <NullNode start="(167, 34)" end="(167, 58)">
            <OtherNode start="(167, 34)" end="(167, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 34)" end="(167, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 35)" end="(167, 37)">
                <IdentNode start="(167, 35)" end="(167, 37)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(167, 38)" end="(167, 47)">
                <AtomNode start="(167, 38)" end="(167, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 40)" end="(167, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(167, 40)" end="(167, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(167, 46)" end="(167, 47)">
                    <IdentNode start="(167, 46)" end="(167, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(167, 47)" end="(167, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(167, 49)" end="(167, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 49)" end="(167, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 50)" end="(167, 51)">
                <IdentNode start="(167, 50)" end="(167, 51)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(167, 52)" end="(167, 57)">
                <AtomNode start="(167, 52)" end="(167, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(167, 54)" end="(167, 57)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(167, 57)" end="(167, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(167, 59)" end="(168, 40)">
            <AtomNode start="(167, 59)" end="(167, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(168, 5)" end="(168, 40)" kind="«term_=_»">
              <OtherNode start="(168, 5)" end="(168, 31)" kind="«term__[_]_?»">
                <OtherNode start="(168, 5)" end="(168, 27)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(168, 5)" end="(168, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(168, 6)" end="(168, 26)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(168, 6)" end="(168, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(168, 17)" end="(168, 26)">
                      <OtherNode start="(168, 17)" end="(168, 18)" kind="num">
                        <AtomNode start="(168, 17)" end="(168, 18)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                      <OtherNode start="(168, 19)" end="(168, 26)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(168, 19)" end="(168, 20)" leading="" trailing="" val="("/>
                        <OtherNode start="(168, 20)" end="(168, 25)" kind="«term_+_»">
                          <IdentNode start="(168, 20)" end="(168, 21)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(168, 22)" end="(168, 23)" leading="" trailing=" " val="+"/>
                          <OtherNode start="(168, 24)" end="(168, 25)" kind="num">
                            <AtomNode start="(168, 24)" end="(168, 25)" leading="" trailing="" val="1"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(168, 25)" end="(168, 26)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(168, 26)" end="(168, 27)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(168, 27)" end="(168, 28)" leading="" trailing="" val="["/>
                <IdentNode start="(168, 28)" end="(168, 29)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(168, 29)" end="(168, 30)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(168, 30)" end="(168, 31)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(168, 32)" end="(168, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(168, 34)" end="(168, 40)" kind="«term__[_]_?»">
                <IdentNode start="(168, 34)" end="(168, 36)" leading="" trailing="" raw_val="as" val="as"/>
                <GroupNode/>
                <AtomNode start="(168, 36)" end="(168, 37)" leading="" trailing="" val="["/>
                <IdentNode start="(168, 37)" end="(168, 38)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(168, 38)" end="(168, 39)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(168, 39)" end="(168, 40)" leading="" trailing=" " val="?"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(168, 41)" end="(170, 8)">
          <AtomNode start="(168, 41)" end="(168, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(168, 44)" end="(170, 8)">
            <AtomNode start="(168, 44)" end="(168, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(169, 3)" end="(170, 8)">
              <TacticTacticseq1IndentedNode start="(169, 3)" end="(170, 8)">
                <NullNode start="(169, 3)" end="(170, 8)">
                  <OtherNode start="(169, 3)" end="(169, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;j : Nat&#10;⊢ (as.extract 0 (j + 1))[j]? = as[j]?" state_after="α : Type u_1&#10;as : Array α&#10;j : Nat&#10;⊢ min (j + 1) as.size ≤ j → as.size ≤ j" tactic="simp [getElem?_extract]">
                    <AtomNode start="(169, 3)" end="(169, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(169, 8)" end="(169, 26)">
                      <AtomNode start="(169, 8)" end="(169, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(169, 9)" end="(169, 25)">
                        <OtherNode start="(169, 9)" end="(169, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(169, 9)" end="(169, 25)" leading="" trailing="" raw_val="getElem?_extract" val="getElem?_extract" full_name="Array.getElem?_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(169, 25)" end="(169, 26)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(170, 3)" end="(170, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;j : Nat&#10;⊢ min (j + 1) as.size ≤ j → as.size ≤ j" state_after="no goals" tactic="omega">
                    <AtomNode start="(170, 3)" end="(170, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(172, 1)" end="(178, 25)" name="extract_extract" full_name="Array.extract_extract">
      <CommandDeclmodifiersNode start="(172, 1)" end="(172, 8)">
        <NullNode/>
        <NullNode start="(172, 1)" end="(172, 8)">
          <OtherNode start="(172, 1)" end="(172, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(172, 1)" end="(172, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(172, 3)" end="(172, 7)">
              <OtherNode start="(172, 3)" end="(172, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(172, 3)" end="(172, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(172, 3)" end="(172, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(172, 7)" end="(172, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(172, 9)" end="(178, 25)" name="extract_extract" full_name="Array.extract_extract" _is_private_decl="False">
        <AtomNode start="(172, 9)" end="(172, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(172, 17)" end="(172, 32)">
          <IdentNode start="(172, 17)" end="(172, 32)" leading="" trailing=" " raw_val="extract_extract" val="extract_extract"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(172, 33)" end="(173, 70)">
          <NullNode start="(172, 33)" end="(172, 63)">
            <OtherNode start="(172, 33)" end="(172, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(172, 33)" end="(172, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(172, 34)" end="(172, 36)">
                <IdentNode start="(172, 34)" end="(172, 36)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(172, 37)" end="(172, 46)">
                <AtomNode start="(172, 37)" end="(172, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(172, 39)" end="(172, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(172, 39)" end="(172, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(172, 45)" end="(172, 46)">
                    <IdentNode start="(172, 45)" end="(172, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(172, 46)" end="(172, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(172, 48)" end="(172, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(172, 48)" end="(172, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(172, 49)" end="(172, 56)">
                <IdentNode start="(172, 49)" end="(172, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(172, 51)" end="(172, 52)" leading="" trailing=" " raw_val="j" val="j"/>
                <IdentNode start="(172, 53)" end="(172, 54)" leading="" trailing=" " raw_val="k" val="k"/>
                <IdentNode start="(172, 55)" end="(172, 56)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(172, 57)" end="(172, 62)">
                <AtomNode start="(172, 57)" end="(172, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(172, 59)" end="(172, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(172, 62)" end="(172, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(172, 64)" end="(173, 70)">
            <AtomNode start="(172, 64)" end="(172, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(173, 5)" end="(173, 70)" kind="«term_=_»">
              <OtherNode start="(173, 5)" end="(173, 33)" kind="Lean.Parser.Term.app">
                <OtherNode start="(173, 5)" end="(173, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(173, 5)" end="(173, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(173, 5)" end="(173, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(173, 6)" end="(173, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(173, 6)" end="(173, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(173, 17)" end="(173, 20)">
                        <IdentNode start="(173, 17)" end="(173, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(173, 19)" end="(173, 20)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(173, 20)" end="(173, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(173, 21)" end="(173, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(173, 22)" end="(173, 29)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(173, 30)" end="(173, 33)">
                  <IdentNode start="(173, 30)" end="(173, 31)" leading="" trailing=" " raw_val="k" val="k"/>
                  <IdentNode start="(173, 32)" end="(173, 33)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(173, 34)" end="(173, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(173, 36)" end="(173, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(173, 36)" end="(173, 46)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(173, 47)" end="(173, 70)">
                  <OtherNode start="(173, 47)" end="(173, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(173, 47)" end="(173, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(173, 48)" end="(173, 53)" kind="«term_+_»">
                      <IdentNode start="(173, 48)" end="(173, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(173, 50)" end="(173, 51)" leading="" trailing=" " val="+"/>
                      <IdentNode start="(173, 52)" end="(173, 53)" leading="" trailing="" raw_val="k" val="k"/>
                    </OtherNode>
                    <AtomNode start="(173, 53)" end="(173, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(173, 55)" end="(173, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(173, 55)" end="(173, 56)" leading="" trailing="" val="("/>
                    <OtherNode start="(173, 56)" end="(173, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(173, 56)" end="(173, 59)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(173, 60)" end="(173, 69)">
                        <OtherNode start="(173, 60)" end="(173, 67)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(173, 60)" end="(173, 61)" leading="" trailing="" val="("/>
                          <OtherNode start="(173, 61)" end="(173, 66)" kind="«term_+_»">
                            <IdentNode start="(173, 61)" end="(173, 62)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(173, 63)" end="(173, 64)" leading="" trailing=" " val="+"/>
                            <IdentNode start="(173, 65)" end="(173, 66)" leading="" trailing="" raw_val="l" val="l"/>
                          </OtherNode>
                          <AtomNode start="(173, 66)" end="(173, 67)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(173, 68)" end="(173, 69)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(173, 69)" end="(173, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(173, 71)" end="(178, 25)">
          <AtomNode start="(173, 71)" end="(173, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(173, 74)" end="(178, 25)">
            <AtomNode start="(173, 74)" end="(173, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(174, 3)" end="(178, 25)">
              <TacticTacticseq1IndentedNode start="(174, 3)" end="(178, 25)">
                <NullNode start="(174, 3)" end="(178, 25)">
                  <OtherNode start="(174, 3)" end="(174, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;⊢ (as.extract i j).extract k l = as.extract (i + k) (min (i + l) j)" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;⊢ ((as.extract i j).extract k l).size = (as.extract (i + k) (min (i + l) j)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l m : Nat&#10;h₁ : m &amp;lt; ((as.extract i j).extract k l).size&#10;h₂ : m &amp;lt; (as.extract (i + k) (min (i + l) j)).size&#10;⊢ ((as.extract i j).extract k l)[m] = (as.extract (i + k) (min (i + l) j))[m]" tactic="ext m h₁ h₂">
                    <AtomNode start="(174, 3)" end="(174, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(174, 7)" end="(174, 14)">
                      <OtherNode start="(174, 7)" end="(174, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(174, 7)" end="(174, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(174, 7)" end="(174, 8)" leading="" trailing=" " raw_val="m" val="m"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(174, 9)" end="(174, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(174, 9)" end="(174, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(174, 9)" end="(174, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(174, 12)" end="(174, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(174, 12)" end="(174, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(174, 12)" end="(174, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(175, 3)" end="(176, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;⊢ ((as.extract i j).extract k l).size = (as.extract (i + k) (min (i + l) j)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l m : Nat&#10;h₁ : m &amp;lt; ((as.extract i j).extract k l).size&#10;h₂ : m &amp;lt; (as.extract (i + k) (min (i + l) j)).size&#10;⊢ ((as.extract i j).extract k l)[m] = (as.extract (i + k) (min (i + l) j))[m]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l m : Nat&#10;h₁ : m &amp;lt; ((as.extract i j).extract k l).size&#10;h₂ : m &amp;lt; (as.extract (i + k) (min (i + l) j)).size&#10;⊢ ((as.extract i j).extract k l)[m] = (as.extract (i + k) (min (i + l) j))[m]" tactic="· simp&#10;  omega">
                    <OtherNode start="(175, 3)" end="(175, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(175, 3)" end="(175, 4)" kind="patternIgnore">
                        <OtherNode start="(175, 3)" end="(175, 4)" kind="token.«· »">
                          <AtomNode start="(175, 3)" end="(175, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(175, 5)" end="(176, 10)">
                      <TacticTacticseq1IndentedNode start="(175, 5)" end="(176, 10)">
                        <NullNode start="(175, 5)" end="(176, 10)">
                          <OtherNode start="(175, 5)" end="(175, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;⊢ ((as.extract i j).extract k l).size = (as.extract (i + k) (min (i + l) j)).size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;⊢ min l (min j as.size - i) - k = min (i + l) (min j as.size) - (i + k)" tactic="simp">
                            <AtomNode start="(175, 5)" end="(175, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(176, 5)" end="(176, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k l : Nat&#10;⊢ min l (min j as.size - i) - k = min (i + l) (min j as.size) - (i + k)" state_after="no goals" tactic="omega">
                            <AtomNode start="(176, 5)" end="(176, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(177, 3)" end="(178, 25)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l m : Nat&#10;h₁ : m &amp;lt; ((as.extract i j).extract k l).size&#10;h₂ : m &amp;lt; (as.extract (i + k) (min (i + l) j)).size&#10;⊢ ((as.extract i j).extract k l)[m] = (as.extract (i + k) (min (i + l) j))[m]" state_after="no goals" tactic="· simp only [size_extract] at h₁ h₂&#10;  simp [Nat.add_assoc]">
                    <OtherNode start="(177, 3)" end="(177, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(177, 3)" end="(177, 4)" kind="patternIgnore">
                        <OtherNode start="(177, 3)" end="(177, 4)" kind="token.«· »">
                          <AtomNode start="(177, 3)" end="(177, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(177, 5)" end="(178, 25)">
                      <TacticTacticseq1IndentedNode start="(177, 5)" end="(178, 25)">
                        <NullNode start="(177, 5)" end="(178, 25)">
                          <OtherNode start="(177, 5)" end="(177, 38)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l m : Nat&#10;h₁ : m &amp;lt; ((as.extract i j).extract k l).size&#10;h₂ : m &amp;lt; (as.extract (i + k) (min (i + l) j)).size&#10;⊢ ((as.extract i j).extract k l)[m] = (as.extract (i + k) (min (i + l) j))[m]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l m : Nat&#10;h₁✝ : m &amp;lt; ((as.extract i j).extract k l).size&#10;h₂✝ : m &amp;lt; (as.extract (i + k) (min (i + l) j)).size&#10;h₁ : m &amp;lt; min l (min j as.size - i) - k&#10;h₂ : m &amp;lt; min (min (i + l) j) as.size - (i + k)&#10;⊢ ((as.extract i j).extract k l)[m] = (as.extract (i + k) (min (i + l) j))[m]" tactic="simp only [size_extract] at h₁ h₂">
                            <AtomNode start="(177, 5)" end="(177, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(177, 10)" end="(177, 14)">
                              <AtomNode start="(177, 10)" end="(177, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(177, 15)" end="(177, 29)">
                              <AtomNode start="(177, 15)" end="(177, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(177, 16)" end="(177, 28)">
                                <OtherNode start="(177, 16)" end="(177, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(177, 16)" end="(177, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(177, 28)" end="(177, 29)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(177, 30)" end="(177, 38)">
                              <OtherNode start="(177, 30)" end="(177, 38)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(177, 30)" end="(177, 32)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(177, 33)" end="(177, 38)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(177, 33)" end="(177, 38)">
                                    <IdentNode start="(177, 33)" end="(177, 35)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(177, 36)" end="(177, 38)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(178, 5)" end="(178, 25)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k l m : Nat&#10;h₁✝ : m &amp;lt; ((as.extract i j).extract k l).size&#10;h₂✝ : m &amp;lt; (as.extract (i + k) (min (i + l) j)).size&#10;h₁ : m &amp;lt; min l (min j as.size - i) - k&#10;h₂ : m &amp;lt; min (min (i + l) j) as.size - (i + k)&#10;⊢ ((as.extract i j).extract k l)[m] = (as.extract (i + k) (min (i + l) j))[m]" state_after="no goals" tactic="simp [Nat.add_assoc]">
                            <AtomNode start="(178, 5)" end="(178, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(178, 10)" end="(178, 25)">
                              <AtomNode start="(178, 10)" end="(178, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(178, 11)" end="(178, 24)">
                                <OtherNode start="(178, 11)" end="(178, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(178, 11)" end="(178, 24)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(178, 24)" end="(178, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(180, 1)" end="(182, 11)" name="extract_eq_empty_of_eq_empty" full_name="Array.extract_eq_empty_of_eq_empty">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(180, 1)" end="(182, 11)" name="extract_eq_empty_of_eq_empty" full_name="Array.extract_eq_empty_of_eq_empty" _is_private_decl="False">
        <AtomNode start="(180, 1)" end="(180, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(180, 9)" end="(180, 37)">
          <IdentNode start="(180, 9)" end="(180, 37)" leading="" trailing=" " raw_val="extract_eq_empty_of_eq_empty" val="extract_eq_empty_of_eq_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(180, 38)" end="(181, 25)">
          <NullNode start="(180, 38)" end="(180, 79)">
            <OtherNode start="(180, 38)" end="(180, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(180, 38)" end="(180, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(180, 39)" end="(180, 41)">
                <IdentNode start="(180, 39)" end="(180, 41)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(180, 42)" end="(180, 51)">
                <AtomNode start="(180, 42)" end="(180, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(180, 44)" end="(180, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(180, 44)" end="(180, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(180, 50)" end="(180, 51)">
                    <IdentNode start="(180, 50)" end="(180, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(180, 51)" end="(180, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(180, 53)" end="(180, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(180, 53)" end="(180, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(180, 54)" end="(180, 57)">
                <IdentNode start="(180, 54)" end="(180, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(180, 56)" end="(180, 57)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(180, 58)" end="(180, 63)">
                <AtomNode start="(180, 58)" end="(180, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(180, 60)" end="(180, 63)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(180, 63)" end="(180, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(180, 65)" end="(180, 79)">
              <AtomNode start="(180, 65)" end="(180, 66)" leading="" trailing="" val="("/>
              <NullNode start="(180, 66)" end="(180, 67)">
                <IdentNode start="(180, 66)" end="(180, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(180, 68)" end="(180, 78)">
                <AtomNode start="(180, 68)" end="(180, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(180, 70)" end="(180, 78)" kind="«term_=_»">
                  <IdentNode start="(180, 70)" end="(180, 72)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(180, 73)" end="(180, 74)" leading="" trailing=" " val="="/>
                  <OtherNode start="(180, 75)" end="(180, 78)" kind="«term#[_,]»">
                    <AtomNode start="(180, 75)" end="(180, 77)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(180, 77)" end="(180, 78)" leading="" trailing="" val="]"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(180, 78)" end="(180, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(180, 80)" end="(181, 25)">
            <AtomNode start="(180, 80)" end="(180, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(181, 5)" end="(181, 25)" kind="«term_=_»">
              <OtherNode start="(181, 5)" end="(181, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(181, 5)" end="(181, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(181, 16)" end="(181, 19)">
                  <IdentNode start="(181, 16)" end="(181, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(181, 18)" end="(181, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(181, 20)" end="(181, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(181, 22)" end="(181, 25)" kind="«term#[_,]»">
                <AtomNode start="(181, 22)" end="(181, 24)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(181, 24)" end="(181, 25)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(181, 26)" end="(182, 11)">
          <AtomNode start="(181, 26)" end="(181, 28)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(181, 29)" end="(182, 11)">
            <AtomNode start="(181, 29)" end="(181, 31)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(182, 3)" end="(182, 11)">
              <TacticTacticseq1IndentedNode start="(182, 3)" end="(182, 11)">
                <NullNode start="(182, 3)" end="(182, 11)">
                  <OtherNode start="(182, 3)" end="(182, 11)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : as = #[]&#10;⊢ as.extract i j = #[]" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(182, 3)" end="(182, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(182, 8)" end="(182, 11)">
                      <AtomNode start="(182, 8)" end="(182, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(182, 9)" end="(182, 10)">
                        <OtherNode start="(182, 9)" end="(182, 10)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(182, 9)" end="(182, 10)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(182, 10)" end="(182, 11)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(184, 1)" end="(186, 36)" name="ne_empty_of_extract_ne_empty" full_name="Array.ne_empty_of_extract_ne_empty">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(184, 1)" end="(186, 36)" name="ne_empty_of_extract_ne_empty" full_name="Array.ne_empty_of_extract_ne_empty" _is_private_decl="False">
        <AtomNode start="(184, 1)" end="(184, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(184, 9)" end="(184, 37)">
          <IdentNode start="(184, 9)" end="(184, 37)" leading="" trailing=" " raw_val="ne_empty_of_extract_ne_empty" val="ne_empty_of_extract_ne_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(184, 38)" end="(185, 13)">
          <NullNode start="(184, 38)" end="(184, 91)">
            <OtherNode start="(184, 38)" end="(184, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(184, 38)" end="(184, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(184, 39)" end="(184, 41)">
                <IdentNode start="(184, 39)" end="(184, 41)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(184, 42)" end="(184, 51)">
                <AtomNode start="(184, 42)" end="(184, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(184, 44)" end="(184, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(184, 44)" end="(184, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(184, 50)" end="(184, 51)">
                    <IdentNode start="(184, 50)" end="(184, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(184, 51)" end="(184, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(184, 53)" end="(184, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(184, 53)" end="(184, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(184, 54)" end="(184, 57)">
                <IdentNode start="(184, 54)" end="(184, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(184, 56)" end="(184, 57)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(184, 58)" end="(184, 63)">
                <AtomNode start="(184, 58)" end="(184, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(184, 60)" end="(184, 63)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(184, 63)" end="(184, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(184, 65)" end="(184, 91)">
              <AtomNode start="(184, 65)" end="(184, 66)" leading="" trailing="" val="("/>
              <NullNode start="(184, 66)" end="(184, 67)">
                <IdentNode start="(184, 66)" end="(184, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(184, 68)" end="(184, 90)">
                <AtomNode start="(184, 68)" end="(184, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(184, 70)" end="(184, 90)" kind="«term_≠_»">
                  <OtherNode start="(184, 70)" end="(184, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(184, 70)" end="(184, 80)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(184, 81)" end="(184, 84)">
                      <IdentNode start="(184, 81)" end="(184, 82)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(184, 83)" end="(184, 84)" leading="" trailing=" " raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(184, 85)" end="(184, 86)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(184, 87)" end="(184, 90)" kind="«term#[_,]»">
                    <AtomNode start="(184, 87)" end="(184, 89)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(184, 89)" end="(184, 90)" leading="" trailing="" val="]"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(184, 90)" end="(184, 91)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(184, 92)" end="(185, 13)">
            <AtomNode start="(184, 92)" end="(184, 93)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(185, 5)" end="(185, 13)" kind="«term_≠_»">
              <IdentNode start="(185, 5)" end="(185, 7)" leading="" trailing=" " raw_val="as" val="as"/>
              <AtomNode start="(185, 8)" end="(185, 9)" leading="" trailing=" " val="≠"/>
              <OtherNode start="(185, 10)" end="(185, 13)" kind="«term#[_,]»">
                <AtomNode start="(185, 10)" end="(185, 12)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(185, 12)" end="(185, 13)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(185, 14)" end="(186, 36)">
          <AtomNode start="(185, 14)" end="(185, 16)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(186, 3)" end="(186, 36)" kind="Lean.Parser.Term.app">
            <IdentNode start="(186, 3)" end="(186, 5)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
            <NullNode start="(186, 6)" end="(186, 36)">
              <IdentNode start="(186, 6)" end="(186, 34)" leading="" trailing=" " raw_val="extract_eq_empty_of_eq_empty" val="extract_eq_empty_of_eq_empty" full_name="Array.extract_eq_empty_of_eq_empty" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(180, 9)" def_end="(180, 37)"/>
              <IdentNode start="(186, 35)" end="(186, 36)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(188, 1)" end="(212, 14)" name="extract_set" full_name="Array.extract_set">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(188, 1)" end="(212, 14)" name="extract_set" full_name="Array.extract_set" _is_private_decl="False">
        <AtomNode start="(188, 1)" end="(188, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(188, 9)" end="(188, 20)">
          <IdentNode start="(188, 9)" end="(188, 20)" leading="" trailing=" " raw_val="extract_set" val="extract_set"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(188, 21)" end="(194, 26)">
          <NullNode start="(188, 21)" end="(188, 75)">
            <OtherNode start="(188, 21)" end="(188, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 21)" end="(188, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 22)" end="(188, 24)">
                <IdentNode start="(188, 22)" end="(188, 24)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(188, 25)" end="(188, 34)">
                <AtomNode start="(188, 25)" end="(188, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 27)" end="(188, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(188, 27)" end="(188, 32)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(188, 33)" end="(188, 34)">
                    <IdentNode start="(188, 33)" end="(188, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(188, 34)" end="(188, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(188, 36)" end="(188, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 36)" end="(188, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 37)" end="(188, 42)">
                <IdentNode start="(188, 37)" end="(188, 38)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(188, 39)" end="(188, 40)" leading="" trailing=" " raw_val="j" val="j"/>
                <IdentNode start="(188, 41)" end="(188, 42)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(188, 43)" end="(188, 48)">
                <AtomNode start="(188, 43)" end="(188, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(188, 45)" end="(188, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(188, 48)" end="(188, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(188, 50)" end="(188, 67)">
              <AtomNode start="(188, 50)" end="(188, 51)" leading="" trailing="" val="("/>
              <NullNode start="(188, 51)" end="(188, 52)">
                <IdentNode start="(188, 51)" end="(188, 52)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(188, 53)" end="(188, 66)">
                <AtomNode start="(188, 53)" end="(188, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 55)" end="(188, 66)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(188, 55)" end="(188, 56)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(188, 57)" end="(188, 58)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(188, 59)" end="(188, 66)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(188, 66)" end="(188, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(188, 68)" end="(188, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 68)" end="(188, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 69)" end="(188, 70)">
                <IdentNode start="(188, 69)" end="(188, 70)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(188, 71)" end="(188, 74)">
                <AtomNode start="(188, 71)" end="(188, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(188, 73)" end="(188, 74)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(188, 74)" end="(188, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(188, 76)" end="(194, 26)">
            <AtomNode start="(188, 76)" end="(188, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(189, 5)" end="(194, 26)" kind="«term_=_»">
              <OtherNode start="(189, 5)" end="(189, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(189, 5)" end="(189, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(189, 5)" end="(189, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(189, 5)" end="(189, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(189, 6)" end="(189, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(189, 6)" end="(189, 12)" leading="" trailing=" " raw_val="as.set" val="as.set"/>
                      <NullNode start="(189, 13)" end="(189, 16)">
                        <IdentNode start="(189, 13)" end="(189, 14)" leading="" trailing=" " raw_val="k" val="k"/>
                        <IdentNode start="(189, 15)" end="(189, 16)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(189, 16)" end="(189, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(189, 17)" end="(189, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(189, 18)" end="(189, 25)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(189, 26)" end="(189, 29)">
                  <IdentNode start="(189, 26)" end="(189, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(189, 28)" end="(189, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(189, 30)" end="(189, 31)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(190, 7)" end="(194, 26)" kind="termDepIfThenElse">
                <AtomNode start="(190, 7)" end="(190, 9)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(190, 10)" end="(190, 11)">
                  <TermHoleNode start="(190, 10)" end="(190, 11)">
                    <AtomNode start="(190, 10)" end="(190, 11)" leading="" trailing=" " val="_"/>
                  </TermHoleNode>
                </LeanBinderidentNode>
                <AtomNode start="(190, 12)" end="(190, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 14)" end="(190, 19)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(190, 14)" end="(190, 15)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(190, 16)" end="(190, 17)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(190, 18)" end="(190, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(190, 20)" end="(190, 24)" leading="" trailing="&#10;        " val="then"/>
                <OtherNode start="(191, 9)" end="(191, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(191, 9)" end="(191, 19)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(191, 20)" end="(191, 23)">
                    <IdentNode start="(191, 20)" end="(191, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(191, 22)" end="(191, 23)" leading="" trailing="&#10;      " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(192, 7)" end="(192, 11)" leading="" trailing=" " val="else"/>
                <OtherNode start="(192, 12)" end="(194, 26)" kind="termDepIfThenElse">
                  <AtomNode start="(192, 12)" end="(192, 14)" leading="" trailing=" " val="if"/>
                  <LeanBinderidentNode start="(192, 15)" end="(192, 16)">
                    <TermHoleNode start="(192, 15)" end="(192, 16)">
                      <AtomNode start="(192, 15)" end="(192, 16)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </LeanBinderidentNode>
                  <AtomNode start="(192, 17)" end="(192, 18)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(192, 19)" end="(192, 36)" kind="«term_&amp;lt;_»">
                    <IdentNode start="(192, 19)" end="(192, 20)" leading="" trailing=" " raw_val="k" val="k"/>
                    <AtomNode start="(192, 21)" end="(192, 22)" leading="" trailing=" " val="&amp;lt;"/>
                    <OtherNode start="(192, 23)" end="(192, 36)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(192, 23)" end="(192, 26)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(192, 27)" end="(192, 36)">
                        <IdentNode start="(192, 27)" end="(192, 28)" leading="" trailing=" " raw_val="j" val="j"/>
                        <IdentNode start="(192, 29)" end="(192, 36)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(192, 37)" end="(192, 41)" leading="" trailing="&#10;        " val="then"/>
                  <OtherNode start="(193, 9)" end="(193, 56)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(193, 9)" end="(193, 29)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(193, 9)" end="(193, 25)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(193, 9)" end="(193, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(193, 10)" end="(193, 24)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(193, 10)" end="(193, 20)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                          <NullNode start="(193, 21)" end="(193, 24)">
                            <IdentNode start="(193, 21)" end="(193, 22)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(193, 23)" end="(193, 24)" leading="" trailing="" raw_val="j" val="j"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(193, 24)" end="(193, 25)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(193, 25)" end="(193, 26)" leading="" trailing="" val="."/>
                      <IdentNode start="(193, 26)" end="(193, 29)" leading="" trailing=" " raw_val="set" val="set" full_name="Array.set" mod_name="Init.Data.Array.Set" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Set.lean"/>
                    </OtherNode>
                    <NullNode start="(193, 30)" end="(193, 56)">
                      <OtherNode start="(193, 30)" end="(193, 37)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(193, 30)" end="(193, 31)" leading="" trailing="" val="("/>
                        <OtherNode start="(193, 31)" end="(193, 36)" kind="«term_-_»">
                          <IdentNode start="(193, 31)" end="(193, 32)" leading="" trailing=" " raw_val="k" val="k"/>
                          <AtomNode start="(193, 33)" end="(193, 34)" leading="" trailing=" " val="-"/>
                          <IdentNode start="(193, 35)" end="(193, 36)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                        <AtomNode start="(193, 36)" end="(193, 37)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(193, 38)" end="(193, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                      <OtherNode start="(193, 40)" end="(193, 56)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(193, 40)" end="(193, 41)" leading="" trailing="" val="("/>
                        <TermBytacticNode start="(193, 41)" end="(193, 55)">
                          <AtomNode start="(193, 41)" end="(193, 43)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(193, 44)" end="(193, 55)">
                            <TacticTacticseq1IndentedNode start="(193, 44)" end="(193, 55)">
                              <NullNode start="(193, 44)" end="(193, 55)">
                                <OtherNode start="(193, 44)" end="(193, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.50499&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;x✝¹ : ¬k &amp;lt; i&#10;x✝ : k &amp;lt; min j as.size&#10;⊢ k - i &amp;lt; (as.extract i j).size" state_after="α : Type ?u.50499&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;x✝¹ : ¬k &amp;lt; i&#10;x✝ : k &amp;lt; min j as.size&#10;⊢ k - i &amp;lt; min j as.size - i" tactic="simp">
                                  <AtomNode start="(193, 44)" end="(193, 48)" leading="" trailing="" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(193, 48)" end="(193, 49)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(193, 50)" end="(193, 55)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.50499&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;x✝¹ : ¬k &amp;lt; i&#10;x✝ : k &amp;lt; min j as.size&#10;⊢ k - i &amp;lt; min j as.size - i" state_after="no goals" tactic="omega">
                                  <AtomNode start="(193, 50)" end="(193, 55)" leading="" trailing="" val="omega"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(193, 55)" end="(193, 56)" leading="" trailing="&#10;      " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(194, 7)" end="(194, 11)" leading="" trailing=" " val="else"/>
                  <OtherNode start="(194, 12)" end="(194, 26)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(194, 12)" end="(194, 22)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(194, 23)" end="(194, 26)">
                      <IdentNode start="(194, 23)" end="(194, 24)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(194, 25)" end="(194, 26)" leading="" trailing=" " raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(194, 27)" end="(212, 14)">
          <AtomNode start="(194, 27)" end="(194, 29)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(194, 30)" end="(212, 14)">
            <AtomNode start="(194, 30)" end="(194, 32)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(195, 3)" end="(212, 14)">
              <TacticTacticseq1IndentedNode start="(195, 3)" end="(212, 14)">
                <NullNode start="(195, 3)" end="(212, 14)">
                  <OtherNode start="(195, 3)" end="(195, 8)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;⊢ (as.set k a h).extract i j =&#10;    if x : k &amp;lt; i then as.extract i j&#10;    else if x_1 : k &amp;lt; min j as.size then (as.extract i j).set (k - i) a ⋯ else as.extract i j" state_after="case isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = as.extract i j&#10;&#10;case isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : ¬k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = if x : k &amp;lt; min j as.size then (as.extract i j).set (k - i) a ⋯ else as.extract i j" tactic="split">
                    <AtomNode start="(195, 3)" end="(195, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(196, 3)" end="(200, 12)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = as.extract i j&#10;&#10;case isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : ¬k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = if x : k &amp;lt; min j as.size then (as.extract i j).set (k - i) a ⋯ else as.extract i j" state_after="case isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : ¬k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = if x : k &amp;lt; min j as.size then (as.extract i j).set (k - i) a ⋯ else as.extract i j" tactic="· ext l h₁ h₂&#10;  · simp&#10;  · simp at h₁ h₂&#10;    simp [getElem_set]&#10;    omega">
                    <OtherNode start="(196, 3)" end="(196, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(196, 3)" end="(196, 4)" kind="patternIgnore">
                        <OtherNode start="(196, 3)" end="(196, 4)" kind="token.«· »">
                          <AtomNode start="(196, 3)" end="(196, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(196, 5)" end="(200, 12)">
                      <TacticTacticseq1IndentedNode start="(196, 5)" end="(200, 12)">
                        <NullNode start="(196, 5)" end="(200, 12)">
                          <OtherNode start="(196, 5)" end="(196, 16)" kind="Lean.Elab.Tactic.Ext.ext" state_before="case isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = as.extract i j" state_after="case isTrue.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;⊢ ((as.set k a h).extract i j).size = (as.extract i j).size&#10;&#10;case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" tactic="ext l h₁ h₂">
                            <AtomNode start="(196, 5)" end="(196, 8)" leading="" trailing=" " val="ext"/>
                            <NullNode start="(196, 9)" end="(196, 16)">
                              <OtherNode start="(196, 9)" end="(196, 10)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(196, 9)" end="(196, 10)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(196, 9)" end="(196, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(196, 11)" end="(196, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(196, 11)" end="(196, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(196, 11)" end="(196, 13)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(196, 14)" end="(196, 16)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(196, 14)" end="(196, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(196, 14)" end="(196, 16)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(197, 5)" end="(197, 11)" kind="Lean.cdot" state_before="case isTrue.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;⊢ ((as.set k a h).extract i j).size = (as.extract i j).size&#10;&#10;case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" tactic="· simp">
                            <OtherNode start="(197, 5)" end="(197, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(197, 5)" end="(197, 6)" kind="patternIgnore">
                                <OtherNode start="(197, 5)" end="(197, 6)" kind="token.«· »">
                                  <AtomNode start="(197, 5)" end="(197, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(197, 7)" end="(197, 11)">
                              <TacticTacticseq1IndentedNode start="(197, 7)" end="(197, 11)">
                                <NullNode start="(197, 7)" end="(197, 11)">
                                  <OtherNode start="(197, 7)" end="(197, 11)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;⊢ ((as.set k a h).extract i j).size = (as.extract i j).size" state_after="no goals" tactic="simp">
                                    <AtomNode start="(197, 7)" end="(197, 11)" leading="" trailing="&#10;    " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(198, 5)" end="(200, 12)" kind="Lean.cdot" state_before="case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="no goals" tactic="· simp at h₁ h₂&#10;  simp [getElem_set]&#10;  omega">
                            <OtherNode start="(198, 5)" end="(198, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(198, 5)" end="(198, 6)" kind="patternIgnore">
                                <OtherNode start="(198, 5)" end="(198, 6)" kind="token.«· »">
                                  <AtomNode start="(198, 5)" end="(198, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(198, 7)" end="(200, 12)">
                              <TacticTacticseq1IndentedNode start="(198, 7)" end="(200, 12)">
                                <NullNode start="(198, 7)" end="(200, 12)">
                                  <OtherNode start="(198, 7)" end="(198, 20)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" tactic="simp at h₁ h₂">
                                    <AtomNode start="(198, 7)" end="(198, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(198, 12)" end="(198, 20)">
                                      <OtherNode start="(198, 12)" end="(198, 20)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(198, 12)" end="(198, 14)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(198, 15)" end="(198, 20)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(198, 15)" end="(198, 20)">
                                            <IdentNode start="(198, 15)" end="(198, 17)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                            <IdentNode start="(198, 18)" end="(198, 20)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(199, 7)" end="(199, 25)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ k = i + l → a = as[i + l]" tactic="simp [getElem_set]">
                                    <AtomNode start="(199, 7)" end="(199, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(199, 12)" end="(199, 25)">
                                      <AtomNode start="(199, 12)" end="(199, 13)" leading="" trailing="" val="["/>
                                      <NullNode start="(199, 13)" end="(199, 24)">
                                        <OtherNode start="(199, 13)" end="(199, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(199, 13)" end="(199, 24)" leading="" trailing="" raw_val="getElem_set" val="getElem_set" full_name="Array.getElem_set" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(199, 24)" end="(199, 25)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(200, 7)" end="(200, 12)" kind="Lean.Parser.Tactic.omega" state_before="case isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : k &amp;lt; i&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ k = i + l → a = as[i + l]" state_after="no goals" tactic="omega">
                                    <AtomNode start="(200, 7)" end="(200, 12)" leading="" trailing="&#10;  " val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(201, 3)" end="(212, 14)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : ¬k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = if x : k &amp;lt; min j as.size then (as.extract i j).set (k - i) a ⋯ else as.extract i j" state_after="no goals" tactic="· split&#10;  · ext l h₁ h₂&#10;    · simp&#10;    · simp only [getElem_extract, getElem_set]&#10;      split&#10;      · rw [if_pos]; omega&#10;      · rw [if_neg]; omega&#10;  · ext l h₁ h₂&#10;    · simp&#10;    · simp at h₁ h₂&#10;      simp [getElem_set]&#10;      omega">
                    <OtherNode start="(201, 3)" end="(201, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(201, 3)" end="(201, 4)" kind="patternIgnore">
                        <OtherNode start="(201, 3)" end="(201, 4)" kind="token.«· »">
                          <AtomNode start="(201, 3)" end="(201, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(201, 5)" end="(212, 14)">
                      <TacticTacticseq1IndentedNode start="(201, 5)" end="(212, 14)">
                        <NullNode start="(201, 5)" end="(212, 14)">
                          <OtherNode start="(201, 5)" end="(201, 10)" kind="Lean.Parser.Tactic.split" state_before="case isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝ : ¬k &amp;lt; i&#10;⊢ (as.set k a h).extract i j = if x : k &amp;lt; min j as.size then (as.extract i j).set (k - i) a ⋯ else as.extract i j" state_after="case isFalse.isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = (as.extract i j).set (k - i) a ⋯&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = as.extract i j" tactic="split">
                            <AtomNode start="(201, 5)" end="(201, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(202, 5)" end="(207, 29)" kind="Lean.cdot" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = (as.extract i j).set (k - i) a ⋯&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = as.extract i j" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = as.extract i j" tactic="· ext l h₁ h₂&#10;  · simp&#10;  · simp only [getElem_extract, getElem_set]&#10;    split&#10;    · rw [if_pos]; omega&#10;    · rw [if_neg]; omega">
                            <OtherNode start="(202, 5)" end="(202, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(202, 5)" end="(202, 6)" kind="patternIgnore">
                                <OtherNode start="(202, 5)" end="(202, 6)" kind="token.«· »">
                                  <AtomNode start="(202, 5)" end="(202, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(202, 7)" end="(207, 29)">
                              <TacticTacticseq1IndentedNode start="(202, 7)" end="(207, 29)">
                                <NullNode start="(202, 7)" end="(207, 29)">
                                  <OtherNode start="(202, 7)" end="(202, 18)" kind="Lean.Elab.Tactic.Ext.ext" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = (as.extract i j).set (k - i) a ⋯" state_after="case isFalse.isTrue.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;⊢ ((as.set k a h).extract i j).size = ((as.extract i j).set (k - i) a ⋯).size&#10;&#10;case isFalse.isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;⊢ ((as.set k a h).extract i j)[l] = ((as.extract i j).set (k - i) a ⋯)[l]" tactic="ext l h₁ h₂">
                                    <AtomNode start="(202, 7)" end="(202, 10)" leading="" trailing=" " val="ext"/>
                                    <NullNode start="(202, 11)" end="(202, 18)">
                                      <OtherNode start="(202, 11)" end="(202, 12)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(202, 11)" end="(202, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(202, 11)" end="(202, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(202, 13)" end="(202, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(202, 13)" end="(202, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(202, 13)" end="(202, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(202, 16)" end="(202, 18)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(202, 16)" end="(202, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(202, 16)" end="(202, 18)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(203, 7)" end="(203, 13)" kind="Lean.cdot" state_before="case isFalse.isTrue.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;⊢ ((as.set k a h).extract i j).size = ((as.extract i j).set (k - i) a ⋯).size&#10;&#10;case isFalse.isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;⊢ ((as.set k a h).extract i j)[l] = ((as.extract i j).set (k - i) a ⋯)[l]" state_after="case isFalse.isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;⊢ ((as.set k a h).extract i j)[l] = ((as.extract i j).set (k - i) a ⋯)[l]" tactic="· simp">
                                    <OtherNode start="(203, 7)" end="(203, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(203, 7)" end="(203, 8)" kind="patternIgnore">
                                        <OtherNode start="(203, 7)" end="(203, 8)" kind="token.«· »">
                                          <AtomNode start="(203, 7)" end="(203, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(203, 9)" end="(203, 13)">
                                      <TacticTacticseq1IndentedNode start="(203, 9)" end="(203, 13)">
                                        <NullNode start="(203, 9)" end="(203, 13)">
                                          <OtherNode start="(203, 9)" end="(203, 13)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isTrue.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;⊢ ((as.set k a h).extract i j).size = ((as.extract i j).set (k - i) a ⋯).size" state_after="no goals" tactic="simp">
                                            <AtomNode start="(203, 9)" end="(203, 13)" leading="" trailing="&#10;      " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(204, 7)" end="(207, 29)" kind="Lean.cdot" state_before="case isFalse.isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;⊢ ((as.set k a h).extract i j)[l] = ((as.extract i j).set (k - i) a ⋯)[l]" state_after="no goals" tactic="· simp only [getElem_extract, getElem_set]&#10;  split&#10;  · rw [if_pos]; omega&#10;  · rw [if_neg]; omega">
                                    <OtherNode start="(204, 7)" end="(204, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(204, 7)" end="(204, 8)" kind="patternIgnore">
                                        <OtherNode start="(204, 7)" end="(204, 8)" kind="token.«· »">
                                          <AtomNode start="(204, 7)" end="(204, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(204, 9)" end="(207, 29)">
                                      <TacticTacticseq1IndentedNode start="(204, 9)" end="(207, 29)">
                                        <NullNode start="(204, 9)" end="(207, 29)">
                                          <OtherNode start="(204, 9)" end="(204, 49)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;⊢ ((as.set k a h).extract i j)[l] = ((as.extract i j).set (k - i) a ⋯)[l]" state_after="case isFalse.isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;⊢ (if k = i + l then a else as[i + l]) = if k - i = l then a else as[i + l]" tactic="simp only [getElem_extract, getElem_set]">
                                            <AtomNode start="(204, 9)" end="(204, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(204, 14)" end="(204, 18)">
                                              <AtomNode start="(204, 14)" end="(204, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(204, 19)" end="(204, 49)">
                                              <AtomNode start="(204, 19)" end="(204, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(204, 20)" end="(204, 48)">
                                                <OtherNode start="(204, 20)" end="(204, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(204, 20)" end="(204, 35)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(204, 35)" end="(204, 36)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(204, 37)" end="(204, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(204, 37)" end="(204, 48)" leading="" trailing="" raw_val="getElem_set" val="getElem_set" full_name="Array.getElem_set" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(204, 48)" end="(204, 49)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(205, 9)" end="(205, 14)" kind="Lean.Parser.Tactic.split" state_before="case isFalse.isTrue.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;⊢ (if k = i + l then a else as[i + l]) = if k - i = l then a else as[i + l]" state_after="case isFalse.isTrue.h₂.isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : k = i + l&#10;⊢ a = if k - i = l then a else as[i + l]&#10;&#10;case isFalse.isTrue.h₂.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : ¬k = i + l&#10;⊢ as[i + l] = if k - i = l then a else as[i + l]" tactic="split">
                                            <AtomNode start="(205, 9)" end="(205, 14)" leading="" trailing="&#10;        " val="split"/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(206, 9)" end="(206, 29)" kind="Lean.cdot" state_before="case isFalse.isTrue.h₂.isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : k = i + l&#10;⊢ a = if k - i = l then a else as[i + l]&#10;&#10;case isFalse.isTrue.h₂.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : ¬k = i + l&#10;⊢ as[i + l] = if k - i = l then a else as[i + l]" state_after="case isFalse.isTrue.h₂.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : ¬k = i + l&#10;⊢ as[i + l] = if k - i = l then a else as[i + l]" tactic="· rw [if_pos]; omega">
                                            <OtherNode start="(206, 9)" end="(206, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(206, 9)" end="(206, 10)" kind="patternIgnore">
                                                <OtherNode start="(206, 9)" end="(206, 10)" kind="token.«· »">
                                                  <AtomNode start="(206, 9)" end="(206, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(206, 11)" end="(206, 29)">
                                              <TacticTacticseq1IndentedNode start="(206, 11)" end="(206, 29)">
                                                <NullNode start="(206, 11)" end="(206, 29)">
                                                  <OtherNode start="(206, 11)" end="(206, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse.isTrue.h₂.isTrue&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : k = i + l&#10;⊢ a = if k - i = l then a else as[i + l]" state_after="case isFalse.isTrue.h₂.isTrue.hc&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : k = i + l&#10;⊢ k - i = l" tactic="rw [if_pos]">
                                                    <AtomNode start="(206, 11)" end="(206, 13)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(206, 14)" end="(206, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(206, 14)" end="(206, 15)" leading="" trailing="" val="["/>
                                                      <NullNode start="(206, 15)" end="(206, 21)">
                                                        <OtherNode start="(206, 15)" end="(206, 21)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <IdentNode start="(206, 15)" end="(206, 21)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(206, 21)" end="(206, 22)" leading="" trailing="" val="]"/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(206, 22)" end="(206, 23)" leading="" trailing=" " val=";"/>
                                                  <OtherNode start="(206, 24)" end="(206, 29)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isTrue.h₂.isTrue.hc&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : k = i + l&#10;⊢ k - i = l" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(206, 24)" end="(206, 29)" leading="" trailing="&#10;        " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(207, 9)" end="(207, 29)" kind="Lean.cdot" state_before="case isFalse.isTrue.h₂.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : ¬k = i + l&#10;⊢ as[i + l] = if k - i = l then a else as[i + l]" state_after="no goals" tactic="· rw [if_neg]; omega">
                                            <OtherNode start="(207, 9)" end="(207, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(207, 9)" end="(207, 10)" kind="patternIgnore">
                                                <OtherNode start="(207, 9)" end="(207, 10)" kind="token.«· »">
                                                  <AtomNode start="(207, 9)" end="(207, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(207, 11)" end="(207, 29)">
                                              <TacticTacticseq1IndentedNode start="(207, 11)" end="(207, 29)">
                                                <NullNode start="(207, 11)" end="(207, 29)">
                                                  <OtherNode start="(207, 11)" end="(207, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse.isTrue.h₂.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : ¬k = i + l&#10;⊢ as[i + l] = if k - i = l then a else as[i + l]" state_after="case isFalse.isTrue.h₂.isFalse.hnc&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : ¬k = i + l&#10;⊢ ¬k - i = l" tactic="rw [if_neg]">
                                                    <AtomNode start="(207, 11)" end="(207, 13)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(207, 14)" end="(207, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(207, 14)" end="(207, 15)" leading="" trailing="" val="["/>
                                                      <NullNode start="(207, 15)" end="(207, 21)">
                                                        <OtherNode start="(207, 15)" end="(207, 21)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <IdentNode start="(207, 15)" end="(207, 21)" leading="" trailing="" raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(207, 21)" end="(207, 22)" leading="" trailing="" val="]"/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(207, 22)" end="(207, 23)" leading="" trailing=" " val=";"/>
                                                  <OtherNode start="(207, 24)" end="(207, 29)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isTrue.h₂.isFalse.hnc&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝² : ¬k &amp;lt; i&#10;h✝¹ : k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; ((as.extract i j).set (k - i) a ⋯).size&#10;h✝ : ¬k = i + l&#10;⊢ ¬k - i = l" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(207, 24)" end="(207, 29)" leading="" trailing="&#10;    " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(208, 5)" end="(212, 14)" kind="Lean.cdot" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = as.extract i j" state_after="no goals" tactic="· ext l h₁ h₂&#10;  · simp&#10;  · simp at h₁ h₂&#10;    simp [getElem_set]&#10;    omega">
                            <OtherNode start="(208, 5)" end="(208, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(208, 5)" end="(208, 6)" kind="patternIgnore">
                                <OtherNode start="(208, 5)" end="(208, 6)" kind="token.«· »">
                                  <AtomNode start="(208, 5)" end="(208, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(208, 7)" end="(212, 14)">
                              <TacticTacticseq1IndentedNode start="(208, 7)" end="(212, 14)">
                                <NullNode start="(208, 7)" end="(212, 14)">
                                  <OtherNode start="(208, 7)" end="(208, 18)" kind="Lean.Elab.Tactic.Ext.ext" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ (as.set k a h).extract i j = as.extract i j" state_after="case isFalse.isFalse.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ ((as.set k a h).extract i j).size = (as.extract i j).size&#10;&#10;case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" tactic="ext l h₁ h₂">
                                    <AtomNode start="(208, 7)" end="(208, 10)" leading="" trailing=" " val="ext"/>
                                    <NullNode start="(208, 11)" end="(208, 18)">
                                      <OtherNode start="(208, 11)" end="(208, 12)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(208, 11)" end="(208, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(208, 11)" end="(208, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(208, 13)" end="(208, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(208, 13)" end="(208, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(208, 13)" end="(208, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(208, 16)" end="(208, 18)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(208, 16)" end="(208, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(208, 16)" end="(208, 18)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(209, 7)" end="(209, 13)" kind="Lean.cdot" state_before="case isFalse.isFalse.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ ((as.set k a h).extract i j).size = (as.extract i j).size&#10;&#10;case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" tactic="· simp">
                                    <OtherNode start="(209, 7)" end="(209, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(209, 7)" end="(209, 8)" kind="patternIgnore">
                                        <OtherNode start="(209, 7)" end="(209, 8)" kind="token.«· »">
                                          <AtomNode start="(209, 7)" end="(209, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(209, 9)" end="(209, 13)">
                                      <TacticTacticseq1IndentedNode start="(209, 9)" end="(209, 13)">
                                        <NullNode start="(209, 9)" end="(209, 13)">
                                          <OtherNode start="(209, 9)" end="(209, 13)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isFalse.h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;⊢ ((as.set k a h).extract i j).size = (as.extract i j).size" state_after="no goals" tactic="simp">
                                            <AtomNode start="(209, 9)" end="(209, 13)" leading="" trailing="&#10;      " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(210, 7)" end="(212, 14)" kind="Lean.cdot" state_before="case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="no goals" tactic="· simp at h₁ h₂&#10;  simp [getElem_set]&#10;  omega">
                                    <OtherNode start="(210, 7)" end="(210, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(210, 7)" end="(210, 8)" kind="patternIgnore">
                                        <OtherNode start="(210, 7)" end="(210, 8)" kind="token.«· »">
                                          <AtomNode start="(210, 7)" end="(210, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(210, 9)" end="(212, 14)">
                                      <TacticTacticseq1IndentedNode start="(210, 9)" end="(212, 14)">
                                        <NullNode start="(210, 9)" end="(212, 14)">
                                          <OtherNode start="(210, 9)" end="(210, 22)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j).size&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" tactic="simp at h₁ h₂">
                                            <AtomNode start="(210, 9)" end="(210, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(210, 14)" end="(210, 22)">
                                              <OtherNode start="(210, 14)" end="(210, 22)" kind="Lean.Parser.Tactic.location">
                                                <AtomNode start="(210, 14)" end="(210, 16)" leading="" trailing=" " val="at"/>
                                                <OtherNode start="(210, 17)" end="(210, 22)" kind="Lean.Parser.Tactic.locationHyp">
                                                  <NullNode start="(210, 17)" end="(210, 22)">
                                                    <IdentNode start="(210, 17)" end="(210, 19)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                    <IdentNode start="(210, 20)" end="(210, 22)" leading="" trailing="&#10;        " raw_val="h₂" val="h₂"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(211, 9)" end="(211, 27)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ ((as.set k a h).extract i j)[l] = (as.extract i j)[l]" state_after="case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ k = i + l → a = as[i + l]" tactic="simp [getElem_set]">
                                            <AtomNode start="(211, 9)" end="(211, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(211, 14)" end="(211, 27)">
                                              <AtomNode start="(211, 14)" end="(211, 15)" leading="" trailing="" val="["/>
                                              <NullNode start="(211, 15)" end="(211, 26)">
                                                <OtherNode start="(211, 15)" end="(211, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(211, 15)" end="(211, 26)" leading="" trailing="" raw_val="getElem_set" val="getElem_set" full_name="Array.getElem_set" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(211, 26)" end="(211, 27)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(212, 9)" end="(212, 14)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isFalse.h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; as.size&#10;a : α&#10;h✝¹ : ¬k &amp;lt; i&#10;h✝ : ¬k &amp;lt; min j as.size&#10;l : Nat&#10;h₁✝ : l &amp;lt; ((as.set k a h).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ k = i + l → a = as[i + l]" state_after="no goals" tactic="omega">
                                            <AtomNode start="(212, 9)" end="(212, 14)" leading="" trailing="&#10;&#10;" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(214, 1)" end="(218, 27)" name="set_extract" full_name="Array.set_extract">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(214, 1)" end="(218, 27)" name="set_extract" full_name="Array.set_extract" _is_private_decl="False">
        <AtomNode start="(214, 1)" end="(214, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(214, 9)" end="(214, 20)">
          <IdentNode start="(214, 9)" end="(214, 20)" leading="" trailing=" " raw_val="set_extract" val="set_extract"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(214, 21)" end="(215, 84)">
          <NullNode start="(214, 21)" end="(214, 89)">
            <OtherNode start="(214, 21)" end="(214, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(214, 21)" end="(214, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(214, 22)" end="(214, 24)">
                <IdentNode start="(214, 22)" end="(214, 24)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(214, 25)" end="(214, 34)">
                <AtomNode start="(214, 25)" end="(214, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(214, 27)" end="(214, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(214, 27)" end="(214, 32)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(214, 33)" end="(214, 34)">
                    <IdentNode start="(214, 33)" end="(214, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(214, 34)" end="(214, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(214, 36)" end="(214, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(214, 36)" end="(214, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(214, 37)" end="(214, 42)">
                <IdentNode start="(214, 37)" end="(214, 38)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(214, 39)" end="(214, 40)" leading="" trailing=" " raw_val="j" val="j"/>
                <IdentNode start="(214, 41)" end="(214, 42)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(214, 43)" end="(214, 48)">
                <AtomNode start="(214, 43)" end="(214, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(214, 45)" end="(214, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(214, 48)" end="(214, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(214, 50)" end="(214, 81)">
              <AtomNode start="(214, 50)" end="(214, 51)" leading="" trailing="" val="("/>
              <NullNode start="(214, 51)" end="(214, 52)">
                <IdentNode start="(214, 51)" end="(214, 52)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(214, 53)" end="(214, 80)">
                <AtomNode start="(214, 53)" end="(214, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(214, 55)" end="(214, 80)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(214, 55)" end="(214, 56)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(214, 57)" end="(214, 58)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(214, 59)" end="(214, 80)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(214, 59)" end="(214, 75)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(214, 59)" end="(214, 60)" leading="" trailing="" val="("/>
                      <OtherNode start="(214, 60)" end="(214, 74)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(214, 60)" end="(214, 70)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                        <NullNode start="(214, 71)" end="(214, 74)">
                          <IdentNode start="(214, 71)" end="(214, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(214, 73)" end="(214, 74)" leading="" trailing="" raw_val="j" val="j"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(214, 74)" end="(214, 75)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(214, 75)" end="(214, 76)" leading="" trailing="" val="."/>
                    <IdentNode start="(214, 76)" end="(214, 80)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(214, 80)" end="(214, 81)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(214, 82)" end="(214, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(214, 82)" end="(214, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(214, 83)" end="(214, 84)">
                <IdentNode start="(214, 83)" end="(214, 84)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(214, 85)" end="(214, 88)">
                <AtomNode start="(214, 85)" end="(214, 86)" leading="" trailing=" " val=":"/>
                <IdentNode start="(214, 87)" end="(214, 88)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(214, 88)" end="(214, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(214, 90)" end="(215, 84)">
            <AtomNode start="(214, 90)" end="(214, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(215, 5)" end="(215, 84)" kind="«term_=_»">
              <OtherNode start="(215, 5)" end="(215, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(215, 5)" end="(215, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(215, 5)" end="(215, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(215, 5)" end="(215, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(215, 6)" end="(215, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(215, 6)" end="(215, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(215, 17)" end="(215, 20)">
                        <IdentNode start="(215, 17)" end="(215, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(215, 19)" end="(215, 20)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(215, 20)" end="(215, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(215, 21)" end="(215, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(215, 22)" end="(215, 25)" leading="" trailing=" " raw_val="set" val="set" full_name="Array.set" mod_name="Init.Data.Array.Set" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Set.lean"/>
                </OtherNode>
                <NullNode start="(215, 26)" end="(215, 29)">
                  <IdentNode start="(215, 26)" end="(215, 27)" leading="" trailing=" " raw_val="k" val="k"/>
                  <IdentNode start="(215, 28)" end="(215, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(215, 30)" end="(215, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(215, 32)" end="(215, 84)" kind="Lean.Parser.Term.app">
                <OtherNode start="(215, 32)" end="(215, 80)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(215, 32)" end="(215, 72)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(215, 32)" end="(215, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(215, 33)" end="(215, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(215, 33)" end="(215, 39)" leading="" trailing=" " raw_val="as.set" val="as.set"/>
                      <NullNode start="(215, 40)" end="(215, 71)">
                        <OtherNode start="(215, 40)" end="(215, 47)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(215, 40)" end="(215, 41)" leading="" trailing="" val="("/>
                          <OtherNode start="(215, 41)" end="(215, 46)" kind="«term_+_»">
                            <IdentNode start="(215, 41)" end="(215, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(215, 43)" end="(215, 44)" leading="" trailing=" " val="+"/>
                            <IdentNode start="(215, 45)" end="(215, 46)" leading="" trailing="" raw_val="k" val="k"/>
                          </OtherNode>
                          <AtomNode start="(215, 46)" end="(215, 47)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(215, 48)" end="(215, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                        <OtherNode start="(215, 50)" end="(215, 71)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(215, 50)" end="(215, 51)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(215, 51)" end="(215, 70)">
                            <AtomNode start="(215, 51)" end="(215, 53)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(215, 54)" end="(215, 70)">
                              <TacticTacticseq1IndentedNode start="(215, 54)" end="(215, 70)">
                                <NullNode start="(215, 54)" end="(215, 70)">
                                  <OtherNode start="(215, 54)" end="(215, 63)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.60939&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;⊢ i + k &amp;lt; as.size" state_after="α : Type ?u.60939&#10;as : Array α&#10;i j k : Nat&#10;a : α&#10;h : k &amp;lt; min j as.size - i&#10;⊢ i + k &amp;lt; as.size" tactic="simp at h">
                                    <AtomNode start="(215, 54)" end="(215, 58)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(215, 59)" end="(215, 63)">
                                      <OtherNode start="(215, 59)" end="(215, 63)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(215, 59)" end="(215, 61)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(215, 62)" end="(215, 63)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(215, 62)" end="(215, 63)">
                                            <IdentNode start="(215, 62)" end="(215, 63)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(215, 63)" end="(215, 64)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(215, 65)" end="(215, 70)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.60939&#10;as : Array α&#10;i j k : Nat&#10;a : α&#10;h : k &amp;lt; min j as.size - i&#10;⊢ i + k &amp;lt; as.size" state_after="no goals" tactic="omega">
                                    <AtomNode start="(215, 65)" end="(215, 70)" leading="" trailing="" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(215, 70)" end="(215, 71)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(215, 71)" end="(215, 72)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(215, 72)" end="(215, 73)" leading="" trailing="" val="."/>
                  <IdentNode start="(215, 73)" end="(215, 80)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(215, 81)" end="(215, 84)">
                  <IdentNode start="(215, 81)" end="(215, 82)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(215, 83)" end="(215, 84)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(215, 85)" end="(218, 27)">
          <AtomNode start="(215, 85)" end="(215, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(215, 88)" end="(218, 27)">
            <AtomNode start="(215, 88)" end="(215, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(216, 3)" end="(218, 27)">
              <TacticTacticseq1IndentedNode start="(216, 3)" end="(218, 27)">
                <NullNode start="(216, 3)" end="(218, 27)">
                  <OtherNode start="(216, 3)" end="(216, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;⊢ (as.extract i j).set k a h = (as.set (i + k) a ⋯).extract i j" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;⊢ ((as.extract i j).set k a h).size = ((as.set (i + k) a ⋯).extract i j).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).set k a h).size&#10;h₂ : l &amp;lt; ((as.set (i + k) a ⋯).extract i j).size&#10;⊢ ((as.extract i j).set k a h)[l] = ((as.set (i + k) a ⋯).extract i j)[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(216, 3)" end="(216, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(216, 7)" end="(216, 14)">
                      <OtherNode start="(216, 7)" end="(216, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(216, 7)" end="(216, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(216, 7)" end="(216, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(216, 9)" end="(216, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(216, 9)" end="(216, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(216, 9)" end="(216, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(216, 12)" end="(216, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(216, 12)" end="(216, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(216, 12)" end="(216, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(217, 3)" end="(217, 9)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;⊢ ((as.extract i j).set k a h).size = ((as.set (i + k) a ⋯).extract i j).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).set k a h).size&#10;h₂ : l &amp;lt; ((as.set (i + k) a ⋯).extract i j).size&#10;⊢ ((as.extract i j).set k a h)[l] = ((as.set (i + k) a ⋯).extract i j)[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).set k a h).size&#10;h₂ : l &amp;lt; ((as.set (i + k) a ⋯).extract i j).size&#10;⊢ ((as.extract i j).set k a h)[l] = ((as.set (i + k) a ⋯).extract i j)[l]" tactic="· simp">
                    <OtherNode start="(217, 3)" end="(217, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(217, 3)" end="(217, 4)" kind="patternIgnore">
                        <OtherNode start="(217, 3)" end="(217, 4)" kind="token.«· »">
                          <AtomNode start="(217, 3)" end="(217, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(217, 5)" end="(217, 9)">
                      <TacticTacticseq1IndentedNode start="(217, 5)" end="(217, 9)">
                        <NullNode start="(217, 5)" end="(217, 9)">
                          <OtherNode start="(217, 5)" end="(217, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;⊢ ((as.extract i j).set k a h).size = ((as.set (i + k) a ⋯).extract i j).size" state_after="no goals" tactic="simp">
                            <AtomNode start="(217, 5)" end="(217, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(218, 3)" end="(218, 27)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).set k a h).size&#10;h₂ : l &amp;lt; ((as.set (i + k) a ⋯).extract i j).size&#10;⊢ ((as.extract i j).set k a h)[l] = ((as.set (i + k) a ⋯).extract i j)[l]" state_after="no goals" tactic="· simp_all [getElem_set]">
                    <OtherNode start="(218, 3)" end="(218, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(218, 3)" end="(218, 4)" kind="patternIgnore">
                        <OtherNode start="(218, 3)" end="(218, 4)" kind="token.«· »">
                          <AtomNode start="(218, 3)" end="(218, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(218, 5)" end="(218, 27)">
                      <TacticTacticseq1IndentedNode start="(218, 5)" end="(218, 27)">
                        <NullNode start="(218, 5)" end="(218, 27)">
                          <OtherNode start="(218, 5)" end="(218, 27)" kind="Lean.Parser.Tactic.simpAll" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;h : k &amp;lt; (as.extract i j).size&#10;a : α&#10;l : Nat&#10;h₁ : l &amp;lt; ((as.extract i j).set k a h).size&#10;h₂ : l &amp;lt; ((as.set (i + k) a ⋯).extract i j).size&#10;⊢ ((as.extract i j).set k a h)[l] = ((as.set (i + k) a ⋯).extract i j)[l]" state_after="no goals" tactic="simp_all [getElem_set]">
                            <AtomNode start="(218, 5)" end="(218, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(218, 14)" end="(218, 27)">
                              <AtomNode start="(218, 14)" end="(218, 15)" leading="" trailing="" val="["/>
                              <NullNode start="(218, 15)" end="(218, 26)">
                                <OtherNode start="(218, 15)" end="(218, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(218, 15)" end="(218, 26)" leading="" trailing="" raw_val="getElem_set" val="getElem_set" full_name="Array.getElem_set" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(218, 26)" end="(218, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(220, 1)" end="(235, 14)" name="extract_append" full_name="Array.extract_append">
      <CommandDeclmodifiersNode start="(220, 1)" end="(220, 8)">
        <NullNode/>
        <NullNode start="(220, 1)" end="(220, 8)">
          <OtherNode start="(220, 1)" end="(220, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(220, 1)" end="(220, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(220, 3)" end="(220, 7)">
              <OtherNode start="(220, 3)" end="(220, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(220, 3)" end="(220, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(220, 3)" end="(220, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(220, 7)" end="(220, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(221, 1)" end="(235, 14)" name="extract_append" full_name="Array.extract_append" _is_private_decl="False">
        <AtomNode start="(221, 1)" end="(221, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(221, 9)" end="(221, 23)">
          <IdentNode start="(221, 9)" end="(221, 23)" leading="" trailing=" " raw_val="extract_append" val="extract_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(221, 24)" end="(222, 86)">
          <NullNode start="(221, 24)" end="(221, 53)">
            <OtherNode start="(221, 24)" end="(221, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(221, 24)" end="(221, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(221, 25)" end="(221, 30)">
                <IdentNode start="(221, 25)" end="(221, 27)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(221, 28)" end="(221, 30)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(221, 31)" end="(221, 40)">
                <AtomNode start="(221, 31)" end="(221, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(221, 33)" end="(221, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(221, 33)" end="(221, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(221, 39)" end="(221, 40)">
                    <IdentNode start="(221, 39)" end="(221, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(221, 40)" end="(221, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(221, 42)" end="(221, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(221, 42)" end="(221, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(221, 43)" end="(221, 46)">
                <IdentNode start="(221, 43)" end="(221, 44)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(221, 45)" end="(221, 46)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(221, 47)" end="(221, 52)">
                <AtomNode start="(221, 47)" end="(221, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(221, 49)" end="(221, 52)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(221, 52)" end="(221, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(221, 54)" end="(222, 86)">
            <AtomNode start="(221, 54)" end="(221, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(222, 5)" end="(222, 86)" kind="«term_=_»">
              <OtherNode start="(222, 5)" end="(222, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(222, 5)" end="(222, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(222, 5)" end="(222, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(222, 5)" end="(222, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(222, 6)" end="(222, 14)" kind="«term_++_»">
                      <IdentNode start="(222, 6)" end="(222, 8)" leading="" trailing=" " raw_val="as" val="as"/>
                      <AtomNode start="(222, 9)" end="(222, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(222, 12)" end="(222, 14)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </OtherNode>
                    <AtomNode start="(222, 14)" end="(222, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(222, 15)" end="(222, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(222, 16)" end="(222, 23)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(222, 24)" end="(222, 27)">
                  <IdentNode start="(222, 24)" end="(222, 25)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(222, 26)" end="(222, 27)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(222, 28)" end="(222, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(222, 30)" end="(222, 86)" kind="«term_++_»">
                <OtherNode start="(222, 30)" end="(222, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(222, 30)" end="(222, 40)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(222, 41)" end="(222, 44)">
                    <IdentNode start="(222, 41)" end="(222, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(222, 43)" end="(222, 44)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(222, 45)" end="(222, 47)" leading="" trailing=" " val="++"/>
                <OtherNode start="(222, 48)" end="(222, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(222, 48)" end="(222, 58)" leading="" trailing=" " raw_val="bs.extract" val="bs.extract"/>
                  <NullNode start="(222, 59)" end="(222, 86)">
                    <OtherNode start="(222, 59)" end="(222, 72)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(222, 59)" end="(222, 60)" leading="" trailing="" val="("/>
                      <OtherNode start="(222, 60)" end="(222, 71)" kind="«term_-_»">
                        <IdentNode start="(222, 60)" end="(222, 61)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(222, 62)" end="(222, 63)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(222, 64)" end="(222, 71)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                      </OtherNode>
                      <AtomNode start="(222, 71)" end="(222, 72)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(222, 73)" end="(222, 86)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(222, 73)" end="(222, 74)" leading="" trailing="" val="("/>
                      <OtherNode start="(222, 74)" end="(222, 85)" kind="«term_-_»">
                        <IdentNode start="(222, 74)" end="(222, 75)" leading="" trailing=" " raw_val="j" val="j"/>
                        <AtomNode start="(222, 76)" end="(222, 77)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(222, 78)" end="(222, 85)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                      </OtherNode>
                      <AtomNode start="(222, 85)" end="(222, 86)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(222, 87)" end="(235, 14)">
          <AtomNode start="(222, 87)" end="(222, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(222, 90)" end="(235, 14)">
            <AtomNode start="(222, 90)" end="(222, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(223, 3)" end="(235, 14)">
              <TacticTacticseq1IndentedNode start="(223, 3)" end="(235, 14)">
                <NullNode start="(223, 3)" end="(235, 14)">
                  <OtherNode start="(223, 3)" end="(223, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as bs : Array α&#10;i j : Nat&#10;⊢ (as ++ bs).extract i j = as.extract i j ++ bs.extract (i - as.size) (j - as.size)" state_after="case h₁&#10;α : Type u_1&#10;as bs : Array α&#10;i j : Nat&#10;⊢ ((as ++ bs).extract i j).size = (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;⊢ ((as ++ bs).extract i j)[l] = (as.extract i j ++ bs.extract (i - as.size) (j - as.size))[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(223, 3)" end="(223, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(223, 7)" end="(223, 14)">
                      <OtherNode start="(223, 7)" end="(223, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(223, 7)" end="(223, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(223, 7)" end="(223, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(223, 9)" end="(223, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(223, 9)" end="(223, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(223, 9)" end="(223, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(223, 12)" end="(223, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(223, 12)" end="(223, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(223, 12)" end="(223, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(224, 3)" end="(225, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as bs : Array α&#10;i j : Nat&#10;⊢ ((as ++ bs).extract i j).size = (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;&#10;case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;⊢ ((as ++ bs).extract i j)[l] = (as.extract i j ++ bs.extract (i - as.size) (j - as.size))[l]" state_after="case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;⊢ ((as ++ bs).extract i j)[l] = (as.extract i j ++ bs.extract (i - as.size) (j - as.size))[l]" tactic="· simp&#10;  omega">
                    <OtherNode start="(224, 3)" end="(224, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(224, 3)" end="(224, 4)" kind="patternIgnore">
                        <OtherNode start="(224, 3)" end="(224, 4)" kind="token.«· »">
                          <AtomNode start="(224, 3)" end="(224, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(224, 5)" end="(225, 10)">
                      <TacticTacticseq1IndentedNode start="(224, 5)" end="(225, 10)">
                        <NullNode start="(224, 5)" end="(225, 10)">
                          <OtherNode start="(224, 5)" end="(224, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as bs : Array α&#10;i j : Nat&#10;⊢ ((as ++ bs).extract i j).size = (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size" state_after="case h₁&#10;α : Type u_1&#10;as bs : Array α&#10;i j : Nat&#10;⊢ min j (as.size + bs.size) - i = min j as.size - i + (min (j - as.size) bs.size - (i - as.size))" tactic="simp">
                            <AtomNode start="(224, 5)" end="(224, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(225, 5)" end="(225, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as bs : Array α&#10;i j : Nat&#10;⊢ min j (as.size + bs.size) - i = min j as.size - i + (min (j - as.size) bs.size - (i - as.size))" state_after="no goals" tactic="omega">
                            <AtomNode start="(225, 5)" end="(225, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(226, 3)" end="(235, 14)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;⊢ ((as ++ bs).extract i j)[l] = (as.extract i j ++ bs.extract (i - as.size) (j - as.size))[l]" state_after="no goals" tactic="· simp only [size_extract, size_append] at h₁ h₂&#10;  simp only [getElem_extract, getElem_append, size_extract]&#10;  split&#10;  · split&#10;    · rfl&#10;    · omega&#10;  · split&#10;    · omega&#10;    · congr 1&#10;      omega">
                    <OtherNode start="(226, 3)" end="(226, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(226, 3)" end="(226, 4)" kind="patternIgnore">
                        <OtherNode start="(226, 3)" end="(226, 4)" kind="token.«· »">
                          <AtomNode start="(226, 3)" end="(226, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(226, 5)" end="(235, 14)">
                      <TacticTacticseq1IndentedNode start="(226, 5)" end="(235, 14)">
                        <NullNode start="(226, 5)" end="(235, 14)">
                          <OtherNode start="(226, 5)" end="(226, 51)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;⊢ ((as ++ bs).extract i j)[l] = (as.extract i j ++ bs.extract (i - as.size) (j - as.size))[l]" state_after="case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;⊢ ((as ++ bs).extract i j)[l] = (as.extract i j ++ bs.extract (i - as.size) (j - as.size))[l]" tactic="simp only [size_extract, size_append] at h₁ h₂">
                            <AtomNode start="(226, 5)" end="(226, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(226, 10)" end="(226, 14)">
                              <AtomNode start="(226, 10)" end="(226, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(226, 15)" end="(226, 42)">
                              <AtomNode start="(226, 15)" end="(226, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(226, 16)" end="(226, 41)">
                                <OtherNode start="(226, 16)" end="(226, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(226, 16)" end="(226, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(226, 28)" end="(226, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(226, 30)" end="(226, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(226, 30)" end="(226, 41)" leading="" trailing="" raw_val="size_append" val="size_append" full_name="Array.size_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(226, 41)" end="(226, 42)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(226, 43)" end="(226, 51)">
                              <OtherNode start="(226, 43)" end="(226, 51)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(226, 43)" end="(226, 45)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(226, 46)" end="(226, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(226, 46)" end="(226, 51)">
                                    <IdentNode start="(226, 46)" end="(226, 48)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(226, 49)" end="(226, 51)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(227, 5)" end="(227, 62)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;⊢ ((as ++ bs).extract i j)[l] = (as.extract i j ++ bs.extract (i - as.size) (j - as.size))[l]" state_after="case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;⊢ (if h' : i + l &amp;lt; as.size then as[i + l] else bs[i + l - as.size]) =&#10;    if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" tactic="simp only [getElem_extract, getElem_append, size_extract]">
                            <AtomNode start="(227, 5)" end="(227, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(227, 10)" end="(227, 14)">
                              <AtomNode start="(227, 10)" end="(227, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(227, 15)" end="(227, 62)">
                              <AtomNode start="(227, 15)" end="(227, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(227, 16)" end="(227, 61)">
                                <OtherNode start="(227, 16)" end="(227, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(227, 16)" end="(227, 31)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(227, 31)" end="(227, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(227, 33)" end="(227, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(227, 33)" end="(227, 47)" leading="" trailing="" raw_val="getElem_append" val="getElem_append" full_name="Array.getElem_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(227, 47)" end="(227, 48)" leading="" trailing=" " val=","/>
                                <OtherNode start="(227, 49)" end="(227, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(227, 49)" end="(227, 61)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(227, 61)" end="(227, 62)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(228, 5)" end="(228, 10)" kind="Lean.Parser.Tactic.split" state_before="case h₂&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;⊢ (if h' : i + l &amp;lt; as.size then as[i + l] else bs[i + l - as.size]) =&#10;    if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" state_after="case h₂.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : i + l &amp;lt; as.size&#10;⊢ as[i + l] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]&#10;&#10;case h₂.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : ¬i + l &amp;lt; as.size&#10;⊢ bs[i + l - as.size] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" tactic="split">
                            <AtomNode start="(228, 5)" end="(228, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(229, 5)" end="(231, 14)" kind="Lean.cdot" state_before="case h₂.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : i + l &amp;lt; as.size&#10;⊢ as[i + l] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]&#10;&#10;case h₂.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : ¬i + l &amp;lt; as.size&#10;⊢ bs[i + l - as.size] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" state_after="case h₂.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : ¬i + l &amp;lt; as.size&#10;⊢ bs[i + l - as.size] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" tactic="· split&#10;  · rfl&#10;  · omega">
                            <OtherNode start="(229, 5)" end="(229, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(229, 5)" end="(229, 6)" kind="patternIgnore">
                                <OtherNode start="(229, 5)" end="(229, 6)" kind="token.«· »">
                                  <AtomNode start="(229, 5)" end="(229, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(229, 7)" end="(231, 14)">
                              <TacticTacticseq1IndentedNode start="(229, 7)" end="(231, 14)">
                                <NullNode start="(229, 7)" end="(231, 14)">
                                  <OtherNode start="(229, 7)" end="(229, 12)" kind="Lean.Parser.Tactic.split" state_before="case h₂.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : i + l &amp;lt; as.size&#10;⊢ as[i + l] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" state_after="case h₂.isTrue.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = as[i + l]&#10;&#10;case h₂.isTrue.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = bs[i - as.size + (l - (min j as.size - i))]" tactic="split">
                                    <AtomNode start="(229, 7)" end="(229, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(230, 7)" end="(230, 12)" kind="Lean.cdot" state_before="case h₂.isTrue.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = as[i + l]&#10;&#10;case h₂.isTrue.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = bs[i - as.size + (l - (min j as.size - i))]" state_after="case h₂.isTrue.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = bs[i - as.size + (l - (min j as.size - i))]" tactic="· rfl">
                                    <OtherNode start="(230, 7)" end="(230, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(230, 7)" end="(230, 8)" kind="patternIgnore">
                                        <OtherNode start="(230, 7)" end="(230, 8)" kind="token.«· »">
                                          <AtomNode start="(230, 7)" end="(230, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(230, 9)" end="(230, 12)">
                                      <TacticTacticseq1IndentedNode start="(230, 9)" end="(230, 12)">
                                        <NullNode start="(230, 9)" end="(230, 12)">
                                          <OtherNode start="(230, 9)" end="(230, 12)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h₂.isTrue.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = as[i + l]" state_after="no goals" tactic="rfl">
                                            <AtomNode start="(230, 9)" end="(230, 12)" leading="" trailing="&#10;      " val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(231, 7)" end="(231, 14)" kind="Lean.cdot" state_before="case h₂.isTrue.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = bs[i - as.size + (l - (min j as.size - i))]" state_after="no goals" tactic="· omega">
                                    <OtherNode start="(231, 7)" end="(231, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(231, 7)" end="(231, 8)" kind="patternIgnore">
                                        <OtherNode start="(231, 7)" end="(231, 8)" kind="token.«· »">
                                          <AtomNode start="(231, 7)" end="(231, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(231, 9)" end="(231, 14)">
                                      <TacticTacticseq1IndentedNode start="(231, 9)" end="(231, 14)">
                                        <NullNode start="(231, 9)" end="(231, 14)">
                                          <OtherNode start="(231, 9)" end="(231, 14)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.isTrue.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ as[i + l] = bs[i - as.size + (l - (min j as.size - i))]" state_after="no goals" tactic="omega">
                                            <AtomNode start="(231, 9)" end="(231, 14)" leading="" trailing="&#10;    " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(232, 5)" end="(235, 14)" kind="Lean.cdot" state_before="case h₂.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : ¬i + l &amp;lt; as.size&#10;⊢ bs[i + l - as.size] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" state_after="no goals" tactic="· split&#10;  · omega&#10;  · congr 1&#10;    omega">
                            <OtherNode start="(232, 5)" end="(232, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(232, 5)" end="(232, 6)" kind="patternIgnore">
                                <OtherNode start="(232, 5)" end="(232, 6)" kind="token.«· »">
                                  <AtomNode start="(232, 5)" end="(232, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(232, 7)" end="(235, 14)">
                              <TacticTacticseq1IndentedNode start="(232, 7)" end="(235, 14)">
                                <NullNode start="(232, 7)" end="(235, 14)">
                                  <OtherNode start="(232, 7)" end="(232, 12)" kind="Lean.Parser.Tactic.split" state_before="case h₂.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝ : ¬i + l &amp;lt; as.size&#10;⊢ bs[i + l - as.size] = if h : l &amp;lt; min j as.size - i then as[i + l] else bs[i - as.size + (l - (min j as.size - i))]" state_after="case h₂.isFalse.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = as[i + l]&#10;&#10;case h₂.isFalse.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = bs[i - as.size + (l - (min j as.size - i))]" tactic="split">
                                    <AtomNode start="(232, 7)" end="(232, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(233, 7)" end="(233, 14)" kind="Lean.cdot" state_before="case h₂.isFalse.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = as[i + l]&#10;&#10;case h₂.isFalse.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = bs[i - as.size + (l - (min j as.size - i))]" state_after="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = bs[i - as.size + (l - (min j as.size - i))]" tactic="· omega">
                                    <OtherNode start="(233, 7)" end="(233, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(233, 7)" end="(233, 8)" kind="patternIgnore">
                                        <OtherNode start="(233, 7)" end="(233, 8)" kind="token.«· »">
                                          <AtomNode start="(233, 7)" end="(233, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(233, 9)" end="(233, 14)">
                                      <TacticTacticseq1IndentedNode start="(233, 9)" end="(233, 14)">
                                        <NullNode start="(233, 9)" end="(233, 14)">
                                          <OtherNode start="(233, 9)" end="(233, 14)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.isFalse.isTrue&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = as[i + l]" state_after="no goals" tactic="omega">
                                            <AtomNode start="(233, 9)" end="(233, 14)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(234, 7)" end="(235, 14)" kind="Lean.cdot" state_before="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = bs[i - as.size + (l - (min j as.size - i))]" state_after="no goals" tactic="· congr 1&#10;  omega">
                                    <OtherNode start="(234, 7)" end="(234, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(234, 7)" end="(234, 8)" kind="patternIgnore">
                                        <OtherNode start="(234, 7)" end="(234, 8)" kind="token.«· »">
                                          <AtomNode start="(234, 7)" end="(234, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(234, 9)" end="(235, 14)">
                                      <TacticTacticseq1IndentedNode start="(234, 9)" end="(235, 14)">
                                        <NullNode start="(234, 9)" end="(235, 14)">
                                          <OtherNode start="(234, 9)" end="(234, 16)" kind="Lean.Parser.Tactic.congr" state_before="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ bs[i + l - as.size] = bs[i - as.size + (l - (min j as.size - i))]" state_after="case h₂.isFalse.isFalse.e_i&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ i + l - as.size = i - as.size + (l - (min j as.size - i))" tactic="congr 1">
                                            <AtomNode start="(234, 9)" end="(234, 14)" leading="" trailing=" " val="congr"/>
                                            <NullNode start="(234, 15)" end="(234, 16)">
                                              <OtherNode start="(234, 15)" end="(234, 16)" kind="num">
                                                <AtomNode start="(234, 15)" end="(234, 16)" leading="" trailing="&#10;        " val="1"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(235, 9)" end="(235, 14)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.isFalse.isFalse.e_i&#10;α : Type u_1&#10;as bs : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; ((as ++ bs).extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i j ++ bs.extract (i - as.size) (j - as.size)).size&#10;h₁ : l &amp;lt; min j (as.size + bs.size) - i&#10;h₂ : l &amp;lt; min j as.size - i + (min (j - as.size) bs.size - (i - as.size))&#10;h✝¹ : ¬i + l &amp;lt; as.size&#10;h✝ : ¬l &amp;lt; min j as.size - i&#10;⊢ i + l - as.size = i - as.size + (l - (min j as.size - i))" state_after="no goals" tactic="omega">
                                            <AtomNode start="(235, 9)" end="(235, 14)" leading="" trailing="&#10;&#10;" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(237, 1)" end="(239, 7)" name="extract_append_left" full_name="Array.extract_append_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(237, 1)" end="(239, 7)" name="extract_append_left" full_name="Array.extract_append_left" _is_private_decl="False">
        <AtomNode start="(237, 1)" end="(237, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(237, 9)" end="(237, 28)">
          <IdentNode start="(237, 9)" end="(237, 28)" leading="" trailing=" " raw_val="extract_append_left" val="extract_append_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(237, 29)" end="(238, 56)">
          <NullNode start="(237, 29)" end="(237, 46)">
            <OtherNode start="(237, 29)" end="(237, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(237, 29)" end="(237, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(237, 30)" end="(237, 35)">
                <IdentNode start="(237, 30)" end="(237, 32)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(237, 33)" end="(237, 35)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(237, 36)" end="(237, 45)">
                <AtomNode start="(237, 36)" end="(237, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(237, 38)" end="(237, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(237, 38)" end="(237, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(237, 44)" end="(237, 45)">
                    <IdentNode start="(237, 44)" end="(237, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(237, 45)" end="(237, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(237, 47)" end="(238, 56)">
            <AtomNode start="(237, 47)" end="(237, 48)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(238, 5)" end="(238, 56)" kind="«term_=_»">
              <OtherNode start="(238, 5)" end="(238, 33)" kind="Lean.Parser.Term.app">
                <OtherNode start="(238, 5)" end="(238, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(238, 5)" end="(238, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(238, 5)" end="(238, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(238, 6)" end="(238, 14)" kind="«term_++_»">
                      <IdentNode start="(238, 6)" end="(238, 8)" leading="" trailing=" " raw_val="as" val="as"/>
                      <AtomNode start="(238, 9)" end="(238, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(238, 12)" end="(238, 14)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </OtherNode>
                    <AtomNode start="(238, 14)" end="(238, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(238, 15)" end="(238, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(238, 16)" end="(238, 23)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(238, 24)" end="(238, 33)">
                  <OtherNode start="(238, 24)" end="(238, 25)" kind="num">
                    <AtomNode start="(238, 24)" end="(238, 25)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(238, 26)" end="(238, 33)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(238, 34)" end="(238, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(238, 36)" end="(238, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(238, 36)" end="(238, 46)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(238, 47)" end="(238, 56)">
                  <OtherNode start="(238, 47)" end="(238, 48)" kind="num">
                    <AtomNode start="(238, 47)" end="(238, 48)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(238, 49)" end="(238, 56)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(238, 57)" end="(239, 7)">
          <AtomNode start="(238, 57)" end="(238, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(238, 60)" end="(239, 7)">
            <AtomNode start="(238, 60)" end="(238, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(239, 3)" end="(239, 7)">
              <TacticTacticseq1IndentedNode start="(239, 3)" end="(239, 7)">
                <NullNode start="(239, 3)" end="(239, 7)">
                  <OtherNode start="(239, 3)" end="(239, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as bs : Array α&#10;⊢ (as ++ bs).extract 0 as.size = as.extract" state_after="no goals" tactic="simp">
                    <AtomNode start="(239, 3)" end="(239, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(241, 1)" end="(245, 8)" name="extract_append_right" full_name="Array.extract_append_right">
      <CommandDeclmodifiersNode start="(241, 1)" end="(241, 8)">
        <NullNode/>
        <NullNode start="(241, 1)" end="(241, 8)">
          <OtherNode start="(241, 1)" end="(241, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(241, 1)" end="(241, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(241, 3)" end="(241, 7)">
              <OtherNode start="(241, 3)" end="(241, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(241, 3)" end="(241, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(241, 3)" end="(241, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(241, 7)" end="(241, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(241, 9)" end="(245, 8)" name="extract_append_right" full_name="Array.extract_append_right" _is_private_decl="False">
        <AtomNode start="(241, 9)" end="(241, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(241, 17)" end="(241, 37)">
          <IdentNode start="(241, 17)" end="(241, 37)" leading="" trailing=" " raw_val="extract_append_right" val="extract_append_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(241, 38)" end="(242, 62)">
          <NullNode start="(241, 38)" end="(241, 55)">
            <OtherNode start="(241, 38)" end="(241, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(241, 38)" end="(241, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(241, 39)" end="(241, 44)">
                <IdentNode start="(241, 39)" end="(241, 41)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(241, 42)" end="(241, 44)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(241, 45)" end="(241, 54)">
                <AtomNode start="(241, 45)" end="(241, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(241, 47)" end="(241, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(241, 47)" end="(241, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(241, 53)" end="(241, 54)">
                    <IdentNode start="(241, 53)" end="(241, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(241, 54)" end="(241, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(241, 56)" end="(242, 62)">
            <AtomNode start="(241, 56)" end="(241, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(242, 5)" end="(242, 62)" kind="«term_=_»">
              <OtherNode start="(242, 5)" end="(242, 45)" kind="Lean.Parser.Term.app">
                <OtherNode start="(242, 5)" end="(242, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(242, 5)" end="(242, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(242, 5)" end="(242, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(242, 6)" end="(242, 14)" kind="«term_++_»">
                      <IdentNode start="(242, 6)" end="(242, 8)" leading="" trailing=" " raw_val="as" val="as"/>
                      <AtomNode start="(242, 9)" end="(242, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(242, 12)" end="(242, 14)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </OtherNode>
                    <AtomNode start="(242, 14)" end="(242, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(242, 15)" end="(242, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(242, 16)" end="(242, 23)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(242, 24)" end="(242, 45)">
                  <IdentNode start="(242, 24)" end="(242, 31)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                  <OtherNode start="(242, 32)" end="(242, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(242, 32)" end="(242, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(242, 33)" end="(242, 44)" kind="«term_+_»">
                      <IdentNode start="(242, 33)" end="(242, 40)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                      <AtomNode start="(242, 41)" end="(242, 42)" leading="" trailing=" " val="+"/>
                      <IdentNode start="(242, 43)" end="(242, 44)" leading="" trailing="" raw_val="i" val="i"/>
                    </OtherNode>
                    <AtomNode start="(242, 44)" end="(242, 45)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(242, 46)" end="(242, 47)" leading="" trailing=" " val="="/>
              <OtherNode start="(242, 48)" end="(242, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(242, 48)" end="(242, 58)" leading="" trailing=" " raw_val="bs.extract" val="bs.extract"/>
                <NullNode start="(242, 59)" end="(242, 62)">
                  <OtherNode start="(242, 59)" end="(242, 60)" kind="num">
                    <AtomNode start="(242, 59)" end="(242, 60)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(242, 61)" end="(242, 62)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(242, 63)" end="(245, 8)">
          <AtomNode start="(242, 63)" end="(242, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(242, 66)" end="(245, 8)">
            <AtomNode start="(242, 66)" end="(242, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(243, 3)" end="(245, 8)">
              <TacticTacticseq1IndentedNode start="(243, 3)" end="(245, 8)">
                <NullNode start="(243, 3)" end="(245, 8)">
                  <OtherNode start="(243, 3)" end="(243, 76)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;i : Nat&#10;as bs : Array α&#10;⊢ (as ++ bs).extract as.size (as.size + i) = bs.extract 0 i" state_after="α : Type u_1&#10;i : Nat&#10;as bs : Array α&#10;⊢ bs.extract 0 (as.size + i - as.size) = bs.extract 0 i" tactic="simp only [extract_append, extract_size_left, Nat.sub_self, empty_append]">
                    <AtomNode start="(243, 3)" end="(243, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(243, 8)" end="(243, 12)">
                      <AtomNode start="(243, 8)" end="(243, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(243, 13)" end="(243, 76)">
                      <AtomNode start="(243, 13)" end="(243, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(243, 14)" end="(243, 75)">
                        <OtherNode start="(243, 14)" end="(243, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(243, 14)" end="(243, 28)" leading="" trailing="" raw_val="extract_append" val="extract_append" full_name="Array.extract_append" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(221, 9)" def_end="(221, 23)"/>
                        </OtherNode>
                        <AtomNode start="(243, 28)" end="(243, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(243, 30)" end="(243, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(243, 30)" end="(243, 47)" leading="" trailing="" raw_val="extract_size_left" val="extract_size_left" full_name="Array.extract_size_left" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(127, 9)" def_end="(127, 26)"/>
                        </OtherNode>
                        <AtomNode start="(243, 47)" end="(243, 48)" leading="" trailing=" " val=","/>
                        <OtherNode start="(243, 49)" end="(243, 61)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(243, 49)" end="(243, 61)" leading="" trailing="" raw_val="Nat.sub_self" val="Nat.sub_self" full_name="Nat.sub_self" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(243, 61)" end="(243, 62)" leading="" trailing=" " val=","/>
                        <OtherNode start="(243, 63)" end="(243, 75)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(243, 63)" end="(243, 75)" leading="" trailing="" raw_val="empty_append" val="empty_append" full_name="Array.empty_append" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(243, 75)" end="(243, 76)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(244, 3)" end="(244, 10)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;i : Nat&#10;as bs : Array α&#10;⊢ bs.extract 0 (as.size + i - as.size) = bs.extract 0 i" state_after="case e_stop&#10;α : Type u_1&#10;i : Nat&#10;as bs : Array α&#10;⊢ as.size + i - as.size = i" tactic="congr 1">
                    <AtomNode start="(244, 3)" end="(244, 8)" leading="" trailing=" " val="congr"/>
                    <NullNode start="(244, 9)" end="(244, 10)">
                      <OtherNode start="(244, 9)" end="(244, 10)" kind="num">
                        <AtomNode start="(244, 9)" end="(244, 10)" leading="" trailing="&#10;  " val="1"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(245, 3)" end="(245, 8)" kind="Lean.Parser.Tactic.omega" state_before="case e_stop&#10;α : Type u_1&#10;i : Nat&#10;as bs : Array α&#10;⊢ as.size + i - as.size = i" state_after="no goals" tactic="omega">
                    <AtomNode start="(245, 3)" end="(245, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(247, 1)" end="(252, 45)" name="map_extract" full_name="Array.map_extract">
      <CommandDeclmodifiersNode start="(247, 1)" end="(247, 8)">
        <NullNode/>
        <NullNode start="(247, 1)" end="(247, 8)">
          <OtherNode start="(247, 1)" end="(247, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(247, 1)" end="(247, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(247, 3)" end="(247, 7)">
              <OtherNode start="(247, 3)" end="(247, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(247, 3)" end="(247, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(247, 3)" end="(247, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(247, 7)" end="(247, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(247, 9)" end="(252, 45)" name="map_extract" full_name="Array.map_extract" _is_private_decl="False">
        <AtomNode start="(247, 9)" end="(247, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(247, 17)" end="(247, 28)">
          <IdentNode start="(247, 17)" end="(247, 28)" leading="" trailing=" " raw_val="map_extract" val="map_extract"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(247, 29)" end="(248, 52)">
          <NullNode start="(247, 29)" end="(247, 55)">
            <OtherNode start="(247, 29)" end="(247, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(247, 29)" end="(247, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(247, 30)" end="(247, 32)">
                <IdentNode start="(247, 30)" end="(247, 32)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(247, 33)" end="(247, 42)">
                <AtomNode start="(247, 33)" end="(247, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(247, 35)" end="(247, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(247, 35)" end="(247, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(247, 41)" end="(247, 42)">
                    <IdentNode start="(247, 41)" end="(247, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(247, 42)" end="(247, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(247, 44)" end="(247, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(247, 44)" end="(247, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(247, 45)" end="(247, 48)">
                <IdentNode start="(247, 45)" end="(247, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(247, 47)" end="(247, 48)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(247, 49)" end="(247, 54)">
                <AtomNode start="(247, 49)" end="(247, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(247, 51)" end="(247, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(247, 54)" end="(247, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(247, 56)" end="(248, 52)">
            <AtomNode start="(247, 56)" end="(247, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(248, 5)" end="(248, 52)" kind="«term_=_»">
              <OtherNode start="(248, 5)" end="(248, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(248, 5)" end="(248, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(248, 5)" end="(248, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(248, 5)" end="(248, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(248, 6)" end="(248, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(248, 6)" end="(248, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(248, 17)" end="(248, 20)">
                        <IdentNode start="(248, 17)" end="(248, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(248, 19)" end="(248, 20)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(248, 20)" end="(248, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(248, 21)" end="(248, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(248, 22)" end="(248, 25)" leading="" trailing=" " raw_val="map" val="map" full_name="Array.map" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(248, 26)" end="(248, 27)">
                  <IdentNode start="(248, 26)" end="(248, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(248, 28)" end="(248, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(248, 30)" end="(248, 52)" kind="Lean.Parser.Term.app">
                <OtherNode start="(248, 30)" end="(248, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(248, 30)" end="(248, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(248, 30)" end="(248, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(248, 31)" end="(248, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(248, 31)" end="(248, 37)" leading="" trailing=" " raw_val="as.map" val="as.map"/>
                      <NullNode start="(248, 38)" end="(248, 39)">
                        <IdentNode start="(248, 38)" end="(248, 39)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(248, 39)" end="(248, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(248, 40)" end="(248, 41)" leading="" trailing="" val="."/>
                  <IdentNode start="(248, 41)" end="(248, 48)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(248, 49)" end="(248, 52)">
                  <IdentNode start="(248, 49)" end="(248, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(248, 51)" end="(248, 52)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(248, 53)" end="(252, 45)">
          <AtomNode start="(248, 53)" end="(248, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(248, 56)" end="(252, 45)">
            <AtomNode start="(248, 56)" end="(248, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(249, 3)" end="(252, 45)">
              <TacticTacticseq1IndentedNode start="(249, 3)" end="(252, 45)">
                <NullNode start="(249, 3)" end="(252, 45)">
                  <OtherNode start="(249, 3)" end="(249, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j : Nat&#10;⊢ map f (as.extract i j) = (map f as).extract i j" state_after="case h₁&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j : Nat&#10;⊢ (map f (as.extract i j)).size = ((map f as).extract i j).size&#10;&#10;case h₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (map f (as.extract i j)).size&#10;h₂ : l &amp;lt; ((map f as).extract i j).size&#10;⊢ (map f (as.extract i j))[l] = ((map f as).extract i j)[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(249, 3)" end="(249, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(249, 7)" end="(249, 14)">
                      <OtherNode start="(249, 7)" end="(249, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(249, 7)" end="(249, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(249, 7)" end="(249, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(249, 9)" end="(249, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(249, 9)" end="(249, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(249, 9)" end="(249, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(249, 12)" end="(249, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(249, 12)" end="(249, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(249, 12)" end="(249, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(250, 3)" end="(250, 9)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j : Nat&#10;⊢ (map f (as.extract i j)).size = ((map f as).extract i j).size&#10;&#10;case h₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (map f (as.extract i j)).size&#10;h₂ : l &amp;lt; ((map f as).extract i j).size&#10;⊢ (map f (as.extract i j))[l] = ((map f as).extract i j)[l]" state_after="case h₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (map f (as.extract i j)).size&#10;h₂ : l &amp;lt; ((map f as).extract i j).size&#10;⊢ (map f (as.extract i j))[l] = ((map f as).extract i j)[l]" tactic="· simp">
                    <OtherNode start="(250, 3)" end="(250, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(250, 3)" end="(250, 4)" kind="patternIgnore">
                        <OtherNode start="(250, 3)" end="(250, 4)" kind="token.«· »">
                          <AtomNode start="(250, 3)" end="(250, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(250, 5)" end="(250, 9)">
                      <TacticTacticseq1IndentedNode start="(250, 5)" end="(250, 9)">
                        <NullNode start="(250, 5)" end="(250, 9)">
                          <OtherNode start="(250, 5)" end="(250, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j : Nat&#10;⊢ (map f (as.extract i j)).size = ((map f as).extract i j).size" state_after="no goals" tactic="simp">
                            <AtomNode start="(250, 5)" end="(250, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(251, 3)" end="(252, 45)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (map f (as.extract i j)).size&#10;h₂ : l &amp;lt; ((map f as).extract i j).size&#10;⊢ (map f (as.extract i j))[l] = ((map f as).extract i j)[l]" state_after="no goals" tactic="· simp only [size_map, size_extract] at h₁ h₂&#10;  simp only [getElem_map, getElem_extract]">
                    <OtherNode start="(251, 3)" end="(251, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(251, 3)" end="(251, 4)" kind="patternIgnore">
                        <OtherNode start="(251, 3)" end="(251, 4)" kind="token.«· »">
                          <AtomNode start="(251, 3)" end="(251, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(251, 5)" end="(252, 45)">
                      <TacticTacticseq1IndentedNode start="(251, 5)" end="(252, 45)">
                        <NullNode start="(251, 5)" end="(252, 45)">
                          <OtherNode start="(251, 5)" end="(251, 48)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (map f (as.extract i j)).size&#10;h₂ : l &amp;lt; ((map f as).extract i j).size&#10;⊢ (map f (as.extract i j))[l] = ((map f as).extract i j)[l]" state_after="case h₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (map f (as.extract i j)).size&#10;h₂✝ : l &amp;lt; ((map f as).extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ (map f (as.extract i j))[l] = ((map f as).extract i j)[l]" tactic="simp only [size_map, size_extract] at h₁ h₂">
                            <AtomNode start="(251, 5)" end="(251, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(251, 10)" end="(251, 14)">
                              <AtomNode start="(251, 10)" end="(251, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(251, 15)" end="(251, 39)">
                              <AtomNode start="(251, 15)" end="(251, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(251, 16)" end="(251, 38)">
                                <OtherNode start="(251, 16)" end="(251, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(251, 16)" end="(251, 24)" leading="" trailing="" raw_val="size_map" val="size_map" full_name="Array.size_map" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(251, 24)" end="(251, 25)" leading="" trailing=" " val=","/>
                                <OtherNode start="(251, 26)" end="(251, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(251, 26)" end="(251, 38)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(251, 38)" end="(251, 39)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(251, 40)" end="(251, 48)">
                              <OtherNode start="(251, 40)" end="(251, 48)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(251, 40)" end="(251, 42)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(251, 43)" end="(251, 48)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(251, 43)" end="(251, 48)">
                                    <IdentNode start="(251, 43)" end="(251, 45)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(251, 46)" end="(251, 48)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(252, 5)" end="(252, 45)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → α✝&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (map f (as.extract i j)).size&#10;h₂✝ : l &amp;lt; ((map f as).extract i j).size&#10;h₁ h₂ : l &amp;lt; min j as.size - i&#10;⊢ (map f (as.extract i j))[l] = ((map f as).extract i j)[l]" state_after="no goals" tactic="simp only [getElem_map, getElem_extract]">
                            <AtomNode start="(252, 5)" end="(252, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(252, 10)" end="(252, 14)">
                              <AtomNode start="(252, 10)" end="(252, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(252, 15)" end="(252, 45)">
                              <AtomNode start="(252, 15)" end="(252, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(252, 16)" end="(252, 44)">
                                <OtherNode start="(252, 16)" end="(252, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(252, 16)" end="(252, 27)" leading="" trailing="" raw_val="getElem_map" val="getElem_map" full_name="Array.getElem_map" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(252, 27)" end="(252, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(252, 29)" end="(252, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(252, 29)" end="(252, 44)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(252, 44)" end="(252, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(254, 1)" end="(259, 51)" name="extract_replicate" full_name="Array.extract_replicate">
      <CommandDeclmodifiersNode start="(254, 1)" end="(254, 8)">
        <NullNode/>
        <NullNode start="(254, 1)" end="(254, 8)">
          <OtherNode start="(254, 1)" end="(254, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(254, 1)" end="(254, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(254, 3)" end="(254, 7)">
              <OtherNode start="(254, 3)" end="(254, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(254, 3)" end="(254, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(254, 3)" end="(254, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(254, 7)" end="(254, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(254, 9)" end="(259, 51)" name="extract_replicate" full_name="Array.extract_replicate" _is_private_decl="False">
        <AtomNode start="(254, 9)" end="(254, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(254, 17)" end="(254, 34)">
          <IdentNode start="(254, 17)" end="(254, 34)" leading="" trailing=" " raw_val="extract_replicate" val="extract_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(254, 35)" end="(255, 60)">
          <NullNode start="(254, 35)" end="(254, 56)">
            <OtherNode start="(254, 35)" end="(254, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(254, 35)" end="(254, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(254, 36)" end="(254, 37)">
                <IdentNode start="(254, 36)" end="(254, 37)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(254, 38)" end="(254, 41)">
                <AtomNode start="(254, 38)" end="(254, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(254, 40)" end="(254, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(254, 41)" end="(254, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(254, 43)" end="(254, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(254, 43)" end="(254, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(254, 44)" end="(254, 49)">
                <IdentNode start="(254, 44)" end="(254, 45)" leading="" trailing=" " raw_val="n" val="n"/>
                <IdentNode start="(254, 46)" end="(254, 47)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(254, 48)" end="(254, 49)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(254, 50)" end="(254, 55)">
                <AtomNode start="(254, 50)" end="(254, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(254, 52)" end="(254, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(254, 55)" end="(254, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(254, 57)" end="(255, 60)">
            <AtomNode start="(254, 57)" end="(254, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(255, 5)" end="(255, 60)" kind="«term_=_»">
              <OtherNode start="(255, 5)" end="(255, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(255, 5)" end="(255, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(255, 5)" end="(255, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(255, 5)" end="(255, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(255, 6)" end="(255, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(255, 6)" end="(255, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(255, 16)" end="(255, 19)">
                        <IdentNode start="(255, 16)" end="(255, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(255, 18)" end="(255, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(255, 19)" end="(255, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(255, 20)" end="(255, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(255, 21)" end="(255, 28)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(255, 29)" end="(255, 32)">
                  <IdentNode start="(255, 29)" end="(255, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(255, 31)" end="(255, 32)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(255, 33)" end="(255, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(255, 35)" end="(255, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(255, 35)" end="(255, 44)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(255, 45)" end="(255, 60)">
                  <OtherNode start="(255, 45)" end="(255, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(255, 45)" end="(255, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(255, 46)" end="(255, 57)" kind="«term_-_»">
                      <OtherNode start="(255, 46)" end="(255, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(255, 46)" end="(255, 49)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(255, 50)" end="(255, 53)">
                          <IdentNode start="(255, 50)" end="(255, 51)" leading="" trailing=" " raw_val="j" val="j"/>
                          <IdentNode start="(255, 52)" end="(255, 53)" leading="" trailing=" " raw_val="n" val="n"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(255, 54)" end="(255, 55)" leading="" trailing=" " val="-"/>
                      <IdentNode start="(255, 56)" end="(255, 57)" leading="" trailing="" raw_val="i" val="i"/>
                    </OtherNode>
                    <AtomNode start="(255, 57)" end="(255, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(255, 59)" end="(255, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(255, 61)" end="(259, 51)">
          <AtomNode start="(255, 61)" end="(255, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(255, 64)" end="(259, 51)">
            <AtomNode start="(255, 64)" end="(255, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(256, 3)" end="(259, 51)">
              <TacticTacticseq1IndentedNode start="(256, 3)" end="(259, 51)">
                <NullNode start="(256, 3)" end="(259, 51)">
                  <OtherNode start="(256, 3)" end="(256, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;a : α&#10;n i j : Nat&#10;⊢ (replicate n a).extract i j = replicate (min j n - i) a" state_after="case h₁&#10;α : Type u_1&#10;a : α&#10;n i j : Nat&#10;⊢ ((replicate n a).extract i j).size = (replicate (min j n - i) a).size&#10;&#10;case h₂&#10;α : Type u_1&#10;a : α&#10;n i j l : Nat&#10;h₁ : l &amp;lt; ((replicate n a).extract i j).size&#10;h₂ : l &amp;lt; (replicate (min j n - i) a).size&#10;⊢ ((replicate n a).extract i j)[l] = (replicate (min j n - i) a)[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(256, 3)" end="(256, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(256, 7)" end="(256, 14)">
                      <OtherNode start="(256, 7)" end="(256, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(256, 7)" end="(256, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(256, 7)" end="(256, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(256, 9)" end="(256, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(256, 9)" end="(256, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(256, 9)" end="(256, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(256, 12)" end="(256, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(256, 12)" end="(256, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(256, 12)" end="(256, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(257, 3)" end="(257, 9)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;a : α&#10;n i j : Nat&#10;⊢ ((replicate n a).extract i j).size = (replicate (min j n - i) a).size&#10;&#10;case h₂&#10;α : Type u_1&#10;a : α&#10;n i j l : Nat&#10;h₁ : l &amp;lt; ((replicate n a).extract i j).size&#10;h₂ : l &amp;lt; (replicate (min j n - i) a).size&#10;⊢ ((replicate n a).extract i j)[l] = (replicate (min j n - i) a)[l]" state_after="case h₂&#10;α : Type u_1&#10;a : α&#10;n i j l : Nat&#10;h₁ : l &amp;lt; ((replicate n a).extract i j).size&#10;h₂ : l &amp;lt; (replicate (min j n - i) a).size&#10;⊢ ((replicate n a).extract i j)[l] = (replicate (min j n - i) a)[l]" tactic="· simp">
                    <OtherNode start="(257, 3)" end="(257, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(257, 3)" end="(257, 4)" kind="patternIgnore">
                        <OtherNode start="(257, 3)" end="(257, 4)" kind="token.«· »">
                          <AtomNode start="(257, 3)" end="(257, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(257, 5)" end="(257, 9)">
                      <TacticTacticseq1IndentedNode start="(257, 5)" end="(257, 9)">
                        <NullNode start="(257, 5)" end="(257, 9)">
                          <OtherNode start="(257, 5)" end="(257, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;a : α&#10;n i j : Nat&#10;⊢ ((replicate n a).extract i j).size = (replicate (min j n - i) a).size" state_after="no goals" tactic="simp">
                            <AtomNode start="(257, 5)" end="(257, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(258, 3)" end="(259, 51)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;a : α&#10;n i j l : Nat&#10;h₁ : l &amp;lt; ((replicate n a).extract i j).size&#10;h₂ : l &amp;lt; (replicate (min j n - i) a).size&#10;⊢ ((replicate n a).extract i j)[l] = (replicate (min j n - i) a)[l]" state_after="no goals" tactic="· simp only [size_extract, size_replicate] at h₁ h₂&#10;  simp only [getElem_extract, getElem_replicate]">
                    <OtherNode start="(258, 3)" end="(258, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(258, 3)" end="(258, 4)" kind="patternIgnore">
                        <OtherNode start="(258, 3)" end="(258, 4)" kind="token.«· »">
                          <AtomNode start="(258, 3)" end="(258, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(258, 5)" end="(259, 51)">
                      <TacticTacticseq1IndentedNode start="(258, 5)" end="(259, 51)">
                        <NullNode start="(258, 5)" end="(259, 51)">
                          <OtherNode start="(258, 5)" end="(258, 54)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;a : α&#10;n i j l : Nat&#10;h₁ : l &amp;lt; ((replicate n a).extract i j).size&#10;h₂ : l &amp;lt; (replicate (min j n - i) a).size&#10;⊢ ((replicate n a).extract i j)[l] = (replicate (min j n - i) a)[l]" state_after="case h₂&#10;α : Type u_1&#10;a : α&#10;n i j l : Nat&#10;h₁✝ : l &amp;lt; ((replicate n a).extract i j).size&#10;h₂✝ : l &amp;lt; (replicate (min j n - i) a).size&#10;h₁ h₂ : l &amp;lt; min j n - i&#10;⊢ ((replicate n a).extract i j)[l] = (replicate (min j n - i) a)[l]" tactic="simp only [size_extract, size_replicate] at h₁ h₂">
                            <AtomNode start="(258, 5)" end="(258, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(258, 10)" end="(258, 14)">
                              <AtomNode start="(258, 10)" end="(258, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(258, 15)" end="(258, 45)">
                              <AtomNode start="(258, 15)" end="(258, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(258, 16)" end="(258, 44)">
                                <OtherNode start="(258, 16)" end="(258, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(258, 16)" end="(258, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(258, 28)" end="(258, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(258, 30)" end="(258, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(258, 30)" end="(258, 44)" leading="" trailing="" raw_val="size_replicate" val="size_replicate" full_name="Array.size_replicate" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(258, 44)" end="(258, 45)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(258, 46)" end="(258, 54)">
                              <OtherNode start="(258, 46)" end="(258, 54)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(258, 46)" end="(258, 48)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(258, 49)" end="(258, 54)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(258, 49)" end="(258, 54)">
                                    <IdentNode start="(258, 49)" end="(258, 51)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(258, 52)" end="(258, 54)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(259, 5)" end="(259, 51)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;a : α&#10;n i j l : Nat&#10;h₁✝ : l &amp;lt; ((replicate n a).extract i j).size&#10;h₂✝ : l &amp;lt; (replicate (min j n - i) a).size&#10;h₁ h₂ : l &amp;lt; min j n - i&#10;⊢ ((replicate n a).extract i j)[l] = (replicate (min j n - i) a)[l]" state_after="no goals" tactic="simp only [getElem_extract, getElem_replicate]">
                            <AtomNode start="(259, 5)" end="(259, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(259, 10)" end="(259, 14)">
                              <AtomNode start="(259, 10)" end="(259, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(259, 15)" end="(259, 51)">
                              <AtomNode start="(259, 15)" end="(259, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(259, 16)" end="(259, 50)">
                                <OtherNode start="(259, 16)" end="(259, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(259, 16)" end="(259, 31)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(259, 31)" end="(259, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(259, 33)" end="(259, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(259, 33)" end="(259, 50)" leading="" trailing="" raw_val="getElem_replicate" val="getElem_replicate" full_name="Array.getElem_replicate" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(259, 50)" end="(259, 51)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(261, 1)" end="(262, 45)" name="extract_mkArray" full_name="Array.extract_mkArray">
      <CommandDeclmodifiersNode start="(261, 1)" end="(261, 56)">
        <NullNode/>
        <NullNode start="(261, 1)" end="(261, 56)">
          <OtherNode start="(261, 1)" end="(261, 56)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(261, 1)" end="(261, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(261, 3)" end="(261, 55)">
              <OtherNode start="(261, 3)" end="(261, 55)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(261, 3)" end="(261, 55)" kind="Lean.deprecated">
                  <AtomNode start="(261, 3)" end="(261, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(261, 14)" end="(261, 31)">
                    <IdentNode start="(261, 14)" end="(261, 31)" leading="" trailing=" " raw_val="extract_replicate" val="extract_replicate" full_name="Array.extract_replicate" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(254, 17)" def_end="(254, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(261, 32)" end="(261, 55)">
                    <AtomNode start="(261, 32)" end="(261, 33)" leading="" trailing="" val="("/>
                    <AtomNode start="(261, 33)" end="(261, 38)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(261, 39)" end="(261, 41)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(261, 42)" end="(261, 54)" kind="str">
                      <AtomNode start="(261, 42)" end="(261, 54)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(261, 54)" end="(261, 55)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(261, 55)" end="(261, 56)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(262, 1)" end="(262, 45)" name="extract_mkArray">
        <AtomNode start="(262, 1)" end="(262, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(262, 8)" end="(262, 23)">
          <IdentNode start="(262, 8)" end="(262, 23)" leading="" trailing=" " raw_val="extract_mkArray" val="extract_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(262, 24)" end="(262, 45)">
          <AtomNode start="(262, 24)" end="(262, 26)" leading="" trailing=" " val=":="/>
          <OtherNode start="(262, 27)" end="(262, 45)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(262, 27)" end="(262, 28)" leading="" trailing="" val="@"/>
            <IdentNode start="(262, 28)" end="(262, 45)" leading="" trailing="&#10;&#10;" raw_val="extract_replicate" val="extract_replicate" full_name="Array.extract_replicate" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(254, 17)" def_end="(254, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(264, 1)" end="(267, 7)" name="extract_eq_extract_right" full_name="Array.extract_eq_extract_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(264, 1)" end="(267, 7)" name="extract_eq_extract_right" full_name="Array.extract_eq_extract_right" _is_private_decl="False">
        <AtomNode start="(264, 1)" end="(264, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(264, 9)" end="(264, 33)">
          <IdentNode start="(264, 9)" end="(264, 33)" leading="" trailing=" " raw_val="extract_eq_extract_right" val="extract_eq_extract_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(264, 34)" end="(265, 94)">
          <NullNode start="(264, 34)" end="(264, 63)">
            <OtherNode start="(264, 34)" end="(264, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(264, 34)" end="(264, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(264, 35)" end="(264, 37)">
                <IdentNode start="(264, 35)" end="(264, 37)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(264, 38)" end="(264, 47)">
                <AtomNode start="(264, 38)" end="(264, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(264, 40)" end="(264, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(264, 40)" end="(264, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(264, 46)" end="(264, 47)">
                    <IdentNode start="(264, 46)" end="(264, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(264, 47)" end="(264, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(264, 49)" end="(264, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(264, 49)" end="(264, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(264, 50)" end="(264, 56)">
                <IdentNode start="(264, 50)" end="(264, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(264, 52)" end="(264, 53)" leading="" trailing=" " raw_val="j" val="j"/>
                <IdentNode start="(264, 54)" end="(264, 56)" leading="" trailing=" " raw_val="j'" val="j'"/>
              </NullNode>
              <NullNode start="(264, 57)" end="(264, 62)">
                <AtomNode start="(264, 57)" end="(264, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(264, 59)" end="(264, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(264, 62)" end="(264, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(264, 64)" end="(265, 94)">
            <AtomNode start="(264, 64)" end="(264, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(265, 5)" end="(265, 94)" kind="«term_↔_»">
              <OtherNode start="(265, 5)" end="(265, 37)" kind="«term_=_»">
                <OtherNode start="(265, 5)" end="(265, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(265, 5)" end="(265, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(265, 16)" end="(265, 19)">
                    <IdentNode start="(265, 16)" end="(265, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(265, 18)" end="(265, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(265, 20)" end="(265, 21)" leading="" trailing=" " val="="/>
                <OtherNode start="(265, 22)" end="(265, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(265, 22)" end="(265, 32)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(265, 33)" end="(265, 37)">
                    <IdentNode start="(265, 33)" end="(265, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(265, 35)" end="(265, 37)" leading="" trailing=" " raw_val="j'" val="j'"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(265, 38)" end="(265, 39)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(265, 40)" end="(265, 94)" kind="«term_=_»">
                <OtherNode start="(265, 40)" end="(265, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(265, 40)" end="(265, 43)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(265, 44)" end="(265, 65)">
                    <OtherNode start="(265, 44)" end="(265, 51)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(265, 44)" end="(265, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(265, 45)" end="(265, 50)" kind="«term_-_»">
                        <IdentNode start="(265, 45)" end="(265, 46)" leading="" trailing=" " raw_val="j" val="j"/>
                        <AtomNode start="(265, 47)" end="(265, 48)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(265, 49)" end="(265, 50)" leading="" trailing="" raw_val="i" val="i"/>
                      </OtherNode>
                      <AtomNode start="(265, 50)" end="(265, 51)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(265, 52)" end="(265, 65)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(265, 52)" end="(265, 53)" leading="" trailing="" val="("/>
                      <OtherNode start="(265, 53)" end="(265, 64)" kind="«term_-_»">
                        <IdentNode start="(265, 53)" end="(265, 60)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                        <AtomNode start="(265, 61)" end="(265, 62)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(265, 63)" end="(265, 64)" leading="" trailing="" raw_val="i" val="i"/>
                      </OtherNode>
                      <AtomNode start="(265, 64)" end="(265, 65)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(265, 66)" end="(265, 67)" leading="" trailing=" " val="="/>
                <OtherNode start="(265, 68)" end="(265, 94)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(265, 68)" end="(265, 71)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(265, 72)" end="(265, 94)">
                    <OtherNode start="(265, 72)" end="(265, 80)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(265, 72)" end="(265, 73)" leading="" trailing="" val="("/>
                      <OtherNode start="(265, 73)" end="(265, 79)" kind="«term_-_»">
                        <IdentNode start="(265, 73)" end="(265, 75)" leading="" trailing=" " raw_val="j'" val="j'"/>
                        <AtomNode start="(265, 76)" end="(265, 77)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(265, 78)" end="(265, 79)" leading="" trailing="" raw_val="i" val="i"/>
                      </OtherNode>
                      <AtomNode start="(265, 79)" end="(265, 80)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(265, 81)" end="(265, 94)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(265, 81)" end="(265, 82)" leading="" trailing="" val="("/>
                      <OtherNode start="(265, 82)" end="(265, 93)" kind="«term_-_»">
                        <IdentNode start="(265, 82)" end="(265, 89)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                        <AtomNode start="(265, 90)" end="(265, 91)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(265, 92)" end="(265, 93)" leading="" trailing="" raw_val="i" val="i"/>
                      </OtherNode>
                      <AtomNode start="(265, 93)" end="(265, 94)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(265, 95)" end="(267, 7)">
          <AtomNode start="(265, 95)" end="(265, 97)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(265, 98)" end="(267, 7)">
            <AtomNode start="(265, 98)" end="(265, 100)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(266, 3)" end="(267, 7)">
              <TacticTacticseq1IndentedNode start="(266, 3)" end="(267, 7)">
                <NullNode start="(266, 3)" end="(267, 7)">
                  <OtherNode start="(266, 3)" end="(266, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;as : Array α&#10;i j j' : Nat&#10;⊢ as.extract i j = as.extract i j' ↔ min (j - i) (as.size - i) = min (j' - i) (as.size - i)" state_after="case mk&#10;α : Type u_1&#10;i j j' : Nat&#10;as : List α&#10;⊢ { toList := as }.extract i j = { toList := as }.extract i j' ↔&#10;    min (j - i) ({ toList := as }.size - i) = min (j' - i) ({ toList := as }.size - i)" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(266, 3)" end="(266, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(266, 10)" end="(266, 12)">
                      <OtherNode start="(266, 10)" end="(266, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(266, 10)" end="(266, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(266, 13)" end="(266, 22)">
                      <AtomNode start="(266, 13)" end="(266, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(266, 18)" end="(266, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(266, 18)" end="(266, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(266, 18)" end="(266, 22)">
                            <OtherNode start="(266, 18)" end="(266, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(266, 18)" end="(266, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(266, 19)" end="(266, 21)">
                                <OtherNode start="(266, 19)" end="(266, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(266, 19)" end="(266, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(266, 19)" end="(266, 21)">
                                      <OtherNode start="(266, 19)" end="(266, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(266, 19)" end="(266, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(266, 21)" end="(266, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(267, 3)" end="(267, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i j j' : Nat&#10;as : List α&#10;⊢ { toList := as }.extract i j = { toList := as }.extract i j' ↔&#10;    min (j - i) ({ toList := as }.size - i) = min (j' - i) ({ toList := as }.size - i)" state_after="no goals" tactic="simp">
                    <AtomNode start="(267, 3)" end="(267, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(269, 1)" end="(281, 12)" name="extract_eq_extract_left" full_name="Array.extract_eq_extract_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(269, 1)" end="(281, 12)" name="extract_eq_extract_left" full_name="Array.extract_eq_extract_left" _is_private_decl="False">
        <AtomNode start="(269, 1)" end="(269, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(269, 9)" end="(269, 32)">
          <IdentNode start="(269, 9)" end="(269, 32)" leading="" trailing=" " raw_val="extract_eq_extract_left" val="extract_eq_extract_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(269, 33)" end="(270, 78)">
          <NullNode start="(269, 33)" end="(269, 62)">
            <OtherNode start="(269, 33)" end="(269, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(269, 33)" end="(269, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(269, 34)" end="(269, 36)">
                <IdentNode start="(269, 34)" end="(269, 36)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(269, 37)" end="(269, 46)">
                <AtomNode start="(269, 37)" end="(269, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(269, 39)" end="(269, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(269, 39)" end="(269, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(269, 45)" end="(269, 46)">
                    <IdentNode start="(269, 45)" end="(269, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(269, 46)" end="(269, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(269, 48)" end="(269, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(269, 48)" end="(269, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(269, 49)" end="(269, 55)">
                <IdentNode start="(269, 49)" end="(269, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(269, 51)" end="(269, 53)" leading="" trailing=" " raw_val="i'" val="i'"/>
                <IdentNode start="(269, 54)" end="(269, 55)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(269, 56)" end="(269, 61)">
                <AtomNode start="(269, 56)" end="(269, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(269, 58)" end="(269, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(269, 61)" end="(269, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(269, 63)" end="(270, 78)">
            <AtomNode start="(269, 63)" end="(269, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(270, 5)" end="(270, 78)" kind="«term_↔_»">
              <OtherNode start="(270, 5)" end="(270, 37)" kind="«term_=_»">
                <OtherNode start="(270, 5)" end="(270, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(270, 5)" end="(270, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(270, 16)" end="(270, 19)">
                    <IdentNode start="(270, 16)" end="(270, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(270, 18)" end="(270, 19)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(270, 20)" end="(270, 21)" leading="" trailing=" " val="="/>
                <OtherNode start="(270, 22)" end="(270, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(270, 22)" end="(270, 32)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(270, 33)" end="(270, 37)">
                    <IdentNode start="(270, 33)" end="(270, 35)" leading="" trailing=" " raw_val="i'" val="i'"/>
                    <IdentNode start="(270, 36)" end="(270, 37)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(270, 38)" end="(270, 39)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(270, 40)" end="(270, 78)" kind="«term_=_»">
                <OtherNode start="(270, 40)" end="(270, 57)" kind="«term_-_»">
                  <OtherNode start="(270, 40)" end="(270, 53)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(270, 40)" end="(270, 43)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(270, 44)" end="(270, 53)">
                      <IdentNode start="(270, 44)" end="(270, 45)" leading="" trailing=" " raw_val="j" val="j"/>
                      <IdentNode start="(270, 46)" end="(270, 53)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(270, 54)" end="(270, 55)" leading="" trailing=" " val="-"/>
                  <IdentNode start="(270, 56)" end="(270, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(270, 58)" end="(270, 59)" leading="" trailing=" " val="="/>
                <OtherNode start="(270, 60)" end="(270, 78)" kind="«term_-_»">
                  <OtherNode start="(270, 60)" end="(270, 73)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(270, 60)" end="(270, 63)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(270, 64)" end="(270, 73)">
                      <IdentNode start="(270, 64)" end="(270, 65)" leading="" trailing=" " raw_val="j" val="j"/>
                      <IdentNode start="(270, 66)" end="(270, 73)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(270, 74)" end="(270, 75)" leading="" trailing=" " val="-"/>
                  <IdentNode start="(270, 76)" end="(270, 78)" leading="" trailing=" " raw_val="i'" val="i'"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(270, 79)" end="(281, 12)">
          <AtomNode start="(270, 79)" end="(270, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(270, 82)" end="(281, 12)">
            <AtomNode start="(270, 82)" end="(270, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(271, 3)" end="(281, 12)">
              <TacticTacticseq1IndentedNode start="(271, 3)" end="(281, 12)">
                <NullNode start="(271, 3)" end="(281, 12)">
                  <OtherNode start="(271, 3)" end="(271, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ as.extract i j = as.extract i' j ↔ min j as.size - i = min j as.size - i'" state_after="case mp&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ as.extract i j = as.extract i' j → min j as.size - i = min j as.size - i'&#10;&#10;case mpr&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ min j as.size - i = min j as.size - i' → as.extract i j = as.extract i' j" tactic="constructor">
                    <AtomNode start="(271, 3)" end="(271, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(272, 3)" end="(274, 18)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ as.extract i j = as.extract i' j → min j as.size - i = min j as.size - i'&#10;&#10;case mpr&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ min j as.size - i = min j as.size - i' → as.extract i j = as.extract i' j" state_after="case mpr&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ min j as.size - i = min j as.size - i' → as.extract i j = as.extract i' j" tactic="· intro h&#10;  replace h := congrArg Array.size h&#10;  simpa using h">
                    <OtherNode start="(272, 3)" end="(272, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(272, 3)" end="(272, 4)" kind="patternIgnore">
                        <OtherNode start="(272, 3)" end="(272, 4)" kind="token.«· »">
                          <AtomNode start="(272, 3)" end="(272, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(272, 5)" end="(274, 18)">
                      <TacticTacticseq1IndentedNode start="(272, 5)" end="(274, 18)">
                        <NullNode start="(272, 5)" end="(274, 18)">
                          <OtherNode start="(272, 5)" end="(272, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ as.extract i j = as.extract i' j → min j as.size - i = min j as.size - i'" state_after="case mp&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : as.extract i j = as.extract i' j&#10;⊢ min j as.size - i = min j as.size - i'" tactic="intro h">
                            <AtomNode start="(272, 5)" end="(272, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(272, 11)" end="(272, 12)">
                              <IdentNode start="(272, 11)" end="(272, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(273, 5)" end="(273, 39)" kind="Lean.Parser.Tactic.replace" state_before="case mp&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : as.extract i j = as.extract i' j&#10;⊢ min j as.size - i = min j as.size - i'" state_after="case mp&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : (as.extract i j).size = (as.extract i' j).size&#10;⊢ min j as.size - i = min j as.size - i'" tactic="replace h := congrArg Array.size h">
                            <AtomNode start="(273, 5)" end="(273, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(273, 13)" end="(273, 39)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(273, 13)" end="(273, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(273, 13)" end="(273, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(273, 13)" end="(273, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(273, 15)" end="(273, 17)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(273, 18)" end="(273, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(273, 18)" end="(273, 26)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(273, 27)" end="(273, 39)">
                                    <IdentNode start="(273, 27)" end="(273, 37)" leading="" trailing=" " raw_val="Array.size" val="Array.size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <IdentNode start="(273, 38)" end="(273, 39)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(274, 5)" end="(274, 18)" kind="Lean.Parser.Tactic.simpa" state_before="case mp&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : (as.extract i j).size = (as.extract i' j).size&#10;⊢ min j as.size - i = min j as.size - i'" state_after="no goals" tactic="simpa using h">
                            <AtomNode start="(274, 5)" end="(274, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(274, 11)" end="(274, 18)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(274, 11)" end="(274, 18)">
                                <AtomNode start="(274, 11)" end="(274, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(274, 17)" end="(274, 18)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(275, 3)" end="(281, 12)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ min j as.size - i = min j as.size - i' → as.extract i j = as.extract i' j" state_after="no goals" tactic="· intro h&#10;  ext l h₁ h₂&#10;  · simpa&#10;  · simp only [size_extract] at h₁ h₂&#10;    simp only [getElem_extract]&#10;    congr 1&#10;    omega">
                    <OtherNode start="(275, 3)" end="(275, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(275, 3)" end="(275, 4)" kind="patternIgnore">
                        <OtherNode start="(275, 3)" end="(275, 4)" kind="token.«· »">
                          <AtomNode start="(275, 3)" end="(275, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(275, 5)" end="(281, 12)">
                      <TacticTacticseq1IndentedNode start="(275, 5)" end="(281, 12)">
                        <NullNode start="(275, 5)" end="(281, 12)">
                          <OtherNode start="(275, 5)" end="(275, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;⊢ min j as.size - i = min j as.size - i' → as.extract i j = as.extract i' j" state_after="case mpr&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;⊢ as.extract i j = as.extract i' j" tactic="intro h">
                            <AtomNode start="(275, 5)" end="(275, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(275, 11)" end="(275, 12)">
                              <IdentNode start="(275, 11)" end="(275, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(276, 5)" end="(276, 16)" kind="Lean.Elab.Tactic.Ext.ext" state_before="case mpr&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;⊢ as.extract i j = as.extract i' j" state_after="case mpr.h₁&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;⊢ (as.extract i j).size = (as.extract i' j).size&#10;&#10;case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i' j).size&#10;⊢ (as.extract i j)[l] = (as.extract i' j)[l]" tactic="ext l h₁ h₂">
                            <AtomNode start="(276, 5)" end="(276, 8)" leading="" trailing=" " val="ext"/>
                            <NullNode start="(276, 9)" end="(276, 16)">
                              <OtherNode start="(276, 9)" end="(276, 10)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(276, 9)" end="(276, 10)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(276, 9)" end="(276, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(276, 11)" end="(276, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(276, 11)" end="(276, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(276, 11)" end="(276, 13)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(276, 14)" end="(276, 16)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(276, 14)" end="(276, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(276, 14)" end="(276, 16)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(277, 5)" end="(277, 12)" kind="Lean.cdot" state_before="case mpr.h₁&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;⊢ (as.extract i j).size = (as.extract i' j).size&#10;&#10;case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i' j).size&#10;⊢ (as.extract i j)[l] = (as.extract i' j)[l]" state_after="case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i' j).size&#10;⊢ (as.extract i j)[l] = (as.extract i' j)[l]" tactic="· simpa">
                            <OtherNode start="(277, 5)" end="(277, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(277, 5)" end="(277, 6)" kind="patternIgnore">
                                <OtherNode start="(277, 5)" end="(277, 6)" kind="token.«· »">
                                  <AtomNode start="(277, 5)" end="(277, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(277, 7)" end="(277, 12)">
                              <TacticTacticseq1IndentedNode start="(277, 7)" end="(277, 12)">
                                <NullNode start="(277, 7)" end="(277, 12)">
                                  <OtherNode start="(277, 7)" end="(277, 12)" kind="Lean.Parser.Tactic.simpa" state_before="case mpr.h₁&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;⊢ (as.extract i j).size = (as.extract i' j).size" state_after="no goals" tactic="simpa">
                                    <AtomNode start="(277, 7)" end="(277, 12)" leading="" trailing="&#10;    " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(278, 5)" end="(281, 12)" kind="Lean.cdot" state_before="case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i' j).size&#10;⊢ (as.extract i j)[l] = (as.extract i' j)[l]" state_after="no goals" tactic="· simp only [size_extract] at h₁ h₂&#10;  simp only [getElem_extract]&#10;  congr 1&#10;  omega">
                            <OtherNode start="(278, 5)" end="(278, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(278, 5)" end="(278, 6)" kind="patternIgnore">
                                <OtherNode start="(278, 5)" end="(278, 6)" kind="token.«· »">
                                  <AtomNode start="(278, 5)" end="(278, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(278, 7)" end="(281, 12)">
                              <TacticTacticseq1IndentedNode start="(278, 7)" end="(281, 12)">
                                <NullNode start="(278, 7)" end="(281, 12)">
                                  <OtherNode start="(278, 7)" end="(278, 40)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁ : l &amp;lt; (as.extract i j).size&#10;h₂ : l &amp;lt; (as.extract i' j).size&#10;⊢ (as.extract i j)[l] = (as.extract i' j)[l]" state_after="case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i' j).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min j as.size - i'&#10;⊢ (as.extract i j)[l] = (as.extract i' j)[l]" tactic="simp only [size_extract] at h₁ h₂">
                                    <AtomNode start="(278, 7)" end="(278, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(278, 12)" end="(278, 16)">
                                      <AtomNode start="(278, 12)" end="(278, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(278, 17)" end="(278, 31)">
                                      <AtomNode start="(278, 17)" end="(278, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(278, 18)" end="(278, 30)">
                                        <OtherNode start="(278, 18)" end="(278, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(278, 18)" end="(278, 30)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(278, 30)" end="(278, 31)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(278, 32)" end="(278, 40)">
                                      <OtherNode start="(278, 32)" end="(278, 40)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(278, 32)" end="(278, 34)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(278, 35)" end="(278, 40)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(278, 35)" end="(278, 40)">
                                            <IdentNode start="(278, 35)" end="(278, 37)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                            <IdentNode start="(278, 38)" end="(278, 40)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(279, 7)" end="(279, 34)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i' j).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min j as.size - i'&#10;⊢ (as.extract i j)[l] = (as.extract i' j)[l]" state_after="case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i' j).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min j as.size - i'&#10;⊢ as[i + l] = as[i' + l]" tactic="simp only [getElem_extract]">
                                    <AtomNode start="(279, 7)" end="(279, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(279, 12)" end="(279, 16)">
                                      <AtomNode start="(279, 12)" end="(279, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(279, 17)" end="(279, 34)">
                                      <AtomNode start="(279, 17)" end="(279, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(279, 18)" end="(279, 33)">
                                        <OtherNode start="(279, 18)" end="(279, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(279, 18)" end="(279, 33)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(279, 33)" end="(279, 34)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(280, 7)" end="(280, 14)" kind="Lean.Parser.Tactic.congr" state_before="case mpr.h₂&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i' j).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min j as.size - i'&#10;⊢ as[i + l] = as[i' + l]" state_after="case mpr.h₂.e_i&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i' j).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min j as.size - i'&#10;⊢ i + l = i' + l" tactic="congr 1">
                                    <AtomNode start="(280, 7)" end="(280, 12)" leading="" trailing=" " val="congr"/>
                                    <NullNode start="(280, 13)" end="(280, 14)">
                                      <OtherNode start="(280, 13)" end="(280, 14)" kind="num">
                                        <AtomNode start="(280, 13)" end="(280, 14)" leading="" trailing="&#10;      " val="1"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(281, 7)" end="(281, 12)" kind="Lean.Parser.Tactic.omega" state_before="case mpr.h₂.e_i&#10;α : Type u_1&#10;as : Array α&#10;i i' j : Nat&#10;h : min j as.size - i = min j as.size - i'&#10;l : Nat&#10;h₁✝ : l &amp;lt; (as.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract i' j).size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min j as.size - i'&#10;⊢ i + l = i' + l" state_after="no goals" tactic="omega">
                                    <AtomNode start="(281, 7)" end="(281, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(283, 1)" end="(286, 8)" name="extract_add_left" full_name="Array.extract_add_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(283, 1)" end="(286, 8)" name="extract_add_left" full_name="Array.extract_add_left" _is_private_decl="False">
        <AtomNode start="(283, 1)" end="(283, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(283, 9)" end="(283, 25)">
          <IdentNode start="(283, 9)" end="(283, 25)" leading="" trailing=" " raw_val="extract_add_left" val="extract_add_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(283, 26)" end="(284, 62)">
          <NullNode start="(283, 26)" end="(283, 54)">
            <OtherNode start="(283, 26)" end="(283, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(283, 26)" end="(283, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(283, 27)" end="(283, 29)">
                <IdentNode start="(283, 27)" end="(283, 29)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(283, 30)" end="(283, 39)">
                <AtomNode start="(283, 30)" end="(283, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(283, 32)" end="(283, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(283, 32)" end="(283, 37)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(283, 38)" end="(283, 39)">
                    <IdentNode start="(283, 38)" end="(283, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(283, 39)" end="(283, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(283, 41)" end="(283, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(283, 41)" end="(283, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(283, 42)" end="(283, 47)">
                <IdentNode start="(283, 42)" end="(283, 43)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(283, 44)" end="(283, 45)" leading="" trailing=" " raw_val="j" val="j"/>
                <IdentNode start="(283, 46)" end="(283, 47)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(283, 48)" end="(283, 53)">
                <AtomNode start="(283, 48)" end="(283, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(283, 50)" end="(283, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(283, 53)" end="(283, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(283, 55)" end="(284, 62)">
            <AtomNode start="(283, 55)" end="(283, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(284, 5)" end="(284, 62)" kind="«term_=_»">
              <OtherNode start="(284, 5)" end="(284, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(284, 5)" end="(284, 15)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                <NullNode start="(284, 16)" end="(284, 25)">
                  <OtherNode start="(284, 16)" end="(284, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(284, 16)" end="(284, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(284, 17)" end="(284, 22)" kind="«term_+_»">
                      <IdentNode start="(284, 17)" end="(284, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(284, 19)" end="(284, 20)" leading="" trailing=" " val="+"/>
                      <IdentNode start="(284, 21)" end="(284, 22)" leading="" trailing="" raw_val="j" val="j"/>
                    </OtherNode>
                    <AtomNode start="(284, 22)" end="(284, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(284, 24)" end="(284, 25)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(284, 26)" end="(284, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(284, 28)" end="(284, 62)" kind="Lean.Parser.Term.app">
                <OtherNode start="(284, 28)" end="(284, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(284, 28)" end="(284, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(284, 28)" end="(284, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(284, 29)" end="(284, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(284, 29)" end="(284, 39)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(284, 40)" end="(284, 43)">
                        <IdentNode start="(284, 40)" end="(284, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(284, 42)" end="(284, 43)" leading="" trailing="" raw_val="k" val="k"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(284, 43)" end="(284, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(284, 44)" end="(284, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(284, 45)" end="(284, 52)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(284, 53)" end="(284, 62)">
                  <IdentNode start="(284, 53)" end="(284, 54)" leading="" trailing=" " raw_val="j" val="j"/>
                  <OtherNode start="(284, 55)" end="(284, 62)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(284, 55)" end="(284, 56)" leading="" trailing="" val="("/>
                    <OtherNode start="(284, 56)" end="(284, 61)" kind="«term_-_»">
                      <IdentNode start="(284, 56)" end="(284, 57)" leading="" trailing=" " raw_val="k" val="k"/>
                      <AtomNode start="(284, 58)" end="(284, 59)" leading="" trailing=" " val="-"/>
                      <IdentNode start="(284, 60)" end="(284, 61)" leading="" trailing="" raw_val="i" val="i"/>
                    </OtherNode>
                    <AtomNode start="(284, 61)" end="(284, 62)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(284, 63)" end="(286, 8)">
          <AtomNode start="(284, 63)" end="(284, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(284, 66)" end="(286, 8)">
            <AtomNode start="(284, 66)" end="(284, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(285, 3)" end="(286, 8)">
              <TacticTacticseq1IndentedNode start="(285, 3)" end="(286, 8)">
                <NullNode start="(285, 3)" end="(286, 8)">
                  <OtherNode start="(285, 3)" end="(285, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ as.extract (i + j) k = (as.extract i k).extract j (k - i)" state_after="α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ min (k - (i + j)) (as.size - (i + j)) = min (min (i + (k - i)) k - (i + j)) (as.size - (i + j))" tactic="simp [extract_eq_extract_right]">
                    <AtomNode start="(285, 3)" end="(285, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(285, 8)" end="(285, 34)">
                      <AtomNode start="(285, 8)" end="(285, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(285, 9)" end="(285, 33)">
                        <OtherNode start="(285, 9)" end="(285, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(285, 9)" end="(285, 33)" leading="" trailing="" raw_val="extract_eq_extract_right" val="extract_eq_extract_right" full_name="Array.extract_eq_extract_right" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(264, 9)" def_end="(264, 33)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(285, 33)" end="(285, 34)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(286, 3)" end="(286, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;i j k : Nat&#10;⊢ min (k - (i + j)) (as.size - (i + j)) = min (min (i + (k - i)) k - (i + j)) (as.size - (i + j))" state_after="no goals" tactic="omega">
                    <AtomNode start="(286, 3)" end="(286, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(288, 1)" end="(294, 29)" name="mem_extract_iff_getElem" full_name="Array.mem_extract_iff_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(288, 1)" end="(294, 29)" name="mem_extract_iff_getElem" full_name="Array.mem_extract_iff_getElem" _is_private_decl="False">
        <AtomNode start="(288, 1)" end="(288, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(288, 9)" end="(288, 32)">
          <IdentNode start="(288, 9)" end="(288, 32)" leading="" trailing=" " raw_val="mem_extract_iff_getElem" val="mem_extract_iff_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(288, 33)" end="(289, 81)">
          <NullNode start="(288, 33)" end="(288, 67)">
            <OtherNode start="(288, 33)" end="(288, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(288, 33)" end="(288, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(288, 34)" end="(288, 36)">
                <IdentNode start="(288, 34)" end="(288, 36)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(288, 37)" end="(288, 46)">
                <AtomNode start="(288, 37)" end="(288, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(288, 39)" end="(288, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(288, 39)" end="(288, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(288, 45)" end="(288, 46)">
                    <IdentNode start="(288, 45)" end="(288, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(288, 46)" end="(288, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(288, 48)" end="(288, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(288, 48)" end="(288, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(288, 49)" end="(288, 50)">
                <IdentNode start="(288, 49)" end="(288, 50)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(288, 51)" end="(288, 54)">
                <AtomNode start="(288, 51)" end="(288, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(288, 53)" end="(288, 54)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(288, 54)" end="(288, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(288, 56)" end="(288, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(288, 56)" end="(288, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(288, 57)" end="(288, 60)">
                <IdentNode start="(288, 57)" end="(288, 58)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(288, 59)" end="(288, 60)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(288, 61)" end="(288, 66)">
                <AtomNode start="(288, 61)" end="(288, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(288, 63)" end="(288, 66)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(288, 66)" end="(288, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(288, 68)" end="(289, 81)">
            <AtomNode start="(288, 68)" end="(288, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(289, 5)" end="(289, 81)" kind="«term_↔_»">
              <OtherNode start="(289, 5)" end="(289, 23)" kind="«term_∈_»">
                <IdentNode start="(289, 5)" end="(289, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(289, 7)" end="(289, 8)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(289, 9)" end="(289, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(289, 9)" end="(289, 19)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                  <NullNode start="(289, 20)" end="(289, 23)">
                    <IdentNode start="(289, 20)" end="(289, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(289, 22)" end="(289, 23)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(289, 24)" end="(289, 25)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(289, 26)" end="(289, 81)" kind="«term∃_,_»">
                <AtomNode start="(289, 26)" end="(289, 27)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(289, 28)" end="(289, 66)" kind="Lean.explicitBinders">
                  <NullNode start="(289, 28)" end="(289, 66)">
                    <OtherNode start="(289, 28)" end="(289, 37)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(289, 28)" end="(289, 29)" leading="" trailing="" val="("/>
                      <NullNode start="(289, 29)" end="(289, 30)">
                        <LeanBinderidentNode start="(289, 29)" end="(289, 30)">
                          <IdentNode start="(289, 29)" end="(289, 30)" leading="" trailing=" " raw_val="k" val="k"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(289, 31)" end="(289, 32)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(289, 33)" end="(289, 36)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(289, 36)" end="(289, 37)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(289, 38)" end="(289, 66)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(289, 38)" end="(289, 39)" leading="" trailing="" val="("/>
                      <NullNode start="(289, 39)" end="(289, 41)">
                        <LeanBinderidentNode start="(289, 39)" end="(289, 41)">
                          <IdentNode start="(289, 39)" end="(289, 41)" leading="" trailing=" " raw_val="hm" val="hm"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(289, 42)" end="(289, 43)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(289, 44)" end="(289, 65)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(289, 44)" end="(289, 45)" leading="" trailing=" " raw_val="k" val="k"/>
                        <AtomNode start="(289, 46)" end="(289, 47)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(289, 48)" end="(289, 65)" kind="«term_-_»">
                          <OtherNode start="(289, 48)" end="(289, 61)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(289, 48)" end="(289, 51)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(289, 52)" end="(289, 61)">
                              <IdentNode start="(289, 52)" end="(289, 53)" leading="" trailing=" " raw_val="j" val="j"/>
                              <IdentNode start="(289, 54)" end="(289, 61)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(289, 62)" end="(289, 63)" leading="" trailing=" " val="-"/>
                          <IdentNode start="(289, 64)" end="(289, 65)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(289, 65)" end="(289, 66)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(289, 66)" end="(289, 67)" leading="" trailing=" " val=","/>
                <OtherNode start="(289, 68)" end="(289, 81)" kind="«term_=_»">
                  <OtherNode start="(289, 68)" end="(289, 77)" kind="«term__[_]»">
                    <IdentNode start="(289, 68)" end="(289, 70)" leading="" trailing="" raw_val="as" val="as"/>
                    <AtomNode start="(289, 70)" end="(289, 71)" leading="" trailing="" val="["/>
                    <OtherNode start="(289, 71)" end="(289, 76)" kind="«term_+_»">
                      <IdentNode start="(289, 71)" end="(289, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(289, 73)" end="(289, 74)" leading="" trailing=" " val="+"/>
                      <IdentNode start="(289, 75)" end="(289, 76)" leading="" trailing="" raw_val="k" val="k"/>
                    </OtherNode>
                    <AtomNode start="(289, 76)" end="(289, 77)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <AtomNode start="(289, 78)" end="(289, 79)" leading="" trailing=" " val="="/>
                  <IdentNode start="(289, 80)" end="(289, 81)" leading="" trailing=" " raw_val="a" val="a"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(289, 82)" end="(294, 29)">
          <AtomNode start="(289, 82)" end="(289, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(289, 85)" end="(294, 29)">
            <AtomNode start="(289, 85)" end="(289, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(290, 3)" end="(294, 29)">
              <TacticTacticseq1IndentedNode start="(290, 3)" end="(294, 29)">
                <NullNode start="(290, 3)" end="(294, 29)">
                  <OtherNode start="(290, 3)" end="(290, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;as : Array α&#10;a : α&#10;i j : Nat&#10;⊢ a ∈ as.extract i j ↔ ∃ k hm, as[i + k] = a" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;i j : Nat&#10;as : List α&#10;⊢ a ∈ { toList := as }.extract i j ↔ ∃ k hm, { toList := as }[i + k] = a" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(290, 3)" end="(290, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(290, 10)" end="(290, 12)">
                      <OtherNode start="(290, 10)" end="(290, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(290, 10)" end="(290, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(290, 13)" end="(290, 22)">
                      <AtomNode start="(290, 13)" end="(290, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(290, 18)" end="(290, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(290, 18)" end="(290, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(290, 18)" end="(290, 22)">
                            <OtherNode start="(290, 18)" end="(290, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(290, 18)" end="(290, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(290, 19)" end="(290, 21)">
                                <OtherNode start="(290, 19)" end="(290, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(290, 19)" end="(290, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(290, 19)" end="(290, 21)">
                                      <OtherNode start="(290, 19)" end="(290, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(290, 19)" end="(290, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(290, 21)" end="(290, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(291, 3)" end="(291, 35)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;i j : Nat&#10;as : List α&#10;⊢ a ∈ { toList := as }.extract i j ↔ ∃ k hm, { toList := as }[i + k] = a" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;i j : Nat&#10;as : List α&#10;⊢ (∃ j_1 h, as[i + j_1] = a) ↔ ∃ k h, as[i + k] = a" tactic="simp [List.mem_take_iff_getElem]">
                    <AtomNode start="(291, 3)" end="(291, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(291, 8)" end="(291, 35)">
                      <AtomNode start="(291, 8)" end="(291, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(291, 9)" end="(291, 34)">
                        <OtherNode start="(291, 9)" end="(291, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 9)" end="(291, 34)" leading="" trailing="" raw_val="List.mem_take_iff_getElem" val="List.mem_take_iff_getElem" full_name="List.mem_take_iff_getElem" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(291, 34)" end="(291, 35)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(292, 3)" end="(294, 29)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;i j : Nat&#10;as : List α&#10;⊢ (∃ j_1 h, as[i + j_1] = a) ↔ ∃ k h, as[i + k] = a" state_after="no goals" tactic="constructor &amp;lt;;&amp;gt;&#10;· rintro ⟨k, h, rfl⟩&#10;  exact ⟨k, by omega, rfl⟩">
                    <OtherNode start="(292, 3)" end="(292, 14)" kind="Lean.Parser.Tactic.constructor">
                      <AtomNode start="(292, 3)" end="(292, 14)" leading="" trailing=" " val="constructor"/>
                    </OtherNode>
                    <AtomNode start="(292, 15)" end="(292, 18)" leading="" trailing="&#10;  " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(293, 3)" end="(294, 29)" kind="Lean.cdot">
                      <OtherNode start="(293, 3)" end="(293, 4)" kind="Lean.cdotTk">
                        <OtherNode start="(293, 3)" end="(293, 4)" kind="patternIgnore">
                          <OtherNode start="(293, 3)" end="(293, 4)" kind="token.«· »">
                            <AtomNode start="(293, 3)" end="(293, 4)" leading="" trailing=" " val="·"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <TacticTacticseqNode start="(293, 5)" end="(294, 29)">
                        <TacticTacticseq1IndentedNode start="(293, 5)" end="(294, 29)">
                          <NullNode start="(293, 5)" end="(294, 29)">
                            <OtherNode start="(293, 5)" end="(293, 23)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mpr&#10;α : Type u_1&#10;a : α&#10;i j : Nat&#10;as : List α&#10;⊢ (∃ k h, as[i + k] = a) → ∃ j_1 h, as[i + j_1] = a" state_after="case mk.mpr.intro.intro&#10;α : Type u_1&#10;i j : Nat&#10;as : List α&#10;k : Nat&#10;h : k &amp;lt; min j as.length - i&#10;⊢ ∃ j_1 h_1, as[i + j_1] = as[i + k]" tactic="rintro ⟨k, h, rfl⟩">
                              <AtomNode start="(293, 5)" end="(293, 11)" leading="" trailing=" " val="rintro"/>
                              <NullNode start="(293, 12)" end="(293, 23)">
                                <OtherNode start="(293, 12)" end="(293, 23)" kind="Lean.Parser.Tactic.rintroPat.one">
                                  <OtherNode start="(293, 12)" end="(293, 23)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(293, 12)" end="(293, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(293, 13)" end="(293, 22)">
                                      <OtherNode start="(293, 13)" end="(293, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(293, 13)" end="(293, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(293, 13)" end="(293, 14)">
                                            <OtherNode start="(293, 13)" end="(293, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(293, 13)" end="(293, 14)" leading="" trailing="" raw_val="k" val="k"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(293, 14)" end="(293, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(293, 16)" end="(293, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(293, 16)" end="(293, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(293, 16)" end="(293, 17)">
                                            <OtherNode start="(293, 16)" end="(293, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(293, 16)" end="(293, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(293, 17)" end="(293, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(293, 19)" end="(293, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(293, 19)" end="(293, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(293, 19)" end="(293, 22)">
                                            <OtherNode start="(293, 19)" end="(293, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(293, 19)" end="(293, 22)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(293, 22)" end="(293, 23)" leading="" trailing="&#10;    " val="⟩"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(294, 5)" end="(294, 29)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mpr.intro.intro&#10;α : Type u_1&#10;i j : Nat&#10;as : List α&#10;k : Nat&#10;h : k &amp;lt; min j as.length - i&#10;⊢ ∃ j_1 h_1, as[i + j_1] = as[i + k]" state_after="no goals" tactic="exact ⟨k, by omega, rfl⟩">
                              <AtomNode start="(294, 5)" end="(294, 10)" leading="" trailing=" " val="exact"/>
                              <OtherNode start="(294, 11)" end="(294, 29)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(294, 11)" end="(294, 12)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(294, 12)" end="(294, 28)">
                                  <IdentNode start="(294, 12)" end="(294, 13)" leading="" trailing="" raw_val="k" val="k"/>
                                  <AtomNode start="(294, 13)" end="(294, 14)" leading="" trailing=" " val=","/>
                                  <TermBytacticNode start="(294, 15)" end="(294, 23)">
                                    <AtomNode start="(294, 15)" end="(294, 17)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(294, 18)" end="(294, 23)">
                                      <TacticTacticseq1IndentedNode start="(294, 18)" end="(294, 23)">
                                        <NullNode start="(294, 18)" end="(294, 23)">
                                          <OtherNode start="(294, 18)" end="(294, 23)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i j : Nat&#10;as : List α&#10;k : Nat&#10;h : k &amp;lt; min j as.length - i&#10;⊢ k &amp;lt; min (j - i) (as.length - i)" state_after="no goals" tactic="omega">
                                            <AtomNode start="(294, 18)" end="(294, 23)" leading="" trailing="" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(294, 23)" end="(294, 24)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(294, 25)" end="(294, 28)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </NullNode>
                                <AtomNode start="(294, 28)" end="(294, 29)" leading="" trailing="&#10;&#10;" val="⟩"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(296, 1)" end="(300, 70)" name="set_eq_push_extract_append_extract" full_name="Array.set_eq_push_extract_append_extract">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(296, 1)" end="(300, 70)" name="set_eq_push_extract_append_extract" full_name="Array.set_eq_push_extract_append_extract" _is_private_decl="False">
        <AtomNode start="(296, 1)" end="(296, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(296, 9)" end="(296, 43)">
          <IdentNode start="(296, 9)" end="(296, 43)" leading="" trailing=" " raw_val="set_eq_push_extract_append_extract" val="set_eq_push_extract_append_extract"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(296, 44)" end="(297, 73)">
          <NullNode start="(296, 44)" end="(296, 94)">
            <OtherNode start="(296, 44)" end="(296, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(296, 44)" end="(296, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(296, 45)" end="(296, 47)">
                <IdentNode start="(296, 45)" end="(296, 47)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(296, 48)" end="(296, 57)">
                <AtomNode start="(296, 48)" end="(296, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(296, 50)" end="(296, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(296, 50)" end="(296, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(296, 56)" end="(296, 57)">
                    <IdentNode start="(296, 56)" end="(296, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(296, 57)" end="(296, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(296, 59)" end="(296, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(296, 59)" end="(296, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(296, 60)" end="(296, 61)">
                <IdentNode start="(296, 60)" end="(296, 61)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(296, 62)" end="(296, 67)">
                <AtomNode start="(296, 62)" end="(296, 63)" leading="" trailing=" " val=":"/>
                <IdentNode start="(296, 64)" end="(296, 67)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(296, 67)" end="(296, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(296, 69)" end="(296, 86)">
              <AtomNode start="(296, 69)" end="(296, 70)" leading="" trailing="" val="("/>
              <NullNode start="(296, 70)" end="(296, 71)">
                <IdentNode start="(296, 70)" end="(296, 71)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(296, 72)" end="(296, 85)">
                <AtomNode start="(296, 72)" end="(296, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(296, 74)" end="(296, 85)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(296, 74)" end="(296, 75)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(296, 76)" end="(296, 77)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(296, 78)" end="(296, 85)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(296, 85)" end="(296, 86)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(296, 87)" end="(296, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(296, 87)" end="(296, 88)" leading="" trailing="" val="{"/>
              <NullNode start="(296, 88)" end="(296, 89)">
                <IdentNode start="(296, 88)" end="(296, 89)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(296, 90)" end="(296, 93)">
                <AtomNode start="(296, 90)" end="(296, 91)" leading="" trailing=" " val=":"/>
                <IdentNode start="(296, 92)" end="(296, 93)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(296, 93)" end="(296, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(296, 95)" end="(297, 73)">
            <AtomNode start="(296, 95)" end="(296, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(297, 5)" end="(297, 73)" kind="«term_=_»">
              <OtherNode start="(297, 5)" end="(297, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(297, 5)" end="(297, 11)" leading="" trailing=" " raw_val="as.set" val="as.set"/>
                <NullNode start="(297, 12)" end="(297, 15)">
                  <IdentNode start="(297, 12)" end="(297, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(297, 14)" end="(297, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(297, 16)" end="(297, 17)" leading="" trailing=" " val="="/>
              <OtherNode start="(297, 18)" end="(297, 73)" kind="«term_++_»">
                <OtherNode start="(297, 18)" end="(297, 41)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(297, 18)" end="(297, 39)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(297, 18)" end="(297, 34)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(297, 18)" end="(297, 19)" leading="" trailing="" val="("/>
                      <OtherNode start="(297, 19)" end="(297, 33)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(297, 19)" end="(297, 29)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                        <NullNode start="(297, 30)" end="(297, 33)">
                          <OtherNode start="(297, 30)" end="(297, 31)" kind="num">
                            <AtomNode start="(297, 30)" end="(297, 31)" leading="" trailing=" " val="0"/>
                          </OtherNode>
                          <IdentNode start="(297, 32)" end="(297, 33)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(297, 33)" end="(297, 34)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(297, 34)" end="(297, 35)" leading="" trailing="" val="."/>
                    <IdentNode start="(297, 35)" end="(297, 39)" leading="" trailing=" " raw_val="push" val="push" full_name="Array.push" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <NullNode start="(297, 40)" end="(297, 41)">
                    <IdentNode start="(297, 40)" end="(297, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(297, 42)" end="(297, 44)" leading="" trailing=" " val="++"/>
                <OtherNode start="(297, 45)" end="(297, 73)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(297, 45)" end="(297, 46)" leading="" trailing="" val="("/>
                  <OtherNode start="(297, 46)" end="(297, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(297, 46)" end="(297, 56)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(297, 57)" end="(297, 72)">
                      <OtherNode start="(297, 57)" end="(297, 64)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(297, 57)" end="(297, 58)" leading="" trailing="" val="("/>
                        <OtherNode start="(297, 58)" end="(297, 63)" kind="«term_+_»">
                          <IdentNode start="(297, 58)" end="(297, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(297, 60)" end="(297, 61)" leading="" trailing=" " val="+"/>
                          <OtherNode start="(297, 62)" end="(297, 63)" kind="num">
                            <AtomNode start="(297, 62)" end="(297, 63)" leading="" trailing="" val="1"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(297, 63)" end="(297, 64)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(297, 65)" end="(297, 72)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(297, 72)" end="(297, 73)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(297, 74)" end="(300, 70)">
          <AtomNode start="(297, 74)" end="(297, 76)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(297, 77)" end="(300, 70)">
            <AtomNode start="(297, 77)" end="(297, 79)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(298, 3)" end="(300, 70)">
              <TacticTacticseq1IndentedNode start="(298, 3)" end="(300, 70)">
                <NullNode start="(298, 3)" end="(300, 70)">
                  <OtherNode start="(298, 3)" end="(298, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;as : Array α&#10;i : Nat&#10;h : i &amp;lt; as.size&#10;a : α&#10;⊢ as.set i a h = (as.extract 0 i).push a ++ as.extract (i + 1)" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;as : List α&#10;h : i &amp;lt; { toList := as }.size&#10;⊢ { toList := as }.set i a h = ({ toList := as }.extract 0 i).push a ++ { toList := as }.extract (i + 1)" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(298, 3)" end="(298, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(298, 10)" end="(298, 12)">
                      <OtherNode start="(298, 10)" end="(298, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(298, 10)" end="(298, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(298, 13)" end="(298, 22)">
                      <AtomNode start="(298, 13)" end="(298, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(298, 18)" end="(298, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(298, 18)" end="(298, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(298, 18)" end="(298, 22)">
                            <OtherNode start="(298, 18)" end="(298, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(298, 18)" end="(298, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(298, 19)" end="(298, 21)">
                                <OtherNode start="(298, 19)" end="(298, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(298, 19)" end="(298, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(298, 19)" end="(298, 21)">
                                      <OtherNode start="(298, 19)" end="(298, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(298, 19)" end="(298, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(298, 21)" end="(298, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(299, 3)" end="(299, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;as : List α&#10;h : i &amp;lt; { toList := as }.size&#10;⊢ { toList := as }.set i a h = ({ toList := as }.extract 0 i).push a ++ { toList := as }.extract (i + 1)" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;as : List α&#10;h✝ : i &amp;lt; { toList := as }.size&#10;h : i &amp;lt; as.length&#10;⊢ { toList := as }.set i a h✝ = ({ toList := as }.extract 0 i).push a ++ { toList := as }.extract (i + 1)" tactic="simp at h">
                    <AtomNode start="(299, 3)" end="(299, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(299, 8)" end="(299, 12)">
                      <OtherNode start="(299, 8)" end="(299, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(299, 8)" end="(299, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(299, 11)" end="(299, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(299, 11)" end="(299, 12)">
                            <IdentNode start="(299, 11)" end="(299, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(300, 3)" end="(300, 70)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;as : List α&#10;h✝ : i &amp;lt; { toList := as }.size&#10;h : i &amp;lt; as.length&#10;⊢ { toList := as }.set i a h✝ = ({ toList := as }.extract 0 i).push a ++ { toList := as }.extract (i + 1)" state_after="no goals" tactic="simp [List.set_eq_take_append_cons_drop, h, List.take_of_length_le]">
                    <AtomNode start="(300, 3)" end="(300, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(300, 8)" end="(300, 70)">
                      <AtomNode start="(300, 8)" end="(300, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(300, 9)" end="(300, 69)">
                        <OtherNode start="(300, 9)" end="(300, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(300, 9)" end="(300, 42)" leading="" trailing="" raw_val="List.set_eq_take_append_cons_drop" val="List.set_eq_take_append_cons_drop" full_name="List.set_eq_take_append_cons_drop" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(300, 42)" end="(300, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(300, 44)" end="(300, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(300, 44)" end="(300, 45)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                        <AtomNode start="(300, 45)" end="(300, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(300, 47)" end="(300, 69)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(300, 47)" end="(300, 69)" leading="" trailing="" raw_val="List.take_of_length_le" val="List.take_of_length_le" full_name="List.take_of_length_le" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(300, 69)" end="(300, 70)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(302, 1)" end="(310, 10)" name="extract_reverse" full_name="Array.extract_reverse">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(302, 1)" end="(310, 10)" name="extract_reverse" full_name="Array.extract_reverse" _is_private_decl="False">
        <AtomNode start="(302, 1)" end="(302, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(302, 9)" end="(302, 24)">
          <IdentNode start="(302, 9)" end="(302, 24)" leading="" trailing=" " raw_val="extract_reverse" val="extract_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(302, 25)" end="(303, 78)">
          <NullNode start="(302, 25)" end="(302, 51)">
            <OtherNode start="(302, 25)" end="(302, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(302, 25)" end="(302, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(302, 26)" end="(302, 28)">
                <IdentNode start="(302, 26)" end="(302, 28)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(302, 29)" end="(302, 38)">
                <AtomNode start="(302, 29)" end="(302, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(302, 31)" end="(302, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(302, 31)" end="(302, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(302, 37)" end="(302, 38)">
                    <IdentNode start="(302, 37)" end="(302, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(302, 38)" end="(302, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(302, 40)" end="(302, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(302, 40)" end="(302, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(302, 41)" end="(302, 44)">
                <IdentNode start="(302, 41)" end="(302, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(302, 43)" end="(302, 44)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(302, 45)" end="(302, 50)">
                <AtomNode start="(302, 45)" end="(302, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(302, 47)" end="(302, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(302, 50)" end="(302, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(302, 52)" end="(303, 78)">
            <AtomNode start="(302, 52)" end="(302, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(303, 5)" end="(303, 78)" kind="«term_=_»">
              <OtherNode start="(303, 5)" end="(303, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(303, 5)" end="(303, 23)" leading="" trailing=" " raw_val="as.reverse.extract" val="as.reverse.extract"/>
                <NullNode start="(303, 24)" end="(303, 27)">
                  <IdentNode start="(303, 24)" end="(303, 25)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(303, 26)" end="(303, 27)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(303, 28)" end="(303, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(303, 30)" end="(303, 78)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(303, 30)" end="(303, 70)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(303, 30)" end="(303, 31)" leading="" trailing="" val="("/>
                  <OtherNode start="(303, 31)" end="(303, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(303, 31)" end="(303, 41)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(303, 42)" end="(303, 69)">
                      <OtherNode start="(303, 42)" end="(303, 55)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(303, 42)" end="(303, 43)" leading="" trailing="" val="("/>
                        <OtherNode start="(303, 43)" end="(303, 54)" kind="«term_-_»">
                          <IdentNode start="(303, 43)" end="(303, 50)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                          <AtomNode start="(303, 51)" end="(303, 52)" leading="" trailing=" " val="-"/>
                          <IdentNode start="(303, 53)" end="(303, 54)" leading="" trailing="" raw_val="j" val="j"/>
                        </OtherNode>
                        <AtomNode start="(303, 54)" end="(303, 55)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(303, 56)" end="(303, 69)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(303, 56)" end="(303, 57)" leading="" trailing="" val="("/>
                        <OtherNode start="(303, 57)" end="(303, 68)" kind="«term_-_»">
                          <IdentNode start="(303, 57)" end="(303, 64)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                          <AtomNode start="(303, 65)" end="(303, 66)" leading="" trailing=" " val="-"/>
                          <IdentNode start="(303, 67)" end="(303, 68)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                        <AtomNode start="(303, 68)" end="(303, 69)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(303, 69)" end="(303, 70)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(303, 70)" end="(303, 71)" leading="" trailing="" val="."/>
                <IdentNode start="(303, 71)" end="(303, 78)" leading="" trailing=" " raw_val="reverse" val="reverse" full_name="Array.reverse" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(303, 79)" end="(310, 10)">
          <AtomNode start="(303, 79)" end="(303, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(303, 82)" end="(310, 10)">
            <AtomNode start="(303, 82)" end="(303, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(304, 3)" end="(310, 10)">
              <TacticTacticseq1IndentedNode start="(304, 3)" end="(310, 10)">
                <NullNode start="(304, 3)" end="(310, 10)">
                  <OtherNode start="(304, 3)" end="(304, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ as.reverse.extract i j = (as.extract (as.size - j) (as.size - i)).reverse" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.reverse.extract i j).size = (as.extract (as.size - j) (as.size - i)).reverse.size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;⊢ (as.reverse.extract i j)[l] = (as.extract (as.size - j) (as.size - i)).reverse[l]" tactic="ext l h₁ h₂">
                    <AtomNode start="(304, 3)" end="(304, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(304, 7)" end="(304, 14)">
                      <OtherNode start="(304, 7)" end="(304, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(304, 7)" end="(304, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(304, 7)" end="(304, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(304, 9)" end="(304, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(304, 9)" end="(304, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(304, 9)" end="(304, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(304, 12)" end="(304, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(304, 12)" end="(304, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(304, 12)" end="(304, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(305, 3)" end="(306, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.reverse.extract i j).size = (as.extract (as.size - j) (as.size - i)).reverse.size&#10;&#10;case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;⊢ (as.reverse.extract i j)[l] = (as.extract (as.size - j) (as.size - i)).reverse[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;⊢ (as.reverse.extract i j)[l] = (as.extract (as.size - j) (as.size - i)).reverse[l]" tactic="· simp&#10;  omega">
                    <OtherNode start="(305, 3)" end="(305, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(305, 3)" end="(305, 4)" kind="patternIgnore">
                        <OtherNode start="(305, 3)" end="(305, 4)" kind="token.«· »">
                          <AtomNode start="(305, 3)" end="(305, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(305, 5)" end="(306, 10)">
                      <TacticTacticseq1IndentedNode start="(305, 5)" end="(306, 10)">
                        <NullNode start="(305, 5)" end="(306, 10)">
                          <OtherNode start="(305, 5)" end="(305, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.reverse.extract i j).size = (as.extract (as.size - j) (as.size - i)).reverse.size" state_after="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ min j as.size - i = as.size - i - (as.size - j)" tactic="simp">
                            <AtomNode start="(305, 5)" end="(305, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(306, 5)" end="(306, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ min j as.size - i = as.size - i - (as.size - j)" state_after="no goals" tactic="omega">
                            <AtomNode start="(306, 5)" end="(306, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(307, 3)" end="(310, 10)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;⊢ (as.reverse.extract i j)[l] = (as.extract (as.size - j) (as.size - i)).reverse[l]" state_after="no goals" tactic="· simp only [size_extract, size_reverse] at h₁ h₂&#10;  simp only [getElem_extract, getElem_reverse, size_extract]&#10;  congr 1&#10;  omega">
                    <OtherNode start="(307, 3)" end="(307, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(307, 3)" end="(307, 4)" kind="patternIgnore">
                        <OtherNode start="(307, 3)" end="(307, 4)" kind="token.«· »">
                          <AtomNode start="(307, 3)" end="(307, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(307, 5)" end="(310, 10)">
                      <TacticTacticseq1IndentedNode start="(307, 5)" end="(310, 10)">
                        <NullNode start="(307, 5)" end="(310, 10)">
                          <OtherNode start="(307, 5)" end="(307, 52)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;⊢ (as.reverse.extract i j)[l] = (as.extract (as.size - j) (as.size - i)).reverse[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min (as.size - i) as.size - (as.size - j)&#10;⊢ (as.reverse.extract i j)[l] = (as.extract (as.size - j) (as.size - i)).reverse[l]" tactic="simp only [size_extract, size_reverse] at h₁ h₂">
                            <AtomNode start="(307, 5)" end="(307, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(307, 10)" end="(307, 14)">
                              <AtomNode start="(307, 10)" end="(307, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(307, 15)" end="(307, 43)">
                              <AtomNode start="(307, 15)" end="(307, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(307, 16)" end="(307, 42)">
                                <OtherNode start="(307, 16)" end="(307, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(307, 16)" end="(307, 28)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(307, 28)" end="(307, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(307, 30)" end="(307, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(307, 30)" end="(307, 42)" leading="" trailing="" raw_val="size_reverse" val="size_reverse" full_name="Array.size_reverse" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(307, 42)" end="(307, 43)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(307, 44)" end="(307, 52)">
                              <OtherNode start="(307, 44)" end="(307, 52)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(307, 44)" end="(307, 46)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(307, 47)" end="(307, 52)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(307, 47)" end="(307, 52)">
                                    <IdentNode start="(307, 47)" end="(307, 49)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(307, 50)" end="(307, 52)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(308, 5)" end="(308, 63)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min (as.size - i) as.size - (as.size - j)&#10;⊢ (as.reverse.extract i j)[l] = (as.extract (as.size - j) (as.size - i)).reverse[l]" state_after="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min (as.size - i) as.size - (as.size - j)&#10;⊢ as[as.size - 1 - (i + l)] = as[as.size - j + (min (as.size - i) as.size - (as.size - j) - 1 - l)]" tactic="simp only [getElem_extract, getElem_reverse, size_extract]">
                            <AtomNode start="(308, 5)" end="(308, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(308, 10)" end="(308, 14)">
                              <AtomNode start="(308, 10)" end="(308, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(308, 15)" end="(308, 63)">
                              <AtomNode start="(308, 15)" end="(308, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(308, 16)" end="(308, 62)">
                                <OtherNode start="(308, 16)" end="(308, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(308, 16)" end="(308, 31)" leading="" trailing="" raw_val="getElem_extract" val="getElem_extract" full_name="Array.getElem_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(308, 31)" end="(308, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(308, 33)" end="(308, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(308, 33)" end="(308, 48)" leading="" trailing="" raw_val="getElem_reverse" val="getElem_reverse" full_name="Array.getElem_reverse" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(308, 48)" end="(308, 49)" leading="" trailing=" " val=","/>
                                <OtherNode start="(308, 50)" end="(308, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(308, 50)" end="(308, 62)" leading="" trailing="" raw_val="size_extract" val="size_extract" full_name="Array.size_extract" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(308, 62)" end="(308, 63)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(309, 5)" end="(309, 12)" kind="Lean.Parser.Tactic.congr" state_before="case h₂&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min (as.size - i) as.size - (as.size - j)&#10;⊢ as[as.size - 1 - (i + l)] = as[as.size - j + (min (as.size - i) as.size - (as.size - j) - 1 - l)]" state_after="case h₂.e_i&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min (as.size - i) as.size - (as.size - j)&#10;⊢ as.size - 1 - (i + l) = as.size - j + (min (as.size - i) as.size - (as.size - j) - 1 - l)" tactic="congr 1">
                            <AtomNode start="(309, 5)" end="(309, 10)" leading="" trailing=" " val="congr"/>
                            <NullNode start="(309, 11)" end="(309, 12)">
                              <OtherNode start="(309, 11)" end="(309, 12)" kind="num">
                                <AtomNode start="(309, 11)" end="(309, 12)" leading="" trailing="&#10;    " val="1"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(310, 5)" end="(310, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.e_i&#10;α : Type u_1&#10;as : Array α&#10;i j l : Nat&#10;h₁✝ : l &amp;lt; (as.reverse.extract i j).size&#10;h₂✝ : l &amp;lt; (as.extract (as.size - j) (as.size - i)).reverse.size&#10;h₁ : l &amp;lt; min j as.size - i&#10;h₂ : l &amp;lt; min (as.size - i) as.size - (as.size - j)&#10;⊢ as.size - 1 - (i + l) = as.size - j + (min (as.size - i) as.size - (as.size - j) - 1 - l)" state_after="no goals" tactic="omega">
                            <AtomNode start="(310, 5)" end="(310, 10)" leading="" trailing="&#10;&#10;" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(312, 1)" end="(323, 10)" name="reverse_extract" full_name="Array.reverse_extract">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(312, 1)" end="(323, 10)" name="reverse_extract" full_name="Array.reverse_extract" _is_private_decl="False">
        <AtomNode start="(312, 1)" end="(312, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(312, 9)" end="(312, 24)">
          <IdentNode start="(312, 9)" end="(312, 24)" leading="" trailing=" " raw_val="reverse_extract" val="reverse_extract"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(312, 25)" end="(313, 78)">
          <NullNode start="(312, 25)" end="(312, 51)">
            <OtherNode start="(312, 25)" end="(312, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(312, 25)" end="(312, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(312, 26)" end="(312, 28)">
                <IdentNode start="(312, 26)" end="(312, 28)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(312, 29)" end="(312, 38)">
                <AtomNode start="(312, 29)" end="(312, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(312, 31)" end="(312, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(312, 31)" end="(312, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(312, 37)" end="(312, 38)">
                    <IdentNode start="(312, 37)" end="(312, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(312, 38)" end="(312, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(312, 40)" end="(312, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(312, 40)" end="(312, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(312, 41)" end="(312, 44)">
                <IdentNode start="(312, 41)" end="(312, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(312, 43)" end="(312, 44)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(312, 45)" end="(312, 50)">
                <AtomNode start="(312, 45)" end="(312, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(312, 47)" end="(312, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(312, 50)" end="(312, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(312, 52)" end="(313, 78)">
            <AtomNode start="(312, 52)" end="(312, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(313, 5)" end="(313, 78)" kind="«term_=_»">
              <OtherNode start="(313, 5)" end="(313, 29)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(313, 5)" end="(313, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(313, 5)" end="(313, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(313, 6)" end="(313, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(313, 6)" end="(313, 16)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                    <NullNode start="(313, 17)" end="(313, 20)">
                      <IdentNode start="(313, 17)" end="(313, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(313, 19)" end="(313, 20)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(313, 20)" end="(313, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(313, 21)" end="(313, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(313, 22)" end="(313, 29)" leading="" trailing=" " raw_val="reverse" val="reverse" full_name="Array.reverse" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(313, 30)" end="(313, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(313, 32)" end="(313, 78)" kind="Lean.Parser.Term.app">
                <IdentNode start="(313, 32)" end="(313, 50)" leading="" trailing=" " raw_val="as.reverse.extract" val="as.reverse.extract"/>
                <NullNode start="(313, 51)" end="(313, 78)">
                  <OtherNode start="(313, 51)" end="(313, 64)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(313, 51)" end="(313, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(313, 52)" end="(313, 63)" kind="«term_-_»">
                      <IdentNode start="(313, 52)" end="(313, 59)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                      <AtomNode start="(313, 60)" end="(313, 61)" leading="" trailing=" " val="-"/>
                      <IdentNode start="(313, 62)" end="(313, 63)" leading="" trailing="" raw_val="j" val="j"/>
                    </OtherNode>
                    <AtomNode start="(313, 63)" end="(313, 64)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(313, 65)" end="(313, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(313, 65)" end="(313, 66)" leading="" trailing="" val="("/>
                    <OtherNode start="(313, 66)" end="(313, 77)" kind="«term_-_»">
                      <IdentNode start="(313, 66)" end="(313, 73)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                      <AtomNode start="(313, 74)" end="(313, 75)" leading="" trailing=" " val="-"/>
                      <IdentNode start="(313, 76)" end="(313, 77)" leading="" trailing="" raw_val="i" val="i"/>
                    </OtherNode>
                    <AtomNode start="(313, 77)" end="(313, 78)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(313, 79)" end="(323, 10)">
          <AtomNode start="(313, 79)" end="(313, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(313, 82)" end="(323, 10)">
            <AtomNode start="(313, 82)" end="(313, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(314, 3)" end="(323, 10)">
              <TacticTacticseq1IndentedNode start="(314, 3)" end="(323, 10)">
                <NullNode start="(314, 3)" end="(323, 10)">
                  <OtherNode start="(314, 3)" end="(314, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.extract i j).reverse = as.reverse.extract (as.size - j) (as.size - i)" state_after="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.extract i j).reverse = (as.extract (as.size - (as.size - i)) (as.size - (as.size - j))).reverse" tactic="rw [extract_reverse]">
                    <AtomNode start="(314, 3)" end="(314, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(314, 6)" end="(314, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(314, 6)" end="(314, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(314, 7)" end="(314, 22)">
                        <OtherNode start="(314, 7)" end="(314, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(314, 7)" end="(314, 22)" leading="" trailing="" raw_val="extract_reverse" val="extract_reverse" full_name="Array.extract_reverse" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(302, 9)" def_end="(302, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(314, 22)" end="(314, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(315, 3)" end="(315, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ (as.extract i j).reverse = (as.extract (as.size - (as.size - i)) (as.size - (as.size - j))).reverse" state_after="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" tactic="simp">
                    <AtomNode start="(315, 3)" end="(315, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(316, 3)" end="(316, 27)" kind="«tacticBy_cases_:_»" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="case pos&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))&#10;&#10;case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" tactic="by_cases h : j ≤ as.size">
                    <AtomNode start="(316, 3)" end="(316, 11)" leading="" trailing=" " val="by_cases"/>
                    <NullNode start="(316, 12)" end="(316, 15)">
                      <IdentNode start="(316, 12)" end="(316, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                      <AtomNode start="(316, 14)" end="(316, 15)" leading="" trailing=" " val=":"/>
                    </NullNode>
                    <OtherNode start="(316, 16)" end="(316, 27)" kind="«term_≤_»">
                      <IdentNode start="(316, 16)" end="(316, 17)" leading="" trailing=" " raw_val="j" val="j"/>
                      <AtomNode start="(316, 18)" end="(316, 19)" leading="" trailing=" " val="≤"/>
                      <IdentNode start="(316, 20)" end="(316, 27)" leading="" trailing="&#10;  " raw_val="as.size" val="as.size"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(317, 3)" end="(319, 10)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))&#10;&#10;case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" tactic="· have : as.size - (as.size - j) = j := by omega&#10;  simp [this, extract_eq_extract_left]&#10;  omega">
                    <OtherNode start="(317, 3)" end="(317, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(317, 3)" end="(317, 4)" kind="patternIgnore">
                        <OtherNode start="(317, 3)" end="(317, 4)" kind="token.«· »">
                          <AtomNode start="(317, 3)" end="(317, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(317, 5)" end="(319, 10)">
                      <TacticTacticseq1IndentedNode start="(317, 5)" end="(319, 10)">
                        <NullNode start="(317, 5)" end="(319, 10)">
                          <OtherNode start="(317, 5)" end="(317, 51)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="case pos&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;this : as.size - (as.size - j) = j&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" tactic="have : as.size - (as.size - j) = j := by omega">
                            <AtomNode start="(317, 5)" end="(317, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(317, 10)" end="(317, 51)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(317, 10)" end="(317, 51)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(317, 10)" end="(317, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(317, 10)" end="(317, 10)" kind="hygieneInfo">
                                    <IdentNode start="(317, 10)" end="(317, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(317, 10)" end="(317, 39)">
                                  <TermTypespecNode start="(317, 10)" end="(317, 39)">
                                    <AtomNode start="(317, 10)" end="(317, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(317, 12)" end="(317, 39)" kind="«term_=_»">
                                      <OtherNode start="(317, 12)" end="(317, 35)" kind="«term_-_»">
                                        <IdentNode start="(317, 12)" end="(317, 19)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                                        <AtomNode start="(317, 20)" end="(317, 21)" leading="" trailing=" " val="-"/>
                                        <OtherNode start="(317, 22)" end="(317, 35)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(317, 22)" end="(317, 23)" leading="" trailing="" val="("/>
                                          <OtherNode start="(317, 23)" end="(317, 34)" kind="«term_-_»">
                                            <IdentNode start="(317, 23)" end="(317, 30)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                                            <AtomNode start="(317, 31)" end="(317, 32)" leading="" trailing=" " val="-"/>
                                            <IdentNode start="(317, 33)" end="(317, 34)" leading="" trailing="" raw_val="j" val="j"/>
                                          </OtherNode>
                                          <AtomNode start="(317, 34)" end="(317, 35)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(317, 36)" end="(317, 37)" leading="" trailing=" " val="="/>
                                      <IdentNode start="(317, 38)" end="(317, 39)" leading="" trailing=" " raw_val="j" val="j"/>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(317, 40)" end="(317, 42)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(317, 43)" end="(317, 51)">
                                  <AtomNode start="(317, 43)" end="(317, 45)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(317, 46)" end="(317, 51)">
                                    <TacticTacticseq1IndentedNode start="(317, 46)" end="(317, 51)">
                                      <NullNode start="(317, 46)" end="(317, 51)">
                                        <OtherNode start="(317, 46)" end="(317, 51)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;⊢ as.size - (as.size - j) = j" state_after="no goals" tactic="omega">
                                          <AtomNode start="(317, 46)" end="(317, 51)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(318, 5)" end="(318, 41)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;this : as.size - (as.size - j) = j&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="case pos&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;this : as.size - (as.size - j) = j&#10;⊢ min j as.size - i = min j as.size - (as.size - (as.size - i))" tactic="simp [this, extract_eq_extract_left]">
                            <AtomNode start="(318, 5)" end="(318, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(318, 10)" end="(318, 41)">
                              <AtomNode start="(318, 10)" end="(318, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(318, 11)" end="(318, 40)">
                                <OtherNode start="(318, 11)" end="(318, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(318, 11)" end="(318, 15)" leading="" trailing="" raw_val="this" val="this"/>
                                </OtherNode>
                                <AtomNode start="(318, 15)" end="(318, 16)" leading="" trailing=" " val=","/>
                                <OtherNode start="(318, 17)" end="(318, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(318, 17)" end="(318, 40)" leading="" trailing="" raw_val="extract_eq_extract_left" val="extract_eq_extract_left" full_name="Array.extract_eq_extract_left" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(269, 9)" def_end="(269, 32)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(318, 40)" end="(318, 41)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(319, 5)" end="(319, 10)" kind="Lean.Parser.Tactic.omega" state_before="case pos&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : j ≤ as.size&#10;this : as.size - (as.size - j) = j&#10;⊢ min j as.size - i = min j as.size - (as.size - (as.size - i))" state_after="no goals" tactic="omega">
                            <AtomNode start="(319, 5)" end="(319, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(320, 3)" end="(323, 10)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="no goals" tactic="· have : as.size - (as.size - j) = as.size := by omega&#10;  simp only [Nat.not_le] at h&#10;  simp [h, this, extract_eq_extract_left]&#10;  omega">
                    <OtherNode start="(320, 3)" end="(320, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(320, 3)" end="(320, 4)" kind="patternIgnore">
                        <OtherNode start="(320, 3)" end="(320, 4)" kind="token.«· »">
                          <AtomNode start="(320, 3)" end="(320, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(320, 5)" end="(323, 10)">
                      <TacticTacticseq1IndentedNode start="(320, 5)" end="(323, 10)">
                        <NullNode start="(320, 5)" end="(323, 10)">
                          <OtherNode start="(320, 5)" end="(320, 57)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;this : as.size - (as.size - j) = as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" tactic="have : as.size - (as.size - j) = as.size := by omega">
                            <AtomNode start="(320, 5)" end="(320, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(320, 10)" end="(320, 57)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(320, 10)" end="(320, 57)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(320, 10)" end="(320, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(320, 10)" end="(320, 10)" kind="hygieneInfo">
                                    <IdentNode start="(320, 10)" end="(320, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(320, 10)" end="(320, 45)">
                                  <TermTypespecNode start="(320, 10)" end="(320, 45)">
                                    <AtomNode start="(320, 10)" end="(320, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(320, 12)" end="(320, 45)" kind="«term_=_»">
                                      <OtherNode start="(320, 12)" end="(320, 35)" kind="«term_-_»">
                                        <IdentNode start="(320, 12)" end="(320, 19)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                                        <AtomNode start="(320, 20)" end="(320, 21)" leading="" trailing=" " val="-"/>
                                        <OtherNode start="(320, 22)" end="(320, 35)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(320, 22)" end="(320, 23)" leading="" trailing="" val="("/>
                                          <OtherNode start="(320, 23)" end="(320, 34)" kind="«term_-_»">
                                            <IdentNode start="(320, 23)" end="(320, 30)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                                            <AtomNode start="(320, 31)" end="(320, 32)" leading="" trailing=" " val="-"/>
                                            <IdentNode start="(320, 33)" end="(320, 34)" leading="" trailing="" raw_val="j" val="j"/>
                                          </OtherNode>
                                          <AtomNode start="(320, 34)" end="(320, 35)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(320, 36)" end="(320, 37)" leading="" trailing=" " val="="/>
                                      <IdentNode start="(320, 38)" end="(320, 45)" leading="" trailing=" " raw_val="as.size" val="as.size"/>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(320, 46)" end="(320, 48)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(320, 49)" end="(320, 57)">
                                  <AtomNode start="(320, 49)" end="(320, 51)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(320, 52)" end="(320, 57)">
                                    <TacticTacticseq1IndentedNode start="(320, 52)" end="(320, 57)">
                                      <NullNode start="(320, 52)" end="(320, 57)">
                                        <OtherNode start="(320, 52)" end="(320, 57)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;⊢ as.size - (as.size - j) = as.size" state_after="no goals" tactic="omega">
                                          <AtomNode start="(320, 52)" end="(320, 57)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(321, 5)" end="(321, 32)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;h : ¬j ≤ as.size&#10;this : as.size - (as.size - j) = as.size&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;this : as.size - (as.size - j) = as.size&#10;h : as.size &amp;lt; j&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" tactic="simp only [Nat.not_le] at h">
                            <AtomNode start="(321, 5)" end="(321, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(321, 10)" end="(321, 14)">
                              <AtomNode start="(321, 10)" end="(321, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(321, 15)" end="(321, 27)">
                              <AtomNode start="(321, 15)" end="(321, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(321, 16)" end="(321, 26)">
                                <OtherNode start="(321, 16)" end="(321, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(321, 16)" end="(321, 26)" leading="" trailing="" raw_val="Nat.not_le" val="Nat.not_le" full_name="Nat.not_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(321, 26)" end="(321, 27)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(321, 28)" end="(321, 32)">
                              <OtherNode start="(321, 28)" end="(321, 32)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(321, 28)" end="(321, 30)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(321, 31)" end="(321, 32)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(321, 31)" end="(321, 32)">
                                    <IdentNode start="(321, 31)" end="(321, 32)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(322, 5)" end="(322, 44)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;this : as.size - (as.size - j) = as.size&#10;h : as.size &amp;lt; j&#10;⊢ as.extract i j = as.extract (as.size - (as.size - i)) (as.size - (as.size - j))" state_after="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;this : as.size - (as.size - j) = as.size&#10;h : as.size &amp;lt; j&#10;⊢ as.size - i = as.size - (as.size - (as.size - i))" tactic="simp [h, this, extract_eq_extract_left]">
                            <AtomNode start="(322, 5)" end="(322, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(322, 10)" end="(322, 44)">
                              <AtomNode start="(322, 10)" end="(322, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(322, 11)" end="(322, 43)">
                                <OtherNode start="(322, 11)" end="(322, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(322, 11)" end="(322, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(322, 12)" end="(322, 13)" leading="" trailing=" " val=","/>
                                <OtherNode start="(322, 14)" end="(322, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(322, 14)" end="(322, 18)" leading="" trailing="" raw_val="this" val="this"/>
                                </OtherNode>
                                <AtomNode start="(322, 18)" end="(322, 19)" leading="" trailing=" " val=","/>
                                <OtherNode start="(322, 20)" end="(322, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(322, 20)" end="(322, 43)" leading="" trailing="" raw_val="extract_eq_extract_left" val="extract_eq_extract_left" full_name="Array.extract_eq_extract_left" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(269, 9)" def_end="(269, 32)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(322, 43)" end="(322, 44)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(323, 5)" end="(323, 10)" kind="Lean.Parser.Tactic.omega" state_before="case neg&#10;α : Type u_1&#10;as : Array α&#10;i j : Nat&#10;this : as.size - (as.size - j) = as.size&#10;h : as.size &amp;lt; j&#10;⊢ as.size - i = as.size - (as.size - (as.size - i))" state_after="no goals" tactic="omega">
                            <AtomNode start="(323, 5)" end="(323, 10)" leading="" trailing="&#10;&#10;" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(325, 1)" end="(325, 21)" comment="### takeWhile -/">
      <AtomNode start="(325, 1)" end="(325, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(325, 5)" end="(325, 21)" leading="" trailing="&#10;&#10;" val="### takeWhile -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(327, 1)" end="(330, 28)" name="takeWhile_map" full_name="Array.takeWhile_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(327, 1)" end="(330, 28)" name="takeWhile_map" full_name="Array.takeWhile_map" _is_private_decl="False">
        <AtomNode start="(327, 1)" end="(327, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(327, 9)" end="(327, 22)">
          <IdentNode start="(327, 9)" end="(327, 22)" leading="" trailing=" " raw_val="takeWhile_map" val="takeWhile_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(327, 23)" end="(328, 58)">
          <NullNode start="(327, 23)" end="(327, 64)">
            <OtherNode start="(327, 23)" end="(327, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(327, 23)" end="(327, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(327, 24)" end="(327, 25)">
                <IdentNode start="(327, 24)" end="(327, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(327, 26)" end="(327, 33)">
                <AtomNode start="(327, 26)" end="(327, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(327, 28)" end="(327, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(327, 28)" end="(327, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(327, 30)" end="(327, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(327, 32)" end="(327, 33)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(327, 33)" end="(327, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(327, 35)" end="(327, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(327, 35)" end="(327, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(327, 36)" end="(327, 37)">
                <IdentNode start="(327, 36)" end="(327, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(327, 38)" end="(327, 48)">
                <AtomNode start="(327, 38)" end="(327, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(327, 40)" end="(327, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(327, 40)" end="(327, 41)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(327, 42)" end="(327, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(327, 44)" end="(327, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(327, 48)" end="(327, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(327, 50)" end="(327, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(327, 50)" end="(327, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(327, 51)" end="(327, 53)">
                <IdentNode start="(327, 51)" end="(327, 53)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(327, 54)" end="(327, 63)">
                <AtomNode start="(327, 54)" end="(327, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(327, 56)" end="(327, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(327, 56)" end="(327, 61)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(327, 62)" end="(327, 63)">
                    <IdentNode start="(327, 62)" end="(327, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(327, 63)" end="(327, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(327, 65)" end="(328, 58)">
            <AtomNode start="(327, 65)" end="(327, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(328, 5)" end="(328, 58)" kind="«term_=_»">
              <OtherNode start="(328, 5)" end="(328, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(328, 5)" end="(328, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(328, 5)" end="(328, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(328, 5)" end="(328, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(328, 6)" end="(328, 14)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(328, 6)" end="(328, 12)" leading="" trailing=" " raw_val="as.map" val="as.map"/>
                      <NullNode start="(328, 13)" end="(328, 14)">
                        <IdentNode start="(328, 13)" end="(328, 14)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(328, 14)" end="(328, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(328, 15)" end="(328, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(328, 16)" end="(328, 25)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(328, 26)" end="(328, 27)">
                  <IdentNode start="(328, 26)" end="(328, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(328, 28)" end="(328, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(328, 30)" end="(328, 58)" kind="Lean.Parser.Term.app">
                <OtherNode start="(328, 30)" end="(328, 56)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(328, 30)" end="(328, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(328, 30)" end="(328, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(328, 31)" end="(328, 51)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(328, 31)" end="(328, 43)" leading="" trailing=" " raw_val="as.takeWhile" val="as.takeWhile"/>
                      <NullNode start="(328, 44)" end="(328, 51)">
                        <OtherNode start="(328, 44)" end="(328, 51)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(328, 44)" end="(328, 45)" leading="" trailing="" val="("/>
                          <OtherNode start="(328, 45)" end="(328, 50)" kind="«term_∘_»">
                            <IdentNode start="(328, 45)" end="(328, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                            <AtomNode start="(328, 47)" end="(328, 48)" leading="" trailing=" " val="∘"/>
                            <IdentNode start="(328, 49)" end="(328, 50)" leading="" trailing="" raw_val="f" val="f"/>
                          </OtherNode>
                          <AtomNode start="(328, 50)" end="(328, 51)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(328, 51)" end="(328, 52)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(328, 52)" end="(328, 53)" leading="" trailing="" val="."/>
                  <IdentNode start="(328, 53)" end="(328, 56)" leading="" trailing=" " raw_val="map" val="map" full_name="Array.map" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(328, 57)" end="(328, 58)">
                  <IdentNode start="(328, 57)" end="(328, 58)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(328, 59)" end="(330, 28)">
          <AtomNode start="(328, 59)" end="(328, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(328, 62)" end="(330, 28)">
            <AtomNode start="(328, 62)" end="(328, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(329, 3)" end="(330, 28)">
              <TacticTacticseq1IndentedNode start="(329, 3)" end="(330, 28)">
                <NullNode start="(329, 3)" end="(330, 28)">
                  <OtherNode start="(329, 3)" end="(329, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;p : β → Bool&#10;as : Array α&#10;⊢ takeWhile p (map f as) = map f (takeWhile (p ∘ f) as)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;p : β → Bool&#10;as : List α&#10;⊢ takeWhile p (map f { toList := as }) = map f (takeWhile (p ∘ f) { toList := as })" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(329, 3)" end="(329, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(329, 10)" end="(329, 12)">
                      <OtherNode start="(329, 10)" end="(329, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(329, 10)" end="(329, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(329, 13)" end="(329, 22)">
                      <AtomNode start="(329, 13)" end="(329, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(329, 18)" end="(329, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(329, 18)" end="(329, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(329, 18)" end="(329, 22)">
                            <OtherNode start="(329, 18)" end="(329, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(329, 18)" end="(329, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(329, 19)" end="(329, 21)">
                                <OtherNode start="(329, 19)" end="(329, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(329, 19)" end="(329, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(329, 19)" end="(329, 21)">
                                      <OtherNode start="(329, 19)" end="(329, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(329, 19)" end="(329, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(329, 21)" end="(329, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(330, 3)" end="(330, 28)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;p : β → Bool&#10;as : List α&#10;⊢ takeWhile p (map f { toList := as }) = map f (takeWhile (p ∘ f) { toList := as })" state_after="no goals" tactic="simp [List.takeWhile_map]">
                    <AtomNode start="(330, 3)" end="(330, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(330, 8)" end="(330, 28)">
                      <AtomNode start="(330, 8)" end="(330, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(330, 9)" end="(330, 27)">
                        <OtherNode start="(330, 9)" end="(330, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(330, 9)" end="(330, 27)" leading="" trailing="" raw_val="List.takeWhile_map" val="List.takeWhile_map" full_name="List.takeWhile_map" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(330, 27)" end="(330, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(332, 1)" end="(335, 48)" name="popWhile_map" full_name="Array.popWhile_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(332, 1)" end="(335, 48)" name="popWhile_map" full_name="Array.popWhile_map" _is_private_decl="False">
        <AtomNode start="(332, 1)" end="(332, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(332, 9)" end="(332, 21)">
          <IdentNode start="(332, 9)" end="(332, 21)" leading="" trailing=" " raw_val="popWhile_map" val="popWhile_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(332, 22)" end="(333, 56)">
          <NullNode start="(332, 22)" end="(332, 63)">
            <OtherNode start="(332, 22)" end="(332, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(332, 22)" end="(332, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(332, 23)" end="(332, 24)">
                <IdentNode start="(332, 23)" end="(332, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(332, 25)" end="(332, 32)">
                <AtomNode start="(332, 25)" end="(332, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(332, 27)" end="(332, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(332, 27)" end="(332, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(332, 29)" end="(332, 30)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(332, 31)" end="(332, 32)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(332, 32)" end="(332, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(332, 34)" end="(332, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(332, 34)" end="(332, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(332, 35)" end="(332, 36)">
                <IdentNode start="(332, 35)" end="(332, 36)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(332, 37)" end="(332, 47)">
                <AtomNode start="(332, 37)" end="(332, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(332, 39)" end="(332, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(332, 39)" end="(332, 40)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(332, 41)" end="(332, 42)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(332, 43)" end="(332, 47)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(332, 47)" end="(332, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(332, 49)" end="(332, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(332, 49)" end="(332, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(332, 50)" end="(332, 52)">
                <IdentNode start="(332, 50)" end="(332, 52)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(332, 53)" end="(332, 62)">
                <AtomNode start="(332, 53)" end="(332, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(332, 55)" end="(332, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(332, 55)" end="(332, 60)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(332, 61)" end="(332, 62)">
                    <IdentNode start="(332, 61)" end="(332, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(332, 62)" end="(332, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(332, 64)" end="(333, 56)">
            <AtomNode start="(332, 64)" end="(332, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(333, 5)" end="(333, 56)" kind="«term_=_»">
              <OtherNode start="(333, 5)" end="(333, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(333, 5)" end="(333, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(333, 5)" end="(333, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(333, 5)" end="(333, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(333, 6)" end="(333, 14)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(333, 6)" end="(333, 12)" leading="" trailing=" " raw_val="as.map" val="as.map"/>
                      <NullNode start="(333, 13)" end="(333, 14)">
                        <IdentNode start="(333, 13)" end="(333, 14)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(333, 14)" end="(333, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(333, 15)" end="(333, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(333, 16)" end="(333, 24)" leading="" trailing=" " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(333, 25)" end="(333, 26)">
                  <IdentNode start="(333, 25)" end="(333, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(333, 27)" end="(333, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(333, 29)" end="(333, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(333, 29)" end="(333, 54)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(333, 29)" end="(333, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(333, 29)" end="(333, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(333, 30)" end="(333, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(333, 30)" end="(333, 41)" leading="" trailing=" " raw_val="as.popWhile" val="as.popWhile"/>
                      <NullNode start="(333, 42)" end="(333, 49)">
                        <OtherNode start="(333, 42)" end="(333, 49)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(333, 42)" end="(333, 43)" leading="" trailing="" val="("/>
                          <OtherNode start="(333, 43)" end="(333, 48)" kind="«term_∘_»">
                            <IdentNode start="(333, 43)" end="(333, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                            <AtomNode start="(333, 45)" end="(333, 46)" leading="" trailing=" " val="∘"/>
                            <IdentNode start="(333, 47)" end="(333, 48)" leading="" trailing="" raw_val="f" val="f"/>
                          </OtherNode>
                          <AtomNode start="(333, 48)" end="(333, 49)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(333, 49)" end="(333, 50)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(333, 50)" end="(333, 51)" leading="" trailing="" val="."/>
                  <IdentNode start="(333, 51)" end="(333, 54)" leading="" trailing=" " raw_val="map" val="map" full_name="Array.map" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(333, 55)" end="(333, 56)">
                  <IdentNode start="(333, 55)" end="(333, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(333, 57)" end="(335, 48)">
          <AtomNode start="(333, 57)" end="(333, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(333, 60)" end="(335, 48)">
            <AtomNode start="(333, 60)" end="(333, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(334, 3)" end="(335, 48)">
              <TacticTacticseq1IndentedNode start="(334, 3)" end="(335, 48)">
                <NullNode start="(334, 3)" end="(335, 48)">
                  <OtherNode start="(334, 3)" end="(334, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;p : β → Bool&#10;as : Array α&#10;⊢ popWhile p (map f as) = map f (popWhile (p ∘ f) as)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;p : β → Bool&#10;as : List α&#10;⊢ popWhile p (map f { toList := as }) = map f (popWhile (p ∘ f) { toList := as })" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(334, 3)" end="(334, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(334, 10)" end="(334, 12)">
                      <OtherNode start="(334, 10)" end="(334, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(334, 10)" end="(334, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(334, 13)" end="(334, 22)">
                      <AtomNode start="(334, 13)" end="(334, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(334, 18)" end="(334, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(334, 18)" end="(334, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(334, 18)" end="(334, 22)">
                            <OtherNode start="(334, 18)" end="(334, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(334, 18)" end="(334, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(334, 19)" end="(334, 21)">
                                <OtherNode start="(334, 19)" end="(334, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(334, 19)" end="(334, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(334, 19)" end="(334, 21)">
                                      <OtherNode start="(334, 19)" end="(334, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(334, 19)" end="(334, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(334, 21)" end="(334, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(335, 3)" end="(335, 48)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;p : β → Bool&#10;as : List α&#10;⊢ popWhile p (map f { toList := as }) = map f (popWhile (p ∘ f) { toList := as })" state_after="no goals" tactic="simp [List.dropWhile_map, ← List.map_reverse]">
                    <AtomNode start="(335, 3)" end="(335, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(335, 8)" end="(335, 48)">
                      <AtomNode start="(335, 8)" end="(335, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(335, 9)" end="(335, 47)">
                        <OtherNode start="(335, 9)" end="(335, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(335, 9)" end="(335, 27)" leading="" trailing="" raw_val="List.dropWhile_map" val="List.dropWhile_map" full_name="List.dropWhile_map" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(335, 27)" end="(335, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(335, 29)" end="(335, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(335, 29)" end="(335, 30)">
                            <OtherNode start="(335, 29)" end="(335, 30)" kind="patternIgnore">
                              <OtherNode start="(335, 29)" end="(335, 30)" kind="token.«← »">
                                <AtomNode start="(335, 29)" end="(335, 30)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(335, 31)" end="(335, 47)" leading="" trailing="" raw_val="List.map_reverse" val="List.map_reverse" full_name="List.map_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(335, 47)" end="(335, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(337, 1)" end="(340, 34)" name="takeWhile_filterMap" full_name="Array.takeWhile_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(337, 1)" end="(340, 34)" name="takeWhile_filterMap" full_name="Array.takeWhile_filterMap" _is_private_decl="False">
        <AtomNode start="(337, 1)" end="(337, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(337, 9)" end="(337, 28)">
          <IdentNode start="(337, 9)" end="(337, 28)" leading="" trailing=" " raw_val="takeWhile_filterMap" val="takeWhile_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(337, 29)" end="(338, 83)">
          <NullNode start="(337, 29)" end="(337, 77)">
            <OtherNode start="(337, 29)" end="(337, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(337, 29)" end="(337, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(337, 30)" end="(337, 31)">
                <IdentNode start="(337, 30)" end="(337, 31)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(337, 32)" end="(337, 46)">
                <AtomNode start="(337, 32)" end="(337, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(337, 34)" end="(337, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(337, 34)" end="(337, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(337, 36)" end="(337, 37)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(337, 38)" end="(337, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(337, 38)" end="(337, 44)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(337, 45)" end="(337, 46)">
                      <IdentNode start="(337, 45)" end="(337, 46)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(337, 46)" end="(337, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(337, 48)" end="(337, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(337, 48)" end="(337, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(337, 49)" end="(337, 50)">
                <IdentNode start="(337, 49)" end="(337, 50)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(337, 51)" end="(337, 61)">
                <AtomNode start="(337, 51)" end="(337, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(337, 53)" end="(337, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(337, 53)" end="(337, 54)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(337, 55)" end="(337, 56)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(337, 57)" end="(337, 61)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(337, 61)" end="(337, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(337, 63)" end="(337, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(337, 63)" end="(337, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(337, 64)" end="(337, 66)">
                <IdentNode start="(337, 64)" end="(337, 66)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(337, 67)" end="(337, 76)">
                <AtomNode start="(337, 67)" end="(337, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(337, 69)" end="(337, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(337, 69)" end="(337, 74)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(337, 75)" end="(337, 76)">
                    <IdentNode start="(337, 75)" end="(337, 76)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(337, 76)" end="(337, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(337, 78)" end="(338, 83)">
            <AtomNode start="(337, 78)" end="(337, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(338, 5)" end="(338, 83)" kind="«term_=_»">
              <OtherNode start="(338, 5)" end="(338, 33)" kind="Lean.Parser.Term.app">
                <OtherNode start="(338, 5)" end="(338, 31)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(338, 5)" end="(338, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(338, 5)" end="(338, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(338, 6)" end="(338, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(338, 6)" end="(338, 18)" leading="" trailing=" " raw_val="as.filterMap" val="as.filterMap"/>
                      <NullNode start="(338, 19)" end="(338, 20)">
                        <IdentNode start="(338, 19)" end="(338, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(338, 20)" end="(338, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(338, 21)" end="(338, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(338, 22)" end="(338, 31)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(338, 32)" end="(338, 33)">
                  <IdentNode start="(338, 32)" end="(338, 33)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(338, 34)" end="(338, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(338, 36)" end="(338, 83)" kind="Lean.Parser.Term.app">
                <OtherNode start="(338, 36)" end="(338, 81)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(338, 36)" end="(338, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(338, 36)" end="(338, 37)" leading="" trailing="" val="("/>
                    <OtherNode start="(338, 37)" end="(338, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(338, 37)" end="(338, 49)" leading="" trailing=" " raw_val="as.takeWhile" val="as.takeWhile"/>
                      <NullNode start="(338, 50)" end="(338, 70)">
                        <OtherNode start="(338, 50)" end="(338, 70)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(338, 50)" end="(338, 53)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(338, 54)" end="(338, 70)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(338, 54)" end="(338, 55)">
                              <IdentNode start="(338, 54)" end="(338, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(338, 56)" end="(338, 58)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(338, 59)" end="(338, 70)" kind="Lean.Parser.Term.app">
                              <OtherNode start="(338, 59)" end="(338, 68)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(338, 59)" end="(338, 64)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(338, 59)" end="(338, 60)" leading="" trailing="" val="("/>
                                  <OtherNode start="(338, 60)" end="(338, 63)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(338, 60)" end="(338, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(338, 62)" end="(338, 63)">
                                      <IdentNode start="(338, 62)" end="(338, 63)" leading="" trailing="" raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(338, 63)" end="(338, 64)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(338, 64)" end="(338, 65)" leading="" trailing="" val="."/>
                                <IdentNode start="(338, 65)" end="(338, 68)" leading="" trailing=" " raw_val="all" val="all" full_name="Option.all" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                              </OtherNode>
                              <NullNode start="(338, 69)" end="(338, 70)">
                                <IdentNode start="(338, 69)" end="(338, 70)" leading="" trailing="" raw_val="p" val="p"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(338, 70)" end="(338, 71)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(338, 71)" end="(338, 72)" leading="" trailing="" val="."/>
                  <IdentNode start="(338, 72)" end="(338, 81)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="Array.filterMap" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(338, 82)" end="(338, 83)">
                  <IdentNode start="(338, 82)" end="(338, 83)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(338, 84)" end="(340, 34)">
          <AtomNode start="(338, 84)" end="(338, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(338, 87)" end="(340, 34)">
            <AtomNode start="(338, 87)" end="(338, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(339, 3)" end="(340, 34)">
              <TacticTacticseq1IndentedNode start="(339, 3)" end="(340, 34)">
                <NullNode start="(339, 3)" end="(340, 34)">
                  <OtherNode start="(339, 3)" end="(339, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;as : Array α&#10;⊢ takeWhile p (filterMap f as) = filterMap f (takeWhile (fun a =&amp;gt; Option.all p (f a)) as)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;as : List α&#10;⊢ takeWhile p (filterMap f { toList := as }) = filterMap f (takeWhile (fun a =&amp;gt; Option.all p (f a)) { toList := as })" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(339, 3)" end="(339, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(339, 10)" end="(339, 12)">
                      <OtherNode start="(339, 10)" end="(339, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(339, 10)" end="(339, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(339, 13)" end="(339, 22)">
                      <AtomNode start="(339, 13)" end="(339, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(339, 18)" end="(339, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(339, 18)" end="(339, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(339, 18)" end="(339, 22)">
                            <OtherNode start="(339, 18)" end="(339, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(339, 18)" end="(339, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(339, 19)" end="(339, 21)">
                                <OtherNode start="(339, 19)" end="(339, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(339, 19)" end="(339, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(339, 19)" end="(339, 21)">
                                      <OtherNode start="(339, 19)" end="(339, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(339, 19)" end="(339, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(339, 21)" end="(339, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(340, 3)" end="(340, 34)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;as : List α&#10;⊢ takeWhile p (filterMap f { toList := as }) = filterMap f (takeWhile (fun a =&amp;gt; Option.all p (f a)) { toList := as })" state_after="no goals" tactic="simp [List.takeWhile_filterMap]">
                    <AtomNode start="(340, 3)" end="(340, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(340, 8)" end="(340, 34)">
                      <AtomNode start="(340, 8)" end="(340, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(340, 9)" end="(340, 33)">
                        <OtherNode start="(340, 9)" end="(340, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(340, 9)" end="(340, 33)" leading="" trailing="" raw_val="List.takeWhile_filterMap" val="List.takeWhile_filterMap" full_name="List.takeWhile_filterMap" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(340, 33)" end="(340, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(342, 1)" end="(345, 60)" name="popWhile_filterMap" full_name="Array.popWhile_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(342, 1)" end="(345, 60)" name="popWhile_filterMap" full_name="Array.popWhile_filterMap" _is_private_decl="False">
        <AtomNode start="(342, 1)" end="(342, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(342, 9)" end="(342, 27)">
          <IdentNode start="(342, 9)" end="(342, 27)" leading="" trailing=" " raw_val="popWhile_filterMap" val="popWhile_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(342, 28)" end="(343, 81)">
          <NullNode start="(342, 28)" end="(342, 76)">
            <OtherNode start="(342, 28)" end="(342, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 28)" end="(342, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 29)" end="(342, 30)">
                <IdentNode start="(342, 29)" end="(342, 30)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(342, 31)" end="(342, 45)">
                <AtomNode start="(342, 31)" end="(342, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 33)" end="(342, 45)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(342, 33)" end="(342, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(342, 35)" end="(342, 36)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(342, 37)" end="(342, 45)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(342, 37)" end="(342, 43)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(342, 44)" end="(342, 45)">
                      <IdentNode start="(342, 44)" end="(342, 45)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 45)" end="(342, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(342, 47)" end="(342, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 47)" end="(342, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 48)" end="(342, 49)">
                <IdentNode start="(342, 48)" end="(342, 49)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(342, 50)" end="(342, 60)">
                <AtomNode start="(342, 50)" end="(342, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 52)" end="(342, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(342, 52)" end="(342, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(342, 54)" end="(342, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(342, 56)" end="(342, 60)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 60)" end="(342, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(342, 62)" end="(342, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 62)" end="(342, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 63)" end="(342, 65)">
                <IdentNode start="(342, 63)" end="(342, 65)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(342, 66)" end="(342, 75)">
                <AtomNode start="(342, 66)" end="(342, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 68)" end="(342, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(342, 68)" end="(342, 73)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(342, 74)" end="(342, 75)">
                    <IdentNode start="(342, 74)" end="(342, 75)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 75)" end="(342, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(342, 77)" end="(343, 81)">
            <AtomNode start="(342, 77)" end="(342, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(343, 5)" end="(343, 81)" kind="«term_=_»">
              <OtherNode start="(343, 5)" end="(343, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(343, 5)" end="(343, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(343, 5)" end="(343, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(343, 5)" end="(343, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(343, 6)" end="(343, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(343, 6)" end="(343, 18)" leading="" trailing=" " raw_val="as.filterMap" val="as.filterMap"/>
                      <NullNode start="(343, 19)" end="(343, 20)">
                        <IdentNode start="(343, 19)" end="(343, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(343, 20)" end="(343, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(343, 21)" end="(343, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(343, 22)" end="(343, 30)" leading="" trailing=" " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(343, 31)" end="(343, 32)">
                  <IdentNode start="(343, 31)" end="(343, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(343, 33)" end="(343, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(343, 35)" end="(343, 81)" kind="Lean.Parser.Term.app">
                <OtherNode start="(343, 35)" end="(343, 79)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(343, 35)" end="(343, 69)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(343, 35)" end="(343, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(343, 36)" end="(343, 68)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(343, 36)" end="(343, 47)" leading="" trailing=" " raw_val="as.popWhile" val="as.popWhile"/>
                      <NullNode start="(343, 48)" end="(343, 68)">
                        <OtherNode start="(343, 48)" end="(343, 68)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(343, 48)" end="(343, 51)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(343, 52)" end="(343, 68)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(343, 52)" end="(343, 53)">
                              <IdentNode start="(343, 52)" end="(343, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(343, 54)" end="(343, 56)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(343, 57)" end="(343, 68)" kind="Lean.Parser.Term.app">
                              <OtherNode start="(343, 57)" end="(343, 66)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(343, 57)" end="(343, 62)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(343, 57)" end="(343, 58)" leading="" trailing="" val="("/>
                                  <OtherNode start="(343, 58)" end="(343, 61)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(343, 58)" end="(343, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(343, 60)" end="(343, 61)">
                                      <IdentNode start="(343, 60)" end="(343, 61)" leading="" trailing="" raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(343, 61)" end="(343, 62)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(343, 62)" end="(343, 63)" leading="" trailing="" val="."/>
                                <IdentNode start="(343, 63)" end="(343, 66)" leading="" trailing=" " raw_val="all" val="all" full_name="Option.all" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                              </OtherNode>
                              <NullNode start="(343, 67)" end="(343, 68)">
                                <IdentNode start="(343, 67)" end="(343, 68)" leading="" trailing="" raw_val="p" val="p"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(343, 68)" end="(343, 69)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(343, 69)" end="(343, 70)" leading="" trailing="" val="."/>
                  <IdentNode start="(343, 70)" end="(343, 79)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="Array.filterMap" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(343, 80)" end="(343, 81)">
                  <IdentNode start="(343, 80)" end="(343, 81)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(343, 82)" end="(345, 60)">
          <AtomNode start="(343, 82)" end="(343, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(343, 85)" end="(345, 60)">
            <AtomNode start="(343, 85)" end="(343, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(344, 3)" end="(345, 60)">
              <TacticTacticseq1IndentedNode start="(344, 3)" end="(345, 60)">
                <NullNode start="(344, 3)" end="(345, 60)">
                  <OtherNode start="(344, 3)" end="(344, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;as : Array α&#10;⊢ popWhile p (filterMap f as) = filterMap f (popWhile (fun a =&amp;gt; Option.all p (f a)) as)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;as : List α&#10;⊢ popWhile p (filterMap f { toList := as }) = filterMap f (popWhile (fun a =&amp;gt; Option.all p (f a)) { toList := as })" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(344, 3)" end="(344, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(344, 10)" end="(344, 12)">
                      <OtherNode start="(344, 10)" end="(344, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(344, 10)" end="(344, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(344, 13)" end="(344, 22)">
                      <AtomNode start="(344, 13)" end="(344, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(344, 18)" end="(344, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(344, 18)" end="(344, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(344, 18)" end="(344, 22)">
                            <OtherNode start="(344, 18)" end="(344, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(344, 18)" end="(344, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(344, 19)" end="(344, 21)">
                                <OtherNode start="(344, 19)" end="(344, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(344, 19)" end="(344, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(344, 19)" end="(344, 21)">
                                      <OtherNode start="(344, 19)" end="(344, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(344, 19)" end="(344, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(344, 21)" end="(344, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(345, 3)" end="(345, 60)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;as : List α&#10;⊢ popWhile p (filterMap f { toList := as }) = filterMap f (popWhile (fun a =&amp;gt; Option.all p (f a)) { toList := as })" state_after="no goals" tactic="simp [List.dropWhile_filterMap, ← List.filterMap_reverse]">
                    <AtomNode start="(345, 3)" end="(345, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(345, 8)" end="(345, 60)">
                      <AtomNode start="(345, 8)" end="(345, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(345, 9)" end="(345, 59)">
                        <OtherNode start="(345, 9)" end="(345, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(345, 9)" end="(345, 33)" leading="" trailing="" raw_val="List.dropWhile_filterMap" val="List.dropWhile_filterMap" full_name="List.dropWhile_filterMap" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(345, 33)" end="(345, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(345, 35)" end="(345, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(345, 35)" end="(345, 36)">
                            <OtherNode start="(345, 35)" end="(345, 36)" kind="patternIgnore">
                              <OtherNode start="(345, 35)" end="(345, 36)" kind="token.«← »">
                                <AtomNode start="(345, 35)" end="(345, 36)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(345, 37)" end="(345, 59)" leading="" trailing="" raw_val="List.filterMap_reverse" val="List.filterMap_reverse" full_name="List.filterMap_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(345, 59)" end="(345, 60)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(347, 1)" end="(350, 31)" name="takeWhile_filter" full_name="Array.takeWhile_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(347, 1)" end="(350, 31)" name="takeWhile_filter" full_name="Array.takeWhile_filter" _is_private_decl="False">
        <AtomNode start="(347, 1)" end="(347, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(347, 9)" end="(347, 25)">
          <IdentNode start="(347, 9)" end="(347, 25)" leading="" trailing=" " raw_val="takeWhile_filter" val="takeWhile_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(347, 26)" end="(348, 77)">
          <NullNode start="(347, 26)" end="(347, 57)">
            <OtherNode start="(347, 26)" end="(347, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 26)" end="(347, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 27)" end="(347, 30)">
                <IdentNode start="(347, 27)" end="(347, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(347, 29)" end="(347, 30)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(347, 31)" end="(347, 41)">
                <AtomNode start="(347, 31)" end="(347, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 33)" end="(347, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(347, 33)" end="(347, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(347, 35)" end="(347, 36)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(347, 37)" end="(347, 41)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 41)" end="(347, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(347, 43)" end="(347, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 43)" end="(347, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 44)" end="(347, 46)">
                <IdentNode start="(347, 44)" end="(347, 46)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(347, 47)" end="(347, 56)">
                <AtomNode start="(347, 47)" end="(347, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 49)" end="(347, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(347, 49)" end="(347, 54)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(347, 55)" end="(347, 56)">
                    <IdentNode start="(347, 55)" end="(347, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 56)" end="(347, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(347, 58)" end="(348, 77)">
            <AtomNode start="(347, 58)" end="(347, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(348, 5)" end="(348, 77)" kind="«term_=_»">
              <OtherNode start="(348, 5)" end="(348, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(348, 5)" end="(348, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(348, 5)" end="(348, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(348, 5)" end="(348, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(348, 6)" end="(348, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(348, 6)" end="(348, 15)" leading="" trailing=" " raw_val="as.filter" val="as.filter"/>
                      <NullNode start="(348, 16)" end="(348, 17)">
                        <IdentNode start="(348, 16)" end="(348, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(348, 17)" end="(348, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(348, 18)" end="(348, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(348, 19)" end="(348, 28)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(348, 29)" end="(348, 30)">
                  <IdentNode start="(348, 29)" end="(348, 30)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(348, 31)" end="(348, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(348, 33)" end="(348, 77)" kind="Lean.Parser.Term.app">
                <OtherNode start="(348, 33)" end="(348, 75)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(348, 33)" end="(348, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(348, 33)" end="(348, 34)" leading="" trailing="" val="("/>
                    <OtherNode start="(348, 34)" end="(348, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(348, 34)" end="(348, 46)" leading="" trailing=" " raw_val="as.takeWhile" val="as.takeWhile"/>
                      <NullNode start="(348, 47)" end="(348, 67)">
                        <OtherNode start="(348, 47)" end="(348, 67)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(348, 47)" end="(348, 50)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(348, 51)" end="(348, 67)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(348, 51)" end="(348, 52)">
                              <IdentNode start="(348, 51)" end="(348, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(348, 53)" end="(348, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(348, 56)" end="(348, 67)" kind="«term_||_»">
                              <OtherNode start="(348, 56)" end="(348, 60)" kind="term!_">
                                <AtomNode start="(348, 56)" end="(348, 57)" leading="" trailing="" val="!"/>
                                <OtherNode start="(348, 57)" end="(348, 60)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(348, 57)" end="(348, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <NullNode start="(348, 59)" end="(348, 60)">
                                    <IdentNode start="(348, 59)" end="(348, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(348, 61)" end="(348, 63)" leading="" trailing=" " val="||"/>
                              <OtherNode start="(348, 64)" end="(348, 67)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(348, 64)" end="(348, 65)" leading="" trailing=" " raw_val="q" val="q"/>
                                <NullNode start="(348, 66)" end="(348, 67)">
                                  <IdentNode start="(348, 66)" end="(348, 67)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(348, 67)" end="(348, 68)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(348, 68)" end="(348, 69)" leading="" trailing="" val="."/>
                  <IdentNode start="(348, 69)" end="(348, 75)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(348, 76)" end="(348, 77)">
                  <IdentNode start="(348, 76)" end="(348, 77)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(348, 78)" end="(350, 31)">
          <AtomNode start="(348, 78)" end="(348, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(348, 81)" end="(350, 31)">
            <AtomNode start="(348, 81)" end="(348, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(349, 3)" end="(350, 31)">
              <TacticTacticseq1IndentedNode start="(349, 3)" end="(350, 31)">
                <NullNode start="(349, 3)" end="(350, 31)">
                  <OtherNode start="(349, 3)" end="(349, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p q : α → Bool&#10;as : Array α&#10;⊢ takeWhile q (filter p as) = filter p (takeWhile (fun a =&amp;gt; !p a || q a) as)" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;as : List α&#10;⊢ takeWhile q (filter p { toList := as }) = filter p (takeWhile (fun a =&amp;gt; !p a || q a) { toList := as })" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(349, 3)" end="(349, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(349, 10)" end="(349, 12)">
                      <OtherNode start="(349, 10)" end="(349, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(349, 10)" end="(349, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(349, 13)" end="(349, 22)">
                      <AtomNode start="(349, 13)" end="(349, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(349, 18)" end="(349, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(349, 18)" end="(349, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(349, 18)" end="(349, 22)">
                            <OtherNode start="(349, 18)" end="(349, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(349, 18)" end="(349, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(349, 19)" end="(349, 21)">
                                <OtherNode start="(349, 19)" end="(349, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(349, 19)" end="(349, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(349, 19)" end="(349, 21)">
                                      <OtherNode start="(349, 19)" end="(349, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(349, 19)" end="(349, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(349, 21)" end="(349, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(350, 3)" end="(350, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;as : List α&#10;⊢ takeWhile q (filter p { toList := as }) = filter p (takeWhile (fun a =&amp;gt; !p a || q a) { toList := as })" state_after="no goals" tactic="simp [List.takeWhile_filter]">
                    <AtomNode start="(350, 3)" end="(350, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(350, 8)" end="(350, 31)">
                      <AtomNode start="(350, 8)" end="(350, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(350, 9)" end="(350, 30)">
                        <OtherNode start="(350, 9)" end="(350, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(350, 9)" end="(350, 30)" leading="" trailing="" raw_val="List.takeWhile_filter" val="List.takeWhile_filter" full_name="List.takeWhile_filter" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(350, 30)" end="(350, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(352, 1)" end="(355, 54)" name="popWhile_filter" full_name="Array.popWhile_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(352, 1)" end="(355, 54)" name="popWhile_filter" full_name="Array.popWhile_filter" _is_private_decl="False">
        <AtomNode start="(352, 1)" end="(352, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(352, 9)" end="(352, 24)">
          <IdentNode start="(352, 9)" end="(352, 24)" leading="" trailing=" " raw_val="popWhile_filter" val="popWhile_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(352, 25)" end="(353, 75)">
          <NullNode start="(352, 25)" end="(352, 56)">
            <OtherNode start="(352, 25)" end="(352, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(352, 25)" end="(352, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(352, 26)" end="(352, 29)">
                <IdentNode start="(352, 26)" end="(352, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(352, 28)" end="(352, 29)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(352, 30)" end="(352, 40)">
                <AtomNode start="(352, 30)" end="(352, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(352, 32)" end="(352, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(352, 32)" end="(352, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(352, 34)" end="(352, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(352, 36)" end="(352, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(352, 40)" end="(352, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(352, 42)" end="(352, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(352, 42)" end="(352, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(352, 43)" end="(352, 45)">
                <IdentNode start="(352, 43)" end="(352, 45)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(352, 46)" end="(352, 55)">
                <AtomNode start="(352, 46)" end="(352, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(352, 48)" end="(352, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(352, 48)" end="(352, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(352, 54)" end="(352, 55)">
                    <IdentNode start="(352, 54)" end="(352, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(352, 55)" end="(352, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(352, 57)" end="(353, 75)">
            <AtomNode start="(352, 57)" end="(352, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(353, 5)" end="(353, 75)" kind="«term_=_»">
              <OtherNode start="(353, 5)" end="(353, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(353, 5)" end="(353, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(353, 5)" end="(353, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(353, 5)" end="(353, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(353, 6)" end="(353, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(353, 6)" end="(353, 15)" leading="" trailing=" " raw_val="as.filter" val="as.filter"/>
                      <NullNode start="(353, 16)" end="(353, 17)">
                        <IdentNode start="(353, 16)" end="(353, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(353, 17)" end="(353, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(353, 18)" end="(353, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(353, 19)" end="(353, 27)" leading="" trailing=" " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(353, 28)" end="(353, 29)">
                  <IdentNode start="(353, 28)" end="(353, 29)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(353, 30)" end="(353, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(353, 32)" end="(353, 75)" kind="Lean.Parser.Term.app">
                <OtherNode start="(353, 32)" end="(353, 73)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(353, 32)" end="(353, 66)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(353, 32)" end="(353, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(353, 33)" end="(353, 65)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(353, 33)" end="(353, 44)" leading="" trailing=" " raw_val="as.popWhile" val="as.popWhile"/>
                      <NullNode start="(353, 45)" end="(353, 65)">
                        <OtherNode start="(353, 45)" end="(353, 65)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(353, 45)" end="(353, 48)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(353, 49)" end="(353, 65)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(353, 49)" end="(353, 50)">
                              <IdentNode start="(353, 49)" end="(353, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(353, 51)" end="(353, 53)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(353, 54)" end="(353, 65)" kind="«term_||_»">
                              <OtherNode start="(353, 54)" end="(353, 58)" kind="term!_">
                                <AtomNode start="(353, 54)" end="(353, 55)" leading="" trailing="" val="!"/>
                                <OtherNode start="(353, 55)" end="(353, 58)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(353, 55)" end="(353, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <NullNode start="(353, 57)" end="(353, 58)">
                                    <IdentNode start="(353, 57)" end="(353, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(353, 59)" end="(353, 61)" leading="" trailing=" " val="||"/>
                              <OtherNode start="(353, 62)" end="(353, 65)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(353, 62)" end="(353, 63)" leading="" trailing=" " raw_val="q" val="q"/>
                                <NullNode start="(353, 64)" end="(353, 65)">
                                  <IdentNode start="(353, 64)" end="(353, 65)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(353, 65)" end="(353, 66)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(353, 66)" end="(353, 67)" leading="" trailing="" val="."/>
                  <IdentNode start="(353, 67)" end="(353, 73)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(353, 74)" end="(353, 75)">
                  <IdentNode start="(353, 74)" end="(353, 75)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(353, 76)" end="(355, 54)">
          <AtomNode start="(353, 76)" end="(353, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(353, 79)" end="(355, 54)">
            <AtomNode start="(353, 79)" end="(353, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(354, 3)" end="(355, 54)">
              <TacticTacticseq1IndentedNode start="(354, 3)" end="(355, 54)">
                <NullNode start="(354, 3)" end="(355, 54)">
                  <OtherNode start="(354, 3)" end="(354, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p q : α → Bool&#10;as : Array α&#10;⊢ popWhile q (filter p as) = filter p (popWhile (fun a =&amp;gt; !p a || q a) as)" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;as : List α&#10;⊢ popWhile q (filter p { toList := as }) = filter p (popWhile (fun a =&amp;gt; !p a || q a) { toList := as })" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(354, 3)" end="(354, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(354, 10)" end="(354, 12)">
                      <OtherNode start="(354, 10)" end="(354, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(354, 10)" end="(354, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(354, 13)" end="(354, 22)">
                      <AtomNode start="(354, 13)" end="(354, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(354, 18)" end="(354, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(354, 18)" end="(354, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(354, 18)" end="(354, 22)">
                            <OtherNode start="(354, 18)" end="(354, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(354, 18)" end="(354, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(354, 19)" end="(354, 21)">
                                <OtherNode start="(354, 19)" end="(354, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(354, 19)" end="(354, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(354, 19)" end="(354, 21)">
                                      <OtherNode start="(354, 19)" end="(354, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(354, 19)" end="(354, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(354, 21)" end="(354, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(355, 3)" end="(355, 54)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;as : List α&#10;⊢ popWhile q (filter p { toList := as }) = filter p (popWhile (fun a =&amp;gt; !p a || q a) { toList := as })" state_after="no goals" tactic="simp [List.dropWhile_filter, ← List.filter_reverse]">
                    <AtomNode start="(355, 3)" end="(355, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(355, 8)" end="(355, 54)">
                      <AtomNode start="(355, 8)" end="(355, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(355, 9)" end="(355, 53)">
                        <OtherNode start="(355, 9)" end="(355, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(355, 9)" end="(355, 30)" leading="" trailing="" raw_val="List.dropWhile_filter" val="List.dropWhile_filter" full_name="List.dropWhile_filter" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(355, 30)" end="(355, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(355, 32)" end="(355, 53)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(355, 32)" end="(355, 33)">
                            <OtherNode start="(355, 32)" end="(355, 33)" kind="patternIgnore">
                              <OtherNode start="(355, 32)" end="(355, 33)" kind="token.«← »">
                                <AtomNode start="(355, 32)" end="(355, 33)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(355, 34)" end="(355, 53)" leading="" trailing="" raw_val="List.filter_reverse" val="List.filter_reverse" full_name="List.filter_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(355, 53)" end="(355, 54)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(357, 1)" end="(363, 16)" name="takeWhile_append" full_name="Array.takeWhile_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(357, 1)" end="(363, 16)" name="takeWhile_append" full_name="Array.takeWhile_append" _is_private_decl="False">
        <AtomNode start="(357, 1)" end="(357, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(357, 9)" end="(357, 25)">
          <IdentNode start="(357, 9)" end="(357, 25)" leading="" trailing=" " raw_val="takeWhile_append" val="takeWhile_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(357, 26)" end="(359, 87)">
          <NullNode start="(357, 26)" end="(357, 43)">
            <OtherNode start="(357, 26)" end="(357, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(357, 26)" end="(357, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(357, 27)" end="(357, 32)">
                <IdentNode start="(357, 27)" end="(357, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(357, 30)" end="(357, 32)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(357, 33)" end="(357, 42)">
                <AtomNode start="(357, 33)" end="(357, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(357, 35)" end="(357, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(357, 35)" end="(357, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(357, 41)" end="(357, 42)">
                    <IdentNode start="(357, 41)" end="(357, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(357, 42)" end="(357, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(357, 44)" end="(359, 87)">
            <AtomNode start="(357, 44)" end="(357, 45)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(358, 5)" end="(359, 87)" kind="«term_=_»">
              <OtherNode start="(358, 5)" end="(358, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(358, 5)" end="(358, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(358, 5)" end="(358, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(358, 5)" end="(358, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(358, 6)" end="(358, 14)" kind="«term_++_»">
                      <IdentNode start="(358, 6)" end="(358, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(358, 9)" end="(358, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(358, 12)" end="(358, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(358, 14)" end="(358, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(358, 15)" end="(358, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(358, 16)" end="(358, 25)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(358, 26)" end="(358, 27)">
                  <IdentNode start="(358, 26)" end="(358, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(358, 28)" end="(358, 29)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(359, 7)" end="(359, 87)" kind="termIfThenElse">
                <AtomNode start="(359, 7)" end="(359, 9)" leading="" trailing=" " val="if"/>
                <OtherNode start="(359, 10)" end="(359, 41)" kind="«term_=_»">
                  <OtherNode start="(359, 10)" end="(359, 31)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(359, 10)" end="(359, 26)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(359, 10)" end="(359, 11)" leading="" trailing="" val="("/>
                      <OtherNode start="(359, 11)" end="(359, 25)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(359, 11)" end="(359, 23)" leading="" trailing=" " raw_val="xs.takeWhile" val="xs.takeWhile"/>
                        <NullNode start="(359, 24)" end="(359, 25)">
                          <IdentNode start="(359, 24)" end="(359, 25)" leading="" trailing="" raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(359, 25)" end="(359, 26)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(359, 26)" end="(359, 27)" leading="" trailing="" val="."/>
                    <IdentNode start="(359, 27)" end="(359, 31)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <AtomNode start="(359, 32)" end="(359, 33)" leading="" trailing=" " val="="/>
                  <IdentNode start="(359, 34)" end="(359, 41)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                </OtherNode>
                <AtomNode start="(359, 42)" end="(359, 46)" leading="" trailing=" " val="then"/>
                <OtherNode start="(359, 47)" end="(359, 67)" kind="«term_++_»">
                  <IdentNode start="(359, 47)" end="(359, 49)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(359, 50)" end="(359, 52)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(359, 53)" end="(359, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(359, 53)" end="(359, 65)" leading="" trailing=" " raw_val="ys.takeWhile" val="ys.takeWhile"/>
                    <NullNode start="(359, 66)" end="(359, 67)">
                      <IdentNode start="(359, 66)" end="(359, 67)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(359, 68)" end="(359, 72)" leading="" trailing=" " val="else"/>
                <OtherNode start="(359, 73)" end="(359, 87)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(359, 73)" end="(359, 85)" leading="" trailing=" " raw_val="xs.takeWhile" val="xs.takeWhile"/>
                  <NullNode start="(359, 86)" end="(359, 87)">
                    <IdentNode start="(359, 86)" end="(359, 87)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(359, 88)" end="(363, 16)">
          <AtomNode start="(359, 88)" end="(359, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(359, 91)" end="(363, 16)">
            <AtomNode start="(359, 91)" end="(359, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(360, 3)" end="(363, 16)">
              <TacticTacticseq1IndentedNode start="(360, 3)" end="(363, 16)">
                <NullNode start="(360, 3)" end="(363, 16)">
                  <OtherNode start="(360, 3)" end="(360, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;⊢ takeWhile p (xs ++ ys) = if (takeWhile p xs).size = xs.size then xs ++ takeWhile p ys else takeWhile p xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ takeWhile p ({ toList := xs } ++ ys) =&#10;    if (takeWhile p { toList := xs }).size = { toList := xs }.size then { toList := xs } ++ takeWhile p ys&#10;    else takeWhile p { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(360, 3)" end="(360, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(360, 10)" end="(360, 12)">
                      <OtherNode start="(360, 10)" end="(360, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(360, 10)" end="(360, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(360, 13)" end="(360, 22)">
                      <AtomNode start="(360, 13)" end="(360, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(360, 18)" end="(360, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(360, 18)" end="(360, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(360, 18)" end="(360, 22)">
                            <OtherNode start="(360, 18)" end="(360, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(360, 18)" end="(360, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(360, 19)" end="(360, 21)">
                                <OtherNode start="(360, 19)" end="(360, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(360, 19)" end="(360, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(360, 19)" end="(360, 21)">
                                      <OtherNode start="(360, 19)" end="(360, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(360, 19)" end="(360, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(360, 21)" end="(360, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(361, 3)" end="(361, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ takeWhile p ({ toList := xs } ++ ys) =&#10;    if (takeWhile p { toList := xs }).size = { toList := xs }.size then { toList := xs } ++ takeWhile p ys&#10;    else takeWhile p { toList := xs }" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ takeWhile p ({ toList := xs } ++ { toList := ys }) =&#10;    if (takeWhile p { toList := xs }).size = { toList := xs }.size then { toList := xs } ++ takeWhile p { toList := ys }&#10;    else takeWhile p { toList := xs }" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(361, 3)" end="(361, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(361, 10)" end="(361, 12)">
                      <OtherNode start="(361, 10)" end="(361, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(361, 10)" end="(361, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(361, 13)" end="(361, 22)">
                      <AtomNode start="(361, 13)" end="(361, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(361, 18)" end="(361, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(361, 18)" end="(361, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(361, 18)" end="(361, 22)">
                            <OtherNode start="(361, 18)" end="(361, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(361, 18)" end="(361, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(361, 19)" end="(361, 21)">
                                <OtherNode start="(361, 19)" end="(361, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(361, 19)" end="(361, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(361, 19)" end="(361, 21)">
                                      <OtherNode start="(361, 19)" end="(361, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(361, 19)" end="(361, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(361, 21)" end="(361, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(362, 3)" end="(362, 100)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ takeWhile p ({ toList := xs } ++ { toList := ys }) =&#10;    if (takeWhile p { toList := xs }).size = { toList := xs }.size then { toList := xs } ++ takeWhile p { toList := ys }&#10;    else takeWhile p { toList := xs }" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if (List.takeWhile p xs).length = xs.length then xs ++ List.takeWhile p ys else List.takeWhile p xs).toArray =&#10;    if (List.takeWhile p xs).length = xs.length then (xs ++ List.takeWhile p ys).toArray&#10;    else (List.takeWhile p xs).toArray" tactic="simp only [List.append_toArray, List.takeWhile_toArray, List.takeWhile_append, List.size_toArray]">
                    <AtomNode start="(362, 3)" end="(362, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(362, 8)" end="(362, 12)">
                      <AtomNode start="(362, 8)" end="(362, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(362, 13)" end="(362, 100)">
                      <AtomNode start="(362, 13)" end="(362, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(362, 14)" end="(362, 99)">
                        <OtherNode start="(362, 14)" end="(362, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(362, 14)" end="(362, 33)" leading="" trailing="" raw_val="List.append_toArray" val="List.append_toArray" full_name="List.append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(362, 33)" end="(362, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(362, 35)" end="(362, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(362, 35)" end="(362, 57)" leading="" trailing="" raw_val="List.takeWhile_toArray" val="List.takeWhile_toArray" full_name="List.takeWhile_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(362, 57)" end="(362, 58)" leading="" trailing=" " val=","/>
                        <OtherNode start="(362, 59)" end="(362, 80)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(362, 59)" end="(362, 80)" leading="" trailing="" raw_val="List.takeWhile_append" val="List.takeWhile_append" full_name="List.takeWhile_append" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(362, 80)" end="(362, 81)" leading="" trailing=" " val=","/>
                        <OtherNode start="(362, 82)" end="(362, 99)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(362, 82)" end="(362, 99)" leading="" trailing="" raw_val="List.size_toArray" val="List.size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(362, 99)" end="(362, 100)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(363, 3)" end="(363, 16)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if (List.takeWhile p xs).length = xs.length then xs ++ List.takeWhile p ys else List.takeWhile p xs).toArray =&#10;    if (List.takeWhile p xs).length = xs.length then (xs ++ List.takeWhile p ys).toArray&#10;    else (List.takeWhile p xs).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; rfl">
                    <OtherNode start="(363, 3)" end="(363, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(363, 3)" end="(363, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(363, 9)" end="(363, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(363, 13)" end="(363, 16)" kind="Lean.Parser.Tactic.tacticRfl">
                      <AtomNode start="(363, 13)" end="(363, 16)" leading="" trailing="&#10;&#10;" val="rfl"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(365, 1)" end="(370, 40)" name="takeWhile_append_of_pos" full_name="Array.takeWhile_append_of_pos">
      <CommandDeclmodifiersNode start="(365, 1)" end="(365, 8)">
        <NullNode/>
        <NullNode start="(365, 1)" end="(365, 8)">
          <OtherNode start="(365, 1)" end="(365, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(365, 1)" end="(365, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(365, 3)" end="(365, 7)">
              <OtherNode start="(365, 3)" end="(365, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(365, 3)" end="(365, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(365, 3)" end="(365, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(365, 7)" end="(365, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(365, 9)" end="(370, 40)" name="takeWhile_append_of_pos" full_name="Array.takeWhile_append_of_pos" _is_private_decl="False">
        <AtomNode start="(365, 9)" end="(365, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(365, 17)" end="(365, 40)">
          <IdentNode start="(365, 17)" end="(365, 40)" leading="" trailing=" " raw_val="takeWhile_append_of_pos" val="takeWhile_append_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(365, 41)" end="(366, 50)">
          <NullNode start="(365, 41)" end="(365, 93)">
            <OtherNode start="(365, 41)" end="(365, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(365, 41)" end="(365, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(365, 42)" end="(365, 43)">
                <IdentNode start="(365, 42)" end="(365, 43)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(365, 44)" end="(365, 54)">
                <AtomNode start="(365, 44)" end="(365, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(365, 46)" end="(365, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(365, 46)" end="(365, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(365, 48)" end="(365, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(365, 50)" end="(365, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(365, 54)" end="(365, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(365, 56)" end="(365, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(365, 56)" end="(365, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(365, 57)" end="(365, 62)">
                <IdentNode start="(365, 57)" end="(365, 59)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(365, 60)" end="(365, 62)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(365, 63)" end="(365, 72)">
                <AtomNode start="(365, 63)" end="(365, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(365, 65)" end="(365, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(365, 65)" end="(365, 70)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(365, 71)" end="(365, 72)">
                    <IdentNode start="(365, 71)" end="(365, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(365, 72)" end="(365, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(365, 74)" end="(365, 93)">
              <AtomNode start="(365, 74)" end="(365, 75)" leading="" trailing="" val="("/>
              <NullNode start="(365, 75)" end="(365, 76)">
                <IdentNode start="(365, 75)" end="(365, 76)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(365, 77)" end="(365, 92)">
                <AtomNode start="(365, 77)" end="(365, 78)" leading="" trailing=" " val=":"/>
                <OtherNode start="(365, 79)" end="(365, 92)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(365, 79)" end="(365, 80)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(365, 81)" end="(365, 82)">
                    <IdentNode start="(365, 81)" end="(365, 82)" leading="" trailing=" " raw_val="a" val="a"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(365, 83)" end="(365, 87)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(365, 83)" end="(365, 84)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(365, 85)" end="(365, 87)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(365, 87)" end="(365, 88)" leading="" trailing=" " val=","/>
                  <OtherNode start="(365, 89)" end="(365, 92)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(365, 89)" end="(365, 90)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(365, 91)" end="(365, 92)">
                      <IdentNode start="(365, 91)" end="(365, 92)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(365, 92)" end="(365, 93)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(365, 94)" end="(366, 50)">
            <AtomNode start="(365, 94)" end="(365, 95)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(366, 5)" end="(366, 50)" kind="«term_=_»">
              <OtherNode start="(366, 5)" end="(366, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(366, 5)" end="(366, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(366, 5)" end="(366, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(366, 5)" end="(366, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(366, 6)" end="(366, 14)" kind="«term_++_»">
                      <IdentNode start="(366, 6)" end="(366, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(366, 9)" end="(366, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(366, 12)" end="(366, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(366, 14)" end="(366, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(366, 15)" end="(366, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(366, 16)" end="(366, 25)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(366, 26)" end="(366, 27)">
                  <IdentNode start="(366, 26)" end="(366, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(366, 28)" end="(366, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(366, 30)" end="(366, 50)" kind="«term_++_»">
                <IdentNode start="(366, 30)" end="(366, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <AtomNode start="(366, 33)" end="(366, 35)" leading="" trailing=" " val="++"/>
                <OtherNode start="(366, 36)" end="(366, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(366, 36)" end="(366, 48)" leading="" trailing=" " raw_val="ys.takeWhile" val="ys.takeWhile"/>
                  <NullNode start="(366, 49)" end="(366, 50)">
                    <IdentNode start="(366, 49)" end="(366, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(366, 51)" end="(370, 40)">
          <AtomNode start="(366, 51)" end="(366, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(366, 54)" end="(370, 40)">
            <AtomNode start="(366, 54)" end="(366, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(367, 3)" end="(370, 40)">
              <TacticTacticseq1IndentedNode start="(367, 3)" end="(370, 40)">
                <NullNode start="(367, 3)" end="(370, 40)">
                  <OtherNode start="(367, 3)" end="(367, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;h : ∀ (a : α), a ∈ xs → p a = true&#10;⊢ takeWhile p (xs ++ ys) = xs ++ takeWhile p ys" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → p a = true&#10;⊢ takeWhile p ({ toList := xs } ++ ys) = { toList := xs } ++ takeWhile p ys" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(367, 3)" end="(367, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(367, 10)" end="(367, 12)">
                      <OtherNode start="(367, 10)" end="(367, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(367, 10)" end="(367, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(367, 13)" end="(367, 22)">
                      <AtomNode start="(367, 13)" end="(367, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(367, 18)" end="(367, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(367, 18)" end="(367, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(367, 18)" end="(367, 22)">
                            <OtherNode start="(367, 18)" end="(367, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(367, 18)" end="(367, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(367, 19)" end="(367, 21)">
                                <OtherNode start="(367, 19)" end="(367, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(367, 19)" end="(367, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(367, 19)" end="(367, 21)">
                                      <OtherNode start="(367, 19)" end="(367, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(367, 19)" end="(367, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(367, 21)" end="(367, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(368, 3)" end="(368, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → p a = true&#10;⊢ takeWhile p ({ toList := xs } ++ ys) = { toList := xs } ++ takeWhile p ys" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → p a = true&#10;ys : List α&#10;⊢ takeWhile p ({ toList := xs } ++ { toList := ys }) = { toList := xs } ++ takeWhile p { toList := ys }" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(368, 3)" end="(368, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(368, 10)" end="(368, 12)">
                      <OtherNode start="(368, 10)" end="(368, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(368, 10)" end="(368, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(368, 13)" end="(368, 22)">
                      <AtomNode start="(368, 13)" end="(368, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(368, 18)" end="(368, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(368, 18)" end="(368, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(368, 18)" end="(368, 22)">
                            <OtherNode start="(368, 18)" end="(368, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(368, 18)" end="(368, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(368, 19)" end="(368, 21)">
                                <OtherNode start="(368, 19)" end="(368, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(368, 19)" end="(368, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(368, 19)" end="(368, 21)">
                                      <OtherNode start="(368, 19)" end="(368, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(368, 19)" end="(368, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(368, 21)" end="(368, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(369, 3)" end="(369, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → p a = true&#10;ys : List α&#10;⊢ takeWhile p ({ toList := xs } ++ { toList := ys }) = { toList := xs } ++ takeWhile p { toList := ys }" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ xs → p a = true&#10;⊢ takeWhile p ({ toList := xs } ++ { toList := ys }) = { toList := xs } ++ takeWhile p { toList := ys }" tactic="simp at h">
                    <AtomNode start="(369, 3)" end="(369, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(369, 8)" end="(369, 12)">
                      <OtherNode start="(369, 8)" end="(369, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(369, 8)" end="(369, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(369, 11)" end="(369, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(369, 11)" end="(369, 12)">
                            <IdentNode start="(369, 11)" end="(369, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(370, 3)" end="(370, 40)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ xs → p a = true&#10;⊢ takeWhile p ({ toList := xs } ++ { toList := ys }) = { toList := xs } ++ takeWhile p { toList := ys }" state_after="no goals" tactic="simp [List.takeWhile_append_of_pos h]">
                    <AtomNode start="(370, 3)" end="(370, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(370, 8)" end="(370, 40)">
                      <AtomNode start="(370, 8)" end="(370, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(370, 9)" end="(370, 39)">
                        <OtherNode start="(370, 9)" end="(370, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(370, 9)" end="(370, 39)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(370, 9)" end="(370, 37)" leading="" trailing=" " raw_val="List.takeWhile_append_of_pos" val="List.takeWhile_append_of_pos" full_name="List.takeWhile_append_of_pos" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                            <NullNode start="(370, 38)" end="(370, 39)">
                              <IdentNode start="(370, 38)" end="(370, 39)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(370, 39)" end="(370, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(372, 1)" end="(383, 9)" name="popWhile_append" full_name="Array.popWhile_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(372, 1)" end="(383, 9)" name="popWhile_append" full_name="Array.popWhile_append" _is_private_decl="False">
        <AtomNode start="(372, 1)" end="(372, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(372, 9)" end="(372, 24)">
          <IdentNode start="(372, 9)" end="(372, 24)" leading="" trailing=" " raw_val="popWhile_append" val="popWhile_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(372, 25)" end="(374, 77)">
          <NullNode start="(372, 25)" end="(372, 42)">
            <OtherNode start="(372, 25)" end="(372, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(372, 25)" end="(372, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(372, 26)" end="(372, 31)">
                <IdentNode start="(372, 26)" end="(372, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(372, 29)" end="(372, 31)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(372, 32)" end="(372, 41)">
                <AtomNode start="(372, 32)" end="(372, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(372, 34)" end="(372, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(372, 34)" end="(372, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(372, 40)" end="(372, 41)">
                    <IdentNode start="(372, 40)" end="(372, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(372, 41)" end="(372, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(372, 43)" end="(374, 77)">
            <AtomNode start="(372, 43)" end="(372, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(373, 5)" end="(374, 77)" kind="«term_=_»">
              <OtherNode start="(373, 5)" end="(373, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(373, 5)" end="(373, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(373, 5)" end="(373, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(373, 5)" end="(373, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(373, 6)" end="(373, 14)" kind="«term_++_»">
                      <IdentNode start="(373, 6)" end="(373, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(373, 9)" end="(373, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(373, 12)" end="(373, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(373, 14)" end="(373, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(373, 15)" end="(373, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(373, 16)" end="(373, 24)" leading="" trailing=" " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(373, 25)" end="(373, 26)">
                  <IdentNode start="(373, 25)" end="(373, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(373, 27)" end="(373, 28)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(374, 7)" end="(374, 77)" kind="termIfThenElse">
                <AtomNode start="(374, 7)" end="(374, 9)" leading="" trailing=" " val="if"/>
                <OtherNode start="(374, 10)" end="(374, 33)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(374, 10)" end="(374, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(374, 10)" end="(374, 11)" leading="" trailing="" val="("/>
                    <OtherNode start="(374, 11)" end="(374, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(374, 11)" end="(374, 22)" leading="" trailing=" " raw_val="ys.popWhile" val="ys.popWhile"/>
                      <NullNode start="(374, 23)" end="(374, 24)">
                        <IdentNode start="(374, 23)" end="(374, 24)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(374, 24)" end="(374, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(374, 25)" end="(374, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(374, 26)" end="(374, 33)" leading="" trailing=" " raw_val="isEmpty" val="isEmpty" full_name="Array.isEmpty" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <AtomNode start="(374, 34)" end="(374, 38)" leading="" trailing=" " val="then"/>
                <OtherNode start="(374, 39)" end="(374, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(374, 39)" end="(374, 50)" leading="" trailing=" " raw_val="xs.popWhile" val="xs.popWhile"/>
                  <NullNode start="(374, 51)" end="(374, 52)">
                    <IdentNode start="(374, 51)" end="(374, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(374, 53)" end="(374, 57)" leading="" trailing=" " val="else"/>
                <OtherNode start="(374, 58)" end="(374, 77)" kind="«term_++_»">
                  <IdentNode start="(374, 58)" end="(374, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(374, 61)" end="(374, 63)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(374, 64)" end="(374, 77)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(374, 64)" end="(374, 75)" leading="" trailing=" " raw_val="ys.popWhile" val="ys.popWhile"/>
                    <NullNode start="(374, 76)" end="(374, 77)">
                      <IdentNode start="(374, 76)" end="(374, 77)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(374, 78)" end="(383, 9)">
          <AtomNode start="(374, 78)" end="(374, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(374, 81)" end="(383, 9)">
            <AtomNode start="(374, 81)" end="(374, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(375, 3)" end="(383, 9)">
              <TacticTacticseq1IndentedNode start="(375, 3)" end="(383, 9)">
                <NullNode start="(375, 3)" end="(383, 9)">
                  <OtherNode start="(375, 3)" end="(375, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;⊢ popWhile p (xs ++ ys) = if (popWhile p ys).isEmpty = true then popWhile p xs else xs ++ popWhile p ys" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ popWhile p ({ toList := xs } ++ ys) =&#10;    if (popWhile p ys).isEmpty = true then popWhile p { toList := xs } else { toList := xs } ++ popWhile p ys" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(375, 3)" end="(375, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(375, 10)" end="(375, 12)">
                      <OtherNode start="(375, 10)" end="(375, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(375, 10)" end="(375, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(375, 13)" end="(375, 22)">
                      <AtomNode start="(375, 13)" end="(375, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(375, 18)" end="(375, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(375, 18)" end="(375, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(375, 18)" end="(375, 22)">
                            <OtherNode start="(375, 18)" end="(375, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(375, 18)" end="(375, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(375, 19)" end="(375, 21)">
                                <OtherNode start="(375, 19)" end="(375, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(375, 19)" end="(375, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(375, 19)" end="(375, 21)">
                                      <OtherNode start="(375, 19)" end="(375, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(375, 19)" end="(375, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(375, 21)" end="(375, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(376, 3)" end="(376, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ popWhile p ({ toList := xs } ++ ys) =&#10;    if (popWhile p ys).isEmpty = true then popWhile p { toList := xs } else { toList := xs } ++ popWhile p ys" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ popWhile p ({ toList := xs } ++ { toList := ys }) =&#10;    if (popWhile p { toList := ys }).isEmpty = true then popWhile p { toList := xs }&#10;    else { toList := xs } ++ popWhile p { toList := ys }" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(376, 3)" end="(376, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(376, 10)" end="(376, 12)">
                      <OtherNode start="(376, 10)" end="(376, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(376, 10)" end="(376, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(376, 13)" end="(376, 22)">
                      <AtomNode start="(376, 13)" end="(376, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(376, 18)" end="(376, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(376, 18)" end="(376, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(376, 18)" end="(376, 22)">
                            <OtherNode start="(376, 18)" end="(376, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(376, 18)" end="(376, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(376, 19)" end="(376, 21)">
                                <OtherNode start="(376, 19)" end="(376, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(376, 19)" end="(376, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(376, 19)" end="(376, 21)">
                                      <OtherNode start="(376, 19)" end="(376, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(376, 19)" end="(376, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(376, 21)" end="(376, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(377, 3)" end="(378, 66)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ popWhile p ({ toList := xs } ++ { toList := ys }) =&#10;    if (popWhile p { toList := ys }).isEmpty = true then popWhile p { toList := xs }&#10;    else { toList := xs } ++ popWhile p { toList := ys }" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if (List.dropWhile p ys.reverse).isEmpty = true then List.dropWhile p xs.reverse&#10;        else List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray =&#10;    if (popWhile p { toList := ys }).isEmpty = true then (List.dropWhile p xs.reverse).reverse.toArray&#10;    else (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" tactic="simp only [List.append_toArray, List.popWhile_toArray, List.reverse_append, List.dropWhile_append,&#10;  List.isEmpty_iff, List.isEmpty_toArray, List.isEmpty_reverse]">
                    <AtomNode start="(377, 3)" end="(377, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(377, 8)" end="(377, 12)">
                      <AtomNode start="(377, 8)" end="(377, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(377, 13)" end="(378, 66)">
                      <AtomNode start="(377, 13)" end="(377, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(377, 14)" end="(378, 65)">
                        <OtherNode start="(377, 14)" end="(377, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(377, 14)" end="(377, 33)" leading="" trailing="" raw_val="List.append_toArray" val="List.append_toArray" full_name="List.append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(377, 33)" end="(377, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(377, 35)" end="(377, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(377, 35)" end="(377, 56)" leading="" trailing="" raw_val="List.popWhile_toArray" val="List.popWhile_toArray" full_name="List.popWhile_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(377, 56)" end="(377, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(377, 58)" end="(377, 77)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(377, 58)" end="(377, 77)" leading="" trailing="" raw_val="List.reverse_append" val="List.reverse_append" full_name="List.reverse_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(377, 77)" end="(377, 78)" leading="" trailing=" " val=","/>
                        <OtherNode start="(377, 79)" end="(377, 100)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(377, 79)" end="(377, 100)" leading="" trailing="" raw_val="List.dropWhile_append" val="List.dropWhile_append" full_name="List.dropWhile_append" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(377, 100)" end="(377, 101)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(378, 5)" end="(378, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(378, 5)" end="(378, 21)" leading="" trailing="" raw_val="List.isEmpty_iff" val="List.isEmpty_iff" full_name="List.isEmpty_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(378, 21)" end="(378, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(378, 23)" end="(378, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(378, 23)" end="(378, 43)" leading="" trailing="" raw_val="List.isEmpty_toArray" val="List.isEmpty_toArray" full_name="List.isEmpty_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(378, 43)" end="(378, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(378, 45)" end="(378, 65)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(378, 45)" end="(378, 65)" leading="" trailing="" raw_val="List.isEmpty_reverse" val="List.isEmpty_reverse" full_name="List.isEmpty_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(378, 65)" end="(378, 66)" leading="" trailing="&#10;  -- Why do these not fire with `simp`?&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(380, 3)" end="(380, 73)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if (List.dropWhile p ys.reverse).isEmpty = true then List.dropWhile p xs.reverse&#10;        else List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray =&#10;    if (popWhile p { toList := ys }).isEmpty = true then (List.dropWhile p xs.reverse).reverse.toArray&#10;    else (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if (List.dropWhile p ys.reverse).isEmpty = true then List.dropWhile p xs.reverse&#10;        else List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray =&#10;    if (List.dropWhile p ys.reverse).isEmpty = true then (List.dropWhile p xs.reverse).reverse.toArray&#10;    else (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" tactic="rw [List.popWhile_toArray, List.isEmpty_toArray, List.isEmpty_reverse]">
                    <AtomNode start="(380, 3)" end="(380, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(380, 6)" end="(380, 73)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(380, 6)" end="(380, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(380, 7)" end="(380, 72)">
                        <OtherNode start="(380, 7)" end="(380, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(380, 7)" end="(380, 28)" leading="" trailing="" raw_val="List.popWhile_toArray" val="List.popWhile_toArray" full_name="List.popWhile_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(380, 28)" end="(380, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(380, 30)" end="(380, 50)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(380, 30)" end="(380, 50)" leading="" trailing="" raw_val="List.isEmpty_toArray" val="List.isEmpty_toArray" full_name="List.isEmpty_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(380, 50)" end="(380, 51)" leading="" trailing=" " val=","/>
                        <OtherNode start="(380, 52)" end="(380, 72)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(380, 52)" end="(380, 72)" leading="" trailing="" raw_val="List.isEmpty_reverse" val="List.isEmpty_reverse" full_name="List.isEmpty_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(380, 72)" end="(380, 73)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(381, 3)" end="(381, 8)" kind="Lean.Parser.Tactic.split" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if (List.dropWhile p ys.reverse).isEmpty = true then List.dropWhile p xs.reverse&#10;        else List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray =&#10;    if (List.dropWhile p ys.reverse).isEmpty = true then (List.dropWhile p xs.reverse).reverse.toArray&#10;    else (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" state_after="case mk.mk.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : (List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p xs.reverse).reverse.toArray = (List.dropWhile p xs.reverse).reverse.toArray&#10;&#10;case mk.mk.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : ¬(List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray = (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" tactic="split">
                    <AtomNode start="(381, 3)" end="(381, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(382, 3)" end="(382, 8)" kind="Lean.cdot" state_before="case mk.mk.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : (List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p xs.reverse).reverse.toArray = (List.dropWhile p xs.reverse).reverse.toArray&#10;&#10;case mk.mk.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : ¬(List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray = (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" state_after="case mk.mk.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : ¬(List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray = (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" tactic="· rfl">
                    <OtherNode start="(382, 3)" end="(382, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(382, 3)" end="(382, 4)" kind="patternIgnore">
                        <OtherNode start="(382, 3)" end="(382, 4)" kind="token.«· »">
                          <AtomNode start="(382, 3)" end="(382, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(382, 5)" end="(382, 8)">
                      <TacticTacticseq1IndentedNode start="(382, 5)" end="(382, 8)">
                        <NullNode start="(382, 5)" end="(382, 8)">
                          <OtherNode start="(382, 5)" end="(382, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case mk.mk.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : (List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p xs.reverse).reverse.toArray = (List.dropWhile p xs.reverse).reverse.toArray" state_after="no goals" tactic="rfl">
                            <AtomNode start="(382, 5)" end="(382, 8)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(383, 3)" end="(383, 9)" kind="Lean.cdot" state_before="case mk.mk.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : ¬(List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray = (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" state_after="no goals" tactic="· simp">
                    <OtherNode start="(383, 3)" end="(383, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(383, 3)" end="(383, 4)" kind="patternIgnore">
                        <OtherNode start="(383, 3)" end="(383, 4)" kind="token.«· »">
                          <AtomNode start="(383, 3)" end="(383, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(383, 5)" end="(383, 9)">
                      <TacticTacticseq1IndentedNode start="(383, 5)" end="(383, 9)">
                        <NullNode start="(383, 5)" end="(383, 9)">
                          <OtherNode start="(383, 5)" end="(383, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h✝ : ¬(List.dropWhile p ys.reverse).isEmpty = true&#10;⊢ (List.dropWhile p ys.reverse ++ xs.reverse).reverse.toArray = (xs ++ (List.dropWhile p ys.reverse).reverse).toArray" state_after="no goals" tactic="simp">
                            <AtomNode start="(383, 5)" end="(383, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(385, 1)" end="(393, 8)" name="popWhile_append_of_pos" full_name="Array.popWhile_append_of_pos">
      <CommandDeclmodifiersNode start="(385, 1)" end="(385, 8)">
        <NullNode/>
        <NullNode start="(385, 1)" end="(385, 8)">
          <OtherNode start="(385, 1)" end="(385, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(385, 1)" end="(385, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(385, 3)" end="(385, 7)">
              <OtherNode start="(385, 3)" end="(385, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(385, 3)" end="(385, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(385, 3)" end="(385, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(385, 7)" end="(385, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(385, 9)" end="(393, 8)" name="popWhile_append_of_pos" full_name="Array.popWhile_append_of_pos" _is_private_decl="False">
        <AtomNode start="(385, 9)" end="(385, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(385, 17)" end="(385, 39)">
          <IdentNode start="(385, 17)" end="(385, 39)" leading="" trailing=" " raw_val="popWhile_append_of_pos" val="popWhile_append_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(385, 40)" end="(386, 42)">
          <NullNode start="(385, 40)" end="(385, 92)">
            <OtherNode start="(385, 40)" end="(385, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 40)" end="(385, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 41)" end="(385, 42)">
                <IdentNode start="(385, 41)" end="(385, 42)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(385, 43)" end="(385, 53)">
                <AtomNode start="(385, 43)" end="(385, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 45)" end="(385, 53)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(385, 45)" end="(385, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(385, 47)" end="(385, 48)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(385, 49)" end="(385, 53)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(385, 53)" end="(385, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(385, 55)" end="(385, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 55)" end="(385, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 56)" end="(385, 61)">
                <IdentNode start="(385, 56)" end="(385, 58)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(385, 59)" end="(385, 61)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(385, 62)" end="(385, 71)">
                <AtomNode start="(385, 62)" end="(385, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 64)" end="(385, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(385, 64)" end="(385, 69)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(385, 70)" end="(385, 71)">
                    <IdentNode start="(385, 70)" end="(385, 71)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(385, 71)" end="(385, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(385, 73)" end="(385, 92)">
              <AtomNode start="(385, 73)" end="(385, 74)" leading="" trailing="" val="("/>
              <NullNode start="(385, 74)" end="(385, 75)">
                <IdentNode start="(385, 74)" end="(385, 75)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(385, 76)" end="(385, 91)">
                <AtomNode start="(385, 76)" end="(385, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 78)" end="(385, 91)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(385, 78)" end="(385, 79)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(385, 80)" end="(385, 81)">
                    <IdentNode start="(385, 80)" end="(385, 81)" leading="" trailing=" " raw_val="a" val="a"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(385, 82)" end="(385, 86)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(385, 82)" end="(385, 83)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(385, 84)" end="(385, 86)" leading="" trailing="" raw_val="ys" val="ys"/>
                  </OtherNode>
                  <AtomNode start="(385, 86)" end="(385, 87)" leading="" trailing=" " val=","/>
                  <OtherNode start="(385, 88)" end="(385, 91)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(385, 88)" end="(385, 89)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(385, 90)" end="(385, 91)">
                      <IdentNode start="(385, 90)" end="(385, 91)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(385, 91)" end="(385, 92)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(385, 93)" end="(386, 42)">
            <AtomNode start="(385, 93)" end="(385, 94)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(386, 5)" end="(386, 42)" kind="«term_=_»">
              <OtherNode start="(386, 5)" end="(386, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(386, 5)" end="(386, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(386, 5)" end="(386, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(386, 5)" end="(386, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(386, 6)" end="(386, 14)" kind="«term_++_»">
                      <IdentNode start="(386, 6)" end="(386, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(386, 9)" end="(386, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(386, 12)" end="(386, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(386, 14)" end="(386, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(386, 15)" end="(386, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(386, 16)" end="(386, 24)" leading="" trailing=" " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(386, 25)" end="(386, 26)">
                  <IdentNode start="(386, 25)" end="(386, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(386, 27)" end="(386, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(386, 29)" end="(386, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(386, 29)" end="(386, 40)" leading="" trailing=" " raw_val="xs.popWhile" val="xs.popWhile"/>
                <NullNode start="(386, 41)" end="(386, 42)">
                  <IdentNode start="(386, 41)" end="(386, 42)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(386, 43)" end="(393, 8)">
          <AtomNode start="(386, 43)" end="(386, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(386, 46)" end="(393, 8)">
            <AtomNode start="(386, 46)" end="(386, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(387, 3)" end="(393, 8)">
              <TacticTacticseq1IndentedNode start="(387, 3)" end="(393, 8)">
                <NullNode start="(387, 3)" end="(393, 8)">
                  <OtherNode start="(387, 3)" end="(387, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;⊢ popWhile p (xs ++ ys) = popWhile p xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;xs : List α&#10;⊢ popWhile p ({ toList := xs } ++ ys) = popWhile p { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(387, 3)" end="(387, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(387, 10)" end="(387, 12)">
                      <OtherNode start="(387, 10)" end="(387, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(387, 10)" end="(387, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(387, 13)" end="(387, 22)">
                      <AtomNode start="(387, 13)" end="(387, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(387, 18)" end="(387, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(387, 18)" end="(387, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(387, 18)" end="(387, 22)">
                            <OtherNode start="(387, 18)" end="(387, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(387, 18)" end="(387, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(387, 19)" end="(387, 21)">
                                <OtherNode start="(387, 19)" end="(387, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(387, 19)" end="(387, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(387, 19)" end="(387, 21)">
                                      <OtherNode start="(387, 19)" end="(387, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(387, 19)" end="(387, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(387, 21)" end="(387, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(388, 3)" end="(388, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;xs : List α&#10;⊢ popWhile p ({ toList := xs } ++ ys) = popWhile p { toList := xs }" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ { toList := ys } → p a = true&#10;⊢ popWhile p ({ toList := xs } ++ { toList := ys }) = popWhile p { toList := xs }" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(388, 3)" end="(388, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(388, 10)" end="(388, 12)">
                      <OtherNode start="(388, 10)" end="(388, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(388, 10)" end="(388, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(388, 13)" end="(388, 22)">
                      <AtomNode start="(388, 13)" end="(388, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(388, 18)" end="(388, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(388, 18)" end="(388, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(388, 18)" end="(388, 22)">
                            <OtherNode start="(388, 18)" end="(388, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(388, 18)" end="(388, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(388, 19)" end="(388, 21)">
                                <OtherNode start="(388, 19)" end="(388, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(388, 19)" end="(388, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(388, 19)" end="(388, 21)">
                                      <OtherNode start="(388, 19)" end="(388, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(388, 19)" end="(388, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(388, 21)" end="(388, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(389, 3)" end="(389, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ { toList := ys } → p a = true&#10;⊢ popWhile p ({ toList := xs } ++ { toList := ys }) = popWhile p { toList := xs }" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;⊢ popWhile p ({ toList := xs } ++ { toList := ys }) = popWhile p { toList := xs }" tactic="simp at h">
                    <AtomNode start="(389, 3)" end="(389, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(389, 8)" end="(389, 12)">
                      <OtherNode start="(389, 8)" end="(389, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(389, 8)" end="(389, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(389, 11)" end="(389, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(389, 11)" end="(389, 12)">
                            <IdentNode start="(389, 11)" end="(389, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(390, 3)" end="(391, 22)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;⊢ popWhile p ({ toList := xs } ++ { toList := ys }) = popWhile p { toList := xs }" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;⊢ List.dropWhile p (ys.reverse ++ xs.reverse) = List.dropWhile p xs.reverse" tactic="simp only [List.append_toArray, List.popWhile_toArray, List.reverse_append, mk.injEq,&#10;  List.reverse_inj]">
                    <AtomNode start="(390, 3)" end="(390, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(390, 8)" end="(390, 12)">
                      <AtomNode start="(390, 8)" end="(390, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(390, 13)" end="(391, 22)">
                      <AtomNode start="(390, 13)" end="(390, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(390, 14)" end="(391, 21)">
                        <OtherNode start="(390, 14)" end="(390, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(390, 14)" end="(390, 33)" leading="" trailing="" raw_val="List.append_toArray" val="List.append_toArray" full_name="List.append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(390, 33)" end="(390, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(390, 35)" end="(390, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(390, 35)" end="(390, 56)" leading="" trailing="" raw_val="List.popWhile_toArray" val="List.popWhile_toArray" full_name="List.popWhile_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(390, 56)" end="(390, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(390, 58)" end="(390, 77)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(390, 58)" end="(390, 77)" leading="" trailing="" raw_val="List.reverse_append" val="List.reverse_append" full_name="List.reverse_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(390, 77)" end="(390, 78)" leading="" trailing=" " val=","/>
                        <OtherNode start="(390, 79)" end="(390, 87)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(390, 79)" end="(390, 87)" leading="" trailing="" raw_val="mk.injEq" val="mk.injEq" full_name="Array.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(390, 87)" end="(390, 88)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(391, 5)" end="(391, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(391, 5)" end="(391, 21)" leading="" trailing="" raw_val="List.reverse_inj" val="List.reverse_inj" full_name="List.reverse_inj" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(391, 21)" end="(391, 22)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(392, 3)" end="(392, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;⊢ List.dropWhile p (ys.reverse ++ xs.reverse) = List.dropWhile p xs.reverse" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;⊢ ∀ (a : α), a ∈ ys.reverse → p a = true" tactic="rw [List.dropWhile_append_of_pos]">
                    <AtomNode start="(392, 3)" end="(392, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(392, 6)" end="(392, 36)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(392, 6)" end="(392, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(392, 7)" end="(392, 35)">
                        <OtherNode start="(392, 7)" end="(392, 35)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(392, 7)" end="(392, 35)" leading="" trailing="" raw_val="List.dropWhile_append_of_pos" val="List.dropWhile_append_of_pos" full_name="List.dropWhile_append_of_pos" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(392, 35)" end="(392, 36)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(393, 3)" end="(393, 8)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;h : ∀ (a : α), a ∈ ys → p a = true&#10;⊢ ∀ (a : α), a ∈ ys.reverse → p a = true" state_after="no goals" tactic="simpa">
                    <AtomNode start="(393, 3)" end="(393, 8)" leading="" trailing="&#10;&#10;" val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(395, 1)" end="(397, 34)" name="takeWhile_replicate_eq_filter" full_name="Array.takeWhile_replicate_eq_filter">
      <CommandDeclmodifiersNode start="(395, 1)" end="(395, 8)">
        <NullNode/>
        <NullNode start="(395, 1)" end="(395, 8)">
          <OtherNode start="(395, 1)" end="(395, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(395, 1)" end="(395, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(395, 3)" end="(395, 7)">
              <OtherNode start="(395, 3)" end="(395, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(395, 3)" end="(395, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(395, 3)" end="(395, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(395, 7)" end="(395, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(395, 9)" end="(397, 34)" name="takeWhile_replicate_eq_filter" full_name="Array.takeWhile_replicate_eq_filter" _is_private_decl="False">
        <AtomNode start="(395, 9)" end="(395, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(395, 17)" end="(395, 46)">
          <IdentNode start="(395, 17)" end="(395, 46)" leading="" trailing=" " raw_val="takeWhile_replicate_eq_filter" val="takeWhile_replicate_eq_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(395, 47)" end="(396, 59)">
          <NullNode start="(395, 47)" end="(395, 61)">
            <OtherNode start="(395, 47)" end="(395, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 47)" end="(395, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 48)" end="(395, 49)">
                <IdentNode start="(395, 48)" end="(395, 49)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(395, 50)" end="(395, 60)">
                <AtomNode start="(395, 50)" end="(395, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(395, 52)" end="(395, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(395, 52)" end="(395, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(395, 54)" end="(395, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(395, 56)" end="(395, 60)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(395, 60)" end="(395, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(395, 62)" end="(396, 59)">
            <AtomNode start="(395, 62)" end="(395, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(396, 5)" end="(396, 59)" kind="«term_=_»">
              <OtherNode start="(396, 5)" end="(396, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(396, 5)" end="(396, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(396, 5)" end="(396, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(396, 5)" end="(396, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(396, 6)" end="(396, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(396, 6)" end="(396, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(396, 16)" end="(396, 19)">
                        <IdentNode start="(396, 16)" end="(396, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(396, 18)" end="(396, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(396, 19)" end="(396, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(396, 20)" end="(396, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(396, 21)" end="(396, 30)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(396, 31)" end="(396, 32)">
                  <IdentNode start="(396, 31)" end="(396, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(396, 33)" end="(396, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(396, 35)" end="(396, 59)" kind="Lean.Parser.Term.app">
                <OtherNode start="(396, 35)" end="(396, 57)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(396, 35)" end="(396, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(396, 35)" end="(396, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(396, 36)" end="(396, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(396, 36)" end="(396, 45)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(396, 46)" end="(396, 49)">
                        <IdentNode start="(396, 46)" end="(396, 47)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(396, 48)" end="(396, 49)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(396, 49)" end="(396, 50)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(396, 50)" end="(396, 51)" leading="" trailing="" val="."/>
                  <IdentNode start="(396, 51)" end="(396, 57)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(396, 58)" end="(396, 59)">
                  <IdentNode start="(396, 58)" end="(396, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(396, 60)" end="(397, 34)">
          <AtomNode start="(396, 60)" end="(396, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(396, 63)" end="(397, 34)">
            <AtomNode start="(396, 63)" end="(396, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(397, 3)" end="(397, 34)">
              <TacticTacticseq1IndentedNode start="(397, 3)" end="(397, 34)">
                <NullNode start="(397, 3)" end="(397, 34)">
                  <OtherNode start="(397, 3)" end="(397, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ takeWhile p (replicate n a) = filter p (replicate n a)" state_after="no goals" tactic="simp [← List.toArray_replicate]">
                    <AtomNode start="(397, 3)" end="(397, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(397, 8)" end="(397, 34)">
                      <AtomNode start="(397, 8)" end="(397, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(397, 9)" end="(397, 33)">
                        <OtherNode start="(397, 9)" end="(397, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(397, 9)" end="(397, 10)">
                            <OtherNode start="(397, 9)" end="(397, 10)" kind="patternIgnore">
                              <OtherNode start="(397, 9)" end="(397, 10)" kind="token.«← »">
                                <AtomNode start="(397, 9)" end="(397, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(397, 11)" end="(397, 33)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(397, 33)" end="(397, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(399, 1)" end="(400, 69)" name="takeWhile_mkArray_eq_filter" full_name="Array.takeWhile_mkArray_eq_filter">
      <CommandDeclmodifiersNode start="(399, 1)" end="(399, 68)">
        <NullNode/>
        <NullNode start="(399, 1)" end="(399, 68)">
          <OtherNode start="(399, 1)" end="(399, 68)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(399, 1)" end="(399, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(399, 3)" end="(399, 67)">
              <OtherNode start="(399, 3)" end="(399, 67)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(399, 3)" end="(399, 67)" kind="Lean.deprecated">
                  <AtomNode start="(399, 3)" end="(399, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(399, 14)" end="(399, 43)">
                    <IdentNode start="(399, 14)" end="(399, 43)" leading="" trailing=" " raw_val="takeWhile_replicate_eq_filter" val="takeWhile_replicate_eq_filter" full_name="Array.takeWhile_replicate_eq_filter" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(395, 17)" def_end="(395, 46)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(399, 44)" end="(399, 67)">
                    <AtomNode start="(399, 44)" end="(399, 45)" leading="" trailing="" val="("/>
                    <AtomNode start="(399, 45)" end="(399, 50)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(399, 51)" end="(399, 53)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(399, 54)" end="(399, 66)" kind="str">
                      <AtomNode start="(399, 54)" end="(399, 66)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(399, 66)" end="(399, 67)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(399, 67)" end="(399, 68)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(400, 1)" end="(400, 69)" name="takeWhile_mkArray_eq_filter">
        <AtomNode start="(400, 1)" end="(400, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(400, 8)" end="(400, 35)">
          <IdentNode start="(400, 8)" end="(400, 35)" leading="" trailing=" " raw_val="takeWhile_mkArray_eq_filter" val="takeWhile_mkArray_eq_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(400, 36)" end="(400, 69)">
          <AtomNode start="(400, 36)" end="(400, 38)" leading="" trailing=" " val=":="/>
          <OtherNode start="(400, 39)" end="(400, 69)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(400, 39)" end="(400, 40)" leading="" trailing="" val="@"/>
            <IdentNode start="(400, 40)" end="(400, 69)" leading="" trailing="&#10;&#10;" raw_val="takeWhile_replicate_eq_filter" val="takeWhile_replicate_eq_filter" full_name="Array.takeWhile_replicate_eq_filter" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(395, 17)" def_end="(395, 46)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(402, 1)" end="(404, 57)" name="takeWhile_replicate" full_name="Array.takeWhile_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(402, 1)" end="(404, 57)" name="takeWhile_replicate" full_name="Array.takeWhile_replicate" _is_private_decl="False">
        <AtomNode start="(402, 1)" end="(402, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(402, 9)" end="(402, 28)">
          <IdentNode start="(402, 9)" end="(402, 28)" leading="" trailing=" " raw_val="takeWhile_replicate" val="takeWhile_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(402, 29)" end="(403, 69)">
          <NullNode start="(402, 29)" end="(402, 43)">
            <OtherNode start="(402, 29)" end="(402, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(402, 29)" end="(402, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(402, 30)" end="(402, 31)">
                <IdentNode start="(402, 30)" end="(402, 31)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(402, 32)" end="(402, 42)">
                <AtomNode start="(402, 32)" end="(402, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(402, 34)" end="(402, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(402, 34)" end="(402, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(402, 36)" end="(402, 37)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(402, 38)" end="(402, 42)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(402, 42)" end="(402, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(402, 44)" end="(403, 69)">
            <AtomNode start="(402, 44)" end="(402, 45)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(403, 5)" end="(403, 69)" kind="«term_=_»">
              <OtherNode start="(403, 5)" end="(403, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(403, 5)" end="(403, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(403, 5)" end="(403, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(403, 5)" end="(403, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(403, 6)" end="(403, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(403, 6)" end="(403, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(403, 16)" end="(403, 19)">
                        <IdentNode start="(403, 16)" end="(403, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(403, 18)" end="(403, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(403, 19)" end="(403, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(403, 20)" end="(403, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(403, 21)" end="(403, 30)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(403, 31)" end="(403, 32)">
                  <IdentNode start="(403, 31)" end="(403, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(403, 33)" end="(403, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(403, 35)" end="(403, 69)" kind="termIfThenElse">
                <AtomNode start="(403, 35)" end="(403, 37)" leading="" trailing=" " val="if"/>
                <OtherNode start="(403, 38)" end="(403, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(403, 38)" end="(403, 39)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(403, 40)" end="(403, 41)">
                    <IdentNode start="(403, 40)" end="(403, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(403, 42)" end="(403, 46)" leading="" trailing=" " val="then"/>
                <OtherNode start="(403, 47)" end="(403, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(403, 47)" end="(403, 56)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(403, 57)" end="(403, 60)">
                    <IdentNode start="(403, 57)" end="(403, 58)" leading="" trailing=" " raw_val="n" val="n"/>
                    <IdentNode start="(403, 59)" end="(403, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(403, 61)" end="(403, 65)" leading="" trailing=" " val="else"/>
                <OtherNode start="(403, 66)" end="(403, 69)" kind="«term#[_,]»">
                  <AtomNode start="(403, 66)" end="(403, 68)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(403, 68)" end="(403, 69)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(403, 70)" end="(404, 57)">
          <AtomNode start="(403, 70)" end="(403, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(403, 73)" end="(404, 57)">
            <AtomNode start="(403, 73)" end="(403, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(404, 3)" end="(404, 57)">
              <TacticTacticseq1IndentedNode start="(404, 3)" end="(404, 57)">
                <NullNode start="(404, 3)" end="(404, 57)">
                  <OtherNode start="(404, 3)" end="(404, 57)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ takeWhile p (replicate n a) = if p a = true then replicate n a else #[]" state_after="no goals" tactic="simp [takeWhile_replicate_eq_filter, filter_replicate]">
                    <AtomNode start="(404, 3)" end="(404, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(404, 8)" end="(404, 57)">
                      <AtomNode start="(404, 8)" end="(404, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(404, 9)" end="(404, 56)">
                        <OtherNode start="(404, 9)" end="(404, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(404, 9)" end="(404, 38)" leading="" trailing="" raw_val="takeWhile_replicate_eq_filter" val="takeWhile_replicate_eq_filter" full_name="Array.takeWhile_replicate_eq_filter" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(395, 17)" def_end="(395, 46)"/>
                        </OtherNode>
                        <AtomNode start="(404, 38)" end="(404, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(404, 40)" end="(404, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(404, 40)" end="(404, 56)" leading="" trailing="" raw_val="filter_replicate" val="filter_replicate" full_name="Array.filter_replicate" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(404, 56)" end="(404, 57)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(406, 1)" end="(407, 49)" name="takeWhile_mkArray" full_name="Array.takeWhile_mkArray">
      <CommandDeclmodifiersNode start="(406, 1)" end="(406, 58)">
        <NullNode/>
        <NullNode start="(406, 1)" end="(406, 58)">
          <OtherNode start="(406, 1)" end="(406, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(406, 1)" end="(406, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(406, 3)" end="(406, 57)">
              <OtherNode start="(406, 3)" end="(406, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(406, 3)" end="(406, 57)" kind="Lean.deprecated">
                  <AtomNode start="(406, 3)" end="(406, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(406, 14)" end="(406, 33)">
                    <IdentNode start="(406, 14)" end="(406, 33)" leading="" trailing=" " raw_val="takeWhile_replicate" val="takeWhile_replicate" full_name="Array.takeWhile_replicate" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(402, 9)" def_end="(402, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(406, 34)" end="(406, 57)">
                    <AtomNode start="(406, 34)" end="(406, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(406, 35)" end="(406, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(406, 41)" end="(406, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(406, 44)" end="(406, 56)" kind="str">
                      <AtomNode start="(406, 44)" end="(406, 56)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(406, 56)" end="(406, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(406, 57)" end="(406, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(407, 1)" end="(407, 49)" name="takeWhile_mkArray">
        <AtomNode start="(407, 1)" end="(407, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(407, 8)" end="(407, 25)">
          <IdentNode start="(407, 8)" end="(407, 25)" leading="" trailing=" " raw_val="takeWhile_mkArray" val="takeWhile_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(407, 26)" end="(407, 49)">
          <AtomNode start="(407, 26)" end="(407, 28)" leading="" trailing=" " val=":="/>
          <OtherNode start="(407, 29)" end="(407, 49)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(407, 29)" end="(407, 30)" leading="" trailing="" val="@"/>
            <IdentNode start="(407, 30)" end="(407, 49)" leading="" trailing="&#10;&#10;" raw_val="takeWhile_replicate" val="takeWhile_replicate" full_name="Array.takeWhile_replicate" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(402, 9)" def_end="(402, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(409, 1)" end="(411, 57)" name="popWhile_replicate_eq_filter_not" full_name="Array.popWhile_replicate_eq_filter_not">
      <CommandDeclmodifiersNode start="(409, 1)" end="(409, 8)">
        <NullNode/>
        <NullNode start="(409, 1)" end="(409, 8)">
          <OtherNode start="(409, 1)" end="(409, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(409, 1)" end="(409, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(409, 3)" end="(409, 7)">
              <OtherNode start="(409, 3)" end="(409, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(409, 3)" end="(409, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(409, 3)" end="(409, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(409, 7)" end="(409, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(409, 9)" end="(411, 57)" name="popWhile_replicate_eq_filter_not" full_name="Array.popWhile_replicate_eq_filter_not" _is_private_decl="False">
        <AtomNode start="(409, 9)" end="(409, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(409, 17)" end="(409, 49)">
          <IdentNode start="(409, 17)" end="(409, 49)" leading="" trailing=" " raw_val="popWhile_replicate_eq_filter_not" val="popWhile_replicate_eq_filter_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(409, 50)" end="(410, 72)">
          <NullNode start="(409, 50)" end="(409, 64)">
            <OtherNode start="(409, 50)" end="(409, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(409, 50)" end="(409, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(409, 51)" end="(409, 52)">
                <IdentNode start="(409, 51)" end="(409, 52)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(409, 53)" end="(409, 63)">
                <AtomNode start="(409, 53)" end="(409, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 55)" end="(409, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(409, 55)" end="(409, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(409, 57)" end="(409, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(409, 59)" end="(409, 63)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(409, 63)" end="(409, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(409, 65)" end="(410, 72)">
            <AtomNode start="(409, 65)" end="(409, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(410, 5)" end="(410, 72)" kind="«term_=_»">
              <OtherNode start="(410, 5)" end="(410, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(410, 5)" end="(410, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(410, 5)" end="(410, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(410, 5)" end="(410, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(410, 6)" end="(410, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(410, 6)" end="(410, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(410, 16)" end="(410, 19)">
                        <IdentNode start="(410, 16)" end="(410, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(410, 18)" end="(410, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(410, 19)" end="(410, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(410, 20)" end="(410, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(410, 21)" end="(410, 29)" leading="" trailing=" " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(410, 30)" end="(410, 31)">
                  <IdentNode start="(410, 30)" end="(410, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(410, 32)" end="(410, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(410, 34)" end="(410, 72)" kind="Lean.Parser.Term.app">
                <OtherNode start="(410, 34)" end="(410, 56)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(410, 34)" end="(410, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(410, 34)" end="(410, 35)" leading="" trailing="" val="("/>
                    <OtherNode start="(410, 35)" end="(410, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(410, 35)" end="(410, 44)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(410, 45)" end="(410, 48)">
                        <IdentNode start="(410, 45)" end="(410, 46)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(410, 47)" end="(410, 48)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(410, 48)" end="(410, 49)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(410, 49)" end="(410, 50)" leading="" trailing="" val="."/>
                  <IdentNode start="(410, 50)" end="(410, 56)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(410, 57)" end="(410, 72)">
                  <OtherNode start="(410, 57)" end="(410, 72)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(410, 57)" end="(410, 58)" leading="" trailing="" val="("/>
                    <OtherNode start="(410, 58)" end="(410, 71)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(410, 58)" end="(410, 61)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(410, 62)" end="(410, 71)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(410, 62)" end="(410, 63)">
                          <IdentNode start="(410, 62)" end="(410, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(410, 64)" end="(410, 66)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(410, 67)" end="(410, 71)" kind="term!_">
                          <AtomNode start="(410, 67)" end="(410, 68)" leading="" trailing="" val="!"/>
                          <OtherNode start="(410, 68)" end="(410, 71)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(410, 68)" end="(410, 69)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(410, 70)" end="(410, 71)">
                              <IdentNode start="(410, 70)" end="(410, 71)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(410, 71)" end="(410, 72)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(410, 73)" end="(411, 57)">
          <AtomNode start="(410, 73)" end="(410, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(410, 76)" end="(411, 57)">
            <AtomNode start="(410, 76)" end="(410, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(411, 3)" end="(411, 57)">
              <TacticTacticseq1IndentedNode start="(411, 3)" end="(411, 57)">
                <NullNode start="(411, 3)" end="(411, 57)">
                  <OtherNode start="(411, 3)" end="(411, 57)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ popWhile p (replicate n a) = filter (fun a =&amp;gt; !p a) (replicate n a)" state_after="no goals" tactic="simp [← List.toArray_replicate, ← List.filter_reverse]">
                    <AtomNode start="(411, 3)" end="(411, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(411, 8)" end="(411, 57)">
                      <AtomNode start="(411, 8)" end="(411, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(411, 9)" end="(411, 56)">
                        <OtherNode start="(411, 9)" end="(411, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(411, 9)" end="(411, 10)">
                            <OtherNode start="(411, 9)" end="(411, 10)" kind="patternIgnore">
                              <OtherNode start="(411, 9)" end="(411, 10)" kind="token.«← »">
                                <AtomNode start="(411, 9)" end="(411, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(411, 11)" end="(411, 33)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(411, 33)" end="(411, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(411, 35)" end="(411, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(411, 35)" end="(411, 36)">
                            <OtherNode start="(411, 35)" end="(411, 36)" kind="patternIgnore">
                              <OtherNode start="(411, 35)" end="(411, 36)" kind="token.«← »">
                                <AtomNode start="(411, 35)" end="(411, 36)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(411, 37)" end="(411, 56)" leading="" trailing="" raw_val="List.filter_reverse" val="List.filter_reverse" full_name="List.filter_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(411, 56)" end="(411, 57)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(413, 1)" end="(414, 75)" name="popWhile_mkArray_eq_filter_not" full_name="Array.popWhile_mkArray_eq_filter_not">
      <CommandDeclmodifiersNode start="(413, 1)" end="(413, 71)">
        <NullNode/>
        <NullNode start="(413, 1)" end="(413, 71)">
          <OtherNode start="(413, 1)" end="(413, 71)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(413, 1)" end="(413, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(413, 3)" end="(413, 70)">
              <OtherNode start="(413, 3)" end="(413, 70)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(413, 3)" end="(413, 70)" kind="Lean.deprecated">
                  <AtomNode start="(413, 3)" end="(413, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(413, 14)" end="(413, 46)">
                    <IdentNode start="(413, 14)" end="(413, 46)" leading="" trailing=" " raw_val="popWhile_replicate_eq_filter_not" val="popWhile_replicate_eq_filter_not" full_name="Array.popWhile_replicate_eq_filter_not" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(409, 17)" def_end="(409, 49)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(413, 47)" end="(413, 70)">
                    <AtomNode start="(413, 47)" end="(413, 48)" leading="" trailing="" val="("/>
                    <AtomNode start="(413, 48)" end="(413, 53)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(413, 54)" end="(413, 56)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(413, 57)" end="(413, 69)" kind="str">
                      <AtomNode start="(413, 57)" end="(413, 69)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(413, 69)" end="(413, 70)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(413, 70)" end="(413, 71)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(414, 1)" end="(414, 75)" name="popWhile_mkArray_eq_filter_not">
        <AtomNode start="(414, 1)" end="(414, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(414, 8)" end="(414, 38)">
          <IdentNode start="(414, 8)" end="(414, 38)" leading="" trailing=" " raw_val="popWhile_mkArray_eq_filter_not" val="popWhile_mkArray_eq_filter_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(414, 39)" end="(414, 75)">
          <AtomNode start="(414, 39)" end="(414, 41)" leading="" trailing=" " val=":="/>
          <OtherNode start="(414, 42)" end="(414, 75)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(414, 42)" end="(414, 43)" leading="" trailing="" val="@"/>
            <IdentNode start="(414, 43)" end="(414, 75)" leading="" trailing="&#10;&#10;" raw_val="popWhile_replicate_eq_filter_not" val="popWhile_replicate_eq_filter_not" full_name="Array.popWhile_replicate_eq_filter_not" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(409, 17)" def_end="(409, 49)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(416, 1)" end="(420, 21)" name="popWhile_replicate" full_name="Array.popWhile_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(416, 1)" end="(420, 21)" name="popWhile_replicate" full_name="Array.popWhile_replicate" _is_private_decl="False">
        <AtomNode start="(416, 1)" end="(416, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(416, 9)" end="(416, 27)">
          <IdentNode start="(416, 9)" end="(416, 27)" leading="" trailing=" " raw_val="popWhile_replicate" val="popWhile_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(416, 28)" end="(417, 68)">
          <NullNode start="(416, 28)" end="(416, 42)">
            <OtherNode start="(416, 28)" end="(416, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(416, 28)" end="(416, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(416, 29)" end="(416, 30)">
                <IdentNode start="(416, 29)" end="(416, 30)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(416, 31)" end="(416, 41)">
                <AtomNode start="(416, 31)" end="(416, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(416, 33)" end="(416, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(416, 33)" end="(416, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(416, 35)" end="(416, 36)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(416, 37)" end="(416, 41)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(416, 41)" end="(416, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(416, 43)" end="(417, 68)">
            <AtomNode start="(416, 43)" end="(416, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(417, 5)" end="(417, 68)" kind="«term_=_»">
              <OtherNode start="(417, 5)" end="(417, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(417, 5)" end="(417, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(417, 5)" end="(417, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(417, 5)" end="(417, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(417, 6)" end="(417, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(417, 6)" end="(417, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(417, 16)" end="(417, 19)">
                        <IdentNode start="(417, 16)" end="(417, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(417, 18)" end="(417, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(417, 19)" end="(417, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(417, 20)" end="(417, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(417, 21)" end="(417, 29)" leading="" trailing=" " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(417, 30)" end="(417, 31)">
                  <IdentNode start="(417, 30)" end="(417, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(417, 32)" end="(417, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(417, 34)" end="(417, 68)" kind="termIfThenElse">
                <AtomNode start="(417, 34)" end="(417, 36)" leading="" trailing=" " val="if"/>
                <OtherNode start="(417, 37)" end="(417, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(417, 37)" end="(417, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(417, 39)" end="(417, 40)">
                    <IdentNode start="(417, 39)" end="(417, 40)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(417, 41)" end="(417, 45)" leading="" trailing=" " val="then"/>
                <OtherNode start="(417, 46)" end="(417, 49)" kind="«term#[_,]»">
                  <AtomNode start="(417, 46)" end="(417, 48)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(417, 48)" end="(417, 49)" leading="" trailing=" " val="]"/>
                </OtherNode>
                <AtomNode start="(417, 50)" end="(417, 54)" leading="" trailing=" " val="else"/>
                <OtherNode start="(417, 55)" end="(417, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(417, 55)" end="(417, 64)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(417, 65)" end="(417, 68)">
                    <IdentNode start="(417, 65)" end="(417, 66)" leading="" trailing=" " raw_val="n" val="n"/>
                    <IdentNode start="(417, 67)" end="(417, 68)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(417, 69)" end="(420, 21)">
          <AtomNode start="(417, 69)" end="(417, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(417, 72)" end="(420, 21)">
            <AtomNode start="(417, 72)" end="(417, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(418, 3)" end="(420, 21)">
              <TacticTacticseq1IndentedNode start="(418, 3)" end="(420, 21)">
                <NullNode start="(418, 3)" end="(420, 21)">
                  <OtherNode start="(418, 3)" end="(419, 19)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ popWhile p (replicate n a) = if p a = true then #[] else replicate n a" state_after="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ (if p a = false then replicate n a else #[]) = if p a = true then #[] else replicate n a" tactic="simp only [popWhile_replicate_eq_filter_not, size_replicate, filter_replicate, Bool.not_eq_eq_eq_not,&#10;  Bool.not_true]">
                    <AtomNode start="(418, 3)" end="(418, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(418, 8)" end="(418, 12)">
                      <AtomNode start="(418, 8)" end="(418, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(418, 13)" end="(419, 19)">
                      <AtomNode start="(418, 13)" end="(418, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(418, 14)" end="(419, 18)">
                        <OtherNode start="(418, 14)" end="(418, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(418, 14)" end="(418, 46)" leading="" trailing="" raw_val="popWhile_replicate_eq_filter_not" val="popWhile_replicate_eq_filter_not" full_name="Array.popWhile_replicate_eq_filter_not" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(409, 17)" def_end="(409, 49)"/>
                        </OtherNode>
                        <AtomNode start="(418, 46)" end="(418, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(418, 48)" end="(418, 62)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(418, 48)" end="(418, 62)" leading="" trailing="" raw_val="size_replicate" val="size_replicate" full_name="Array.size_replicate" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(418, 62)" end="(418, 63)" leading="" trailing=" " val=","/>
                        <OtherNode start="(418, 64)" end="(418, 80)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(418, 64)" end="(418, 80)" leading="" trailing="" raw_val="filter_replicate" val="filter_replicate" full_name="Array.filter_replicate" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(418, 80)" end="(418, 81)" leading="" trailing=" " val=","/>
                        <OtherNode start="(418, 82)" end="(418, 103)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(418, 82)" end="(418, 103)" leading="" trailing="" raw_val="Bool.not_eq_eq_eq_not" val="Bool.not_eq_eq_eq_not" full_name="Bool.not_eq_eq_eq_not" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(418, 103)" end="(418, 104)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(419, 5)" end="(419, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(419, 5)" end="(419, 18)" leading="" trailing="" raw_val="Bool.not_true" val="Bool.not_true" full_name="Bool.not_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(419, 18)" end="(419, 19)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(420, 3)" end="(420, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ (if p a = false then replicate n a else #[]) = if p a = true then #[] else replicate n a" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(420, 3)" end="(420, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(420, 3)" end="(420, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(420, 9)" end="(420, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(420, 13)" end="(420, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(420, 13)" end="(420, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(422, 1)" end="(423, 47)" name="popWhile_mkArray" full_name="Array.popWhile_mkArray">
      <CommandDeclmodifiersNode start="(422, 1)" end="(422, 57)">
        <NullNode/>
        <NullNode start="(422, 1)" end="(422, 57)">
          <OtherNode start="(422, 1)" end="(422, 57)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(422, 1)" end="(422, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(422, 3)" end="(422, 56)">
              <OtherNode start="(422, 3)" end="(422, 56)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(422, 3)" end="(422, 56)" kind="Lean.deprecated">
                  <AtomNode start="(422, 3)" end="(422, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(422, 14)" end="(422, 32)">
                    <IdentNode start="(422, 14)" end="(422, 32)" leading="" trailing=" " raw_val="popWhile_replicate" val="popWhile_replicate" full_name="Array.popWhile_replicate" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(416, 9)" def_end="(416, 27)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(422, 33)" end="(422, 56)">
                    <AtomNode start="(422, 33)" end="(422, 34)" leading="" trailing="" val="("/>
                    <AtomNode start="(422, 34)" end="(422, 39)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(422, 40)" end="(422, 42)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(422, 43)" end="(422, 55)" kind="str">
                      <AtomNode start="(422, 43)" end="(422, 55)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(422, 55)" end="(422, 56)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(422, 56)" end="(422, 57)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(423, 1)" end="(423, 47)" name="popWhile_mkArray">
        <AtomNode start="(423, 1)" end="(423, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(423, 8)" end="(423, 24)">
          <IdentNode start="(423, 8)" end="(423, 24)" leading="" trailing=" " raw_val="popWhile_mkArray" val="popWhile_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(423, 25)" end="(423, 47)">
          <AtomNode start="(423, 25)" end="(423, 27)" leading="" trailing=" " val=":="/>
          <OtherNode start="(423, 28)" end="(423, 47)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(423, 28)" end="(423, 29)" leading="" trailing="" val="@"/>
            <IdentNode start="(423, 29)" end="(423, 47)" leading="" trailing="&#10;&#10;" raw_val="popWhile_replicate" val="popWhile_replicate" full_name="Array.popWhile_replicate" mod_name="Init.Data.Array.Extract" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Extract.lean" def_start="(416, 9)" def_end="(416, 27)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(425, 1)" end="(428, 29)" name="extract_takeWhile" full_name="Array.extract_takeWhile">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(425, 1)" end="(428, 29)" name="extract_takeWhile" full_name="Array.extract_takeWhile" _is_private_decl="False">
        <AtomNode start="(425, 1)" end="(425, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(425, 9)" end="(425, 26)">
          <IdentNode start="(425, 9)" end="(425, 26)" leading="" trailing=" " raw_val="extract_takeWhile" val="extract_takeWhile"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(425, 27)" end="(426, 64)">
          <NullNode start="(425, 27)" end="(425, 51)">
            <OtherNode start="(425, 27)" end="(425, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(425, 27)" end="(425, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(425, 28)" end="(425, 30)">
                <IdentNode start="(425, 28)" end="(425, 30)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(425, 31)" end="(425, 40)">
                <AtomNode start="(425, 31)" end="(425, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(425, 33)" end="(425, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(425, 33)" end="(425, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(425, 39)" end="(425, 40)">
                    <IdentNode start="(425, 39)" end="(425, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(425, 40)" end="(425, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(425, 42)" end="(425, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(425, 42)" end="(425, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(425, 43)" end="(425, 44)">
                <IdentNode start="(425, 43)" end="(425, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(425, 45)" end="(425, 50)">
                <AtomNode start="(425, 45)" end="(425, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(425, 47)" end="(425, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(425, 50)" end="(425, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(425, 52)" end="(426, 64)">
            <AtomNode start="(425, 52)" end="(425, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(426, 5)" end="(426, 64)" kind="«term_=_»">
              <OtherNode start="(426, 5)" end="(426, 33)" kind="Lean.Parser.Term.app">
                <OtherNode start="(426, 5)" end="(426, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(426, 5)" end="(426, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(426, 5)" end="(426, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(426, 6)" end="(426, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(426, 6)" end="(426, 18)" leading="" trailing=" " raw_val="as.takeWhile" val="as.takeWhile"/>
                      <NullNode start="(426, 19)" end="(426, 20)">
                        <IdentNode start="(426, 19)" end="(426, 20)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(426, 20)" end="(426, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(426, 21)" end="(426, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(426, 22)" end="(426, 29)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Array.extract" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(426, 30)" end="(426, 33)">
                  <OtherNode start="(426, 30)" end="(426, 31)" kind="num">
                    <AtomNode start="(426, 30)" end="(426, 31)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(426, 32)" end="(426, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(426, 34)" end="(426, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(426, 36)" end="(426, 64)" kind="Lean.Parser.Term.app">
                <OtherNode start="(426, 36)" end="(426, 62)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(426, 36)" end="(426, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(426, 36)" end="(426, 37)" leading="" trailing="" val="("/>
                    <OtherNode start="(426, 37)" end="(426, 51)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(426, 37)" end="(426, 47)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(426, 48)" end="(426, 51)">
                        <OtherNode start="(426, 48)" end="(426, 49)" kind="num">
                          <AtomNode start="(426, 48)" end="(426, 49)" leading="" trailing=" " val="0"/>
                        </OtherNode>
                        <IdentNode start="(426, 50)" end="(426, 51)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(426, 51)" end="(426, 52)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(426, 52)" end="(426, 53)" leading="" trailing="" val="."/>
                  <IdentNode start="(426, 53)" end="(426, 62)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(426, 63)" end="(426, 64)">
                  <IdentNode start="(426, 63)" end="(426, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(426, 65)" end="(428, 29)">
          <AtomNode start="(426, 65)" end="(426, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(426, 68)" end="(428, 29)">
            <AtomNode start="(426, 68)" end="(426, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(427, 3)" end="(428, 29)">
              <TacticTacticseq1IndentedNode start="(427, 3)" end="(428, 29)">
                <NullNode start="(427, 3)" end="(428, 29)">
                  <OtherNode start="(427, 3)" end="(427, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;as : Array α&#10;i : Nat&#10;⊢ (takeWhile p as).extract 0 i = takeWhile p (as.extract 0 i)" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;as : List α&#10;⊢ (takeWhile p { toList := as }).extract 0 i = takeWhile p ({ toList := as }.extract 0 i)" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(427, 3)" end="(427, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(427, 10)" end="(427, 12)">
                      <OtherNode start="(427, 10)" end="(427, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(427, 10)" end="(427, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(427, 13)" end="(427, 22)">
                      <AtomNode start="(427, 13)" end="(427, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(427, 18)" end="(427, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(427, 18)" end="(427, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(427, 18)" end="(427, 22)">
                            <OtherNode start="(427, 18)" end="(427, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(427, 18)" end="(427, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(427, 19)" end="(427, 21)">
                                <OtherNode start="(427, 19)" end="(427, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(427, 19)" end="(427, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(427, 19)" end="(427, 21)">
                                      <OtherNode start="(427, 19)" end="(427, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(427, 19)" end="(427, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(427, 21)" end="(427, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(428, 3)" end="(428, 29)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;as : List α&#10;⊢ (takeWhile p { toList := as }).extract 0 i = takeWhile p ({ toList := as }.extract 0 i)" state_after="no goals" tactic="simp [List.take_takeWhile]">
                    <AtomNode start="(428, 3)" end="(428, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(428, 8)" end="(428, 29)">
                      <AtomNode start="(428, 8)" end="(428, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(428, 9)" end="(428, 28)">
                        <OtherNode start="(428, 9)" end="(428, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(428, 9)" end="(428, 28)" leading="" trailing="" raw_val="List.take_takeWhile" val="List.take_takeWhile" full_name="List.take_takeWhile" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(428, 28)" end="(428, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(430, 1)" end="(434, 7)" name="all_takeWhile" full_name="Array.all_takeWhile">
      <CommandDeclmodifiersNode start="(430, 1)" end="(430, 8)">
        <NullNode/>
        <NullNode start="(430, 1)" end="(430, 8)">
          <OtherNode start="(430, 1)" end="(430, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(430, 1)" end="(430, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(430, 3)" end="(430, 7)">
              <OtherNode start="(430, 3)" end="(430, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(430, 3)" end="(430, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(430, 3)" end="(430, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(430, 7)" end="(430, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(430, 9)" end="(434, 7)" name="all_takeWhile" full_name="Array.all_takeWhile" _is_private_decl="False">
        <AtomNode start="(430, 9)" end="(430, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(430, 17)" end="(430, 30)">
          <IdentNode start="(430, 17)" end="(430, 30)" leading="" trailing=" " raw_val="all_takeWhile" val="all_takeWhile"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(430, 31)" end="(431, 34)">
          <NullNode start="(430, 31)" end="(430, 45)">
            <OtherNode start="(430, 31)" end="(430, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(430, 31)" end="(430, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(430, 32)" end="(430, 34)">
                <IdentNode start="(430, 32)" end="(430, 34)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(430, 35)" end="(430, 44)">
                <AtomNode start="(430, 35)" end="(430, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(430, 37)" end="(430, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(430, 37)" end="(430, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(430, 43)" end="(430, 44)">
                    <IdentNode start="(430, 43)" end="(430, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(430, 44)" end="(430, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(430, 46)" end="(431, 34)">
            <AtomNode start="(430, 46)" end="(430, 47)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(431, 5)" end="(431, 34)" kind="«term_=_»">
              <OtherNode start="(431, 5)" end="(431, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(431, 5)" end="(431, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(431, 5)" end="(431, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(431, 5)" end="(431, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(431, 6)" end="(431, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(431, 6)" end="(431, 18)" leading="" trailing=" " raw_val="as.takeWhile" val="as.takeWhile"/>
                      <NullNode start="(431, 19)" end="(431, 20)">
                        <IdentNode start="(431, 19)" end="(431, 20)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(431, 20)" end="(431, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(431, 21)" end="(431, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(431, 22)" end="(431, 25)" leading="" trailing=" " raw_val="all" val="all" full_name="Array.all" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(431, 26)" end="(431, 27)">
                  <IdentNode start="(431, 26)" end="(431, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(431, 28)" end="(431, 29)" leading="" trailing=" " val="="/>
              <IdentNode start="(431, 30)" end="(431, 34)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(431, 35)" end="(434, 7)">
          <AtomNode start="(431, 35)" end="(431, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(431, 38)" end="(434, 7)">
            <AtomNode start="(431, 38)" end="(431, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(432, 3)" end="(434, 7)">
              <TacticTacticseq1IndentedNode start="(432, 3)" end="(434, 7)">
                <NullNode start="(432, 3)" end="(434, 7)">
                  <OtherNode start="(432, 3)" end="(432, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;as : Array α&#10;⊢ (takeWhile p as).all p = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ (takeWhile p { toList := as }).all p = true" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(432, 3)" end="(432, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(432, 10)" end="(432, 12)">
                      <OtherNode start="(432, 10)" end="(432, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(432, 10)" end="(432, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(432, 13)" end="(432, 22)">
                      <AtomNode start="(432, 13)" end="(432, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(432, 18)" end="(432, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(432, 18)" end="(432, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(432, 18)" end="(432, 22)">
                            <OtherNode start="(432, 18)" end="(432, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(432, 18)" end="(432, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(432, 19)" end="(432, 21)">
                                <OtherNode start="(432, 19)" end="(432, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(432, 19)" end="(432, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(432, 19)" end="(432, 21)">
                                      <OtherNode start="(432, 19)" end="(432, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(432, 19)" end="(432, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(432, 21)" end="(432, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(433, 3)" end="(433, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ (takeWhile p { toList := as }).all p = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ (List.takeWhile p as).toArray.all p = true" tactic="rw [List.takeWhile_toArray]">
                    <AtomNode start="(433, 3)" end="(433, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(433, 6)" end="(433, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(433, 6)" end="(433, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(433, 7)" end="(433, 29)">
                        <OtherNode start="(433, 7)" end="(433, 29)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(433, 7)" end="(433, 29)" leading="" trailing="" raw_val="List.takeWhile_toArray" val="List.takeWhile_toArray" full_name="List.takeWhile_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(433, 29)" end="(433, 30)" leading="" trailing=" -- Not sure why this doesn't fire with `simp`.&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(434, 3)" end="(434, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ (List.takeWhile p as).toArray.all p = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(434, 3)" end="(434, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(436, 1)" end="(440, 7)" name="any_popWhile" full_name="Array.any_popWhile">
      <CommandDeclmodifiersNode start="(436, 1)" end="(436, 8)">
        <NullNode/>
        <NullNode start="(436, 1)" end="(436, 8)">
          <OtherNode start="(436, 1)" end="(436, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(436, 1)" end="(436, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(436, 3)" end="(436, 7)">
              <OtherNode start="(436, 3)" end="(436, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(436, 3)" end="(436, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(436, 3)" end="(436, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(436, 7)" end="(436, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(436, 9)" end="(440, 7)" name="any_popWhile" full_name="Array.any_popWhile" _is_private_decl="False">
        <AtomNode start="(436, 9)" end="(436, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(436, 17)" end="(436, 29)">
          <IdentNode start="(436, 17)" end="(436, 29)" leading="" trailing=" " raw_val="any_popWhile" val="any_popWhile"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(436, 30)" end="(437, 52)">
          <NullNode start="(436, 30)" end="(436, 44)">
            <OtherNode start="(436, 30)" end="(436, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(436, 30)" end="(436, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(436, 31)" end="(436, 33)">
                <IdentNode start="(436, 31)" end="(436, 33)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(436, 34)" end="(436, 43)">
                <AtomNode start="(436, 34)" end="(436, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(436, 36)" end="(436, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(436, 36)" end="(436, 41)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(436, 42)" end="(436, 43)">
                    <IdentNode start="(436, 42)" end="(436, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(436, 43)" end="(436, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(436, 45)" end="(437, 52)">
            <AtomNode start="(436, 45)" end="(436, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(437, 5)" end="(437, 52)" kind="«term_=_»">
              <OtherNode start="(437, 5)" end="(437, 40)" kind="Lean.Parser.Term.app">
                <OtherNode start="(437, 5)" end="(437, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(437, 5)" end="(437, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(437, 5)" end="(437, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(437, 6)" end="(437, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(437, 6)" end="(437, 17)" leading="" trailing=" " raw_val="as.popWhile" val="as.popWhile"/>
                      <NullNode start="(437, 18)" end="(437, 19)">
                        <IdentNode start="(437, 18)" end="(437, 19)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(437, 19)" end="(437, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(437, 20)" end="(437, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(437, 21)" end="(437, 24)" leading="" trailing=" " raw_val="any" val="any" full_name="Array.any" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(437, 25)" end="(437, 40)">
                  <OtherNode start="(437, 25)" end="(437, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(437, 25)" end="(437, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(437, 26)" end="(437, 39)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(437, 26)" end="(437, 29)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(437, 30)" end="(437, 39)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(437, 30)" end="(437, 31)">
                          <IdentNode start="(437, 30)" end="(437, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(437, 32)" end="(437, 34)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(437, 35)" end="(437, 39)" kind="term!_">
                          <AtomNode start="(437, 35)" end="(437, 36)" leading="" trailing="" val="!"/>
                          <OtherNode start="(437, 36)" end="(437, 39)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(437, 36)" end="(437, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(437, 38)" end="(437, 39)">
                              <IdentNode start="(437, 38)" end="(437, 39)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(437, 39)" end="(437, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(437, 41)" end="(437, 42)" leading="" trailing=" " val="="/>
              <OtherNode start="(437, 43)" end="(437, 52)" kind="term!_">
                <AtomNode start="(437, 43)" end="(437, 44)" leading="" trailing="" val="!"/>
                <OtherNode start="(437, 44)" end="(437, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(437, 44)" end="(437, 50)" leading="" trailing=" " raw_val="as.all" val="as.all"/>
                  <NullNode start="(437, 51)" end="(437, 52)">
                    <IdentNode start="(437, 51)" end="(437, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(437, 53)" end="(440, 7)">
          <AtomNode start="(437, 53)" end="(437, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(437, 56)" end="(440, 7)">
            <AtomNode start="(437, 56)" end="(437, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(438, 3)" end="(440, 7)">
              <TacticTacticseq1IndentedNode start="(438, 3)" end="(440, 7)">
                <NullNode start="(438, 3)" end="(440, 7)">
                  <OtherNode start="(438, 3)" end="(438, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;as : Array α&#10;⊢ ((popWhile p as).any fun a =&amp;gt; !p a) = !as.all p" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ ((popWhile p { toList := as }).any fun a =&amp;gt; !p a) = !{ toList := as }.all p" tactic="rcases as with ⟨as⟩">
                    <AtomNode start="(438, 3)" end="(438, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(438, 10)" end="(438, 12)">
                      <OtherNode start="(438, 10)" end="(438, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(438, 10)" end="(438, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(438, 13)" end="(438, 22)">
                      <AtomNode start="(438, 13)" end="(438, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(438, 18)" end="(438, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(438, 18)" end="(438, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(438, 18)" end="(438, 22)">
                            <OtherNode start="(438, 18)" end="(438, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(438, 18)" end="(438, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(438, 19)" end="(438, 21)">
                                <OtherNode start="(438, 19)" end="(438, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(438, 19)" end="(438, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(438, 19)" end="(438, 21)">
                                      <OtherNode start="(438, 19)" end="(438, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(438, 19)" end="(438, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(438, 21)" end="(438, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(439, 3)" end="(439, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ ((popWhile p { toList := as }).any fun a =&amp;gt; !p a) = !{ toList := as }.all p" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ ((List.dropWhile p as.reverse).reverse.toArray.any fun a =&amp;gt; !p a) = !{ toList := as }.all p" tactic="rw [List.popWhile_toArray]">
                    <AtomNode start="(439, 3)" end="(439, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(439, 6)" end="(439, 29)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(439, 6)" end="(439, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(439, 7)" end="(439, 28)">
                        <OtherNode start="(439, 7)" end="(439, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(439, 7)" end="(439, 28)" leading="" trailing="" raw_val="List.popWhile_toArray" val="List.popWhile_toArray" full_name="List.popWhile_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(439, 28)" end="(439, 29)" leading="" trailing=" -- Not sure why this doesn't fire with `simp`.&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(440, 3)" end="(440, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;as : List α&#10;⊢ ((List.dropWhile p as.reverse).reverse.toArray.any fun a =&amp;gt; !p a) = !{ toList := as }.all p" state_after="no goals" tactic="simp">
                    <AtomNode start="(440, 3)" end="(440, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(442, 1)" end="(445, 44)" name="takeWhile_eq_extract_findIdx_not" full_name="Array.takeWhile_eq_extract_findIdx_not">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(442, 1)" end="(445, 44)" name="takeWhile_eq_extract_findIdx_not" full_name="Array.takeWhile_eq_extract_findIdx_not" _is_private_decl="False">
        <AtomNode start="(442, 1)" end="(442, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(442, 9)" end="(442, 41)">
          <IdentNode start="(442, 9)" end="(442, 41)" leading="" trailing=" " raw_val="takeWhile_eq_extract_findIdx_not" val="takeWhile_eq_extract_findIdx_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(442, 42)" end="(443, 63)">
          <NullNode start="(442, 42)" end="(442, 71)">
            <OtherNode start="(442, 42)" end="(442, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(442, 42)" end="(442, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(442, 43)" end="(442, 45)">
                <IdentNode start="(442, 43)" end="(442, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(442, 46)" end="(442, 55)">
                <AtomNode start="(442, 46)" end="(442, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(442, 48)" end="(442, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(442, 48)" end="(442, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(442, 54)" end="(442, 55)">
                    <IdentNode start="(442, 54)" end="(442, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(442, 55)" end="(442, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(442, 57)" end="(442, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(442, 57)" end="(442, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(442, 58)" end="(442, 59)">
                <IdentNode start="(442, 58)" end="(442, 59)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(442, 60)" end="(442, 70)">
                <AtomNode start="(442, 60)" end="(442, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(442, 62)" end="(442, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(442, 62)" end="(442, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(442, 64)" end="(442, 65)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(442, 66)" end="(442, 70)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(442, 70)" end="(442, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(442, 72)" end="(443, 63)">
            <AtomNode start="(442, 72)" end="(442, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(443, 5)" end="(443, 63)" kind="«term_=_»">
              <OtherNode start="(443, 5)" end="(443, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(443, 5)" end="(443, 14)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(443, 15)" end="(443, 19)">
                  <IdentNode start="(443, 15)" end="(443, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(443, 17)" end="(443, 19)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(443, 20)" end="(443, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(443, 22)" end="(443, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(443, 22)" end="(443, 32)" leading="" trailing=" " raw_val="xs.extract" val="xs.extract"/>
                <NullNode start="(443, 33)" end="(443, 63)">
                  <OtherNode start="(443, 33)" end="(443, 34)" kind="num">
                    <AtomNode start="(443, 33)" end="(443, 34)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <OtherNode start="(443, 35)" end="(443, 63)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(443, 35)" end="(443, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(443, 36)" end="(443, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(443, 36)" end="(443, 46)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(443, 47)" end="(443, 62)">
                        <OtherNode start="(443, 47)" end="(443, 62)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(443, 47)" end="(443, 48)" leading="" trailing="" val="("/>
                          <OtherNode start="(443, 48)" end="(443, 61)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(443, 48)" end="(443, 51)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(443, 52)" end="(443, 61)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(443, 52)" end="(443, 53)">
                                <IdentNode start="(443, 52)" end="(443, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(443, 54)" end="(443, 56)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(443, 57)" end="(443, 61)" kind="term!_">
                                <AtomNode start="(443, 57)" end="(443, 58)" leading="" trailing="" val="!"/>
                                <OtherNode start="(443, 58)" end="(443, 61)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(443, 58)" end="(443, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <NullNode start="(443, 60)" end="(443, 61)">
                                    <IdentNode start="(443, 60)" end="(443, 61)" leading="" trailing="" raw_val="a" val="a"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(443, 61)" end="(443, 62)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(443, 62)" end="(443, 63)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(443, 64)" end="(445, 44)">
          <AtomNode start="(443, 64)" end="(443, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(443, 67)" end="(445, 44)">
            <AtomNode start="(443, 67)" end="(443, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(444, 3)" end="(445, 44)">
              <TacticTacticseq1IndentedNode start="(444, 3)" end="(445, 44)">
                <NullNode start="(444, 3)" end="(445, 44)">
                  <OtherNode start="(444, 3)" end="(444, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ takeWhile p xs = xs.extract 0 (findIdx (fun a =&amp;gt; !p a) xs)" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ takeWhile p { toList := xs } = { toList := xs }.extract 0 (findIdx (fun a =&amp;gt; !p a) { toList := xs })" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(444, 3)" end="(444, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(444, 10)" end="(444, 12)">
                      <OtherNode start="(444, 10)" end="(444, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(444, 10)" end="(444, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(444, 13)" end="(444, 22)">
                      <AtomNode start="(444, 13)" end="(444, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(444, 18)" end="(444, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(444, 18)" end="(444, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(444, 18)" end="(444, 22)">
                            <OtherNode start="(444, 18)" end="(444, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(444, 18)" end="(444, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(444, 19)" end="(444, 21)">
                                <OtherNode start="(444, 19)" end="(444, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(444, 19)" end="(444, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(444, 19)" end="(444, 21)">
                                      <OtherNode start="(444, 19)" end="(444, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(444, 19)" end="(444, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(444, 21)" end="(444, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(445, 3)" end="(445, 44)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ takeWhile p { toList := xs } = { toList := xs }.extract 0 (findIdx (fun a =&amp;gt; !p a) { toList := xs })" state_after="no goals" tactic="simp [List.takeWhile_eq_take_findIdx_not]">
                    <AtomNode start="(445, 3)" end="(445, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(445, 8)" end="(445, 44)">
                      <AtomNode start="(445, 8)" end="(445, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(445, 9)" end="(445, 43)">
                        <OtherNode start="(445, 9)" end="(445, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(445, 9)" end="(445, 43)" leading="" trailing="" raw_val="List.takeWhile_eq_take_findIdx_not" val="List.takeWhile_eq_take_findIdx_not" full_name="List.takeWhile_eq_take_findIdx_not" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(445, 43)" end="(445, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(447, 1)" end="(447, 10)" name="Array">
      <AtomNode start="(447, 1)" end="(447, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(447, 5)" end="(447, 10)">
        <IdentNode start="(447, 5)" end="(447, 10)" leading="" trailing="&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 1)" end="(16, 3)" text="# Lemmas about `Array.extract`&#10;&#10;This file follows the contents of `Init.Data.List.TakeDrop` and `Init.Data.List.Nat.TakeDrop`.&#10;-/"/>
    <Comment start="(18, 38)" end="(19, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(19, 39)" end="(21, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(24, 1)" end="(24, 19)" text="### extract -/"/>
    <Comment start="(325, 1)" end="(325, 21)" text="### takeWhile -/"/>
    <Comment start="(379, 3)" end="(380, 3)" text="-- Why do these not fire with `simp`?&#10;  "/>
    <Comment start="(433, 31)" end="(434, 3)" text="-- Not sure why this doesn't fire with `simp`.&#10;  "/>
    <Comment start="(439, 30)" end="(440, 3)" text="-- Not sure why this doesn't fire with `simp`.&#10;  "/>
  </Comments>
</TracedFile>
