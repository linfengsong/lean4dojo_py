<TracedFile path="src/lean/Init/Data/Array/Monadic.lean" md5="e3dbd7bdb7ad6d4f1e7b1865d6a3e566">
  <FileNode start="(1, 1)" end="(486, 10)">
    <ModuleHeaderNode start="(6, 1)" end="(11, 30)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(11, 30)">
        <ModuleImportNode start="(9, 1)" end="(9, 30)" module="Init.Data.Array.Lemmas" path="src/lean/Init/Data/Array/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Lemmas" val="Init.Data.Array.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 30)" module="Init.Data.Array.Attach" path="src/lean/Init/Data/Array/Attach.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Attach" val="Init.Data.Array.Attach"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 30)" module="Init.Data.List.Monadic" path="src/lean/Init/Data/List/Monadic.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 30)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Monadic" val="Init.Data.List.Monadic"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(13, 1)" end="(15, 3)" comment="# Lemmas about `Array.forIn'` and `Array.forIn`.&#10;-/">
      <AtomNode start="(13, 1)" end="(13, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(14, 1)" end="(15, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `Array.forIn'` and `Array.forIn`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(17, 1)" end="(17, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(17, 1)" end="(17, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(17, 12)" end="(17, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(17, 33)" end="(17, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(18, 1)" end="(18, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(18, 1)" end="(18, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(18, 12)" end="(18, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(18, 34)" end="(18, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(20, 1)" end="(20, 16)" name="Array">
      <AtomNode start="(20, 1)" end="(20, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(20, 11)" end="(20, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(22, 1)" end="(22, 9)">
      <AtomNode start="(22, 1)" end="(22, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(22, 6)" end="(22, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(22, 6)" end="(22, 9)">
          <IdentNode start="(22, 6)" end="(22, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(24, 1)" end="(24, 29)" comment="## Monadic operations -/">
      <AtomNode start="(24, 1)" end="(24, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(24, 5)" end="(24, 29)" leading="" trailing="&#10;&#10;" val="## Monadic operations -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(26, 1)" end="(26, 16)" comment="### mapM -/">
      <AtomNode start="(26, 1)" end="(26, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(26, 5)" end="(26, 16)" leading="" trailing="&#10;&#10;" val="### mapM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(28, 1)" end="(30, 25)" name="mapM_pure" full_name="Array.mapM_pure">
      <CommandDeclmodifiersNode start="(28, 1)" end="(28, 8)">
        <NullNode/>
        <NullNode start="(28, 1)" end="(28, 8)">
          <OtherNode start="(28, 1)" end="(28, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(28, 1)" end="(28, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(28, 3)" end="(28, 7)">
              <OtherNode start="(28, 3)" end="(28, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(28, 3)" end="(28, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(28, 3)" end="(28, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(28, 7)" end="(28, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(28, 9)" end="(30, 25)" name="mapM_pure" full_name="Array.mapM_pure" _is_private_decl="False">
        <AtomNode start="(28, 9)" end="(28, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(28, 17)" end="(28, 26)">
          <IdentNode start="(28, 17)" end="(28, 26)" leading="" trailing=" " raw_val="mapM_pure" val="mapM_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(28, 27)" end="(29, 53)">
          <NullNode start="(28, 27)" end="(28, 79)">
            <OtherNode start="(28, 27)" end="(28, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(28, 27)" end="(28, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(28, 28)" end="(28, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(28, 28)" end="(28, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(28, 34)" end="(28, 35)">
                  <IdentNode start="(28, 34)" end="(28, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(28, 35)" end="(28, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(28, 37)" end="(28, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(28, 37)" end="(28, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(28, 38)" end="(28, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(28, 38)" end="(28, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(28, 50)" end="(28, 51)">
                  <IdentNode start="(28, 50)" end="(28, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(28, 51)" end="(28, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(28, 53)" end="(28, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(28, 53)" end="(28, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(28, 54)" end="(28, 56)">
                <IdentNode start="(28, 54)" end="(28, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(28, 57)" end="(28, 66)">
                <AtomNode start="(28, 57)" end="(28, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(28, 59)" end="(28, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(28, 59)" end="(28, 64)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(28, 65)" end="(28, 66)">
                    <IdentNode start="(28, 65)" end="(28, 66)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(28, 66)" end="(28, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(28, 68)" end="(28, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(28, 68)" end="(28, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(28, 69)" end="(28, 70)">
                <IdentNode start="(28, 69)" end="(28, 70)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(28, 71)" end="(28, 78)">
                <AtomNode start="(28, 71)" end="(28, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(28, 73)" end="(28, 78)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(28, 73)" end="(28, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(28, 75)" end="(28, 76)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(28, 77)" end="(28, 78)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(28, 78)" end="(28, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(28, 80)" end="(29, 53)">
            <AtomNode start="(28, 80)" end="(28, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(29, 5)" end="(29, 53)" kind="«term_=_»">
              <OtherNode start="(29, 5)" end="(29, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(29, 5)" end="(29, 12)" leading="" trailing=" " raw_val="xs.mapM" val="xs.mapM"/>
                <NullNode start="(29, 13)" end="(29, 35)">
                  <OtherNode start="(29, 13)" end="(29, 21)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(29, 13)" end="(29, 14)" leading="" trailing="" val="("/>
                    <IdentNode start="(29, 14)" end="(29, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(29, 16)" end="(29, 18)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(29, 19)" end="(29, 20)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(29, 20)" end="(29, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(29, 22)" end="(29, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(29, 22)" end="(29, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(29, 23)" end="(29, 34)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(29, 23)" end="(29, 27)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(29, 28)" end="(29, 30)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(29, 31)" end="(29, 34)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(29, 31)" end="(29, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(29, 33)" end="(29, 34)">
                          <OtherNode start="(29, 33)" end="(29, 34)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(29, 33)" end="(29, 34)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(29, 34)" end="(29, 35)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(29, 36)" end="(29, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(29, 38)" end="(29, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(29, 38)" end="(29, 42)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(29, 43)" end="(29, 53)">
                  <OtherNode start="(29, 43)" end="(29, 53)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(29, 43)" end="(29, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(29, 44)" end="(29, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(29, 44)" end="(29, 50)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(29, 51)" end="(29, 52)">
                        <IdentNode start="(29, 51)" end="(29, 52)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(29, 52)" end="(29, 53)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(29, 54)" end="(30, 25)">
          <AtomNode start="(29, 54)" end="(29, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(29, 57)" end="(30, 25)">
            <AtomNode start="(29, 57)" end="(29, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(30, 3)" end="(30, 25)">
              <TacticTacticseq1IndentedNode start="(30, 3)" end="(30, 25)">
                <NullNode start="(30, 3)" end="(30, 25)">
                  <OtherNode start="(30, 3)" end="(30, 15)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → β&#10;⊢ mapM (fun x =&amp;gt; pure (f x)) xs = pure (map f xs)" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β&#10;toList✝ : List α&#10;⊢ mapM (fun x =&amp;gt; pure (f x)) { toList := toList✝ } = pure (map f { toList := toList✝ })" tactic="induction xs">
                    <AtomNode start="(30, 3)" end="(30, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(30, 13)" end="(30, 15)">
                      <OtherNode start="(30, 13)" end="(30, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(30, 13)" end="(30, 15)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(30, 15)" end="(30, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(30, 17)" end="(30, 25)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β&#10;toList✝ : List α&#10;⊢ mapM (fun x =&amp;gt; pure (f x)) { toList := toList✝ } = pure (map f { toList := toList✝ })" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(30, 17)" end="(30, 25)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(32, 1)" end="(33, 12)" name="mapM_id" full_name="Array.mapM_id">
      <CommandDeclmodifiersNode start="(32, 1)" end="(32, 8)">
        <NullNode/>
        <NullNode start="(32, 1)" end="(32, 8)">
          <OtherNode start="(32, 1)" end="(32, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(32, 1)" end="(32, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(32, 3)" end="(32, 7)">
              <OtherNode start="(32, 3)" end="(32, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(32, 3)" end="(32, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(32, 3)" end="(32, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(32, 7)" end="(32, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(32, 9)" end="(33, 12)" name="mapM_id" full_name="Array.mapM_id" _is_private_decl="False">
        <AtomNode start="(32, 9)" end="(32, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(32, 17)" end="(32, 24)">
          <IdentNode start="(32, 17)" end="(32, 24)" leading="" trailing=" " raw_val="mapM_id" val="mapM_id"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(32, 25)" end="(32, 77)">
          <NullNode start="(32, 25)" end="(32, 54)">
            <OtherNode start="(32, 25)" end="(32, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(32, 25)" end="(32, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(32, 26)" end="(32, 28)">
                <IdentNode start="(32, 26)" end="(32, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(32, 29)" end="(32, 38)">
                <AtomNode start="(32, 29)" end="(32, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(32, 31)" end="(32, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(32, 31)" end="(32, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(32, 37)" end="(32, 38)">
                    <IdentNode start="(32, 37)" end="(32, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(32, 38)" end="(32, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(32, 40)" end="(32, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(32, 40)" end="(32, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(32, 41)" end="(32, 42)">
                <IdentNode start="(32, 41)" end="(32, 42)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(32, 43)" end="(32, 53)">
                <AtomNode start="(32, 43)" end="(32, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(32, 45)" end="(32, 53)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(32, 45)" end="(32, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(32, 47)" end="(32, 48)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(32, 49)" end="(32, 53)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(32, 49)" end="(32, 51)" leading="" trailing=" " raw_val="Id" val="Id" full_name="Id" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                    <NullNode start="(32, 52)" end="(32, 53)">
                      <IdentNode start="(32, 52)" end="(32, 53)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(32, 53)" end="(32, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(32, 55)" end="(32, 77)">
            <AtomNode start="(32, 55)" end="(32, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(32, 57)" end="(32, 77)" kind="«term_=_»">
              <OtherNode start="(32, 57)" end="(32, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(32, 57)" end="(32, 64)" leading="" trailing=" " raw_val="xs.mapM" val="xs.mapM"/>
                <NullNode start="(32, 65)" end="(32, 66)">
                  <IdentNode start="(32, 65)" end="(32, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(32, 67)" end="(32, 68)" leading="" trailing=" " val="="/>
              <OtherNode start="(32, 69)" end="(32, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(32, 69)" end="(32, 75)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                <NullNode start="(32, 76)" end="(32, 77)">
                  <IdentNode start="(32, 76)" end="(32, 77)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(32, 78)" end="(33, 12)">
          <AtomNode start="(32, 78)" end="(32, 80)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(33, 3)" end="(33, 12)" leading="" trailing="&#10;&#10;" raw_val="mapM_pure" val="mapM_pure" full_name="Array.mapM_pure" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(28, 17)" def_end="(28, 26)"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(35, 1)" end="(39, 7)" name="mapM_append" full_name="Array.mapM_append">
      <CommandDeclmodifiersNode start="(35, 1)" end="(35, 8)">
        <NullNode/>
        <NullNode start="(35, 1)" end="(35, 8)">
          <OtherNode start="(35, 1)" end="(35, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(35, 1)" end="(35, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(35, 3)" end="(35, 7)">
              <OtherNode start="(35, 3)" end="(35, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(35, 3)" end="(35, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(35, 3)" end="(35, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(35, 7)" end="(35, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(35, 9)" end="(39, 7)" name="mapM_append" full_name="Array.mapM_append" _is_private_decl="False">
        <AtomNode start="(35, 9)" end="(35, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(35, 17)" end="(35, 28)">
          <IdentNode start="(35, 17)" end="(35, 28)" leading="" trailing=" " raw_val="mapM_append" val="mapM_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(35, 29)" end="(36, 64)">
          <NullNode start="(35, 29)" end="(35, 86)">
            <OtherNode start="(35, 29)" end="(35, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(35, 29)" end="(35, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(35, 30)" end="(35, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(35, 30)" end="(35, 35)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(35, 36)" end="(35, 37)">
                  <IdentNode start="(35, 36)" end="(35, 37)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(35, 37)" end="(35, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(35, 39)" end="(35, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(35, 39)" end="(35, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(35, 40)" end="(35, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(35, 40)" end="(35, 51)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(35, 52)" end="(35, 53)">
                  <IdentNode start="(35, 52)" end="(35, 53)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(35, 53)" end="(35, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(35, 55)" end="(35, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(35, 55)" end="(35, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(35, 56)" end="(35, 57)">
                <IdentNode start="(35, 56)" end="(35, 57)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(35, 58)" end="(35, 67)">
                <AtomNode start="(35, 58)" end="(35, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 60)" end="(35, 67)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(35, 60)" end="(35, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(35, 62)" end="(35, 63)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(35, 64)" end="(35, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(35, 64)" end="(35, 65)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(35, 66)" end="(35, 67)">
                      <IdentNode start="(35, 66)" end="(35, 67)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(35, 67)" end="(35, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(35, 69)" end="(35, 86)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(35, 69)" end="(35, 70)" leading="" trailing="" val="{"/>
              <NullNode start="(35, 70)" end="(35, 75)">
                <IdentNode start="(35, 70)" end="(35, 72)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(35, 73)" end="(35, 75)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(35, 76)" end="(35, 85)">
                <AtomNode start="(35, 76)" end="(35, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 78)" end="(35, 85)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(35, 78)" end="(35, 83)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(35, 84)" end="(35, 85)">
                    <IdentNode start="(35, 84)" end="(35, 85)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(35, 85)" end="(35, 86)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(35, 87)" end="(36, 64)">
            <AtomNode start="(35, 87)" end="(35, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(36, 5)" end="(36, 64)" kind="«term_=_»">
              <OtherNode start="(36, 5)" end="(36, 22)" kind="Lean.Parser.Term.app">
                <OtherNode start="(36, 5)" end="(36, 20)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(36, 5)" end="(36, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(36, 5)" end="(36, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(36, 6)" end="(36, 14)" kind="«term_++_»">
                      <IdentNode start="(36, 6)" end="(36, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(36, 9)" end="(36, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(36, 12)" end="(36, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(36, 14)" end="(36, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(36, 15)" end="(36, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(36, 16)" end="(36, 20)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="Array.mapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(36, 21)" end="(36, 22)">
                  <IdentNode start="(36, 21)" end="(36, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(36, 23)" end="(36, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(36, 25)" end="(36, 64)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(36, 25)" end="(36, 26)" leading="" trailing="" val="("/>
                <OtherNode start="(36, 26)" end="(36, 63)" kind="Lean.Parser.Term.termReturn">
                  <AtomNode start="(36, 26)" end="(36, 32)" leading="" trailing=" " val="return"/>
                  <NullNode start="(36, 33)" end="(36, 63)">
                    <OtherNode start="(36, 33)" end="(36, 63)" kind="«term_++_»">
                      <OtherNode start="(36, 33)" end="(36, 46)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(36, 33)" end="(36, 34)" leading="" trailing="" val="("/>
                        <OtherNode start="(36, 34)" end="(36, 45)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(36, 34)" end="(36, 35)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(36, 36)" end="(36, 45)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(36, 36)" end="(36, 43)" leading="" trailing=" " raw_val="xs.mapM" val="xs.mapM"/>
                            <NullNode start="(36, 44)" end="(36, 45)">
                              <IdentNode start="(36, 44)" end="(36, 45)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(36, 45)" end="(36, 46)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(36, 47)" end="(36, 49)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(36, 50)" end="(36, 63)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(36, 50)" end="(36, 51)" leading="" trailing="" val="("/>
                        <OtherNode start="(36, 51)" end="(36, 62)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(36, 51)" end="(36, 52)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(36, 53)" end="(36, 62)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(36, 53)" end="(36, 60)" leading="" trailing=" " raw_val="ys.mapM" val="ys.mapM"/>
                            <NullNode start="(36, 61)" end="(36, 62)">
                              <IdentNode start="(36, 61)" end="(36, 62)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(36, 62)" end="(36, 63)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(36, 63)" end="(36, 64)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(36, 65)" end="(39, 7)">
          <AtomNode start="(36, 65)" end="(36, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(36, 68)" end="(39, 7)">
            <AtomNode start="(36, 68)" end="(36, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(37, 3)" end="(39, 7)">
              <TacticTacticseq1IndentedNode start="(37, 3)" end="(39, 7)">
                <NullNode start="(37, 3)" end="(39, 7)">
                  <OtherNode start="(37, 3)" end="(37, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs ys : Array α&#10;⊢ mapM f (xs ++ ys) = do&#10;    let __do_lift ← mapM f xs&#10;    let __do_lift_1 ← mapM f ys&#10;    pure (__do_lift ++ __do_lift_1)" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;ys : Array α&#10;xs : List α&#10;⊢ mapM f ({ toList := xs } ++ ys) = do&#10;    let __do_lift ← mapM f { toList := xs }&#10;    let __do_lift_1 ← mapM f ys&#10;    pure (__do_lift ++ __do_lift_1)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(37, 3)" end="(37, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(37, 10)" end="(37, 12)">
                      <OtherNode start="(37, 10)" end="(37, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(37, 10)" end="(37, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(37, 13)" end="(37, 22)">
                      <AtomNode start="(37, 13)" end="(37, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(37, 18)" end="(37, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(37, 18)" end="(37, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(37, 18)" end="(37, 22)">
                            <OtherNode start="(37, 18)" end="(37, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(37, 18)" end="(37, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(37, 19)" end="(37, 21)">
                                <OtherNode start="(37, 19)" end="(37, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(37, 19)" end="(37, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(37, 19)" end="(37, 21)">
                                      <OtherNode start="(37, 19)" end="(37, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(37, 19)" end="(37, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(37, 21)" end="(37, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(38, 3)" end="(38, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;ys : Array α&#10;xs : List α&#10;⊢ mapM f ({ toList := xs } ++ ys) = do&#10;    let __do_lift ← mapM f { toList := xs }&#10;    let __do_lift_1 ← mapM f ys&#10;    pure (__do_lift ++ __do_lift_1)" state_after="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs ys : List α&#10;⊢ mapM f ({ toList := xs } ++ { toList := ys }) = do&#10;    let __do_lift ← mapM f { toList := xs }&#10;    let __do_lift_1 ← mapM f { toList := ys }&#10;    pure (__do_lift ++ __do_lift_1)" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(38, 3)" end="(38, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(38, 10)" end="(38, 12)">
                      <OtherNode start="(38, 10)" end="(38, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(38, 10)" end="(38, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(38, 13)" end="(38, 22)">
                      <AtomNode start="(38, 13)" end="(38, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(38, 18)" end="(38, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(38, 18)" end="(38, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(38, 18)" end="(38, 22)">
                            <OtherNode start="(38, 18)" end="(38, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(38, 18)" end="(38, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(38, 19)" end="(38, 21)">
                                <OtherNode start="(38, 19)" end="(38, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(38, 19)" end="(38, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(38, 19)" end="(38, 21)">
                                      <OtherNode start="(38, 19)" end="(38, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(38, 19)" end="(38, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(38, 21)" end="(38, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(39, 3)" end="(39, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs ys : List α&#10;⊢ mapM f ({ toList := xs } ++ { toList := ys }) = do&#10;    let __do_lift ← mapM f { toList := xs }&#10;    let __do_lift_1 ← mapM f { toList := ys }&#10;    pure (__do_lift ++ __do_lift_1)" state_after="no goals" tactic="simp">
                    <AtomNode start="(39, 3)" end="(39, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(41, 1)" end="(54, 32)" name="mapM_eq_foldlM_push" full_name="Array.mapM_eq_foldlM_push">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(41, 1)" end="(54, 32)" name="mapM_eq_foldlM_push" full_name="Array.mapM_eq_foldlM_push" _is_private_decl="False">
        <AtomNode start="(41, 1)" end="(41, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(41, 9)" end="(41, 28)">
          <IdentNode start="(41, 9)" end="(41, 28)" leading="" trailing=" " raw_val="mapM_eq_foldlM_push" val="mapM_eq_foldlM_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(41, 29)" end="(42, 71)">
          <NullNode start="(41, 29)" end="(41, 83)">
            <OtherNode start="(41, 29)" end="(41, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(41, 29)" end="(41, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(41, 30)" end="(41, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(41, 30)" end="(41, 35)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(41, 36)" end="(41, 37)">
                  <IdentNode start="(41, 36)" end="(41, 37)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(41, 37)" end="(41, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(41, 39)" end="(41, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(41, 39)" end="(41, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(41, 40)" end="(41, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(41, 40)" end="(41, 51)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(41, 52)" end="(41, 53)">
                  <IdentNode start="(41, 52)" end="(41, 53)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(41, 53)" end="(41, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(41, 55)" end="(41, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(41, 55)" end="(41, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(41, 56)" end="(41, 57)">
                <IdentNode start="(41, 56)" end="(41, 57)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(41, 58)" end="(41, 67)">
                <AtomNode start="(41, 58)" end="(41, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(41, 60)" end="(41, 67)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(41, 60)" end="(41, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(41, 62)" end="(41, 63)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(41, 64)" end="(41, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(41, 64)" end="(41, 65)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(41, 66)" end="(41, 67)">
                      <IdentNode start="(41, 66)" end="(41, 67)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(41, 67)" end="(41, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(41, 69)" end="(41, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(41, 69)" end="(41, 70)" leading="" trailing="" val="{"/>
              <NullNode start="(41, 70)" end="(41, 72)">
                <IdentNode start="(41, 70)" end="(41, 72)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(41, 73)" end="(41, 82)">
                <AtomNode start="(41, 73)" end="(41, 74)" leading="" trailing=" " val=":"/>
                <OtherNode start="(41, 75)" end="(41, 82)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(41, 75)" end="(41, 80)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(41, 81)" end="(41, 82)">
                    <IdentNode start="(41, 81)" end="(41, 82)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(41, 82)" end="(41, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(41, 84)" end="(42, 71)">
            <AtomNode start="(41, 84)" end="(41, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(42, 5)" end="(42, 71)" kind="«term_=_»">
              <OtherNode start="(42, 5)" end="(42, 14)" kind="Lean.Parser.Term.app">
                <IdentNode start="(42, 5)" end="(42, 9)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="Array.mapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(42, 10)" end="(42, 14)">
                  <IdentNode start="(42, 10)" end="(42, 11)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(42, 12)" end="(42, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(42, 15)" end="(42, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(42, 17)" end="(42, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(42, 17)" end="(42, 26)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(42, 27)" end="(42, 71)">
                  <OtherNode start="(42, 27)" end="(42, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(42, 27)" end="(42, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(42, 28)" end="(42, 66)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(42, 28)" end="(42, 31)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(42, 32)" end="(42, 66)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(42, 32)" end="(42, 37)">
                          <IdentNode start="(42, 32)" end="(42, 35)" leading="" trailing=" " raw_val="acc" val="acc"/>
                          <IdentNode start="(42, 36)" end="(42, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(42, 38)" end="(42, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(42, 41)" end="(42, 66)" kind="Lean.Parser.Term.termReturn">
                          <AtomNode start="(42, 41)" end="(42, 47)" leading="" trailing=" " val="return"/>
                          <NullNode start="(42, 48)" end="(42, 66)">
                            <OtherNode start="(42, 48)" end="(42, 66)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(42, 48)" end="(42, 49)" leading="" trailing="" val="("/>
                              <OtherNode start="(42, 49)" end="(42, 65)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(42, 49)" end="(42, 57)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                <NullNode start="(42, 58)" end="(42, 65)">
                                  <OtherNode start="(42, 58)" end="(42, 65)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(42, 58)" end="(42, 59)" leading="" trailing="" val="("/>
                                    <OtherNode start="(42, 59)" end="(42, 64)" kind="Lean.Parser.Term.liftMethod">
                                      <AtomNode start="(42, 59)" end="(42, 60)" leading="" trailing=" " val="←"/>
                                      <OtherNode start="(42, 61)" end="(42, 64)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(42, 61)" end="(42, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                                        <NullNode start="(42, 63)" end="(42, 64)">
                                          <IdentNode start="(42, 63)" end="(42, 64)" leading="" trailing="" raw_val="a" val="a"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(42, 64)" end="(42, 65)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(42, 65)" end="(42, 66)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(42, 66)" end="(42, 67)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(42, 68)" end="(42, 71)" kind="«term#[_,]»">
                    <AtomNode start="(42, 68)" end="(42, 70)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(42, 70)" end="(42, 71)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(42, 72)" end="(54, 32)">
          <AtomNode start="(42, 72)" end="(42, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(42, 75)" end="(54, 32)">
            <AtomNode start="(42, 75)" end="(42, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(43, 3)" end="(54, 32)">
              <TacticTacticseq1IndentedNode start="(43, 3)" end="(54, 32)">
                <NullNode start="(43, 3)" end="(54, 32)">
                  <OtherNode start="(43, 3)" end="(43, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : Array α&#10;⊢ mapM f xs =&#10;    foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (acc.push __do_lift))&#10;      #[] xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ mapM f { toList := xs } =&#10;    foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (acc.push __do_lift))&#10;      #[] { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(43, 3)" end="(43, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(43, 10)" end="(43, 12)">
                      <OtherNode start="(43, 10)" end="(43, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(43, 10)" end="(43, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(43, 13)" end="(43, 22)">
                      <AtomNode start="(43, 13)" end="(43, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(43, 18)" end="(43, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(43, 18)" end="(43, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(43, 18)" end="(43, 22)">
                            <OtherNode start="(43, 18)" end="(43, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(43, 18)" end="(43, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(43, 19)" end="(43, 21)">
                                <OtherNode start="(43, 19)" end="(43, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(43, 19)" end="(43, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(43, 19)" end="(43, 21)">
                                      <OtherNode start="(43, 19)" end="(43, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(43, 19)" end="(43, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(43, 21)" end="(43, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(44, 3)" end="(44, 89)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ mapM f { toList := xs } =&#10;    foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (acc.push __do_lift))&#10;      #[] { toList := xs }" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ List.toArray &amp;lt;$&amp;gt; List.mapM f xs = List.foldlM (fun x y =&amp;gt; x.push &amp;lt;$&amp;gt; f y) #[] xs" tactic="simp only [List.mapM_toArray, bind_pure_comp, List.size_toArray, List.foldlM_toArray']">
                    <AtomNode start="(44, 3)" end="(44, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(44, 8)" end="(44, 12)">
                      <AtomNode start="(44, 8)" end="(44, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(44, 13)" end="(44, 89)">
                      <AtomNode start="(44, 13)" end="(44, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(44, 14)" end="(44, 88)">
                        <OtherNode start="(44, 14)" end="(44, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(44, 14)" end="(44, 31)" leading="" trailing="" raw_val="List.mapM_toArray" val="List.mapM_toArray" full_name="List.mapM_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(44, 31)" end="(44, 32)" leading="" trailing=" " val=","/>
                        <OtherNode start="(44, 33)" end="(44, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(44, 33)" end="(44, 47)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(44, 47)" end="(44, 48)" leading="" trailing=" " val=","/>
                        <OtherNode start="(44, 49)" end="(44, 66)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(44, 49)" end="(44, 66)" leading="" trailing="" raw_val="List.size_toArray" val="List.size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(44, 66)" end="(44, 67)" leading="" trailing=" " val=","/>
                        <OtherNode start="(44, 68)" end="(44, 88)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(44, 68)" end="(44, 88)" leading="" trailing="" raw_val="List.foldlM_toArray'" val="List.foldlM_toArray'" full_name="List.foldlM_toArray'" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(44, 88)" end="(44, 89)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(45, 3)" end="(45, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ List.toArray &amp;lt;$&amp;gt; List.mapM f xs = List.foldlM (fun x y =&amp;gt; x.push &amp;lt;$&amp;gt; f y) #[] xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ List.toArray &amp;lt;$&amp;gt;&#10;      List.reverse &amp;lt;$&amp;gt;&#10;        List.foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← f a&#10;            pure (__do_lift :: acc))&#10;          [] xs =&#10;    List.foldlM (fun x y =&amp;gt; x.push &amp;lt;$&amp;gt; f y) #[] xs" tactic="rw [List.mapM_eq_reverse_foldlM_cons]">
                    <AtomNode start="(45, 3)" end="(45, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(45, 6)" end="(45, 40)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(45, 6)" end="(45, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(45, 7)" end="(45, 39)">
                        <OtherNode start="(45, 7)" end="(45, 39)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(45, 7)" end="(45, 39)" leading="" trailing="" raw_val="List.mapM_eq_reverse_foldlM_cons" val="List.mapM_eq_reverse_foldlM_cons" full_name="List.mapM_eq_reverse_foldlM_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(45, 39)" end="(45, 40)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(46, 3)" end="(46, 46)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ List.toArray &amp;lt;$&amp;gt;&#10;      List.reverse &amp;lt;$&amp;gt;&#10;        List.foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← f a&#10;            pure (__do_lift :: acc))&#10;          [] xs =&#10;    List.foldlM (fun x y =&amp;gt; x.push &amp;lt;$&amp;gt; f y) #[] xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) [] xs =&#10;    List.foldlM (fun x y =&amp;gt; x.push &amp;lt;$&amp;gt; f y) #[] xs" tactic="simp only [bind_pure_comp, Functor.map_map]">
                    <AtomNode start="(46, 3)" end="(46, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(46, 8)" end="(46, 12)">
                      <AtomNode start="(46, 8)" end="(46, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(46, 13)" end="(46, 46)">
                      <AtomNode start="(46, 13)" end="(46, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(46, 14)" end="(46, 45)">
                        <OtherNode start="(46, 14)" end="(46, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(46, 14)" end="(46, 28)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(46, 28)" end="(46, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(46, 30)" end="(46, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(46, 30)" end="(46, 45)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(46, 45)" end="(46, 46)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(47, 3)" end="(49, 18)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) [] xs =&#10;    List.foldlM (fun x y =&amp;gt; x.push &amp;lt;$&amp;gt; f y) #[] xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ ∀ (l : List β),&#10;    (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l xs =&#10;      List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray xs" tactic="suffices ∀ (l), (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l xs =&#10;    List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray xs by&#10;  exact this []">
                    <AtomNode start="(47, 3)" end="(47, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(47, 12)" end="(49, 18)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(47, 12)" end="(47, 12)" kind="hygieneInfo">
                        <IdentNode start="(47, 12)" end="(47, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(47, 12)" end="(48, 71)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(47, 12)" end="(47, 13)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(47, 14)" end="(47, 17)">
                          <TermExplicitbinderNode start="(47, 14)" end="(47, 17)">
                            <AtomNode start="(47, 14)" end="(47, 15)" leading="" trailing="" val="("/>
                            <NullNode start="(47, 15)" end="(47, 16)">
                              <IdentNode start="(47, 15)" end="(47, 16)" leading="" trailing="" raw_val="l" val="l"/>
                            </NullNode>
                            <NullNode/>
                            <NullNode/>
                            <AtomNode start="(47, 16)" end="(47, 17)" leading="" trailing="" val=")"/>
                          </TermExplicitbinderNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(47, 17)" end="(47, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(47, 19)" end="(48, 71)" kind="«term_=_»">
                          <OtherNode start="(47, 19)" end="(47, 113)" kind="«term_&amp;lt;$&amp;gt;_»">
                            <OtherNode start="(47, 19)" end="(47, 49)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(47, 19)" end="(47, 20)" leading="" trailing="" val="("/>
                              <OtherNode start="(47, 20)" end="(47, 48)" kind="Lean.Parser.Term.fun">
                                <AtomNode start="(47, 20)" end="(47, 23)" leading="" trailing=" " val="fun"/>
                                <OtherNode start="(47, 24)" end="(47, 48)" kind="Lean.Parser.Term.basicFun">
                                  <NullNode start="(47, 24)" end="(47, 26)">
                                    <IdentNode start="(47, 24)" end="(47, 26)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                  </NullNode>
                                  <NullNode/>
                                  <AtomNode start="(47, 27)" end="(47, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <IdentNode start="(47, 30)" end="(47, 48)" leading="" trailing="" raw_val="l'.reverse.toArray" val="l'.reverse.toArray"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(47, 48)" end="(47, 49)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <AtomNode start="(47, 50)" end="(47, 53)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                            <OtherNode start="(47, 54)" end="(47, 113)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(47, 54)" end="(47, 65)" leading="" trailing=" " raw_val="List.foldlM" val="List.foldlM" full_name="List.foldlM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                              <NullNode start="(47, 66)" end="(47, 113)">
                                <OtherNode start="(47, 66)" end="(47, 108)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(47, 66)" end="(47, 67)" leading="" trailing="" val="("/>
                                  <OtherNode start="(47, 67)" end="(47, 107)" kind="Lean.Parser.Term.fun">
                                    <AtomNode start="(47, 67)" end="(47, 70)" leading="" trailing=" " val="fun"/>
                                    <OtherNode start="(47, 71)" end="(47, 107)" kind="Lean.Parser.Term.basicFun">
                                      <NullNode start="(47, 71)" end="(47, 76)">
                                        <IdentNode start="(47, 71)" end="(47, 74)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                        <IdentNode start="(47, 75)" end="(47, 76)" leading="" trailing=" " raw_val="a" val="a"/>
                                      </NullNode>
                                      <NullNode/>
                                      <AtomNode start="(47, 77)" end="(47, 79)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <OtherNode start="(47, 80)" end="(47, 107)" kind="«term_&amp;lt;$&amp;gt;_»">
                                        <OtherNode start="(47, 80)" end="(47, 99)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(47, 80)" end="(47, 81)" leading="" trailing="" val="("/>
                                          <OtherNode start="(47, 81)" end="(47, 98)" kind="Lean.Parser.Term.fun">
                                            <AtomNode start="(47, 81)" end="(47, 84)" leading="" trailing=" " val="fun"/>
                                            <OtherNode start="(47, 85)" end="(47, 98)" kind="Lean.Parser.Term.basicFun">
                                              <NullNode start="(47, 85)" end="(47, 86)">
                                                <IdentNode start="(47, 85)" end="(47, 86)" leading="" trailing=" " raw_val="a" val="a"/>
                                              </NullNode>
                                              <NullNode/>
                                              <AtomNode start="(47, 87)" end="(47, 89)" leading="" trailing=" " val="=&amp;gt;"/>
                                              <OtherNode start="(47, 90)" end="(47, 98)" kind="«term_::_»">
                                                <IdentNode start="(47, 90)" end="(47, 91)" leading="" trailing=" " raw_val="a" val="a"/>
                                                <AtomNode start="(47, 92)" end="(47, 94)" leading="" trailing=" " val="::"/>
                                                <IdentNode start="(47, 95)" end="(47, 98)" leading="" trailing="" raw_val="acc" val="acc"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(47, 98)" end="(47, 99)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <AtomNode start="(47, 100)" end="(47, 103)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                                        <OtherNode start="(47, 104)" end="(47, 107)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(47, 104)" end="(47, 105)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <NullNode start="(47, 106)" end="(47, 107)">
                                            <IdentNode start="(47, 106)" end="(47, 107)" leading="" trailing="" raw_val="a" val="a"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(47, 107)" end="(47, 108)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(47, 109)" end="(47, 110)" leading="" trailing=" " raw_val="l" val="l"/>
                                <IdentNode start="(47, 111)" end="(47, 113)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(47, 114)" end="(47, 115)" leading="" trailing="&#10;      " val="="/>
                          <OtherNode start="(48, 7)" end="(48, 71)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(48, 7)" end="(48, 18)" leading="" trailing=" " raw_val="List.foldlM" val="List.foldlM" full_name="List.foldlM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                            <NullNode start="(48, 19)" end="(48, 71)">
                              <OtherNode start="(48, 19)" end="(48, 50)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(48, 19)" end="(48, 20)" leading="" trailing="" val="("/>
                                <OtherNode start="(48, 20)" end="(48, 49)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(48, 20)" end="(48, 23)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(48, 24)" end="(48, 49)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(48, 24)" end="(48, 29)">
                                      <IdentNode start="(48, 24)" end="(48, 27)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      <IdentNode start="(48, 28)" end="(48, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(48, 30)" end="(48, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(48, 33)" end="(48, 49)" kind="«term_&amp;lt;$&amp;gt;_»">
                                      <IdentNode start="(48, 33)" end="(48, 41)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                      <AtomNode start="(48, 42)" end="(48, 45)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                                      <OtherNode start="(48, 46)" end="(48, 49)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(48, 46)" end="(48, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                                        <NullNode start="(48, 48)" end="(48, 49)">
                                          <IdentNode start="(48, 48)" end="(48, 49)" leading="" trailing="" raw_val="a" val="a"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(48, 49)" end="(48, 50)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <IdentNode start="(48, 51)" end="(48, 68)" leading="" trailing=" " raw_val="l.reverse.toArray" val="l.reverse.toArray"/>
                              <IdentNode start="(48, 69)" end="(48, 71)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(48, 72)" end="(49, 18)" kind="Lean.Parser.Term.byTactic'">
                        <AtomNode start="(48, 72)" end="(48, 74)" leading="" trailing="&#10;    " val="by"/>
                        <TacticTacticseqNode start="(49, 5)" end="(49, 18)">
                          <TacticTacticseq1IndentedNode start="(49, 5)" end="(49, 18)">
                            <NullNode start="(49, 5)" end="(49, 18)">
                              <OtherNode start="(49, 5)" end="(49, 18)" kind="Lean.Parser.Tactic.exact" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;this :&#10;  ∀ (l : List β),&#10;    (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l xs =&#10;      List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray xs&#10;⊢ (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) [] xs =&#10;    List.foldlM (fun x y =&amp;gt; x.push &amp;lt;$&amp;gt; f y) #[] xs" state_after="no goals" tactic="exact this []">
                                <AtomNode start="(49, 5)" end="(49, 10)" leading="" trailing=" " val="exact"/>
                                <OtherNode start="(49, 11)" end="(49, 18)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(49, 11)" end="(49, 15)" leading="" trailing=" " raw_val="this" val="this"/>
                                  <NullNode start="(49, 16)" end="(49, 18)">
                                    <OtherNode start="(49, 16)" end="(49, 18)" kind="«term[_]»">
                                      <AtomNode start="(49, 16)" end="(49, 17)" leading="" trailing="" val="["/>
                                      <NullNode/>
                                      <AtomNode start="(49, 17)" end="(49, 18)" leading="" trailing="&#10;  " val="]"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(50, 3)" end="(50, 10)" kind="Lean.Parser.Tactic.intro" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;⊢ ∀ (l : List β),&#10;    (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l xs =&#10;      List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;l : List β&#10;⊢ (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l xs =&#10;    List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray xs" tactic="intro l">
                    <AtomNode start="(50, 3)" end="(50, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(50, 9)" end="(50, 10)">
                      <IdentNode start="(50, 9)" end="(50, 10)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(51, 3)" end="(54, 32)" kind="Lean.Parser.Tactic.induction" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;xs : List α&#10;l : List β&#10;⊢ (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l xs =&#10;    List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray xs" state_after="no goals" tactic="induction xs generalizing l with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp [ih, List.foldlM_cons]">
                    <AtomNode start="(51, 3)" end="(51, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(51, 13)" end="(51, 15)">
                      <OtherNode start="(51, 13)" end="(51, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(51, 13)" end="(51, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(51, 16)" end="(51, 30)">
                      <AtomNode start="(51, 16)" end="(51, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(51, 29)" end="(51, 30)">
                        <IdentNode start="(51, 29)" end="(51, 30)" leading="" trailing=" " raw_val="l" val="l"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(51, 31)" end="(54, 32)">
                      <OtherNode start="(51, 31)" end="(54, 32)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(51, 31)" end="(51, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(52, 3)" end="(54, 32)">
                          <OtherNode start="(52, 3)" end="(52, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(52, 3)" end="(52, 8)">
                              <OtherNode start="(52, 3)" end="(52, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(52, 3)" end="(52, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(52, 5)" end="(52, 8)">
                                  <NullNode/>
                                  <IdentNode start="(52, 5)" end="(52, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(52, 9)" end="(52, 16)">
                              <AtomNode start="(52, 9)" end="(52, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(52, 12)" end="(52, 16)">
                                <TacticTacticseq1IndentedNode start="(52, 12)" end="(52, 16)">
                                  <NullNode start="(52, 12)" end="(52, 16)">
                                    <OtherNode start="(52, 12)" end="(52, 16)" kind="Lean.Parser.Tactic.simp" state_before="case mk.nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l : List β&#10;⊢ (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l [] =&#10;    List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(52, 12)" end="(52, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(53, 3)" end="(54, 32)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(53, 3)" end="(53, 17)">
                              <OtherNode start="(53, 3)" end="(53, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(53, 3)" end="(53, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(53, 5)" end="(53, 9)">
                                  <NullNode/>
                                  <IdentNode start="(53, 5)" end="(53, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(53, 10)" end="(53, 17)">
                                  <IdentNode start="(53, 10)" end="(53, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(53, 12)" end="(53, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(53, 15)" end="(53, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(53, 18)" end="(54, 32)">
                              <AtomNode start="(53, 18)" end="(53, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(54, 5)" end="(54, 32)">
                                <TacticTacticseq1IndentedNode start="(54, 5)" end="(54, 32)">
                                  <NullNode start="(54, 5)" end="(54, 32)">
                                    <OtherNode start="(54, 5)" end="(54, 32)" kind="Lean.Parser.Tactic.simp" state_before="case mk.cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (l : List β),&#10;    (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l as =&#10;      List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray as&#10;l : List β&#10;⊢ (fun l' =&amp;gt; l'.reverse.toArray) &amp;lt;$&amp;gt; List.foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) l (a :: as) =&#10;    List.foldlM (fun acc a =&amp;gt; acc.push &amp;lt;$&amp;gt; f a) l.reverse.toArray (a :: as)" state_after="no goals" tactic="simp [ih, List.foldlM_cons]">
                                      <AtomNode start="(54, 5)" end="(54, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(54, 10)" end="(54, 32)">
                                        <AtomNode start="(54, 10)" end="(54, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(54, 11)" end="(54, 31)">
                                          <OtherNode start="(54, 11)" end="(54, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(54, 11)" end="(54, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(54, 13)" end="(54, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(54, 15)" end="(54, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(54, 15)" end="(54, 31)" leading="" trailing="" raw_val="List.foldlM_cons" val="List.foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(54, 31)" end="(54, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(56, 1)" end="(56, 29)" comment="### foldlM and foldrM -/">
      <AtomNode start="(56, 1)" end="(56, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(56, 5)" end="(56, 29)" leading="" trailing="&#10;&#10;" val="### foldlM and foldrM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(58, 1)" end="(62, 25)" name="foldlM_map" full_name="Array.foldlM_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(58, 1)" end="(62, 25)" name="foldlM_map" full_name="Array.foldlM_map" _is_private_decl="False">
        <AtomNode start="(58, 1)" end="(58, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(58, 9)" end="(58, 19)">
          <IdentNode start="(58, 9)" end="(58, 19)" leading="" trailing=" " raw_val="foldlM_map" val="foldlM_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(58, 20)" end="(59, 83)">
          <NullNode start="(58, 20)" end="(58, 110)">
            <OtherNode start="(58, 20)" end="(58, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(58, 20)" end="(58, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(58, 21)" end="(58, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(58, 21)" end="(58, 26)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(58, 27)" end="(58, 28)">
                  <IdentNode start="(58, 27)" end="(58, 28)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(58, 28)" end="(58, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(58, 30)" end="(58, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 30)" end="(58, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 31)" end="(58, 32)">
                <IdentNode start="(58, 31)" end="(58, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(58, 33)" end="(58, 42)">
                <AtomNode start="(58, 33)" end="(58, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 35)" end="(58, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(58, 35)" end="(58, 37)" leading="" trailing=" " raw_val="β₁" val="β₁"/>
                  <AtomNode start="(58, 38)" end="(58, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(58, 40)" end="(58, 42)" leading="" trailing="" raw_val="β₂" val="β₂"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(58, 42)" end="(58, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(58, 44)" end="(58, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 44)" end="(58, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 45)" end="(58, 46)">
                <IdentNode start="(58, 45)" end="(58, 46)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(58, 47)" end="(58, 61)">
                <AtomNode start="(58, 47)" end="(58, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 49)" end="(58, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(58, 49)" end="(58, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(58, 51)" end="(58, 52)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(58, 53)" end="(58, 61)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(58, 53)" end="(58, 55)" leading="" trailing=" " raw_val="β₂" val="β₂"/>
                    <AtomNode start="(58, 56)" end="(58, 57)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(58, 58)" end="(58, 61)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(58, 58)" end="(58, 59)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(58, 60)" end="(58, 61)">
                        <IdentNode start="(58, 60)" end="(58, 61)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(58, 61)" end="(58, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(58, 63)" end="(58, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 63)" end="(58, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 64)" end="(58, 66)">
                <IdentNode start="(58, 64)" end="(58, 66)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(58, 67)" end="(58, 77)">
                <AtomNode start="(58, 67)" end="(58, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 69)" end="(58, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(58, 69)" end="(58, 74)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(58, 75)" end="(58, 77)">
                    <IdentNode start="(58, 75)" end="(58, 77)" leading="" trailing="" raw_val="β₁" val="β₁"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(58, 77)" end="(58, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(58, 79)" end="(58, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 79)" end="(58, 80)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 80)" end="(58, 84)">
                <IdentNode start="(58, 80)" end="(58, 84)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(58, 85)" end="(58, 88)">
                <AtomNode start="(58, 85)" end="(58, 86)" leading="" trailing=" " val=":"/>
                <IdentNode start="(58, 87)" end="(58, 88)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(58, 88)" end="(58, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(58, 90)" end="(58, 110)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 90)" end="(58, 91)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 91)" end="(58, 92)">
                <IdentNode start="(58, 91)" end="(58, 92)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(58, 93)" end="(58, 109)">
                <AtomNode start="(58, 93)" end="(58, 94)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 95)" end="(58, 109)" kind="«term_=_»">
                  <IdentNode start="(58, 95)" end="(58, 99)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(58, 100)" end="(58, 101)" leading="" trailing=" " val="="/>
                  <IdentNode start="(58, 102)" end="(58, 109)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(58, 109)" end="(58, 110)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(58, 111)" end="(59, 83)">
            <AtomNode start="(58, 111)" end="(58, 112)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(59, 5)" end="(59, 83)" kind="«term_=_»">
              <OtherNode start="(59, 5)" end="(59, 36)" kind="Lean.Parser.Term.app">
                <OtherNode start="(59, 5)" end="(59, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(59, 5)" end="(59, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(59, 5)" end="(59, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(59, 6)" end="(59, 14)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(59, 6)" end="(59, 12)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(59, 13)" end="(59, 14)">
                        <IdentNode start="(59, 13)" end="(59, 14)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(59, 14)" end="(59, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(59, 15)" end="(59, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(59, 16)" end="(59, 22)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="Array.foldlM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(59, 23)" end="(59, 36)">
                  <IdentNode start="(59, 23)" end="(59, 24)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(59, 25)" end="(59, 29)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(59, 30)" end="(59, 31)" kind="num">
                    <AtomNode start="(59, 30)" end="(59, 31)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(59, 32)" end="(59, 36)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(59, 37)" end="(59, 38)" leading="" trailing=" " val="="/>
              <OtherNode start="(59, 39)" end="(59, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(59, 39)" end="(59, 48)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(59, 49)" end="(59, 83)">
                  <OtherNode start="(59, 49)" end="(59, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(59, 49)" end="(59, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(59, 50)" end="(59, 70)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(59, 50)" end="(59, 53)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(59, 54)" end="(59, 70)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(59, 54)" end="(59, 57)">
                          <IdentNode start="(59, 54)" end="(59, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(59, 56)" end="(59, 57)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(59, 58)" end="(59, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(59, 61)" end="(59, 70)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(59, 61)" end="(59, 62)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(59, 63)" end="(59, 70)">
                            <IdentNode start="(59, 63)" end="(59, 64)" leading="" trailing=" " raw_val="x" val="x"/>
                            <OtherNode start="(59, 65)" end="(59, 70)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(59, 65)" end="(59, 66)" leading="" trailing="" val="("/>
                              <OtherNode start="(59, 66)" end="(59, 69)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(59, 66)" end="(59, 67)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(59, 68)" end="(59, 69)">
                                  <IdentNode start="(59, 68)" end="(59, 69)" leading="" trailing="" raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(59, 69)" end="(59, 70)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(59, 70)" end="(59, 71)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(59, 72)" end="(59, 76)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(59, 77)" end="(59, 78)" kind="num">
                    <AtomNode start="(59, 77)" end="(59, 78)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(59, 79)" end="(59, 83)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(59, 84)" end="(62, 25)">
          <AtomNode start="(59, 84)" end="(59, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(59, 87)" end="(62, 25)">
            <AtomNode start="(59, 87)" end="(59, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(60, 3)" end="(62, 25)">
              <TacticTacticseq1IndentedNode start="(60, 3)" end="(62, 25)">
                <NullNode start="(60, 3)" end="(62, 25)">
                  <OtherNode start="(60, 3)" end="(60, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;stop : Nat&#10;inst✝ : Monad m&#10;f : β₁ → β₂&#10;g : α → β₂ → m α&#10;xs : Array β₁&#10;init : α&#10;w : stop = xs.size&#10;⊢ foldlM g init (map f xs) 0 stop = foldlM (fun x y =&amp;gt; g x (f y)) init xs 0 stop" state_after="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝ : Monad m&#10;f : β₁ → β₂&#10;g : α → β₂ → m α&#10;xs : Array β₁&#10;init : α&#10;⊢ foldlM g init (map f xs) 0 xs.size = foldlM (fun x y =&amp;gt; g x (f y)) init xs" tactic="subst w">
                    <AtomNode start="(60, 3)" end="(60, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(60, 9)" end="(60, 10)">
                      <IdentNode start="(60, 9)" end="(60, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(61, 3)" end="(61, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝ : Monad m&#10;f : β₁ → β₂&#10;g : α → β₂ → m α&#10;xs : Array β₁&#10;init : α&#10;⊢ foldlM g init (map f xs) 0 xs.size = foldlM (fun x y =&amp;gt; g x (f y)) init xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝ : Monad m&#10;f : β₁ → β₂&#10;g : α → β₂ → m α&#10;init : α&#10;toList✝ : List β₁&#10;⊢ foldlM g init (map f { toList := toList✝ }) 0 { toList := toList✝ }.size =&#10;    foldlM (fun x y =&amp;gt; g x (f y)) init { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(61, 3)" end="(61, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(61, 9)" end="(61, 11)">
                      <OtherNode start="(61, 9)" end="(61, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(61, 9)" end="(61, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(62, 3)" end="(62, 25)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝ : Monad m&#10;f : β₁ → β₂&#10;g : α → β₂ → m α&#10;init : α&#10;toList✝ : List β₁&#10;⊢ foldlM g init (map f { toList := toList✝ }) 0 { toList := toList✝ }.size =&#10;    foldlM (fun x y =&amp;gt; g x (f y)) init { toList := toList✝ }" state_after="no goals" tactic="simp [List.foldlM_map]">
                    <AtomNode start="(62, 3)" end="(62, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(62, 8)" end="(62, 25)">
                      <AtomNode start="(62, 8)" end="(62, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(62, 9)" end="(62, 24)">
                        <OtherNode start="(62, 9)" end="(62, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(62, 9)" end="(62, 24)" leading="" trailing="" raw_val="List.foldlM_map" val="List.foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(62, 24)" end="(62, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(64, 1)" end="(69, 25)" name="foldrM_map" full_name="Array.foldrM_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(64, 1)" end="(69, 25)" name="foldrM_map" full_name="Array.foldrM_map" _is_private_decl="False">
        <AtomNode start="(64, 1)" end="(64, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(64, 9)" end="(64, 19)">
          <IdentNode start="(64, 9)" end="(64, 19)" leading="" trailing=" " raw_val="foldrM_map" val="foldrM_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(64, 20)" end="(66, 85)">
          <NullNode start="(64, 20)" end="(65, 37)">
            <OtherNode start="(64, 20)" end="(64, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(64, 20)" end="(64, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(64, 21)" end="(64, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(64, 21)" end="(64, 26)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(64, 27)" end="(64, 28)">
                  <IdentNode start="(64, 27)" end="(64, 28)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(64, 28)" end="(64, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(64, 30)" end="(64, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(64, 30)" end="(64, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(64, 31)" end="(64, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(64, 31)" end="(64, 42)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(64, 43)" end="(64, 44)">
                  <IdentNode start="(64, 43)" end="(64, 44)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(64, 44)" end="(64, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(64, 46)" end="(64, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(64, 46)" end="(64, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(64, 47)" end="(64, 48)">
                <IdentNode start="(64, 47)" end="(64, 48)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(64, 49)" end="(64, 58)">
                <AtomNode start="(64, 49)" end="(64, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(64, 51)" end="(64, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(64, 51)" end="(64, 53)" leading="" trailing=" " raw_val="β₁" val="β₁"/>
                  <AtomNode start="(64, 54)" end="(64, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(64, 56)" end="(64, 58)" leading="" trailing="" raw_val="β₂" val="β₂"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(64, 58)" end="(64, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(64, 60)" end="(64, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(64, 60)" end="(64, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(64, 61)" end="(64, 62)">
                <IdentNode start="(64, 61)" end="(64, 62)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(64, 63)" end="(64, 77)">
                <AtomNode start="(64, 63)" end="(64, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(64, 65)" end="(64, 77)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(64, 65)" end="(64, 67)" leading="" trailing=" " raw_val="β₂" val="β₂"/>
                  <AtomNode start="(64, 68)" end="(64, 69)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(64, 70)" end="(64, 77)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(64, 70)" end="(64, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(64, 72)" end="(64, 73)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(64, 74)" end="(64, 77)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(64, 74)" end="(64, 75)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(64, 76)" end="(64, 77)">
                        <IdentNode start="(64, 76)" end="(64, 77)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(64, 77)" end="(64, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(64, 79)" end="(64, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(64, 79)" end="(64, 80)" leading="" trailing="" val="{"/>
              <NullNode start="(64, 80)" end="(64, 82)">
                <IdentNode start="(64, 80)" end="(64, 82)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(64, 83)" end="(64, 93)">
                <AtomNode start="(64, 83)" end="(64, 84)" leading="" trailing=" " val=":"/>
                <OtherNode start="(64, 85)" end="(64, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(64, 85)" end="(64, 90)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(64, 91)" end="(64, 93)">
                    <IdentNode start="(64, 91)" end="(64, 93)" leading="" trailing="" raw_val="β₁" val="β₁"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(64, 93)" end="(64, 94)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(65, 5)" end="(65, 15)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(65, 5)" end="(65, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(65, 6)" end="(65, 10)">
                <IdentNode start="(65, 6)" end="(65, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(65, 11)" end="(65, 14)">
                <AtomNode start="(65, 11)" end="(65, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(65, 13)" end="(65, 14)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(65, 14)" end="(65, 15)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(65, 16)" end="(65, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(65, 16)" end="(65, 17)" leading="" trailing="" val="{"/>
              <NullNode start="(65, 17)" end="(65, 18)">
                <IdentNode start="(65, 17)" end="(65, 18)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(65, 19)" end="(65, 36)">
                <AtomNode start="(65, 19)" end="(65, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(65, 21)" end="(65, 36)" kind="«term_=_»">
                  <IdentNode start="(65, 21)" end="(65, 26)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(65, 27)" end="(65, 28)" leading="" trailing=" " val="="/>
                  <IdentNode start="(65, 29)" end="(65, 36)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(65, 36)" end="(65, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(65, 38)" end="(66, 85)">
            <AtomNode start="(65, 38)" end="(65, 39)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(66, 5)" end="(66, 85)" kind="«term_=_»">
              <OtherNode start="(66, 5)" end="(66, 37)" kind="Lean.Parser.Term.app">
                <OtherNode start="(66, 5)" end="(66, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(66, 5)" end="(66, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(66, 5)" end="(66, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(66, 6)" end="(66, 14)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(66, 6)" end="(66, 12)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(66, 13)" end="(66, 14)">
                        <IdentNode start="(66, 13)" end="(66, 14)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(66, 14)" end="(66, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(66, 15)" end="(66, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(66, 16)" end="(66, 22)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="Array.foldrM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(66, 23)" end="(66, 37)">
                  <IdentNode start="(66, 23)" end="(66, 24)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(66, 25)" end="(66, 29)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(66, 30)" end="(66, 35)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(66, 36)" end="(66, 37)" kind="num">
                    <AtomNode start="(66, 36)" end="(66, 37)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(66, 38)" end="(66, 39)" leading="" trailing=" " val="="/>
              <OtherNode start="(66, 40)" end="(66, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(66, 40)" end="(66, 49)" leading="" trailing=" " raw_val="xs.foldrM" val="xs.foldrM"/>
                <NullNode start="(66, 50)" end="(66, 85)">
                  <OtherNode start="(66, 50)" end="(66, 72)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(66, 50)" end="(66, 51)" leading="" trailing="" val="("/>
                    <OtherNode start="(66, 51)" end="(66, 71)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(66, 51)" end="(66, 54)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(66, 55)" end="(66, 71)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(66, 55)" end="(66, 58)">
                          <IdentNode start="(66, 55)" end="(66, 56)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(66, 57)" end="(66, 58)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(66, 59)" end="(66, 61)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(66, 62)" end="(66, 71)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(66, 62)" end="(66, 63)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(66, 64)" end="(66, 71)">
                            <OtherNode start="(66, 64)" end="(66, 69)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(66, 64)" end="(66, 65)" leading="" trailing="" val="("/>
                              <OtherNode start="(66, 65)" end="(66, 68)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(66, 65)" end="(66, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(66, 67)" end="(66, 68)">
                                  <IdentNode start="(66, 67)" end="(66, 68)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(66, 68)" end="(66, 69)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(66, 70)" end="(66, 71)" leading="" trailing="" raw_val="y" val="y"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(66, 71)" end="(66, 72)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(66, 73)" end="(66, 77)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(66, 78)" end="(66, 83)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(66, 84)" end="(66, 85)" kind="num">
                    <AtomNode start="(66, 84)" end="(66, 85)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(66, 86)" end="(69, 25)">
          <AtomNode start="(66, 86)" end="(66, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(66, 89)" end="(69, 25)">
            <AtomNode start="(66, 89)" end="(66, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(67, 3)" end="(69, 25)">
              <TacticTacticseq1IndentedNode start="(67, 3)" end="(69, 25)">
                <NullNode start="(67, 3)" end="(69, 25)">
                  <OtherNode start="(67, 3)" end="(67, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;start : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : β₁ → β₂&#10;g : β₂ → α → m α&#10;xs : Array β₁&#10;init : α&#10;w : start = xs.size&#10;⊢ foldrM g init (map f xs) start = foldrM (fun x y =&amp;gt; g (f x) y) init xs start" state_after="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : β₁ → β₂&#10;g : β₂ → α → m α&#10;xs : Array β₁&#10;init : α&#10;⊢ foldrM g init (map f xs) xs.size = foldrM (fun x y =&amp;gt; g (f x) y) init xs" tactic="subst w">
                    <AtomNode start="(67, 3)" end="(67, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(67, 9)" end="(67, 10)">
                      <IdentNode start="(67, 9)" end="(67, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(68, 3)" end="(68, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : β₁ → β₂&#10;g : β₂ → α → m α&#10;xs : Array β₁&#10;init : α&#10;⊢ foldrM g init (map f xs) xs.size = foldrM (fun x y =&amp;gt; g (f x) y) init xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : β₁ → β₂&#10;g : β₂ → α → m α&#10;init : α&#10;toList✝ : List β₁&#10;⊢ foldrM g init (map f { toList := toList✝ }) { toList := toList✝ }.size =&#10;    foldrM (fun x y =&amp;gt; g (f x) y) init { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(68, 3)" end="(68, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(68, 9)" end="(68, 11)">
                      <OtherNode start="(68, 9)" end="(68, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(68, 9)" end="(68, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(69, 3)" end="(69, 25)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : β₁ → β₂&#10;g : β₂ → α → m α&#10;init : α&#10;toList✝ : List β₁&#10;⊢ foldrM g init (map f { toList := toList✝ }) { toList := toList✝ }.size =&#10;    foldrM (fun x y =&amp;gt; g (f x) y) init { toList := toList✝ }" state_after="no goals" tactic="simp [List.foldrM_map]">
                    <AtomNode start="(69, 3)" end="(69, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(69, 8)" end="(69, 25)">
                      <AtomNode start="(69, 8)" end="(69, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(69, 9)" end="(69, 24)">
                        <OtherNode start="(69, 9)" end="(69, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(69, 9)" end="(69, 24)" leading="" trailing="" raw_val="List.foldrM_map" val="List.foldrM_map" full_name="List.foldrM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(69, 24)" end="(69, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(71, 1)" end="(78, 6)" name="foldlM_filterMap" full_name="Array.foldlM_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(71, 1)" end="(78, 6)" name="foldlM_filterMap" full_name="Array.foldlM_filterMap" _is_private_decl="False">
        <AtomNode start="(71, 1)" end="(71, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(71, 9)" end="(71, 25)">
          <IdentNode start="(71, 9)" end="(71, 25)" leading="" trailing=" " raw_val="foldlM_filterMap" val="foldlM_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(71, 26)" end="(74, 84)">
          <NullNode start="(71, 26)" end="(72, 50)">
            <OtherNode start="(71, 26)" end="(71, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(71, 26)" end="(71, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(71, 27)" end="(71, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(71, 27)" end="(71, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(71, 33)" end="(71, 34)">
                  <IdentNode start="(71, 33)" end="(71, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(71, 34)" end="(71, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(71, 36)" end="(71, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(71, 36)" end="(71, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(71, 37)" end="(71, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(71, 37)" end="(71, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(71, 49)" end="(71, 50)">
                  <IdentNode start="(71, 49)" end="(71, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(71, 50)" end="(71, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(71, 52)" end="(71, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(71, 52)" end="(71, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(71, 53)" end="(71, 54)">
                <IdentNode start="(71, 53)" end="(71, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(71, 55)" end="(71, 69)">
                <AtomNode start="(71, 55)" end="(71, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(71, 57)" end="(71, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(71, 57)" end="(71, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(71, 59)" end="(71, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(71, 61)" end="(71, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(71, 61)" end="(71, 67)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(71, 68)" end="(71, 69)">
                      <IdentNode start="(71, 68)" end="(71, 69)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(71, 69)" end="(71, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(71, 71)" end="(71, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(71, 71)" end="(71, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(71, 72)" end="(71, 73)">
                <IdentNode start="(71, 72)" end="(71, 73)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(71, 74)" end="(71, 87)">
                <AtomNode start="(71, 74)" end="(71, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(71, 76)" end="(71, 87)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(71, 76)" end="(71, 77)" leading="" trailing=" " raw_val="γ" val="γ"/>
                  <AtomNode start="(71, 78)" end="(71, 79)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(71, 80)" end="(71, 87)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(71, 80)" end="(71, 81)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(71, 82)" end="(71, 83)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(71, 84)" end="(71, 87)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(71, 84)" end="(71, 85)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(71, 86)" end="(71, 87)">
                        <IdentNode start="(71, 86)" end="(71, 87)" leading="" trailing="" raw_val="γ" val="γ"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(71, 87)" end="(71, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(71, 89)" end="(71, 103)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(71, 89)" end="(71, 90)" leading="" trailing="" val="{"/>
              <NullNode start="(71, 90)" end="(71, 92)">
                <IdentNode start="(71, 90)" end="(71, 92)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(71, 93)" end="(71, 102)">
                <AtomNode start="(71, 93)" end="(71, 94)" leading="" trailing=" " val=":"/>
                <OtherNode start="(71, 95)" end="(71, 102)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(71, 95)" end="(71, 100)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(71, 101)" end="(71, 102)">
                    <IdentNode start="(71, 101)" end="(71, 102)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(71, 102)" end="(71, 103)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(72, 5)" end="(72, 15)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(72, 5)" end="(72, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(72, 6)" end="(72, 10)">
                <IdentNode start="(72, 6)" end="(72, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(72, 11)" end="(72, 14)">
                <AtomNode start="(72, 11)" end="(72, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(72, 13)" end="(72, 14)" leading="" trailing="" raw_val="γ" val="γ"/>
              </NullNode>
              <AtomNode start="(72, 14)" end="(72, 15)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(72, 16)" end="(72, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(72, 16)" end="(72, 17)" leading="" trailing="" val="{"/>
              <NullNode start="(72, 17)" end="(72, 18)">
                <IdentNode start="(72, 17)" end="(72, 18)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(72, 19)" end="(72, 49)">
                <AtomNode start="(72, 19)" end="(72, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(72, 21)" end="(72, 49)" kind="«term_=_»">
                  <IdentNode start="(72, 21)" end="(72, 25)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(72, 26)" end="(72, 27)" leading="" trailing=" " val="="/>
                  <OtherNode start="(72, 28)" end="(72, 49)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(72, 28)" end="(72, 44)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(72, 28)" end="(72, 29)" leading="" trailing="" val="("/>
                      <OtherNode start="(72, 29)" end="(72, 43)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(72, 29)" end="(72, 41)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                        <NullNode start="(72, 42)" end="(72, 43)">
                          <IdentNode start="(72, 42)" end="(72, 43)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(72, 43)" end="(72, 44)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(72, 44)" end="(72, 45)" leading="" trailing="" val="."/>
                    <IdentNode start="(72, 45)" end="(72, 49)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(72, 49)" end="(72, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(72, 51)" end="(74, 84)">
            <AtomNode start="(72, 51)" end="(72, 52)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(73, 5)" end="(74, 84)" kind="«term_=_»">
              <OtherNode start="(73, 5)" end="(73, 42)" kind="Lean.Parser.Term.app">
                <OtherNode start="(73, 5)" end="(73, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(73, 5)" end="(73, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(73, 5)" end="(73, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(73, 6)" end="(73, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(73, 6)" end="(73, 18)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                      <NullNode start="(73, 19)" end="(73, 20)">
                        <IdentNode start="(73, 19)" end="(73, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(73, 20)" end="(73, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(73, 21)" end="(73, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(73, 22)" end="(73, 28)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="Array.foldlM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(73, 29)" end="(73, 42)">
                  <IdentNode start="(73, 29)" end="(73, 30)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(73, 31)" end="(73, 35)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(73, 36)" end="(73, 37)" kind="num">
                    <AtomNode start="(73, 36)" end="(73, 37)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(73, 38)" end="(73, 42)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(73, 43)" end="(73, 44)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(74, 7)" end="(74, 84)" kind="Lean.Parser.Term.app">
                <IdentNode start="(74, 7)" end="(74, 16)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(74, 17)" end="(74, 84)">
                  <OtherNode start="(74, 17)" end="(74, 79)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(74, 17)" end="(74, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(74, 18)" end="(74, 78)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(74, 18)" end="(74, 21)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(74, 22)" end="(74, 78)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(74, 22)" end="(74, 25)">
                          <IdentNode start="(74, 22)" end="(74, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(74, 24)" end="(74, 25)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(74, 26)" end="(74, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(74, 29)" end="(74, 78)" kind="Lean.Parser.Term.match">
                          <AtomNode start="(74, 29)" end="(74, 34)" leading="" trailing=" " val="match"/>
                          <NullNode/>
                          <NullNode/>
                          <NullNode start="(74, 35)" end="(74, 38)">
                            <OtherNode start="(74, 35)" end="(74, 38)" kind="Lean.Parser.Term.matchDiscr">
                              <NullNode/>
                              <OtherNode start="(74, 35)" end="(74, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(74, 35)" end="(74, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(74, 37)" end="(74, 38)">
                                  <IdentNode start="(74, 37)" end="(74, 38)" leading="" trailing=" " raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(74, 39)" end="(74, 43)" leading="" trailing=" " val="with"/>
                          <OtherNode start="(74, 44)" end="(74, 78)" kind="Lean.Parser.Term.matchAlts">
                            <NullNode start="(74, 44)" end="(74, 78)">
                              <OtherNode start="(74, 44)" end="(74, 61)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(74, 44)" end="(74, 45)" leading="" trailing=" " val="|"/>
                                <NullNode start="(74, 46)" end="(74, 52)">
                                  <NullNode start="(74, 46)" end="(74, 52)">
                                    <OtherNode start="(74, 46)" end="(74, 52)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(74, 46)" end="(74, 50)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(74, 51)" end="(74, 52)">
                                        <IdentNode start="(74, 51)" end="(74, 52)" leading="" trailing=" " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(74, 53)" end="(74, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(74, 56)" end="(74, 61)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(74, 56)" end="(74, 57)" leading="" trailing=" " raw_val="g" val="g"/>
                                  <NullNode start="(74, 58)" end="(74, 61)">
                                    <IdentNode start="(74, 58)" end="(74, 59)" leading="" trailing=" " raw_val="x" val="x"/>
                                    <IdentNode start="(74, 60)" end="(74, 61)" leading="" trailing=" " raw_val="b" val="b"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(74, 62)" end="(74, 78)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(74, 62)" end="(74, 63)" leading="" trailing=" " val="|"/>
                                <NullNode start="(74, 64)" end="(74, 68)">
                                  <NullNode start="(74, 64)" end="(74, 68)">
                                    <IdentNode start="(74, 64)" end="(74, 68)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(74, 69)" end="(74, 71)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(74, 72)" end="(74, 78)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(74, 72)" end="(74, 76)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(74, 77)" end="(74, 78)">
                                    <IdentNode start="(74, 77)" end="(74, 78)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(74, 78)" end="(74, 79)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(74, 80)" end="(74, 84)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(74, 85)" end="(78, 6)">
          <AtomNode start="(74, 85)" end="(74, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(74, 88)" end="(78, 6)">
            <AtomNode start="(74, 88)" end="(74, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(75, 3)" end="(78, 6)">
              <TacticTacticseq1IndentedNode start="(75, 3)" end="(78, 6)">
                <NullNode start="(75, 3)" end="(78, 6)">
                  <OtherNode start="(75, 3)" end="(75, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;stop : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;xs : Array α&#10;init : γ&#10;w : stop = (filterMap f xs).size&#10;⊢ foldlM g init (filterMap f xs) 0 stop =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init xs" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;xs : Array α&#10;init : γ&#10;⊢ foldlM g init (filterMap f xs) =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init xs" tactic="subst w">
                    <AtomNode start="(75, 3)" end="(75, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(75, 9)" end="(75, 10)">
                      <IdentNode start="(75, 9)" end="(75, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(76, 3)" end="(76, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;xs : Array α&#10;init : γ&#10;⊢ foldlM g init (filterMap f xs) =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ foldlM g init (filterMap f { toList := toList✝ }) =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(76, 3)" end="(76, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(76, 9)" end="(76, 11)">
                      <OtherNode start="(76, 9)" end="(76, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(76, 9)" end="(76, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(77, 3)" end="(77, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ foldlM g init (filterMap f { toList := toList✝ }) =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init { toList := toList✝ }" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ List.foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init toList✝ =&#10;    List.foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init toList✝" tactic="simp [List.foldlM_filterMap]">
                    <AtomNode start="(77, 3)" end="(77, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(77, 8)" end="(77, 31)">
                      <AtomNode start="(77, 8)" end="(77, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(77, 9)" end="(77, 30)">
                        <OtherNode start="(77, 9)" end="(77, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(77, 9)" end="(77, 30)" leading="" trailing="" raw_val="List.foldlM_filterMap" val="List.foldlM_filterMap" full_name="List.foldlM_filterMap" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(77, 30)" end="(77, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(78, 3)" end="(78, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ List.foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init toList✝ =&#10;    List.foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init toList✝" state_after="no goals" tactic="rfl">
                    <AtomNode start="(78, 3)" end="(78, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(80, 1)" end="(87, 6)" name="foldrM_filterMap" full_name="Array.foldrM_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(80, 1)" end="(87, 6)" name="foldrM_filterMap" full_name="Array.foldrM_filterMap" _is_private_decl="False">
        <AtomNode start="(80, 1)" end="(80, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(80, 9)" end="(80, 25)">
          <IdentNode start="(80, 9)" end="(80, 25)" leading="" trailing=" " raw_val="foldrM_filterMap" val="foldrM_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(80, 26)" end="(83, 84)">
          <NullNode start="(80, 26)" end="(81, 51)">
            <OtherNode start="(80, 26)" end="(80, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(80, 26)" end="(80, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(80, 27)" end="(80, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(80, 27)" end="(80, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(80, 33)" end="(80, 34)">
                  <IdentNode start="(80, 33)" end="(80, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(80, 34)" end="(80, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(80, 36)" end="(80, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(80, 36)" end="(80, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(80, 37)" end="(80, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(80, 37)" end="(80, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(80, 49)" end="(80, 50)">
                  <IdentNode start="(80, 49)" end="(80, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(80, 50)" end="(80, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(80, 52)" end="(80, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(80, 52)" end="(80, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(80, 53)" end="(80, 54)">
                <IdentNode start="(80, 53)" end="(80, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(80, 55)" end="(80, 69)">
                <AtomNode start="(80, 55)" end="(80, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(80, 57)" end="(80, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(80, 57)" end="(80, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(80, 59)" end="(80, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(80, 61)" end="(80, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(80, 61)" end="(80, 67)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(80, 68)" end="(80, 69)">
                      <IdentNode start="(80, 68)" end="(80, 69)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(80, 69)" end="(80, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(80, 71)" end="(80, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(80, 71)" end="(80, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(80, 72)" end="(80, 73)">
                <IdentNode start="(80, 72)" end="(80, 73)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(80, 74)" end="(80, 87)">
                <AtomNode start="(80, 74)" end="(80, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(80, 76)" end="(80, 87)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(80, 76)" end="(80, 77)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(80, 78)" end="(80, 79)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(80, 80)" end="(80, 87)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(80, 80)" end="(80, 81)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    <AtomNode start="(80, 82)" end="(80, 83)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(80, 84)" end="(80, 87)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(80, 84)" end="(80, 85)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(80, 86)" end="(80, 87)">
                        <IdentNode start="(80, 86)" end="(80, 87)" leading="" trailing="" raw_val="γ" val="γ"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(80, 87)" end="(80, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(80, 89)" end="(80, 103)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(80, 89)" end="(80, 90)" leading="" trailing="" val="{"/>
              <NullNode start="(80, 90)" end="(80, 92)">
                <IdentNode start="(80, 90)" end="(80, 92)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(80, 93)" end="(80, 102)">
                <AtomNode start="(80, 93)" end="(80, 94)" leading="" trailing=" " val=":"/>
                <OtherNode start="(80, 95)" end="(80, 102)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(80, 95)" end="(80, 100)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(80, 101)" end="(80, 102)">
                    <IdentNode start="(80, 101)" end="(80, 102)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(80, 102)" end="(80, 103)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(81, 5)" end="(81, 15)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(81, 5)" end="(81, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(81, 6)" end="(81, 10)">
                <IdentNode start="(81, 6)" end="(81, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(81, 11)" end="(81, 14)">
                <AtomNode start="(81, 11)" end="(81, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(81, 13)" end="(81, 14)" leading="" trailing="" raw_val="γ" val="γ"/>
              </NullNode>
              <AtomNode start="(81, 14)" end="(81, 15)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(81, 16)" end="(81, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(81, 16)" end="(81, 17)" leading="" trailing="" val="{"/>
              <NullNode start="(81, 17)" end="(81, 18)">
                <IdentNode start="(81, 17)" end="(81, 18)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(81, 19)" end="(81, 50)">
                <AtomNode start="(81, 19)" end="(81, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(81, 21)" end="(81, 50)" kind="«term_=_»">
                  <IdentNode start="(81, 21)" end="(81, 26)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(81, 27)" end="(81, 28)" leading="" trailing=" " val="="/>
                  <OtherNode start="(81, 29)" end="(81, 50)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(81, 29)" end="(81, 45)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(81, 29)" end="(81, 30)" leading="" trailing="" val="("/>
                      <OtherNode start="(81, 30)" end="(81, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(81, 30)" end="(81, 42)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                        <NullNode start="(81, 43)" end="(81, 44)">
                          <IdentNode start="(81, 43)" end="(81, 44)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(81, 44)" end="(81, 45)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(81, 45)" end="(81, 46)" leading="" trailing="" val="."/>
                    <IdentNode start="(81, 46)" end="(81, 50)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(81, 50)" end="(81, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(81, 52)" end="(83, 84)">
            <AtomNode start="(81, 52)" end="(81, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(82, 5)" end="(83, 84)" kind="«term_=_»">
              <OtherNode start="(82, 5)" end="(82, 43)" kind="Lean.Parser.Term.app">
                <OtherNode start="(82, 5)" end="(82, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(82, 5)" end="(82, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(82, 5)" end="(82, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(82, 6)" end="(82, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(82, 6)" end="(82, 18)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                      <NullNode start="(82, 19)" end="(82, 20)">
                        <IdentNode start="(82, 19)" end="(82, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(82, 20)" end="(82, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(82, 21)" end="(82, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(82, 22)" end="(82, 28)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="Array.foldrM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(82, 29)" end="(82, 43)">
                  <IdentNode start="(82, 29)" end="(82, 30)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(82, 31)" end="(82, 35)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(82, 36)" end="(82, 41)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(82, 42)" end="(82, 43)" kind="num">
                    <AtomNode start="(82, 42)" end="(82, 43)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(82, 44)" end="(82, 45)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(83, 7)" end="(83, 84)" kind="Lean.Parser.Term.app">
                <IdentNode start="(83, 7)" end="(83, 16)" leading="" trailing=" " raw_val="xs.foldrM" val="xs.foldrM"/>
                <NullNode start="(83, 17)" end="(83, 84)">
                  <OtherNode start="(83, 17)" end="(83, 79)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(83, 17)" end="(83, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(83, 18)" end="(83, 78)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(83, 18)" end="(83, 21)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(83, 22)" end="(83, 78)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(83, 22)" end="(83, 25)">
                          <IdentNode start="(83, 22)" end="(83, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(83, 24)" end="(83, 25)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(83, 26)" end="(83, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(83, 29)" end="(83, 78)" kind="Lean.Parser.Term.match">
                          <AtomNode start="(83, 29)" end="(83, 34)" leading="" trailing=" " val="match"/>
                          <NullNode/>
                          <NullNode/>
                          <NullNode start="(83, 35)" end="(83, 38)">
                            <OtherNode start="(83, 35)" end="(83, 38)" kind="Lean.Parser.Term.matchDiscr">
                              <NullNode/>
                              <OtherNode start="(83, 35)" end="(83, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(83, 35)" end="(83, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(83, 37)" end="(83, 38)">
                                  <IdentNode start="(83, 37)" end="(83, 38)" leading="" trailing=" " raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(83, 39)" end="(83, 43)" leading="" trailing=" " val="with"/>
                          <OtherNode start="(83, 44)" end="(83, 78)" kind="Lean.Parser.Term.matchAlts">
                            <NullNode start="(83, 44)" end="(83, 78)">
                              <OtherNode start="(83, 44)" end="(83, 61)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(83, 44)" end="(83, 45)" leading="" trailing=" " val="|"/>
                                <NullNode start="(83, 46)" end="(83, 52)">
                                  <NullNode start="(83, 46)" end="(83, 52)">
                                    <OtherNode start="(83, 46)" end="(83, 52)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(83, 46)" end="(83, 50)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(83, 51)" end="(83, 52)">
                                        <IdentNode start="(83, 51)" end="(83, 52)" leading="" trailing=" " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(83, 53)" end="(83, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(83, 56)" end="(83, 61)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(83, 56)" end="(83, 57)" leading="" trailing=" " raw_val="g" val="g"/>
                                  <NullNode start="(83, 58)" end="(83, 61)">
                                    <IdentNode start="(83, 58)" end="(83, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <IdentNode start="(83, 60)" end="(83, 61)" leading="" trailing=" " raw_val="y" val="y"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(83, 62)" end="(83, 78)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(83, 62)" end="(83, 63)" leading="" trailing=" " val="|"/>
                                <NullNode start="(83, 64)" end="(83, 68)">
                                  <NullNode start="(83, 64)" end="(83, 68)">
                                    <IdentNode start="(83, 64)" end="(83, 68)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(83, 69)" end="(83, 71)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(83, 72)" end="(83, 78)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(83, 72)" end="(83, 76)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(83, 77)" end="(83, 78)">
                                    <IdentNode start="(83, 77)" end="(83, 78)" leading="" trailing="" raw_val="y" val="y"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(83, 78)" end="(83, 79)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(83, 80)" end="(83, 84)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(83, 85)" end="(87, 6)">
          <AtomNode start="(83, 85)" end="(83, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(83, 88)" end="(87, 6)">
            <AtomNode start="(83, 88)" end="(83, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(84, 3)" end="(87, 6)">
              <TacticTacticseq1IndentedNode start="(84, 3)" end="(87, 6)">
                <NullNode start="(84, 3)" end="(87, 6)">
                  <OtherNode start="(84, 3)" end="(84, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;start : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;xs : Array α&#10;init : γ&#10;w : start = (filterMap f xs).size&#10;⊢ foldrM g init (filterMap f xs) start =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init xs" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;xs : Array α&#10;init : γ&#10;⊢ foldrM g init (filterMap f xs) =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init xs" tactic="subst w">
                    <AtomNode start="(84, 3)" end="(84, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(84, 9)" end="(84, 10)">
                      <IdentNode start="(84, 9)" end="(84, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(85, 3)" end="(85, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;xs : Array α&#10;init : γ&#10;⊢ foldrM g init (filterMap f xs) =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ foldrM g init (filterMap f { toList := toList✝ }) =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(85, 3)" end="(85, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(85, 9)" end="(85, 11)">
                      <OtherNode start="(85, 9)" end="(85, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(85, 9)" end="(85, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(86, 3)" end="(86, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ foldrM g init (filterMap f { toList := toList✝ }) =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init { toList := toList✝ }" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ List.foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init toList✝ =&#10;    List.foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init toList✝" tactic="simp [List.foldrM_filterMap]">
                    <AtomNode start="(86, 3)" end="(86, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(86, 8)" end="(86, 31)">
                      <AtomNode start="(86, 8)" end="(86, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 9)" end="(86, 30)">
                        <OtherNode start="(86, 9)" end="(86, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 9)" end="(86, 30)" leading="" trailing="" raw_val="List.foldrM_filterMap" val="List.foldrM_filterMap" full_name="List.foldrM_filterMap" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 30)" end="(86, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(87, 3)" end="(87, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;init : γ&#10;toList✝ : List α&#10;⊢ List.foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init toList✝ =&#10;    List.foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init toList✝" state_after="no goals" tactic="rfl">
                    <AtomNode start="(87, 3)" end="(87, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(89, 1)" end="(95, 28)" name="foldlM_filter" full_name="Array.foldlM_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(89, 1)" end="(95, 28)" name="foldlM_filter" full_name="Array.foldlM_filter" _is_private_decl="False">
        <AtomNode start="(89, 1)" end="(89, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(89, 9)" end="(89, 22)">
          <IdentNode start="(89, 9)" end="(89, 22)" leading="" trailing=" " raw_val="foldlM_filter" val="foldlM_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(89, 23)" end="(92, 64)">
          <NullNode start="(89, 23)" end="(90, 47)">
            <OtherNode start="(89, 23)" end="(89, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(89, 23)" end="(89, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(89, 24)" end="(89, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(89, 24)" end="(89, 29)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(89, 30)" end="(89, 31)">
                  <IdentNode start="(89, 30)" end="(89, 31)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(89, 31)" end="(89, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(89, 33)" end="(89, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(89, 33)" end="(89, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(89, 34)" end="(89, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(89, 34)" end="(89, 45)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(89, 46)" end="(89, 47)">
                  <IdentNode start="(89, 46)" end="(89, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(89, 47)" end="(89, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(89, 49)" end="(89, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(89, 49)" end="(89, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(89, 50)" end="(89, 51)">
                <IdentNode start="(89, 50)" end="(89, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(89, 52)" end="(89, 62)">
                <AtomNode start="(89, 52)" end="(89, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(89, 54)" end="(89, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(89, 54)" end="(89, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(89, 56)" end="(89, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(89, 58)" end="(89, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(89, 62)" end="(89, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(89, 64)" end="(89, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(89, 64)" end="(89, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(89, 65)" end="(89, 66)">
                <IdentNode start="(89, 65)" end="(89, 66)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(89, 67)" end="(89, 80)">
                <AtomNode start="(89, 67)" end="(89, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(89, 69)" end="(89, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(89, 69)" end="(89, 70)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(89, 71)" end="(89, 72)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(89, 73)" end="(89, 80)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(89, 73)" end="(89, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(89, 75)" end="(89, 76)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(89, 77)" end="(89, 80)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(89, 77)" end="(89, 78)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(89, 79)" end="(89, 80)">
                        <IdentNode start="(89, 79)" end="(89, 80)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(89, 80)" end="(89, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(89, 82)" end="(89, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(89, 82)" end="(89, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(89, 83)" end="(89, 85)">
                <IdentNode start="(89, 83)" end="(89, 85)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(89, 86)" end="(89, 95)">
                <AtomNode start="(89, 86)" end="(89, 87)" leading="" trailing=" " val=":"/>
                <OtherNode start="(89, 88)" end="(89, 95)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(89, 88)" end="(89, 93)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(89, 94)" end="(89, 95)">
                    <IdentNode start="(89, 94)" end="(89, 95)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(89, 95)" end="(89, 96)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(90, 5)" end="(90, 15)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(90, 5)" end="(90, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(90, 6)" end="(90, 10)">
                <IdentNode start="(90, 6)" end="(90, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(90, 11)" end="(90, 14)">
                <AtomNode start="(90, 11)" end="(90, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(90, 13)" end="(90, 14)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(90, 14)" end="(90, 15)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(90, 16)" end="(90, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(90, 16)" end="(90, 17)" leading="" trailing="" val="{"/>
              <NullNode start="(90, 17)" end="(90, 18)">
                <IdentNode start="(90, 17)" end="(90, 18)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(90, 19)" end="(90, 46)">
                <AtomNode start="(90, 19)" end="(90, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(90, 21)" end="(90, 46)" kind="«term_=_»">
                  <IdentNode start="(90, 21)" end="(90, 25)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(90, 26)" end="(90, 27)" leading="" trailing=" " val="="/>
                  <OtherNode start="(90, 28)" end="(90, 46)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(90, 28)" end="(90, 41)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(90, 28)" end="(90, 29)" leading="" trailing="" val="("/>
                      <OtherNode start="(90, 29)" end="(90, 40)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(90, 29)" end="(90, 38)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                        <NullNode start="(90, 39)" end="(90, 40)">
                          <IdentNode start="(90, 39)" end="(90, 40)" leading="" trailing="" raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(90, 40)" end="(90, 41)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(90, 41)" end="(90, 42)" leading="" trailing="" val="."/>
                    <IdentNode start="(90, 42)" end="(90, 46)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(90, 46)" end="(90, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(90, 48)" end="(92, 64)">
            <AtomNode start="(90, 48)" end="(90, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(91, 5)" end="(92, 64)" kind="«term_=_»">
              <OtherNode start="(91, 5)" end="(91, 39)" kind="Lean.Parser.Term.app">
                <OtherNode start="(91, 5)" end="(91, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(91, 5)" end="(91, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(91, 5)" end="(91, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(91, 6)" end="(91, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(91, 6)" end="(91, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                      <NullNode start="(91, 16)" end="(91, 17)">
                        <IdentNode start="(91, 16)" end="(91, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(91, 17)" end="(91, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(91, 18)" end="(91, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(91, 19)" end="(91, 25)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="Array.foldlM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(91, 26)" end="(91, 39)">
                  <IdentNode start="(91, 26)" end="(91, 27)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(91, 28)" end="(91, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(91, 33)" end="(91, 34)" kind="num">
                    <AtomNode start="(91, 33)" end="(91, 34)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(91, 35)" end="(91, 39)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(91, 40)" end="(91, 41)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(92, 7)" end="(92, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(92, 7)" end="(92, 16)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(92, 17)" end="(92, 64)">
                  <OtherNode start="(92, 17)" end="(92, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(92, 17)" end="(92, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(92, 18)" end="(92, 58)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(92, 18)" end="(92, 21)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(92, 22)" end="(92, 58)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(92, 22)" end="(92, 25)">
                          <IdentNode start="(92, 22)" end="(92, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(92, 24)" end="(92, 25)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(92, 26)" end="(92, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(92, 29)" end="(92, 58)" kind="termIfThenElse">
                          <AtomNode start="(92, 29)" end="(92, 31)" leading="" trailing=" " val="if"/>
                          <OtherNode start="(92, 32)" end="(92, 35)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(92, 32)" end="(92, 33)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(92, 34)" end="(92, 35)">
                              <IdentNode start="(92, 34)" end="(92, 35)" leading="" trailing=" " raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(92, 36)" end="(92, 40)" leading="" trailing=" " val="then"/>
                          <OtherNode start="(92, 41)" end="(92, 46)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(92, 41)" end="(92, 42)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(92, 43)" end="(92, 46)">
                              <IdentNode start="(92, 43)" end="(92, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                              <IdentNode start="(92, 45)" end="(92, 46)" leading="" trailing=" " raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(92, 47)" end="(92, 51)" leading="" trailing=" " val="else"/>
                          <OtherNode start="(92, 52)" end="(92, 58)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(92, 52)" end="(92, 56)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(92, 57)" end="(92, 58)">
                              <IdentNode start="(92, 57)" end="(92, 58)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(92, 58)" end="(92, 59)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(92, 60)" end="(92, 64)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(92, 65)" end="(95, 28)">
          <AtomNode start="(92, 65)" end="(92, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(92, 68)" end="(95, 28)">
            <AtomNode start="(92, 68)" end="(92, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(93, 3)" end="(95, 28)">
              <TacticTacticseq1IndentedNode start="(93, 3)" end="(95, 28)">
                <NullNode start="(93, 3)" end="(95, 28)">
                  <OtherNode start="(93, 3)" end="(93, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;stop : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;xs : Array α&#10;init : β&#10;w : stop = (filter p xs).size&#10;⊢ foldlM g init (filter p xs) 0 stop = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init xs" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;xs : Array α&#10;init : β&#10;⊢ foldlM g init (filter p xs) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init xs" tactic="subst w">
                    <AtomNode start="(93, 3)" end="(93, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(93, 9)" end="(93, 10)">
                      <IdentNode start="(93, 9)" end="(93, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(94, 3)" end="(94, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;xs : Array α&#10;init : β&#10;⊢ foldlM g init (filter p xs) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;init : β&#10;toList✝ : List α&#10;⊢ foldlM g init (filter p { toList := toList✝ }) =&#10;    foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(94, 3)" end="(94, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(94, 9)" end="(94, 11)">
                      <OtherNode start="(94, 9)" end="(94, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(94, 9)" end="(94, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(95, 3)" end="(95, 28)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;init : β&#10;toList✝ : List α&#10;⊢ foldlM g init (filter p { toList := toList✝ }) =&#10;    foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init { toList := toList✝ }" state_after="no goals" tactic="simp [List.foldlM_filter]">
                    <AtomNode start="(95, 3)" end="(95, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(95, 8)" end="(95, 28)">
                      <AtomNode start="(95, 8)" end="(95, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(95, 9)" end="(95, 27)">
                        <OtherNode start="(95, 9)" end="(95, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(95, 9)" end="(95, 27)" leading="" trailing="" raw_val="List.foldlM_filter" val="List.foldlM_filter" full_name="List.foldlM_filter" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(95, 27)" end="(95, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(97, 1)" end="(103, 28)" name="foldrM_filter" full_name="Array.foldrM_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(97, 1)" end="(103, 28)" name="foldrM_filter" full_name="Array.foldrM_filter" _is_private_decl="False">
        <AtomNode start="(97, 1)" end="(97, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(97, 9)" end="(97, 22)">
          <IdentNode start="(97, 9)" end="(97, 22)" leading="" trailing=" " raw_val="foldrM_filter" val="foldrM_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(97, 23)" end="(100, 64)">
          <NullNode start="(97, 23)" end="(98, 48)">
            <OtherNode start="(97, 23)" end="(97, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(97, 23)" end="(97, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(97, 24)" end="(97, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(97, 24)" end="(97, 29)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(97, 30)" end="(97, 31)">
                  <IdentNode start="(97, 30)" end="(97, 31)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(97, 31)" end="(97, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(97, 33)" end="(97, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(97, 33)" end="(97, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(97, 34)" end="(97, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(97, 34)" end="(97, 45)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(97, 46)" end="(97, 47)">
                  <IdentNode start="(97, 46)" end="(97, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(97, 47)" end="(97, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(97, 49)" end="(97, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 49)" end="(97, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 50)" end="(97, 51)">
                <IdentNode start="(97, 50)" end="(97, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(97, 52)" end="(97, 62)">
                <AtomNode start="(97, 52)" end="(97, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 54)" end="(97, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(97, 54)" end="(97, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(97, 56)" end="(97, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(97, 58)" end="(97, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 62)" end="(97, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(97, 64)" end="(97, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 64)" end="(97, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 65)" end="(97, 66)">
                <IdentNode start="(97, 65)" end="(97, 66)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(97, 67)" end="(97, 80)">
                <AtomNode start="(97, 67)" end="(97, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 69)" end="(97, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(97, 69)" end="(97, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(97, 71)" end="(97, 72)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(97, 73)" end="(97, 80)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(97, 73)" end="(97, 74)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(97, 75)" end="(97, 76)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(97, 77)" end="(97, 80)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(97, 77)" end="(97, 78)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(97, 79)" end="(97, 80)">
                        <IdentNode start="(97, 79)" end="(97, 80)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 80)" end="(97, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(97, 82)" end="(97, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 82)" end="(97, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 83)" end="(97, 85)">
                <IdentNode start="(97, 83)" end="(97, 85)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(97, 86)" end="(97, 95)">
                <AtomNode start="(97, 86)" end="(97, 87)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 88)" end="(97, 95)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(97, 88)" end="(97, 93)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(97, 94)" end="(97, 95)">
                    <IdentNode start="(97, 94)" end="(97, 95)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 95)" end="(97, 96)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(98, 5)" end="(98, 15)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(98, 5)" end="(98, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(98, 6)" end="(98, 10)">
                <IdentNode start="(98, 6)" end="(98, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(98, 11)" end="(98, 14)">
                <AtomNode start="(98, 11)" end="(98, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(98, 13)" end="(98, 14)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(98, 14)" end="(98, 15)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(98, 16)" end="(98, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(98, 16)" end="(98, 17)" leading="" trailing="" val="{"/>
              <NullNode start="(98, 17)" end="(98, 18)">
                <IdentNode start="(98, 17)" end="(98, 18)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(98, 19)" end="(98, 47)">
                <AtomNode start="(98, 19)" end="(98, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(98, 21)" end="(98, 47)" kind="«term_=_»">
                  <IdentNode start="(98, 21)" end="(98, 26)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(98, 27)" end="(98, 28)" leading="" trailing=" " val="="/>
                  <OtherNode start="(98, 29)" end="(98, 47)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(98, 29)" end="(98, 42)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(98, 29)" end="(98, 30)" leading="" trailing="" val="("/>
                      <OtherNode start="(98, 30)" end="(98, 41)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(98, 30)" end="(98, 39)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                        <NullNode start="(98, 40)" end="(98, 41)">
                          <IdentNode start="(98, 40)" end="(98, 41)" leading="" trailing="" raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(98, 41)" end="(98, 42)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(98, 42)" end="(98, 43)" leading="" trailing="" val="."/>
                    <IdentNode start="(98, 43)" end="(98, 47)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(98, 47)" end="(98, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(98, 49)" end="(100, 64)">
            <AtomNode start="(98, 49)" end="(98, 50)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(99, 5)" end="(100, 64)" kind="«term_=_»">
              <OtherNode start="(99, 5)" end="(99, 40)" kind="Lean.Parser.Term.app">
                <OtherNode start="(99, 5)" end="(99, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(99, 5)" end="(99, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(99, 5)" end="(99, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(99, 6)" end="(99, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(99, 6)" end="(99, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                      <NullNode start="(99, 16)" end="(99, 17)">
                        <IdentNode start="(99, 16)" end="(99, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(99, 17)" end="(99, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(99, 18)" end="(99, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(99, 19)" end="(99, 25)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="Array.foldrM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(99, 26)" end="(99, 40)">
                  <IdentNode start="(99, 26)" end="(99, 27)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(99, 28)" end="(99, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(99, 33)" end="(99, 38)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(99, 39)" end="(99, 40)" kind="num">
                    <AtomNode start="(99, 39)" end="(99, 40)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(99, 41)" end="(99, 42)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(100, 7)" end="(100, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(100, 7)" end="(100, 16)" leading="" trailing=" " raw_val="xs.foldrM" val="xs.foldrM"/>
                <NullNode start="(100, 17)" end="(100, 64)">
                  <OtherNode start="(100, 17)" end="(100, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(100, 17)" end="(100, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(100, 18)" end="(100, 58)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(100, 18)" end="(100, 21)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(100, 22)" end="(100, 58)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(100, 22)" end="(100, 25)">
                          <IdentNode start="(100, 22)" end="(100, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(100, 24)" end="(100, 25)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(100, 26)" end="(100, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(100, 29)" end="(100, 58)" kind="termIfThenElse">
                          <AtomNode start="(100, 29)" end="(100, 31)" leading="" trailing=" " val="if"/>
                          <OtherNode start="(100, 32)" end="(100, 35)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(100, 32)" end="(100, 33)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(100, 34)" end="(100, 35)">
                              <IdentNode start="(100, 34)" end="(100, 35)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(100, 36)" end="(100, 40)" leading="" trailing=" " val="then"/>
                          <OtherNode start="(100, 41)" end="(100, 46)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(100, 41)" end="(100, 42)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(100, 43)" end="(100, 46)">
                              <IdentNode start="(100, 43)" end="(100, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                              <IdentNode start="(100, 45)" end="(100, 46)" leading="" trailing=" " raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(100, 47)" end="(100, 51)" leading="" trailing=" " val="else"/>
                          <OtherNode start="(100, 52)" end="(100, 58)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(100, 52)" end="(100, 56)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(100, 57)" end="(100, 58)">
                              <IdentNode start="(100, 57)" end="(100, 58)" leading="" trailing="" raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(100, 58)" end="(100, 59)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(100, 60)" end="(100, 64)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(100, 65)" end="(103, 28)">
          <AtomNode start="(100, 65)" end="(100, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(100, 68)" end="(103, 28)">
            <AtomNode start="(100, 68)" end="(100, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(101, 3)" end="(103, 28)">
              <TacticTacticseq1IndentedNode start="(101, 3)" end="(103, 28)">
                <NullNode start="(101, 3)" end="(103, 28)">
                  <OtherNode start="(101, 3)" end="(101, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;start : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;xs : Array α&#10;init : β&#10;w : start = (filter p xs).size&#10;⊢ foldrM g init (filter p xs) start = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init xs" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;xs : Array α&#10;init : β&#10;⊢ foldrM g init (filter p xs) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init xs" tactic="subst w">
                    <AtomNode start="(101, 3)" end="(101, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(101, 9)" end="(101, 10)">
                      <IdentNode start="(101, 9)" end="(101, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(102, 3)" end="(102, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;xs : Array α&#10;init : β&#10;⊢ foldrM g init (filter p xs) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;init : β&#10;toList✝ : List α&#10;⊢ foldrM g init (filter p { toList := toList✝ }) =&#10;    foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(102, 3)" end="(102, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(102, 9)" end="(102, 11)">
                      <OtherNode start="(102, 9)" end="(102, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(102, 9)" end="(102, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(103, 3)" end="(103, 28)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;init : β&#10;toList✝ : List α&#10;⊢ foldrM g init (filter p { toList := toList✝ }) =&#10;    foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init { toList := toList✝ }" state_after="no goals" tactic="simp [List.foldrM_filter]">
                    <AtomNode start="(103, 3)" end="(103, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(103, 8)" end="(103, 28)">
                      <AtomNode start="(103, 8)" end="(103, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(103, 9)" end="(103, 27)">
                        <OtherNode start="(103, 9)" end="(103, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(103, 9)" end="(103, 27)" leading="" trailing="" raw_val="List.foldrM_filter" val="List.foldrM_filter" full_name="List.foldrM_filter" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(103, 27)" end="(103, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(105, 1)" end="(111, 25)" name="foldlM_attachWith" full_name="Array.foldlM_attachWith">
      <CommandDeclmodifiersNode start="(105, 1)" end="(105, 8)">
        <NullNode/>
        <NullNode start="(105, 1)" end="(105, 8)">
          <OtherNode start="(105, 1)" end="(105, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(105, 1)" end="(105, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(105, 3)" end="(105, 7)">
              <OtherNode start="(105, 3)" end="(105, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(105, 3)" end="(105, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(105, 3)" end="(105, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(105, 7)" end="(105, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(105, 9)" end="(111, 25)" name="foldlM_attachWith" full_name="Array.foldlM_attachWith" _is_private_decl="False">
        <AtomNode start="(105, 9)" end="(105, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(105, 17)" end="(105, 34)">
          <IdentNode start="(105, 17)" end="(105, 34)" leading="" trailing=" " raw_val="foldlM_attachWith" val="foldlM_attachWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(105, 35)" end="(108, 58)">
          <NullNode start="(105, 35)" end="(106, 111)">
            <OtherNode start="(105, 35)" end="(105, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(105, 35)" end="(105, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(105, 36)" end="(105, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(105, 36)" end="(105, 41)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(105, 42)" end="(105, 43)">
                  <IdentNode start="(105, 42)" end="(105, 43)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(105, 43)" end="(105, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(106, 5)" end="(106, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 5)" end="(106, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 6)" end="(106, 8)">
                <IdentNode start="(106, 6)" end="(106, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(106, 9)" end="(106, 18)">
                <AtomNode start="(106, 9)" end="(106, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 11)" end="(106, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(106, 11)" end="(106, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(106, 17)" end="(106, 18)">
                    <IdentNode start="(106, 17)" end="(106, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 18)" end="(106, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(106, 20)" end="(106, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 20)" end="(106, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 21)" end="(106, 22)">
                <IdentNode start="(106, 21)" end="(106, 22)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(106, 23)" end="(106, 33)">
                <AtomNode start="(106, 23)" end="(106, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 25)" end="(106, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(106, 25)" end="(106, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(106, 27)" end="(106, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(106, 29)" end="(106, 33)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(106, 29)" end="(106, 33)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 33)" end="(106, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(106, 35)" end="(106, 58)">
              <AtomNode start="(106, 35)" end="(106, 36)" leading="" trailing="" val="("/>
              <NullNode start="(106, 36)" end="(106, 37)">
                <IdentNode start="(106, 36)" end="(106, 37)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode start="(106, 38)" end="(106, 57)">
                <AtomNode start="(106, 38)" end="(106, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 40)" end="(106, 57)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(106, 40)" end="(106, 41)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(106, 42)" end="(106, 43)">
                    <IdentNode start="(106, 42)" end="(106, 43)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(106, 43)" end="(106, 44)" leading="" trailing=" " val=","/>
                  <OtherNode start="(106, 45)" end="(106, 57)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(106, 45)" end="(106, 51)" kind="«term_∈_»">
                      <IdentNode start="(106, 45)" end="(106, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(106, 47)" end="(106, 48)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(106, 49)" end="(106, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(106, 52)" end="(106, 53)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(106, 54)" end="(106, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(106, 54)" end="(106, 55)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(106, 56)" end="(106, 57)">
                        <IdentNode start="(106, 56)" end="(106, 57)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(106, 57)" end="(106, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(106, 59)" end="(106, 86)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 59)" end="(106, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 60)" end="(106, 61)">
                <IdentNode start="(106, 60)" end="(106, 61)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(106, 62)" end="(106, 85)">
                <AtomNode start="(106, 62)" end="(106, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 64)" end="(106, 85)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(106, 64)" end="(106, 65)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(106, 66)" end="(106, 67)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(106, 68)" end="(106, 85)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(106, 68)" end="(106, 79)" kind="«term{_:_//_}»">
                      <AtomNode start="(106, 68)" end="(106, 69)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(106, 70)" end="(106, 71)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(106, 72)" end="(106, 74)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(106, 75)" end="(106, 78)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(106, 75)" end="(106, 76)" leading="" trailing=" " raw_val="q" val="q"/>
                        <NullNode start="(106, 77)" end="(106, 78)">
                          <IdentNode start="(106, 77)" end="(106, 78)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(106, 78)" end="(106, 79)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <AtomNode start="(106, 80)" end="(106, 81)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(106, 82)" end="(106, 85)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(106, 82)" end="(106, 83)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(106, 84)" end="(106, 85)">
                        <IdentNode start="(106, 84)" end="(106, 85)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 85)" end="(106, 86)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(106, 87)" end="(106, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 87)" end="(106, 88)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 88)" end="(106, 89)">
                <IdentNode start="(106, 88)" end="(106, 89)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(106, 89)" end="(106, 90)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(106, 91)" end="(106, 111)">
              <AtomNode start="(106, 91)" end="(106, 92)" leading="" trailing="" val="("/>
              <NullNode start="(106, 92)" end="(106, 93)">
                <IdentNode start="(106, 92)" end="(106, 93)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(106, 94)" end="(106, 110)">
                <AtomNode start="(106, 94)" end="(106, 95)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 96)" end="(106, 110)" kind="«term_=_»">
                  <IdentNode start="(106, 96)" end="(106, 100)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(106, 101)" end="(106, 102)" leading="" trailing=" " val="="/>
                  <IdentNode start="(106, 103)" end="(106, 110)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(106, 110)" end="(106, 111)" leading="" trailing="" val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(106, 111)" end="(108, 58)">
            <AtomNode start="(106, 111)" end="(106, 112)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(107, 5)" end="(108, 58)" kind="«term_=_»">
              <OtherNode start="(107, 5)" end="(107, 42)" kind="Lean.Parser.Term.app">
                <OtherNode start="(107, 5)" end="(107, 31)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(107, 5)" end="(107, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(107, 5)" end="(107, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(107, 6)" end="(107, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(107, 6)" end="(107, 19)" leading="" trailing=" " raw_val="xs.attachWith" val="xs.attachWith"/>
                      <NullNode start="(107, 20)" end="(107, 23)">
                        <IdentNode start="(107, 20)" end="(107, 21)" leading="" trailing=" " raw_val="q" val="q"/>
                        <IdentNode start="(107, 22)" end="(107, 23)" leading="" trailing="" raw_val="H" val="H"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(107, 23)" end="(107, 24)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(107, 24)" end="(107, 25)" leading="" trailing="" val="."/>
                  <IdentNode start="(107, 25)" end="(107, 31)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="Array.foldlM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(107, 32)" end="(107, 42)">
                  <IdentNode start="(107, 32)" end="(107, 33)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(107, 34)" end="(107, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                  <OtherNode start="(107, 36)" end="(107, 37)" kind="num">
                    <AtomNode start="(107, 36)" end="(107, 37)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(107, 38)" end="(107, 42)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(107, 43)" end="(107, 44)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(108, 7)" end="(108, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(108, 7)" end="(108, 23)" leading="" trailing=" " raw_val="xs.attach.foldlM" val="xs.attach.foldlM"/>
                <NullNode start="(108, 24)" end="(108, 58)">
                  <OtherNode start="(108, 24)" end="(108, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(108, 24)" end="(108, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(108, 25)" end="(108, 55)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(108, 25)" end="(108, 28)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(108, 29)" end="(108, 55)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(108, 29)" end="(108, 37)">
                          <IdentNode start="(108, 29)" end="(108, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                          <OtherNode start="(108, 31)" end="(108, 37)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(108, 31)" end="(108, 32)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(108, 32)" end="(108, 36)">
                              <IdentNode start="(108, 32)" end="(108, 33)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(108, 33)" end="(108, 34)" leading="" trailing=" " val=","/>
                              <IdentNode start="(108, 35)" end="(108, 36)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                            <AtomNode start="(108, 36)" end="(108, 37)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(108, 38)" end="(108, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(108, 41)" end="(108, 55)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(108, 41)" end="(108, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(108, 43)" end="(108, 55)">
                            <IdentNode start="(108, 43)" end="(108, 44)" leading="" trailing=" " raw_val="b" val="b"/>
                            <OtherNode start="(108, 45)" end="(108, 55)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(108, 45)" end="(108, 46)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(108, 46)" end="(108, 54)">
                                <IdentNode start="(108, 46)" end="(108, 47)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(108, 47)" end="(108, 48)" leading="" trailing=" " val=","/>
                                <OtherNode start="(108, 49)" end="(108, 54)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(108, 49)" end="(108, 50)" leading="" trailing=" " raw_val="H" val="H"/>
                                  <NullNode start="(108, 51)" end="(108, 54)">
                                    <TermHoleNode start="(108, 51)" end="(108, 52)">
                                      <AtomNode start="(108, 51)" end="(108, 52)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <IdentNode start="(108, 53)" end="(108, 54)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(108, 54)" end="(108, 55)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(108, 55)" end="(108, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(108, 57)" end="(108, 58)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(108, 59)" end="(111, 25)">
          <AtomNode start="(108, 59)" end="(108, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(108, 62)" end="(111, 25)">
            <AtomNode start="(108, 62)" end="(108, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(109, 3)" end="(111, 25)">
              <TacticTacticseq1IndentedNode start="(109, 3)" end="(111, 25)">
                <NullNode start="(109, 3)" end="(111, 25)">
                  <OtherNode start="(109, 3)" end="(109, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;stop : Nat&#10;inst✝ : Monad m&#10;xs : Array α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ xs → q a&#10;f : β → { x // q x } → m β&#10;b : β&#10;w : stop = xs.size&#10;⊢ foldlM f b (xs.attachWith q H) 0 stop =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;      b xs.attach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;xs : Array α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ xs → q a&#10;f : β → { x // q x } → m β&#10;b : β&#10;⊢ foldlM f b (xs.attachWith q H) 0 xs.size =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;      b xs.attach" tactic="subst w">
                    <AtomNode start="(109, 3)" end="(109, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(109, 9)" end="(109, 10)">
                      <IdentNode start="(109, 9)" end="(109, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(110, 3)" end="(110, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;xs : Array α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ xs → q a&#10;f : β → { x // q x } → m β&#10;b : β&#10;⊢ foldlM f b (xs.attachWith q H) 0 xs.size =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;      b xs.attach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;q : α → Prop&#10;f : β → { x // q x } → m β&#10;b : β&#10;xs : List α&#10;H : ∀ (a : α), a ∈ { toList := xs } → q a&#10;⊢ foldlM f b ({ toList := xs }.attachWith q H) 0 { toList := xs }.size =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;      b { toList := xs }.attach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(110, 3)" end="(110, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(110, 10)" end="(110, 12)">
                      <OtherNode start="(110, 10)" end="(110, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(110, 10)" end="(110, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(110, 13)" end="(110, 22)">
                      <AtomNode start="(110, 13)" end="(110, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(110, 18)" end="(110, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(110, 18)" end="(110, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(110, 18)" end="(110, 22)">
                            <OtherNode start="(110, 18)" end="(110, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(110, 18)" end="(110, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(110, 19)" end="(110, 21)">
                                <OtherNode start="(110, 19)" end="(110, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(110, 19)" end="(110, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(110, 19)" end="(110, 21)">
                                      <OtherNode start="(110, 19)" end="(110, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(110, 19)" end="(110, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(110, 21)" end="(110, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(111, 3)" end="(111, 25)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;q : α → Prop&#10;f : β → { x // q x } → m β&#10;b : β&#10;xs : List α&#10;H : ∀ (a : α), a ∈ { toList := xs } → q a&#10;⊢ foldlM f b ({ toList := xs }.attachWith q H) 0 { toList := xs }.size =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;      b { toList := xs }.attach" state_after="no goals" tactic="simp [List.foldlM_map]">
                    <AtomNode start="(111, 3)" end="(111, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(111, 8)" end="(111, 25)">
                      <AtomNode start="(111, 8)" end="(111, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(111, 9)" end="(111, 24)">
                        <OtherNode start="(111, 9)" end="(111, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(111, 9)" end="(111, 24)" leading="" trailing="" raw_val="List.foldlM_map" val="List.foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(111, 24)" end="(111, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(113, 1)" end="(120, 25)" name="foldrM_attachWith" full_name="Array.foldrM_attachWith">
      <CommandDeclmodifiersNode start="(113, 1)" end="(113, 8)">
        <NullNode/>
        <NullNode start="(113, 1)" end="(113, 8)">
          <OtherNode start="(113, 1)" end="(113, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(113, 1)" end="(113, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(113, 3)" end="(113, 7)">
              <OtherNode start="(113, 3)" end="(113, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(113, 3)" end="(113, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(113, 3)" end="(113, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(113, 7)" end="(113, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(113, 9)" end="(120, 25)" name="foldrM_attachWith" full_name="Array.foldrM_attachWith" _is_private_decl="False">
        <AtomNode start="(113, 9)" end="(113, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(113, 17)" end="(113, 34)">
          <IdentNode start="(113, 17)" end="(113, 34)" leading="" trailing=" " raw_val="foldrM_attachWith" val="foldrM_attachWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(113, 35)" end="(117, 61)">
          <NullNode start="(113, 35)" end="(115, 26)">
            <OtherNode start="(113, 35)" end="(113, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(113, 35)" end="(113, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(113, 36)" end="(113, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(113, 36)" end="(113, 41)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(113, 42)" end="(113, 43)">
                  <IdentNode start="(113, 42)" end="(113, 43)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(113, 43)" end="(113, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(113, 45)" end="(113, 60)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(113, 45)" end="(113, 46)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(113, 46)" end="(113, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(113, 46)" end="(113, 57)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(113, 58)" end="(113, 59)">
                  <IdentNode start="(113, 58)" end="(113, 59)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(113, 59)" end="(113, 60)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(114, 5)" end="(114, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(114, 5)" end="(114, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(114, 6)" end="(114, 8)">
                <IdentNode start="(114, 6)" end="(114, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(114, 9)" end="(114, 18)">
                <AtomNode start="(114, 9)" end="(114, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(114, 11)" end="(114, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(114, 11)" end="(114, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(114, 17)" end="(114, 18)">
                    <IdentNode start="(114, 17)" end="(114, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(114, 18)" end="(114, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(114, 20)" end="(114, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(114, 20)" end="(114, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(114, 21)" end="(114, 22)">
                <IdentNode start="(114, 21)" end="(114, 22)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(114, 23)" end="(114, 33)">
                <AtomNode start="(114, 23)" end="(114, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(114, 25)" end="(114, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(114, 25)" end="(114, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(114, 27)" end="(114, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(114, 29)" end="(114, 33)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(114, 29)" end="(114, 33)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(114, 33)" end="(114, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(114, 35)" end="(114, 58)">
              <AtomNode start="(114, 35)" end="(114, 36)" leading="" trailing="" val="("/>
              <NullNode start="(114, 36)" end="(114, 37)">
                <IdentNode start="(114, 36)" end="(114, 37)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode start="(114, 38)" end="(114, 57)">
                <AtomNode start="(114, 38)" end="(114, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(114, 40)" end="(114, 57)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(114, 40)" end="(114, 41)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(114, 42)" end="(114, 43)">
                    <IdentNode start="(114, 42)" end="(114, 43)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(114, 43)" end="(114, 44)" leading="" trailing=" " val=","/>
                  <OtherNode start="(114, 45)" end="(114, 57)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(114, 45)" end="(114, 51)" kind="«term_∈_»">
                      <IdentNode start="(114, 45)" end="(114, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(114, 47)" end="(114, 48)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(114, 49)" end="(114, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(114, 52)" end="(114, 53)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(114, 54)" end="(114, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(114, 54)" end="(114, 55)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(114, 56)" end="(114, 57)">
                        <IdentNode start="(114, 56)" end="(114, 57)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(114, 57)" end="(114, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(114, 59)" end="(114, 86)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(114, 59)" end="(114, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(114, 60)" end="(114, 61)">
                <IdentNode start="(114, 60)" end="(114, 61)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(114, 62)" end="(114, 85)">
                <AtomNode start="(114, 62)" end="(114, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(114, 64)" end="(114, 85)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(114, 64)" end="(114, 75)" kind="«term{_:_//_}»">
                    <AtomNode start="(114, 64)" end="(114, 65)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(114, 66)" end="(114, 67)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(114, 68)" end="(114, 70)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(114, 71)" end="(114, 74)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(114, 71)" end="(114, 72)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(114, 73)" end="(114, 74)">
                        <IdentNode start="(114, 73)" end="(114, 74)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(114, 74)" end="(114, 75)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(114, 76)" end="(114, 77)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(114, 78)" end="(114, 85)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(114, 78)" end="(114, 79)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(114, 80)" end="(114, 81)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(114, 82)" end="(114, 85)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(114, 82)" end="(114, 83)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(114, 84)" end="(114, 85)">
                        <IdentNode start="(114, 84)" end="(114, 85)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(114, 85)" end="(114, 86)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(114, 87)" end="(114, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(114, 87)" end="(114, 88)" leading="" trailing="" val="{"/>
              <NullNode start="(114, 88)" end="(114, 89)">
                <IdentNode start="(114, 88)" end="(114, 89)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(114, 89)" end="(114, 90)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(115, 5)" end="(115, 26)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(115, 5)" end="(115, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(115, 6)" end="(115, 7)">
                <IdentNode start="(115, 6)" end="(115, 7)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(115, 8)" end="(115, 25)">
                <AtomNode start="(115, 8)" end="(115, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(115, 10)" end="(115, 25)" kind="«term_=_»">
                  <IdentNode start="(115, 10)" end="(115, 15)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(115, 16)" end="(115, 17)" leading="" trailing=" " val="="/>
                  <IdentNode start="(115, 18)" end="(115, 25)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(115, 25)" end="(115, 26)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(115, 27)" end="(117, 61)">
            <AtomNode start="(115, 27)" end="(115, 28)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(116, 5)" end="(117, 61)" kind="«term_=_»">
              <OtherNode start="(116, 5)" end="(116, 43)" kind="Lean.Parser.Term.app">
                <OtherNode start="(116, 5)" end="(116, 31)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(116, 5)" end="(116, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(116, 5)" end="(116, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(116, 6)" end="(116, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(116, 6)" end="(116, 19)" leading="" trailing=" " raw_val="xs.attachWith" val="xs.attachWith"/>
                      <NullNode start="(116, 20)" end="(116, 23)">
                        <IdentNode start="(116, 20)" end="(116, 21)" leading="" trailing=" " raw_val="q" val="q"/>
                        <IdentNode start="(116, 22)" end="(116, 23)" leading="" trailing="" raw_val="H" val="H"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(116, 23)" end="(116, 24)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(116, 24)" end="(116, 25)" leading="" trailing="" val="."/>
                  <IdentNode start="(116, 25)" end="(116, 31)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="Array.foldrM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(116, 32)" end="(116, 43)">
                  <IdentNode start="(116, 32)" end="(116, 33)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(116, 34)" end="(116, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(116, 36)" end="(116, 41)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(116, 42)" end="(116, 43)" kind="num">
                    <AtomNode start="(116, 42)" end="(116, 43)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(116, 44)" end="(116, 45)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(117, 7)" end="(117, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(117, 7)" end="(117, 23)" leading="" trailing=" " raw_val="xs.attach.foldrM" val="xs.attach.foldrM"/>
                <NullNode start="(117, 24)" end="(117, 61)">
                  <OtherNode start="(117, 24)" end="(117, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(117, 24)" end="(117, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(117, 25)" end="(117, 58)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(117, 25)" end="(117, 28)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(117, 29)" end="(117, 58)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(117, 29)" end="(117, 34)">
                          <IdentNode start="(117, 29)" end="(117, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(117, 31)" end="(117, 34)" leading="" trailing=" " raw_val="acc" val="acc"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(117, 35)" end="(117, 37)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(117, 38)" end="(117, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(117, 38)" end="(117, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(117, 40)" end="(117, 58)">
                            <OtherNode start="(117, 40)" end="(117, 54)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(117, 40)" end="(117, 41)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(117, 41)" end="(117, 53)">
                                <OtherNode start="(117, 41)" end="(117, 44)" kind="Lean.Parser.Term.proj">
                                  <IdentNode start="(117, 41)" end="(117, 42)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(117, 42)" end="(117, 43)" leading="" trailing="" val="."/>
                                  <OtherNode start="(117, 43)" end="(117, 44)" kind="fieldIdx">
                                    <AtomNode start="(117, 43)" end="(117, 44)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(117, 44)" end="(117, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(117, 46)" end="(117, 53)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(117, 46)" end="(117, 47)" leading="" trailing=" " raw_val="H" val="H"/>
                                  <NullNode start="(117, 48)" end="(117, 53)">
                                    <TermHoleNode start="(117, 48)" end="(117, 49)">
                                      <AtomNode start="(117, 48)" end="(117, 49)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <OtherNode start="(117, 50)" end="(117, 53)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(117, 50)" end="(117, 51)" leading="" trailing="" raw_val="a" val="a"/>
                                      <AtomNode start="(117, 51)" end="(117, 52)" leading="" trailing="" val="."/>
                                      <OtherNode start="(117, 52)" end="(117, 53)" kind="fieldIdx">
                                        <AtomNode start="(117, 52)" end="(117, 53)" leading="" trailing="" val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(117, 53)" end="(117, 54)" leading="" trailing=" " val="⟩"/>
                            </OtherNode>
                            <IdentNode start="(117, 55)" end="(117, 58)" leading="" trailing="" raw_val="acc" val="acc"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(117, 58)" end="(117, 59)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(117, 60)" end="(117, 61)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(117, 62)" end="(120, 25)">
          <AtomNode start="(117, 62)" end="(117, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(117, 65)" end="(120, 25)">
            <AtomNode start="(117, 65)" end="(117, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(118, 3)" end="(120, 25)">
              <TacticTacticseq1IndentedNode start="(118, 3)" end="(120, 25)">
                <NullNode start="(118, 3)" end="(120, 25)">
                  <OtherNode start="(118, 3)" end="(118, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;start : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ xs → q a&#10;f : { x // q x } → β → m β&#10;b : β&#10;w : start = xs.size&#10;⊢ foldrM f b (xs.attachWith q H) start = foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b xs.attach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ xs → q a&#10;f : { x // q x } → β → m β&#10;b : β&#10;⊢ foldrM f b (xs.attachWith q H) xs.size = foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b xs.attach" tactic="subst w">
                    <AtomNode start="(118, 3)" end="(118, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(118, 9)" end="(118, 10)">
                      <IdentNode start="(118, 9)" end="(118, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(119, 3)" end="(119, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ xs → q a&#10;f : { x // q x } → β → m β&#10;b : β&#10;⊢ foldrM f b (xs.attachWith q H) xs.size = foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b xs.attach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;q : α → Prop&#10;f : { x // q x } → β → m β&#10;b : β&#10;xs : List α&#10;H : ∀ (a : α), a ∈ { toList := xs } → q a&#10;⊢ foldrM f b ({ toList := xs }.attachWith q H) { toList := xs }.size =&#10;    foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b { toList := xs }.attach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(119, 3)" end="(119, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(119, 10)" end="(119, 12)">
                      <OtherNode start="(119, 10)" end="(119, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(119, 10)" end="(119, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(119, 13)" end="(119, 22)">
                      <AtomNode start="(119, 13)" end="(119, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(119, 18)" end="(119, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(119, 18)" end="(119, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(119, 18)" end="(119, 22)">
                            <OtherNode start="(119, 18)" end="(119, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(119, 18)" end="(119, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(119, 19)" end="(119, 21)">
                                <OtherNode start="(119, 19)" end="(119, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(119, 19)" end="(119, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(119, 19)" end="(119, 21)">
                                      <OtherNode start="(119, 19)" end="(119, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(119, 19)" end="(119, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(119, 21)" end="(119, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(120, 3)" end="(120, 25)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;q : α → Prop&#10;f : { x // q x } → β → m β&#10;b : β&#10;xs : List α&#10;H : ∀ (a : α), a ∈ { toList := xs } → q a&#10;⊢ foldrM f b ({ toList := xs }.attachWith q H) { toList := xs }.size =&#10;    foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b { toList := xs }.attach" state_after="no goals" tactic="simp [List.foldrM_map]">
                    <AtomNode start="(120, 3)" end="(120, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(120, 8)" end="(120, 25)">
                      <AtomNode start="(120, 8)" end="(120, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(120, 9)" end="(120, 24)">
                        <OtherNode start="(120, 9)" end="(120, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(120, 9)" end="(120, 24)" leading="" trailing="" raw_val="List.foldrM_map" val="List.foldrM_map" full_name="List.foldrM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(120, 24)" end="(120, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(122, 1)" end="(122, 16)" comment="### forM -/">
      <AtomNode start="(122, 1)" end="(122, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(122, 5)" end="(122, 16)" leading="" trailing="&#10;&#10;" val="### forM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(124, 1)" end="(128, 11)" name="forM_congr" full_name="Array.forM_congr">
      <CommandDeclmodifiersNode start="(124, 1)" end="(124, 9)">
        <NullNode/>
        <NullNode start="(124, 1)" end="(124, 9)">
          <OtherNode start="(124, 1)" end="(124, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(124, 1)" end="(124, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(124, 3)" end="(124, 8)">
              <OtherNode start="(124, 3)" end="(124, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(124, 3)" end="(124, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(124, 3)" end="(124, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(124, 8)" end="(124, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(124, 10)" end="(128, 11)" name="forM_congr" full_name="Array.forM_congr" _is_private_decl="False">
        <AtomNode start="(124, 10)" end="(124, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(124, 18)" end="(124, 28)">
          <IdentNode start="(124, 18)" end="(124, 28)" leading="" trailing=" " raw_val="forM_congr" val="forM_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(124, 29)" end="(126, 26)">
          <NullNode start="(124, 29)" end="(125, 22)">
            <OtherNode start="(124, 29)" end="(124, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(124, 29)" end="(124, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(124, 30)" end="(124, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(124, 30)" end="(124, 35)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(124, 36)" end="(124, 37)">
                  <IdentNode start="(124, 36)" end="(124, 37)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(124, 37)" end="(124, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(124, 39)" end="(124, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(124, 39)" end="(124, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(124, 40)" end="(124, 45)">
                <IdentNode start="(124, 40)" end="(124, 42)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(124, 43)" end="(124, 45)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(124, 46)" end="(124, 55)">
                <AtomNode start="(124, 46)" end="(124, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(124, 48)" end="(124, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(124, 48)" end="(124, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(124, 54)" end="(124, 55)">
                    <IdentNode start="(124, 54)" end="(124, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(124, 55)" end="(124, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(124, 57)" end="(124, 70)">
              <AtomNode start="(124, 57)" end="(124, 58)" leading="" trailing="" val="("/>
              <NullNode start="(124, 58)" end="(124, 59)">
                <IdentNode start="(124, 58)" end="(124, 59)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(124, 60)" end="(124, 69)">
                <AtomNode start="(124, 60)" end="(124, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(124, 62)" end="(124, 69)" kind="«term_=_»">
                  <IdentNode start="(124, 62)" end="(124, 64)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(124, 65)" end="(124, 66)" leading="" trailing=" " val="="/>
                  <IdentNode start="(124, 67)" end="(124, 69)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(124, 69)" end="(124, 70)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(125, 5)" end="(125, 22)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(125, 5)" end="(125, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(125, 6)" end="(125, 7)">
                <IdentNode start="(125, 6)" end="(125, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(125, 8)" end="(125, 21)">
                <AtomNode start="(125, 8)" end="(125, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(125, 10)" end="(125, 21)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(125, 10)" end="(125, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(125, 12)" end="(125, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(125, 14)" end="(125, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(125, 14)" end="(125, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(125, 16)" end="(125, 21)">
                      <IdentNode start="(125, 16)" end="(125, 21)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(125, 21)" end="(125, 22)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(125, 23)" end="(126, 26)">
            <AtomNode start="(125, 23)" end="(125, 24)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(126, 5)" end="(126, 26)" kind="«term_=_»">
              <OtherNode start="(126, 5)" end="(126, 14)" kind="Lean.Parser.Term.app">
                <IdentNode start="(126, 5)" end="(126, 9)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(126, 10)" end="(126, 14)">
                  <IdentNode start="(126, 10)" end="(126, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(126, 13)" end="(126, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(126, 15)" end="(126, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(126, 17)" end="(126, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(126, 17)" end="(126, 21)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(126, 22)" end="(126, 26)">
                  <IdentNode start="(126, 22)" end="(126, 24)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  <IdentNode start="(126, 25)" end="(126, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(126, 27)" end="(128, 11)">
          <AtomNode start="(126, 27)" end="(126, 29)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(126, 30)" end="(128, 11)">
            <AtomNode start="(126, 30)" end="(126, 32)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(127, 3)" end="(128, 11)">
              <TacticTacticseq1IndentedNode start="(127, 3)" end="(128, 11)">
                <NullNode start="(127, 3)" end="(128, 11)">
                  <OtherNode start="(127, 3)" end="(127, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;as bs : Array α&#10;w : as = bs&#10;f : α → m PUnit&#10;⊢ forM as f = forM bs f" state_after="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;f : α → m PUnit&#10;toList✝¹ toList✝ : List α&#10;w : { toList := toList✝¹ } = { toList := toList✝ }&#10;⊢ forM { toList := toList✝¹ } f = forM { toList := toList✝ } f" tactic="cases as &amp;lt;;&amp;gt; cases bs">
                    <OtherNode start="(127, 3)" end="(127, 11)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(127, 3)" end="(127, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(127, 9)" end="(127, 11)">
                        <OtherNode start="(127, 9)" end="(127, 11)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(127, 9)" end="(127, 11)" leading="" trailing=" " raw_val="as" val="as"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(127, 12)" end="(127, 15)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(127, 16)" end="(127, 24)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(127, 16)" end="(127, 21)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(127, 22)" end="(127, 24)">
                        <OtherNode start="(127, 22)" end="(127, 24)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(127, 22)" end="(127, 24)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(128, 3)" end="(128, 11)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;f : α → m PUnit&#10;toList✝¹ toList✝ : List α&#10;w : { toList := toList✝¹ } = { toList := toList✝ }&#10;⊢ forM { toList := toList✝¹ } f = forM { toList := toList✝ } f" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(128, 3)" end="(128, 11)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(130, 1)" end="(134, 7)" name="forM_append" full_name="Array.forM_append">
      <CommandDeclmodifiersNode start="(130, 1)" end="(130, 8)">
        <NullNode/>
        <NullNode start="(130, 1)" end="(130, 8)">
          <OtherNode start="(130, 1)" end="(130, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(130, 1)" end="(130, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(130, 3)" end="(130, 7)">
              <OtherNode start="(130, 3)" end="(130, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(130, 3)" end="(130, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(130, 3)" end="(130, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(130, 7)" end="(130, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(130, 9)" end="(134, 7)" name="forM_append" full_name="Array.forM_append" _is_private_decl="False">
        <AtomNode start="(130, 9)" end="(130, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(130, 17)" end="(130, 28)">
          <IdentNode start="(130, 17)" end="(130, 28)" leading="" trailing=" " raw_val="forM_append" val="forM_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(130, 29)" end="(131, 50)">
          <NullNode start="(130, 29)" end="(130, 90)">
            <OtherNode start="(130, 29)" end="(130, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(130, 29)" end="(130, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(130, 30)" end="(130, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 30)" end="(130, 35)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(130, 36)" end="(130, 37)">
                  <IdentNode start="(130, 36)" end="(130, 37)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(130, 37)" end="(130, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(130, 39)" end="(130, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(130, 39)" end="(130, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(130, 40)" end="(130, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 40)" end="(130, 51)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(130, 52)" end="(130, 53)">
                  <IdentNode start="(130, 52)" end="(130, 53)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(130, 53)" end="(130, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(130, 55)" end="(130, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(130, 55)" end="(130, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(130, 56)" end="(130, 61)">
                <IdentNode start="(130, 56)" end="(130, 58)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(130, 59)" end="(130, 61)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(130, 62)" end="(130, 71)">
                <AtomNode start="(130, 62)" end="(130, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(130, 64)" end="(130, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(130, 64)" end="(130, 69)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(130, 70)" end="(130, 71)">
                    <IdentNode start="(130, 70)" end="(130, 71)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(130, 71)" end="(130, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(130, 73)" end="(130, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(130, 73)" end="(130, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(130, 74)" end="(130, 75)">
                <IdentNode start="(130, 74)" end="(130, 75)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(130, 76)" end="(130, 89)">
                <AtomNode start="(130, 76)" end="(130, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(130, 78)" end="(130, 89)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(130, 78)" end="(130, 79)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(130, 80)" end="(130, 81)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(130, 82)" end="(130, 89)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(130, 82)" end="(130, 83)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(130, 84)" end="(130, 89)">
                      <IdentNode start="(130, 84)" end="(130, 89)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(130, 89)" end="(130, 90)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(130, 91)" end="(131, 50)">
            <AtomNode start="(130, 91)" end="(130, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(131, 5)" end="(131, 50)" kind="«term_=_»">
              <OtherNode start="(131, 5)" end="(131, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(131, 5)" end="(131, 9)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(131, 10)" end="(131, 22)">
                  <OtherNode start="(131, 10)" end="(131, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(131, 10)" end="(131, 11)" leading="" trailing="" val="("/>
                    <OtherNode start="(131, 11)" end="(131, 19)" kind="«term_++_»">
                      <IdentNode start="(131, 11)" end="(131, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(131, 14)" end="(131, 16)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(131, 17)" end="(131, 19)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(131, 19)" end="(131, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(131, 21)" end="(131, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(131, 23)" end="(131, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(131, 25)" end="(131, 50)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(131, 25)" end="(131, 26)" leading="" trailing="" val="("/>
                <OtherNode start="(131, 26)" end="(131, 49)" kind="Lean.Parser.Term.do">
                  <AtomNode start="(131, 26)" end="(131, 28)" leading="" trailing=" " val="do"/>
                  <OtherNode start="(131, 29)" end="(131, 49)" kind="Lean.Parser.Term.doSeqIndent">
                    <NullNode start="(131, 29)" end="(131, 49)">
                      <OtherNode start="(131, 29)" end="(131, 39)" kind="Lean.Parser.Term.doSeqItem">
                        <OtherNode start="(131, 29)" end="(131, 38)" kind="Lean.Parser.Term.doExpr">
                          <OtherNode start="(131, 29)" end="(131, 38)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(131, 29)" end="(131, 33)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                            <NullNode start="(131, 34)" end="(131, 38)">
                              <IdentNode start="(131, 34)" end="(131, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              <IdentNode start="(131, 37)" end="(131, 38)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <NullNode start="(131, 38)" end="(131, 39)">
                          <AtomNode start="(131, 38)" end="(131, 39)" leading="" trailing=" " val=";"/>
                        </NullNode>
                      </OtherNode>
                      <OtherNode start="(131, 40)" end="(131, 49)" kind="Lean.Parser.Term.doSeqItem">
                        <OtherNode start="(131, 40)" end="(131, 49)" kind="Lean.Parser.Term.doExpr">
                          <OtherNode start="(131, 40)" end="(131, 49)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(131, 40)" end="(131, 44)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                            <NullNode start="(131, 45)" end="(131, 49)">
                              <IdentNode start="(131, 45)" end="(131, 47)" leading="" trailing=" " raw_val="ys" val="ys"/>
                              <IdentNode start="(131, 48)" end="(131, 49)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(131, 49)" end="(131, 50)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(131, 51)" end="(134, 7)">
          <AtomNode start="(131, 51)" end="(131, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(131, 54)" end="(134, 7)">
            <AtomNode start="(131, 54)" end="(131, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(132, 3)" end="(134, 7)">
              <TacticTacticseq1IndentedNode start="(132, 3)" end="(134, 7)">
                <NullNode start="(132, 3)" end="(134, 7)">
                  <OtherNode start="(132, 3)" end="(132, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs ys : Array α&#10;f : α → m PUnit&#10;⊢ forM (xs ++ ys) f = do&#10;    forM xs f&#10;    forM ys f" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;ys : Array α&#10;f : α → m PUnit&#10;xs : List α&#10;⊢ forM ({ toList := xs } ++ ys) f = do&#10;    forM { toList := xs } f&#10;    forM ys f" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(132, 3)" end="(132, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(132, 10)" end="(132, 12)">
                      <OtherNode start="(132, 10)" end="(132, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(132, 10)" end="(132, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(132, 13)" end="(132, 22)">
                      <AtomNode start="(132, 13)" end="(132, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(132, 18)" end="(132, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(132, 18)" end="(132, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(132, 18)" end="(132, 22)">
                            <OtherNode start="(132, 18)" end="(132, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(132, 18)" end="(132, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(132, 19)" end="(132, 21)">
                                <OtherNode start="(132, 19)" end="(132, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(132, 19)" end="(132, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(132, 19)" end="(132, 21)">
                                      <OtherNode start="(132, 19)" end="(132, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(132, 19)" end="(132, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(132, 21)" end="(132, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(133, 3)" end="(133, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;ys : Array α&#10;f : α → m PUnit&#10;xs : List α&#10;⊢ forM ({ toList := xs } ++ ys) f = do&#10;    forM { toList := xs } f&#10;    forM ys f" state_after="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m PUnit&#10;xs ys : List α&#10;⊢ forM ({ toList := xs } ++ { toList := ys }) f = do&#10;    forM { toList := xs } f&#10;    forM { toList := ys } f" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(133, 3)" end="(133, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(133, 10)" end="(133, 12)">
                      <OtherNode start="(133, 10)" end="(133, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(133, 10)" end="(133, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(133, 13)" end="(133, 22)">
                      <AtomNode start="(133, 13)" end="(133, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(133, 18)" end="(133, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(133, 18)" end="(133, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(133, 18)" end="(133, 22)">
                            <OtherNode start="(133, 18)" end="(133, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(133, 18)" end="(133, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(133, 19)" end="(133, 21)">
                                <OtherNode start="(133, 19)" end="(133, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(133, 19)" end="(133, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(133, 19)" end="(133, 21)">
                                      <OtherNode start="(133, 19)" end="(133, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(133, 19)" end="(133, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(133, 21)" end="(133, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(134, 3)" end="(134, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m PUnit&#10;xs ys : List α&#10;⊢ forM ({ toList := xs } ++ { toList := ys }) f = do&#10;    forM { toList := xs } f&#10;    forM { toList := ys } f" state_after="no goals" tactic="simp">
                    <AtomNode start="(134, 3)" end="(134, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(136, 1)" end="(139, 7)" name="forM_map" full_name="Array.forM_map">
      <CommandDeclmodifiersNode start="(136, 1)" end="(136, 8)">
        <NullNode/>
        <NullNode start="(136, 1)" end="(136, 8)">
          <OtherNode start="(136, 1)" end="(136, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(136, 1)" end="(136, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(136, 3)" end="(136, 7)">
              <OtherNode start="(136, 3)" end="(136, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(136, 3)" end="(136, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(136, 3)" end="(136, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(136, 7)" end="(136, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(136, 9)" end="(139, 7)" name="forM_map" full_name="Array.forM_map" _is_private_decl="False">
        <AtomNode start="(136, 9)" end="(136, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(136, 17)" end="(136, 25)">
          <IdentNode start="(136, 17)" end="(136, 25)" leading="" trailing=" " raw_val="forM_map" val="forM_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(136, 26)" end="(137, 51)">
          <NullNode start="(136, 26)" end="(136, 96)">
            <OtherNode start="(136, 26)" end="(136, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(136, 26)" end="(136, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(136, 27)" end="(136, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(136, 27)" end="(136, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(136, 33)" end="(136, 34)">
                  <IdentNode start="(136, 33)" end="(136, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(136, 34)" end="(136, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(136, 36)" end="(136, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(136, 36)" end="(136, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(136, 37)" end="(136, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(136, 37)" end="(136, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(136, 49)" end="(136, 50)">
                  <IdentNode start="(136, 49)" end="(136, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(136, 50)" end="(136, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(136, 52)" end="(136, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 52)" end="(136, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 53)" end="(136, 55)">
                <IdentNode start="(136, 53)" end="(136, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(136, 56)" end="(136, 65)">
                <AtomNode start="(136, 56)" end="(136, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(136, 58)" end="(136, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(136, 58)" end="(136, 63)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(136, 64)" end="(136, 65)">
                    <IdentNode start="(136, 64)" end="(136, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(136, 65)" end="(136, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(136, 67)" end="(136, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 67)" end="(136, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 68)" end="(136, 69)">
                <IdentNode start="(136, 68)" end="(136, 69)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(136, 70)" end="(136, 77)">
                <AtomNode start="(136, 70)" end="(136, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(136, 72)" end="(136, 77)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(136, 72)" end="(136, 73)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(136, 74)" end="(136, 75)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(136, 76)" end="(136, 77)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(136, 77)" end="(136, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(136, 79)" end="(136, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 79)" end="(136, 80)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 80)" end="(136, 81)">
                <IdentNode start="(136, 80)" end="(136, 81)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(136, 82)" end="(136, 95)">
                <AtomNode start="(136, 82)" end="(136, 83)" leading="" trailing=" " val=":"/>
                <OtherNode start="(136, 84)" end="(136, 95)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(136, 84)" end="(136, 85)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(136, 86)" end="(136, 87)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(136, 88)" end="(136, 95)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(136, 88)" end="(136, 89)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(136, 90)" end="(136, 95)">
                      <IdentNode start="(136, 90)" end="(136, 95)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(136, 95)" end="(136, 96)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(136, 97)" end="(137, 51)">
            <AtomNode start="(136, 97)" end="(136, 98)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(137, 5)" end="(137, 51)" kind="«term_=_»">
              <OtherNode start="(137, 5)" end="(137, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(137, 5)" end="(137, 9)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(137, 10)" end="(137, 22)">
                  <OtherNode start="(137, 10)" end="(137, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(137, 10)" end="(137, 11)" leading="" trailing="" val="("/>
                    <OtherNode start="(137, 11)" end="(137, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(137, 11)" end="(137, 17)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(137, 18)" end="(137, 19)">
                        <IdentNode start="(137, 18)" end="(137, 19)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(137, 19)" end="(137, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(137, 21)" end="(137, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(137, 23)" end="(137, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(137, 25)" end="(137, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(137, 25)" end="(137, 29)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(137, 30)" end="(137, 51)">
                  <IdentNode start="(137, 30)" end="(137, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <OtherNode start="(137, 33)" end="(137, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(137, 33)" end="(137, 34)" leading="" trailing="" val="("/>
                    <OtherNode start="(137, 34)" end="(137, 50)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(137, 34)" end="(137, 37)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(137, 38)" end="(137, 50)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(137, 38)" end="(137, 39)">
                          <IdentNode start="(137, 38)" end="(137, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(137, 40)" end="(137, 42)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(137, 43)" end="(137, 50)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(137, 43)" end="(137, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(137, 45)" end="(137, 50)">
                            <OtherNode start="(137, 45)" end="(137, 50)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(137, 45)" end="(137, 46)" leading="" trailing="" val="("/>
                              <OtherNode start="(137, 46)" end="(137, 49)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(137, 46)" end="(137, 47)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(137, 48)" end="(137, 49)">
                                  <IdentNode start="(137, 48)" end="(137, 49)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(137, 49)" end="(137, 50)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(137, 50)" end="(137, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(137, 52)" end="(139, 7)">
          <AtomNode start="(137, 52)" end="(137, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(137, 55)" end="(139, 7)">
            <AtomNode start="(137, 55)" end="(137, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(138, 3)" end="(139, 7)">
              <TacticTacticseq1IndentedNode start="(138, 3)" end="(139, 7)">
                <NullNode start="(138, 3)" end="(139, 7)">
                  <OtherNode start="(138, 3)" end="(138, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;g : α → β&#10;f : β → m PUnit&#10;⊢ forM (map g xs) f = forM xs fun a =&amp;gt; f (g a)" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;g : α → β&#10;f : β → m PUnit&#10;xs : List α&#10;⊢ forM (map g { toList := xs }) f = forM { toList := xs } fun a =&amp;gt; f (g a)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(138, 3)" end="(138, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(138, 10)" end="(138, 12)">
                      <OtherNode start="(138, 10)" end="(138, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(138, 10)" end="(138, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(138, 13)" end="(138, 22)">
                      <AtomNode start="(138, 13)" end="(138, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(138, 18)" end="(138, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(138, 18)" end="(138, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(138, 18)" end="(138, 22)">
                            <OtherNode start="(138, 18)" end="(138, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(138, 18)" end="(138, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(138, 19)" end="(138, 21)">
                                <OtherNode start="(138, 19)" end="(138, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(138, 19)" end="(138, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(138, 19)" end="(138, 21)">
                                      <OtherNode start="(138, 19)" end="(138, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(138, 19)" end="(138, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(138, 21)" end="(138, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(139, 3)" end="(139, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;g : α → β&#10;f : β → m PUnit&#10;xs : List α&#10;⊢ forM (map g { toList := xs }) f = forM { toList := xs } fun a =&amp;gt; f (g a)" state_after="no goals" tactic="simp">
                    <AtomNode start="(139, 3)" end="(139, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(141, 1)" end="(141, 18)" comment="### forIn' -/">
      <AtomNode start="(141, 1)" end="(141, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(141, 5)" end="(141, 18)" leading="" trailing="&#10;&#10;" val="### forIn' -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(143, 1)" end="(151, 33)" name="forIn'_congr" full_name="Array.forIn'_congr">
      <CommandDeclmodifiersNode start="(143, 1)" end="(143, 9)">
        <NullNode/>
        <NullNode start="(143, 1)" end="(143, 9)">
          <OtherNode start="(143, 1)" end="(143, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(143, 1)" end="(143, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(143, 3)" end="(143, 8)">
              <OtherNode start="(143, 3)" end="(143, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(143, 3)" end="(143, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(143, 3)" end="(143, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(143, 8)" end="(143, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(143, 10)" end="(151, 33)" name="forIn'_congr" full_name="Array.forIn'_congr" _is_private_decl="False">
        <AtomNode start="(143, 10)" end="(143, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(143, 18)" end="(143, 30)">
          <IdentNode start="(143, 18)" end="(143, 30)" leading="" trailing=" " raw_val="forIn'_congr" val="forIn'_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(143, 31)" end="(148, 35)">
          <NullNode start="(143, 31)" end="(147, 58)">
            <OtherNode start="(143, 31)" end="(143, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(143, 31)" end="(143, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(143, 32)" end="(143, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(143, 32)" end="(143, 37)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(143, 38)" end="(143, 39)">
                  <IdentNode start="(143, 38)" end="(143, 39)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(143, 39)" end="(143, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(143, 41)" end="(143, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(143, 41)" end="(143, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(143, 42)" end="(143, 47)">
                <IdentNode start="(143, 42)" end="(143, 44)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(143, 45)" end="(143, 47)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(143, 48)" end="(143, 57)">
                <AtomNode start="(143, 48)" end="(143, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(143, 50)" end="(143, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(143, 50)" end="(143, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(143, 56)" end="(143, 57)">
                    <IdentNode start="(143, 56)" end="(143, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(143, 57)" end="(143, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(143, 59)" end="(143, 72)">
              <AtomNode start="(143, 59)" end="(143, 60)" leading="" trailing="" val="("/>
              <NullNode start="(143, 60)" end="(143, 61)">
                <IdentNode start="(143, 60)" end="(143, 61)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(143, 62)" end="(143, 71)">
                <AtomNode start="(143, 62)" end="(143, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(143, 64)" end="(143, 71)" kind="«term_=_»">
                  <IdentNode start="(143, 64)" end="(143, 66)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(143, 67)" end="(143, 68)" leading="" trailing=" " val="="/>
                  <IdentNode start="(143, 69)" end="(143, 71)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(143, 71)" end="(143, 72)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(144, 5)" end="(144, 15)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 5)" end="(144, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 6)" end="(144, 10)">
                <IdentNode start="(144, 6)" end="(144, 7)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(144, 8)" end="(144, 10)" leading="" trailing=" " raw_val="b'" val="b'"/>
              </NullNode>
              <NullNode start="(144, 11)" end="(144, 14)">
                <AtomNode start="(144, 11)" end="(144, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(144, 13)" end="(144, 14)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(144, 14)" end="(144, 15)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(144, 16)" end="(144, 29)">
              <AtomNode start="(144, 16)" end="(144, 17)" leading="" trailing="" val="("/>
              <NullNode start="(144, 17)" end="(144, 19)">
                <IdentNode start="(144, 17)" end="(144, 19)" leading="" trailing=" " raw_val="hb" val="hb"/>
              </NullNode>
              <NullNode start="(144, 20)" end="(144, 28)">
                <AtomNode start="(144, 20)" end="(144, 21)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 22)" end="(144, 28)" kind="«term_=_»">
                  <IdentNode start="(144, 22)" end="(144, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(144, 24)" end="(144, 25)" leading="" trailing=" " val="="/>
                  <IdentNode start="(144, 26)" end="(144, 28)" leading="" trailing="" raw_val="b'" val="b'"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 28)" end="(144, 29)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(145, 5)" end="(145, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(145, 5)" end="(145, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(145, 6)" end="(145, 7)">
                <IdentNode start="(145, 6)" end="(145, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(145, 8)" end="(145, 50)">
                <AtomNode start="(145, 8)" end="(145, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(145, 10)" end="(145, 50)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(145, 10)" end="(145, 18)">
                    <AtomNode start="(145, 10)" end="(145, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(145, 11)" end="(145, 13)">
                      <IdentNode start="(145, 11)" end="(145, 13)" leading="" trailing=" " raw_val="a'" val="a'"/>
                    </NullNode>
                    <NullNode start="(145, 14)" end="(145, 17)">
                      <AtomNode start="(145, 14)" end="(145, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(145, 16)" end="(145, 17)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(145, 17)" end="(145, 18)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(145, 19)" end="(145, 20)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(145, 21)" end="(145, 50)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(145, 21)" end="(145, 28)" kind="«term_∈_»">
                      <IdentNode start="(145, 21)" end="(145, 23)" leading="" trailing=" " raw_val="a'" val="a'"/>
                      <AtomNode start="(145, 24)" end="(145, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(145, 26)" end="(145, 28)" leading="" trailing=" " raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(145, 29)" end="(145, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(145, 31)" end="(145, 50)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(145, 31)" end="(145, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(145, 33)" end="(145, 34)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(145, 35)" end="(145, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(145, 35)" end="(145, 36)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(145, 37)" end="(145, 50)">
                          <OtherNode start="(145, 37)" end="(145, 50)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(145, 37)" end="(145, 38)" leading="" trailing="" val="("/>
                            <OtherNode start="(145, 38)" end="(145, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(145, 38)" end="(145, 47)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(145, 48)" end="(145, 49)">
                                <IdentNode start="(145, 48)" end="(145, 49)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(145, 49)" end="(145, 50)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(145, 50)" end="(145, 51)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(146, 5)" end="(146, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(146, 5)" end="(146, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(146, 6)" end="(146, 7)">
                <IdentNode start="(146, 6)" end="(146, 7)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(146, 8)" end="(146, 50)">
                <AtomNode start="(146, 8)" end="(146, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(146, 10)" end="(146, 50)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(146, 10)" end="(146, 18)">
                    <AtomNode start="(146, 10)" end="(146, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(146, 11)" end="(146, 13)">
                      <IdentNode start="(146, 11)" end="(146, 13)" leading="" trailing=" " raw_val="a'" val="a'"/>
                    </NullNode>
                    <NullNode start="(146, 14)" end="(146, 17)">
                      <AtomNode start="(146, 14)" end="(146, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(146, 16)" end="(146, 17)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(146, 17)" end="(146, 18)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(146, 19)" end="(146, 20)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(146, 21)" end="(146, 50)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(146, 21)" end="(146, 28)" kind="«term_∈_»">
                      <IdentNode start="(146, 21)" end="(146, 23)" leading="" trailing=" " raw_val="a'" val="a'"/>
                      <AtomNode start="(146, 24)" end="(146, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(146, 26)" end="(146, 28)" leading="" trailing=" " raw_val="bs" val="bs"/>
                    </OtherNode>
                    <AtomNode start="(146, 29)" end="(146, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(146, 31)" end="(146, 50)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(146, 31)" end="(146, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(146, 33)" end="(146, 34)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(146, 35)" end="(146, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(146, 35)" end="(146, 36)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(146, 37)" end="(146, 50)">
                          <OtherNode start="(146, 37)" end="(146, 50)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(146, 37)" end="(146, 38)" leading="" trailing="" val="("/>
                            <OtherNode start="(146, 38)" end="(146, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(146, 38)" end="(146, 47)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(146, 48)" end="(146, 49)">
                                <IdentNode start="(146, 48)" end="(146, 49)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(146, 49)" end="(146, 50)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(146, 50)" end="(146, 51)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(147, 5)" end="(147, 58)">
              <AtomNode start="(147, 5)" end="(147, 6)" leading="" trailing="" val="("/>
              <NullNode start="(147, 6)" end="(147, 7)">
                <IdentNode start="(147, 6)" end="(147, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(147, 8)" end="(147, 57)">
                <AtomNode start="(147, 8)" end="(147, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(147, 10)" end="(147, 57)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(147, 10)" end="(147, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(147, 12)" end="(147, 17)">
                    <IdentNode start="(147, 12)" end="(147, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(147, 14)" end="(147, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <IdentNode start="(147, 16)" end="(147, 17)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(147, 17)" end="(147, 18)" leading="" trailing=" " val=","/>
                  <OtherNode start="(147, 19)" end="(147, 57)" kind="«term_=_»">
                    <OtherNode start="(147, 19)" end="(147, 47)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(147, 19)" end="(147, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(147, 21)" end="(147, 47)">
                        <IdentNode start="(147, 21)" end="(147, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                        <OtherNode start="(147, 23)" end="(147, 45)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(147, 23)" end="(147, 24)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(147, 24)" end="(147, 44)">
                            <AtomNode start="(147, 24)" end="(147, 26)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(147, 27)" end="(147, 44)">
                              <TacticTacticseq1IndentedNode start="(147, 27)" end="(147, 44)">
                                <NullNode start="(147, 27)" end="(147, 44)">
                                  <OtherNode start="(147, 27)" end="(147, 44)" kind="Lean.Parser.Tactic.simpa" state_before="m✝ : Type ?u.28326 → Type ?u.28250&#10;α : Type ?u.28255&#10;β : Type ?u.28326&#10;inst✝ : Monad m✝&#10;as bs : Array α&#10;w : as = bs&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;f : (a' : α) → a' ∈ as → β → m✝ (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m✝ (ForInStep β)&#10;a : α&#10;m : a ∈ bs&#10;b : β&#10;⊢ a ∈ as" state_after="no goals" tactic="simpa [w] using m">
                                    <AtomNode start="(147, 27)" end="(147, 32)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(147, 33)" end="(147, 44)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(147, 33)" end="(147, 36)">
                                        <OtherNode start="(147, 33)" end="(147, 36)" kind="Lean.Parser.Tactic.simpArgs">
                                          <AtomNode start="(147, 33)" end="(147, 34)" leading="" trailing="" val="["/>
                                          <NullNode start="(147, 34)" end="(147, 35)">
                                            <OtherNode start="(147, 34)" end="(147, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(147, 34)" end="(147, 35)" leading="" trailing="" raw_val="w" val="w"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(147, 35)" end="(147, 36)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(147, 37)" end="(147, 44)">
                                        <AtomNode start="(147, 37)" end="(147, 42)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(147, 43)" end="(147, 44)" leading="" trailing="" raw_val="m" val="m"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(147, 44)" end="(147, 45)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(147, 46)" end="(147, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(147, 48)" end="(147, 49)" leading="" trailing=" " val="="/>
                    <OtherNode start="(147, 50)" end="(147, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(147, 50)" end="(147, 51)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(147, 52)" end="(147, 57)">
                        <IdentNode start="(147, 52)" end="(147, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(147, 54)" end="(147, 55)" leading="" trailing=" " raw_val="m" val="m"/>
                        <IdentNode start="(147, 56)" end="(147, 57)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(147, 57)" end="(147, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(147, 59)" end="(148, 35)">
            <AtomNode start="(147, 59)" end="(147, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(148, 5)" end="(148, 35)" kind="«term_=_»">
              <OtherNode start="(148, 5)" end="(148, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(148, 5)" end="(148, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(148, 12)" end="(148, 18)">
                  <IdentNode start="(148, 12)" end="(148, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(148, 15)" end="(148, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(148, 17)" end="(148, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(148, 19)" end="(148, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(148, 21)" end="(148, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(148, 21)" end="(148, 27)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(148, 28)" end="(148, 35)">
                  <IdentNode start="(148, 28)" end="(148, 30)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  <IdentNode start="(148, 31)" end="(148, 33)" leading="" trailing=" " raw_val="b'" val="b'"/>
                  <IdentNode start="(148, 34)" end="(148, 35)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(148, 36)" end="(151, 33)">
          <AtomNode start="(148, 36)" end="(148, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(148, 39)" end="(151, 33)">
            <AtomNode start="(148, 39)" end="(148, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(149, 3)" end="(151, 33)">
              <TacticTacticseq1IndentedNode start="(149, 3)" end="(151, 33)">
                <NullNode start="(149, 3)" end="(151, 33)">
                  <OtherNode start="(149, 3)" end="(149, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : Array α&#10;w : as = bs&#10;b b' : β&#10;hb : b = b'&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ bs) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' as b f = forIn' bs b' g" state_after="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;toList✝¹ : List α&#10;f : (a' : α) → a' ∈ { toList := toList✝¹ } → β → m (ForInStep β)&#10;toList✝ : List α&#10;g : (a' : α) → a' ∈ { toList := toList✝ } → β → m (ForInStep β)&#10;w : { toList := toList✝¹ } = { toList := toList✝ }&#10;h : ∀ (a : α) (m_1 : a ∈ { toList := toList✝ }) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' { toList := toList✝¹ } b f = forIn' { toList := toList✝ } b' g" tactic="cases as &amp;lt;;&amp;gt; cases bs">
                    <OtherNode start="(149, 3)" end="(149, 11)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(149, 3)" end="(149, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(149, 9)" end="(149, 11)">
                        <OtherNode start="(149, 9)" end="(149, 11)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(149, 9)" end="(149, 11)" leading="" trailing=" " raw_val="as" val="as"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(149, 12)" end="(149, 15)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(149, 16)" end="(149, 24)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(149, 16)" end="(149, 21)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(149, 22)" end="(149, 24)">
                        <OtherNode start="(149, 22)" end="(149, 24)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(149, 22)" end="(149, 24)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(150, 3)" end="(150, 66)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;toList✝¹ : List α&#10;f : (a' : α) → a' ∈ { toList := toList✝¹ } → β → m (ForInStep β)&#10;toList✝ : List α&#10;g : (a' : α) → a' ∈ { toList := toList✝ } → β → m (ForInStep β)&#10;w : { toList := toList✝¹ } = { toList := toList✝ }&#10;h : ∀ (a : α) (m_1 : a ∈ { toList := toList✝ }) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' { toList := toList✝¹ } b f = forIn' { toList := toList✝ } b' g" state_after="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;toList✝¹ : List α&#10;f : (a' : α) → a' ∈ { toList := toList✝¹ } → β → m (ForInStep β)&#10;toList✝ : List α&#10;g : (a' : α) → a' ∈ { toList := toList✝ } → β → m (ForInStep β)&#10;w✝ : { toList := toList✝¹ } = { toList := toList✝ }&#10;w : toList✝¹ = toList✝&#10;h : ∀ (a : α) (m_1 : a ∈ toList✝) (b : β), f a ⋯ b = g a ⋯ b&#10;⊢ (forIn' toList✝¹ b fun a m b =&amp;gt; f a ⋯ b) = forIn' toList✝ b' fun a m b =&amp;gt; g a ⋯ b" tactic="simp only [mk.injEq, mem_toArray, List.forIn'_toArray] at w h ⊢">
                    <AtomNode start="(150, 3)" end="(150, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(150, 8)" end="(150, 12)">
                      <AtomNode start="(150, 8)" end="(150, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(150, 13)" end="(150, 57)">
                      <AtomNode start="(150, 13)" end="(150, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(150, 14)" end="(150, 56)">
                        <OtherNode start="(150, 14)" end="(150, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(150, 14)" end="(150, 22)" leading="" trailing="" raw_val="mk.injEq" val="mk.injEq" full_name="Array.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(150, 22)" end="(150, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(150, 24)" end="(150, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(150, 24)" end="(150, 35)" leading="" trailing="" raw_val="mem_toArray" val="mem_toArray" full_name="Array.mem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(150, 35)" end="(150, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(150, 37)" end="(150, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(150, 37)" end="(150, 56)" leading="" trailing="" raw_val="List.forIn'_toArray" val="List.forIn'_toArray" full_name="List.forIn'_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(150, 56)" end="(150, 57)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(150, 58)" end="(150, 66)">
                      <OtherNode start="(150, 58)" end="(150, 66)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(150, 58)" end="(150, 60)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(150, 61)" end="(150, 66)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(150, 61)" end="(150, 66)">
                            <IdentNode start="(150, 61)" end="(150, 62)" leading="" trailing=" " raw_val="w" val="w"/>
                            <IdentNode start="(150, 63)" end="(150, 64)" leading="" trailing=" " raw_val="h" val="h"/>
                            <OtherNode start="(150, 65)" end="(150, 66)" kind="Lean.Parser.Tactic.locationType">
                              <OtherNode start="(150, 65)" end="(150, 66)" kind="patternIgnore">
                                <OtherNode start="(150, 65)" end="(150, 66)" kind="token.«⊢»">
                                  <AtomNode start="(150, 65)" end="(150, 66)" leading="" trailing="&#10;  " val="⊢"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(151, 3)" end="(151, 33)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;toList✝¹ : List α&#10;f : (a' : α) → a' ∈ { toList := toList✝¹ } → β → m (ForInStep β)&#10;toList✝ : List α&#10;g : (a' : α) → a' ∈ { toList := toList✝ } → β → m (ForInStep β)&#10;w✝ : { toList := toList✝¹ } = { toList := toList✝ }&#10;w : toList✝¹ = toList✝&#10;h : ∀ (a : α) (m_1 : a ∈ toList✝) (b : β), f a ⋯ b = g a ⋯ b&#10;⊢ (forIn' toList✝¹ b fun a m b =&amp;gt; f a ⋯ b) = forIn' toList✝ b' fun a m b =&amp;gt; g a ⋯ b" state_after="no goals" tactic="exact List.forIn'_congr w hb h">
                    <AtomNode start="(151, 3)" end="(151, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(151, 9)" end="(151, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(151, 9)" end="(151, 26)" leading="" trailing=" " raw_val="List.forIn'_congr" val="List.forIn'_congr" full_name="List.forIn'_congr" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                      <NullNode start="(151, 27)" end="(151, 33)">
                        <IdentNode start="(151, 27)" end="(151, 28)" leading="" trailing=" " raw_val="w" val="w"/>
                        <IdentNode start="(151, 29)" end="(151, 31)" leading="" trailing=" " raw_val="hb" val="hb"/>
                        <IdentNode start="(151, 32)" end="(151, 33)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(165, 8)" name="forIn'_eq_foldlM" full_name="Array.forIn'_eq_foldlM">
      <CommandDeclmodifiersNode start="(153, 1)" end="(156, 3)">
        <NullNode start="(153, 1)" end="(156, 3)">
          <CommandDoccommentNode start="(153, 1)" end="(156, 3)" comment="We can express a for loop over an array as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/">
            <AtomNode start="(153, 1)" end="(153, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(154, 1)" end="(156, 3)" leading="" trailing="&#10;" val="We can express a for loop over an array as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(157, 1)" end="(165, 8)" name="forIn'_eq_foldlM" full_name="Array.forIn'_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(157, 1)" end="(157, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(157, 9)" end="(157, 25)">
          <IdentNode start="(157, 9)" end="(157, 25)" leading="" trailing=" " raw_val="forIn'_eq_foldlM" val="forIn'_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(157, 26)" end="(162, 60)">
          <NullNode start="(157, 26)" end="(158, 75)">
            <OtherNode start="(157, 26)" end="(157, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(157, 26)" end="(157, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(157, 27)" end="(157, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(157, 27)" end="(157, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(157, 33)" end="(157, 34)">
                  <IdentNode start="(157, 33)" end="(157, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(157, 34)" end="(157, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(157, 36)" end="(157, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(157, 36)" end="(157, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(157, 37)" end="(157, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(157, 37)" end="(157, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(157, 49)" end="(157, 50)">
                  <IdentNode start="(157, 49)" end="(157, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(157, 50)" end="(157, 51)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(158, 5)" end="(158, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(158, 5)" end="(158, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(158, 6)" end="(158, 8)">
                <IdentNode start="(158, 6)" end="(158, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(158, 9)" end="(158, 18)">
                <AtomNode start="(158, 9)" end="(158, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(158, 11)" end="(158, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(158, 11)" end="(158, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(158, 17)" end="(158, 18)">
                    <IdentNode start="(158, 17)" end="(158, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(158, 18)" end="(158, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(158, 20)" end="(158, 64)">
              <AtomNode start="(158, 20)" end="(158, 21)" leading="" trailing="" val="("/>
              <NullNode start="(158, 21)" end="(158, 22)">
                <IdentNode start="(158, 21)" end="(158, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(158, 23)" end="(158, 63)">
                <AtomNode start="(158, 23)" end="(158, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(158, 25)" end="(158, 63)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(158, 25)" end="(158, 32)">
                    <AtomNode start="(158, 25)" end="(158, 26)" leading="" trailing="" val="("/>
                    <NullNode start="(158, 26)" end="(158, 27)">
                      <IdentNode start="(158, 26)" end="(158, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(158, 28)" end="(158, 31)">
                      <AtomNode start="(158, 28)" end="(158, 29)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(158, 30)" end="(158, 31)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(158, 31)" end="(158, 32)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(158, 33)" end="(158, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(158, 35)" end="(158, 63)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(158, 35)" end="(158, 41)" kind="«term_∈_»">
                      <IdentNode start="(158, 35)" end="(158, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(158, 37)" end="(158, 38)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(158, 39)" end="(158, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(158, 42)" end="(158, 43)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(158, 44)" end="(158, 63)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(158, 44)" end="(158, 45)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(158, 46)" end="(158, 47)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(158, 48)" end="(158, 63)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(158, 48)" end="(158, 49)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(158, 50)" end="(158, 63)">
                          <OtherNode start="(158, 50)" end="(158, 63)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(158, 50)" end="(158, 51)" leading="" trailing="" val="("/>
                            <OtherNode start="(158, 51)" end="(158, 62)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(158, 51)" end="(158, 60)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(158, 61)" end="(158, 62)">
                                <IdentNode start="(158, 61)" end="(158, 62)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(158, 62)" end="(158, 63)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(158, 63)" end="(158, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(158, 65)" end="(158, 75)">
              <AtomNode start="(158, 65)" end="(158, 66)" leading="" trailing="" val="("/>
              <NullNode start="(158, 66)" end="(158, 70)">
                <IdentNode start="(158, 66)" end="(158, 70)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(158, 71)" end="(158, 74)">
                <AtomNode start="(158, 71)" end="(158, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(158, 73)" end="(158, 74)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(158, 74)" end="(158, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(158, 76)" end="(162, 60)">
            <AtomNode start="(158, 76)" end="(158, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(159, 5)" end="(162, 60)" kind="«term_=_»">
              <OtherNode start="(159, 5)" end="(159, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(159, 5)" end="(159, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(159, 12)" end="(159, 21)">
                  <IdentNode start="(159, 12)" end="(159, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(159, 15)" end="(159, 19)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(159, 20)" end="(159, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(159, 22)" end="(159, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(159, 24)" end="(162, 60)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(159, 24)" end="(159, 39)" leading="" trailing=" " raw_val="ForInStep.value" val="ForInStep.value" full_name="ForInStep.value" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <AtomNode start="(159, 40)" end="(159, 43)" leading="" trailing="&#10;      " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(160, 7)" end="(162, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(160, 7)" end="(160, 23)" leading="" trailing=" " raw_val="xs.attach.foldlM" val="xs.attach.foldlM"/>
                  <NullNode start="(160, 24)" end="(162, 60)">
                    <OtherNode start="(160, 24)" end="(162, 37)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(160, 24)" end="(160, 25)" leading="" trailing="" val="("/>
                      <OtherNode start="(160, 25)" end="(162, 36)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(160, 25)" end="(160, 28)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(160, 29)" end="(162, 36)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(160, 29)" end="(160, 37)">
                            <IdentNode start="(160, 29)" end="(160, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                            <OtherNode start="(160, 31)" end="(160, 37)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(160, 31)" end="(160, 32)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(160, 32)" end="(160, 36)">
                                <IdentNode start="(160, 32)" end="(160, 33)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(160, 33)" end="(160, 34)" leading="" trailing=" " val=","/>
                                <IdentNode start="(160, 35)" end="(160, 36)" leading="" trailing="" raw_val="m" val="m"/>
                              </NullNode>
                              <AtomNode start="(160, 36)" end="(160, 37)" leading="" trailing=" " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(160, 38)" end="(160, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(160, 41)" end="(162, 36)" kind="Lean.Parser.Term.match">
                            <AtomNode start="(160, 41)" end="(160, 46)" leading="" trailing=" " val="match"/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(160, 47)" end="(160, 48)">
                              <OtherNode start="(160, 47)" end="(160, 48)" kind="Lean.Parser.Term.matchDiscr">
                                <NullNode/>
                                <IdentNode start="(160, 47)" end="(160, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(160, 49)" end="(160, 53)" leading="" trailing="&#10;        " val="with"/>
                            <OtherNode start="(161, 9)" end="(162, 36)" kind="Lean.Parser.Term.matchAlts">
                              <NullNode start="(161, 9)" end="(162, 36)">
                                <OtherNode start="(161, 9)" end="(161, 30)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(161, 9)" end="(161, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(161, 11)" end="(161, 19)">
                                    <NullNode start="(161, 11)" end="(161, 19)">
                                      <OtherNode start="(161, 11)" end="(161, 19)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(161, 11)" end="(161, 17)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(161, 11)" end="(161, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(161, 12)" end="(161, 17)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                        </OtherNode>
                                        <NullNode start="(161, 18)" end="(161, 19)">
                                          <IdentNode start="(161, 18)" end="(161, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(161, 20)" end="(161, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(161, 23)" end="(161, 30)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(161, 23)" end="(161, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(161, 25)" end="(161, 30)">
                                      <IdentNode start="(161, 25)" end="(161, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <IdentNode start="(161, 27)" end="(161, 28)" leading="" trailing=" " raw_val="m" val="m"/>
                                      <IdentNode start="(161, 29)" end="(161, 30)" leading="" trailing="&#10;        " raw_val="b" val="b"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(162, 9)" end="(162, 36)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(162, 9)" end="(162, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(162, 11)" end="(162, 18)">
                                    <NullNode start="(162, 11)" end="(162, 18)">
                                      <OtherNode start="(162, 11)" end="(162, 18)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(162, 11)" end="(162, 16)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(162, 11)" end="(162, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(162, 12)" end="(162, 16)" leading="" trailing=" " raw_val="done" val="done"/>
                                        </OtherNode>
                                        <NullNode start="(162, 17)" end="(162, 18)">
                                          <IdentNode start="(162, 17)" end="(162, 18)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(162, 19)" end="(162, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(162, 22)" end="(162, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(162, 22)" end="(162, 26)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(162, 27)" end="(162, 36)">
                                      <OtherNode start="(162, 27)" end="(162, 36)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(162, 27)" end="(162, 28)" leading="" trailing="" val="("/>
                                        <OtherNode start="(162, 28)" end="(162, 35)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(162, 28)" end="(162, 33)" kind="Lean.Parser.Term.dotIdent">
                                            <AtomNode start="(162, 28)" end="(162, 29)" leading="" trailing="" val="."/>
                                            <IdentNode start="(162, 29)" end="(162, 33)" leading="" trailing=" " raw_val="done" val="done"/>
                                          </OtherNode>
                                          <NullNode start="(162, 34)" end="(162, 35)">
                                            <IdentNode start="(162, 34)" end="(162, 35)" leading="" trailing="" raw_val="b" val="b"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(162, 35)" end="(162, 36)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(162, 36)" end="(162, 37)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(162, 38)" end="(162, 60)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(162, 38)" end="(162, 39)" leading="" trailing="" val="("/>
                      <OtherNode start="(162, 39)" end="(162, 59)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(162, 39)" end="(162, 54)" leading="" trailing=" " raw_val="ForInStep.yield" val="ForInStep.yield" full_name="ForInStep.yield" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        <NullNode start="(162, 55)" end="(162, 59)">
                          <IdentNode start="(162, 55)" end="(162, 59)" leading="" trailing="" raw_val="init" val="init"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(162, 59)" end="(162, 60)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(162, 61)" end="(165, 8)">
          <AtomNode start="(162, 61)" end="(162, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(162, 64)" end="(165, 8)">
            <AtomNode start="(162, 64)" end="(162, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(163, 3)" end="(165, 8)">
              <TacticTacticseq1IndentedNode start="(163, 3)" end="(165, 8)">
                <NullNode start="(163, 3)" end="(165, 8)">
                  <OtherNode start="(163, 3)" end="(163, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : (a : α) → a ∈ xs → β → m (ForInStep β)&#10;init : β&#10;⊢ forIn' xs init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m_1⟩ =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a m_1 b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs.attach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → m (ForInStep β)&#10;⊢ forIn' { toList := xs } init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m_1⟩ =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a m_1 b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) { toList := xs }.attach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(163, 3)" end="(163, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(163, 10)" end="(163, 12)">
                      <OtherNode start="(163, 10)" end="(163, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(163, 10)" end="(163, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(163, 13)" end="(163, 22)">
                      <AtomNode start="(163, 13)" end="(163, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(163, 18)" end="(163, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(163, 18)" end="(163, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(163, 18)" end="(163, 22)">
                            <OtherNode start="(163, 18)" end="(163, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(163, 18)" end="(163, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(163, 19)" end="(163, 21)">
                                <OtherNode start="(163, 19)" end="(163, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(163, 19)" end="(163, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(163, 19)" end="(163, 21)">
                                      <OtherNode start="(163, 19)" end="(163, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(163, 19)" end="(163, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(163, 21)" end="(163, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(164, 3)" end="(164, 48)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → m (ForInStep β)&#10;⊢ forIn' { toList := xs } init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m_1⟩ =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a m_1 b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) { toList := xs }.attach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → m (ForInStep β)&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs.attach =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun x y =&amp;gt;&#10;          match x with&#10;          | ForInStep.yield b =&amp;gt; f y.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs.attach" tactic="simp [List.forIn'_eq_foldlM, List.foldlM_map]">
                    <AtomNode start="(164, 3)" end="(164, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(164, 8)" end="(164, 48)">
                      <AtomNode start="(164, 8)" end="(164, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(164, 9)" end="(164, 47)">
                        <OtherNode start="(164, 9)" end="(164, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(164, 9)" end="(164, 30)" leading="" trailing="" raw_val="List.forIn'_eq_foldlM" val="List.forIn'_eq_foldlM" full_name="List.forIn'_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                        <AtomNode start="(164, 30)" end="(164, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(164, 32)" end="(164, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(164, 32)" end="(164, 47)" leading="" trailing="" raw_val="List.foldlM_map" val="List.foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(164, 47)" end="(164, 48)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(165, 3)" end="(165, 8)" kind="Lean.Parser.Tactic.congr" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → m (ForInStep β)&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs.attach =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun x y =&amp;gt;&#10;          match x with&#10;          | ForInStep.yield b =&amp;gt; f y.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs.attach" state_after="no goals" tactic="congr">
                    <AtomNode start="(165, 3)" end="(165, 8)" leading="" trailing="&#10;&#10;" val="congr"/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(167, 1)" end="(173, 25)" name="forIn'_yield_eq_foldlM" full_name="Array.forIn'_yield_eq_foldlM">
      <CommandDeclmodifiersNode start="(167, 1)" end="(168, 8)">
        <NullNode start="(167, 1)" end="(167, 78)">
          <CommandDoccommentNode start="(167, 1)" end="(167, 78)" comment="We can express a for loop over an array which always yields as a fold. -/">
            <AtomNode start="(167, 1)" end="(167, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(167, 5)" end="(167, 78)" leading="" trailing="&#10;" val="We can express a for loop over an array which always yields as a fold. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(168, 1)" end="(168, 8)">
          <OtherNode start="(168, 1)" end="(168, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(168, 1)" end="(168, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(168, 3)" end="(168, 7)">
              <OtherNode start="(168, 3)" end="(168, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(168, 3)" end="(168, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(168, 3)" end="(168, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(168, 7)" end="(168, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(168, 9)" end="(173, 25)" name="forIn'_yield_eq_foldlM" full_name="Array.forIn'_yield_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(168, 9)" end="(168, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(168, 17)" end="(168, 39)">
          <IdentNode start="(168, 17)" end="(168, 39)" leading="" trailing=" " raw_val="forIn'_yield_eq_foldlM" val="forIn'_yield_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(168, 40)" end="(171, 66)">
          <NullNode start="(168, 40)" end="(169, 98)">
            <OtherNode start="(168, 40)" end="(168, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(168, 40)" end="(168, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(168, 41)" end="(168, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(168, 41)" end="(168, 46)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(168, 47)" end="(168, 48)">
                  <IdentNode start="(168, 47)" end="(168, 48)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(168, 48)" end="(168, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(168, 50)" end="(168, 65)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(168, 50)" end="(168, 51)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(168, 51)" end="(168, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(168, 51)" end="(168, 62)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(168, 63)" end="(168, 64)">
                  <IdentNode start="(168, 63)" end="(168, 64)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(168, 64)" end="(168, 65)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(169, 5)" end="(169, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(169, 5)" end="(169, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(169, 6)" end="(169, 8)">
                <IdentNode start="(169, 6)" end="(169, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(169, 9)" end="(169, 18)">
                <AtomNode start="(169, 9)" end="(169, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(169, 11)" end="(169, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(169, 11)" end="(169, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(169, 17)" end="(169, 18)">
                    <IdentNode start="(169, 17)" end="(169, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(169, 18)" end="(169, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(169, 20)" end="(169, 52)">
              <AtomNode start="(169, 20)" end="(169, 21)" leading="" trailing="" val="("/>
              <NullNode start="(169, 21)" end="(169, 22)">
                <IdentNode start="(169, 21)" end="(169, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(169, 23)" end="(169, 51)">
                <AtomNode start="(169, 23)" end="(169, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(169, 25)" end="(169, 51)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(169, 25)" end="(169, 32)">
                    <AtomNode start="(169, 25)" end="(169, 26)" leading="" trailing="" val="("/>
                    <NullNode start="(169, 26)" end="(169, 27)">
                      <IdentNode start="(169, 26)" end="(169, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(169, 28)" end="(169, 31)">
                      <AtomNode start="(169, 28)" end="(169, 29)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(169, 30)" end="(169, 31)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(169, 31)" end="(169, 32)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(169, 33)" end="(169, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(169, 35)" end="(169, 51)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(169, 35)" end="(169, 41)" kind="«term_∈_»">
                      <IdentNode start="(169, 35)" end="(169, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(169, 37)" end="(169, 38)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(169, 39)" end="(169, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(169, 42)" end="(169, 43)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(169, 44)" end="(169, 51)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(169, 44)" end="(169, 45)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(169, 46)" end="(169, 47)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(169, 48)" end="(169, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(169, 48)" end="(169, 49)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(169, 50)" end="(169, 51)">
                          <IdentNode start="(169, 50)" end="(169, 51)" leading="" trailing="" raw_val="γ" val="γ"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(169, 51)" end="(169, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(169, 53)" end="(169, 87)">
              <AtomNode start="(169, 53)" end="(169, 54)" leading="" trailing="" val="("/>
              <NullNode start="(169, 54)" end="(169, 55)">
                <IdentNode start="(169, 54)" end="(169, 55)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(169, 56)" end="(169, 86)">
                <AtomNode start="(169, 56)" end="(169, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(169, 58)" end="(169, 86)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(169, 58)" end="(169, 65)">
                    <AtomNode start="(169, 58)" end="(169, 59)" leading="" trailing="" val="("/>
                    <NullNode start="(169, 59)" end="(169, 60)">
                      <IdentNode start="(169, 59)" end="(169, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(169, 61)" end="(169, 64)">
                      <AtomNode start="(169, 61)" end="(169, 62)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(169, 63)" end="(169, 64)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(169, 64)" end="(169, 65)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(169, 66)" end="(169, 67)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(169, 68)" end="(169, 86)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(169, 68)" end="(169, 74)" kind="«term_∈_»">
                      <IdentNode start="(169, 68)" end="(169, 69)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(169, 70)" end="(169, 71)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(169, 72)" end="(169, 74)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(169, 75)" end="(169, 76)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(169, 77)" end="(169, 86)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(169, 77)" end="(169, 78)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(169, 79)" end="(169, 80)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(169, 81)" end="(169, 86)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(169, 81)" end="(169, 82)" leading="" trailing=" " raw_val="γ" val="γ"/>
                        <AtomNode start="(169, 83)" end="(169, 84)" leading="" trailing=" " val="→"/>
                        <IdentNode start="(169, 85)" end="(169, 86)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(169, 86)" end="(169, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(169, 88)" end="(169, 98)">
              <AtomNode start="(169, 88)" end="(169, 89)" leading="" trailing="" val="("/>
              <NullNode start="(169, 89)" end="(169, 93)">
                <IdentNode start="(169, 89)" end="(169, 93)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(169, 94)" end="(169, 97)">
                <AtomNode start="(169, 94)" end="(169, 95)" leading="" trailing=" " val=":"/>
                <IdentNode start="(169, 96)" end="(169, 97)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(169, 97)" end="(169, 98)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(169, 99)" end="(171, 66)">
            <AtomNode start="(169, 99)" end="(169, 100)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(170, 5)" end="(171, 66)" kind="«term_=_»">
              <OtherNode start="(170, 5)" end="(170, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(170, 5)" end="(170, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(170, 12)" end="(170, 76)">
                  <IdentNode start="(170, 12)" end="(170, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(170, 15)" end="(170, 19)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(170, 20)" end="(170, 76)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(170, 20)" end="(170, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(170, 21)" end="(170, 75)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(170, 21)" end="(170, 24)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(170, 25)" end="(170, 75)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(170, 25)" end="(170, 30)">
                          <IdentNode start="(170, 25)" end="(170, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(170, 27)" end="(170, 28)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(170, 29)" end="(170, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(170, 31)" end="(170, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(170, 34)" end="(170, 75)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(170, 34)" end="(170, 63)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(170, 34)" end="(170, 35)" leading="" trailing="" val="("/>
                            <OtherNode start="(170, 35)" end="(170, 62)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(170, 35)" end="(170, 38)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(170, 39)" end="(170, 62)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(170, 39)" end="(170, 40)">
                                  <IdentNode start="(170, 39)" end="(170, 40)" leading="" trailing=" " raw_val="c" val="c"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(170, 41)" end="(170, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(170, 44)" end="(170, 62)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(170, 44)" end="(170, 50)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(170, 44)" end="(170, 45)" leading="" trailing="" val="."/>
                                    <IdentNode start="(170, 45)" end="(170, 50)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                  </OtherNode>
                                  <NullNode start="(170, 51)" end="(170, 62)">
                                    <OtherNode start="(170, 51)" end="(170, 62)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(170, 51)" end="(170, 52)" leading="" trailing="" val="("/>
                                      <OtherNode start="(170, 52)" end="(170, 61)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(170, 52)" end="(170, 53)" leading="" trailing=" " raw_val="g" val="g"/>
                                        <NullNode start="(170, 54)" end="(170, 61)">
                                          <IdentNode start="(170, 54)" end="(170, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <IdentNode start="(170, 56)" end="(170, 57)" leading="" trailing=" " raw_val="m" val="m"/>
                                          <IdentNode start="(170, 58)" end="(170, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                                          <IdentNode start="(170, 60)" end="(170, 61)" leading="" trailing="" raw_val="c" val="c"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(170, 61)" end="(170, 62)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(170, 62)" end="(170, 63)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <AtomNode start="(170, 64)" end="(170, 67)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(170, 68)" end="(170, 75)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(170, 68)" end="(170, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(170, 70)" end="(170, 75)">
                              <IdentNode start="(170, 70)" end="(170, 71)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(170, 72)" end="(170, 73)" leading="" trailing=" " raw_val="m" val="m"/>
                              <IdentNode start="(170, 74)" end="(170, 75)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(170, 75)" end="(170, 76)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(170, 77)" end="(170, 78)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(171, 7)" end="(171, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(171, 7)" end="(171, 23)" leading="" trailing=" " raw_val="xs.attach.foldlM" val="xs.attach.foldlM"/>
                <NullNode start="(171, 24)" end="(171, 66)">
                  <OtherNode start="(171, 24)" end="(171, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(171, 24)" end="(171, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(171, 25)" end="(171, 60)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(171, 25)" end="(171, 28)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(171, 29)" end="(171, 60)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(171, 29)" end="(171, 37)">
                          <IdentNode start="(171, 29)" end="(171, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                          <OtherNode start="(171, 31)" end="(171, 37)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(171, 31)" end="(171, 32)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(171, 32)" end="(171, 36)">
                              <IdentNode start="(171, 32)" end="(171, 33)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(171, 33)" end="(171, 34)" leading="" trailing=" " val=","/>
                              <IdentNode start="(171, 35)" end="(171, 36)" leading="" trailing="" raw_val="m" val="m"/>
                            </NullNode>
                            <AtomNode start="(171, 36)" end="(171, 37)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(171, 38)" end="(171, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(171, 41)" end="(171, 60)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(171, 41)" end="(171, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(171, 41)" end="(171, 42)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(171, 43)" end="(171, 48)">
                              <IdentNode start="(171, 43)" end="(171, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(171, 45)" end="(171, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                              <IdentNode start="(171, 47)" end="(171, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(171, 49)" end="(171, 52)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(171, 53)" end="(171, 60)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(171, 53)" end="(171, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(171, 55)" end="(171, 60)">
                              <IdentNode start="(171, 55)" end="(171, 56)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(171, 57)" end="(171, 58)" leading="" trailing=" " raw_val="m" val="m"/>
                              <IdentNode start="(171, 59)" end="(171, 60)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(171, 60)" end="(171, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(171, 62)" end="(171, 66)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(171, 67)" end="(173, 25)">
          <AtomNode start="(171, 67)" end="(171, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(171, 70)" end="(173, 25)">
            <AtomNode start="(171, 70)" end="(171, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(172, 3)" end="(173, 25)">
              <TacticTacticseq1IndentedNode start="(172, 3)" end="(173, 25)">
                <NullNode start="(172, 3)" end="(173, 25)">
                  <OtherNode start="(172, 3)" end="(172, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : (a : α) → a ∈ xs → β → m γ&#10;g : (a : α) → a ∈ xs → β → γ → β&#10;init : β&#10;⊢ (forIn' xs init fun a m_1 b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a m_1 b c)) &amp;lt;$&amp;gt; f a m_1 b) =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, m_1⟩ =&amp;gt; g a m_1 b &amp;lt;$&amp;gt; f a m_1 b)&#10;      init xs.attach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → m γ&#10;g : (a : α) → a ∈ { toList := xs } → β → γ → β&#10;⊢ (forIn' { toList := xs } init fun a m_1 b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a m_1 b c)) &amp;lt;$&amp;gt; f a m_1 b) =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, m_1⟩ =&amp;gt; g a m_1 b &amp;lt;$&amp;gt; f a m_1 b)&#10;      init { toList := xs }.attach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(172, 3)" end="(172, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(172, 10)" end="(172, 12)">
                      <OtherNode start="(172, 10)" end="(172, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(172, 10)" end="(172, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(172, 13)" end="(172, 22)">
                      <AtomNode start="(172, 13)" end="(172, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(172, 18)" end="(172, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(172, 18)" end="(172, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(172, 18)" end="(172, 22)">
                            <OtherNode start="(172, 18)" end="(172, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(172, 18)" end="(172, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(172, 19)" end="(172, 21)">
                                <OtherNode start="(172, 19)" end="(172, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(172, 19)" end="(172, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(172, 19)" end="(172, 21)">
                                      <OtherNode start="(172, 19)" end="(172, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(172, 19)" end="(172, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(172, 21)" end="(172, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(173, 3)" end="(173, 25)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → m γ&#10;g : (a : α) → a ∈ { toList := xs } → β → γ → β&#10;⊢ (forIn' { toList := xs } init fun a m_1 b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a m_1 b c)) &amp;lt;$&amp;gt; f a m_1 b) =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, m_1⟩ =&amp;gt; g a m_1 b &amp;lt;$&amp;gt; f a m_1 b)&#10;      init { toList := xs }.attach" state_after="no goals" tactic="simp [List.foldlM_map]">
                    <AtomNode start="(173, 3)" end="(173, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(173, 8)" end="(173, 25)">
                      <AtomNode start="(173, 8)" end="(173, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(173, 9)" end="(173, 24)">
                        <OtherNode start="(173, 9)" end="(173, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(173, 9)" end="(173, 24)" leading="" trailing="" raw_val="List.foldlM_map" val="List.foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(173, 24)" end="(173, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(175, 1)" end="(180, 57)" name="forIn'_pure_yield_eq_foldl" full_name="Array.forIn'_pure_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(175, 1)" end="(175, 8)">
        <NullNode/>
        <NullNode start="(175, 1)" end="(175, 8)">
          <OtherNode start="(175, 1)" end="(175, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(175, 1)" end="(175, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(175, 3)" end="(175, 7)">
              <OtherNode start="(175, 3)" end="(175, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(175, 3)" end="(175, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(175, 3)" end="(175, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(175, 7)" end="(175, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(175, 9)" end="(180, 57)" name="forIn'_pure_yield_eq_foldl" full_name="Array.forIn'_pure_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(175, 9)" end="(175, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(175, 17)" end="(175, 43)">
          <IdentNode start="(175, 17)" end="(175, 43)" leading="" trailing=" " raw_val="forIn'_pure_yield_eq_foldl" val="forIn'_pure_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(175, 44)" end="(178, 69)">
          <NullNode start="(175, 44)" end="(176, 61)">
            <OtherNode start="(175, 44)" end="(175, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(175, 44)" end="(175, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(175, 45)" end="(175, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(175, 45)" end="(175, 50)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(175, 51)" end="(175, 52)">
                  <IdentNode start="(175, 51)" end="(175, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(175, 52)" end="(175, 53)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(175, 54)" end="(175, 69)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(175, 54)" end="(175, 55)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(175, 55)" end="(175, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(175, 55)" end="(175, 66)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(175, 67)" end="(175, 68)">
                  <IdentNode start="(175, 67)" end="(175, 68)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(175, 68)" end="(175, 69)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(176, 5)" end="(176, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(176, 5)" end="(176, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(176, 6)" end="(176, 8)">
                <IdentNode start="(176, 6)" end="(176, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(176, 9)" end="(176, 18)">
                <AtomNode start="(176, 9)" end="(176, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(176, 11)" end="(176, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(176, 11)" end="(176, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(176, 17)" end="(176, 18)">
                    <IdentNode start="(176, 17)" end="(176, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(176, 18)" end="(176, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(176, 20)" end="(176, 50)">
              <AtomNode start="(176, 20)" end="(176, 21)" leading="" trailing="" val="("/>
              <NullNode start="(176, 21)" end="(176, 22)">
                <IdentNode start="(176, 21)" end="(176, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(176, 23)" end="(176, 49)">
                <AtomNode start="(176, 23)" end="(176, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(176, 25)" end="(176, 49)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(176, 25)" end="(176, 32)">
                    <AtomNode start="(176, 25)" end="(176, 26)" leading="" trailing="" val="("/>
                    <NullNode start="(176, 26)" end="(176, 27)">
                      <IdentNode start="(176, 26)" end="(176, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(176, 28)" end="(176, 31)">
                      <AtomNode start="(176, 28)" end="(176, 29)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(176, 30)" end="(176, 31)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(176, 31)" end="(176, 32)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(176, 33)" end="(176, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(176, 35)" end="(176, 49)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(176, 35)" end="(176, 41)" kind="«term_∈_»">
                      <IdentNode start="(176, 35)" end="(176, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(176, 37)" end="(176, 38)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(176, 39)" end="(176, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(176, 42)" end="(176, 43)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(176, 44)" end="(176, 49)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(176, 44)" end="(176, 45)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(176, 46)" end="(176, 47)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(176, 48)" end="(176, 49)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(176, 49)" end="(176, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(176, 51)" end="(176, 61)">
              <AtomNode start="(176, 51)" end="(176, 52)" leading="" trailing="" val="("/>
              <NullNode start="(176, 52)" end="(176, 56)">
                <IdentNode start="(176, 52)" end="(176, 56)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(176, 57)" end="(176, 60)">
                <AtomNode start="(176, 57)" end="(176, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(176, 59)" end="(176, 60)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(176, 60)" end="(176, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(176, 62)" end="(178, 69)">
            <AtomNode start="(176, 62)" end="(176, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(177, 5)" end="(178, 69)" kind="«term_=_»">
              <OtherNode start="(177, 5)" end="(177, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(177, 5)" end="(177, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(177, 12)" end="(177, 58)">
                  <IdentNode start="(177, 12)" end="(177, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(177, 15)" end="(177, 19)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(177, 20)" end="(177, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(177, 20)" end="(177, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(177, 21)" end="(177, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(177, 21)" end="(177, 24)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(177, 25)" end="(177, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(177, 25)" end="(177, 30)">
                          <IdentNode start="(177, 25)" end="(177, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(177, 27)" end="(177, 28)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(177, 29)" end="(177, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(177, 31)" end="(177, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(177, 34)" end="(177, 57)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(177, 34)" end="(177, 38)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(177, 39)" end="(177, 57)">
                            <OtherNode start="(177, 39)" end="(177, 57)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(177, 39)" end="(177, 40)" leading="" trailing="" val="("/>
                              <OtherNode start="(177, 40)" end="(177, 56)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(177, 40)" end="(177, 46)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(177, 40)" end="(177, 41)" leading="" trailing="" val="."/>
                                  <IdentNode start="(177, 41)" end="(177, 46)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                </OtherNode>
                                <NullNode start="(177, 47)" end="(177, 56)">
                                  <OtherNode start="(177, 47)" end="(177, 56)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(177, 47)" end="(177, 48)" leading="" trailing="" val="("/>
                                    <OtherNode start="(177, 48)" end="(177, 55)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(177, 48)" end="(177, 49)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(177, 50)" end="(177, 55)">
                                        <IdentNode start="(177, 50)" end="(177, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <IdentNode start="(177, 52)" end="(177, 53)" leading="" trailing=" " raw_val="m" val="m"/>
                                        <IdentNode start="(177, 54)" end="(177, 55)" leading="" trailing="" raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(177, 55)" end="(177, 56)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(177, 56)" end="(177, 57)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(177, 57)" end="(177, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(177, 59)" end="(177, 60)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(178, 7)" end="(178, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(178, 7)" end="(178, 11)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(178, 12)" end="(178, 69)">
                  <OtherNode start="(178, 12)" end="(178, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(178, 12)" end="(178, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(178, 13)" end="(178, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                    <AtomNode start="(178, 15)" end="(178, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(178, 18)" end="(178, 19)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(178, 19)" end="(178, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(178, 21)" end="(178, 69)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(178, 21)" end="(178, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(178, 22)" end="(178, 68)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(178, 22)" end="(178, 37)" leading="" trailing=" " raw_val="xs.attach.foldl" val="xs.attach.foldl"/>
                      <NullNode start="(178, 38)" end="(178, 68)">
                        <OtherNode start="(178, 38)" end="(178, 63)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(178, 38)" end="(178, 39)" leading="" trailing="" val="("/>
                          <OtherNode start="(178, 39)" end="(178, 62)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(178, 39)" end="(178, 42)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(178, 43)" end="(178, 62)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(178, 43)" end="(178, 51)">
                                <IdentNode start="(178, 43)" end="(178, 44)" leading="" trailing=" " raw_val="b" val="b"/>
                                <OtherNode start="(178, 45)" end="(178, 51)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(178, 45)" end="(178, 46)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(178, 46)" end="(178, 50)">
                                    <IdentNode start="(178, 46)" end="(178, 47)" leading="" trailing="" raw_val="a" val="a"/>
                                    <AtomNode start="(178, 47)" end="(178, 48)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(178, 49)" end="(178, 50)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                  <AtomNode start="(178, 50)" end="(178, 51)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(178, 52)" end="(178, 54)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(178, 55)" end="(178, 62)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(178, 55)" end="(178, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(178, 57)" end="(178, 62)">
                                  <IdentNode start="(178, 57)" end="(178, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(178, 59)" end="(178, 60)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(178, 61)" end="(178, 62)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(178, 62)" end="(178, 63)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(178, 64)" end="(178, 68)" leading="" trailing="" raw_val="init" val="init"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(178, 68)" end="(178, 69)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(178, 70)" end="(180, 57)">
          <AtomNode start="(178, 70)" end="(178, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(178, 73)" end="(180, 57)">
            <AtomNode start="(178, 73)" end="(178, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(179, 3)" end="(180, 57)">
              <TacticTacticseq1IndentedNode start="(179, 3)" end="(180, 57)">
                <NullNode start="(179, 3)" end="(180, 57)">
                  <OtherNode start="(179, 3)" end="(179, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : (a : α) → a ∈ xs → β → β&#10;init : β&#10;⊢ (forIn' xs init fun a m_1 b =&amp;gt; pure (ForInStep.yield (f a m_1 b))) =&#10;    pure&#10;      (foldl&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, h⟩ =&amp;gt; f a h b)&#10;        init xs.attach)" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → β&#10;⊢ (forIn' { toList := xs } init fun a m_1 b =&amp;gt; pure (ForInStep.yield (f a m_1 b))) =&#10;    pure&#10;      (foldl&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, h⟩ =&amp;gt; f a h b)&#10;        init { toList := xs }.attach)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(179, 3)" end="(179, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(179, 10)" end="(179, 12)">
                      <OtherNode start="(179, 10)" end="(179, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(179, 10)" end="(179, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(179, 13)" end="(179, 22)">
                      <AtomNode start="(179, 13)" end="(179, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(179, 18)" end="(179, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(179, 18)" end="(179, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(179, 18)" end="(179, 22)">
                            <OtherNode start="(179, 18)" end="(179, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(179, 18)" end="(179, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(179, 19)" end="(179, 21)">
                                <OtherNode start="(179, 19)" end="(179, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(179, 19)" end="(179, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(179, 19)" end="(179, 21)">
                                      <OtherNode start="(179, 19)" end="(179, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(179, 19)" end="(179, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(179, 21)" end="(179, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(180, 3)" end="(180, 57)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → β&#10;⊢ (forIn' { toList := xs } init fun a m_1 b =&amp;gt; pure (ForInStep.yield (f a m_1 b))) =&#10;    pure&#10;      (foldl&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, h⟩ =&amp;gt; f a h b)&#10;        init { toList := xs }.attach)" state_after="no goals" tactic="simp [List.forIn'_pure_yield_eq_foldl, List.foldl_map]">
                    <AtomNode start="(180, 3)" end="(180, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(180, 8)" end="(180, 57)">
                      <AtomNode start="(180, 8)" end="(180, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(180, 9)" end="(180, 56)">
                        <OtherNode start="(180, 9)" end="(180, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(180, 9)" end="(180, 40)" leading="" trailing="" raw_val="List.forIn'_pure_yield_eq_foldl" val="List.forIn'_pure_yield_eq_foldl" full_name="List.forIn'_pure_yield_eq_foldl" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                        <AtomNode start="(180, 40)" end="(180, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(180, 42)" end="(180, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(180, 42)" end="(180, 56)" leading="" trailing="" raw_val="List.foldl_map" val="List.foldl_map" full_name="List.foldl_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(180, 56)" end="(180, 57)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(182, 1)" end="(187, 24)" name="forIn'_yield_eq_foldl" full_name="Array.forIn'_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(182, 1)" end="(182, 8)">
        <NullNode/>
        <NullNode start="(182, 1)" end="(182, 8)">
          <OtherNode start="(182, 1)" end="(182, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(182, 1)" end="(182, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(182, 3)" end="(182, 7)">
              <OtherNode start="(182, 3)" end="(182, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(182, 3)" end="(182, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(182, 3)" end="(182, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(182, 7)" end="(182, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(182, 9)" end="(187, 24)" name="forIn'_yield_eq_foldl" full_name="Array.forIn'_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(182, 9)" end="(182, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(182, 17)" end="(182, 38)">
          <IdentNode start="(182, 17)" end="(182, 38)" leading="" trailing="&#10;    " raw_val="forIn'_yield_eq_foldl" val="forIn'_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(183, 5)" end="(185, 53)">
          <NullNode start="(183, 5)" end="(183, 61)">
            <OtherNode start="(183, 5)" end="(183, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(183, 5)" end="(183, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(183, 6)" end="(183, 8)">
                <IdentNode start="(183, 6)" end="(183, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(183, 9)" end="(183, 18)">
                <AtomNode start="(183, 9)" end="(183, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 11)" end="(183, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(183, 11)" end="(183, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(183, 17)" end="(183, 18)">
                    <IdentNode start="(183, 17)" end="(183, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(183, 18)" end="(183, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(183, 20)" end="(183, 50)">
              <AtomNode start="(183, 20)" end="(183, 21)" leading="" trailing="" val="("/>
              <NullNode start="(183, 21)" end="(183, 22)">
                <IdentNode start="(183, 21)" end="(183, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(183, 23)" end="(183, 49)">
                <AtomNode start="(183, 23)" end="(183, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 25)" end="(183, 49)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(183, 25)" end="(183, 32)">
                    <AtomNode start="(183, 25)" end="(183, 26)" leading="" trailing="" val="("/>
                    <NullNode start="(183, 26)" end="(183, 27)">
                      <IdentNode start="(183, 26)" end="(183, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(183, 28)" end="(183, 31)">
                      <AtomNode start="(183, 28)" end="(183, 29)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(183, 30)" end="(183, 31)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(183, 31)" end="(183, 32)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(183, 33)" end="(183, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(183, 35)" end="(183, 49)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(183, 35)" end="(183, 41)" kind="«term_∈_»">
                      <IdentNode start="(183, 35)" end="(183, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(183, 37)" end="(183, 38)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(183, 39)" end="(183, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(183, 42)" end="(183, 43)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(183, 44)" end="(183, 49)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(183, 44)" end="(183, 45)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(183, 46)" end="(183, 47)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(183, 48)" end="(183, 49)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(183, 49)" end="(183, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(183, 51)" end="(183, 61)">
              <AtomNode start="(183, 51)" end="(183, 52)" leading="" trailing="" val="("/>
              <NullNode start="(183, 52)" end="(183, 56)">
                <IdentNode start="(183, 52)" end="(183, 56)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(183, 57)" end="(183, 60)">
                <AtomNode start="(183, 57)" end="(183, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(183, 59)" end="(183, 60)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(183, 60)" end="(183, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(183, 62)" end="(185, 53)">
            <AtomNode start="(183, 62)" end="(183, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(184, 5)" end="(185, 53)" kind="«term_=_»">
              <OtherNode start="(184, 5)" end="(184, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(184, 5)" end="(184, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(184, 12)" end="(184, 61)">
                  <OtherNode start="(184, 12)" end="(184, 21)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(184, 12)" end="(184, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(184, 13)" end="(184, 14)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(184, 15)" end="(184, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(184, 18)" end="(184, 20)" leading="" trailing="" raw_val="Id" val="Id" full_name="Id" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                    <AtomNode start="(184, 20)" end="(184, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(184, 22)" end="(184, 24)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(184, 25)" end="(184, 29)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(184, 30)" end="(184, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(184, 30)" end="(184, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(184, 31)" end="(184, 60)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(184, 31)" end="(184, 34)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(184, 35)" end="(184, 60)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(184, 35)" end="(184, 40)">
                          <IdentNode start="(184, 35)" end="(184, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(184, 37)" end="(184, 38)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(184, 39)" end="(184, 40)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(184, 41)" end="(184, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(184, 44)" end="(184, 60)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(184, 44)" end="(184, 50)" kind="Lean.Parser.Term.dotIdent">
                            <AtomNode start="(184, 44)" end="(184, 45)" leading="" trailing="" val="."/>
                            <IdentNode start="(184, 45)" end="(184, 50)" leading="" trailing=" " raw_val="yield" val="yield"/>
                          </OtherNode>
                          <NullNode start="(184, 51)" end="(184, 60)">
                            <OtherNode start="(184, 51)" end="(184, 60)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(184, 51)" end="(184, 52)" leading="" trailing="" val="("/>
                              <OtherNode start="(184, 52)" end="(184, 59)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(184, 52)" end="(184, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(184, 54)" end="(184, 59)">
                                  <IdentNode start="(184, 54)" end="(184, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(184, 56)" end="(184, 57)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <IdentNode start="(184, 58)" end="(184, 59)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(184, 59)" end="(184, 60)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(184, 60)" end="(184, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(184, 62)" end="(184, 63)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(185, 7)" end="(185, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(185, 7)" end="(185, 22)" leading="" trailing=" " raw_val="xs.attach.foldl" val="xs.attach.foldl"/>
                <NullNode start="(185, 23)" end="(185, 53)">
                  <OtherNode start="(185, 23)" end="(185, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(185, 23)" end="(185, 24)" leading="" trailing="" val="("/>
                    <OtherNode start="(185, 24)" end="(185, 47)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(185, 24)" end="(185, 27)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(185, 28)" end="(185, 47)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(185, 28)" end="(185, 36)">
                          <IdentNode start="(185, 28)" end="(185, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                          <OtherNode start="(185, 30)" end="(185, 36)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(185, 30)" end="(185, 31)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(185, 31)" end="(185, 35)">
                              <IdentNode start="(185, 31)" end="(185, 32)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(185, 32)" end="(185, 33)" leading="" trailing=" " val=","/>
                              <IdentNode start="(185, 34)" end="(185, 35)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                            <AtomNode start="(185, 35)" end="(185, 36)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(185, 37)" end="(185, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(185, 40)" end="(185, 47)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(185, 40)" end="(185, 41)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(185, 42)" end="(185, 47)">
                            <IdentNode start="(185, 42)" end="(185, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(185, 44)" end="(185, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                            <IdentNode start="(185, 46)" end="(185, 47)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(185, 47)" end="(185, 48)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(185, 49)" end="(185, 53)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(185, 54)" end="(187, 24)">
          <AtomNode start="(185, 54)" end="(185, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(185, 57)" end="(187, 24)">
            <AtomNode start="(185, 57)" end="(185, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(186, 3)" end="(187, 24)">
              <TacticTacticseq1IndentedNode start="(186, 3)" end="(187, 24)">
                <NullNode start="(186, 3)" end="(187, 24)">
                  <OtherNode start="(186, 3)" end="(186, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : Array α&#10;f : (a : α) → a ∈ xs → β → β&#10;init : β&#10;⊢ (forIn' xs init fun a m b =&amp;gt; ForInStep.yield (f a m b)) =&#10;    foldl&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f a h b)&#10;      init xs.attach" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → β&#10;⊢ (forIn' { toList := xs } init fun a m b =&amp;gt; ForInStep.yield (f a m b)) =&#10;    foldl&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f a h b)&#10;      init { toList := xs }.attach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(186, 3)" end="(186, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(186, 10)" end="(186, 12)">
                      <OtherNode start="(186, 10)" end="(186, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(186, 10)" end="(186, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(186, 13)" end="(186, 22)">
                      <AtomNode start="(186, 13)" end="(186, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(186, 18)" end="(186, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(186, 18)" end="(186, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(186, 18)" end="(186, 22)">
                            <OtherNode start="(186, 18)" end="(186, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(186, 18)" end="(186, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(186, 19)" end="(186, 21)">
                                <OtherNode start="(186, 19)" end="(186, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(186, 19)" end="(186, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(186, 19)" end="(186, 21)">
                                      <OtherNode start="(186, 19)" end="(186, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(186, 19)" end="(186, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(186, 21)" end="(186, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(187, 3)" end="(187, 24)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;init : β&#10;xs : List α&#10;f : (a : α) → a ∈ { toList := xs } → β → β&#10;⊢ (forIn' { toList := xs } init fun a m b =&amp;gt; ForInStep.yield (f a m b)) =&#10;    foldl&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f a h b)&#10;      init { toList := xs }.attach" state_after="no goals" tactic="simp [List.foldl_map]">
                    <AtomNode start="(187, 3)" end="(187, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(187, 8)" end="(187, 24)">
                      <AtomNode start="(187, 8)" end="(187, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(187, 9)" end="(187, 23)">
                        <OtherNode start="(187, 9)" end="(187, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(187, 9)" end="(187, 23)" leading="" trailing="" raw_val="List.foldl_map" val="List.foldl_map" full_name="List.foldl_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(187, 23)" end="(187, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(189, 1)" end="(193, 7)" name="forIn'_map" full_name="Array.forIn'_map">
      <CommandDeclmodifiersNode start="(189, 1)" end="(189, 8)">
        <NullNode/>
        <NullNode start="(189, 1)" end="(189, 8)">
          <OtherNode start="(189, 1)" end="(189, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(189, 1)" end="(189, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(189, 3)" end="(189, 7)">
              <OtherNode start="(189, 3)" end="(189, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(189, 3)" end="(189, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(189, 3)" end="(189, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(189, 7)" end="(189, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(189, 9)" end="(193, 7)" name="forIn'_map" full_name="Array.forIn'_map" _is_private_decl="False">
        <AtomNode start="(189, 9)" end="(189, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(189, 17)" end="(189, 27)">
          <IdentNode start="(189, 17)" end="(189, 27)" leading="" trailing=" " raw_val="forIn'_map" val="forIn'_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(189, 28)" end="(191, 88)">
          <NullNode start="(189, 28)" end="(190, 82)">
            <OtherNode start="(189, 28)" end="(189, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(189, 28)" end="(189, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(189, 29)" end="(189, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(189, 29)" end="(189, 34)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(189, 35)" end="(189, 36)">
                  <IdentNode start="(189, 35)" end="(189, 36)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(189, 36)" end="(189, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(189, 38)" end="(189, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(189, 38)" end="(189, 39)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(189, 39)" end="(189, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(189, 39)" end="(189, 50)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(189, 51)" end="(189, 52)">
                  <IdentNode start="(189, 51)" end="(189, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(189, 52)" end="(189, 53)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(190, 5)" end="(190, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(190, 5)" end="(190, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(190, 6)" end="(190, 8)">
                <IdentNode start="(190, 6)" end="(190, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(190, 9)" end="(190, 18)">
                <AtomNode start="(190, 9)" end="(190, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 11)" end="(190, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(190, 11)" end="(190, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(190, 17)" end="(190, 18)">
                    <IdentNode start="(190, 17)" end="(190, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(190, 18)" end="(190, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(190, 20)" end="(190, 31)">
              <AtomNode start="(190, 20)" end="(190, 21)" leading="" trailing="" val="("/>
              <NullNode start="(190, 21)" end="(190, 22)">
                <IdentNode start="(190, 21)" end="(190, 22)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(190, 23)" end="(190, 30)">
                <AtomNode start="(190, 23)" end="(190, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 25)" end="(190, 30)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(190, 25)" end="(190, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(190, 27)" end="(190, 28)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(190, 29)" end="(190, 30)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(190, 30)" end="(190, 31)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(190, 32)" end="(190, 82)">
              <AtomNode start="(190, 32)" end="(190, 33)" leading="" trailing="" val="("/>
              <NullNode start="(190, 33)" end="(190, 34)">
                <IdentNode start="(190, 33)" end="(190, 34)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(190, 35)" end="(190, 81)">
                <AtomNode start="(190, 35)" end="(190, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 37)" end="(190, 81)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(190, 37)" end="(190, 44)">
                    <AtomNode start="(190, 37)" end="(190, 38)" leading="" trailing="" val="("/>
                    <NullNode start="(190, 38)" end="(190, 39)">
                      <IdentNode start="(190, 38)" end="(190, 39)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                    <NullNode start="(190, 40)" end="(190, 43)">
                      <AtomNode start="(190, 40)" end="(190, 41)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(190, 42)" end="(190, 43)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(190, 43)" end="(190, 44)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(190, 45)" end="(190, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(190, 47)" end="(190, 81)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(190, 47)" end="(190, 59)" kind="«term_∈_»">
                      <IdentNode start="(190, 47)" end="(190, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(190, 49)" end="(190, 50)" leading="" trailing=" " val="∈"/>
                      <OtherNode start="(190, 51)" end="(190, 59)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(190, 51)" end="(190, 57)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                        <NullNode start="(190, 58)" end="(190, 59)">
                          <IdentNode start="(190, 58)" end="(190, 59)" leading="" trailing=" " raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(190, 60)" end="(190, 61)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(190, 62)" end="(190, 81)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(190, 62)" end="(190, 63)" leading="" trailing=" " raw_val="γ" val="γ"/>
                      <AtomNode start="(190, 64)" end="(190, 65)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(190, 66)" end="(190, 81)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(190, 66)" end="(190, 67)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(190, 68)" end="(190, 81)">
                          <OtherNode start="(190, 68)" end="(190, 81)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(190, 68)" end="(190, 69)" leading="" trailing="" val="("/>
                            <OtherNode start="(190, 69)" end="(190, 80)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(190, 69)" end="(190, 78)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(190, 79)" end="(190, 80)">
                                <IdentNode start="(190, 79)" end="(190, 80)" leading="" trailing="" raw_val="γ" val="γ"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(190, 80)" end="(190, 81)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(190, 81)" end="(190, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(190, 83)" end="(191, 88)">
            <AtomNode start="(190, 83)" end="(190, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(191, 5)" end="(191, 88)" kind="«term_=_»">
              <OtherNode start="(191, 5)" end="(191, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(191, 5)" end="(191, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(191, 12)" end="(191, 29)">
                  <OtherNode start="(191, 12)" end="(191, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(191, 12)" end="(191, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(191, 13)" end="(191, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(191, 13)" end="(191, 19)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(191, 20)" end="(191, 21)">
                        <IdentNode start="(191, 20)" end="(191, 21)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(191, 21)" end="(191, 22)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(191, 23)" end="(191, 27)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(191, 28)" end="(191, 29)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(191, 30)" end="(191, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(191, 32)" end="(191, 88)" kind="Lean.Parser.Term.app">
                <IdentNode start="(191, 32)" end="(191, 38)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(191, 39)" end="(191, 88)">
                  <IdentNode start="(191, 39)" end="(191, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(191, 42)" end="(191, 46)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(191, 47)" end="(191, 88)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(191, 47)" end="(191, 50)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(191, 51)" end="(191, 88)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(191, 51)" end="(191, 56)">
                        <IdentNode start="(191, 51)" end="(191, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(191, 53)" end="(191, 54)" leading="" trailing=" " raw_val="h" val="h"/>
                        <IdentNode start="(191, 55)" end="(191, 56)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(191, 57)" end="(191, 59)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(191, 60)" end="(191, 88)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(191, 60)" end="(191, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(191, 62)" end="(191, 88)">
                          <OtherNode start="(191, 62)" end="(191, 67)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(191, 62)" end="(191, 63)" leading="" trailing="" val="("/>
                            <OtherNode start="(191, 63)" end="(191, 66)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(191, 63)" end="(191, 64)" leading="" trailing=" " raw_val="g" val="g"/>
                              <NullNode start="(191, 65)" end="(191, 66)">
                                <IdentNode start="(191, 65)" end="(191, 66)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(191, 66)" end="(191, 67)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(191, 68)" end="(191, 86)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(191, 68)" end="(191, 69)" leading="" trailing="" val="("/>
                            <OtherNode start="(191, 69)" end="(191, 85)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(191, 69)" end="(191, 83)" leading="" trailing=" " raw_val="mem_map_of_mem" val="mem_map_of_mem" full_name="Array.mem_map_of_mem" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                              <NullNode start="(191, 84)" end="(191, 85)">
                                <IdentNode start="(191, 84)" end="(191, 85)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(191, 85)" end="(191, 86)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <IdentNode start="(191, 87)" end="(191, 88)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(191, 89)" end="(193, 7)">
          <AtomNode start="(191, 89)" end="(191, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(191, 92)" end="(193, 7)">
            <AtomNode start="(191, 92)" end="(191, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(192, 3)" end="(193, 7)">
              <TacticTacticseq1IndentedNode start="(192, 3)" end="(193, 7)">
                <NullNode start="(192, 3)" end="(193, 7)">
                  <OtherNode start="(192, 3)" end="(192, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;g : α → β&#10;f : (b : β) → b ∈ map g xs → γ → m (ForInStep γ)&#10;⊢ forIn' (map g xs) init f = forIn' xs init fun a h y =&amp;gt; f (g a) ⋯ y" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;g : α → β&#10;xs : List α&#10;f : (b : β) → b ∈ map g { toList := xs } → γ → m (ForInStep γ)&#10;⊢ forIn' (map g { toList := xs }) init f = forIn' { toList := xs } init fun a h y =&amp;gt; f (g a) ⋯ y" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(192, 3)" end="(192, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(192, 10)" end="(192, 12)">
                      <OtherNode start="(192, 10)" end="(192, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(192, 10)" end="(192, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(192, 13)" end="(192, 22)">
                      <AtomNode start="(192, 13)" end="(192, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(192, 18)" end="(192, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(192, 18)" end="(192, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(192, 18)" end="(192, 22)">
                            <OtherNode start="(192, 18)" end="(192, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(192, 18)" end="(192, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(192, 19)" end="(192, 21)">
                                <OtherNode start="(192, 19)" end="(192, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(192, 19)" end="(192, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(192, 19)" end="(192, 21)">
                                      <OtherNode start="(192, 19)" end="(192, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(192, 19)" end="(192, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(192, 21)" end="(192, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(193, 3)" end="(193, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;g : α → β&#10;xs : List α&#10;f : (b : β) → b ∈ map g { toList := xs } → γ → m (ForInStep γ)&#10;⊢ forIn' (map g { toList := xs }) init f = forIn' { toList := xs } init fun a h y =&amp;gt; f (g a) ⋯ y" state_after="no goals" tactic="simp">
                    <AtomNode start="(193, 3)" end="(193, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(195, 1)" end="(207, 8)" name="forIn_eq_foldlM" full_name="Array.forIn_eq_foldlM">
      <CommandDeclmodifiersNode start="(195, 1)" end="(198, 3)">
        <NullNode start="(195, 1)" end="(198, 3)">
          <CommandDoccommentNode start="(195, 1)" end="(198, 3)" comment="We can express a for loop over an array as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/">
            <AtomNode start="(195, 1)" end="(195, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(196, 1)" end="(198, 3)" leading="" trailing="&#10;" val="We can express a for loop over an array as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(199, 1)" end="(207, 8)" name="forIn_eq_foldlM" full_name="Array.forIn_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(199, 1)" end="(199, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(199, 9)" end="(199, 24)">
          <IdentNode start="(199, 9)" end="(199, 24)" leading="" trailing=" " raw_val="forIn_eq_foldlM" val="forIn_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(199, 25)" end="(204, 60)">
          <NullNode start="(199, 25)" end="(200, 60)">
            <OtherNode start="(199, 25)" end="(199, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(199, 25)" end="(199, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(199, 26)" end="(199, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(199, 26)" end="(199, 31)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(199, 32)" end="(199, 33)">
                  <IdentNode start="(199, 32)" end="(199, 33)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(199, 33)" end="(199, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(199, 35)" end="(199, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(199, 35)" end="(199, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(199, 36)" end="(199, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(199, 36)" end="(199, 47)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(199, 48)" end="(199, 49)">
                  <IdentNode start="(199, 48)" end="(199, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(199, 49)" end="(199, 50)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(200, 5)" end="(200, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(200, 5)" end="(200, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(200, 6)" end="(200, 8)">
                <IdentNode start="(200, 6)" end="(200, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(200, 9)" end="(200, 18)">
                <AtomNode start="(200, 9)" end="(200, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(200, 11)" end="(200, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(200, 11)" end="(200, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(200, 17)" end="(200, 18)">
                    <IdentNode start="(200, 17)" end="(200, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(200, 18)" end="(200, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(200, 20)" end="(200, 49)">
              <AtomNode start="(200, 20)" end="(200, 21)" leading="" trailing="" val="("/>
              <NullNode start="(200, 21)" end="(200, 22)">
                <IdentNode start="(200, 21)" end="(200, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(200, 23)" end="(200, 48)">
                <AtomNode start="(200, 23)" end="(200, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(200, 25)" end="(200, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(200, 25)" end="(200, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(200, 27)" end="(200, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(200, 29)" end="(200, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(200, 29)" end="(200, 30)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(200, 31)" end="(200, 32)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(200, 33)" end="(200, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(200, 33)" end="(200, 34)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(200, 35)" end="(200, 48)">
                        <OtherNode start="(200, 35)" end="(200, 48)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(200, 35)" end="(200, 36)" leading="" trailing="" val="("/>
                          <OtherNode start="(200, 36)" end="(200, 47)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(200, 36)" end="(200, 45)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(200, 46)" end="(200, 47)">
                              <IdentNode start="(200, 46)" end="(200, 47)" leading="" trailing="" raw_val="β" val="β"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(200, 47)" end="(200, 48)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(200, 48)" end="(200, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(200, 50)" end="(200, 60)">
              <AtomNode start="(200, 50)" end="(200, 51)" leading="" trailing="" val="("/>
              <NullNode start="(200, 51)" end="(200, 55)">
                <IdentNode start="(200, 51)" end="(200, 55)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(200, 56)" end="(200, 59)">
                <AtomNode start="(200, 56)" end="(200, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(200, 58)" end="(200, 59)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(200, 59)" end="(200, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(200, 61)" end="(204, 60)">
            <AtomNode start="(200, 61)" end="(200, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(201, 5)" end="(204, 60)" kind="«term_=_»">
              <OtherNode start="(201, 5)" end="(201, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(201, 5)" end="(201, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(201, 11)" end="(201, 20)">
                  <IdentNode start="(201, 11)" end="(201, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(201, 14)" end="(201, 18)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(201, 19)" end="(201, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(201, 21)" end="(201, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(201, 23)" end="(204, 60)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(201, 23)" end="(201, 38)" leading="" trailing=" " raw_val="ForInStep.value" val="ForInStep.value" full_name="ForInStep.value" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <AtomNode start="(201, 39)" end="(201, 42)" leading="" trailing="&#10;      " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(202, 7)" end="(204, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(202, 7)" end="(202, 16)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                  <NullNode start="(202, 17)" end="(204, 60)">
                    <OtherNode start="(202, 17)" end="(204, 37)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(202, 17)" end="(202, 18)" leading="" trailing="" val="("/>
                      <OtherNode start="(202, 18)" end="(204, 36)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(202, 18)" end="(202, 21)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(202, 22)" end="(204, 36)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(202, 22)" end="(202, 25)">
                            <IdentNode start="(202, 22)" end="(202, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                            <IdentNode start="(202, 24)" end="(202, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(202, 26)" end="(202, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(202, 29)" end="(204, 36)" kind="Lean.Parser.Term.match">
                            <AtomNode start="(202, 29)" end="(202, 34)" leading="" trailing=" " val="match"/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(202, 35)" end="(202, 36)">
                              <OtherNode start="(202, 35)" end="(202, 36)" kind="Lean.Parser.Term.matchDiscr">
                                <NullNode/>
                                <IdentNode start="(202, 35)" end="(202, 36)" leading="" trailing=" " raw_val="b" val="b"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(202, 37)" end="(202, 41)" leading="" trailing="&#10;        " val="with"/>
                            <OtherNode start="(203, 9)" end="(204, 36)" kind="Lean.Parser.Term.matchAlts">
                              <NullNode start="(203, 9)" end="(204, 36)">
                                <OtherNode start="(203, 9)" end="(203, 28)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(203, 9)" end="(203, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(203, 11)" end="(203, 19)">
                                    <NullNode start="(203, 11)" end="(203, 19)">
                                      <OtherNode start="(203, 11)" end="(203, 19)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(203, 11)" end="(203, 17)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(203, 11)" end="(203, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(203, 12)" end="(203, 17)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                        </OtherNode>
                                        <NullNode start="(203, 18)" end="(203, 19)">
                                          <IdentNode start="(203, 18)" end="(203, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(203, 20)" end="(203, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(203, 23)" end="(203, 28)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(203, 23)" end="(203, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(203, 25)" end="(203, 28)">
                                      <IdentNode start="(203, 25)" end="(203, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <IdentNode start="(203, 27)" end="(203, 28)" leading="" trailing="&#10;        " raw_val="b" val="b"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(204, 9)" end="(204, 36)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(204, 9)" end="(204, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(204, 11)" end="(204, 18)">
                                    <NullNode start="(204, 11)" end="(204, 18)">
                                      <OtherNode start="(204, 11)" end="(204, 18)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(204, 11)" end="(204, 16)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(204, 11)" end="(204, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(204, 12)" end="(204, 16)" leading="" trailing=" " raw_val="done" val="done"/>
                                        </OtherNode>
                                        <NullNode start="(204, 17)" end="(204, 18)">
                                          <IdentNode start="(204, 17)" end="(204, 18)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(204, 19)" end="(204, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(204, 22)" end="(204, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(204, 22)" end="(204, 26)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(204, 27)" end="(204, 36)">
                                      <OtherNode start="(204, 27)" end="(204, 36)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(204, 27)" end="(204, 28)" leading="" trailing="" val="("/>
                                        <OtherNode start="(204, 28)" end="(204, 35)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(204, 28)" end="(204, 33)" kind="Lean.Parser.Term.dotIdent">
                                            <AtomNode start="(204, 28)" end="(204, 29)" leading="" trailing="" val="."/>
                                            <IdentNode start="(204, 29)" end="(204, 33)" leading="" trailing=" " raw_val="done" val="done"/>
                                          </OtherNode>
                                          <NullNode start="(204, 34)" end="(204, 35)">
                                            <IdentNode start="(204, 34)" end="(204, 35)" leading="" trailing="" raw_val="b" val="b"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(204, 35)" end="(204, 36)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(204, 36)" end="(204, 37)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(204, 38)" end="(204, 60)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(204, 38)" end="(204, 39)" leading="" trailing="" val="("/>
                      <OtherNode start="(204, 39)" end="(204, 59)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(204, 39)" end="(204, 54)" leading="" trailing=" " raw_val="ForInStep.yield" val="ForInStep.yield" full_name="ForInStep.yield" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        <NullNode start="(204, 55)" end="(204, 59)">
                          <IdentNode start="(204, 55)" end="(204, 59)" leading="" trailing="" raw_val="init" val="init"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(204, 59)" end="(204, 60)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(204, 61)" end="(207, 8)">
          <AtomNode start="(204, 61)" end="(204, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(204, 64)" end="(207, 8)">
            <AtomNode start="(204, 64)" end="(204, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(205, 3)" end="(207, 8)">
              <TacticTacticseq1IndentedNode start="(205, 3)" end="(207, 8)">
                <NullNode start="(205, 3)" end="(207, 8)">
                  <OtherNode start="(205, 3)" end="(205, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → β → m (ForInStep β)&#10;init : β&#10;⊢ forIn xs init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;init : β&#10;xs : List α&#10;⊢ forIn { toList := xs } init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(205, 3)" end="(205, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(205, 10)" end="(205, 12)">
                      <OtherNode start="(205, 10)" end="(205, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(205, 10)" end="(205, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(205, 13)" end="(205, 22)">
                      <AtomNode start="(205, 13)" end="(205, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(205, 18)" end="(205, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(205, 18)" end="(205, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(205, 18)" end="(205, 22)">
                            <OtherNode start="(205, 18)" end="(205, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(205, 18)" end="(205, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(205, 19)" end="(205, 21)">
                                <OtherNode start="(205, 19)" end="(205, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(205, 19)" end="(205, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(205, 19)" end="(205, 21)">
                                      <OtherNode start="(205, 19)" end="(205, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(205, 19)" end="(205, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(205, 21)" end="(205, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(206, 3)" end="(206, 96)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;init : β&#10;xs : List α&#10;⊢ forIn { toList := xs } init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) { toList := xs }" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;init : β&#10;xs : List α&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun x y =&amp;gt;&#10;          match x with&#10;          | ForInStep.yield b =&amp;gt; f y b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs" tactic="simp only [List.forIn_toArray, List.forIn_eq_foldlM, List.size_toArray, List.foldlM_toArray']">
                    <AtomNode start="(206, 3)" end="(206, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(206, 8)" end="(206, 12)">
                      <AtomNode start="(206, 8)" end="(206, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(206, 13)" end="(206, 96)">
                      <AtomNode start="(206, 13)" end="(206, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(206, 14)" end="(206, 95)">
                        <OtherNode start="(206, 14)" end="(206, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(206, 14)" end="(206, 32)" leading="" trailing="" raw_val="List.forIn_toArray" val="List.forIn_toArray" full_name="List.forIn_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(206, 32)" end="(206, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(206, 34)" end="(206, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(206, 34)" end="(206, 54)" leading="" trailing="" raw_val="List.forIn_eq_foldlM" val="List.forIn_eq_foldlM" full_name="List.forIn_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                        <AtomNode start="(206, 54)" end="(206, 55)" leading="" trailing=" " val=","/>
                        <OtherNode start="(206, 56)" end="(206, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(206, 56)" end="(206, 73)" leading="" trailing="" raw_val="List.size_toArray" val="List.size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(206, 73)" end="(206, 74)" leading="" trailing=" " val=","/>
                        <OtherNode start="(206, 75)" end="(206, 95)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(206, 75)" end="(206, 95)" leading="" trailing="" raw_val="List.foldlM_toArray'" val="List.foldlM_toArray'" full_name="List.foldlM_toArray'" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(206, 95)" end="(206, 96)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(207, 3)" end="(207, 8)" kind="Lean.Parser.Tactic.congr" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;init : β&#10;xs : List α&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      List.foldlM&#10;        (fun x y =&amp;gt;&#10;          match x with&#10;          | ForInStep.yield b =&amp;gt; f y b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) xs" state_after="no goals" tactic="congr">
                    <AtomNode start="(207, 3)" end="(207, 8)" leading="" trailing="&#10;&#10;" val="congr"/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(209, 1)" end="(215, 25)" name="forIn_yield_eq_foldlM" full_name="Array.forIn_yield_eq_foldlM">
      <CommandDeclmodifiersNode start="(209, 1)" end="(210, 8)">
        <NullNode start="(209, 1)" end="(209, 78)">
          <CommandDoccommentNode start="(209, 1)" end="(209, 78)" comment="We can express a for loop over an array which always yields as a fold. -/">
            <AtomNode start="(209, 1)" end="(209, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(209, 5)" end="(209, 78)" leading="" trailing="&#10;" val="We can express a for loop over an array which always yields as a fold. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(210, 1)" end="(210, 8)">
          <OtherNode start="(210, 1)" end="(210, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(210, 1)" end="(210, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(210, 3)" end="(210, 7)">
              <OtherNode start="(210, 3)" end="(210, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(210, 3)" end="(210, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(210, 3)" end="(210, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(210, 7)" end="(210, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(210, 9)" end="(215, 25)" name="forIn_yield_eq_foldlM" full_name="Array.forIn_yield_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(210, 9)" end="(210, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(210, 17)" end="(210, 38)">
          <IdentNode start="(210, 17)" end="(210, 38)" leading="" trailing=" " raw_val="forIn_yield_eq_foldlM" val="forIn_yield_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(210, 39)" end="(213, 50)">
          <NullNode start="(210, 39)" end="(211, 68)">
            <OtherNode start="(210, 39)" end="(210, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(210, 39)" end="(210, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(210, 40)" end="(210, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(210, 40)" end="(210, 45)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(210, 46)" end="(210, 47)">
                  <IdentNode start="(210, 46)" end="(210, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(210, 47)" end="(210, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(210, 49)" end="(210, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(210, 49)" end="(210, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(210, 50)" end="(210, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(210, 50)" end="(210, 61)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(210, 62)" end="(210, 63)">
                  <IdentNode start="(210, 62)" end="(210, 63)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(210, 63)" end="(210, 64)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(211, 5)" end="(211, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(211, 5)" end="(211, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(211, 6)" end="(211, 8)">
                <IdentNode start="(211, 6)" end="(211, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(211, 9)" end="(211, 18)">
                <AtomNode start="(211, 9)" end="(211, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 11)" end="(211, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 11)" end="(211, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(211, 17)" end="(211, 18)">
                    <IdentNode start="(211, 17)" end="(211, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(211, 18)" end="(211, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(211, 20)" end="(211, 37)">
              <AtomNode start="(211, 20)" end="(211, 21)" leading="" trailing="" val="("/>
              <NullNode start="(211, 21)" end="(211, 22)">
                <IdentNode start="(211, 21)" end="(211, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(211, 23)" end="(211, 36)">
                <AtomNode start="(211, 23)" end="(211, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 25)" end="(211, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(211, 25)" end="(211, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(211, 27)" end="(211, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(211, 29)" end="(211, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(211, 29)" end="(211, 30)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(211, 31)" end="(211, 32)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(211, 33)" end="(211, 36)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(211, 33)" end="(211, 34)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(211, 35)" end="(211, 36)">
                        <IdentNode start="(211, 35)" end="(211, 36)" leading="" trailing="" raw_val="γ" val="γ"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(211, 36)" end="(211, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(211, 38)" end="(211, 57)">
              <AtomNode start="(211, 38)" end="(211, 39)" leading="" trailing="" val="("/>
              <NullNode start="(211, 39)" end="(211, 40)">
                <IdentNode start="(211, 39)" end="(211, 40)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(211, 41)" end="(211, 56)">
                <AtomNode start="(211, 41)" end="(211, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 43)" end="(211, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(211, 43)" end="(211, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(211, 45)" end="(211, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(211, 47)" end="(211, 56)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(211, 47)" end="(211, 48)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(211, 49)" end="(211, 50)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(211, 51)" end="(211, 56)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(211, 51)" end="(211, 52)" leading="" trailing=" " raw_val="γ" val="γ"/>
                      <AtomNode start="(211, 53)" end="(211, 54)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(211, 55)" end="(211, 56)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(211, 56)" end="(211, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(211, 58)" end="(211, 68)">
              <AtomNode start="(211, 58)" end="(211, 59)" leading="" trailing="" val="("/>
              <NullNode start="(211, 59)" end="(211, 63)">
                <IdentNode start="(211, 59)" end="(211, 63)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(211, 64)" end="(211, 67)">
                <AtomNode start="(211, 64)" end="(211, 65)" leading="" trailing=" " val=":"/>
                <IdentNode start="(211, 66)" end="(211, 67)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(211, 67)" end="(211, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(211, 69)" end="(213, 50)">
            <AtomNode start="(211, 69)" end="(211, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(212, 5)" end="(213, 50)" kind="«term_=_»">
              <OtherNode start="(212, 5)" end="(212, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(212, 5)" end="(212, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(212, 11)" end="(212, 69)">
                  <IdentNode start="(212, 11)" end="(212, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(212, 14)" end="(212, 18)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(212, 19)" end="(212, 69)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(212, 19)" end="(212, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(212, 20)" end="(212, 68)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(212, 20)" end="(212, 23)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(212, 24)" end="(212, 68)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(212, 24)" end="(212, 27)">
                          <IdentNode start="(212, 24)" end="(212, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(212, 26)" end="(212, 27)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(212, 28)" end="(212, 30)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(212, 31)" end="(212, 68)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(212, 31)" end="(212, 58)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(212, 31)" end="(212, 32)" leading="" trailing="" val="("/>
                            <OtherNode start="(212, 32)" end="(212, 57)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(212, 32)" end="(212, 35)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(212, 36)" end="(212, 57)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(212, 36)" end="(212, 37)">
                                  <IdentNode start="(212, 36)" end="(212, 37)" leading="" trailing=" " raw_val="c" val="c"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(212, 38)" end="(212, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(212, 41)" end="(212, 57)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(212, 41)" end="(212, 47)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(212, 41)" end="(212, 42)" leading="" trailing="" val="."/>
                                    <IdentNode start="(212, 42)" end="(212, 47)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                  </OtherNode>
                                  <NullNode start="(212, 48)" end="(212, 57)">
                                    <OtherNode start="(212, 48)" end="(212, 57)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(212, 48)" end="(212, 49)" leading="" trailing="" val="("/>
                                      <OtherNode start="(212, 49)" end="(212, 56)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(212, 49)" end="(212, 50)" leading="" trailing=" " raw_val="g" val="g"/>
                                        <NullNode start="(212, 51)" end="(212, 56)">
                                          <IdentNode start="(212, 51)" end="(212, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <IdentNode start="(212, 53)" end="(212, 54)" leading="" trailing=" " raw_val="b" val="b"/>
                                          <IdentNode start="(212, 55)" end="(212, 56)" leading="" trailing="" raw_val="c" val="c"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(212, 56)" end="(212, 57)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(212, 57)" end="(212, 58)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <AtomNode start="(212, 59)" end="(212, 62)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(212, 63)" end="(212, 68)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(212, 63)" end="(212, 64)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(212, 65)" end="(212, 68)">
                              <IdentNode start="(212, 65)" end="(212, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(212, 67)" end="(212, 68)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(212, 68)" end="(212, 69)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(212, 70)" end="(212, 71)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(213, 7)" end="(213, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(213, 7)" end="(213, 16)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(213, 17)" end="(213, 50)">
                  <OtherNode start="(213, 17)" end="(213, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(213, 17)" end="(213, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(213, 18)" end="(213, 44)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(213, 18)" end="(213, 21)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(213, 22)" end="(213, 44)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(213, 22)" end="(213, 25)">
                          <IdentNode start="(213, 22)" end="(213, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(213, 24)" end="(213, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(213, 26)" end="(213, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(213, 29)" end="(213, 44)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(213, 29)" end="(213, 34)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(213, 29)" end="(213, 30)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(213, 31)" end="(213, 34)">
                              <IdentNode start="(213, 31)" end="(213, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(213, 33)" end="(213, 34)" leading="" trailing=" " raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(213, 35)" end="(213, 38)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(213, 39)" end="(213, 44)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(213, 39)" end="(213, 40)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(213, 41)" end="(213, 44)">
                              <IdentNode start="(213, 41)" end="(213, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(213, 43)" end="(213, 44)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(213, 44)" end="(213, 45)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(213, 46)" end="(213, 50)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(213, 51)" end="(215, 25)">
          <AtomNode start="(213, 51)" end="(213, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(213, 54)" end="(215, 25)">
            <AtomNode start="(213, 54)" end="(213, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(214, 3)" end="(215, 25)">
              <TacticTacticseq1IndentedNode start="(214, 3)" end="(215, 25)">
                <NullNode start="(214, 3)" end="(215, 25)">
                  <OtherNode start="(214, 3)" end="(214, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → β → m γ&#10;g : α → β → γ → β&#10;init : β&#10;⊢ (forIn xs init fun a b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a b c)) &amp;lt;$&amp;gt; f a b) =&#10;    foldlM (fun b a =&amp;gt; g a b &amp;lt;$&amp;gt; f a b) init xs" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m γ&#10;g : α → β → γ → β&#10;init : β&#10;xs : List α&#10;⊢ (forIn { toList := xs } init fun a b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a b c)) &amp;lt;$&amp;gt; f a b) =&#10;    foldlM (fun b a =&amp;gt; g a b &amp;lt;$&amp;gt; f a b) init { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(214, 3)" end="(214, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(214, 10)" end="(214, 12)">
                      <OtherNode start="(214, 10)" end="(214, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(214, 10)" end="(214, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(214, 13)" end="(214, 22)">
                      <AtomNode start="(214, 13)" end="(214, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(214, 18)" end="(214, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(214, 18)" end="(214, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(214, 18)" end="(214, 22)">
                            <OtherNode start="(214, 18)" end="(214, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(214, 18)" end="(214, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(214, 19)" end="(214, 21)">
                                <OtherNode start="(214, 19)" end="(214, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(214, 19)" end="(214, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(214, 19)" end="(214, 21)">
                                      <OtherNode start="(214, 19)" end="(214, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(214, 19)" end="(214, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(214, 21)" end="(214, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(215, 3)" end="(215, 25)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m γ&#10;g : α → β → γ → β&#10;init : β&#10;xs : List α&#10;⊢ (forIn { toList := xs } init fun a b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a b c)) &amp;lt;$&amp;gt; f a b) =&#10;    foldlM (fun b a =&amp;gt; g a b &amp;lt;$&amp;gt; f a b) init { toList := xs }" state_after="no goals" tactic="simp [List.foldlM_map]">
                    <AtomNode start="(215, 3)" end="(215, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(215, 8)" end="(215, 25)">
                      <AtomNode start="(215, 8)" end="(215, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(215, 9)" end="(215, 24)">
                        <OtherNode start="(215, 9)" end="(215, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(215, 9)" end="(215, 24)" leading="" trailing="" raw_val="List.foldlM_map" val="List.foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(215, 24)" end="(215, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(217, 1)" end="(222, 56)" name="forIn_pure_yield_eq_foldl" full_name="Array.forIn_pure_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(217, 1)" end="(217, 8)">
        <NullNode/>
        <NullNode start="(217, 1)" end="(217, 8)">
          <OtherNode start="(217, 1)" end="(217, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(217, 1)" end="(217, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(217, 3)" end="(217, 7)">
              <OtherNode start="(217, 3)" end="(217, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(217, 3)" end="(217, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(217, 3)" end="(217, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(217, 7)" end="(217, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(217, 9)" end="(222, 56)" name="forIn_pure_yield_eq_foldl" full_name="Array.forIn_pure_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(217, 9)" end="(217, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(217, 17)" end="(217, 42)">
          <IdentNode start="(217, 17)" end="(217, 42)" leading="" trailing=" " raw_val="forIn_pure_yield_eq_foldl" val="forIn_pure_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(217, 43)" end="(220, 55)">
          <NullNode start="(217, 43)" end="(218, 46)">
            <OtherNode start="(217, 43)" end="(217, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(217, 43)" end="(217, 44)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(217, 44)" end="(217, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(217, 44)" end="(217, 49)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(217, 50)" end="(217, 51)">
                  <IdentNode start="(217, 50)" end="(217, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(217, 51)" end="(217, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(217, 53)" end="(217, 68)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(217, 53)" end="(217, 54)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(217, 54)" end="(217, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(217, 54)" end="(217, 65)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(217, 66)" end="(217, 67)">
                  <IdentNode start="(217, 66)" end="(217, 67)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(217, 67)" end="(217, 68)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(218, 5)" end="(218, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(218, 5)" end="(218, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(218, 6)" end="(218, 8)">
                <IdentNode start="(218, 6)" end="(218, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(218, 9)" end="(218, 18)">
                <AtomNode start="(218, 9)" end="(218, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(218, 11)" end="(218, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(218, 11)" end="(218, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(218, 17)" end="(218, 18)">
                    <IdentNode start="(218, 17)" end="(218, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(218, 18)" end="(218, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(218, 20)" end="(218, 35)">
              <AtomNode start="(218, 20)" end="(218, 21)" leading="" trailing="" val="("/>
              <NullNode start="(218, 21)" end="(218, 22)">
                <IdentNode start="(218, 21)" end="(218, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(218, 23)" end="(218, 34)">
                <AtomNode start="(218, 23)" end="(218, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(218, 25)" end="(218, 34)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(218, 25)" end="(218, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(218, 27)" end="(218, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(218, 29)" end="(218, 34)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(218, 29)" end="(218, 30)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(218, 31)" end="(218, 32)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(218, 33)" end="(218, 34)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(218, 34)" end="(218, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(218, 36)" end="(218, 46)">
              <AtomNode start="(218, 36)" end="(218, 37)" leading="" trailing="" val="("/>
              <NullNode start="(218, 37)" end="(218, 41)">
                <IdentNode start="(218, 37)" end="(218, 41)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(218, 42)" end="(218, 45)">
                <AtomNode start="(218, 42)" end="(218, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(218, 44)" end="(218, 45)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(218, 45)" end="(218, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(218, 47)" end="(220, 55)">
            <AtomNode start="(218, 47)" end="(218, 48)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(219, 5)" end="(220, 55)" kind="«term_=_»">
              <OtherNode start="(219, 5)" end="(219, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(219, 5)" end="(219, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(219, 11)" end="(219, 53)">
                  <IdentNode start="(219, 11)" end="(219, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(219, 14)" end="(219, 18)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(219, 19)" end="(219, 53)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(219, 19)" end="(219, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(219, 20)" end="(219, 52)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(219, 20)" end="(219, 23)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(219, 24)" end="(219, 52)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(219, 24)" end="(219, 27)">
                          <IdentNode start="(219, 24)" end="(219, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(219, 26)" end="(219, 27)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(219, 28)" end="(219, 30)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(219, 31)" end="(219, 52)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(219, 31)" end="(219, 35)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(219, 36)" end="(219, 52)">
                            <OtherNode start="(219, 36)" end="(219, 52)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(219, 36)" end="(219, 37)" leading="" trailing="" val="("/>
                              <OtherNode start="(219, 37)" end="(219, 51)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(219, 37)" end="(219, 43)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(219, 37)" end="(219, 38)" leading="" trailing="" val="."/>
                                  <IdentNode start="(219, 38)" end="(219, 43)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                </OtherNode>
                                <NullNode start="(219, 44)" end="(219, 51)">
                                  <OtherNode start="(219, 44)" end="(219, 51)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(219, 44)" end="(219, 45)" leading="" trailing="" val="("/>
                                    <OtherNode start="(219, 45)" end="(219, 50)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(219, 45)" end="(219, 46)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(219, 47)" end="(219, 50)">
                                        <IdentNode start="(219, 47)" end="(219, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <IdentNode start="(219, 49)" end="(219, 50)" leading="" trailing="" raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(219, 50)" end="(219, 51)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(219, 51)" end="(219, 52)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(219, 52)" end="(219, 53)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(219, 54)" end="(219, 55)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(220, 7)" end="(220, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(220, 7)" end="(220, 11)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(220, 12)" end="(220, 55)">
                  <OtherNode start="(220, 12)" end="(220, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(220, 12)" end="(220, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(220, 13)" end="(220, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                    <AtomNode start="(220, 15)" end="(220, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(220, 18)" end="(220, 19)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(220, 19)" end="(220, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(220, 21)" end="(220, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(220, 21)" end="(220, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(220, 22)" end="(220, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(220, 22)" end="(220, 30)" leading="" trailing=" " raw_val="xs.foldl" val="xs.foldl"/>
                      <NullNode start="(220, 31)" end="(220, 54)">
                        <OtherNode start="(220, 31)" end="(220, 49)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(220, 31)" end="(220, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(220, 32)" end="(220, 48)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(220, 32)" end="(220, 35)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(220, 36)" end="(220, 48)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(220, 36)" end="(220, 39)">
                                <IdentNode start="(220, 36)" end="(220, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                                <IdentNode start="(220, 38)" end="(220, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(220, 40)" end="(220, 42)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(220, 43)" end="(220, 48)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(220, 43)" end="(220, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(220, 45)" end="(220, 48)">
                                  <IdentNode start="(220, 45)" end="(220, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(220, 47)" end="(220, 48)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(220, 48)" end="(220, 49)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(220, 50)" end="(220, 54)" leading="" trailing="" raw_val="init" val="init"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(220, 54)" end="(220, 55)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(220, 56)" end="(222, 56)">
          <AtomNode start="(220, 56)" end="(220, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(220, 59)" end="(222, 56)">
            <AtomNode start="(220, 59)" end="(220, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(221, 3)" end="(222, 56)">
              <TacticTacticseq1IndentedNode start="(221, 3)" end="(222, 56)">
                <NullNode start="(221, 3)" end="(222, 56)">
                  <OtherNode start="(221, 3)" end="(221, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → β → β&#10;init : β&#10;⊢ (forIn xs init fun a b =&amp;gt; pure (ForInStep.yield (f a b))) = pure (foldl (fun b a =&amp;gt; f a b) init xs)" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → β&#10;init : β&#10;xs : List α&#10;⊢ (forIn { toList := xs } init fun a b =&amp;gt; pure (ForInStep.yield (f a b))) =&#10;    pure (foldl (fun b a =&amp;gt; f a b) init { toList := xs })" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(221, 3)" end="(221, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(221, 10)" end="(221, 12)">
                      <OtherNode start="(221, 10)" end="(221, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(221, 10)" end="(221, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(221, 13)" end="(221, 22)">
                      <AtomNode start="(221, 13)" end="(221, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(221, 18)" end="(221, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(221, 18)" end="(221, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(221, 18)" end="(221, 22)">
                            <OtherNode start="(221, 18)" end="(221, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(221, 18)" end="(221, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(221, 19)" end="(221, 21)">
                                <OtherNode start="(221, 19)" end="(221, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(221, 19)" end="(221, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(221, 19)" end="(221, 21)">
                                      <OtherNode start="(221, 19)" end="(221, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(221, 19)" end="(221, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(221, 21)" end="(221, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(222, 3)" end="(222, 56)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → β&#10;init : β&#10;xs : List α&#10;⊢ (forIn { toList := xs } init fun a b =&amp;gt; pure (ForInStep.yield (f a b))) =&#10;    pure (foldl (fun b a =&amp;gt; f a b) init { toList := xs })" state_after="no goals" tactic="simp [List.forIn_pure_yield_eq_foldl, List.foldl_map]">
                    <AtomNode start="(222, 3)" end="(222, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(222, 8)" end="(222, 56)">
                      <AtomNode start="(222, 8)" end="(222, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(222, 9)" end="(222, 55)">
                        <OtherNode start="(222, 9)" end="(222, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(222, 9)" end="(222, 39)" leading="" trailing="" raw_val="List.forIn_pure_yield_eq_foldl" val="List.forIn_pure_yield_eq_foldl" full_name="List.forIn_pure_yield_eq_foldl" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                        <AtomNode start="(222, 39)" end="(222, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(222, 41)" end="(222, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(222, 41)" end="(222, 55)" leading="" trailing="" raw_val="List.foldl_map" val="List.foldl_map" full_name="List.foldl_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(222, 55)" end="(222, 56)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(224, 1)" end="(229, 24)" name="forIn_yield_eq_foldl" full_name="Array.forIn_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(224, 1)" end="(224, 8)">
        <NullNode/>
        <NullNode start="(224, 1)" end="(224, 8)">
          <OtherNode start="(224, 1)" end="(224, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(224, 1)" end="(224, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(224, 3)" end="(224, 7)">
              <OtherNode start="(224, 3)" end="(224, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(224, 3)" end="(224, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(224, 3)" end="(224, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(224, 7)" end="(224, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(224, 9)" end="(229, 24)" name="forIn_yield_eq_foldl" full_name="Array.forIn_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(224, 9)" end="(224, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(224, 17)" end="(224, 37)">
          <IdentNode start="(224, 17)" end="(224, 37)" leading="" trailing="&#10;    " raw_val="forIn_yield_eq_foldl" val="forIn_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(225, 5)" end="(227, 39)">
          <NullNode start="(225, 5)" end="(225, 46)">
            <OtherNode start="(225, 5)" end="(225, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(225, 5)" end="(225, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(225, 6)" end="(225, 8)">
                <IdentNode start="(225, 6)" end="(225, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(225, 9)" end="(225, 18)">
                <AtomNode start="(225, 9)" end="(225, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(225, 11)" end="(225, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(225, 11)" end="(225, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(225, 17)" end="(225, 18)">
                    <IdentNode start="(225, 17)" end="(225, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(225, 18)" end="(225, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(225, 20)" end="(225, 35)">
              <AtomNode start="(225, 20)" end="(225, 21)" leading="" trailing="" val="("/>
              <NullNode start="(225, 21)" end="(225, 22)">
                <IdentNode start="(225, 21)" end="(225, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(225, 23)" end="(225, 34)">
                <AtomNode start="(225, 23)" end="(225, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(225, 25)" end="(225, 34)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(225, 25)" end="(225, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(225, 27)" end="(225, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(225, 29)" end="(225, 34)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(225, 29)" end="(225, 30)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(225, 31)" end="(225, 32)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(225, 33)" end="(225, 34)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(225, 34)" end="(225, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(225, 36)" end="(225, 46)">
              <AtomNode start="(225, 36)" end="(225, 37)" leading="" trailing="" val="("/>
              <NullNode start="(225, 37)" end="(225, 41)">
                <IdentNode start="(225, 37)" end="(225, 41)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(225, 42)" end="(225, 45)">
                <AtomNode start="(225, 42)" end="(225, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(225, 44)" end="(225, 45)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(225, 45)" end="(225, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(225, 47)" end="(227, 39)">
            <AtomNode start="(225, 47)" end="(225, 48)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(226, 5)" end="(227, 39)" kind="«term_=_»">
              <OtherNode start="(226, 5)" end="(226, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(226, 5)" end="(226, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(226, 11)" end="(226, 56)">
                  <OtherNode start="(226, 11)" end="(226, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(226, 11)" end="(226, 12)" leading="" trailing="" val="("/>
                    <IdentNode start="(226, 12)" end="(226, 13)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(226, 14)" end="(226, 16)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(226, 17)" end="(226, 19)" leading="" trailing="" raw_val="Id" val="Id" full_name="Id" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                    <AtomNode start="(226, 19)" end="(226, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(226, 21)" end="(226, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(226, 24)" end="(226, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(226, 29)" end="(226, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(226, 29)" end="(226, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(226, 30)" end="(226, 55)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(226, 30)" end="(226, 33)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(226, 34)" end="(226, 55)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(226, 34)" end="(226, 37)">
                          <IdentNode start="(226, 34)" end="(226, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(226, 36)" end="(226, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(226, 38)" end="(226, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(226, 41)" end="(226, 55)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(226, 41)" end="(226, 47)" kind="Lean.Parser.Term.dotIdent">
                            <AtomNode start="(226, 41)" end="(226, 42)" leading="" trailing="" val="."/>
                            <IdentNode start="(226, 42)" end="(226, 47)" leading="" trailing=" " raw_val="yield" val="yield"/>
                          </OtherNode>
                          <NullNode start="(226, 48)" end="(226, 55)">
                            <OtherNode start="(226, 48)" end="(226, 55)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(226, 48)" end="(226, 49)" leading="" trailing="" val="("/>
                              <OtherNode start="(226, 49)" end="(226, 54)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(226, 49)" end="(226, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(226, 51)" end="(226, 54)">
                                  <IdentNode start="(226, 51)" end="(226, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(226, 53)" end="(226, 54)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(226, 54)" end="(226, 55)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(226, 55)" end="(226, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(226, 57)" end="(226, 58)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(227, 7)" end="(227, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(227, 7)" end="(227, 15)" leading="" trailing=" " raw_val="xs.foldl" val="xs.foldl"/>
                <NullNode start="(227, 16)" end="(227, 39)">
                  <OtherNode start="(227, 16)" end="(227, 34)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(227, 16)" end="(227, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(227, 17)" end="(227, 33)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(227, 17)" end="(227, 20)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(227, 21)" end="(227, 33)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(227, 21)" end="(227, 24)">
                          <IdentNode start="(227, 21)" end="(227, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(227, 23)" end="(227, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(227, 25)" end="(227, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(227, 28)" end="(227, 33)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(227, 28)" end="(227, 29)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(227, 30)" end="(227, 33)">
                            <IdentNode start="(227, 30)" end="(227, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(227, 32)" end="(227, 33)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(227, 33)" end="(227, 34)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(227, 35)" end="(227, 39)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(227, 40)" end="(229, 24)">
          <AtomNode start="(227, 40)" end="(227, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(227, 43)" end="(229, 24)">
            <AtomNode start="(227, 43)" end="(227, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(228, 3)" end="(229, 24)">
              <TacticTacticseq1IndentedNode start="(228, 3)" end="(229, 24)">
                <NullNode start="(228, 3)" end="(229, 24)">
                  <OtherNode start="(228, 3)" end="(228, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : Array α&#10;f : α → β → β&#10;init : β&#10;⊢ (forIn xs init fun a b =&amp;gt; ForInStep.yield (f a b)) = foldl (fun b a =&amp;gt; f a b) init xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β → β&#10;init : β&#10;xs : List α&#10;⊢ (forIn { toList := xs } init fun a b =&amp;gt; ForInStep.yield (f a b)) = foldl (fun b a =&amp;gt; f a b) init { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(228, 3)" end="(228, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(228, 10)" end="(228, 12)">
                      <OtherNode start="(228, 10)" end="(228, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(228, 10)" end="(228, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(228, 13)" end="(228, 22)">
                      <AtomNode start="(228, 13)" end="(228, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(228, 18)" end="(228, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(228, 18)" end="(228, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(228, 18)" end="(228, 22)">
                            <OtherNode start="(228, 18)" end="(228, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(228, 18)" end="(228, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(228, 19)" end="(228, 21)">
                                <OtherNode start="(228, 19)" end="(228, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(228, 19)" end="(228, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(228, 19)" end="(228, 21)">
                                      <OtherNode start="(228, 19)" end="(228, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(228, 19)" end="(228, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(228, 21)" end="(228, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(229, 3)" end="(229, 24)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β → β&#10;init : β&#10;xs : List α&#10;⊢ (forIn { toList := xs } init fun a b =&amp;gt; ForInStep.yield (f a b)) = foldl (fun b a =&amp;gt; f a b) init { toList := xs }" state_after="no goals" tactic="simp [List.foldl_map]">
                    <AtomNode start="(229, 3)" end="(229, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(229, 8)" end="(229, 24)">
                      <AtomNode start="(229, 8)" end="(229, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(229, 9)" end="(229, 23)">
                        <OtherNode start="(229, 9)" end="(229, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(229, 9)" end="(229, 23)" leading="" trailing="" raw_val="List.foldl_map" val="List.foldl_map" full_name="List.foldl_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(229, 23)" end="(229, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(231, 1)" end="(235, 7)" name="forIn_map" full_name="Array.forIn_map">
      <CommandDeclmodifiersNode start="(231, 1)" end="(231, 8)">
        <NullNode/>
        <NullNode start="(231, 1)" end="(231, 8)">
          <OtherNode start="(231, 1)" end="(231, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(231, 1)" end="(231, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(231, 3)" end="(231, 7)">
              <OtherNode start="(231, 3)" end="(231, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(231, 3)" end="(231, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(231, 3)" end="(231, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(231, 7)" end="(231, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(231, 9)" end="(235, 7)" name="forIn_map" full_name="Array.forIn_map" _is_private_decl="False">
        <AtomNode start="(231, 9)" end="(231, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(231, 17)" end="(231, 26)">
          <IdentNode start="(231, 17)" end="(231, 26)" leading="" trailing=" " raw_val="forIn_map" val="forIn_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(231, 27)" end="(233, 65)">
          <NullNode start="(231, 27)" end="(232, 61)">
            <OtherNode start="(231, 27)" end="(231, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(231, 27)" end="(231, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(231, 28)" end="(231, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(231, 28)" end="(231, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(231, 34)" end="(231, 35)">
                  <IdentNode start="(231, 34)" end="(231, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(231, 35)" end="(231, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(231, 37)" end="(231, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(231, 37)" end="(231, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(231, 38)" end="(231, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(231, 38)" end="(231, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(231, 50)" end="(231, 51)">
                  <IdentNode start="(231, 50)" end="(231, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(231, 51)" end="(231, 52)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(232, 5)" end="(232, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 5)" end="(232, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 6)" end="(232, 8)">
                <IdentNode start="(232, 6)" end="(232, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(232, 9)" end="(232, 18)">
                <AtomNode start="(232, 9)" end="(232, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 11)" end="(232, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(232, 11)" end="(232, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(232, 17)" end="(232, 18)">
                    <IdentNode start="(232, 17)" end="(232, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 18)" end="(232, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(232, 20)" end="(232, 31)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 20)" end="(232, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 21)" end="(232, 22)">
                <IdentNode start="(232, 21)" end="(232, 22)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(232, 23)" end="(232, 30)">
                <AtomNode start="(232, 23)" end="(232, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 25)" end="(232, 30)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(232, 25)" end="(232, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(232, 27)" end="(232, 28)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(232, 29)" end="(232, 30)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 30)" end="(232, 31)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(232, 32)" end="(232, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 32)" end="(232, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 33)" end="(232, 34)">
                <IdentNode start="(232, 33)" end="(232, 34)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(232, 35)" end="(232, 60)">
                <AtomNode start="(232, 35)" end="(232, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 37)" end="(232, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(232, 37)" end="(232, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(232, 39)" end="(232, 40)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(232, 41)" end="(232, 60)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(232, 41)" end="(232, 42)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    <AtomNode start="(232, 43)" end="(232, 44)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(232, 45)" end="(232, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(232, 45)" end="(232, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(232, 47)" end="(232, 60)">
                        <OtherNode start="(232, 47)" end="(232, 60)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(232, 47)" end="(232, 48)" leading="" trailing="" val="("/>
                          <OtherNode start="(232, 48)" end="(232, 59)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(232, 48)" end="(232, 57)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(232, 58)" end="(232, 59)">
                              <IdentNode start="(232, 58)" end="(232, 59)" leading="" trailing="" raw_val="γ" val="γ"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(232, 59)" end="(232, 60)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 60)" end="(232, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(232, 62)" end="(233, 65)">
            <AtomNode start="(232, 62)" end="(232, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(233, 5)" end="(233, 65)" kind="«term_=_»">
              <OtherNode start="(233, 5)" end="(233, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(233, 5)" end="(233, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(233, 11)" end="(233, 28)">
                  <OtherNode start="(233, 11)" end="(233, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(233, 11)" end="(233, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(233, 12)" end="(233, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(233, 12)" end="(233, 18)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(233, 19)" end="(233, 20)">
                        <IdentNode start="(233, 19)" end="(233, 20)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(233, 20)" end="(233, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(233, 22)" end="(233, 26)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(233, 27)" end="(233, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(233, 29)" end="(233, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(233, 31)" end="(233, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(233, 31)" end="(233, 36)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(233, 37)" end="(233, 65)">
                  <IdentNode start="(233, 37)" end="(233, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(233, 40)" end="(233, 44)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(233, 45)" end="(233, 65)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(233, 45)" end="(233, 48)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(233, 49)" end="(233, 65)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(233, 49)" end="(233, 52)">
                        <IdentNode start="(233, 49)" end="(233, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(233, 51)" end="(233, 52)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(233, 53)" end="(233, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(233, 56)" end="(233, 65)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(233, 56)" end="(233, 57)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(233, 58)" end="(233, 65)">
                          <OtherNode start="(233, 58)" end="(233, 63)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(233, 58)" end="(233, 59)" leading="" trailing="" val="("/>
                            <OtherNode start="(233, 59)" end="(233, 62)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(233, 59)" end="(233, 60)" leading="" trailing=" " raw_val="g" val="g"/>
                              <NullNode start="(233, 61)" end="(233, 62)">
                                <IdentNode start="(233, 61)" end="(233, 62)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(233, 62)" end="(233, 63)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <IdentNode start="(233, 64)" end="(233, 65)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(233, 66)" end="(235, 7)">
          <AtomNode start="(233, 66)" end="(233, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(233, 69)" end="(235, 7)">
            <AtomNode start="(233, 69)" end="(233, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(234, 3)" end="(235, 7)">
              <TacticTacticseq1IndentedNode start="(234, 3)" end="(235, 7)">
                <NullNode start="(234, 3)" end="(235, 7)">
                  <OtherNode start="(234, 3)" end="(234, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;g : α → β&#10;f : β → γ → m (ForInStep γ)&#10;⊢ forIn (map g xs) init f = forIn xs init fun a y =&amp;gt; f (g a) y" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;g : α → β&#10;f : β → γ → m (ForInStep γ)&#10;xs : List α&#10;⊢ forIn (map g { toList := xs }) init f = forIn { toList := xs } init fun a y =&amp;gt; f (g a) y" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(234, 3)" end="(234, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(234, 10)" end="(234, 12)">
                      <OtherNode start="(234, 10)" end="(234, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(234, 10)" end="(234, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(234, 13)" end="(234, 22)">
                      <AtomNode start="(234, 13)" end="(234, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(234, 18)" end="(234, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(234, 18)" end="(234, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(234, 18)" end="(234, 22)">
                            <OtherNode start="(234, 18)" end="(234, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(234, 18)" end="(234, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(234, 19)" end="(234, 21)">
                                <OtherNode start="(234, 19)" end="(234, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(234, 19)" end="(234, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(234, 19)" end="(234, 21)">
                                      <OtherNode start="(234, 19)" end="(234, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(234, 19)" end="(234, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(234, 21)" end="(234, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(235, 3)" end="(235, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;g : α → β&#10;f : β → γ → m (ForInStep γ)&#10;xs : List α&#10;⊢ forIn (map g { toList := xs }) init f = forIn { toList := xs } init fun a y =&amp;gt; f (g a) y" state_after="no goals" tactic="simp">
                    <AtomNode start="(235, 3)" end="(235, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(237, 1)" end="(237, 25)" comment="### allM and anyM -/">
      <AtomNode start="(237, 1)" end="(237, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(237, 5)" end="(237, 25)" leading="" trailing="&#10;&#10;" val="### allM and anyM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(239, 1)" end="(242, 7)" name="anyM_pure" full_name="Array.anyM_pure">
      <CommandDeclmodifiersNode start="(239, 1)" end="(239, 8)">
        <NullNode/>
        <NullNode start="(239, 1)" end="(239, 8)">
          <OtherNode start="(239, 1)" end="(239, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(239, 1)" end="(239, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(239, 3)" end="(239, 7)">
              <OtherNode start="(239, 3)" end="(239, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(239, 3)" end="(239, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(239, 3)" end="(239, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(239, 7)" end="(239, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(239, 9)" end="(242, 7)" name="anyM_pure" full_name="Array.anyM_pure" _is_private_decl="False">
        <AtomNode start="(239, 9)" end="(239, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(239, 17)" end="(239, 26)">
          <IdentNode start="(239, 17)" end="(239, 26)" leading="" trailing=" " raw_val="anyM_pure" val="anyM_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(239, 27)" end="(240, 53)">
          <NullNode start="(239, 27)" end="(239, 82)">
            <OtherNode start="(239, 27)" end="(239, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(239, 27)" end="(239, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(239, 28)" end="(239, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(239, 28)" end="(239, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(239, 34)" end="(239, 35)">
                  <IdentNode start="(239, 34)" end="(239, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(239, 35)" end="(239, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(239, 37)" end="(239, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(239, 37)" end="(239, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(239, 38)" end="(239, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(239, 38)" end="(239, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(239, 50)" end="(239, 51)">
                  <IdentNode start="(239, 50)" end="(239, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(239, 51)" end="(239, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(239, 53)" end="(239, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(239, 53)" end="(239, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(239, 54)" end="(239, 55)">
                <IdentNode start="(239, 54)" end="(239, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(239, 56)" end="(239, 66)">
                <AtomNode start="(239, 56)" end="(239, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(239, 58)" end="(239, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(239, 58)" end="(239, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(239, 60)" end="(239, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(239, 62)" end="(239, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(239, 66)" end="(239, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(239, 68)" end="(239, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(239, 68)" end="(239, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(239, 69)" end="(239, 71)">
                <IdentNode start="(239, 69)" end="(239, 71)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(239, 72)" end="(239, 81)">
                <AtomNode start="(239, 72)" end="(239, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(239, 74)" end="(239, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(239, 74)" end="(239, 79)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(239, 80)" end="(239, 81)">
                    <IdentNode start="(239, 80)" end="(239, 81)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(239, 81)" end="(239, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(239, 83)" end="(240, 53)">
            <AtomNode start="(239, 83)" end="(239, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(240, 5)" end="(240, 53)" kind="«term_=_»">
              <OtherNode start="(240, 5)" end="(240, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(240, 5)" end="(240, 12)" leading="" trailing=" " raw_val="xs.anyM" val="xs.anyM"/>
                <NullNode start="(240, 13)" end="(240, 35)">
                  <OtherNode start="(240, 13)" end="(240, 21)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(240, 13)" end="(240, 14)" leading="" trailing="" val="("/>
                    <IdentNode start="(240, 14)" end="(240, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(240, 16)" end="(240, 18)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(240, 19)" end="(240, 20)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(240, 20)" end="(240, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(240, 22)" end="(240, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(240, 22)" end="(240, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(240, 23)" end="(240, 34)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(240, 23)" end="(240, 27)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(240, 28)" end="(240, 30)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(240, 31)" end="(240, 34)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(240, 31)" end="(240, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(240, 33)" end="(240, 34)">
                          <OtherNode start="(240, 33)" end="(240, 34)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(240, 33)" end="(240, 34)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(240, 34)" end="(240, 35)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(240, 36)" end="(240, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(240, 38)" end="(240, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(240, 38)" end="(240, 42)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(240, 43)" end="(240, 53)">
                  <OtherNode start="(240, 43)" end="(240, 53)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(240, 43)" end="(240, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(240, 44)" end="(240, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(240, 44)" end="(240, 50)" leading="" trailing=" " raw_val="xs.any" val="xs.any"/>
                      <NullNode start="(240, 51)" end="(240, 52)">
                        <IdentNode start="(240, 51)" end="(240, 52)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(240, 52)" end="(240, 53)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(240, 54)" end="(242, 7)">
          <AtomNode start="(240, 54)" end="(240, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(240, 57)" end="(242, 7)">
            <AtomNode start="(240, 57)" end="(240, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(241, 3)" end="(242, 7)">
              <TacticTacticseq1IndentedNode start="(241, 3)" end="(242, 7)">
                <NullNode start="(241, 3)" end="(242, 7)">
                  <OtherNode start="(241, 3)" end="(241, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;xs : Array α&#10;⊢ anyM (fun x =&amp;gt; pure (p x)) xs = pure (xs.any p)" state_after="case mk&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ anyM (fun x =&amp;gt; pure (p x)) { toList := toList✝ } = pure ({ toList := toList✝ }.any p)" tactic="cases xs">
                    <AtomNode start="(241, 3)" end="(241, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(241, 9)" end="(241, 11)">
                      <OtherNode start="(241, 9)" end="(241, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(241, 9)" end="(241, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(242, 3)" end="(242, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ anyM (fun x =&amp;gt; pure (p x)) { toList := toList✝ } = pure ({ toList := toList✝ }.any p)" state_after="no goals" tactic="simp">
                    <AtomNode start="(242, 3)" end="(242, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(244, 1)" end="(247, 7)" name="allM_pure" full_name="Array.allM_pure">
      <CommandDeclmodifiersNode start="(244, 1)" end="(244, 8)">
        <NullNode/>
        <NullNode start="(244, 1)" end="(244, 8)">
          <OtherNode start="(244, 1)" end="(244, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(244, 1)" end="(244, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(244, 3)" end="(244, 7)">
              <OtherNode start="(244, 3)" end="(244, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(244, 3)" end="(244, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(244, 3)" end="(244, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(244, 7)" end="(244, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(244, 9)" end="(247, 7)" name="allM_pure" full_name="Array.allM_pure" _is_private_decl="False">
        <AtomNode start="(244, 9)" end="(244, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(244, 17)" end="(244, 26)">
          <IdentNode start="(244, 17)" end="(244, 26)" leading="" trailing=" " raw_val="allM_pure" val="allM_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(244, 27)" end="(245, 53)">
          <NullNode start="(244, 27)" end="(244, 82)">
            <OtherNode start="(244, 27)" end="(244, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(244, 27)" end="(244, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(244, 28)" end="(244, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(244, 28)" end="(244, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(244, 34)" end="(244, 35)">
                  <IdentNode start="(244, 34)" end="(244, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(244, 35)" end="(244, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(244, 37)" end="(244, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(244, 37)" end="(244, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(244, 38)" end="(244, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(244, 38)" end="(244, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(244, 50)" end="(244, 51)">
                  <IdentNode start="(244, 50)" end="(244, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(244, 51)" end="(244, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(244, 53)" end="(244, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(244, 53)" end="(244, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(244, 54)" end="(244, 55)">
                <IdentNode start="(244, 54)" end="(244, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(244, 56)" end="(244, 66)">
                <AtomNode start="(244, 56)" end="(244, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(244, 58)" end="(244, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(244, 58)" end="(244, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(244, 60)" end="(244, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(244, 62)" end="(244, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(244, 66)" end="(244, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(244, 68)" end="(244, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(244, 68)" end="(244, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(244, 69)" end="(244, 71)">
                <IdentNode start="(244, 69)" end="(244, 71)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(244, 72)" end="(244, 81)">
                <AtomNode start="(244, 72)" end="(244, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(244, 74)" end="(244, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(244, 74)" end="(244, 79)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(244, 80)" end="(244, 81)">
                    <IdentNode start="(244, 80)" end="(244, 81)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(244, 81)" end="(244, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(244, 83)" end="(245, 53)">
            <AtomNode start="(244, 83)" end="(244, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(245, 5)" end="(245, 53)" kind="«term_=_»">
              <OtherNode start="(245, 5)" end="(245, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(245, 5)" end="(245, 12)" leading="" trailing=" " raw_val="xs.allM" val="xs.allM"/>
                <NullNode start="(245, 13)" end="(245, 35)">
                  <OtherNode start="(245, 13)" end="(245, 21)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(245, 13)" end="(245, 14)" leading="" trailing="" val="("/>
                    <IdentNode start="(245, 14)" end="(245, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(245, 16)" end="(245, 18)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(245, 19)" end="(245, 20)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(245, 20)" end="(245, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(245, 22)" end="(245, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(245, 22)" end="(245, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(245, 23)" end="(245, 34)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(245, 23)" end="(245, 27)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(245, 28)" end="(245, 30)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(245, 31)" end="(245, 34)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(245, 31)" end="(245, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(245, 33)" end="(245, 34)">
                          <OtherNode start="(245, 33)" end="(245, 34)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(245, 33)" end="(245, 34)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(245, 34)" end="(245, 35)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(245, 36)" end="(245, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(245, 38)" end="(245, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(245, 38)" end="(245, 42)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(245, 43)" end="(245, 53)">
                  <OtherNode start="(245, 43)" end="(245, 53)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(245, 43)" end="(245, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(245, 44)" end="(245, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(245, 44)" end="(245, 50)" leading="" trailing=" " raw_val="xs.all" val="xs.all"/>
                      <NullNode start="(245, 51)" end="(245, 52)">
                        <IdentNode start="(245, 51)" end="(245, 52)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(245, 52)" end="(245, 53)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(245, 54)" end="(247, 7)">
          <AtomNode start="(245, 54)" end="(245, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(245, 57)" end="(247, 7)">
            <AtomNode start="(245, 57)" end="(245, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(246, 3)" end="(247, 7)">
              <TacticTacticseq1IndentedNode start="(246, 3)" end="(247, 7)">
                <NullNode start="(246, 3)" end="(247, 7)">
                  <OtherNode start="(246, 3)" end="(246, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;xs : Array α&#10;⊢ allM (fun x =&amp;gt; pure (p x)) xs = pure (xs.all p)" state_after="case mk&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ allM (fun x =&amp;gt; pure (p x)) { toList := toList✝ } = pure ({ toList := toList✝ }.all p)" tactic="cases xs">
                    <AtomNode start="(246, 3)" end="(246, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(246, 9)" end="(246, 11)">
                      <OtherNode start="(246, 9)" end="(246, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(246, 9)" end="(246, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(247, 3)" end="(247, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ allM (fun x =&amp;gt; pure (p x)) { toList := toList✝ } = pure ({ toList := toList✝ }.all p)" state_after="no goals" tactic="simp">
                    <AtomNode start="(247, 3)" end="(247, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(249, 1)" end="(249, 33)" comment="### findM? and findSomeM? -/">
      <AtomNode start="(249, 1)" end="(249, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(249, 5)" end="(249, 33)" leading="" trailing="&#10;&#10;" val="### findM? and findSomeM? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(251, 1)" end="(255, 7)" name="findM?_pure" full_name="Array.findM?_pure">
      <CommandDeclmodifiersNode start="(251, 1)" end="(251, 8)">
        <NullNode/>
        <NullNode start="(251, 1)" end="(251, 8)">
          <OtherNode start="(251, 1)" end="(251, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(251, 1)" end="(251, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(251, 3)" end="(251, 7)">
              <OtherNode start="(251, 3)" end="(251, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(251, 3)" end="(251, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(251, 3)" end="(251, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(251, 7)" end="(251, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(252, 1)" end="(255, 7)" name="findM?_pure" full_name="Array.findM?_pure" _is_private_decl="False">
        <AtomNode start="(252, 1)" end="(252, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(252, 9)" end="(252, 20)">
          <IdentNode start="(252, 9)" end="(252, 20)" leading="" trailing=" " raw_val="findM?_pure" val="findM?_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(252, 21)" end="(253, 57)">
          <NullNode start="(252, 21)" end="(252, 80)">
            <OtherNode start="(252, 21)" end="(252, 24)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(252, 21)" end="(252, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(252, 22)" end="(252, 23)">
                <IdentNode start="(252, 22)" end="(252, 23)" leading="" trailing="" raw_val="m" val="m"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(252, 23)" end="(252, 24)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(252, 25)" end="(252, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(252, 25)" end="(252, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(252, 26)" end="(252, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(252, 26)" end="(252, 31)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(252, 32)" end="(252, 33)">
                  <IdentNode start="(252, 32)" end="(252, 33)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(252, 33)" end="(252, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(252, 35)" end="(252, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(252, 35)" end="(252, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(252, 36)" end="(252, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(252, 36)" end="(252, 47)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(252, 48)" end="(252, 49)">
                  <IdentNode start="(252, 48)" end="(252, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(252, 49)" end="(252, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(252, 51)" end="(252, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(252, 51)" end="(252, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(252, 52)" end="(252, 53)">
                <IdentNode start="(252, 52)" end="(252, 53)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(252, 54)" end="(252, 64)">
                <AtomNode start="(252, 54)" end="(252, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(252, 56)" end="(252, 64)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(252, 56)" end="(252, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(252, 58)" end="(252, 59)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(252, 60)" end="(252, 64)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(252, 64)" end="(252, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(252, 66)" end="(252, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(252, 66)" end="(252, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(252, 67)" end="(252, 69)">
                <IdentNode start="(252, 67)" end="(252, 69)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(252, 70)" end="(252, 79)">
                <AtomNode start="(252, 70)" end="(252, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(252, 72)" end="(252, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(252, 72)" end="(252, 77)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(252, 78)" end="(252, 79)">
                    <IdentNode start="(252, 78)" end="(252, 79)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(252, 79)" end="(252, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(252, 81)" end="(253, 57)">
            <AtomNode start="(252, 81)" end="(252, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(253, 5)" end="(253, 57)" kind="«term_=_»">
              <OtherNode start="(253, 5)" end="(253, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(253, 5)" end="(253, 11)" leading="" trailing=" " raw_val="findM?" val="findM?" full_name="Array.findM?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(253, 12)" end="(253, 37)">
                  <OtherNode start="(253, 12)" end="(253, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(253, 12)" end="(253, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(253, 13)" end="(253, 14)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(253, 15)" end="(253, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(253, 18)" end="(253, 19)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(253, 19)" end="(253, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(253, 21)" end="(253, 34)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(253, 21)" end="(253, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(253, 22)" end="(253, 33)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(253, 22)" end="(253, 26)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(253, 27)" end="(253, 29)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(253, 30)" end="(253, 33)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(253, 30)" end="(253, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(253, 32)" end="(253, 33)">
                          <OtherNode start="(253, 32)" end="(253, 33)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(253, 32)" end="(253, 33)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(253, 33)" end="(253, 34)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(253, 35)" end="(253, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(253, 38)" end="(253, 39)" leading="" trailing=" " val="="/>
              <OtherNode start="(253, 40)" end="(253, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(253, 40)" end="(253, 44)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(253, 45)" end="(253, 57)">
                  <OtherNode start="(253, 45)" end="(253, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(253, 45)" end="(253, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(253, 46)" end="(253, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(253, 46)" end="(253, 54)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(253, 55)" end="(253, 56)">
                        <IdentNode start="(253, 55)" end="(253, 56)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(253, 56)" end="(253, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(253, 58)" end="(255, 7)">
          <AtomNode start="(253, 58)" end="(253, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(253, 61)" end="(255, 7)">
            <AtomNode start="(253, 61)" end="(253, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(254, 3)" end="(255, 7)">
              <TacticTacticseq1IndentedNode start="(254, 3)" end="(255, 7)">
                <NullNode start="(254, 3)" end="(255, 7)">
                  <OtherNode start="(254, 3)" end="(254, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;m : Type → Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findM? (fun x =&amp;gt; pure (p x)) xs = pure (find? p xs)" state_after="case mk&#10;α : Type&#10;m : Type → Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findM? (fun x =&amp;gt; pure (p x)) { toList := toList✝ } = pure (find? p { toList := toList✝ })" tactic="cases xs">
                    <AtomNode start="(254, 3)" end="(254, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(254, 9)" end="(254, 11)">
                      <OtherNode start="(254, 9)" end="(254, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(254, 9)" end="(254, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(255, 3)" end="(255, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;m : Type → Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findM? (fun x =&amp;gt; pure (p x)) { toList := toList✝ } = pure (find? p { toList := toList✝ })" state_after="no goals" tactic="simp">
                    <AtomNode start="(255, 3)" end="(255, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(257, 1)" end="(261, 7)" name="findSomeM?_pure" full_name="Array.findSomeM?_pure">
      <CommandDeclmodifiersNode start="(257, 1)" end="(257, 8)">
        <NullNode/>
        <NullNode start="(257, 1)" end="(257, 8)">
          <OtherNode start="(257, 1)" end="(257, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(257, 1)" end="(257, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(257, 3)" end="(257, 7)">
              <OtherNode start="(257, 3)" end="(257, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(257, 3)" end="(257, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(257, 3)" end="(257, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(257, 7)" end="(257, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(258, 1)" end="(261, 7)" name="findSomeM?_pure" full_name="Array.findSomeM?_pure" _is_private_decl="False">
        <AtomNode start="(258, 1)" end="(258, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(258, 9)" end="(258, 24)">
          <IdentNode start="(258, 9)" end="(258, 24)" leading="" trailing=" " raw_val="findSomeM?_pure" val="findSomeM?_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(258, 25)" end="(259, 65)">
          <NullNode start="(258, 25)" end="(258, 84)">
            <OtherNode start="(258, 25)" end="(258, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(258, 25)" end="(258, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(258, 26)" end="(258, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(258, 26)" end="(258, 31)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(258, 32)" end="(258, 33)">
                  <IdentNode start="(258, 32)" end="(258, 33)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(258, 33)" end="(258, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(258, 35)" end="(258, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(258, 35)" end="(258, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(258, 36)" end="(258, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(258, 36)" end="(258, 47)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(258, 48)" end="(258, 49)">
                  <IdentNode start="(258, 48)" end="(258, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(258, 49)" end="(258, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(258, 51)" end="(258, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(258, 51)" end="(258, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(258, 52)" end="(258, 53)">
                <IdentNode start="(258, 52)" end="(258, 53)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(258, 54)" end="(258, 68)">
                <AtomNode start="(258, 54)" end="(258, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(258, 56)" end="(258, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(258, 56)" end="(258, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(258, 58)" end="(258, 59)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(258, 60)" end="(258, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(258, 60)" end="(258, 66)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(258, 67)" end="(258, 68)">
                      <IdentNode start="(258, 67)" end="(258, 68)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(258, 68)" end="(258, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(258, 70)" end="(258, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(258, 70)" end="(258, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(258, 71)" end="(258, 73)">
                <IdentNode start="(258, 71)" end="(258, 73)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(258, 74)" end="(258, 83)">
                <AtomNode start="(258, 74)" end="(258, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(258, 76)" end="(258, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(258, 76)" end="(258, 81)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(258, 82)" end="(258, 83)">
                    <IdentNode start="(258, 82)" end="(258, 83)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(258, 83)" end="(258, 84)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(258, 85)" end="(259, 65)">
            <AtomNode start="(258, 85)" end="(258, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(259, 5)" end="(259, 65)" kind="«term_=_»">
              <OtherNode start="(259, 5)" end="(259, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(259, 5)" end="(259, 15)" leading="" trailing=" " raw_val="findSomeM?" val="findSomeM?" full_name="Array.findSomeM?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(259, 16)" end="(259, 41)">
                  <OtherNode start="(259, 16)" end="(259, 24)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(259, 16)" end="(259, 17)" leading="" trailing="" val="("/>
                    <IdentNode start="(259, 17)" end="(259, 18)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(259, 19)" end="(259, 21)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(259, 22)" end="(259, 23)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(259, 23)" end="(259, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(259, 25)" end="(259, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(259, 25)" end="(259, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(259, 26)" end="(259, 37)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(259, 26)" end="(259, 30)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(259, 31)" end="(259, 33)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(259, 34)" end="(259, 37)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(259, 34)" end="(259, 35)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(259, 36)" end="(259, 37)">
                          <OtherNode start="(259, 36)" end="(259, 37)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(259, 36)" end="(259, 37)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(259, 37)" end="(259, 38)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(259, 39)" end="(259, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(259, 42)" end="(259, 43)" leading="" trailing=" " val="="/>
              <OtherNode start="(259, 44)" end="(259, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(259, 44)" end="(259, 48)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(259, 49)" end="(259, 65)">
                  <OtherNode start="(259, 49)" end="(259, 65)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(259, 49)" end="(259, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(259, 50)" end="(259, 64)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(259, 50)" end="(259, 62)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(259, 63)" end="(259, 64)">
                        <IdentNode start="(259, 63)" end="(259, 64)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(259, 64)" end="(259, 65)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(259, 66)" end="(261, 7)">
          <AtomNode start="(259, 66)" end="(259, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(259, 69)" end="(261, 7)">
            <AtomNode start="(259, 69)" end="(259, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(260, 3)" end="(261, 7)">
              <TacticTacticseq1IndentedNode start="(260, 3)" end="(261, 7)">
                <NullNode start="(260, 3)" end="(261, 7)">
                  <OtherNode start="(260, 3)" end="(260, 11)" kind="Lean.Parser.Tactic.cases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;xs : Array α&#10;⊢ findSomeM? (fun x =&amp;gt; pure (f x)) xs = pure (findSome? f xs)" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ findSomeM? (fun x =&amp;gt; pure (f x)) { toList := toList✝ } = pure (findSome? f { toList := toList✝ })" tactic="cases xs">
                    <AtomNode start="(260, 3)" end="(260, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(260, 9)" end="(260, 11)">
                      <OtherNode start="(260, 9)" end="(260, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(260, 9)" end="(260, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(261, 3)" end="(261, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ findSomeM? (fun x =&amp;gt; pure (f x)) { toList := toList✝ } = pure (findSome? f { toList := toList✝ })" state_after="no goals" tactic="simp">
                    <AtomNode start="(261, 3)" end="(261, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(263, 1)" end="(263, 10)" name="Array">
      <AtomNode start="(263, 1)" end="(263, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(263, 5)" end="(263, 10)">
        <IdentNode start="(263, 5)" end="(263, 10)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
    <CommandNamespaceNode start="(265, 1)" end="(265, 15)" name="List">
      <AtomNode start="(265, 1)" end="(265, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(265, 11)" end="(265, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(267, 1)" end="(279, 26)" name="filterM_toArray" full_name="List.filterM_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(267, 1)" end="(279, 26)" name="filterM_toArray" full_name="List.filterM_toArray" _is_private_decl="False">
        <AtomNode start="(267, 1)" end="(267, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(267, 9)" end="(267, 24)">
          <IdentNode start="(267, 9)" end="(267, 24)" leading="" trailing=" " raw_val="filterM_toArray" val="filterM_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(267, 25)" end="(268, 50)">
          <NullNode start="(267, 25)" end="(267, 80)">
            <OtherNode start="(267, 25)" end="(267, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(267, 25)" end="(267, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(267, 26)" end="(267, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(267, 26)" end="(267, 31)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(267, 32)" end="(267, 33)">
                  <IdentNode start="(267, 32)" end="(267, 33)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(267, 33)" end="(267, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(267, 35)" end="(267, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(267, 35)" end="(267, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(267, 36)" end="(267, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(267, 36)" end="(267, 47)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(267, 48)" end="(267, 49)">
                  <IdentNode start="(267, 48)" end="(267, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(267, 49)" end="(267, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(267, 51)" end="(267, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(267, 51)" end="(267, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(267, 52)" end="(267, 53)">
                <IdentNode start="(267, 52)" end="(267, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(267, 54)" end="(267, 62)">
                <AtomNode start="(267, 54)" end="(267, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(267, 56)" end="(267, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(267, 56)" end="(267, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(267, 61)" end="(267, 62)">
                    <IdentNode start="(267, 61)" end="(267, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(267, 62)" end="(267, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(267, 64)" end="(267, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(267, 64)" end="(267, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(267, 65)" end="(267, 66)">
                <IdentNode start="(267, 65)" end="(267, 66)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(267, 67)" end="(267, 79)">
                <AtomNode start="(267, 67)" end="(267, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(267, 69)" end="(267, 79)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(267, 69)" end="(267, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(267, 71)" end="(267, 72)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(267, 73)" end="(267, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(267, 73)" end="(267, 74)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(267, 75)" end="(267, 79)">
                      <IdentNode start="(267, 75)" end="(267, 79)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(267, 79)" end="(267, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(267, 81)" end="(268, 50)">
            <AtomNode start="(267, 81)" end="(267, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(268, 5)" end="(268, 50)" kind="«term_=_»">
              <OtherNode start="(268, 5)" end="(268, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(268, 5)" end="(268, 22)" leading="" trailing=" " raw_val="l.toArray.filterM" val="l.toArray.filterM"/>
                <NullNode start="(268, 23)" end="(268, 24)">
                  <IdentNode start="(268, 23)" end="(268, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(268, 25)" end="(268, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(268, 27)" end="(268, 50)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(268, 27)" end="(268, 34)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(268, 35)" end="(268, 38)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(268, 39)" end="(268, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(268, 39)" end="(268, 48)" leading="" trailing=" " raw_val="l.filterM" val="l.filterM"/>
                  <NullNode start="(268, 49)" end="(268, 50)">
                    <IdentNode start="(268, 49)" end="(268, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(268, 51)" end="(279, 26)">
          <AtomNode start="(268, 51)" end="(268, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(268, 54)" end="(279, 26)">
            <AtomNode start="(268, 54)" end="(268, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(269, 3)" end="(279, 26)">
              <TacticTacticseq1IndentedNode start="(269, 3)" end="(279, 26)">
                <NullNode start="(269, 3)" end="(279, 26)">
                  <OtherNode start="(269, 3)" end="(269, 86)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.filterM p l.toArray = toArray &amp;lt;$&amp;gt; filterM p l" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      #[] l =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p l []" tactic="simp only [Array.filterM, filterM, foldlM_toArray, bind_pure_comp, Functor.map_map]">
                    <AtomNode start="(269, 3)" end="(269, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(269, 8)" end="(269, 12)">
                      <AtomNode start="(269, 8)" end="(269, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(269, 13)" end="(269, 86)">
                      <AtomNode start="(269, 13)" end="(269, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(269, 14)" end="(269, 85)">
                        <OtherNode start="(269, 14)" end="(269, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(269, 14)" end="(269, 27)" leading="" trailing="" raw_val="Array.filterM" val="Array.filterM" full_name="Array.filterM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(269, 27)" end="(269, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(269, 29)" end="(269, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(269, 29)" end="(269, 36)" leading="" trailing="" raw_val="filterM" val="filterM" full_name="List.filterM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                        <AtomNode start="(269, 36)" end="(269, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(269, 38)" end="(269, 52)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(269, 38)" end="(269, 52)" leading="" trailing="" raw_val="foldlM_toArray" val="foldlM_toArray" full_name="List.foldlM_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(269, 52)" end="(269, 53)" leading="" trailing=" " val=","/>
                        <OtherNode start="(269, 54)" end="(269, 68)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(269, 54)" end="(269, 68)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(269, 68)" end="(269, 69)" leading="" trailing=" " val=","/>
                        <OtherNode start="(269, 70)" end="(269, 85)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(269, 70)" end="(269, 85)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(269, 85)" end="(269, 86)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(270, 3)" end="(270, 34)" kind="Lean.Parser.Tactic.Conv.conv" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      #[] l =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p l []" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      [].reverse.toArray l =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p l []" tactic="conv =&amp;gt; lhs; rw [← reverse_nil]">
                    <AtomNode start="(270, 3)" end="(270, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(270, 8)" end="(270, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(270, 11)" end="(270, 34)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(270, 11)" end="(270, 34)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(270, 11)" end="(270, 34)">
                          <OtherNode start="(270, 11)" end="(270, 14)" kind="Lean.Parser.Tactic.Conv.lhs">
                            <AtomNode start="(270, 11)" end="(270, 14)" leading="" trailing="" val="lhs"/>
                          </OtherNode>
                          <AtomNode start="(270, 14)" end="(270, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(270, 16)" end="(270, 34)" kind="Lean.Parser.Tactic.Conv.convRw__">
                            <AtomNode start="(270, 16)" end="(270, 18)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(270, 19)" end="(270, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(270, 19)" end="(270, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(270, 20)" end="(270, 33)">
                                <OtherNode start="(270, 20)" end="(270, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode start="(270, 20)" end="(270, 21)">
                                    <OtherNode start="(270, 20)" end="(270, 21)" kind="patternIgnore">
                                      <OtherNode start="(270, 20)" end="(270, 21)" kind="token.«← »">
                                        <AtomNode start="(270, 20)" end="(270, 21)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <IdentNode start="(270, 22)" end="(270, 33)" leading="" trailing="" raw_val="reverse_nil" val="reverse_nil" full_name="List.reverse_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(270, 33)" end="(270, 34)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(271, 3)" end="(271, 22)" kind="Lean.Parser.Tactic.generalize" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      [].reverse.toArray l =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p l []" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;acc : List α&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      acc.reverse.toArray l =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p l acc" tactic="generalize [] = acc">
                    <AtomNode start="(271, 3)" end="(271, 13)" leading="" trailing=" " val="generalize"/>
                    <NullNode start="(271, 14)" end="(271, 22)">
                      <OtherNode start="(271, 14)" end="(271, 22)" kind="Lean.Parser.Tactic.generalizeArg">
                        <NullNode/>
                        <OtherNode start="(271, 14)" end="(271, 16)" kind="«term[_]»">
                          <AtomNode start="(271, 14)" end="(271, 15)" leading="" trailing="" val="["/>
                          <NullNode/>
                          <AtomNode start="(271, 15)" end="(271, 16)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <AtomNode start="(271, 17)" end="(271, 18)" leading="" trailing=" " val="="/>
                        <IdentNode start="(271, 19)" end="(271, 22)" leading="" trailing="&#10;  " raw_val="acc" val="acc"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(272, 3)" end="(279, 26)" kind="Lean.Parser.Tactic.induction" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;acc : List α&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      acc.reverse.toArray l =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p l acc" state_after="no goals" tactic="induction l generalizing acc with simp&#10;| cons x xs ih =&amp;gt;&#10;  congr; funext b&#10;  cases b&#10;  · simp only [Bool.false_eq_true, ↓reduceIte, pure_bind, cond_false]&#10;    exact ih acc&#10;  · simp only [↓reduceIte, ← reverse_cons, pure_bind, cond_true]&#10;    exact ih (x :: acc)">
                    <AtomNode start="(272, 3)" end="(272, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(272, 13)" end="(272, 14)">
                      <OtherNode start="(272, 13)" end="(272, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(272, 13)" end="(272, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(272, 15)" end="(272, 31)">
                      <AtomNode start="(272, 15)" end="(272, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(272, 28)" end="(272, 31)">
                        <IdentNode start="(272, 28)" end="(272, 31)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(272, 32)" end="(279, 26)">
                      <OtherNode start="(272, 32)" end="(279, 26)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(272, 32)" end="(272, 36)" leading="" trailing=" " val="with"/>
                        <NullNode start="(272, 37)" end="(272, 41)">
                          <OtherNode start="(272, 37)" end="(272, 41)" kind="Lean.Parser.Tactic.simp">
                            <AtomNode start="(272, 37)" end="(272, 41)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(273, 3)" end="(279, 26)">
                          <OtherNode start="(273, 3)" end="(279, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(273, 3)" end="(273, 17)">
                              <OtherNode start="(273, 3)" end="(273, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(273, 3)" end="(273, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(273, 5)" end="(273, 9)">
                                  <NullNode/>
                                  <IdentNode start="(273, 5)" end="(273, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(273, 10)" end="(273, 17)">
                                  <IdentNode start="(273, 10)" end="(273, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(273, 12)" end="(273, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(273, 15)" end="(273, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(273, 18)" end="(279, 26)">
                              <AtomNode start="(273, 18)" end="(273, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(274, 5)" end="(279, 26)">
                                <TacticTacticseq1IndentedNode start="(274, 5)" end="(279, 26)">
                                  <NullNode start="(274, 5)" end="(279, 26)">
                                    <OtherNode start="(274, 5)" end="(274, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let x_1 ← p x&#10;      let init ← if x_1 = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    do&#10;    let a ← p x&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif a then x :: acc else acc)" state_after="case cons.e_a&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (fun x_1 =&amp;gt; do&#10;      let init ← if x_1 = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    fun a =&amp;gt; (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif a then x :: acc else acc)" tactic="congr">
                                      <AtomNode start="(274, 5)" end="(274, 10)" leading="" trailing="" val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(274, 10)" end="(274, 11)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(274, 12)" end="(274, 20)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (fun x_1 =&amp;gt; do&#10;      let init ← if x_1 = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    fun a =&amp;gt; (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif a then x :: acc else acc)" state_after="case cons.e_a.h&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;b : Bool&#10;⊢ (do&#10;      let init ← if b = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif b then x :: acc else acc)" tactic="funext b">
                                      <AtomNode start="(274, 12)" end="(274, 18)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(274, 19)" end="(274, 20)">
                                        <IdentNode start="(274, 19)" end="(274, 20)" leading="" trailing="&#10;    " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(275, 5)" end="(275, 12)" kind="Lean.Parser.Tactic.cases" state_before="case cons.e_a.h&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;b : Bool&#10;⊢ (do&#10;      let init ← if b = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif b then x :: acc else acc)" state_after="case cons.e_a.h.false&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if false = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif false then x :: acc else acc)&#10;&#10;case cons.e_a.h.true&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if true = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif true then x :: acc else acc)" tactic="cases b">
                                      <AtomNode start="(275, 5)" end="(275, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(275, 11)" end="(275, 12)">
                                        <OtherNode start="(275, 11)" end="(275, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(275, 11)" end="(275, 12)" leading="" trailing="&#10;    " raw_val="b" val="b"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(276, 5)" end="(277, 19)" kind="Lean.cdot" state_before="case cons.e_a.h.false&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if false = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif false then x :: acc else acc)&#10;&#10;case cons.e_a.h.true&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if true = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif true then x :: acc else acc)" state_after="case cons.e_a.h.true&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if true = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif true then x :: acc else acc)" tactic="· simp only [Bool.false_eq_true, ↓reduceIte, pure_bind, cond_false]&#10;  exact ih acc">
                                      <OtherNode start="(276, 5)" end="(276, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(276, 5)" end="(276, 6)" kind="patternIgnore">
                                          <OtherNode start="(276, 5)" end="(276, 6)" kind="token.«· »">
                                            <AtomNode start="(276, 5)" end="(276, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(276, 7)" end="(277, 19)">
                                        <TacticTacticseq1IndentedNode start="(276, 7)" end="(277, 19)">
                                          <NullNode start="(276, 7)" end="(277, 19)">
                                            <OtherNode start="(276, 7)" end="(276, 72)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h.false&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if false = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif false then x :: acc else acc)" state_after="case cons.e_a.h.false&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      acc.reverse.toArray xs =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc" tactic="simp only [Bool.false_eq_true, ↓reduceIte, pure_bind, cond_false]">
                                              <AtomNode start="(276, 7)" end="(276, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(276, 12)" end="(276, 16)">
                                                <AtomNode start="(276, 12)" end="(276, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(276, 17)" end="(276, 72)">
                                                <AtomNode start="(276, 17)" end="(276, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(276, 18)" end="(276, 71)">
                                                  <OtherNode start="(276, 18)" end="(276, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(276, 18)" end="(276, 36)" leading="" trailing="" raw_val="Bool.false_eq_true" val="Bool.false_eq_true" full_name="Bool.false_eq_true" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(276, 36)" end="(276, 37)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(276, 38)" end="(276, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode start="(276, 38)" end="(276, 39)">
                                                      <OtherNode start="(276, 38)" end="(276, 39)" kind="Lean.Parser.Tactic.simpPre">
                                                        <AtomNode start="(276, 38)" end="(276, 39)" leading="" trailing="" val="↓"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <IdentNode start="(276, 39)" end="(276, 48)" leading="" trailing="" raw_val="reduceIte" val="reduceIte"/>
                                                  </OtherNode>
                                                  <AtomNode start="(276, 48)" end="(276, 49)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(276, 50)" end="(276, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(276, 50)" end="(276, 59)" leading="" trailing="" raw_val="pure_bind" val="pure_bind" full_name="LawfulMonad.pure_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(276, 59)" end="(276, 60)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(276, 61)" end="(276, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(276, 61)" end="(276, 71)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(276, 71)" end="(276, 72)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(277, 7)" end="(277, 19)" kind="Lean.Parser.Tactic.exact" state_before="case cons.e_a.h.false&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      acc.reverse.toArray xs =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc" state_after="no goals" tactic="exact ih acc">
                                              <AtomNode start="(277, 7)" end="(277, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(277, 13)" end="(277, 19)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(277, 13)" end="(277, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(277, 16)" end="(277, 19)">
                                                  <IdentNode start="(277, 16)" end="(277, 19)" leading="" trailing="&#10;    " raw_val="acc" val="acc"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(278, 5)" end="(279, 26)" kind="Lean.cdot" state_before="case cons.e_a.h.true&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if true = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif true then x :: acc else acc)" state_after="no goals" tactic="· simp only [↓reduceIte, ← reverse_cons, pure_bind, cond_true]&#10;  exact ih (x :: acc)">
                                      <OtherNode start="(278, 5)" end="(278, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(278, 5)" end="(278, 6)" kind="patternIgnore">
                                          <OtherNode start="(278, 5)" end="(278, 6)" kind="token.«· »">
                                            <AtomNode start="(278, 5)" end="(278, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(278, 7)" end="(279, 26)">
                                        <TacticTacticseq1IndentedNode start="(278, 7)" end="(279, 26)">
                                          <NullNode start="(278, 7)" end="(279, 26)">
                                            <OtherNode start="(278, 7)" end="(278, 67)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h.true&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ (do&#10;      let init ← if true = true then pure (acc.reverse ++ [x]).toArray else pure acc.reverse.toArray&#10;      foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← p a&#10;            if __do_lift = true then pure (acc.push a) else pure acc)&#10;          init xs) =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (bif true then x :: acc else acc)" state_after="case cons.e_a.h.true&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      (x :: acc).reverse.toArray xs =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (x :: acc)" tactic="simp only [↓reduceIte, ← reverse_cons, pure_bind, cond_true]">
                                              <AtomNode start="(278, 7)" end="(278, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(278, 12)" end="(278, 16)">
                                                <AtomNode start="(278, 12)" end="(278, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(278, 17)" end="(278, 67)">
                                                <AtomNode start="(278, 17)" end="(278, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(278, 18)" end="(278, 66)">
                                                  <OtherNode start="(278, 18)" end="(278, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode start="(278, 18)" end="(278, 19)">
                                                      <OtherNode start="(278, 18)" end="(278, 19)" kind="Lean.Parser.Tactic.simpPre">
                                                        <AtomNode start="(278, 18)" end="(278, 19)" leading="" trailing="" val="↓"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <IdentNode start="(278, 19)" end="(278, 28)" leading="" trailing="" raw_val="reduceIte" val="reduceIte"/>
                                                  </OtherNode>
                                                  <AtomNode start="(278, 28)" end="(278, 29)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(278, 30)" end="(278, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode start="(278, 30)" end="(278, 31)">
                                                      <OtherNode start="(278, 30)" end="(278, 31)" kind="patternIgnore">
                                                        <OtherNode start="(278, 30)" end="(278, 31)" kind="token.«← »">
                                                          <AtomNode start="(278, 30)" end="(278, 31)" leading="" trailing=" " val="←"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <IdentNode start="(278, 32)" end="(278, 44)" leading="" trailing="" raw_val="reverse_cons" val="reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(278, 44)" end="(278, 45)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(278, 46)" end="(278, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(278, 46)" end="(278, 55)" leading="" trailing="" raw_val="pure_bind" val="pure_bind" full_name="LawfulMonad.pure_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(278, 55)" end="(278, 56)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(278, 57)" end="(278, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(278, 57)" end="(278, 66)" leading="" trailing="" raw_val="cond_true" val="cond_true" full_name="cond_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(278, 66)" end="(278, 67)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(279, 7)" end="(279, 26)" kind="Lean.Parser.Tactic.exact" state_before="case cons.e_a.h.true&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List α),&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← p a&#10;          if __do_lift = true then pure (acc.push a) else pure acc)&#10;        acc.reverse.toArray xs =&#10;      (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs acc&#10;acc : List α&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← p a&#10;        if __do_lift = true then pure (acc.push a) else pure acc)&#10;      (x :: acc).reverse.toArray xs =&#10;    (fun a =&amp;gt; a.reverse.toArray) &amp;lt;$&amp;gt; filterAuxM p xs (x :: acc)" state_after="no goals" tactic="exact ih (x :: acc)">
                                              <AtomNode start="(279, 7)" end="(279, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(279, 13)" end="(279, 26)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(279, 13)" end="(279, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(279, 16)" end="(279, 26)">
                                                  <OtherNode start="(279, 16)" end="(279, 26)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(279, 16)" end="(279, 17)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(279, 17)" end="(279, 25)" kind="«term_::_»">
                                                      <IdentNode start="(279, 17)" end="(279, 18)" leading="" trailing=" " raw_val="x" val="x"/>
                                                      <AtomNode start="(279, 19)" end="(279, 21)" leading="" trailing=" " val="::"/>
                                                      <IdentNode start="(279, 22)" end="(279, 25)" leading="" trailing="" raw_val="acc" val="acc"/>
                                                    </OtherNode>
                                                    <AtomNode start="(279, 25)" end="(279, 26)" leading="" trailing="&#10;&#10;" val=")"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(281, 1)" end="(285, 23)" name="filterM_toArray'" full_name="List.filterM_toArray'">
      <CommandDeclmodifiersNode start="(281, 1)" end="(282, 8)">
        <NullNode start="(281, 1)" end="(281, 81)">
          <CommandDoccommentNode start="(281, 1)" end="(281, 81)" comment="Variant of `filterM_toArray` with a side condition for the stop position. -/">
            <AtomNode start="(281, 1)" end="(281, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(281, 5)" end="(281, 81)" leading="" trailing="&#10;" val="Variant of `filterM_toArray` with a side condition for the stop position. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(282, 1)" end="(282, 8)">
          <OtherNode start="(282, 1)" end="(282, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(282, 1)" end="(282, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(282, 3)" end="(282, 7)">
              <OtherNode start="(282, 3)" end="(282, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(282, 3)" end="(282, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(282, 3)" end="(282, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(282, 7)" end="(282, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(282, 9)" end="(285, 23)" name="filterM_toArray'" full_name="List.filterM_toArray'" _is_private_decl="False">
        <AtomNode start="(282, 9)" end="(282, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(282, 17)" end="(282, 33)">
          <IdentNode start="(282, 17)" end="(282, 33)" leading="" trailing=" " raw_val="filterM_toArray'" val="filterM_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(282, 34)" end="(283, 57)">
          <NullNode start="(282, 34)" end="(282, 111)">
            <OtherNode start="(282, 34)" end="(282, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(282, 34)" end="(282, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(282, 35)" end="(282, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(282, 35)" end="(282, 40)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(282, 41)" end="(282, 42)">
                  <IdentNode start="(282, 41)" end="(282, 42)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(282, 42)" end="(282, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(282, 44)" end="(282, 59)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(282, 44)" end="(282, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(282, 45)" end="(282, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(282, 45)" end="(282, 56)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(282, 57)" end="(282, 58)">
                  <IdentNode start="(282, 57)" end="(282, 58)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(282, 58)" end="(282, 59)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(282, 60)" end="(282, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(282, 60)" end="(282, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(282, 61)" end="(282, 62)">
                <IdentNode start="(282, 61)" end="(282, 62)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(282, 63)" end="(282, 71)">
                <AtomNode start="(282, 63)" end="(282, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(282, 65)" end="(282, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(282, 65)" end="(282, 69)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(282, 70)" end="(282, 71)">
                    <IdentNode start="(282, 70)" end="(282, 71)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(282, 71)" end="(282, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(282, 73)" end="(282, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(282, 73)" end="(282, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(282, 74)" end="(282, 75)">
                <IdentNode start="(282, 74)" end="(282, 75)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(282, 76)" end="(282, 88)">
                <AtomNode start="(282, 76)" end="(282, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(282, 78)" end="(282, 88)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(282, 78)" end="(282, 79)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(282, 80)" end="(282, 81)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(282, 82)" end="(282, 88)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(282, 82)" end="(282, 83)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(282, 84)" end="(282, 88)">
                      <IdentNode start="(282, 84)" end="(282, 88)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(282, 88)" end="(282, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(282, 90)" end="(282, 111)">
              <AtomNode start="(282, 90)" end="(282, 91)" leading="" trailing="" val="("/>
              <NullNode start="(282, 91)" end="(282, 92)">
                <IdentNode start="(282, 91)" end="(282, 92)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(282, 93)" end="(282, 110)">
                <AtomNode start="(282, 93)" end="(282, 94)" leading="" trailing=" " val=":"/>
                <OtherNode start="(282, 95)" end="(282, 110)" kind="«term_=_»">
                  <IdentNode start="(282, 95)" end="(282, 99)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(282, 100)" end="(282, 101)" leading="" trailing=" " val="="/>
                  <IdentNode start="(282, 102)" end="(282, 110)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(282, 110)" end="(282, 111)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(282, 112)" end="(283, 57)">
            <AtomNode start="(282, 112)" end="(282, 113)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(283, 5)" end="(283, 57)" kind="«term_=_»">
              <OtherNode start="(283, 5)" end="(283, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(283, 5)" end="(283, 22)" leading="" trailing=" " raw_val="l.toArray.filterM" val="l.toArray.filterM"/>
                <NullNode start="(283, 23)" end="(283, 31)">
                  <IdentNode start="(283, 23)" end="(283, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(283, 25)" end="(283, 26)" kind="num">
                    <AtomNode start="(283, 25)" end="(283, 26)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(283, 27)" end="(283, 31)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(283, 32)" end="(283, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(283, 34)" end="(283, 57)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(283, 34)" end="(283, 41)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(283, 42)" end="(283, 45)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(283, 46)" end="(283, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(283, 46)" end="(283, 55)" leading="" trailing=" " raw_val="l.filterM" val="l.filterM"/>
                  <NullNode start="(283, 56)" end="(283, 57)">
                    <IdentNode start="(283, 56)" end="(283, 57)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(283, 58)" end="(285, 23)">
          <AtomNode start="(283, 58)" end="(283, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(283, 61)" end="(285, 23)">
            <AtomNode start="(283, 61)" end="(283, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(284, 3)" end="(285, 23)">
              <TacticTacticseq1IndentedNode start="(284, 3)" end="(285, 23)">
                <NullNode start="(284, 3)" end="(285, 23)">
                  <OtherNode start="(284, 3)" end="(284, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type → Type u_1&#10;α : Type&#10;stop : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;w : stop = l.length&#10;⊢ Array.filterM p l.toArray 0 stop = toArray &amp;lt;$&amp;gt; filterM p l" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.filterM p l.toArray 0 l.length = toArray &amp;lt;$&amp;gt; filterM p l" tactic="subst w">
                    <AtomNode start="(284, 3)" end="(284, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(284, 9)" end="(284, 10)">
                      <IdentNode start="(284, 9)" end="(284, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(285, 3)" end="(285, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.filterM p l.toArray 0 l.length = toArray &amp;lt;$&amp;gt; filterM p l" state_after="no goals" tactic="rw [filterM_toArray]">
                    <AtomNode start="(285, 3)" end="(285, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(285, 6)" end="(285, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(285, 6)" end="(285, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(285, 7)" end="(285, 22)">
                        <OtherNode start="(285, 7)" end="(285, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(285, 7)" end="(285, 22)" leading="" trailing="" raw_val="filterM_toArray" val="filterM_toArray" full_name="List.filterM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(267, 9)" def_end="(267, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(285, 22)" end="(285, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(287, 1)" end="(291, 89)" name="filterRevM_toArray" full_name="List.filterRevM_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(287, 1)" end="(291, 89)" name="filterRevM_toArray" full_name="List.filterRevM_toArray" _is_private_decl="False">
        <AtomNode start="(287, 1)" end="(287, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(287, 9)" end="(287, 27)">
          <IdentNode start="(287, 9)" end="(287, 27)" leading="" trailing=" " raw_val="filterRevM_toArray" val="filterRevM_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(287, 28)" end="(288, 56)">
          <NullNode start="(287, 28)" end="(287, 83)">
            <OtherNode start="(287, 28)" end="(287, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(287, 28)" end="(287, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(287, 29)" end="(287, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(287, 29)" end="(287, 34)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(287, 35)" end="(287, 36)">
                  <IdentNode start="(287, 35)" end="(287, 36)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(287, 36)" end="(287, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(287, 38)" end="(287, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(287, 38)" end="(287, 39)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(287, 39)" end="(287, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(287, 39)" end="(287, 50)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(287, 51)" end="(287, 52)">
                  <IdentNode start="(287, 51)" end="(287, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(287, 52)" end="(287, 53)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(287, 54)" end="(287, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(287, 54)" end="(287, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(287, 55)" end="(287, 56)">
                <IdentNode start="(287, 55)" end="(287, 56)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(287, 57)" end="(287, 65)">
                <AtomNode start="(287, 57)" end="(287, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(287, 59)" end="(287, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(287, 59)" end="(287, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(287, 64)" end="(287, 65)">
                    <IdentNode start="(287, 64)" end="(287, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(287, 65)" end="(287, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(287, 67)" end="(287, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(287, 67)" end="(287, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(287, 68)" end="(287, 69)">
                <IdentNode start="(287, 68)" end="(287, 69)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(287, 70)" end="(287, 82)">
                <AtomNode start="(287, 70)" end="(287, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(287, 72)" end="(287, 82)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(287, 72)" end="(287, 73)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(287, 74)" end="(287, 75)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(287, 76)" end="(287, 82)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(287, 76)" end="(287, 77)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(287, 78)" end="(287, 82)">
                      <IdentNode start="(287, 78)" end="(287, 82)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(287, 82)" end="(287, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(287, 84)" end="(288, 56)">
            <AtomNode start="(287, 84)" end="(287, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(288, 5)" end="(288, 56)" kind="«term_=_»">
              <OtherNode start="(288, 5)" end="(288, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(288, 5)" end="(288, 25)" leading="" trailing=" " raw_val="l.toArray.filterRevM" val="l.toArray.filterRevM"/>
                <NullNode start="(288, 26)" end="(288, 27)">
                  <IdentNode start="(288, 26)" end="(288, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(288, 28)" end="(288, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(288, 30)" end="(288, 56)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(288, 30)" end="(288, 37)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(288, 38)" end="(288, 41)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(288, 42)" end="(288, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(288, 42)" end="(288, 54)" leading="" trailing=" " raw_val="l.filterRevM" val="l.filterRevM"/>
                  <NullNode start="(288, 55)" end="(288, 56)">
                    <IdentNode start="(288, 55)" end="(288, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(288, 57)" end="(291, 89)">
          <AtomNode start="(288, 57)" end="(288, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(288, 60)" end="(291, 89)">
            <AtomNode start="(288, 60)" end="(288, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(289, 3)" end="(291, 89)">
              <TacticTacticseq1IndentedNode start="(289, 3)" end="(291, 89)">
                <NullNode start="(289, 3)" end="(291, 89)">
                  <OtherNode start="(289, 3)" end="(289, 38)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.filterRevM p l.toArray = toArray &amp;lt;$&amp;gt; filterRevM p l" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.reverse &amp;lt;$&amp;gt;&#10;      foldrM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← p x&#10;          if __do_lift = true then pure (y.push x) else pure y)&#10;        #[] l =&#10;    toArray &amp;lt;$&amp;gt; filterAuxM p l.reverse []" tactic="simp [Array.filterRevM, filterRevM]">
                    <AtomNode start="(289, 3)" end="(289, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(289, 8)" end="(289, 38)">
                      <AtomNode start="(289, 8)" end="(289, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(289, 9)" end="(289, 37)">
                        <OtherNode start="(289, 9)" end="(289, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(289, 9)" end="(289, 25)" leading="" trailing="" raw_val="Array.filterRevM" val="Array.filterRevM" full_name="Array.filterRevM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(289, 25)" end="(289, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(289, 27)" end="(289, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(289, 27)" end="(289, 37)" leading="" trailing="" raw_val="filterRevM" val="filterRevM" full_name="List.filterRevM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(289, 37)" end="(289, 38)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(290, 3)" end="(290, 76)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.reverse &amp;lt;$&amp;gt;&#10;      foldrM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← p x&#10;          if __do_lift = true then pure (y.push x) else pure y)&#10;        #[] l =&#10;    toArray &amp;lt;$&amp;gt; filterAuxM p l.reverse []" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.reverse &amp;lt;$&amp;gt; toArray &amp;lt;$&amp;gt; filterM p l.reverse = toArray &amp;lt;$&amp;gt; filterAuxM p l.reverse []" tactic="rw [← foldlM_reverse, ← foldlM_toArray, ← Array.filterM, filterM_toArray]">
                    <AtomNode start="(290, 3)" end="(290, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(290, 6)" end="(290, 76)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(290, 6)" end="(290, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(290, 7)" end="(290, 75)">
                        <OtherNode start="(290, 7)" end="(290, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(290, 7)" end="(290, 8)">
                            <OtherNode start="(290, 7)" end="(290, 8)" kind="patternIgnore">
                              <OtherNode start="(290, 7)" end="(290, 8)" kind="token.«← »">
                                <AtomNode start="(290, 7)" end="(290, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(290, 9)" end="(290, 23)" leading="" trailing="" raw_val="foldlM_reverse" val="foldlM_reverse" full_name="List.foldlM_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(290, 23)" end="(290, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(290, 25)" end="(290, 41)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(290, 25)" end="(290, 26)">
                            <OtherNode start="(290, 25)" end="(290, 26)" kind="patternIgnore">
                              <OtherNode start="(290, 25)" end="(290, 26)" kind="token.«← »">
                                <AtomNode start="(290, 25)" end="(290, 26)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(290, 27)" end="(290, 41)" leading="" trailing="" raw_val="foldlM_toArray" val="foldlM_toArray" full_name="List.foldlM_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(290, 41)" end="(290, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(290, 43)" end="(290, 58)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(290, 43)" end="(290, 44)">
                            <OtherNode start="(290, 43)" end="(290, 44)" kind="patternIgnore">
                              <OtherNode start="(290, 43)" end="(290, 44)" kind="token.«← »">
                                <AtomNode start="(290, 43)" end="(290, 44)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(290, 45)" end="(290, 58)" leading="" trailing="" raw_val="Array.filterM" val="Array.filterM" full_name="Array.filterM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(290, 58)" end="(290, 59)" leading="" trailing=" " val=","/>
                        <OtherNode start="(290, 60)" end="(290, 75)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(290, 60)" end="(290, 75)" leading="" trailing="" raw_val="filterM_toArray" val="filterM_toArray" full_name="List.filterM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(267, 9)" def_end="(267, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(290, 75)" end="(290, 76)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(291, 3)" end="(291, 89)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.reverse &amp;lt;$&amp;gt; toArray &amp;lt;$&amp;gt; filterM p l.reverse = toArray &amp;lt;$&amp;gt; filterAuxM p l.reverse []" state_after="no goals" tactic="simp only [filterM, bind_pure_comp, Functor.map_map, reverse_toArray, reverse_reverse]">
                    <AtomNode start="(291, 3)" end="(291, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(291, 8)" end="(291, 12)">
                      <AtomNode start="(291, 8)" end="(291, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(291, 13)" end="(291, 89)">
                      <AtomNode start="(291, 13)" end="(291, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(291, 14)" end="(291, 88)">
                        <OtherNode start="(291, 14)" end="(291, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 14)" end="(291, 21)" leading="" trailing="" raw_val="filterM" val="filterM" full_name="List.filterM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                        <AtomNode start="(291, 21)" end="(291, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(291, 23)" end="(291, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 23)" end="(291, 37)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(291, 37)" end="(291, 38)" leading="" trailing=" " val=","/>
                        <OtherNode start="(291, 39)" end="(291, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 39)" end="(291, 54)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(291, 54)" end="(291, 55)" leading="" trailing=" " val=","/>
                        <OtherNode start="(291, 56)" end="(291, 71)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 56)" end="(291, 71)" leading="" trailing="" raw_val="reverse_toArray" val="reverse_toArray" full_name="List.reverse_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(291, 71)" end="(291, 72)" leading="" trailing=" " val=","/>
                        <OtherNode start="(291, 73)" end="(291, 88)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 73)" end="(291, 88)" leading="" trailing="" raw_val="reverse_reverse" val="reverse_reverse" full_name="List.reverse_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(291, 88)" end="(291, 89)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(293, 1)" end="(297, 26)" name="filterRevM_toArray'" full_name="List.filterRevM_toArray'">
      <CommandDeclmodifiersNode start="(293, 1)" end="(294, 8)">
        <NullNode start="(293, 1)" end="(293, 85)">
          <CommandDoccommentNode start="(293, 1)" end="(293, 85)" comment="Variant of `filterRevM_toArray` with a side condition for the start position. -/">
            <AtomNode start="(293, 1)" end="(293, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(293, 5)" end="(293, 85)" leading="" trailing="&#10;" val="Variant of `filterRevM_toArray` with a side condition for the start position. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(294, 1)" end="(294, 8)">
          <OtherNode start="(294, 1)" end="(294, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(294, 1)" end="(294, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(294, 3)" end="(294, 7)">
              <OtherNode start="(294, 3)" end="(294, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(294, 3)" end="(294, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(294, 3)" end="(294, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(294, 7)" end="(294, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(294, 9)" end="(297, 26)" name="filterRevM_toArray'" full_name="List.filterRevM_toArray'" _is_private_decl="False">
        <AtomNode start="(294, 9)" end="(294, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(294, 17)" end="(294, 36)">
          <IdentNode start="(294, 17)" end="(294, 36)" leading="" trailing=" " raw_val="filterRevM_toArray'" val="filterRevM_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(294, 37)" end="(295, 64)">
          <NullNode start="(294, 37)" end="(294, 115)">
            <OtherNode start="(294, 37)" end="(294, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(294, 37)" end="(294, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(294, 38)" end="(294, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(294, 38)" end="(294, 43)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(294, 44)" end="(294, 45)">
                  <IdentNode start="(294, 44)" end="(294, 45)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(294, 45)" end="(294, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(294, 47)" end="(294, 62)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(294, 47)" end="(294, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(294, 48)" end="(294, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(294, 48)" end="(294, 59)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(294, 60)" end="(294, 61)">
                  <IdentNode start="(294, 60)" end="(294, 61)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(294, 61)" end="(294, 62)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(294, 63)" end="(294, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(294, 63)" end="(294, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(294, 64)" end="(294, 65)">
                <IdentNode start="(294, 64)" end="(294, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(294, 66)" end="(294, 74)">
                <AtomNode start="(294, 66)" end="(294, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(294, 68)" end="(294, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(294, 68)" end="(294, 72)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(294, 73)" end="(294, 74)">
                    <IdentNode start="(294, 73)" end="(294, 74)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(294, 74)" end="(294, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(294, 76)" end="(294, 92)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(294, 76)" end="(294, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(294, 77)" end="(294, 78)">
                <IdentNode start="(294, 77)" end="(294, 78)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(294, 79)" end="(294, 91)">
                <AtomNode start="(294, 79)" end="(294, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(294, 81)" end="(294, 91)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(294, 81)" end="(294, 82)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(294, 83)" end="(294, 84)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(294, 85)" end="(294, 91)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(294, 85)" end="(294, 86)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(294, 87)" end="(294, 91)">
                      <IdentNode start="(294, 87)" end="(294, 91)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(294, 91)" end="(294, 92)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(294, 93)" end="(294, 115)">
              <AtomNode start="(294, 93)" end="(294, 94)" leading="" trailing="" val="("/>
              <NullNode start="(294, 94)" end="(294, 95)">
                <IdentNode start="(294, 94)" end="(294, 95)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(294, 96)" end="(294, 114)">
                <AtomNode start="(294, 96)" end="(294, 97)" leading="" trailing=" " val=":"/>
                <OtherNode start="(294, 98)" end="(294, 114)" kind="«term_=_»">
                  <IdentNode start="(294, 98)" end="(294, 103)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(294, 104)" end="(294, 105)" leading="" trailing=" " val="="/>
                  <IdentNode start="(294, 106)" end="(294, 114)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(294, 114)" end="(294, 115)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(294, 116)" end="(295, 64)">
            <AtomNode start="(294, 116)" end="(294, 117)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(295, 5)" end="(295, 64)" kind="«term_=_»">
              <OtherNode start="(295, 5)" end="(295, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(295, 5)" end="(295, 25)" leading="" trailing=" " raw_val="l.toArray.filterRevM" val="l.toArray.filterRevM"/>
                <NullNode start="(295, 26)" end="(295, 35)">
                  <IdentNode start="(295, 26)" end="(295, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(295, 28)" end="(295, 33)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(295, 34)" end="(295, 35)" kind="num">
                    <AtomNode start="(295, 34)" end="(295, 35)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(295, 36)" end="(295, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(295, 38)" end="(295, 64)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(295, 38)" end="(295, 45)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(295, 46)" end="(295, 49)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(295, 50)" end="(295, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(295, 50)" end="(295, 62)" leading="" trailing=" " raw_val="l.filterRevM" val="l.filterRevM"/>
                  <NullNode start="(295, 63)" end="(295, 64)">
                    <IdentNode start="(295, 63)" end="(295, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(295, 65)" end="(297, 26)">
          <AtomNode start="(295, 65)" end="(295, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(295, 68)" end="(297, 26)">
            <AtomNode start="(295, 68)" end="(295, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(296, 3)" end="(297, 26)">
              <TacticTacticseq1IndentedNode start="(296, 3)" end="(297, 26)">
                <NullNode start="(296, 3)" end="(297, 26)">
                  <OtherNode start="(296, 3)" end="(296, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type → Type u_1&#10;α : Type&#10;start : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;w : start = l.length&#10;⊢ Array.filterRevM p l.toArray start = toArray &amp;lt;$&amp;gt; filterRevM p l" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.filterRevM p l.toArray l.length = toArray &amp;lt;$&amp;gt; filterRevM p l" tactic="subst w">
                    <AtomNode start="(296, 3)" end="(296, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(296, 9)" end="(296, 10)">
                      <IdentNode start="(296, 9)" end="(296, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(297, 3)" end="(297, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;p : α → m Bool&#10;⊢ Array.filterRevM p l.toArray l.length = toArray &amp;lt;$&amp;gt; filterRevM p l" state_after="no goals" tactic="rw [filterRevM_toArray]">
                    <AtomNode start="(297, 3)" end="(297, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(297, 6)" end="(297, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(297, 6)" end="(297, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(297, 7)" end="(297, 25)">
                        <OtherNode start="(297, 7)" end="(297, 25)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(297, 7)" end="(297, 25)" leading="" trailing="" raw_val="filterRevM_toArray" val="filterRevM_toArray" full_name="List.filterRevM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(287, 9)" def_end="(287, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(297, 25)" end="(297, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(299, 1)" end="(309, 66)" name="filterMapM_toArray" full_name="List.filterMapM_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(299, 1)" end="(309, 66)" name="filterMapM_toArray" full_name="List.filterMapM_toArray" _is_private_decl="False">
        <AtomNode start="(299, 1)" end="(299, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(299, 9)" end="(299, 27)">
          <IdentNode start="(299, 9)" end="(299, 27)" leading="" trailing=" " raw_val="filterMapM_toArray" val="filterMapM_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(299, 28)" end="(300, 56)">
          <NullNode start="(299, 28)" end="(299, 89)">
            <OtherNode start="(299, 28)" end="(299, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(299, 28)" end="(299, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(299, 29)" end="(299, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(299, 29)" end="(299, 34)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(299, 35)" end="(299, 36)">
                  <IdentNode start="(299, 35)" end="(299, 36)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(299, 36)" end="(299, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(299, 38)" end="(299, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(299, 38)" end="(299, 39)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(299, 39)" end="(299, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(299, 39)" end="(299, 50)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(299, 51)" end="(299, 52)">
                  <IdentNode start="(299, 51)" end="(299, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(299, 52)" end="(299, 53)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(299, 54)" end="(299, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(299, 54)" end="(299, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(299, 55)" end="(299, 56)">
                <IdentNode start="(299, 55)" end="(299, 56)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(299, 57)" end="(299, 65)">
                <AtomNode start="(299, 57)" end="(299, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(299, 59)" end="(299, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(299, 59)" end="(299, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(299, 64)" end="(299, 65)">
                    <IdentNode start="(299, 64)" end="(299, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(299, 65)" end="(299, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(299, 67)" end="(299, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(299, 67)" end="(299, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(299, 68)" end="(299, 69)">
                <IdentNode start="(299, 68)" end="(299, 69)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(299, 70)" end="(299, 88)">
                <AtomNode start="(299, 70)" end="(299, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(299, 72)" end="(299, 88)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(299, 72)" end="(299, 73)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(299, 74)" end="(299, 75)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(299, 76)" end="(299, 88)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(299, 76)" end="(299, 77)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(299, 78)" end="(299, 88)">
                      <OtherNode start="(299, 78)" end="(299, 88)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(299, 78)" end="(299, 79)" leading="" trailing="" val="("/>
                        <OtherNode start="(299, 79)" end="(299, 87)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(299, 79)" end="(299, 85)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(299, 86)" end="(299, 87)">
                            <IdentNode start="(299, 86)" end="(299, 87)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(299, 87)" end="(299, 88)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(299, 88)" end="(299, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(299, 90)" end="(300, 56)">
            <AtomNode start="(299, 90)" end="(299, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(300, 5)" end="(300, 56)" kind="«term_=_»">
              <OtherNode start="(300, 5)" end="(300, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(300, 5)" end="(300, 25)" leading="" trailing=" " raw_val="l.toArray.filterMapM" val="l.toArray.filterMapM"/>
                <NullNode start="(300, 26)" end="(300, 27)">
                  <IdentNode start="(300, 26)" end="(300, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(300, 28)" end="(300, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(300, 30)" end="(300, 56)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(300, 30)" end="(300, 37)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(300, 38)" end="(300, 41)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(300, 42)" end="(300, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(300, 42)" end="(300, 54)" leading="" trailing=" " raw_val="l.filterMapM" val="l.filterMapM"/>
                  <NullNode start="(300, 55)" end="(300, 56)">
                    <IdentNode start="(300, 55)" end="(300, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(300, 57)" end="(309, 66)">
          <AtomNode start="(300, 57)" end="(300, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(300, 60)" end="(309, 66)">
            <AtomNode start="(300, 60)" end="(300, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(301, 3)" end="(309, 66)">
              <TacticTacticseq1IndentedNode start="(301, 3)" end="(309, 66)">
                <NullNode start="(301, 3)" end="(309, 66)">
                  <OtherNode start="(301, 3)" end="(301, 38)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;⊢ Array.filterMapM f l.toArray = toArray &amp;lt;$&amp;gt; filterMapM f l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      #[] l =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f l []" tactic="simp [Array.filterMapM, filterMapM]">
                    <AtomNode start="(301, 3)" end="(301, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(301, 8)" end="(301, 38)">
                      <AtomNode start="(301, 8)" end="(301, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(301, 9)" end="(301, 37)">
                        <OtherNode start="(301, 9)" end="(301, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(301, 9)" end="(301, 25)" leading="" trailing="" raw_val="Array.filterMapM" val="Array.filterMapM" full_name="Array.filterMapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(301, 25)" end="(301, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(301, 27)" end="(301, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(301, 27)" end="(301, 37)" leading="" trailing="" raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(301, 37)" end="(301, 38)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(302, 3)" end="(302, 34)" kind="Lean.Parser.Tactic.Conv.conv" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      #[] l =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f l []" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      [].reverse.toArray l =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f l []" tactic="conv =&amp;gt; lhs; rw [← reverse_nil]">
                    <AtomNode start="(302, 3)" end="(302, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(302, 8)" end="(302, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(302, 11)" end="(302, 34)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(302, 11)" end="(302, 34)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(302, 11)" end="(302, 34)">
                          <OtherNode start="(302, 11)" end="(302, 14)" kind="Lean.Parser.Tactic.Conv.lhs">
                            <AtomNode start="(302, 11)" end="(302, 14)" leading="" trailing="" val="lhs"/>
                          </OtherNode>
                          <AtomNode start="(302, 14)" end="(302, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(302, 16)" end="(302, 34)" kind="Lean.Parser.Tactic.Conv.convRw__">
                            <AtomNode start="(302, 16)" end="(302, 18)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(302, 19)" end="(302, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(302, 19)" end="(302, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(302, 20)" end="(302, 33)">
                                <OtherNode start="(302, 20)" end="(302, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode start="(302, 20)" end="(302, 21)">
                                    <OtherNode start="(302, 20)" end="(302, 21)" kind="patternIgnore">
                                      <OtherNode start="(302, 20)" end="(302, 21)" kind="token.«← »">
                                        <AtomNode start="(302, 20)" end="(302, 21)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <IdentNode start="(302, 22)" end="(302, 33)" leading="" trailing="" raw_val="reverse_nil" val="reverse_nil" full_name="List.reverse_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(302, 33)" end="(302, 34)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(303, 3)" end="(303, 22)" kind="Lean.Parser.Tactic.generalize" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      [].reverse.toArray l =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f l []" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;acc : List β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      acc.reverse.toArray l =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f l acc" tactic="generalize [] = acc">
                    <AtomNode start="(303, 3)" end="(303, 13)" leading="" trailing=" " val="generalize"/>
                    <NullNode start="(303, 14)" end="(303, 22)">
                      <OtherNode start="(303, 14)" end="(303, 22)" kind="Lean.Parser.Tactic.generalizeArg">
                        <NullNode/>
                        <OtherNode start="(303, 14)" end="(303, 16)" kind="«term[_]»">
                          <AtomNode start="(303, 14)" end="(303, 15)" leading="" trailing="" val="["/>
                          <NullNode/>
                          <AtomNode start="(303, 15)" end="(303, 16)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <AtomNode start="(303, 17)" end="(303, 18)" leading="" trailing=" " val="="/>
                        <IdentNode start="(303, 19)" end="(303, 22)" leading="" trailing="&#10;  " raw_val="acc" val="acc"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(304, 3)" end="(309, 66)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;acc : List β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      acc.reverse.toArray l =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f l acc" state_after="no goals" tactic="induction l generalizing acc with simp [filterMapM.loop]&#10;| cons x xs ih =&amp;gt;&#10;  congr; funext o&#10;  cases o&#10;  · simp only [pure_bind]; exact ih acc&#10;  · simp only [pure_bind]; rw [← List.reverse_cons]; exact ih _">
                    <AtomNode start="(304, 3)" end="(304, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(304, 13)" end="(304, 14)">
                      <OtherNode start="(304, 13)" end="(304, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(304, 13)" end="(304, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(304, 15)" end="(304, 31)">
                      <AtomNode start="(304, 15)" end="(304, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(304, 28)" end="(304, 31)">
                        <IdentNode start="(304, 28)" end="(304, 31)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(304, 32)" end="(309, 66)">
                      <OtherNode start="(304, 32)" end="(309, 66)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(304, 32)" end="(304, 36)" leading="" trailing=" " val="with"/>
                        <NullNode start="(304, 37)" end="(304, 59)">
                          <OtherNode start="(304, 37)" end="(304, 59)" kind="Lean.Parser.Tactic.simp">
                            <AtomNode start="(304, 37)" end="(304, 41)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(304, 42)" end="(304, 59)">
                              <AtomNode start="(304, 42)" end="(304, 43)" leading="" trailing="" val="["/>
                              <NullNode start="(304, 43)" end="(304, 58)">
                                <OtherNode start="(304, 43)" end="(304, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(304, 43)" end="(304, 58)" leading="" trailing="" raw_val="filterMapM.loop" val="filterMapM.loop" full_name="List.filterMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(304, 58)" end="(304, 59)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(305, 3)" end="(309, 66)">
                          <OtherNode start="(305, 3)" end="(309, 66)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(305, 3)" end="(305, 17)">
                              <OtherNode start="(305, 3)" end="(305, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(305, 3)" end="(305, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(305, 5)" end="(305, 9)">
                                  <NullNode/>
                                  <IdentNode start="(305, 5)" end="(305, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(305, 10)" end="(305, 17)">
                                  <IdentNode start="(305, 10)" end="(305, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(305, 12)" end="(305, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(305, 15)" end="(305, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(305, 18)" end="(309, 66)">
                              <AtomNode start="(305, 18)" end="(305, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(306, 5)" end="(309, 66)">
                                <TacticTacticseq1IndentedNode start="(306, 5)" end="(309, 66)">
                                  <NullNode start="(306, 5)" end="(309, 66)">
                                    <OtherNode start="(306, 5)" end="(306, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ (do&#10;      let x ← f x&#10;      let init ←&#10;        match x with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    do&#10;    let a ← f x&#10;    toArray &amp;lt;$&amp;gt;&#10;        match a with&#10;        | none =&amp;gt; filterMapM.loop f xs acc&#10;        | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ (fun x =&amp;gt; do&#10;      let init ←&#10;        match x with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    fun a =&amp;gt;&#10;    toArray &amp;lt;$&amp;gt;&#10;      match a with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" tactic="congr">
                                      <AtomNode start="(306, 5)" end="(306, 10)" leading="" trailing="" val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(306, 10)" end="(306, 11)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(306, 12)" end="(306, 20)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ (fun x =&amp;gt; do&#10;      let init ←&#10;        match x with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    fun a =&amp;gt;&#10;    toArray &amp;lt;$&amp;gt;&#10;      match a with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;o : Option β&#10;⊢ (do&#10;      let init ←&#10;        match o with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match o with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" tactic="funext o">
                                      <AtomNode start="(306, 12)" end="(306, 18)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(306, 19)" end="(306, 20)">
                                        <IdentNode start="(306, 19)" end="(306, 20)" leading="" trailing="&#10;    " raw_val="o" val="o"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(307, 5)" end="(307, 12)" kind="Lean.Parser.Tactic.cases" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;o : Option β&#10;⊢ (do&#10;      let init ←&#10;        match o with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match o with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" state_after="case cons.e_a.h.none&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ (do&#10;      let init ←&#10;        match none with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match none with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)&#10;&#10;case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ (do&#10;      let init ←&#10;        match some val✝ with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match some val✝ with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" tactic="cases o">
                                      <AtomNode start="(307, 5)" end="(307, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(307, 11)" end="(307, 12)">
                                        <OtherNode start="(307, 11)" end="(307, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(307, 11)" end="(307, 12)" leading="" trailing="&#10;    " raw_val="o" val="o"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(308, 5)" end="(308, 42)" kind="Lean.cdot" state_before="case cons.e_a.h.none&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ (do&#10;      let init ←&#10;        match none with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match none with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)&#10;&#10;case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ (do&#10;      let init ←&#10;        match some val✝ with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match some val✝ with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" state_after="case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ (do&#10;      let init ←&#10;        match some val✝ with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match some val✝ with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" tactic="· simp only [pure_bind]; exact ih acc">
                                      <OtherNode start="(308, 5)" end="(308, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(308, 5)" end="(308, 6)" kind="patternIgnore">
                                          <OtherNode start="(308, 5)" end="(308, 6)" kind="token.«· »">
                                            <AtomNode start="(308, 5)" end="(308, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(308, 7)" end="(308, 42)">
                                        <TacticTacticseq1IndentedNode start="(308, 7)" end="(308, 42)">
                                          <NullNode start="(308, 7)" end="(308, 42)">
                                            <OtherNode start="(308, 7)" end="(308, 28)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h.none&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ (do&#10;      let init ←&#10;        match none with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match none with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" state_after="case cons.e_a.h.none&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      acc.reverse.toArray xs =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc" tactic="simp only [pure_bind]">
                                              <AtomNode start="(308, 7)" end="(308, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(308, 12)" end="(308, 16)">
                                                <AtomNode start="(308, 12)" end="(308, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(308, 17)" end="(308, 28)">
                                                <AtomNode start="(308, 17)" end="(308, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(308, 18)" end="(308, 27)">
                                                  <OtherNode start="(308, 18)" end="(308, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(308, 18)" end="(308, 27)" leading="" trailing="" raw_val="pure_bind" val="pure_bind" full_name="LawfulMonad.pure_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(308, 27)" end="(308, 28)" leading="" trailing="" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(308, 28)" end="(308, 29)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(308, 30)" end="(308, 42)" kind="Lean.Parser.Tactic.exact" state_before="case cons.e_a.h.none&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      acc.reverse.toArray xs =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc" state_after="no goals" tactic="exact ih acc">
                                              <AtomNode start="(308, 30)" end="(308, 35)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(308, 36)" end="(308, 42)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(308, 36)" end="(308, 38)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(308, 39)" end="(308, 42)">
                                                  <IdentNode start="(308, 39)" end="(308, 42)" leading="" trailing="&#10;    " raw_val="acc" val="acc"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(309, 5)" end="(309, 66)" kind="Lean.cdot" state_before="case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ (do&#10;      let init ←&#10;        match some val✝ with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match some val✝ with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" state_after="no goals" tactic="· simp only [pure_bind]; rw [← List.reverse_cons]; exact ih _">
                                      <OtherNode start="(309, 5)" end="(309, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(309, 5)" end="(309, 6)" kind="patternIgnore">
                                          <OtherNode start="(309, 5)" end="(309, 6)" kind="token.«· »">
                                            <AtomNode start="(309, 5)" end="(309, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(309, 7)" end="(309, 66)">
                                        <TacticTacticseq1IndentedNode start="(309, 7)" end="(309, 66)">
                                          <NullNode start="(309, 7)" end="(309, 66)">
                                            <OtherNode start="(309, 7)" end="(309, 28)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ (do&#10;      let init ←&#10;        match some val✝ with&#10;          | some b =&amp;gt; pure (acc.reverse ++ [b]).toArray&#10;          | none =&amp;gt; pure acc.reverse.toArray&#10;      foldlM&#10;          (fun x y =&amp;gt; do&#10;            let __do_lift ← f y&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (x.push b)&#10;              | none =&amp;gt; pure x)&#10;          init xs) =&#10;    toArray &amp;lt;$&amp;gt;&#10;      match some val✝ with&#10;      | none =&amp;gt; filterMapM.loop f xs acc&#10;      | some b =&amp;gt; filterMapM.loop f xs (b :: acc)" state_after="case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      (acc.reverse ++ [val✝]).toArray xs =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f xs (val✝ :: acc)" tactic="simp only [pure_bind]">
                                              <AtomNode start="(309, 7)" end="(309, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(309, 12)" end="(309, 16)">
                                                <AtomNode start="(309, 12)" end="(309, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(309, 17)" end="(309, 28)">
                                                <AtomNode start="(309, 17)" end="(309, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(309, 18)" end="(309, 27)">
                                                  <OtherNode start="(309, 18)" end="(309, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(309, 18)" end="(309, 27)" leading="" trailing="" raw_val="pure_bind" val="pure_bind" full_name="LawfulMonad.pure_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(309, 27)" end="(309, 28)" leading="" trailing="" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(309, 28)" end="(309, 29)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(309, 30)" end="(309, 54)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      (acc.reverse ++ [val✝]).toArray xs =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f xs (val✝ :: acc)" state_after="case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      (val✝ :: acc).reverse.toArray xs =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f xs (val✝ :: acc)" tactic="rw [← List.reverse_cons]">
                                              <AtomNode start="(309, 30)" end="(309, 32)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(309, 33)" end="(309, 54)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(309, 33)" end="(309, 34)" leading="" trailing="" val="["/>
                                                <NullNode start="(309, 34)" end="(309, 53)">
                                                  <OtherNode start="(309, 34)" end="(309, 53)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode start="(309, 34)" end="(309, 35)">
                                                      <OtherNode start="(309, 34)" end="(309, 35)" kind="patternIgnore">
                                                        <OtherNode start="(309, 34)" end="(309, 35)" kind="token.«← »">
                                                          <AtomNode start="(309, 34)" end="(309, 35)" leading="" trailing=" " val="←"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <IdentNode start="(309, 36)" end="(309, 53)" leading="" trailing="" raw_val="List.reverse_cons" val="List.reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(309, 53)" end="(309, 54)" leading="" trailing="" val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(309, 54)" end="(309, 55)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(309, 56)" end="(309, 66)" kind="Lean.Parser.Tactic.exact" state_before="case cons.e_a.h.some&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List β),&#10;    foldlM&#10;        (fun x y =&amp;gt; do&#10;          let __do_lift ← f y&#10;          match __do_lift with&#10;            | some b =&amp;gt; pure (x.push b)&#10;            | none =&amp;gt; pure x)&#10;        acc.reverse.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; filterMapM.loop f xs acc&#10;acc : List β&#10;val✝ : β&#10;⊢ foldlM&#10;      (fun x y =&amp;gt; do&#10;        let __do_lift ← f y&#10;        match __do_lift with&#10;          | some b =&amp;gt; pure (x.push b)&#10;          | none =&amp;gt; pure x)&#10;      (val✝ :: acc).reverse.toArray xs =&#10;    toArray &amp;lt;$&amp;gt; filterMapM.loop f xs (val✝ :: acc)" state_after="no goals" tactic="exact ih _">
                                              <AtomNode start="(309, 56)" end="(309, 61)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(309, 62)" end="(309, 66)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(309, 62)" end="(309, 64)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(309, 65)" end="(309, 66)">
                                                  <TermHoleNode start="(309, 65)" end="(309, 66)">
                                                    <AtomNode start="(309, 65)" end="(309, 66)" leading="" trailing="&#10;&#10;" val="_"/>
                                                  </TermHoleNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(311, 1)" end="(315, 26)" name="filterMapM_toArray'" full_name="List.filterMapM_toArray'">
      <CommandDeclmodifiersNode start="(311, 1)" end="(312, 8)">
        <NullNode start="(311, 1)" end="(311, 84)">
          <CommandDoccommentNode start="(311, 1)" end="(311, 84)" comment="Variant of `filterMapM_toArray` with a side condition for the stop position. -/">
            <AtomNode start="(311, 1)" end="(311, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(311, 5)" end="(311, 84)" leading="" trailing="&#10;" val="Variant of `filterMapM_toArray` with a side condition for the stop position. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(312, 1)" end="(312, 8)">
          <OtherNode start="(312, 1)" end="(312, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(312, 1)" end="(312, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(312, 3)" end="(312, 7)">
              <OtherNode start="(312, 3)" end="(312, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(312, 3)" end="(312, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(312, 3)" end="(312, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(312, 7)" end="(312, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(312, 9)" end="(315, 26)" name="filterMapM_toArray'" full_name="List.filterMapM_toArray'" _is_private_decl="False">
        <AtomNode start="(312, 9)" end="(312, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(312, 17)" end="(312, 36)">
          <IdentNode start="(312, 17)" end="(312, 36)" leading="" trailing=" " raw_val="filterMapM_toArray'" val="filterMapM_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(312, 37)" end="(313, 63)">
          <NullNode start="(312, 37)" end="(312, 120)">
            <OtherNode start="(312, 37)" end="(312, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(312, 37)" end="(312, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(312, 38)" end="(312, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(312, 38)" end="(312, 43)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(312, 44)" end="(312, 45)">
                  <IdentNode start="(312, 44)" end="(312, 45)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(312, 45)" end="(312, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(312, 47)" end="(312, 62)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(312, 47)" end="(312, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(312, 48)" end="(312, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(312, 48)" end="(312, 59)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(312, 60)" end="(312, 61)">
                  <IdentNode start="(312, 60)" end="(312, 61)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(312, 61)" end="(312, 62)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(312, 63)" end="(312, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(312, 63)" end="(312, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(312, 64)" end="(312, 65)">
                <IdentNode start="(312, 64)" end="(312, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(312, 66)" end="(312, 74)">
                <AtomNode start="(312, 66)" end="(312, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(312, 68)" end="(312, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(312, 68)" end="(312, 72)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(312, 73)" end="(312, 74)">
                    <IdentNode start="(312, 73)" end="(312, 74)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(312, 74)" end="(312, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(312, 76)" end="(312, 98)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(312, 76)" end="(312, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(312, 77)" end="(312, 78)">
                <IdentNode start="(312, 77)" end="(312, 78)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(312, 79)" end="(312, 97)">
                <AtomNode start="(312, 79)" end="(312, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(312, 81)" end="(312, 97)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(312, 81)" end="(312, 82)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(312, 83)" end="(312, 84)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(312, 85)" end="(312, 97)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(312, 85)" end="(312, 86)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(312, 87)" end="(312, 97)">
                      <OtherNode start="(312, 87)" end="(312, 97)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(312, 87)" end="(312, 88)" leading="" trailing="" val="("/>
                        <OtherNode start="(312, 88)" end="(312, 96)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(312, 88)" end="(312, 94)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(312, 95)" end="(312, 96)">
                            <IdentNode start="(312, 95)" end="(312, 96)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(312, 96)" end="(312, 97)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(312, 97)" end="(312, 98)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(312, 99)" end="(312, 120)">
              <AtomNode start="(312, 99)" end="(312, 100)" leading="" trailing="" val="("/>
              <NullNode start="(312, 100)" end="(312, 101)">
                <IdentNode start="(312, 100)" end="(312, 101)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(312, 102)" end="(312, 119)">
                <AtomNode start="(312, 102)" end="(312, 103)" leading="" trailing=" " val=":"/>
                <OtherNode start="(312, 104)" end="(312, 119)" kind="«term_=_»">
                  <IdentNode start="(312, 104)" end="(312, 108)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(312, 109)" end="(312, 110)" leading="" trailing=" " val="="/>
                  <IdentNode start="(312, 111)" end="(312, 119)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(312, 119)" end="(312, 120)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(312, 121)" end="(313, 63)">
            <AtomNode start="(312, 121)" end="(312, 122)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(313, 5)" end="(313, 63)" kind="«term_=_»">
              <OtherNode start="(313, 5)" end="(313, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(313, 5)" end="(313, 25)" leading="" trailing=" " raw_val="l.toArray.filterMapM" val="l.toArray.filterMapM"/>
                <NullNode start="(313, 26)" end="(313, 34)">
                  <IdentNode start="(313, 26)" end="(313, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(313, 28)" end="(313, 29)" kind="num">
                    <AtomNode start="(313, 28)" end="(313, 29)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(313, 30)" end="(313, 34)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(313, 35)" end="(313, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(313, 37)" end="(313, 63)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(313, 37)" end="(313, 44)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(313, 45)" end="(313, 48)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(313, 49)" end="(313, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(313, 49)" end="(313, 61)" leading="" trailing=" " raw_val="l.filterMapM" val="l.filterMapM"/>
                  <NullNode start="(313, 62)" end="(313, 63)">
                    <IdentNode start="(313, 62)" end="(313, 63)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(313, 64)" end="(315, 26)">
          <AtomNode start="(313, 64)" end="(313, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(313, 67)" end="(315, 26)">
            <AtomNode start="(313, 67)" end="(313, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(314, 3)" end="(315, 26)">
              <TacticTacticseq1IndentedNode start="(314, 3)" end="(315, 26)">
                <NullNode start="(314, 3)" end="(315, 26)">
                  <OtherNode start="(314, 3)" end="(314, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;stop : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;w : stop = l.length&#10;⊢ Array.filterMapM f l.toArray 0 stop = toArray &amp;lt;$&amp;gt; filterMapM f l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;⊢ Array.filterMapM f l.toArray 0 l.length = toArray &amp;lt;$&amp;gt; filterMapM f l" tactic="subst w">
                    <AtomNode start="(314, 3)" end="(314, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(314, 9)" end="(314, 10)">
                      <IdentNode start="(314, 9)" end="(314, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(315, 3)" end="(315, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Option β)&#10;⊢ Array.filterMapM f l.toArray 0 l.length = toArray &amp;lt;$&amp;gt; filterMapM f l" state_after="no goals" tactic="rw [filterMapM_toArray]">
                    <AtomNode start="(315, 3)" end="(315, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(315, 6)" end="(315, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(315, 6)" end="(315, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(315, 7)" end="(315, 25)">
                        <OtherNode start="(315, 7)" end="(315, 25)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(315, 7)" end="(315, 25)" leading="" trailing="" raw_val="filterMapM_toArray" val="filterMapM_toArray" full_name="List.filterMapM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(299, 9)" def_end="(299, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(315, 25)" end="(315, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(317, 1)" end="(328, 15)" name="flatMapM_toArray" full_name="List.flatMapM_toArray">
      <CommandDeclmodifiersNode start="(317, 1)" end="(317, 8)">
        <NullNode/>
        <NullNode start="(317, 1)" end="(317, 8)">
          <OtherNode start="(317, 1)" end="(317, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(317, 1)" end="(317, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(317, 3)" end="(317, 7)">
              <OtherNode start="(317, 3)" end="(317, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(317, 3)" end="(317, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(317, 3)" end="(317, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(317, 7)" end="(317, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(317, 9)" end="(328, 15)" name="flatMapM_toArray" full_name="List.flatMapM_toArray" _is_private_decl="False">
        <AtomNode start="(317, 9)" end="(317, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(317, 17)" end="(317, 33)">
          <IdentNode start="(317, 17)" end="(317, 33)" leading="" trailing=" " raw_val="flatMapM_toArray" val="flatMapM_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(317, 34)" end="(318, 82)">
          <NullNode start="(317, 34)" end="(317, 94)">
            <OtherNode start="(317, 34)" end="(317, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(317, 34)" end="(317, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(317, 35)" end="(317, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(317, 35)" end="(317, 40)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(317, 41)" end="(317, 42)">
                  <IdentNode start="(317, 41)" end="(317, 42)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(317, 42)" end="(317, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(317, 44)" end="(317, 59)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(317, 44)" end="(317, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(317, 45)" end="(317, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(317, 45)" end="(317, 56)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(317, 57)" end="(317, 58)">
                  <IdentNode start="(317, 57)" end="(317, 58)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(317, 58)" end="(317, 59)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(317, 60)" end="(317, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(317, 60)" end="(317, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(317, 61)" end="(317, 62)">
                <IdentNode start="(317, 61)" end="(317, 62)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(317, 63)" end="(317, 71)">
                <AtomNode start="(317, 63)" end="(317, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(317, 65)" end="(317, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(317, 65)" end="(317, 69)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(317, 70)" end="(317, 71)">
                    <IdentNode start="(317, 70)" end="(317, 71)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(317, 71)" end="(317, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(317, 73)" end="(317, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(317, 73)" end="(317, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(317, 74)" end="(317, 75)">
                <IdentNode start="(317, 74)" end="(317, 75)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(317, 76)" end="(317, 93)">
                <AtomNode start="(317, 76)" end="(317, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(317, 78)" end="(317, 93)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(317, 78)" end="(317, 79)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(317, 80)" end="(317, 81)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(317, 82)" end="(317, 93)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(317, 82)" end="(317, 83)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(317, 84)" end="(317, 93)">
                      <OtherNode start="(317, 84)" end="(317, 93)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(317, 84)" end="(317, 85)" leading="" trailing="" val="("/>
                        <OtherNode start="(317, 85)" end="(317, 92)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(317, 85)" end="(317, 90)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(317, 91)" end="(317, 92)">
                            <IdentNode start="(317, 91)" end="(317, 92)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(317, 92)" end="(317, 93)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(317, 93)" end="(317, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(317, 95)" end="(318, 82)">
            <AtomNode start="(317, 95)" end="(317, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(318, 5)" end="(318, 82)" kind="«term_=_»">
              <OtherNode start="(318, 5)" end="(318, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(318, 5)" end="(318, 23)" leading="" trailing=" " raw_val="l.toArray.flatMapM" val="l.toArray.flatMapM"/>
                <NullNode start="(318, 24)" end="(318, 25)">
                  <IdentNode start="(318, 24)" end="(318, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(318, 26)" end="(318, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(318, 28)" end="(318, 82)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(318, 28)" end="(318, 35)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(318, 36)" end="(318, 39)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(318, 40)" end="(318, 82)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(318, 40)" end="(318, 50)" leading="" trailing=" " raw_val="l.flatMapM" val="l.flatMapM"/>
                  <NullNode start="(318, 51)" end="(318, 82)">
                    <OtherNode start="(318, 51)" end="(318, 82)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(318, 51)" end="(318, 52)" leading="" trailing="" val="("/>
                      <OtherNode start="(318, 52)" end="(318, 81)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(318, 52)" end="(318, 55)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(318, 56)" end="(318, 81)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(318, 56)" end="(318, 57)">
                            <IdentNode start="(318, 56)" end="(318, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(318, 58)" end="(318, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(318, 61)" end="(318, 81)" kind="«term_&amp;lt;$&amp;gt;_»">
                            <IdentNode start="(318, 61)" end="(318, 73)" leading="" trailing=" " raw_val="Array.toList" val="Array.toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <AtomNode start="(318, 74)" end="(318, 77)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                            <OtherNode start="(318, 78)" end="(318, 81)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(318, 78)" end="(318, 79)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(318, 80)" end="(318, 81)">
                                <IdentNode start="(318, 80)" end="(318, 81)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(318, 81)" end="(318, 82)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(318, 83)" end="(328, 15)">
          <AtomNode start="(318, 83)" end="(318, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(318, 86)" end="(328, 15)">
            <AtomNode start="(318, 86)" end="(318, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(319, 3)" end="(328, 15)">
              <TacticTacticseq1IndentedNode start="(319, 3)" end="(328, 15)">
                <NullNode start="(319, 3)" end="(328, 15)">
                  <OtherNode start="(319, 3)" end="(319, 71)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Array β)&#10;⊢ Array.flatMapM f l.toArray = toArray &amp;lt;$&amp;gt; flatMapM (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Array β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) #[] l = toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) l []" tactic="simp only [Array.flatMapM, bind_pure_comp, foldlM_toArray, flatMapM]">
                    <AtomNode start="(319, 3)" end="(319, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(319, 8)" end="(319, 12)">
                      <AtomNode start="(319, 8)" end="(319, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(319, 13)" end="(319, 71)">
                      <AtomNode start="(319, 13)" end="(319, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(319, 14)" end="(319, 70)">
                        <OtherNode start="(319, 14)" end="(319, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 14)" end="(319, 28)" leading="" trailing="" raw_val="Array.flatMapM" val="Array.flatMapM" full_name="Array.flatMapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 28)" end="(319, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(319, 30)" end="(319, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 30)" end="(319, 44)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 44)" end="(319, 45)" leading="" trailing=" " val=","/>
                        <OtherNode start="(319, 46)" end="(319, 60)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 46)" end="(319, 60)" leading="" trailing="" raw_val="foldlM_toArray" val="foldlM_toArray" full_name="List.foldlM_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 60)" end="(319, 61)" leading="" trailing=" " val=","/>
                        <OtherNode start="(319, 62)" end="(319, 70)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 62)" end="(319, 70)" leading="" trailing="" raw_val="flatMapM" val="flatMapM" full_name="List.flatMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(319, 70)" end="(319, 71)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(320, 3)" end="(320, 56)" kind="Lean.Parser.Tactic.Conv.conv" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Array β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) #[] l = toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) l []" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Array β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) [].reverse.flatten.toArray l =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) l []" tactic="conv =&amp;gt; lhs; arg 2; change [].reverse.flatten.toArray">
                    <AtomNode start="(320, 3)" end="(320, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(320, 8)" end="(320, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(320, 11)" end="(320, 56)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(320, 11)" end="(320, 56)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(320, 11)" end="(320, 56)">
                          <OtherNode start="(320, 11)" end="(320, 14)" kind="Lean.Parser.Tactic.Conv.lhs">
                            <AtomNode start="(320, 11)" end="(320, 14)" leading="" trailing="" val="lhs"/>
                          </OtherNode>
                          <AtomNode start="(320, 14)" end="(320, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(320, 16)" end="(320, 21)" kind="Lean.Parser.Tactic.Conv.arg">
                            <AtomNode start="(320, 16)" end="(320, 19)" leading="" trailing=" " val="arg"/>
                            <OtherNode start="(320, 20)" end="(320, 21)" kind="Lean.Parser.Tactic.Conv.argArg">
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(320, 20)" end="(320, 21)" kind="num">
                                <AtomNode start="(320, 20)" end="(320, 21)" leading="" trailing="" val="2"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(320, 21)" end="(320, 22)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(320, 23)" end="(320, 56)" kind="Lean.Parser.Tactic.Conv.change">
                            <AtomNode start="(320, 23)" end="(320, 29)" leading="" trailing=" " val="change"/>
                            <OtherNode start="(320, 30)" end="(320, 56)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(320, 30)" end="(320, 32)" kind="«term[_]»">
                                <AtomNode start="(320, 30)" end="(320, 31)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(320, 31)" end="(320, 32)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(320, 32)" end="(320, 33)" leading="" trailing="" val="."/>
                              <IdentNode start="(320, 33)" end="(320, 56)" leading="" trailing="&#10;  " raw_val="reverse.flatten.toArray" val="reverse.flatten.toArray"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(321, 3)" end="(321, 22)" kind="Lean.Parser.Tactic.generalize" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Array β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) [].reverse.flatten.toArray l =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) l []" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Array β)&#10;acc : List (List β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray l =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) l acc" tactic="generalize [] = acc">
                    <AtomNode start="(321, 3)" end="(321, 13)" leading="" trailing=" " val="generalize"/>
                    <NullNode start="(321, 14)" end="(321, 22)">
                      <OtherNode start="(321, 14)" end="(321, 22)" kind="Lean.Parser.Tactic.generalizeArg">
                        <NullNode/>
                        <OtherNode start="(321, 14)" end="(321, 16)" kind="«term[_]»">
                          <AtomNode start="(321, 14)" end="(321, 15)" leading="" trailing="" val="["/>
                          <NullNode/>
                          <AtomNode start="(321, 15)" end="(321, 16)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <AtomNode start="(321, 17)" end="(321, 18)" leading="" trailing=" " val="="/>
                        <IdentNode start="(321, 19)" end="(321, 22)" leading="" trailing="&#10;  " raw_val="acc" val="acc"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(322, 3)" end="(328, 15)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → m (Array β)&#10;acc : List (List β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray l =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) l acc" state_after="no goals" tactic="induction l generalizing acc with&#10;| nil =&amp;gt; simp only [foldlM_nil, flatMapM.loop, map_pure]&#10;| cons x xs ih =&amp;gt;&#10;  simp only [foldlM_cons, bind_map_left, flatMapM.loop, _root_.map_bind]&#10;  congr; funext xs&#10;  conv =&amp;gt; lhs; rw [Array.toArray_append, ← flatten_concat, ← reverse_cons]&#10;  exact ih _">
                    <AtomNode start="(322, 3)" end="(322, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(322, 13)" end="(322, 14)">
                      <OtherNode start="(322, 13)" end="(322, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(322, 13)" end="(322, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(322, 15)" end="(322, 31)">
                      <AtomNode start="(322, 15)" end="(322, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(322, 28)" end="(322, 31)">
                        <IdentNode start="(322, 28)" end="(322, 31)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(322, 32)" end="(328, 15)">
                      <OtherNode start="(322, 32)" end="(328, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(322, 32)" end="(322, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(323, 3)" end="(328, 15)">
                          <OtherNode start="(323, 3)" end="(323, 59)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(323, 3)" end="(323, 8)">
                              <OtherNode start="(323, 3)" end="(323, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(323, 3)" end="(323, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(323, 5)" end="(323, 8)">
                                  <NullNode/>
                                  <IdentNode start="(323, 5)" end="(323, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(323, 9)" end="(323, 59)">
                              <AtomNode start="(323, 9)" end="(323, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(323, 12)" end="(323, 59)">
                                <TacticTacticseq1IndentedNode start="(323, 12)" end="(323, 59)">
                                  <NullNode start="(323, 12)" end="(323, 59)">
                                    <OtherNode start="(323, 12)" end="(323, 59)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;acc : List (List β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray [] =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) [] acc" state_after="no goals" tactic="simp only [foldlM_nil, flatMapM.loop, map_pure]">
                                      <AtomNode start="(323, 12)" end="(323, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(323, 17)" end="(323, 21)">
                                        <AtomNode start="(323, 17)" end="(323, 21)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(323, 22)" end="(323, 59)">
                                        <AtomNode start="(323, 22)" end="(323, 23)" leading="" trailing="" val="["/>
                                        <NullNode start="(323, 23)" end="(323, 58)">
                                          <OtherNode start="(323, 23)" end="(323, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(323, 23)" end="(323, 33)" leading="" trailing="" raw_val="foldlM_nil" val="foldlM_nil" full_name="List.foldlM_nil" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(323, 33)" end="(323, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(323, 35)" end="(323, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(323, 35)" end="(323, 48)" leading="" trailing="" raw_val="flatMapM.loop" val="flatMapM.loop" full_name="List.flatMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(323, 48)" end="(323, 49)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(323, 50)" end="(323, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(323, 50)" end="(323, 58)" leading="" trailing="" raw_val="map_pure" val="map_pure" full_name="LawfulApplicative.map_pure" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(323, 58)" end="(323, 59)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(324, 3)" end="(328, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(324, 3)" end="(324, 17)">
                              <OtherNode start="(324, 3)" end="(324, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(324, 3)" end="(324, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(324, 5)" end="(324, 9)">
                                  <NullNode/>
                                  <IdentNode start="(324, 5)" end="(324, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(324, 10)" end="(324, 17)">
                                  <IdentNode start="(324, 10)" end="(324, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(324, 12)" end="(324, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(324, 15)" end="(324, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(324, 18)" end="(328, 15)">
                              <AtomNode start="(324, 18)" end="(324, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(325, 5)" end="(328, 15)">
                                <TacticTacticseq1IndentedNode start="(325, 5)" end="(328, 15)">
                                  <NullNode start="(325, 5)" end="(328, 15)">
                                    <OtherNode start="(325, 5)" end="(325, 75)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs acc&#10;acc : List (List β)&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray (x :: xs) =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) (x :: xs) acc" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs acc&#10;acc : List (List β)&#10;⊢ (do&#10;      let a ← f x&#10;      foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (acc.reverse.flatten.toArray ++ a) xs) =&#10;    do&#10;    let a ← f x&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs (a.toList :: acc)" tactic="simp only [foldlM_cons, bind_map_left, flatMapM.loop, _root_.map_bind]">
                                      <AtomNode start="(325, 5)" end="(325, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(325, 10)" end="(325, 14)">
                                        <AtomNode start="(325, 10)" end="(325, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(325, 15)" end="(325, 75)">
                                        <AtomNode start="(325, 15)" end="(325, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(325, 16)" end="(325, 74)">
                                          <OtherNode start="(325, 16)" end="(325, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 16)" end="(325, 27)" leading="" trailing="" raw_val="foldlM_cons" val="foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 27)" end="(325, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 29)" end="(325, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 29)" end="(325, 42)" leading="" trailing="" raw_val="bind_map_left" val="bind_map_left" full_name="bind_map_left" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 42)" end="(325, 43)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 44)" end="(325, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 44)" end="(325, 57)" leading="" trailing="" raw_val="flatMapM.loop" val="flatMapM.loop" full_name="List.flatMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 57)" end="(325, 58)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 59)" end="(325, 74)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 59)" end="(325, 74)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(325, 74)" end="(325, 75)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(326, 5)" end="(326, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs acc&#10;acc : List (List β)&#10;⊢ (do&#10;      let a ← f x&#10;      foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (acc.reverse.flatten.toArray ++ a) xs) =&#10;    do&#10;    let a ← f x&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs (a.toList :: acc)" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs acc&#10;acc : List (List β)&#10;⊢ (fun a =&amp;gt; foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (acc.reverse.flatten.toArray ++ a) xs) = fun a =&amp;gt;&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs (a.toList :: acc)" tactic="congr">
                                      <AtomNode start="(326, 5)" end="(326, 10)" leading="" trailing="" val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(326, 10)" end="(326, 11)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(326, 12)" end="(326, 21)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs acc&#10;acc : List (List β)&#10;⊢ (fun a =&amp;gt; foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (acc.reverse.flatten.toArray ++ a) xs) = fun a =&amp;gt;&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs (a.toList :: acc)" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs✝ : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs✝ =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ acc&#10;acc : List (List β)&#10;xs : Array β&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (acc.reverse.flatten.toArray ++ xs) xs✝ =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ (xs.toList :: acc)" tactic="funext xs">
                                      <AtomNode start="(326, 12)" end="(326, 18)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(326, 19)" end="(326, 21)">
                                        <IdentNode start="(326, 19)" end="(326, 21)" leading="" trailing="&#10;    " raw_val="xs" val="xs"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(327, 5)" end="(327, 77)" kind="Lean.Parser.Tactic.Conv.conv" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs✝ : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs✝ =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ acc&#10;acc : List (List β)&#10;xs : Array β&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (acc.reverse.flatten.toArray ++ xs) xs✝ =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ (xs.toList :: acc)" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs✝ : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs✝ =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ acc&#10;acc : List (List β)&#10;xs : Array β&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (xs.toList :: acc).reverse.flatten.toArray xs✝ =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ (xs.toList :: acc)" tactic="conv =&amp;gt; lhs; rw [Array.toArray_append, ← flatten_concat, ← reverse_cons]">
                                      <AtomNode start="(327, 5)" end="(327, 9)" leading="" trailing=" " val="conv"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <AtomNode start="(327, 10)" end="(327, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <OtherNode start="(327, 13)" end="(327, 77)" kind="Lean.Parser.Tactic.Conv.convSeq">
                                        <OtherNode start="(327, 13)" end="(327, 77)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                                          <NullNode start="(327, 13)" end="(327, 77)">
                                            <OtherNode start="(327, 13)" end="(327, 16)" kind="Lean.Parser.Tactic.Conv.lhs">
                                              <AtomNode start="(327, 13)" end="(327, 16)" leading="" trailing="" val="lhs"/>
                                            </OtherNode>
                                            <AtomNode start="(327, 16)" end="(327, 17)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(327, 18)" end="(327, 77)" kind="Lean.Parser.Tactic.Conv.convRw__">
                                              <AtomNode start="(327, 18)" end="(327, 20)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(327, 21)" end="(327, 77)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(327, 21)" end="(327, 22)" leading="" trailing="" val="["/>
                                                <NullNode start="(327, 22)" end="(327, 76)">
                                                  <OtherNode start="(327, 22)" end="(327, 42)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(327, 22)" end="(327, 42)" leading="" trailing="" raw_val="Array.toArray_append" val="Array.toArray_append" full_name="Array.toArray_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(327, 42)" end="(327, 43)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(327, 44)" end="(327, 60)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode start="(327, 44)" end="(327, 45)">
                                                      <OtherNode start="(327, 44)" end="(327, 45)" kind="patternIgnore">
                                                        <OtherNode start="(327, 44)" end="(327, 45)" kind="token.«← »">
                                                          <AtomNode start="(327, 44)" end="(327, 45)" leading="" trailing=" " val="←"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <IdentNode start="(327, 46)" end="(327, 60)" leading="" trailing="" raw_val="flatten_concat" val="flatten_concat" full_name="List.flatten_concat" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(327, 60)" end="(327, 61)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(327, 62)" end="(327, 76)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode start="(327, 62)" end="(327, 63)">
                                                      <OtherNode start="(327, 62)" end="(327, 63)" kind="patternIgnore">
                                                        <OtherNode start="(327, 62)" end="(327, 63)" kind="token.«← »">
                                                          <AtomNode start="(327, 62)" end="(327, 63)" leading="" trailing=" " val="←"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <IdentNode start="(327, 64)" end="(327, 76)" leading="" trailing="" raw_val="reverse_cons" val="reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(327, 76)" end="(327, 77)" leading="" trailing="&#10;    " val="]"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(328, 5)" end="(328, 15)" kind="Lean.Parser.Tactic.exact" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Array β)&#10;x : α&#10;xs✝ : List α&#10;ih :&#10;  ∀ (acc : List (List β)),&#10;    foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) acc.reverse.flatten.toArray xs✝ =&#10;      toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ acc&#10;acc : List (List β)&#10;xs : Array β&#10;⊢ foldlM (fun x y =&amp;gt; HAppend.hAppend x &amp;lt;$&amp;gt; f y) (xs.toList :: acc).reverse.flatten.toArray xs✝ =&#10;    toArray &amp;lt;$&amp;gt; flatMapM.loop (fun a =&amp;gt; Array.toList &amp;lt;$&amp;gt; f a) xs✝ (xs.toList :: acc)" state_after="no goals" tactic="exact ih _">
                                      <AtomNode start="(328, 5)" end="(328, 10)" leading="" trailing=" " val="exact"/>
                                      <OtherNode start="(328, 11)" end="(328, 15)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(328, 11)" end="(328, 13)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                        <NullNode start="(328, 14)" end="(328, 15)">
                                          <TermHoleNode start="(328, 14)" end="(328, 15)">
                                            <AtomNode start="(328, 14)" end="(328, 15)" leading="" trailing="&#10;&#10;" val="_"/>
                                          </TermHoleNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(330, 1)" end="(330, 9)" name="List">
      <AtomNode start="(330, 1)" end="(330, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(330, 5)" end="(330, 9)">
        <IdentNode start="(330, 5)" end="(330, 9)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
    <CommandNamespaceNode start="(332, 1)" end="(332, 16)" name="Array">
      <AtomNode start="(332, 1)" end="(332, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(332, 11)" end="(332, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(334, 1)" end="(338, 20)" name="filterM_congr" full_name="Array.filterM_congr">
      <CommandDeclmodifiersNode start="(334, 1)" end="(334, 9)">
        <NullNode/>
        <NullNode start="(334, 1)" end="(334, 9)">
          <OtherNode start="(334, 1)" end="(334, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(334, 1)" end="(334, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(334, 3)" end="(334, 8)">
              <OtherNode start="(334, 3)" end="(334, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(334, 3)" end="(334, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(334, 3)" end="(334, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(334, 8)" end="(334, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(334, 10)" end="(338, 20)" name="filterM_congr" full_name="Array.filterM_congr" _is_private_decl="False">
        <AtomNode start="(334, 10)" end="(334, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(334, 18)" end="(334, 31)">
          <IdentNode start="(334, 18)" end="(334, 31)" leading="" trailing=" " raw_val="filterM_congr" val="filterM_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(334, 32)" end="(336, 32)">
          <NullNode start="(334, 32)" end="(335, 59)">
            <OtherNode start="(334, 32)" end="(334, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(334, 32)" end="(334, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(334, 33)" end="(334, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(334, 33)" end="(334, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(334, 39)" end="(334, 40)">
                  <IdentNode start="(334, 39)" end="(334, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(334, 40)" end="(334, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(334, 42)" end="(334, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(334, 42)" end="(334, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(334, 43)" end="(334, 48)">
                <IdentNode start="(334, 43)" end="(334, 45)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(334, 46)" end="(334, 48)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(334, 49)" end="(334, 58)">
                <AtomNode start="(334, 49)" end="(334, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(334, 51)" end="(334, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(334, 51)" end="(334, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(334, 57)" end="(334, 58)">
                    <IdentNode start="(334, 57)" end="(334, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(334, 58)" end="(334, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(334, 60)" end="(334, 73)">
              <AtomNode start="(334, 60)" end="(334, 61)" leading="" trailing="" val="("/>
              <NullNode start="(334, 61)" end="(334, 62)">
                <IdentNode start="(334, 61)" end="(334, 62)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(334, 63)" end="(334, 72)">
                <AtomNode start="(334, 63)" end="(334, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(334, 65)" end="(334, 72)" kind="«term_=_»">
                  <IdentNode start="(334, 65)" end="(334, 67)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(334, 68)" end="(334, 69)" leading="" trailing=" " val="="/>
                  <IdentNode start="(334, 70)" end="(334, 72)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(334, 72)" end="(334, 73)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(335, 5)" end="(335, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(335, 5)" end="(335, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(335, 6)" end="(335, 7)">
                <IdentNode start="(335, 6)" end="(335, 7)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(335, 8)" end="(335, 20)">
                <AtomNode start="(335, 8)" end="(335, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(335, 10)" end="(335, 20)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(335, 10)" end="(335, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(335, 12)" end="(335, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(335, 14)" end="(335, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(335, 14)" end="(335, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(335, 16)" end="(335, 20)">
                      <IdentNode start="(335, 16)" end="(335, 20)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(335, 20)" end="(335, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(335, 22)" end="(335, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(335, 22)" end="(335, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(335, 23)" end="(335, 24)">
                <IdentNode start="(335, 23)" end="(335, 24)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(335, 25)" end="(335, 37)">
                <AtomNode start="(335, 25)" end="(335, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(335, 27)" end="(335, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(335, 27)" end="(335, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(335, 29)" end="(335, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(335, 31)" end="(335, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(335, 31)" end="(335, 32)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(335, 33)" end="(335, 37)">
                      <IdentNode start="(335, 33)" end="(335, 37)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(335, 37)" end="(335, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(335, 39)" end="(335, 59)">
              <AtomNode start="(335, 39)" end="(335, 40)" leading="" trailing="" val="("/>
              <NullNode start="(335, 40)" end="(335, 41)">
                <IdentNode start="(335, 40)" end="(335, 41)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(335, 42)" end="(335, 58)">
                <AtomNode start="(335, 42)" end="(335, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(335, 44)" end="(335, 58)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(335, 44)" end="(335, 45)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(335, 46)" end="(335, 47)">
                    <IdentNode start="(335, 46)" end="(335, 47)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(335, 47)" end="(335, 48)" leading="" trailing=" " val=","/>
                  <OtherNode start="(335, 49)" end="(335, 58)" kind="«term_=_»">
                    <OtherNode start="(335, 49)" end="(335, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(335, 49)" end="(335, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(335, 51)" end="(335, 52)">
                        <IdentNode start="(335, 51)" end="(335, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(335, 53)" end="(335, 54)" leading="" trailing=" " val="="/>
                    <OtherNode start="(335, 55)" end="(335, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(335, 55)" end="(335, 56)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(335, 57)" end="(335, 58)">
                        <IdentNode start="(335, 57)" end="(335, 58)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(335, 58)" end="(335, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(335, 60)" end="(336, 32)">
            <AtomNode start="(335, 60)" end="(335, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(336, 5)" end="(336, 32)" kind="«term_=_»">
              <OtherNode start="(336, 5)" end="(336, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(336, 5)" end="(336, 15)" leading="" trailing=" " raw_val="as.filterM" val="as.filterM"/>
                <NullNode start="(336, 16)" end="(336, 17)">
                  <IdentNode start="(336, 16)" end="(336, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(336, 18)" end="(336, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(336, 20)" end="(336, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(336, 20)" end="(336, 30)" leading="" trailing=" " raw_val="bs.filterM" val="bs.filterM"/>
                <NullNode start="(336, 31)" end="(336, 32)">
                  <IdentNode start="(336, 31)" end="(336, 32)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(336, 33)" end="(338, 20)">
          <AtomNode start="(336, 33)" end="(336, 35)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(336, 36)" end="(338, 20)">
            <AtomNode start="(336, 36)" end="(336, 38)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(337, 3)" end="(338, 20)">
              <TacticTacticseq1IndentedNode start="(337, 3)" end="(338, 20)">
                <NullNode start="(337, 3)" end="(338, 20)">
                  <OtherNode start="(337, 3)" end="(337, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝ : Monad m&#10;as bs : Array α&#10;w : as = bs&#10;p q : α → m Bool&#10;h : ∀ (a : α), p a = q a&#10;⊢ filterM p as = filterM q bs" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝ : Monad m&#10;as : Array α&#10;p q : α → m Bool&#10;h : ∀ (a : α), p a = q a&#10;⊢ filterM p as = filterM q as" tactic="subst w">
                    <AtomNode start="(337, 3)" end="(337, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(337, 9)" end="(337, 10)">
                      <IdentNode start="(337, 9)" end="(337, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(338, 3)" end="(338, 20)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝ : Monad m&#10;as : Array α&#10;p q : α → m Bool&#10;h : ∀ (a : α), p a = q a&#10;⊢ filterM p as = filterM q as" state_after="no goals" tactic="simp [filterM, h]">
                    <AtomNode start="(338, 3)" end="(338, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(338, 8)" end="(338, 20)">
                      <AtomNode start="(338, 8)" end="(338, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(338, 9)" end="(338, 19)">
                        <OtherNode start="(338, 9)" end="(338, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(338, 9)" end="(338, 16)" leading="" trailing="" raw_val="filterM" val="filterM" full_name="Array.filterM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(338, 16)" end="(338, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(338, 18)" end="(338, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(338, 18)" end="(338, 19)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(338, 19)" end="(338, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(340, 1)" end="(344, 23)" name="filterRevM_congr" full_name="Array.filterRevM_congr">
      <CommandDeclmodifiersNode start="(340, 1)" end="(340, 9)">
        <NullNode/>
        <NullNode start="(340, 1)" end="(340, 9)">
          <OtherNode start="(340, 1)" end="(340, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(340, 1)" end="(340, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(340, 3)" end="(340, 8)">
              <OtherNode start="(340, 3)" end="(340, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(340, 3)" end="(340, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(340, 3)" end="(340, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(340, 8)" end="(340, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(340, 10)" end="(344, 23)" name="filterRevM_congr" full_name="Array.filterRevM_congr" _is_private_decl="False">
        <AtomNode start="(340, 10)" end="(340, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(340, 18)" end="(340, 34)">
          <IdentNode start="(340, 18)" end="(340, 34)" leading="" trailing=" " raw_val="filterRevM_congr" val="filterRevM_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(340, 35)" end="(342, 38)">
          <NullNode start="(340, 35)" end="(341, 59)">
            <OtherNode start="(340, 35)" end="(340, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(340, 35)" end="(340, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(340, 36)" end="(340, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(340, 36)" end="(340, 41)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(340, 42)" end="(340, 43)">
                  <IdentNode start="(340, 42)" end="(340, 43)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(340, 43)" end="(340, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(340, 45)" end="(340, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(340, 45)" end="(340, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(340, 46)" end="(340, 51)">
                <IdentNode start="(340, 46)" end="(340, 48)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(340, 49)" end="(340, 51)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(340, 52)" end="(340, 61)">
                <AtomNode start="(340, 52)" end="(340, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(340, 54)" end="(340, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(340, 54)" end="(340, 59)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(340, 60)" end="(340, 61)">
                    <IdentNode start="(340, 60)" end="(340, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(340, 61)" end="(340, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(340, 63)" end="(340, 76)">
              <AtomNode start="(340, 63)" end="(340, 64)" leading="" trailing="" val="("/>
              <NullNode start="(340, 64)" end="(340, 65)">
                <IdentNode start="(340, 64)" end="(340, 65)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(340, 66)" end="(340, 75)">
                <AtomNode start="(340, 66)" end="(340, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(340, 68)" end="(340, 75)" kind="«term_=_»">
                  <IdentNode start="(340, 68)" end="(340, 70)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(340, 71)" end="(340, 72)" leading="" trailing=" " val="="/>
                  <IdentNode start="(340, 73)" end="(340, 75)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(340, 75)" end="(340, 76)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(341, 5)" end="(341, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(341, 5)" end="(341, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(341, 6)" end="(341, 7)">
                <IdentNode start="(341, 6)" end="(341, 7)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(341, 8)" end="(341, 20)">
                <AtomNode start="(341, 8)" end="(341, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(341, 10)" end="(341, 20)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(341, 10)" end="(341, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(341, 12)" end="(341, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(341, 14)" end="(341, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(341, 14)" end="(341, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(341, 16)" end="(341, 20)">
                      <IdentNode start="(341, 16)" end="(341, 20)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(341, 20)" end="(341, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(341, 22)" end="(341, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(341, 22)" end="(341, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(341, 23)" end="(341, 24)">
                <IdentNode start="(341, 23)" end="(341, 24)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(341, 25)" end="(341, 37)">
                <AtomNode start="(341, 25)" end="(341, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(341, 27)" end="(341, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(341, 27)" end="(341, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(341, 29)" end="(341, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(341, 31)" end="(341, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(341, 31)" end="(341, 32)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(341, 33)" end="(341, 37)">
                      <IdentNode start="(341, 33)" end="(341, 37)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(341, 37)" end="(341, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(341, 39)" end="(341, 59)">
              <AtomNode start="(341, 39)" end="(341, 40)" leading="" trailing="" val="("/>
              <NullNode start="(341, 40)" end="(341, 41)">
                <IdentNode start="(341, 40)" end="(341, 41)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(341, 42)" end="(341, 58)">
                <AtomNode start="(341, 42)" end="(341, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(341, 44)" end="(341, 58)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(341, 44)" end="(341, 45)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(341, 46)" end="(341, 47)">
                    <IdentNode start="(341, 46)" end="(341, 47)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(341, 47)" end="(341, 48)" leading="" trailing=" " val=","/>
                  <OtherNode start="(341, 49)" end="(341, 58)" kind="«term_=_»">
                    <OtherNode start="(341, 49)" end="(341, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(341, 49)" end="(341, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(341, 51)" end="(341, 52)">
                        <IdentNode start="(341, 51)" end="(341, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(341, 53)" end="(341, 54)" leading="" trailing=" " val="="/>
                    <OtherNode start="(341, 55)" end="(341, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(341, 55)" end="(341, 56)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(341, 57)" end="(341, 58)">
                        <IdentNode start="(341, 57)" end="(341, 58)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(341, 58)" end="(341, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(341, 60)" end="(342, 38)">
            <AtomNode start="(341, 60)" end="(341, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(342, 5)" end="(342, 38)" kind="«term_=_»">
              <OtherNode start="(342, 5)" end="(342, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(342, 5)" end="(342, 18)" leading="" trailing=" " raw_val="as.filterRevM" val="as.filterRevM"/>
                <NullNode start="(342, 19)" end="(342, 20)">
                  <IdentNode start="(342, 19)" end="(342, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(342, 21)" end="(342, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(342, 23)" end="(342, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(342, 23)" end="(342, 36)" leading="" trailing=" " raw_val="bs.filterRevM" val="bs.filterRevM"/>
                <NullNode start="(342, 37)" end="(342, 38)">
                  <IdentNode start="(342, 37)" end="(342, 38)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(342, 39)" end="(344, 23)">
          <AtomNode start="(342, 39)" end="(342, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(342, 42)" end="(344, 23)">
            <AtomNode start="(342, 42)" end="(342, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(343, 3)" end="(344, 23)">
              <TacticTacticseq1IndentedNode start="(343, 3)" end="(344, 23)">
                <NullNode start="(343, 3)" end="(344, 23)">
                  <OtherNode start="(343, 3)" end="(343, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝ : Monad m&#10;as bs : Array α&#10;w : as = bs&#10;p q : α → m Bool&#10;h : ∀ (a : α), p a = q a&#10;⊢ filterRevM p as = filterRevM q bs" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝ : Monad m&#10;as : Array α&#10;p q : α → m Bool&#10;h : ∀ (a : α), p a = q a&#10;⊢ filterRevM p as = filterRevM q as" tactic="subst w">
                    <AtomNode start="(343, 3)" end="(343, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(343, 9)" end="(343, 10)">
                      <IdentNode start="(343, 9)" end="(343, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(344, 3)" end="(344, 23)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝ : Monad m&#10;as : Array α&#10;p q : α → m Bool&#10;h : ∀ (a : α), p a = q a&#10;⊢ filterRevM p as = filterRevM q as" state_after="no goals" tactic="simp [filterRevM, h]">
                    <AtomNode start="(344, 3)" end="(344, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(344, 8)" end="(344, 23)">
                      <AtomNode start="(344, 8)" end="(344, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(344, 9)" end="(344, 22)">
                        <OtherNode start="(344, 9)" end="(344, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(344, 9)" end="(344, 19)" leading="" trailing="" raw_val="filterRevM" val="filterRevM" full_name="Array.filterRevM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(344, 19)" end="(344, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(344, 21)" end="(344, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(344, 21)" end="(344, 22)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(344, 22)" end="(344, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(346, 1)" end="(350, 23)" name="filterMapM_congr" full_name="Array.filterMapM_congr">
      <CommandDeclmodifiersNode start="(346, 1)" end="(346, 9)">
        <NullNode/>
        <NullNode start="(346, 1)" end="(346, 9)">
          <OtherNode start="(346, 1)" end="(346, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(346, 1)" end="(346, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(346, 3)" end="(346, 8)">
              <OtherNode start="(346, 3)" end="(346, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(346, 3)" end="(346, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(346, 3)" end="(346, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(346, 8)" end="(346, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(346, 10)" end="(350, 23)" name="filterMapM_congr" full_name="Array.filterMapM_congr" _is_private_decl="False">
        <AtomNode start="(346, 10)" end="(346, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(346, 18)" end="(346, 34)">
          <IdentNode start="(346, 18)" end="(346, 34)" leading="" trailing=" " raw_val="filterMapM_congr" val="filterMapM_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(346, 35)" end="(348, 38)">
          <NullNode start="(346, 35)" end="(347, 71)">
            <OtherNode start="(346, 35)" end="(346, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(346, 35)" end="(346, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(346, 36)" end="(346, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(346, 36)" end="(346, 41)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(346, 42)" end="(346, 43)">
                  <IdentNode start="(346, 42)" end="(346, 43)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(346, 43)" end="(346, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(346, 45)" end="(346, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(346, 45)" end="(346, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(346, 46)" end="(346, 51)">
                <IdentNode start="(346, 46)" end="(346, 48)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(346, 49)" end="(346, 51)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(346, 52)" end="(346, 61)">
                <AtomNode start="(346, 52)" end="(346, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(346, 54)" end="(346, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(346, 54)" end="(346, 59)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(346, 60)" end="(346, 61)">
                    <IdentNode start="(346, 60)" end="(346, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(346, 61)" end="(346, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(346, 63)" end="(346, 76)">
              <AtomNode start="(346, 63)" end="(346, 64)" leading="" trailing="" val="("/>
              <NullNode start="(346, 64)" end="(346, 65)">
                <IdentNode start="(346, 64)" end="(346, 65)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(346, 66)" end="(346, 75)">
                <AtomNode start="(346, 66)" end="(346, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(346, 68)" end="(346, 75)" kind="«term_=_»">
                  <IdentNode start="(346, 68)" end="(346, 70)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(346, 71)" end="(346, 72)" leading="" trailing=" " val="="/>
                  <IdentNode start="(346, 73)" end="(346, 75)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(346, 75)" end="(346, 76)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(347, 5)" end="(347, 27)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 5)" end="(347, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 6)" end="(347, 7)">
                <IdentNode start="(347, 6)" end="(347, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(347, 8)" end="(347, 26)">
                <AtomNode start="(347, 8)" end="(347, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 10)" end="(347, 26)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(347, 10)" end="(347, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(347, 12)" end="(347, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(347, 14)" end="(347, 26)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(347, 14)" end="(347, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(347, 16)" end="(347, 26)">
                      <OtherNode start="(347, 16)" end="(347, 26)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(347, 16)" end="(347, 17)" leading="" trailing="" val="("/>
                        <OtherNode start="(347, 17)" end="(347, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(347, 17)" end="(347, 23)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(347, 24)" end="(347, 25)">
                            <IdentNode start="(347, 24)" end="(347, 25)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(347, 25)" end="(347, 26)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 26)" end="(347, 27)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(347, 28)" end="(347, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 28)" end="(347, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 29)" end="(347, 30)">
                <IdentNode start="(347, 29)" end="(347, 30)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(347, 31)" end="(347, 49)">
                <AtomNode start="(347, 31)" end="(347, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 33)" end="(347, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(347, 33)" end="(347, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(347, 35)" end="(347, 36)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(347, 37)" end="(347, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(347, 37)" end="(347, 38)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(347, 39)" end="(347, 49)">
                      <OtherNode start="(347, 39)" end="(347, 49)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(347, 39)" end="(347, 40)" leading="" trailing="" val="("/>
                        <OtherNode start="(347, 40)" end="(347, 48)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(347, 40)" end="(347, 46)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(347, 47)" end="(347, 48)">
                            <IdentNode start="(347, 47)" end="(347, 48)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(347, 48)" end="(347, 49)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 49)" end="(347, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(347, 51)" end="(347, 71)">
              <AtomNode start="(347, 51)" end="(347, 52)" leading="" trailing="" val="("/>
              <NullNode start="(347, 52)" end="(347, 53)">
                <IdentNode start="(347, 52)" end="(347, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(347, 54)" end="(347, 70)">
                <AtomNode start="(347, 54)" end="(347, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 56)" end="(347, 70)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(347, 56)" end="(347, 57)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(347, 58)" end="(347, 59)">
                    <IdentNode start="(347, 58)" end="(347, 59)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(347, 59)" end="(347, 60)" leading="" trailing=" " val=","/>
                  <OtherNode start="(347, 61)" end="(347, 70)" kind="«term_=_»">
                    <OtherNode start="(347, 61)" end="(347, 64)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(347, 61)" end="(347, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(347, 63)" end="(347, 64)">
                        <IdentNode start="(347, 63)" end="(347, 64)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(347, 65)" end="(347, 66)" leading="" trailing=" " val="="/>
                    <OtherNode start="(347, 67)" end="(347, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(347, 67)" end="(347, 68)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(347, 69)" end="(347, 70)">
                        <IdentNode start="(347, 69)" end="(347, 70)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(347, 70)" end="(347, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(347, 72)" end="(348, 38)">
            <AtomNode start="(347, 72)" end="(347, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(348, 5)" end="(348, 38)" kind="«term_=_»">
              <OtherNode start="(348, 5)" end="(348, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 5)" end="(348, 18)" leading="" trailing=" " raw_val="as.filterMapM" val="as.filterMapM"/>
                <NullNode start="(348, 19)" end="(348, 20)">
                  <IdentNode start="(348, 19)" end="(348, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(348, 21)" end="(348, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(348, 23)" end="(348, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 23)" end="(348, 36)" leading="" trailing=" " raw_val="bs.filterMapM" val="bs.filterMapM"/>
                <NullNode start="(348, 37)" end="(348, 38)">
                  <IdentNode start="(348, 37)" end="(348, 38)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(348, 39)" end="(350, 23)">
          <AtomNode start="(348, 39)" end="(348, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(348, 42)" end="(350, 23)">
            <AtomNode start="(348, 42)" end="(348, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(349, 3)" end="(350, 23)">
              <TacticTacticseq1IndentedNode start="(349, 3)" end="(350, 23)">
                <NullNode start="(349, 3)" end="(350, 23)">
                  <OtherNode start="(349, 3)" end="(349, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : Array α&#10;w : as = bs&#10;f g : α → m (Option β)&#10;h : ∀ (a : α), f a = g a&#10;⊢ filterMapM f as = filterMapM g bs" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as : Array α&#10;f g : α → m (Option β)&#10;h : ∀ (a : α), f a = g a&#10;⊢ filterMapM f as = filterMapM g as" tactic="subst w">
                    <AtomNode start="(349, 3)" end="(349, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(349, 9)" end="(349, 10)">
                      <IdentNode start="(349, 9)" end="(349, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(350, 3)" end="(350, 23)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as : Array α&#10;f g : α → m (Option β)&#10;h : ∀ (a : α), f a = g a&#10;⊢ filterMapM f as = filterMapM g as" state_after="no goals" tactic="simp [filterMapM, h]">
                    <AtomNode start="(350, 3)" end="(350, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(350, 8)" end="(350, 23)">
                      <AtomNode start="(350, 8)" end="(350, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(350, 9)" end="(350, 22)">
                        <OtherNode start="(350, 9)" end="(350, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(350, 9)" end="(350, 19)" leading="" trailing="" raw_val="filterMapM" val="filterMapM" full_name="Array.filterMapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(350, 19)" end="(350, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(350, 21)" end="(350, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(350, 21)" end="(350, 22)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(350, 22)" end="(350, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(352, 1)" end="(356, 21)" name="flatMapM_congr" full_name="Array.flatMapM_congr">
      <CommandDeclmodifiersNode start="(352, 1)" end="(352, 9)">
        <NullNode/>
        <NullNode start="(352, 1)" end="(352, 9)">
          <OtherNode start="(352, 1)" end="(352, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(352, 1)" end="(352, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(352, 3)" end="(352, 8)">
              <OtherNode start="(352, 3)" end="(352, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(352, 3)" end="(352, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(352, 3)" end="(352, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(352, 8)" end="(352, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(352, 10)" end="(356, 21)" name="flatMapM_congr" full_name="Array.flatMapM_congr" _is_private_decl="False">
        <AtomNode start="(352, 10)" end="(352, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(352, 18)" end="(352, 32)">
          <IdentNode start="(352, 18)" end="(352, 32)" leading="" trailing=" " raw_val="flatMapM_congr" val="flatMapM_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(352, 33)" end="(354, 34)">
          <NullNode start="(352, 33)" end="(353, 69)">
            <OtherNode start="(352, 33)" end="(352, 42)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(352, 33)" end="(352, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(352, 34)" end="(352, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(352, 34)" end="(352, 39)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(352, 40)" end="(352, 41)">
                  <IdentNode start="(352, 40)" end="(352, 41)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(352, 41)" end="(352, 42)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(352, 43)" end="(352, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(352, 43)" end="(352, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(352, 44)" end="(352, 49)">
                <IdentNode start="(352, 44)" end="(352, 46)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(352, 47)" end="(352, 49)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(352, 50)" end="(352, 59)">
                <AtomNode start="(352, 50)" end="(352, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(352, 52)" end="(352, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(352, 52)" end="(352, 57)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(352, 58)" end="(352, 59)">
                    <IdentNode start="(352, 58)" end="(352, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(352, 59)" end="(352, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(352, 61)" end="(352, 74)">
              <AtomNode start="(352, 61)" end="(352, 62)" leading="" trailing="" val="("/>
              <NullNode start="(352, 62)" end="(352, 63)">
                <IdentNode start="(352, 62)" end="(352, 63)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(352, 64)" end="(352, 73)">
                <AtomNode start="(352, 64)" end="(352, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(352, 66)" end="(352, 73)" kind="«term_=_»">
                  <IdentNode start="(352, 66)" end="(352, 68)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(352, 69)" end="(352, 70)" leading="" trailing=" " val="="/>
                  <IdentNode start="(352, 71)" end="(352, 73)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(352, 73)" end="(352, 74)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(353, 5)" end="(353, 26)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(353, 5)" end="(353, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(353, 6)" end="(353, 7)">
                <IdentNode start="(353, 6)" end="(353, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(353, 8)" end="(353, 25)">
                <AtomNode start="(353, 8)" end="(353, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(353, 10)" end="(353, 25)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(353, 10)" end="(353, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(353, 12)" end="(353, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(353, 14)" end="(353, 25)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(353, 14)" end="(353, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(353, 16)" end="(353, 25)">
                      <OtherNode start="(353, 16)" end="(353, 25)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(353, 16)" end="(353, 17)" leading="" trailing="" val="("/>
                        <OtherNode start="(353, 17)" end="(353, 24)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(353, 17)" end="(353, 22)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(353, 23)" end="(353, 24)">
                            <IdentNode start="(353, 23)" end="(353, 24)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(353, 24)" end="(353, 25)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(353, 25)" end="(353, 26)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(353, 27)" end="(353, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(353, 27)" end="(353, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(353, 28)" end="(353, 29)">
                <IdentNode start="(353, 28)" end="(353, 29)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(353, 30)" end="(353, 47)">
                <AtomNode start="(353, 30)" end="(353, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(353, 32)" end="(353, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(353, 32)" end="(353, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(353, 34)" end="(353, 35)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(353, 36)" end="(353, 47)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(353, 36)" end="(353, 37)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(353, 38)" end="(353, 47)">
                      <OtherNode start="(353, 38)" end="(353, 47)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(353, 38)" end="(353, 39)" leading="" trailing="" val="("/>
                        <OtherNode start="(353, 39)" end="(353, 46)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(353, 39)" end="(353, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(353, 45)" end="(353, 46)">
                            <IdentNode start="(353, 45)" end="(353, 46)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(353, 46)" end="(353, 47)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(353, 47)" end="(353, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(353, 49)" end="(353, 69)">
              <AtomNode start="(353, 49)" end="(353, 50)" leading="" trailing="" val="("/>
              <NullNode start="(353, 50)" end="(353, 51)">
                <IdentNode start="(353, 50)" end="(353, 51)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(353, 52)" end="(353, 68)">
                <AtomNode start="(353, 52)" end="(353, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(353, 54)" end="(353, 68)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(353, 54)" end="(353, 55)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(353, 56)" end="(353, 57)">
                    <IdentNode start="(353, 56)" end="(353, 57)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(353, 57)" end="(353, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(353, 59)" end="(353, 68)" kind="«term_=_»">
                    <OtherNode start="(353, 59)" end="(353, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(353, 59)" end="(353, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(353, 61)" end="(353, 62)">
                        <IdentNode start="(353, 61)" end="(353, 62)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(353, 63)" end="(353, 64)" leading="" trailing=" " val="="/>
                    <OtherNode start="(353, 65)" end="(353, 68)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(353, 65)" end="(353, 66)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(353, 67)" end="(353, 68)">
                        <IdentNode start="(353, 67)" end="(353, 68)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(353, 68)" end="(353, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(353, 70)" end="(354, 34)">
            <AtomNode start="(353, 70)" end="(353, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(354, 5)" end="(354, 34)" kind="«term_=_»">
              <OtherNode start="(354, 5)" end="(354, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(354, 5)" end="(354, 16)" leading="" trailing=" " raw_val="as.flatMapM" val="as.flatMapM"/>
                <NullNode start="(354, 17)" end="(354, 18)">
                  <IdentNode start="(354, 17)" end="(354, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(354, 19)" end="(354, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(354, 21)" end="(354, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(354, 21)" end="(354, 32)" leading="" trailing=" " raw_val="bs.flatMapM" val="bs.flatMapM"/>
                <NullNode start="(354, 33)" end="(354, 34)">
                  <IdentNode start="(354, 33)" end="(354, 34)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(354, 35)" end="(356, 21)">
          <AtomNode start="(354, 35)" end="(354, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(354, 38)" end="(356, 21)">
            <AtomNode start="(354, 38)" end="(354, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(355, 3)" end="(356, 21)">
              <TacticTacticseq1IndentedNode start="(355, 3)" end="(356, 21)">
                <NullNode start="(355, 3)" end="(356, 21)">
                  <OtherNode start="(355, 3)" end="(355, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : Array α&#10;w : as = bs&#10;f g : α → m (Array β)&#10;h : ∀ (a : α), f a = g a&#10;⊢ flatMapM f as = flatMapM g bs" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as : Array α&#10;f g : α → m (Array β)&#10;h : ∀ (a : α), f a = g a&#10;⊢ flatMapM f as = flatMapM g as" tactic="subst w">
                    <AtomNode start="(355, 3)" end="(355, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(355, 9)" end="(355, 10)">
                      <IdentNode start="(355, 9)" end="(355, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(356, 3)" end="(356, 21)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as : Array α&#10;f g : α → m (Array β)&#10;h : ∀ (a : α), f a = g a&#10;⊢ flatMapM f as = flatMapM g as" state_after="no goals" tactic="simp [flatMapM, h]">
                    <AtomNode start="(356, 3)" end="(356, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(356, 8)" end="(356, 21)">
                      <AtomNode start="(356, 8)" end="(356, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(356, 9)" end="(356, 20)">
                        <OtherNode start="(356, 9)" end="(356, 17)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(356, 9)" end="(356, 17)" leading="" trailing="" raw_val="flatMapM" val="flatMapM" full_name="Array.flatMapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(356, 17)" end="(356, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(356, 19)" end="(356, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(356, 19)" end="(356, 20)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(356, 20)" end="(356, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(358, 1)" end="(361, 39)" name="toList_filterM" full_name="Array.toList_filterM">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(358, 1)" end="(361, 39)" name="toList_filterM" full_name="Array.toList_filterM" _is_private_decl="False">
        <AtomNode start="(358, 1)" end="(358, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(358, 9)" end="(358, 23)">
          <IdentNode start="(358, 9)" end="(358, 23)" leading="" trailing=" " raw_val="toList_filterM" val="toList_filterM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(358, 24)" end="(359, 50)">
          <NullNode start="(358, 24)" end="(358, 81)">
            <OtherNode start="(358, 24)" end="(358, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(358, 24)" end="(358, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(358, 25)" end="(358, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(358, 25)" end="(358, 30)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(358, 31)" end="(358, 32)">
                  <IdentNode start="(358, 31)" end="(358, 32)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(358, 32)" end="(358, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(358, 34)" end="(358, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(358, 34)" end="(358, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(358, 35)" end="(358, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(358, 35)" end="(358, 46)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(358, 47)" end="(358, 48)">
                  <IdentNode start="(358, 47)" end="(358, 48)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(358, 48)" end="(358, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(358, 50)" end="(358, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(358, 50)" end="(358, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(358, 51)" end="(358, 53)">
                <IdentNode start="(358, 51)" end="(358, 53)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(358, 54)" end="(358, 63)">
                <AtomNode start="(358, 54)" end="(358, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(358, 56)" end="(358, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(358, 56)" end="(358, 61)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(358, 62)" end="(358, 63)">
                    <IdentNode start="(358, 62)" end="(358, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(358, 63)" end="(358, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(358, 65)" end="(358, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(358, 65)" end="(358, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(358, 66)" end="(358, 67)">
                <IdentNode start="(358, 66)" end="(358, 67)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(358, 68)" end="(358, 80)">
                <AtomNode start="(358, 68)" end="(358, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(358, 70)" end="(358, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(358, 70)" end="(358, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(358, 72)" end="(358, 73)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(358, 74)" end="(358, 80)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(358, 74)" end="(358, 75)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(358, 76)" end="(358, 80)">
                      <IdentNode start="(358, 76)" end="(358, 80)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(358, 80)" end="(358, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(358, 82)" end="(359, 50)">
            <AtomNode start="(358, 82)" end="(358, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(359, 5)" end="(359, 50)" kind="«term_=_»">
              <OtherNode start="(359, 5)" end="(359, 28)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(359, 5)" end="(359, 11)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(359, 12)" end="(359, 15)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(359, 16)" end="(359, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(359, 16)" end="(359, 26)" leading="" trailing=" " raw_val="xs.filterM" val="xs.filterM"/>
                  <NullNode start="(359, 27)" end="(359, 28)">
                    <IdentNode start="(359, 27)" end="(359, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(359, 29)" end="(359, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(359, 31)" end="(359, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(359, 31)" end="(359, 48)" leading="" trailing=" " raw_val="xs.toList.filterM" val="xs.toList.filterM"/>
                <NullNode start="(359, 49)" end="(359, 50)">
                  <IdentNode start="(359, 49)" end="(359, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(359, 51)" end="(361, 39)">
          <AtomNode start="(359, 51)" end="(359, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(359, 54)" end="(361, 39)">
            <AtomNode start="(359, 54)" end="(359, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(360, 3)" end="(361, 39)">
              <TacticTacticseq1IndentedNode start="(360, 3)" end="(361, 39)">
                <NullNode start="(360, 3)" end="(361, 39)">
                  <OtherNode start="(360, 3)" end="(360, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;p : α → m Bool&#10;⊢ toList &amp;lt;$&amp;gt; filterM p xs = List.filterM p xs.toList" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;p : α → m Bool&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.filterM p xs.toList = List.filterM p xs.toList" tactic="rw [List.filterM_toArray]">
                    <AtomNode start="(360, 3)" end="(360, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(360, 6)" end="(360, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(360, 6)" end="(360, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(360, 7)" end="(360, 27)">
                        <OtherNode start="(360, 7)" end="(360, 27)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(360, 7)" end="(360, 27)" leading="" trailing="" raw_val="List.filterM_toArray" val="List.filterM_toArray" full_name="List.filterM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(267, 9)" def_end="(267, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(360, 27)" end="(360, 28)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(361, 3)" end="(361, 39)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;p : α → m Bool&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.filterM p xs.toList = List.filterM p xs.toList" state_after="no goals" tactic="simp only [Functor.map_map, id_map']">
                    <AtomNode start="(361, 3)" end="(361, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(361, 8)" end="(361, 12)">
                      <AtomNode start="(361, 8)" end="(361, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(361, 13)" end="(361, 39)">
                      <AtomNode start="(361, 13)" end="(361, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(361, 14)" end="(361, 38)">
                        <OtherNode start="(361, 14)" end="(361, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(361, 14)" end="(361, 29)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(361, 29)" end="(361, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(361, 31)" end="(361, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(361, 31)" end="(361, 38)" leading="" trailing="" raw_val="id_map'" val="id_map'" full_name="id_map'" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(361, 38)" end="(361, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(363, 1)" end="(366, 39)" name="toList_filterRevM" full_name="Array.toList_filterRevM">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(363, 1)" end="(366, 39)" name="toList_filterRevM" full_name="Array.toList_filterRevM" _is_private_decl="False">
        <AtomNode start="(363, 1)" end="(363, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(363, 9)" end="(363, 26)">
          <IdentNode start="(363, 9)" end="(363, 26)" leading="" trailing=" " raw_val="toList_filterRevM" val="toList_filterRevM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(363, 27)" end="(364, 56)">
          <NullNode start="(363, 27)" end="(363, 84)">
            <OtherNode start="(363, 27)" end="(363, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(363, 27)" end="(363, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(363, 28)" end="(363, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(363, 28)" end="(363, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(363, 34)" end="(363, 35)">
                  <IdentNode start="(363, 34)" end="(363, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(363, 35)" end="(363, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(363, 37)" end="(363, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(363, 37)" end="(363, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(363, 38)" end="(363, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(363, 38)" end="(363, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(363, 50)" end="(363, 51)">
                  <IdentNode start="(363, 50)" end="(363, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(363, 51)" end="(363, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(363, 53)" end="(363, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 53)" end="(363, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 54)" end="(363, 56)">
                <IdentNode start="(363, 54)" end="(363, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(363, 57)" end="(363, 66)">
                <AtomNode start="(363, 57)" end="(363, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(363, 59)" end="(363, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(363, 59)" end="(363, 64)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(363, 65)" end="(363, 66)">
                    <IdentNode start="(363, 65)" end="(363, 66)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(363, 66)" end="(363, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(363, 68)" end="(363, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 68)" end="(363, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 69)" end="(363, 70)">
                <IdentNode start="(363, 69)" end="(363, 70)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(363, 71)" end="(363, 83)">
                <AtomNode start="(363, 71)" end="(363, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(363, 73)" end="(363, 83)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(363, 73)" end="(363, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(363, 75)" end="(363, 76)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(363, 77)" end="(363, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(363, 77)" end="(363, 78)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(363, 79)" end="(363, 83)">
                      <IdentNode start="(363, 79)" end="(363, 83)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(363, 83)" end="(363, 84)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(363, 85)" end="(364, 56)">
            <AtomNode start="(363, 85)" end="(363, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(364, 5)" end="(364, 56)" kind="«term_=_»">
              <OtherNode start="(364, 5)" end="(364, 31)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(364, 5)" end="(364, 11)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(364, 12)" end="(364, 15)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(364, 16)" end="(364, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(364, 16)" end="(364, 29)" leading="" trailing=" " raw_val="xs.filterRevM" val="xs.filterRevM"/>
                  <NullNode start="(364, 30)" end="(364, 31)">
                    <IdentNode start="(364, 30)" end="(364, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(364, 32)" end="(364, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(364, 34)" end="(364, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(364, 34)" end="(364, 54)" leading="" trailing=" " raw_val="xs.toList.filterRevM" val="xs.toList.filterRevM"/>
                <NullNode start="(364, 55)" end="(364, 56)">
                  <IdentNode start="(364, 55)" end="(364, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(364, 57)" end="(366, 39)">
          <AtomNode start="(364, 57)" end="(364, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(364, 60)" end="(366, 39)">
            <AtomNode start="(364, 60)" end="(364, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(365, 3)" end="(366, 39)">
              <TacticTacticseq1IndentedNode start="(365, 3)" end="(366, 39)">
                <NullNode start="(365, 3)" end="(366, 39)">
                  <OtherNode start="(365, 3)" end="(365, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;p : α → m Bool&#10;⊢ toList &amp;lt;$&amp;gt; filterRevM p xs = List.filterRevM p xs.toList" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;p : α → m Bool&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.filterRevM p xs.toList = List.filterRevM p xs.toList" tactic="rw [List.filterRevM_toArray]">
                    <AtomNode start="(365, 3)" end="(365, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(365, 6)" end="(365, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(365, 6)" end="(365, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(365, 7)" end="(365, 30)">
                        <OtherNode start="(365, 7)" end="(365, 30)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(365, 7)" end="(365, 30)" leading="" trailing="" raw_val="List.filterRevM_toArray" val="List.filterRevM_toArray" full_name="List.filterRevM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(287, 9)" def_end="(287, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(365, 30)" end="(365, 31)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(366, 3)" end="(366, 39)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;p : α → m Bool&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.filterRevM p xs.toList = List.filterRevM p xs.toList" state_after="no goals" tactic="simp only [Functor.map_map, id_map']">
                    <AtomNode start="(366, 3)" end="(366, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(366, 8)" end="(366, 12)">
                      <AtomNode start="(366, 8)" end="(366, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(366, 13)" end="(366, 39)">
                      <AtomNode start="(366, 13)" end="(366, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(366, 14)" end="(366, 38)">
                        <OtherNode start="(366, 14)" end="(366, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(366, 14)" end="(366, 29)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(366, 29)" end="(366, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(366, 31)" end="(366, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(366, 31)" end="(366, 38)" leading="" trailing="" raw_val="id_map'" val="id_map'" full_name="id_map'" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(366, 38)" end="(366, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(368, 1)" end="(371, 39)" name="toList_filterMapM" full_name="Array.toList_filterMapM">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(368, 1)" end="(371, 39)" name="toList_filterMapM" full_name="Array.toList_filterMapM" _is_private_decl="False">
        <AtomNode start="(368, 1)" end="(368, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(368, 9)" end="(368, 26)">
          <IdentNode start="(368, 9)" end="(368, 26)" leading="" trailing=" " raw_val="toList_filterMapM" val="toList_filterMapM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(368, 27)" end="(369, 56)">
          <NullNode start="(368, 27)" end="(368, 90)">
            <OtherNode start="(368, 27)" end="(368, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(368, 27)" end="(368, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(368, 28)" end="(368, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(368, 28)" end="(368, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(368, 34)" end="(368, 35)">
                  <IdentNode start="(368, 34)" end="(368, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(368, 35)" end="(368, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(368, 37)" end="(368, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(368, 37)" end="(368, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(368, 38)" end="(368, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(368, 38)" end="(368, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(368, 50)" end="(368, 51)">
                  <IdentNode start="(368, 50)" end="(368, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(368, 51)" end="(368, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(368, 53)" end="(368, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(368, 53)" end="(368, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(368, 54)" end="(368, 56)">
                <IdentNode start="(368, 54)" end="(368, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(368, 57)" end="(368, 66)">
                <AtomNode start="(368, 57)" end="(368, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(368, 59)" end="(368, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(368, 59)" end="(368, 64)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(368, 65)" end="(368, 66)">
                    <IdentNode start="(368, 65)" end="(368, 66)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(368, 66)" end="(368, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(368, 68)" end="(368, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(368, 68)" end="(368, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(368, 69)" end="(368, 70)">
                <IdentNode start="(368, 69)" end="(368, 70)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(368, 71)" end="(368, 89)">
                <AtomNode start="(368, 71)" end="(368, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(368, 73)" end="(368, 89)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(368, 73)" end="(368, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(368, 75)" end="(368, 76)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(368, 77)" end="(368, 89)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(368, 77)" end="(368, 78)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(368, 79)" end="(368, 89)">
                      <OtherNode start="(368, 79)" end="(368, 89)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(368, 79)" end="(368, 80)" leading="" trailing="" val="("/>
                        <OtherNode start="(368, 80)" end="(368, 88)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(368, 80)" end="(368, 86)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(368, 87)" end="(368, 88)">
                            <IdentNode start="(368, 87)" end="(368, 88)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(368, 88)" end="(368, 89)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(368, 89)" end="(368, 90)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(368, 91)" end="(369, 56)">
            <AtomNode start="(368, 91)" end="(368, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(369, 5)" end="(369, 56)" kind="«term_=_»">
              <OtherNode start="(369, 5)" end="(369, 31)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(369, 5)" end="(369, 11)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(369, 12)" end="(369, 15)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(369, 16)" end="(369, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(369, 16)" end="(369, 29)" leading="" trailing=" " raw_val="xs.filterMapM" val="xs.filterMapM"/>
                  <NullNode start="(369, 30)" end="(369, 31)">
                    <IdentNode start="(369, 30)" end="(369, 31)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(369, 32)" end="(369, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(369, 34)" end="(369, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(369, 34)" end="(369, 54)" leading="" trailing=" " raw_val="xs.toList.filterMapM" val="xs.toList.filterMapM"/>
                <NullNode start="(369, 55)" end="(369, 56)">
                  <IdentNode start="(369, 55)" end="(369, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(369, 57)" end="(371, 39)">
          <AtomNode start="(369, 57)" end="(369, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(369, 60)" end="(371, 39)">
            <AtomNode start="(369, 60)" end="(369, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(370, 3)" end="(371, 39)">
              <TacticTacticseq1IndentedNode start="(370, 3)" end="(371, 39)">
                <NullNode start="(370, 3)" end="(371, 39)">
                  <OtherNode start="(370, 3)" end="(370, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Option β)&#10;⊢ toList &amp;lt;$&amp;gt; filterMapM f xs = List.filterMapM f xs.toList" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Option β)&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.filterMapM f xs.toList = List.filterMapM f xs.toList" tactic="rw [List.filterMapM_toArray]">
                    <AtomNode start="(370, 3)" end="(370, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(370, 6)" end="(370, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(370, 6)" end="(370, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(370, 7)" end="(370, 30)">
                        <OtherNode start="(370, 7)" end="(370, 30)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(370, 7)" end="(370, 30)" leading="" trailing="" raw_val="List.filterMapM_toArray" val="List.filterMapM_toArray" full_name="List.filterMapM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(299, 9)" def_end="(299, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(370, 30)" end="(370, 31)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(371, 3)" end="(371, 39)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Option β)&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.filterMapM f xs.toList = List.filterMapM f xs.toList" state_after="no goals" tactic="simp only [Functor.map_map, id_map']">
                    <AtomNode start="(371, 3)" end="(371, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(371, 8)" end="(371, 12)">
                      <AtomNode start="(371, 8)" end="(371, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(371, 13)" end="(371, 39)">
                      <AtomNode start="(371, 13)" end="(371, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(371, 14)" end="(371, 38)">
                        <OtherNode start="(371, 14)" end="(371, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(371, 14)" end="(371, 29)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(371, 29)" end="(371, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(371, 31)" end="(371, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(371, 31)" end="(371, 38)" leading="" trailing="" raw_val="id_map'" val="id_map'" full_name="id_map'" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(371, 38)" end="(371, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(373, 1)" end="(376, 39)" name="toList_flatMapM" full_name="Array.toList_flatMapM">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(373, 1)" end="(376, 39)" name="toList_flatMapM" full_name="Array.toList_flatMapM" _is_private_decl="False">
        <AtomNode start="(373, 1)" end="(373, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(373, 9)" end="(373, 24)">
          <IdentNode start="(373, 9)" end="(373, 24)" leading="" trailing=" " raw_val="toList_flatMapM" val="toList_flatMapM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(373, 25)" end="(374, 76)">
          <NullNode start="(373, 25)" end="(373, 87)">
            <OtherNode start="(373, 25)" end="(373, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(373, 25)" end="(373, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(373, 26)" end="(373, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(373, 26)" end="(373, 31)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(373, 32)" end="(373, 33)">
                  <IdentNode start="(373, 32)" end="(373, 33)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(373, 33)" end="(373, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(373, 35)" end="(373, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(373, 35)" end="(373, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(373, 36)" end="(373, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(373, 36)" end="(373, 47)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(373, 48)" end="(373, 49)">
                  <IdentNode start="(373, 48)" end="(373, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(373, 49)" end="(373, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(373, 51)" end="(373, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(373, 51)" end="(373, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(373, 52)" end="(373, 54)">
                <IdentNode start="(373, 52)" end="(373, 54)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(373, 55)" end="(373, 64)">
                <AtomNode start="(373, 55)" end="(373, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(373, 57)" end="(373, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(373, 57)" end="(373, 62)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(373, 63)" end="(373, 64)">
                    <IdentNode start="(373, 63)" end="(373, 64)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(373, 64)" end="(373, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(373, 66)" end="(373, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(373, 66)" end="(373, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(373, 67)" end="(373, 68)">
                <IdentNode start="(373, 67)" end="(373, 68)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(373, 69)" end="(373, 86)">
                <AtomNode start="(373, 69)" end="(373, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(373, 71)" end="(373, 86)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(373, 71)" end="(373, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(373, 73)" end="(373, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(373, 75)" end="(373, 86)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(373, 75)" end="(373, 76)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(373, 77)" end="(373, 86)">
                      <OtherNode start="(373, 77)" end="(373, 86)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(373, 77)" end="(373, 78)" leading="" trailing="" val="("/>
                        <OtherNode start="(373, 78)" end="(373, 85)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(373, 78)" end="(373, 83)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(373, 84)" end="(373, 85)">
                            <IdentNode start="(373, 84)" end="(373, 85)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(373, 85)" end="(373, 86)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(373, 86)" end="(373, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(373, 88)" end="(374, 76)">
            <AtomNode start="(373, 88)" end="(373, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(374, 5)" end="(374, 76)" kind="«term_=_»">
              <OtherNode start="(374, 5)" end="(374, 29)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(374, 5)" end="(374, 11)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(374, 12)" end="(374, 15)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(374, 16)" end="(374, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(374, 16)" end="(374, 27)" leading="" trailing=" " raw_val="xs.flatMapM" val="xs.flatMapM"/>
                  <NullNode start="(374, 28)" end="(374, 29)">
                    <IdentNode start="(374, 28)" end="(374, 29)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(374, 30)" end="(374, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(374, 32)" end="(374, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(374, 32)" end="(374, 50)" leading="" trailing=" " raw_val="xs.toList.flatMapM" val="xs.toList.flatMapM"/>
                <NullNode start="(374, 51)" end="(374, 76)">
                  <OtherNode start="(374, 51)" end="(374, 76)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(374, 51)" end="(374, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(374, 52)" end="(374, 75)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(374, 52)" end="(374, 55)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(374, 56)" end="(374, 75)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(374, 56)" end="(374, 57)">
                          <IdentNode start="(374, 56)" end="(374, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(374, 58)" end="(374, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(374, 61)" end="(374, 75)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <IdentNode start="(374, 61)" end="(374, 67)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <AtomNode start="(374, 68)" end="(374, 71)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(374, 72)" end="(374, 75)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(374, 72)" end="(374, 73)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(374, 74)" end="(374, 75)">
                              <IdentNode start="(374, 74)" end="(374, 75)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(374, 75)" end="(374, 76)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(374, 77)" end="(376, 39)">
          <AtomNode start="(374, 77)" end="(374, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(374, 80)" end="(376, 39)">
            <AtomNode start="(374, 80)" end="(374, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(375, 3)" end="(376, 39)">
              <TacticTacticseq1IndentedNode start="(375, 3)" end="(376, 39)">
                <NullNode start="(375, 3)" end="(376, 39)">
                  <OtherNode start="(375, 3)" end="(375, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Array β)&#10;⊢ toList &amp;lt;$&amp;gt; flatMapM f xs = List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; f a) xs.toList" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Array β)&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; f a) xs.toList =&#10;    List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; f a) xs.toList" tactic="rw [List.flatMapM_toArray]">
                    <AtomNode start="(375, 3)" end="(375, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(375, 6)" end="(375, 29)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(375, 6)" end="(375, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(375, 7)" end="(375, 28)">
                        <OtherNode start="(375, 7)" end="(375, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(375, 7)" end="(375, 28)" leading="" trailing="" raw_val="List.flatMapM_toArray" val="List.flatMapM_toArray" full_name="List.flatMapM_toArray" mod_name="Init.Data.Array.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Monadic.lean" def_start="(317, 17)" def_end="(317, 33)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(375, 28)" end="(375, 29)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(376, 3)" end="(376, 39)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Array β)&#10;⊢ toList &amp;lt;$&amp;gt; List.toArray &amp;lt;$&amp;gt; List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; f a) xs.toList =&#10;    List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; f a) xs.toList" state_after="no goals" tactic="simp only [Functor.map_map, id_map']">
                    <AtomNode start="(376, 3)" end="(376, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(376, 8)" end="(376, 12)">
                      <AtomNode start="(376, 8)" end="(376, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(376, 13)" end="(376, 39)">
                      <AtomNode start="(376, 13)" end="(376, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(376, 14)" end="(376, 38)">
                        <OtherNode start="(376, 14)" end="(376, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(376, 14)" end="(376, 29)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(376, 29)" end="(376, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(376, 31)" end="(376, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(376, 31)" end="(376, 38)" leading="" trailing="" raw_val="id_map'" val="id_map'" full_name="id_map'" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(376, 38)" end="(376, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(378, 1)" end="(378, 95)" comment="### Recognizing higher order functions using a function that only depends on the value. -/">
      <AtomNode start="(378, 1)" end="(378, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(378, 5)" end="(378, 95)" leading="" trailing="&#10;&#10;" val="### Recognizing higher order functions using a function that only depends on the value. -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(380, 1)" end="(391, 30)" name="foldlM_subtype" full_name="Array.foldlM_subtype">
      <CommandDeclmodifiersNode start="(380, 1)" end="(384, 8)">
        <NullNode start="(380, 1)" end="(383, 3)">
          <CommandDoccommentNode start="(380, 1)" end="(383, 3)" comment="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/">
            <AtomNode start="(380, 1)" end="(380, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(381, 1)" end="(383, 3)" leading="" trailing="&#10;" val="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(384, 1)" end="(384, 8)">
          <OtherNode start="(384, 1)" end="(384, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(384, 1)" end="(384, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(384, 3)" end="(384, 7)">
              <OtherNode start="(384, 3)" end="(384, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(384, 3)" end="(384, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(384, 3)" end="(384, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(384, 7)" end="(384, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(384, 9)" end="(391, 30)" name="foldlM_subtype" full_name="Array.foldlM_subtype" _is_private_decl="False">
        <AtomNode start="(384, 9)" end="(384, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(384, 17)" end="(384, 31)">
          <IdentNode start="(384, 17)" end="(384, 31)" leading="" trailing=" " raw_val="foldlM_subtype" val="foldlM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(384, 32)" end="(387, 57)">
          <NullNode start="(384, 32)" end="(386, 60)">
            <OtherNode start="(384, 32)" end="(384, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(384, 32)" end="(384, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(384, 33)" end="(384, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(384, 33)" end="(384, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(384, 39)" end="(384, 40)">
                  <IdentNode start="(384, 39)" end="(384, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(384, 40)" end="(384, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(384, 42)" end="(384, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 42)" end="(384, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 43)" end="(384, 44)">
                <IdentNode start="(384, 43)" end="(384, 44)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(384, 45)" end="(384, 55)">
                <AtomNode start="(384, 45)" end="(384, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(384, 47)" end="(384, 55)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(384, 47)" end="(384, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(384, 49)" end="(384, 50)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(384, 51)" end="(384, 55)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(384, 51)" end="(384, 55)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(384, 55)" end="(384, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(384, 57)" end="(384, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(384, 57)" end="(384, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(384, 58)" end="(384, 60)">
                <IdentNode start="(384, 58)" end="(384, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(384, 61)" end="(384, 81)">
                <AtomNode start="(384, 61)" end="(384, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(384, 63)" end="(384, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(384, 63)" end="(384, 68)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(384, 69)" end="(384, 81)">
                    <OtherNode start="(384, 69)" end="(384, 81)" kind="«term{_:_//_}»">
                      <AtomNode start="(384, 69)" end="(384, 70)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(384, 71)" end="(384, 72)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(384, 73)" end="(384, 75)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(384, 76)" end="(384, 79)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(384, 76)" end="(384, 77)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(384, 78)" end="(384, 79)">
                          <IdentNode start="(384, 78)" end="(384, 79)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(384, 80)" end="(384, 81)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(384, 81)" end="(384, 82)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(385, 5)" end="(385, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 5)" end="(385, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 6)" end="(385, 7)">
                <IdentNode start="(385, 6)" end="(385, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(385, 8)" end="(385, 32)">
                <AtomNode start="(385, 8)" end="(385, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 10)" end="(385, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(385, 10)" end="(385, 11)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(385, 12)" end="(385, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(385, 14)" end="(385, 32)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(385, 14)" end="(385, 26)" kind="«term{_:_//_}»">
                      <AtomNode start="(385, 14)" end="(385, 15)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(385, 16)" end="(385, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(385, 18)" end="(385, 20)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(385, 21)" end="(385, 24)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(385, 21)" end="(385, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(385, 23)" end="(385, 24)">
                          <IdentNode start="(385, 23)" end="(385, 24)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(385, 25)" end="(385, 26)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <AtomNode start="(385, 27)" end="(385, 28)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(385, 29)" end="(385, 32)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(385, 29)" end="(385, 30)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(385, 31)" end="(385, 32)">
                        <IdentNode start="(385, 31)" end="(385, 32)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(385, 32)" end="(385, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(385, 34)" end="(385, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 34)" end="(385, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 35)" end="(385, 36)">
                <IdentNode start="(385, 35)" end="(385, 36)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(385, 37)" end="(385, 50)">
                <AtomNode start="(385, 37)" end="(385, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 39)" end="(385, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(385, 39)" end="(385, 40)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(385, 41)" end="(385, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(385, 43)" end="(385, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(385, 43)" end="(385, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(385, 45)" end="(385, 46)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(385, 47)" end="(385, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(385, 47)" end="(385, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(385, 49)" end="(385, 50)">
                        <IdentNode start="(385, 49)" end="(385, 50)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(385, 50)" end="(385, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(385, 52)" end="(385, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 52)" end="(385, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 53)" end="(385, 54)">
                <IdentNode start="(385, 53)" end="(385, 54)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(385, 55)" end="(385, 58)">
                <AtomNode start="(385, 55)" end="(385, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(385, 57)" end="(385, 58)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(385, 58)" end="(385, 59)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(386, 5)" end="(386, 39)">
              <AtomNode start="(386, 5)" end="(386, 6)" leading="" trailing="" val="("/>
              <NullNode start="(386, 6)" end="(386, 8)">
                <IdentNode start="(386, 6)" end="(386, 8)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(386, 9)" end="(386, 38)">
                <AtomNode start="(386, 9)" end="(386, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(386, 11)" end="(386, 38)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(386, 11)" end="(386, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(386, 13)" end="(386, 18)">
                    <IdentNode start="(386, 13)" end="(386, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                    <IdentNode start="(386, 15)" end="(386, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(386, 17)" end="(386, 18)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(386, 18)" end="(386, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(386, 20)" end="(386, 38)" kind="«term_=_»">
                    <OtherNode start="(386, 20)" end="(386, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(386, 20)" end="(386, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(386, 22)" end="(386, 30)">
                        <IdentNode start="(386, 22)" end="(386, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                        <OtherNode start="(386, 24)" end="(386, 30)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(386, 24)" end="(386, 25)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(386, 25)" end="(386, 29)">
                            <IdentNode start="(386, 25)" end="(386, 26)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(386, 26)" end="(386, 27)" leading="" trailing=" " val=","/>
                            <IdentNode start="(386, 28)" end="(386, 29)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(386, 29)" end="(386, 30)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(386, 31)" end="(386, 32)" leading="" trailing=" " val="="/>
                    <OtherNode start="(386, 33)" end="(386, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(386, 33)" end="(386, 34)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(386, 35)" end="(386, 38)">
                        <IdentNode start="(386, 35)" end="(386, 36)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(386, 37)" end="(386, 38)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(386, 38)" end="(386, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(386, 40)" end="(386, 60)">
              <AtomNode start="(386, 40)" end="(386, 41)" leading="" trailing="" val="("/>
              <NullNode start="(386, 41)" end="(386, 42)">
                <IdentNode start="(386, 41)" end="(386, 42)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(386, 43)" end="(386, 59)">
                <AtomNode start="(386, 43)" end="(386, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(386, 45)" end="(386, 59)" kind="«term_=_»">
                  <IdentNode start="(386, 45)" end="(386, 49)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(386, 50)" end="(386, 51)" leading="" trailing=" " val="="/>
                  <IdentNode start="(386, 52)" end="(386, 59)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(386, 59)" end="(386, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(386, 61)" end="(387, 57)">
            <AtomNode start="(386, 61)" end="(386, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(387, 5)" end="(387, 57)" kind="«term_=_»">
              <OtherNode start="(387, 5)" end="(387, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(387, 5)" end="(387, 14)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(387, 15)" end="(387, 25)">
                  <IdentNode start="(387, 15)" end="(387, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(387, 17)" end="(387, 18)" leading="" trailing=" " raw_val="x" val="x"/>
                  <OtherNode start="(387, 19)" end="(387, 20)" kind="num">
                    <AtomNode start="(387, 19)" end="(387, 20)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(387, 21)" end="(387, 25)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(387, 26)" end="(387, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(387, 28)" end="(387, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(387, 28)" end="(387, 46)" leading="" trailing=" " raw_val="xs.unattach.foldlM" val="xs.unattach.foldlM"/>
                <NullNode start="(387, 47)" end="(387, 57)">
                  <IdentNode start="(387, 47)" end="(387, 48)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(387, 49)" end="(387, 50)" leading="" trailing=" " raw_val="x" val="x"/>
                  <OtherNode start="(387, 51)" end="(387, 52)" kind="num">
                    <AtomNode start="(387, 51)" end="(387, 52)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(387, 53)" end="(387, 57)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(387, 58)" end="(391, 30)">
          <AtomNode start="(387, 58)" end="(387, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(387, 61)" end="(391, 30)">
            <AtomNode start="(387, 61)" end="(387, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(388, 3)" end="(391, 30)">
              <TacticTacticseq1IndentedNode start="(388, 3)" end="(391, 30)">
                <NullNode start="(388, 3)" end="(391, 30)">
                  <OtherNode start="(388, 3)" end="(388, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;stop : Nat&#10;inst✝ : Monad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;w : stop = xs.size&#10;⊢ foldlM f x xs 0 stop = foldlM g x xs.unattach 0 stop" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;⊢ foldlM f x xs = foldlM g x xs.unattach 0 xs.size" tactic="subst w">
                    <AtomNode start="(388, 3)" end="(388, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(388, 9)" end="(388, 10)">
                      <IdentNode start="(388, 9)" end="(388, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(389, 3)" end="(389, 21)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;⊢ foldlM f x xs = foldlM g x xs.unattach 0 xs.size" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;l : List { x // p x }&#10;⊢ foldlM f x { toList := l } = foldlM g x { toList := l }.unattach 0 { toList := l }.size" tactic="rcases xs with ⟨l⟩">
                    <AtomNode start="(389, 3)" end="(389, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(389, 10)" end="(389, 12)">
                      <OtherNode start="(389, 10)" end="(389, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(389, 10)" end="(389, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(389, 13)" end="(389, 21)">
                      <AtomNode start="(389, 13)" end="(389, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(389, 18)" end="(389, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(389, 18)" end="(389, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(389, 18)" end="(389, 21)">
                            <OtherNode start="(389, 18)" end="(389, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(389, 18)" end="(389, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(389, 19)" end="(389, 20)">
                                <OtherNode start="(389, 19)" end="(389, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(389, 19)" end="(389, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(389, 19)" end="(389, 20)">
                                      <OtherNode start="(389, 19)" end="(389, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(389, 19)" end="(389, 20)" leading="" trailing="" raw_val="l" val="l"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(389, 20)" end="(389, 21)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(390, 3)" end="(390, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;l : List { x // p x }&#10;⊢ foldlM f x { toList := l } = foldlM g x { toList := l }.unattach 0 { toList := l }.size" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;l : List { x // p x }&#10;⊢ List.foldlM (fun x y =&amp;gt; f x y) x l = List.foldlM (fun x y =&amp;gt; g x y) x l.unattach" tactic="simp">
                    <AtomNode start="(390, 3)" end="(390, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(391, 3)" end="(391, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;l : List { x // p x }&#10;⊢ List.foldlM (fun x y =&amp;gt; f x y) x l = List.foldlM (fun x y =&amp;gt; g x y) x l.unattach" state_after="no goals" tactic="rw [List.foldlM_subtype hf]">
                    <AtomNode start="(391, 3)" end="(391, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(391, 6)" end="(391, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(391, 6)" end="(391, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(391, 7)" end="(391, 29)">
                        <OtherNode start="(391, 7)" end="(391, 29)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(391, 7)" end="(391, 29)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(391, 7)" end="(391, 26)" leading="" trailing=" " raw_val="List.foldlM_subtype" val="List.foldlM_subtype" full_name="List.foldlM_subtype" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                            <NullNode start="(391, 27)" end="(391, 29)">
                              <IdentNode start="(391, 27)" end="(391, 29)" leading="" trailing="" raw_val="hf" val="hf"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(391, 29)" end="(391, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(393, 1)" end="(395, 17)" name="foldlM_wfParam" full_name="Array.foldlM_wfParam">
      <CommandDeclmodifiersNode start="(393, 1)" end="(393, 17)">
        <NullNode/>
        <NullNode start="(393, 1)" end="(393, 17)">
          <OtherNode start="(393, 1)" end="(393, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(393, 1)" end="(393, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(393, 3)" end="(393, 16)">
              <OtherNode start="(393, 3)" end="(393, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(393, 3)" end="(393, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(393, 3)" end="(393, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(393, 16)" end="(393, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(393, 18)" end="(395, 17)" name="foldlM_wfParam" full_name="Array.foldlM_wfParam" _is_private_decl="False">
        <AtomNode start="(393, 18)" end="(393, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(393, 26)" end="(393, 40)">
          <IdentNode start="(393, 26)" end="(393, 40)" leading="" trailing=" " raw_val="foldlM_wfParam" val="foldlM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(393, 41)" end="(394, 66)">
          <NullNode start="(393, 41)" end="(393, 94)">
            <OtherNode start="(393, 41)" end="(393, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(393, 41)" end="(393, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(393, 42)" end="(393, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(393, 42)" end="(393, 47)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(393, 48)" end="(393, 49)">
                  <IdentNode start="(393, 48)" end="(393, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(393, 49)" end="(393, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(393, 51)" end="(393, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(393, 51)" end="(393, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(393, 52)" end="(393, 54)">
                <IdentNode start="(393, 52)" end="(393, 54)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(393, 55)" end="(393, 64)">
                <AtomNode start="(393, 55)" end="(393, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(393, 57)" end="(393, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(393, 57)" end="(393, 62)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(393, 63)" end="(393, 64)">
                    <IdentNode start="(393, 63)" end="(393, 64)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(393, 64)" end="(393, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(393, 66)" end="(393, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(393, 66)" end="(393, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(393, 67)" end="(393, 68)">
                <IdentNode start="(393, 67)" end="(393, 68)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(393, 69)" end="(393, 82)">
                <AtomNode start="(393, 69)" end="(393, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(393, 71)" end="(393, 82)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(393, 71)" end="(393, 72)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(393, 73)" end="(393, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(393, 75)" end="(393, 82)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(393, 75)" end="(393, 76)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(393, 77)" end="(393, 78)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(393, 79)" end="(393, 82)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(393, 79)" end="(393, 80)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(393, 81)" end="(393, 82)">
                        <IdentNode start="(393, 81)" end="(393, 82)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(393, 82)" end="(393, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(393, 84)" end="(393, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(393, 84)" end="(393, 85)" leading="" trailing="" val="{"/>
              <NullNode start="(393, 85)" end="(393, 89)">
                <IdentNode start="(393, 85)" end="(393, 89)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(393, 90)" end="(393, 93)">
                <AtomNode start="(393, 90)" end="(393, 91)" leading="" trailing=" " val=":"/>
                <IdentNode start="(393, 92)" end="(393, 93)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(393, 93)" end="(393, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(393, 95)" end="(394, 66)">
            <AtomNode start="(393, 95)" end="(393, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(394, 5)" end="(394, 66)" kind="«term_=_»">
              <OtherNode start="(394, 5)" end="(394, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(394, 5)" end="(394, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(394, 5)" end="(394, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(394, 5)" end="(394, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(394, 6)" end="(394, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(394, 6)" end="(394, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(394, 14)" end="(394, 16)">
                        <IdentNode start="(394, 14)" end="(394, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(394, 16)" end="(394, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(394, 17)" end="(394, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(394, 18)" end="(394, 24)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="Array.foldlM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(394, 25)" end="(394, 31)">
                  <IdentNode start="(394, 25)" end="(394, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(394, 27)" end="(394, 31)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(394, 32)" end="(394, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(394, 34)" end="(394, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(394, 34)" end="(394, 59)" leading="" trailing=" " raw_val="xs.attach.unattach.foldlM" val="xs.attach.unattach.foldlM"/>
                <NullNode start="(394, 60)" end="(394, 66)">
                  <IdentNode start="(394, 60)" end="(394, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(394, 62)" end="(394, 66)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(394, 67)" end="(395, 17)">
          <AtomNode start="(394, 67)" end="(394, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(394, 70)" end="(395, 17)">
            <AtomNode start="(394, 70)" end="(394, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(395, 3)" end="(395, 17)">
              <TacticTacticseq1IndentedNode start="(395, 3)" end="(395, 17)">
                <NullNode start="(395, 3)" end="(395, 17)">
                  <OtherNode start="(395, 3)" end="(395, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;xs : Array α&#10;f : β → α → m β&#10;init : β&#10;⊢ foldlM f init (wfParam xs) = foldlM f init xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(395, 3)" end="(395, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(395, 8)" end="(395, 17)">
                      <AtomNode start="(395, 8)" end="(395, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(395, 9)" end="(395, 16)">
                        <OtherNode start="(395, 9)" end="(395, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(395, 9)" end="(395, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(395, 16)" end="(395, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(397, 1)" end="(401, 17)" name="foldlM_unattach" full_name="Array.foldlM_unattach">
      <CommandDeclmodifiersNode start="(397, 1)" end="(397, 17)">
        <NullNode/>
        <NullNode start="(397, 1)" end="(397, 17)">
          <OtherNode start="(397, 1)" end="(397, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(397, 1)" end="(397, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(397, 3)" end="(397, 16)">
              <OtherNode start="(397, 3)" end="(397, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(397, 3)" end="(397, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(397, 3)" end="(397, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(397, 16)" end="(397, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(397, 18)" end="(401, 17)" name="foldlM_unattach" full_name="Array.foldlM_unattach" _is_private_decl="False">
        <AtomNode start="(397, 18)" end="(397, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(397, 26)" end="(397, 41)">
          <IdentNode start="(397, 26)" end="(397, 41)" leading="" trailing=" " raw_val="foldlM_unattach" val="foldlM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(397, 42)" end="(400, 22)">
          <NullNode start="(397, 42)" end="(397, 120)">
            <OtherNode start="(397, 42)" end="(397, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(397, 42)" end="(397, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(397, 43)" end="(397, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(397, 43)" end="(397, 48)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(397, 49)" end="(397, 50)">
                  <IdentNode start="(397, 49)" end="(397, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(397, 50)" end="(397, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(397, 52)" end="(397, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(397, 52)" end="(397, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(397, 53)" end="(397, 54)">
                <IdentNode start="(397, 53)" end="(397, 54)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(397, 55)" end="(397, 65)">
                <AtomNode start="(397, 55)" end="(397, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(397, 57)" end="(397, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(397, 57)" end="(397, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(397, 59)" end="(397, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(397, 61)" end="(397, 65)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(397, 61)" end="(397, 65)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(397, 65)" end="(397, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(397, 67)" end="(397, 91)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(397, 67)" end="(397, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(397, 68)" end="(397, 70)">
                <IdentNode start="(397, 68)" end="(397, 70)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(397, 71)" end="(397, 90)">
                <AtomNode start="(397, 71)" end="(397, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(397, 73)" end="(397, 90)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(397, 73)" end="(397, 78)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(397, 79)" end="(397, 90)">
                    <OtherNode start="(397, 79)" end="(397, 90)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(397, 79)" end="(397, 80)" leading="" trailing="" val="("/>
                      <OtherNode start="(397, 80)" end="(397, 89)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(397, 80)" end="(397, 87)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(397, 88)" end="(397, 89)">
                          <IdentNode start="(397, 88)" end="(397, 89)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(397, 89)" end="(397, 90)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(397, 90)" end="(397, 91)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(397, 92)" end="(397, 109)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(397, 92)" end="(397, 93)" leading="" trailing="" val="{"/>
              <NullNode start="(397, 93)" end="(397, 94)">
                <IdentNode start="(397, 93)" end="(397, 94)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(397, 95)" end="(397, 108)">
                <AtomNode start="(397, 95)" end="(397, 96)" leading="" trailing=" " val=":"/>
                <OtherNode start="(397, 97)" end="(397, 108)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(397, 97)" end="(397, 98)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(397, 99)" end="(397, 100)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(397, 101)" end="(397, 108)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(397, 101)" end="(397, 102)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(397, 103)" end="(397, 104)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(397, 105)" end="(397, 108)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(397, 105)" end="(397, 106)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(397, 107)" end="(397, 108)">
                        <IdentNode start="(397, 107)" end="(397, 108)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(397, 108)" end="(397, 109)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(397, 110)" end="(397, 120)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(397, 110)" end="(397, 111)" leading="" trailing="" val="{"/>
              <NullNode start="(397, 111)" end="(397, 115)">
                <IdentNode start="(397, 111)" end="(397, 115)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(397, 116)" end="(397, 119)">
                <AtomNode start="(397, 116)" end="(397, 117)" leading="" trailing=" " val=":"/>
                <IdentNode start="(397, 118)" end="(397, 119)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(397, 119)" end="(397, 120)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(397, 121)" end="(400, 22)">
            <AtomNode start="(397, 121)" end="(397, 122)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(398, 5)" end="(400, 22)" kind="«term_=_»">
              <OtherNode start="(398, 5)" end="(398, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(398, 5)" end="(398, 23)" leading="" trailing=" " raw_val="xs.unattach.foldlM" val="xs.unattach.foldlM"/>
                <NullNode start="(398, 24)" end="(398, 30)">
                  <IdentNode start="(398, 24)" end="(398, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(398, 26)" end="(398, 30)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(398, 31)" end="(398, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(398, 33)" end="(400, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(398, 33)" end="(398, 42)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(398, 43)" end="(400, 22)">
                  <OtherNode start="(398, 43)" end="(398, 57)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(398, 43)" end="(398, 44)" leading="" trailing="" val="("/>
                    <IdentNode start="(398, 44)" end="(398, 48)" leading="" trailing=" " raw_val="init" val="init"/>
                    <AtomNode start="(398, 49)" end="(398, 51)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(398, 52)" end="(398, 56)" leading="" trailing="" raw_val="init" val="init"/>
                    <AtomNode start="(398, 56)" end="(398, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(398, 58)" end="(400, 22)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(398, 58)" end="(398, 61)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(398, 62)" end="(400, 22)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(398, 62)" end="(398, 70)">
                        <IdentNode start="(398, 62)" end="(398, 63)" leading="" trailing=" " raw_val="b" val="b"/>
                        <OtherNode start="(398, 64)" end="(398, 70)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(398, 64)" end="(398, 65)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(398, 65)" end="(398, 69)">
                            <IdentNode start="(398, 65)" end="(398, 66)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(398, 66)" end="(398, 67)" leading="" trailing=" " val=","/>
                            <IdentNode start="(398, 68)" end="(398, 69)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(398, 69)" end="(398, 70)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(398, 71)" end="(398, 73)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(399, 7)" end="(400, 22)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(399, 7)" end="(399, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(399, 7)" end="(399, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(399, 22)" end="(399, 25)">
                            <IdentNode start="(399, 22)" end="(399, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                            <IdentNode start="(399, 24)" end="(399, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(399, 26)" end="(399, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(399, 29)" end="(400, 22)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(399, 29)" end="(399, 51)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(399, 29)" end="(399, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(399, 44)" end="(399, 51)">
                              <IdentNode start="(399, 44)" end="(399, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                              <OtherNode start="(399, 46)" end="(399, 51)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(399, 46)" end="(399, 47)" leading="" trailing="" val="("/>
                                <OtherNode start="(399, 47)" end="(399, 50)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(399, 47)" end="(399, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(399, 49)" end="(399, 50)">
                                    <IdentNode start="(399, 49)" end="(399, 50)" leading="" trailing="" raw_val="b" val="b"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(399, 50)" end="(399, 51)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(399, 52)" end="(399, 54)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(399, 55)" end="(400, 22)" kind="«term_&amp;lt;|_»">
                            <OtherNode start="(399, 55)" end="(399, 74)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(399, 55)" end="(399, 69)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                              <NullNode start="(399, 70)" end="(399, 74)">
                                <IdentNode start="(399, 70)" end="(399, 71)" leading="" trailing=" " raw_val="h" val="h"/>
                                <OtherNode start="(399, 72)" end="(399, 74)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(399, 72)" end="(399, 73)" leading="" trailing="" val="("/>
                                  <NullNode/>
                                  <AtomNode start="(399, 73)" end="(399, 74)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(399, 75)" end="(399, 77)" leading="" trailing="&#10;      " val="&amp;lt;|"/>
                            <OtherNode start="(400, 7)" end="(400, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(400, 7)" end="(400, 8)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(400, 9)" end="(400, 22)">
                                <IdentNode start="(400, 9)" end="(400, 10)" leading="" trailing=" " raw_val="b" val="b"/>
                                <OtherNode start="(400, 11)" end="(400, 22)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(400, 11)" end="(400, 12)" leading="" trailing="" val="("/>
                                  <OtherNode start="(400, 12)" end="(400, 21)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(400, 12)" end="(400, 19)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                    <NullNode start="(400, 20)" end="(400, 21)">
                                      <IdentNode start="(400, 20)" end="(400, 21)" leading="" trailing="" raw_val="x" val="x"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(400, 21)" end="(400, 22)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(400, 23)" end="(401, 17)">
          <AtomNode start="(400, 23)" end="(400, 25)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(400, 26)" end="(401, 17)">
            <AtomNode start="(400, 26)" end="(400, 28)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(401, 3)" end="(401, 17)">
              <TacticTacticseq1IndentedNode start="(401, 3)" end="(401, 17)">
                <NullNode start="(401, 3)" end="(401, 17)">
                  <OtherNode start="(401, 3)" end="(401, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;P : α → Prop&#10;xs : Array (Subtype P)&#10;f : β → α → m β&#10;init : β&#10;⊢ foldlM f init xs.unattach =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint b f (binderNameHint x (f b) (binderNameHint h () (f b (wfParam x)))))&#10;      init xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(401, 3)" end="(401, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(401, 8)" end="(401, 17)">
                      <AtomNode start="(401, 8)" end="(401, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(401, 9)" end="(401, 16)">
                        <OtherNode start="(401, 9)" end="(401, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(401, 9)" end="(401, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(401, 16)" end="(401, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(403, 1)" end="(414, 30)" name="foldrM_subtype" full_name="Array.foldrM_subtype">
      <CommandDeclmodifiersNode start="(403, 1)" end="(407, 8)">
        <NullNode start="(403, 1)" end="(406, 3)">
          <CommandDoccommentNode start="(403, 1)" end="(406, 3)" comment="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/">
            <AtomNode start="(403, 1)" end="(403, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(404, 1)" end="(406, 3)" leading="" trailing="&#10;" val="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(407, 1)" end="(407, 8)">
          <OtherNode start="(407, 1)" end="(407, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(407, 1)" end="(407, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(407, 3)" end="(407, 7)">
              <OtherNode start="(407, 3)" end="(407, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(407, 3)" end="(407, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(407, 3)" end="(407, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(407, 7)" end="(407, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(407, 9)" end="(414, 30)" name="foldrM_subtype" full_name="Array.foldrM_subtype" _is_private_decl="False">
        <AtomNode start="(407, 9)" end="(407, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(407, 17)" end="(407, 31)">
          <IdentNode start="(407, 17)" end="(407, 31)" leading="" trailing=" " raw_val="foldrM_subtype" val="foldrM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(407, 32)" end="(410, 59)">
          <NullNode start="(407, 32)" end="(409, 61)">
            <OtherNode start="(407, 32)" end="(407, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(407, 32)" end="(407, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(407, 33)" end="(407, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(407, 33)" end="(407, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(407, 39)" end="(407, 40)">
                  <IdentNode start="(407, 39)" end="(407, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(407, 40)" end="(407, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(407, 42)" end="(407, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(407, 42)" end="(407, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(407, 43)" end="(407, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(407, 43)" end="(407, 54)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(407, 55)" end="(407, 56)">
                  <IdentNode start="(407, 55)" end="(407, 56)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(407, 56)" end="(407, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(407, 58)" end="(407, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(407, 58)" end="(407, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(407, 59)" end="(407, 60)">
                <IdentNode start="(407, 59)" end="(407, 60)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(407, 61)" end="(407, 71)">
                <AtomNode start="(407, 61)" end="(407, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(407, 63)" end="(407, 71)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(407, 63)" end="(407, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(407, 65)" end="(407, 66)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(407, 67)" end="(407, 71)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(407, 67)" end="(407, 71)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(407, 71)" end="(407, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(407, 73)" end="(407, 98)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(407, 73)" end="(407, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(407, 74)" end="(407, 76)">
                <IdentNode start="(407, 74)" end="(407, 76)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(407, 77)" end="(407, 97)">
                <AtomNode start="(407, 77)" end="(407, 78)" leading="" trailing=" " val=":"/>
                <OtherNode start="(407, 79)" end="(407, 97)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(407, 79)" end="(407, 84)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(407, 85)" end="(407, 97)">
                    <OtherNode start="(407, 85)" end="(407, 97)" kind="«term{_:_//_}»">
                      <AtomNode start="(407, 85)" end="(407, 86)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(407, 87)" end="(407, 88)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(407, 89)" end="(407, 91)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(407, 92)" end="(407, 95)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(407, 92)" end="(407, 93)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(407, 94)" end="(407, 95)">
                          <IdentNode start="(407, 94)" end="(407, 95)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(407, 96)" end="(407, 97)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(407, 97)" end="(407, 98)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(408, 5)" end="(408, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(408, 5)" end="(408, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(408, 6)" end="(408, 7)">
                <IdentNode start="(408, 6)" end="(408, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(408, 8)" end="(408, 32)">
                <AtomNode start="(408, 8)" end="(408, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(408, 10)" end="(408, 32)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(408, 10)" end="(408, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(408, 10)" end="(408, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(408, 12)" end="(408, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(408, 14)" end="(408, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(408, 17)" end="(408, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(408, 17)" end="(408, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(408, 19)" end="(408, 20)">
                        <IdentNode start="(408, 19)" end="(408, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(408, 21)" end="(408, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(408, 23)" end="(408, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(408, 25)" end="(408, 32)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(408, 25)" end="(408, 26)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(408, 27)" end="(408, 28)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(408, 29)" end="(408, 32)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(408, 29)" end="(408, 30)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(408, 31)" end="(408, 32)">
                        <IdentNode start="(408, 31)" end="(408, 32)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(408, 32)" end="(408, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(408, 34)" end="(408, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(408, 34)" end="(408, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(408, 35)" end="(408, 36)">
                <IdentNode start="(408, 35)" end="(408, 36)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(408, 37)" end="(408, 50)">
                <AtomNode start="(408, 37)" end="(408, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(408, 39)" end="(408, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(408, 39)" end="(408, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(408, 41)" end="(408, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(408, 43)" end="(408, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(408, 43)" end="(408, 44)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(408, 45)" end="(408, 46)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(408, 47)" end="(408, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(408, 47)" end="(408, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(408, 49)" end="(408, 50)">
                        <IdentNode start="(408, 49)" end="(408, 50)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(408, 50)" end="(408, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(408, 52)" end="(408, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(408, 52)" end="(408, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(408, 53)" end="(408, 54)">
                <IdentNode start="(408, 53)" end="(408, 54)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(408, 55)" end="(408, 58)">
                <AtomNode start="(408, 55)" end="(408, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(408, 57)" end="(408, 58)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(408, 58)" end="(408, 59)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(409, 5)" end="(409, 39)">
              <AtomNode start="(409, 5)" end="(409, 6)" leading="" trailing="" val="("/>
              <NullNode start="(409, 6)" end="(409, 8)">
                <IdentNode start="(409, 6)" end="(409, 8)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(409, 9)" end="(409, 38)">
                <AtomNode start="(409, 9)" end="(409, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 11)" end="(409, 38)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(409, 11)" end="(409, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(409, 13)" end="(409, 18)">
                    <IdentNode start="(409, 13)" end="(409, 14)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(409, 15)" end="(409, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                    <IdentNode start="(409, 17)" end="(409, 18)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(409, 18)" end="(409, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(409, 20)" end="(409, 38)" kind="«term_=_»">
                    <OtherNode start="(409, 20)" end="(409, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(409, 20)" end="(409, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(409, 22)" end="(409, 30)">
                        <OtherNode start="(409, 22)" end="(409, 28)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(409, 22)" end="(409, 23)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(409, 23)" end="(409, 27)">
                            <IdentNode start="(409, 23)" end="(409, 24)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(409, 24)" end="(409, 25)" leading="" trailing=" " val=","/>
                            <IdentNode start="(409, 26)" end="(409, 27)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(409, 27)" end="(409, 28)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <IdentNode start="(409, 29)" end="(409, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(409, 31)" end="(409, 32)" leading="" trailing=" " val="="/>
                    <OtherNode start="(409, 33)" end="(409, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(409, 33)" end="(409, 34)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(409, 35)" end="(409, 38)">
                        <IdentNode start="(409, 35)" end="(409, 36)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(409, 37)" end="(409, 38)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(409, 38)" end="(409, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(409, 40)" end="(409, 61)">
              <AtomNode start="(409, 40)" end="(409, 41)" leading="" trailing="" val="("/>
              <NullNode start="(409, 41)" end="(409, 42)">
                <IdentNode start="(409, 41)" end="(409, 42)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(409, 43)" end="(409, 60)">
                <AtomNode start="(409, 43)" end="(409, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 45)" end="(409, 60)" kind="«term_=_»">
                  <IdentNode start="(409, 45)" end="(409, 50)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(409, 51)" end="(409, 52)" leading="" trailing=" " val="="/>
                  <IdentNode start="(409, 53)" end="(409, 60)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(409, 60)" end="(409, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(409, 62)" end="(410, 59)">
            <AtomNode start="(409, 62)" end="(409, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(410, 5)" end="(410, 59)" kind="«term_=_»">
              <OtherNode start="(410, 5)" end="(410, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(410, 5)" end="(410, 14)" leading="" trailing=" " raw_val="xs.foldrM" val="xs.foldrM"/>
                <NullNode start="(410, 15)" end="(410, 26)">
                  <IdentNode start="(410, 15)" end="(410, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(410, 17)" end="(410, 18)" leading="" trailing=" " raw_val="x" val="x"/>
                  <IdentNode start="(410, 19)" end="(410, 24)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(410, 25)" end="(410, 26)" kind="num">
                    <AtomNode start="(410, 25)" end="(410, 26)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(410, 27)" end="(410, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(410, 29)" end="(410, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(410, 29)" end="(410, 47)" leading="" trailing=" " raw_val="xs.unattach.foldrM" val="xs.unattach.foldrM"/>
                <NullNode start="(410, 48)" end="(410, 59)">
                  <IdentNode start="(410, 48)" end="(410, 49)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(410, 50)" end="(410, 51)" leading="" trailing=" " raw_val="x" val="x"/>
                  <IdentNode start="(410, 52)" end="(410, 57)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(410, 58)" end="(410, 59)" kind="num">
                    <AtomNode start="(410, 58)" end="(410, 59)" leading="" trailing="" val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(410, 59)" end="(414, 30)">
          <AtomNode start="(410, 59)" end="(410, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(410, 62)" end="(414, 30)">
            <AtomNode start="(410, 62)" end="(410, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(411, 3)" end="(414, 30)">
              <TacticTacticseq1IndentedNode start="(411, 3)" end="(414, 30)">
                <NullNode start="(411, 3)" end="(414, 30)">
                  <OtherNode start="(411, 3)" end="(411, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;start : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;w : start = xs.size&#10;⊢ foldrM f x xs start = foldrM g x xs.unattach start" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;⊢ foldrM f x xs = foldrM g x xs.unattach xs.size" tactic="subst w">
                    <AtomNode start="(411, 3)" end="(411, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(411, 9)" end="(411, 10)">
                      <IdentNode start="(411, 9)" end="(411, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(412, 3)" end="(412, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;⊢ foldrM f x xs = foldrM g x xs.unattach xs.size" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;xs : List { x // p x }&#10;⊢ foldrM f x { toList := xs } = foldrM g x { toList := xs }.unattach { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(412, 3)" end="(412, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(412, 10)" end="(412, 12)">
                      <OtherNode start="(412, 10)" end="(412, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(412, 10)" end="(412, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(412, 13)" end="(412, 22)">
                      <AtomNode start="(412, 13)" end="(412, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(412, 18)" end="(412, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(412, 18)" end="(412, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(412, 18)" end="(412, 22)">
                            <OtherNode start="(412, 18)" end="(412, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(412, 18)" end="(412, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(412, 19)" end="(412, 21)">
                                <OtherNode start="(412, 19)" end="(412, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(412, 19)" end="(412, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(412, 19)" end="(412, 21)">
                                      <OtherNode start="(412, 19)" end="(412, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(412, 19)" end="(412, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(412, 21)" end="(412, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(413, 3)" end="(413, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;xs : List { x // p x }&#10;⊢ foldrM f x { toList := xs } = foldrM g x { toList := xs }.unattach { toList := xs }.size" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;xs : List { x // p x }&#10;⊢ List.foldrM (fun x y =&amp;gt; f x y) x xs = List.foldrM (fun x y =&amp;gt; g x y) x xs.unattach" tactic="simp">
                    <AtomNode start="(413, 3)" end="(413, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(414, 3)" end="(414, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;xs : List { x // p x }&#10;⊢ List.foldrM (fun x y =&amp;gt; f x y) x xs = List.foldrM (fun x y =&amp;gt; g x y) x xs.unattach" state_after="no goals" tactic="rw [List.foldrM_subtype hf]">
                    <AtomNode start="(414, 3)" end="(414, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(414, 6)" end="(414, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(414, 6)" end="(414, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(414, 7)" end="(414, 29)">
                        <OtherNode start="(414, 7)" end="(414, 29)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(414, 7)" end="(414, 29)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(414, 7)" end="(414, 26)" leading="" trailing=" " raw_val="List.foldrM_subtype" val="List.foldrM_subtype" full_name="List.foldrM_subtype" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                            <NullNode start="(414, 27)" end="(414, 29)">
                              <IdentNode start="(414, 27)" end="(414, 29)" leading="" trailing="" raw_val="hf" val="hf"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(414, 29)" end="(414, 30)" leading="" trailing="&#10;&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(417, 1)" end="(419, 17)" name="foldrM_wfParam" full_name="Array.foldrM_wfParam">
      <CommandDeclmodifiersNode start="(417, 1)" end="(417, 17)">
        <NullNode/>
        <NullNode start="(417, 1)" end="(417, 17)">
          <OtherNode start="(417, 1)" end="(417, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(417, 1)" end="(417, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(417, 3)" end="(417, 16)">
              <OtherNode start="(417, 3)" end="(417, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(417, 3)" end="(417, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(417, 3)" end="(417, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(417, 16)" end="(417, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(417, 18)" end="(419, 17)" name="foldrM_wfParam" full_name="Array.foldrM_wfParam" _is_private_decl="False">
        <AtomNode start="(417, 18)" end="(417, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(417, 26)" end="(417, 40)">
          <IdentNode start="(417, 26)" end="(417, 40)" leading="" trailing=" " raw_val="foldrM_wfParam" val="foldrM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(417, 41)" end="(418, 66)">
          <NullNode start="(417, 41)" end="(417, 110)">
            <OtherNode start="(417, 41)" end="(417, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(417, 41)" end="(417, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(417, 42)" end="(417, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(417, 42)" end="(417, 47)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(417, 48)" end="(417, 49)">
                  <IdentNode start="(417, 48)" end="(417, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(417, 49)" end="(417, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(417, 51)" end="(417, 66)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(417, 51)" end="(417, 52)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(417, 52)" end="(417, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(417, 52)" end="(417, 63)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(417, 64)" end="(417, 65)">
                  <IdentNode start="(417, 64)" end="(417, 65)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(417, 65)" end="(417, 66)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(417, 67)" end="(417, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(417, 67)" end="(417, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(417, 68)" end="(417, 70)">
                <IdentNode start="(417, 68)" end="(417, 70)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(417, 71)" end="(417, 80)">
                <AtomNode start="(417, 71)" end="(417, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(417, 73)" end="(417, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(417, 73)" end="(417, 78)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(417, 79)" end="(417, 80)">
                    <IdentNode start="(417, 79)" end="(417, 80)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(417, 80)" end="(417, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(417, 82)" end="(417, 99)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(417, 82)" end="(417, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(417, 83)" end="(417, 84)">
                <IdentNode start="(417, 83)" end="(417, 84)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(417, 85)" end="(417, 98)">
                <AtomNode start="(417, 85)" end="(417, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(417, 87)" end="(417, 98)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(417, 87)" end="(417, 88)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(417, 89)" end="(417, 90)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(417, 91)" end="(417, 98)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(417, 91)" end="(417, 92)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(417, 93)" end="(417, 94)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(417, 95)" end="(417, 98)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(417, 95)" end="(417, 96)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(417, 97)" end="(417, 98)">
                        <IdentNode start="(417, 97)" end="(417, 98)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(417, 98)" end="(417, 99)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(417, 100)" end="(417, 110)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(417, 100)" end="(417, 101)" leading="" trailing="" val="{"/>
              <NullNode start="(417, 101)" end="(417, 105)">
                <IdentNode start="(417, 101)" end="(417, 105)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(417, 106)" end="(417, 109)">
                <AtomNode start="(417, 106)" end="(417, 107)" leading="" trailing=" " val=":"/>
                <IdentNode start="(417, 108)" end="(417, 109)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(417, 109)" end="(417, 110)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(417, 111)" end="(418, 66)">
            <AtomNode start="(417, 111)" end="(417, 112)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(418, 5)" end="(418, 66)" kind="«term_=_»">
              <OtherNode start="(418, 5)" end="(418, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(418, 5)" end="(418, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(418, 5)" end="(418, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(418, 5)" end="(418, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(418, 6)" end="(418, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(418, 6)" end="(418, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(418, 14)" end="(418, 16)">
                        <IdentNode start="(418, 14)" end="(418, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(418, 16)" end="(418, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(418, 17)" end="(418, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(418, 18)" end="(418, 24)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="Array.foldrM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(418, 25)" end="(418, 31)">
                  <IdentNode start="(418, 25)" end="(418, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(418, 27)" end="(418, 31)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(418, 32)" end="(418, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(418, 34)" end="(418, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(418, 34)" end="(418, 59)" leading="" trailing=" " raw_val="xs.attach.unattach.foldrM" val="xs.attach.unattach.foldrM"/>
                <NullNode start="(418, 60)" end="(418, 66)">
                  <IdentNode start="(418, 60)" end="(418, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(418, 62)" end="(418, 66)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(418, 67)" end="(419, 17)">
          <AtomNode start="(418, 67)" end="(418, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(418, 70)" end="(419, 17)">
            <AtomNode start="(418, 70)" end="(418, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(419, 3)" end="(419, 17)">
              <TacticTacticseq1IndentedNode start="(419, 3)" end="(419, 17)">
                <NullNode start="(419, 3)" end="(419, 17)">
                  <OtherNode start="(419, 3)" end="(419, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → β → m β&#10;init : β&#10;⊢ foldrM f init (wfParam xs) = foldrM f init xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(419, 3)" end="(419, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(419, 8)" end="(419, 17)">
                      <AtomNode start="(419, 8)" end="(419, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(419, 9)" end="(419, 16)">
                        <OtherNode start="(419, 9)" end="(419, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(419, 9)" end="(419, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(419, 16)" end="(419, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(421, 1)" end="(425, 17)" name="foldrM_unattach" full_name="Array.foldrM_unattach">
      <CommandDeclmodifiersNode start="(421, 1)" end="(421, 17)">
        <NullNode/>
        <NullNode start="(421, 1)" end="(421, 17)">
          <OtherNode start="(421, 1)" end="(421, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(421, 1)" end="(421, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(421, 3)" end="(421, 16)">
              <OtherNode start="(421, 3)" end="(421, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(421, 3)" end="(421, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(421, 3)" end="(421, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(421, 16)" end="(421, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(421, 18)" end="(425, 17)" name="foldrM_unattach" full_name="Array.foldrM_unattach" _is_private_decl="False">
        <AtomNode start="(421, 18)" end="(421, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(421, 26)" end="(421, 41)">
          <IdentNode start="(421, 26)" end="(421, 41)" leading="" trailing=" " raw_val="foldrM_unattach" val="foldrM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(421, 42)" end="(424, 22)">
          <NullNode start="(421, 42)" end="(421, 136)">
            <OtherNode start="(421, 42)" end="(421, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(421, 42)" end="(421, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(421, 43)" end="(421, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(421, 43)" end="(421, 48)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(421, 49)" end="(421, 50)">
                  <IdentNode start="(421, 49)" end="(421, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(421, 50)" end="(421, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(421, 52)" end="(421, 67)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(421, 52)" end="(421, 53)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(421, 53)" end="(421, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(421, 53)" end="(421, 64)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(421, 65)" end="(421, 66)">
                  <IdentNode start="(421, 65)" end="(421, 66)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(421, 66)" end="(421, 67)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(421, 68)" end="(421, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(421, 68)" end="(421, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(421, 69)" end="(421, 70)">
                <IdentNode start="(421, 69)" end="(421, 70)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(421, 71)" end="(421, 81)">
                <AtomNode start="(421, 71)" end="(421, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(421, 73)" end="(421, 81)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(421, 73)" end="(421, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(421, 75)" end="(421, 76)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(421, 77)" end="(421, 81)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(421, 77)" end="(421, 81)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(421, 81)" end="(421, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(421, 83)" end="(421, 107)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(421, 83)" end="(421, 84)" leading="" trailing="" val="{"/>
              <NullNode start="(421, 84)" end="(421, 86)">
                <IdentNode start="(421, 84)" end="(421, 86)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(421, 87)" end="(421, 106)">
                <AtomNode start="(421, 87)" end="(421, 88)" leading="" trailing=" " val=":"/>
                <OtherNode start="(421, 89)" end="(421, 106)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(421, 89)" end="(421, 94)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(421, 95)" end="(421, 106)">
                    <OtherNode start="(421, 95)" end="(421, 106)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(421, 95)" end="(421, 96)" leading="" trailing="" val="("/>
                      <OtherNode start="(421, 96)" end="(421, 105)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(421, 96)" end="(421, 103)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(421, 104)" end="(421, 105)">
                          <IdentNode start="(421, 104)" end="(421, 105)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(421, 105)" end="(421, 106)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(421, 106)" end="(421, 107)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(421, 108)" end="(421, 125)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(421, 108)" end="(421, 109)" leading="" trailing="" val="{"/>
              <NullNode start="(421, 109)" end="(421, 110)">
                <IdentNode start="(421, 109)" end="(421, 110)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(421, 111)" end="(421, 124)">
                <AtomNode start="(421, 111)" end="(421, 112)" leading="" trailing=" " val=":"/>
                <OtherNode start="(421, 113)" end="(421, 124)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(421, 113)" end="(421, 114)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(421, 115)" end="(421, 116)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(421, 117)" end="(421, 124)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(421, 117)" end="(421, 118)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(421, 119)" end="(421, 120)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(421, 121)" end="(421, 124)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(421, 121)" end="(421, 122)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(421, 123)" end="(421, 124)">
                        <IdentNode start="(421, 123)" end="(421, 124)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(421, 124)" end="(421, 125)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(421, 126)" end="(421, 136)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(421, 126)" end="(421, 127)" leading="" trailing="" val="{"/>
              <NullNode start="(421, 127)" end="(421, 131)">
                <IdentNode start="(421, 127)" end="(421, 131)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(421, 132)" end="(421, 135)">
                <AtomNode start="(421, 132)" end="(421, 133)" leading="" trailing=" " val=":"/>
                <IdentNode start="(421, 134)" end="(421, 135)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(421, 135)" end="(421, 136)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(421, 137)" end="(424, 22)">
            <AtomNode start="(421, 137)" end="(421, 138)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(422, 5)" end="(424, 22)" kind="«term_=_»">
              <OtherNode start="(422, 5)" end="(422, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(422, 5)" end="(422, 23)" leading="" trailing=" " raw_val="xs.unattach.foldrM" val="xs.unattach.foldrM"/>
                <NullNode start="(422, 24)" end="(422, 30)">
                  <IdentNode start="(422, 24)" end="(422, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(422, 26)" end="(422, 30)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(422, 31)" end="(422, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(422, 33)" end="(424, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(422, 33)" end="(422, 42)" leading="" trailing=" " raw_val="xs.foldrM" val="xs.foldrM"/>
                <NullNode start="(422, 43)" end="(424, 22)">
                  <OtherNode start="(422, 43)" end="(422, 57)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(422, 43)" end="(422, 44)" leading="" trailing="" val="("/>
                    <IdentNode start="(422, 44)" end="(422, 48)" leading="" trailing=" " raw_val="init" val="init"/>
                    <AtomNode start="(422, 49)" end="(422, 51)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(422, 52)" end="(422, 56)" leading="" trailing="" raw_val="init" val="init"/>
                    <AtomNode start="(422, 56)" end="(422, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(422, 58)" end="(424, 22)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(422, 58)" end="(422, 61)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(422, 62)" end="(424, 22)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(422, 62)" end="(422, 70)">
                        <OtherNode start="(422, 62)" end="(422, 68)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(422, 62)" end="(422, 63)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(422, 63)" end="(422, 67)">
                            <IdentNode start="(422, 63)" end="(422, 64)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(422, 64)" end="(422, 65)" leading="" trailing=" " val=","/>
                            <IdentNode start="(422, 66)" end="(422, 67)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(422, 67)" end="(422, 68)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <IdentNode start="(422, 69)" end="(422, 70)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(422, 71)" end="(422, 73)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(423, 7)" end="(424, 22)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(423, 7)" end="(423, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(423, 7)" end="(423, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(423, 22)" end="(423, 25)">
                            <IdentNode start="(423, 22)" end="(423, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(423, 24)" end="(423, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(423, 26)" end="(423, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(423, 29)" end="(424, 22)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(423, 29)" end="(423, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(423, 29)" end="(423, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(423, 44)" end="(423, 48)">
                              <IdentNode start="(423, 44)" end="(423, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(423, 46)" end="(423, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(423, 46)" end="(423, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(423, 47)" end="(423, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(423, 49)" end="(423, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(423, 52)" end="(424, 22)" kind="«term_&amp;lt;|_»">
                            <OtherNode start="(423, 52)" end="(423, 74)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(423, 52)" end="(423, 66)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                              <NullNode start="(423, 67)" end="(423, 74)">
                                <IdentNode start="(423, 67)" end="(423, 68)" leading="" trailing=" " raw_val="b" val="b"/>
                                <OtherNode start="(423, 69)" end="(423, 74)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(423, 69)" end="(423, 70)" leading="" trailing="" val="("/>
                                  <OtherNode start="(423, 70)" end="(423, 73)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(423, 70)" end="(423, 71)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(423, 72)" end="(423, 73)">
                                      <IdentNode start="(423, 72)" end="(423, 73)" leading="" trailing="" raw_val="x" val="x"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(423, 73)" end="(423, 74)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(423, 75)" end="(423, 77)" leading="" trailing="&#10;      " val="&amp;lt;|"/>
                            <OtherNode start="(424, 7)" end="(424, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(424, 7)" end="(424, 8)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(424, 9)" end="(424, 22)">
                                <OtherNode start="(424, 9)" end="(424, 20)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(424, 9)" end="(424, 10)" leading="" trailing="" val="("/>
                                  <OtherNode start="(424, 10)" end="(424, 19)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(424, 10)" end="(424, 17)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                    <NullNode start="(424, 18)" end="(424, 19)">
                                      <IdentNode start="(424, 18)" end="(424, 19)" leading="" trailing="" raw_val="x" val="x"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(424, 19)" end="(424, 20)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(424, 21)" end="(424, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(424, 23)" end="(425, 17)">
          <AtomNode start="(424, 23)" end="(424, 25)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(424, 26)" end="(425, 17)">
            <AtomNode start="(424, 26)" end="(424, 28)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(425, 3)" end="(425, 17)">
              <TacticTacticseq1IndentedNode start="(425, 3)" end="(425, 17)">
                <NullNode start="(425, 3)" end="(425, 17)">
                  <OtherNode start="(425, 3)" end="(425, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : Array (Subtype P)&#10;f : α → β → m β&#10;init : β&#10;⊢ foldrM f init xs.unattach =&#10;    foldrM&#10;      (fun x b =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (binderNameHint b (f x) (f (wfParam x) b))))&#10;      init xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(425, 3)" end="(425, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(425, 8)" end="(425, 17)">
                      <AtomNode start="(425, 8)" end="(425, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(425, 9)" end="(425, 16)">
                        <OtherNode start="(425, 9)" end="(425, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(425, 9)" end="(425, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(425, 16)" end="(425, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(427, 1)" end="(436, 28)" name="mapM_subtype" full_name="Array.mapM_subtype">
      <CommandDeclmodifiersNode start="(427, 1)" end="(431, 8)">
        <NullNode start="(427, 1)" end="(430, 3)">
          <CommandDoccommentNode start="(427, 1)" end="(430, 3)" comment="This lemma identifies monadic maps over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/">
            <AtomNode start="(427, 1)" end="(427, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(428, 1)" end="(430, 3)" leading="" trailing="&#10;" val="This lemma identifies monadic maps over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(431, 1)" end="(431, 8)">
          <OtherNode start="(431, 1)" end="(431, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(431, 1)" end="(431, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(431, 3)" end="(431, 7)">
              <OtherNode start="(431, 3)" end="(431, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(431, 3)" end="(431, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(431, 3)" end="(431, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(431, 7)" end="(431, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(431, 9)" end="(436, 28)" name="mapM_subtype" full_name="Array.mapM_subtype" _is_private_decl="False">
        <AtomNode start="(431, 9)" end="(431, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(431, 17)" end="(431, 29)">
          <IdentNode start="(431, 17)" end="(431, 29)" leading="" trailing=" " raw_val="mapM_subtype" val="mapM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(431, 30)" end="(433, 35)">
          <NullNode start="(431, 30)" end="(432, 72)">
            <OtherNode start="(431, 30)" end="(431, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(431, 30)" end="(431, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(431, 31)" end="(431, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(431, 31)" end="(431, 36)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(431, 37)" end="(431, 38)">
                  <IdentNode start="(431, 37)" end="(431, 38)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(431, 38)" end="(431, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(431, 40)" end="(431, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(431, 40)" end="(431, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(431, 41)" end="(431, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(431, 41)" end="(431, 52)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(431, 53)" end="(431, 54)">
                  <IdentNode start="(431, 53)" end="(431, 54)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(431, 54)" end="(431, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(431, 56)" end="(431, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(431, 56)" end="(431, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(431, 57)" end="(431, 58)">
                <IdentNode start="(431, 57)" end="(431, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(431, 59)" end="(431, 69)">
                <AtomNode start="(431, 59)" end="(431, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(431, 61)" end="(431, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(431, 61)" end="(431, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(431, 63)" end="(431, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(431, 65)" end="(431, 69)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(431, 65)" end="(431, 69)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(431, 69)" end="(431, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(431, 71)" end="(431, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(431, 71)" end="(431, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(431, 72)" end="(431, 74)">
                <IdentNode start="(431, 72)" end="(431, 74)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(431, 75)" end="(431, 95)">
                <AtomNode start="(431, 75)" end="(431, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(431, 77)" end="(431, 95)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(431, 77)" end="(431, 82)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(431, 83)" end="(431, 95)">
                    <OtherNode start="(431, 83)" end="(431, 95)" kind="«term{_:_//_}»">
                      <AtomNode start="(431, 83)" end="(431, 84)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(431, 85)" end="(431, 86)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(431, 87)" end="(431, 89)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(431, 90)" end="(431, 93)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(431, 90)" end="(431, 91)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(431, 92)" end="(431, 93)">
                          <IdentNode start="(431, 92)" end="(431, 93)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(431, 94)" end="(431, 95)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(431, 95)" end="(431, 96)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(432, 5)" end="(432, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(432, 5)" end="(432, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(432, 6)" end="(432, 7)">
                <IdentNode start="(432, 6)" end="(432, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(432, 8)" end="(432, 28)">
                <AtomNode start="(432, 8)" end="(432, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(432, 10)" end="(432, 28)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(432, 10)" end="(432, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(432, 10)" end="(432, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(432, 12)" end="(432, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(432, 14)" end="(432, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(432, 17)" end="(432, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(432, 17)" end="(432, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(432, 19)" end="(432, 20)">
                        <IdentNode start="(432, 19)" end="(432, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(432, 21)" end="(432, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(432, 23)" end="(432, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(432, 25)" end="(432, 28)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(432, 25)" end="(432, 26)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(432, 27)" end="(432, 28)">
                      <IdentNode start="(432, 27)" end="(432, 28)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(432, 28)" end="(432, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(432, 30)" end="(432, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(432, 30)" end="(432, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(432, 31)" end="(432, 32)">
                <IdentNode start="(432, 31)" end="(432, 32)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(432, 33)" end="(432, 42)">
                <AtomNode start="(432, 33)" end="(432, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(432, 35)" end="(432, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(432, 35)" end="(432, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(432, 37)" end="(432, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(432, 39)" end="(432, 42)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(432, 39)" end="(432, 40)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(432, 41)" end="(432, 42)">
                      <IdentNode start="(432, 41)" end="(432, 42)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(432, 42)" end="(432, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(432, 44)" end="(432, 72)">
              <AtomNode start="(432, 44)" end="(432, 45)" leading="" trailing="" val="("/>
              <NullNode start="(432, 45)" end="(432, 47)">
                <IdentNode start="(432, 45)" end="(432, 47)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(432, 48)" end="(432, 71)">
                <AtomNode start="(432, 48)" end="(432, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(432, 50)" end="(432, 71)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(432, 50)" end="(432, 51)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(432, 52)" end="(432, 55)">
                    <IdentNode start="(432, 52)" end="(432, 53)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(432, 54)" end="(432, 55)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(432, 55)" end="(432, 56)" leading="" trailing=" " val=","/>
                  <OtherNode start="(432, 57)" end="(432, 71)" kind="«term_=_»">
                    <OtherNode start="(432, 57)" end="(432, 65)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(432, 57)" end="(432, 58)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(432, 59)" end="(432, 65)">
                        <OtherNode start="(432, 59)" end="(432, 65)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(432, 59)" end="(432, 60)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(432, 60)" end="(432, 64)">
                            <IdentNode start="(432, 60)" end="(432, 61)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(432, 61)" end="(432, 62)" leading="" trailing=" " val=","/>
                            <IdentNode start="(432, 63)" end="(432, 64)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(432, 64)" end="(432, 65)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(432, 66)" end="(432, 67)" leading="" trailing=" " val="="/>
                    <OtherNode start="(432, 68)" end="(432, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(432, 68)" end="(432, 69)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(432, 70)" end="(432, 71)">
                        <IdentNode start="(432, 70)" end="(432, 71)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(432, 71)" end="(432, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(432, 73)" end="(433, 35)">
            <AtomNode start="(432, 73)" end="(432, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(433, 5)" end="(433, 35)" kind="«term_=_»">
              <OtherNode start="(433, 5)" end="(433, 14)" kind="Lean.Parser.Term.app">
                <IdentNode start="(433, 5)" end="(433, 12)" leading="" trailing=" " raw_val="xs.mapM" val="xs.mapM"/>
                <NullNode start="(433, 13)" end="(433, 14)">
                  <IdentNode start="(433, 13)" end="(433, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(433, 15)" end="(433, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(433, 17)" end="(433, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(433, 17)" end="(433, 33)" leading="" trailing=" " raw_val="xs.unattach.mapM" val="xs.unattach.mapM"/>
                <NullNode start="(433, 34)" end="(433, 35)">
                  <IdentNode start="(433, 34)" end="(433, 35)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(433, 36)" end="(436, 28)">
          <AtomNode start="(433, 36)" end="(433, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(433, 39)" end="(436, 28)">
            <AtomNode start="(433, 39)" end="(433, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(434, 3)" end="(436, 28)">
              <TacticTacticseq1IndentedNode start="(434, 3)" end="(436, 28)">
                <NullNode start="(434, 3)" end="(436, 28)">
                  <OtherNode start="(434, 3)" end="(434, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ mapM f xs = mapM g xs.unattach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ mapM f { toList := xs } = mapM g { toList := xs }.unattach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(434, 3)" end="(434, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(434, 10)" end="(434, 12)">
                      <OtherNode start="(434, 10)" end="(434, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(434, 10)" end="(434, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(434, 13)" end="(434, 22)">
                      <AtomNode start="(434, 13)" end="(434, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(434, 18)" end="(434, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(434, 18)" end="(434, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(434, 18)" end="(434, 22)">
                            <OtherNode start="(434, 18)" end="(434, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(434, 18)" end="(434, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(434, 19)" end="(434, 21)">
                                <OtherNode start="(434, 19)" end="(434, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(434, 19)" end="(434, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(434, 19)" end="(434, 21)">
                                      <OtherNode start="(434, 19)" end="(434, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(434, 19)" end="(434, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(434, 21)" end="(434, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(435, 3)" end="(435, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ mapM f { toList := xs } = mapM g { toList := xs }.unattach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ List.mapM f xs = List.mapM g xs.unattach" tactic="simp">
                    <AtomNode start="(435, 3)" end="(435, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(436, 3)" end="(436, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ List.mapM f xs = List.mapM g xs.unattach" state_after="no goals" tactic="rw [List.mapM_subtype hf]">
                    <AtomNode start="(436, 3)" end="(436, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(436, 6)" end="(436, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(436, 6)" end="(436, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(436, 7)" end="(436, 27)">
                        <OtherNode start="(436, 7)" end="(436, 27)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(436, 7)" end="(436, 27)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(436, 7)" end="(436, 24)" leading="" trailing=" " raw_val="List.mapM_subtype" val="List.mapM_subtype" full_name="List.mapM_subtype" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                            <NullNode start="(436, 25)" end="(436, 27)">
                              <IdentNode start="(436, 25)" end="(436, 27)" leading="" trailing="" raw_val="hf" val="hf"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(436, 27)" end="(436, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(438, 1)" end="(440, 17)" name="mapM_wfParam" full_name="Array.mapM_wfParam">
      <CommandDeclmodifiersNode start="(438, 1)" end="(438, 17)">
        <NullNode/>
        <NullNode start="(438, 1)" end="(438, 17)">
          <OtherNode start="(438, 1)" end="(438, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(438, 1)" end="(438, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(438, 3)" end="(438, 16)">
              <OtherNode start="(438, 3)" end="(438, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(438, 3)" end="(438, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(438, 3)" end="(438, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(438, 16)" end="(438, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(438, 18)" end="(440, 17)" name="mapM_wfParam" full_name="Array.mapM_wfParam" _is_private_decl="False">
        <AtomNode start="(438, 18)" end="(438, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(438, 26)" end="(438, 38)">
          <IdentNode start="(438, 26)" end="(438, 38)" leading="" trailing=" " raw_val="mapM_wfParam" val="mapM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(438, 39)" end="(439, 52)">
          <NullNode start="(438, 39)" end="(438, 93)">
            <OtherNode start="(438, 39)" end="(438, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(438, 39)" end="(438, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(438, 40)" end="(438, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(438, 40)" end="(438, 45)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(438, 46)" end="(438, 47)">
                  <IdentNode start="(438, 46)" end="(438, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(438, 47)" end="(438, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(438, 49)" end="(438, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(438, 49)" end="(438, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(438, 50)" end="(438, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(438, 50)" end="(438, 61)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(438, 62)" end="(438, 63)">
                  <IdentNode start="(438, 62)" end="(438, 63)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(438, 63)" end="(438, 64)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(438, 65)" end="(438, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(438, 65)" end="(438, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(438, 66)" end="(438, 68)">
                <IdentNode start="(438, 66)" end="(438, 68)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(438, 69)" end="(438, 78)">
                <AtomNode start="(438, 69)" end="(438, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(438, 71)" end="(438, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(438, 71)" end="(438, 76)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(438, 77)" end="(438, 78)">
                    <IdentNode start="(438, 77)" end="(438, 78)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(438, 78)" end="(438, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(438, 80)" end="(438, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(438, 80)" end="(438, 81)" leading="" trailing="" val="{"/>
              <NullNode start="(438, 81)" end="(438, 82)">
                <IdentNode start="(438, 81)" end="(438, 82)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(438, 83)" end="(438, 92)">
                <AtomNode start="(438, 83)" end="(438, 84)" leading="" trailing=" " val=":"/>
                <OtherNode start="(438, 85)" end="(438, 92)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(438, 85)" end="(438, 86)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(438, 87)" end="(438, 88)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(438, 89)" end="(438, 92)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(438, 89)" end="(438, 90)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(438, 91)" end="(438, 92)">
                      <IdentNode start="(438, 91)" end="(438, 92)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(438, 92)" end="(438, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(438, 94)" end="(439, 52)">
            <AtomNode start="(438, 94)" end="(438, 95)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(439, 5)" end="(439, 52)" kind="«term_=_»">
              <OtherNode start="(439, 5)" end="(439, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(439, 5)" end="(439, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(439, 5)" end="(439, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(439, 5)" end="(439, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(439, 6)" end="(439, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(439, 6)" end="(439, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(439, 14)" end="(439, 16)">
                        <IdentNode start="(439, 14)" end="(439, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(439, 16)" end="(439, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(439, 17)" end="(439, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(439, 18)" end="(439, 22)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="Array.mapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(439, 23)" end="(439, 24)">
                  <IdentNode start="(439, 23)" end="(439, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(439, 25)" end="(439, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(439, 27)" end="(439, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(439, 27)" end="(439, 50)" leading="" trailing=" " raw_val="xs.attach.unattach.mapM" val="xs.attach.unattach.mapM"/>
                <NullNode start="(439, 51)" end="(439, 52)">
                  <IdentNode start="(439, 51)" end="(439, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(439, 53)" end="(440, 17)">
          <AtomNode start="(439, 53)" end="(439, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(439, 56)" end="(440, 17)">
            <AtomNode start="(439, 56)" end="(439, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(440, 3)" end="(440, 17)">
              <TacticTacticseq1IndentedNode start="(440, 3)" end="(440, 17)">
                <NullNode start="(440, 3)" end="(440, 17)">
                  <OtherNode start="(440, 3)" end="(440, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m β&#10;⊢ mapM f (wfParam xs) = mapM f xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(440, 3)" end="(440, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(440, 8)" end="(440, 17)">
                      <AtomNode start="(440, 8)" end="(440, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(440, 9)" end="(440, 16)">
                        <OtherNode start="(440, 9)" end="(440, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(440, 9)" end="(440, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(440, 16)" end="(440, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(442, 1)" end="(445, 17)" name="mapM_unattach" full_name="Array.mapM_unattach">
      <CommandDeclmodifiersNode start="(442, 1)" end="(442, 17)">
        <NullNode/>
        <NullNode start="(442, 1)" end="(442, 17)">
          <OtherNode start="(442, 1)" end="(442, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(442, 1)" end="(442, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(442, 3)" end="(442, 16)">
              <OtherNode start="(442, 3)" end="(442, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(442, 3)" end="(442, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(442, 3)" end="(442, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(442, 16)" end="(442, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(442, 18)" end="(445, 17)" name="mapM_unattach" full_name="Array.mapM_unattach" _is_private_decl="False">
        <AtomNode start="(442, 18)" end="(442, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(442, 26)" end="(442, 39)">
          <IdentNode start="(442, 26)" end="(442, 39)" leading="" trailing=" " raw_val="mapM_unattach" val="mapM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(442, 40)" end="(444, 65)">
          <NullNode start="(442, 40)" end="(442, 119)">
            <OtherNode start="(442, 40)" end="(442, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(442, 40)" end="(442, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(442, 41)" end="(442, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(442, 41)" end="(442, 46)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(442, 47)" end="(442, 48)">
                  <IdentNode start="(442, 47)" end="(442, 48)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(442, 48)" end="(442, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(442, 50)" end="(442, 65)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(442, 50)" end="(442, 51)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(442, 51)" end="(442, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(442, 51)" end="(442, 62)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(442, 63)" end="(442, 64)">
                  <IdentNode start="(442, 63)" end="(442, 64)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(442, 64)" end="(442, 65)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(442, 66)" end="(442, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(442, 66)" end="(442, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(442, 67)" end="(442, 68)">
                <IdentNode start="(442, 67)" end="(442, 68)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(442, 69)" end="(442, 79)">
                <AtomNode start="(442, 69)" end="(442, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(442, 71)" end="(442, 79)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(442, 71)" end="(442, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(442, 73)" end="(442, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(442, 75)" end="(442, 79)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(442, 75)" end="(442, 79)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(442, 79)" end="(442, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(442, 81)" end="(442, 105)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(442, 81)" end="(442, 82)" leading="" trailing="" val="{"/>
              <NullNode start="(442, 82)" end="(442, 84)">
                <IdentNode start="(442, 82)" end="(442, 84)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(442, 85)" end="(442, 104)">
                <AtomNode start="(442, 85)" end="(442, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(442, 87)" end="(442, 104)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(442, 87)" end="(442, 92)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(442, 93)" end="(442, 104)">
                    <OtherNode start="(442, 93)" end="(442, 104)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(442, 93)" end="(442, 94)" leading="" trailing="" val="("/>
                      <OtherNode start="(442, 94)" end="(442, 103)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(442, 94)" end="(442, 101)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(442, 102)" end="(442, 103)">
                          <IdentNode start="(442, 102)" end="(442, 103)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(442, 103)" end="(442, 104)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(442, 104)" end="(442, 105)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(442, 106)" end="(442, 119)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(442, 106)" end="(442, 107)" leading="" trailing="" val="{"/>
              <NullNode start="(442, 107)" end="(442, 108)">
                <IdentNode start="(442, 107)" end="(442, 108)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(442, 109)" end="(442, 118)">
                <AtomNode start="(442, 109)" end="(442, 110)" leading="" trailing=" " val=":"/>
                <OtherNode start="(442, 111)" end="(442, 118)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(442, 111)" end="(442, 112)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(442, 113)" end="(442, 114)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(442, 115)" end="(442, 118)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(442, 115)" end="(442, 116)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(442, 117)" end="(442, 118)">
                      <IdentNode start="(442, 117)" end="(442, 118)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(442, 118)" end="(442, 119)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(442, 120)" end="(444, 65)">
            <AtomNode start="(442, 120)" end="(442, 121)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(443, 5)" end="(444, 65)" kind="«term_=_»">
              <OtherNode start="(443, 5)" end="(443, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(443, 5)" end="(443, 21)" leading="" trailing=" " raw_val="xs.unattach.mapM" val="xs.unattach.mapM"/>
                <NullNode start="(443, 22)" end="(443, 23)">
                  <IdentNode start="(443, 22)" end="(443, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(443, 24)" end="(443, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(443, 26)" end="(444, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(443, 26)" end="(443, 33)" leading="" trailing=" " raw_val="xs.mapM" val="xs.mapM"/>
                <NullNode start="(443, 34)" end="(444, 65)">
                  <OtherNode start="(443, 34)" end="(444, 65)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(443, 34)" end="(443, 37)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(443, 38)" end="(444, 65)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(443, 38)" end="(443, 44)">
                        <OtherNode start="(443, 38)" end="(443, 44)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(443, 38)" end="(443, 39)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(443, 39)" end="(443, 43)">
                            <IdentNode start="(443, 39)" end="(443, 40)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(443, 40)" end="(443, 41)" leading="" trailing=" " val=","/>
                            <IdentNode start="(443, 42)" end="(443, 43)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(443, 43)" end="(443, 44)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(443, 45)" end="(443, 47)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(444, 7)" end="(444, 65)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(444, 7)" end="(444, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(444, 7)" end="(444, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(444, 22)" end="(444, 25)">
                            <IdentNode start="(444, 22)" end="(444, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(444, 24)" end="(444, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(444, 26)" end="(444, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(444, 29)" end="(444, 65)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(444, 29)" end="(444, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(444, 29)" end="(444, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(444, 44)" end="(444, 48)">
                              <IdentNode start="(444, 44)" end="(444, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(444, 46)" end="(444, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(444, 46)" end="(444, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(444, 47)" end="(444, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(444, 49)" end="(444, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(444, 52)" end="(444, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(444, 52)" end="(444, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(444, 54)" end="(444, 65)">
                              <OtherNode start="(444, 54)" end="(444, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(444, 54)" end="(444, 55)" leading="" trailing="" val="("/>
                                <OtherNode start="(444, 55)" end="(444, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(444, 55)" end="(444, 62)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                  <NullNode start="(444, 63)" end="(444, 64)">
                                    <IdentNode start="(444, 63)" end="(444, 64)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(444, 64)" end="(444, 65)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(444, 66)" end="(445, 17)">
          <AtomNode start="(444, 66)" end="(444, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(444, 69)" end="(445, 17)">
            <AtomNode start="(444, 69)" end="(444, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(445, 3)" end="(445, 17)">
              <TacticTacticseq1IndentedNode start="(445, 3)" end="(445, 17)">
                <NullNode start="(445, 3)" end="(445, 17)">
                  <OtherNode start="(445, 3)" end="(445, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : Array (Subtype P)&#10;f : α → m β&#10;⊢ mapM f xs.unattach =&#10;    mapM&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))&#10;      xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(445, 3)" end="(445, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(445, 8)" end="(445, 17)">
                      <AtomNode start="(445, 8)" end="(445, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(445, 9)" end="(445, 16)">
                        <OtherNode start="(445, 9)" end="(445, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(445, 9)" end="(445, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(445, 16)" end="(445, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(447, 1)" end="(453, 34)" name="filterMapM_subtype" full_name="Array.filterMapM_subtype">
      <CommandDeclmodifiersNode start="(447, 1)" end="(447, 8)">
        <NullNode/>
        <NullNode start="(447, 1)" end="(447, 8)">
          <OtherNode start="(447, 1)" end="(447, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(447, 1)" end="(447, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(447, 3)" end="(447, 7)">
              <OtherNode start="(447, 3)" end="(447, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(447, 3)" end="(447, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(447, 3)" end="(447, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(447, 7)" end="(447, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(447, 9)" end="(453, 34)" name="filterMapM_subtype" full_name="Array.filterMapM_subtype" _is_private_decl="False">
        <AtomNode start="(447, 9)" end="(447, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(447, 17)" end="(447, 35)">
          <IdentNode start="(447, 17)" end="(447, 35)" leading="" trailing=" " raw_val="filterMapM_subtype" val="filterMapM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(447, 36)" end="(449, 54)">
          <NullNode start="(447, 36)" end="(448, 111)">
            <OtherNode start="(447, 36)" end="(447, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(447, 36)" end="(447, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(447, 37)" end="(447, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(447, 37)" end="(447, 42)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(447, 43)" end="(447, 44)">
                  <IdentNode start="(447, 43)" end="(447, 44)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(447, 44)" end="(447, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(447, 46)" end="(447, 61)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(447, 46)" end="(447, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(447, 47)" end="(447, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(447, 47)" end="(447, 58)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(447, 59)" end="(447, 60)">
                  <IdentNode start="(447, 59)" end="(447, 60)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(447, 60)" end="(447, 61)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(447, 62)" end="(447, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(447, 62)" end="(447, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(447, 63)" end="(447, 64)">
                <IdentNode start="(447, 63)" end="(447, 64)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(447, 65)" end="(447, 75)">
                <AtomNode start="(447, 65)" end="(447, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(447, 67)" end="(447, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(447, 67)" end="(447, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(447, 69)" end="(447, 70)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(447, 71)" end="(447, 75)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(447, 71)" end="(447, 75)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(447, 75)" end="(447, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(447, 77)" end="(447, 102)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(447, 77)" end="(447, 78)" leading="" trailing="" val="{"/>
              <NullNode start="(447, 78)" end="(447, 80)">
                <IdentNode start="(447, 78)" end="(447, 80)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(447, 81)" end="(447, 101)">
                <AtomNode start="(447, 81)" end="(447, 82)" leading="" trailing=" " val=":"/>
                <OtherNode start="(447, 83)" end="(447, 101)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(447, 83)" end="(447, 88)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(447, 89)" end="(447, 101)">
                    <OtherNode start="(447, 89)" end="(447, 101)" kind="«term{_:_//_}»">
                      <AtomNode start="(447, 89)" end="(447, 90)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(447, 91)" end="(447, 92)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(447, 93)" end="(447, 95)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(447, 96)" end="(447, 99)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(447, 96)" end="(447, 97)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(447, 98)" end="(447, 99)">
                          <IdentNode start="(447, 98)" end="(447, 99)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(447, 100)" end="(447, 101)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(447, 101)" end="(447, 102)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(448, 5)" end="(448, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(448, 5)" end="(448, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(448, 6)" end="(448, 7)">
                <IdentNode start="(448, 6)" end="(448, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(448, 8)" end="(448, 37)">
                <AtomNode start="(448, 8)" end="(448, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(448, 10)" end="(448, 37)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(448, 10)" end="(448, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(448, 10)" end="(448, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(448, 12)" end="(448, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(448, 14)" end="(448, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(448, 17)" end="(448, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(448, 17)" end="(448, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(448, 19)" end="(448, 20)">
                        <IdentNode start="(448, 19)" end="(448, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(448, 21)" end="(448, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(448, 23)" end="(448, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(448, 25)" end="(448, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(448, 25)" end="(448, 26)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(448, 27)" end="(448, 37)">
                      <OtherNode start="(448, 27)" end="(448, 37)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(448, 27)" end="(448, 28)" leading="" trailing="" val="("/>
                        <OtherNode start="(448, 28)" end="(448, 36)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(448, 28)" end="(448, 34)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(448, 35)" end="(448, 36)">
                            <IdentNode start="(448, 35)" end="(448, 36)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(448, 36)" end="(448, 37)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(448, 37)" end="(448, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(448, 39)" end="(448, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(448, 39)" end="(448, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(448, 40)" end="(448, 41)">
                <IdentNode start="(448, 40)" end="(448, 41)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(448, 42)" end="(448, 60)">
                <AtomNode start="(448, 42)" end="(448, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(448, 44)" end="(448, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(448, 44)" end="(448, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(448, 46)" end="(448, 47)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(448, 48)" end="(448, 60)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(448, 48)" end="(448, 49)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(448, 50)" end="(448, 60)">
                      <OtherNode start="(448, 50)" end="(448, 60)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(448, 50)" end="(448, 51)" leading="" trailing="" val="("/>
                        <OtherNode start="(448, 51)" end="(448, 59)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(448, 51)" end="(448, 57)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(448, 58)" end="(448, 59)">
                            <IdentNode start="(448, 58)" end="(448, 59)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(448, 59)" end="(448, 60)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(448, 60)" end="(448, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(448, 62)" end="(448, 90)">
              <AtomNode start="(448, 62)" end="(448, 63)" leading="" trailing="" val="("/>
              <NullNode start="(448, 63)" end="(448, 65)">
                <IdentNode start="(448, 63)" end="(448, 65)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(448, 66)" end="(448, 89)">
                <AtomNode start="(448, 66)" end="(448, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(448, 68)" end="(448, 89)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(448, 68)" end="(448, 69)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(448, 70)" end="(448, 73)">
                    <IdentNode start="(448, 70)" end="(448, 71)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(448, 72)" end="(448, 73)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(448, 73)" end="(448, 74)" leading="" trailing=" " val=","/>
                  <OtherNode start="(448, 75)" end="(448, 89)" kind="«term_=_»">
                    <OtherNode start="(448, 75)" end="(448, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(448, 75)" end="(448, 76)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(448, 77)" end="(448, 83)">
                        <OtherNode start="(448, 77)" end="(448, 83)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(448, 77)" end="(448, 78)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(448, 78)" end="(448, 82)">
                            <IdentNode start="(448, 78)" end="(448, 79)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(448, 79)" end="(448, 80)" leading="" trailing=" " val=","/>
                            <IdentNode start="(448, 81)" end="(448, 82)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(448, 82)" end="(448, 83)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(448, 84)" end="(448, 85)" leading="" trailing=" " val="="/>
                    <OtherNode start="(448, 86)" end="(448, 89)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(448, 86)" end="(448, 87)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(448, 88)" end="(448, 89)">
                        <IdentNode start="(448, 88)" end="(448, 89)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(448, 89)" end="(448, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(448, 91)" end="(448, 111)">
              <AtomNode start="(448, 91)" end="(448, 92)" leading="" trailing="" val="("/>
              <NullNode start="(448, 92)" end="(448, 93)">
                <IdentNode start="(448, 92)" end="(448, 93)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(448, 94)" end="(448, 110)">
                <AtomNode start="(448, 94)" end="(448, 95)" leading="" trailing=" " val=":"/>
                <OtherNode start="(448, 96)" end="(448, 110)" kind="«term_=_»">
                  <IdentNode start="(448, 96)" end="(448, 100)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(448, 101)" end="(448, 102)" leading="" trailing=" " val="="/>
                  <IdentNode start="(448, 103)" end="(448, 110)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(448, 110)" end="(448, 111)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(448, 112)" end="(449, 54)">
            <AtomNode start="(448, 112)" end="(448, 113)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(449, 5)" end="(449, 54)" kind="«term_=_»">
              <OtherNode start="(449, 5)" end="(449, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(449, 5)" end="(449, 18)" leading="" trailing=" " raw_val="xs.filterMapM" val="xs.filterMapM"/>
                <NullNode start="(449, 19)" end="(449, 27)">
                  <IdentNode start="(449, 19)" end="(449, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(449, 21)" end="(449, 22)" kind="num">
                    <AtomNode start="(449, 21)" end="(449, 22)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(449, 23)" end="(449, 27)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(449, 28)" end="(449, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(449, 30)" end="(449, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(449, 30)" end="(449, 52)" leading="" trailing=" " raw_val="xs.unattach.filterMapM" val="xs.unattach.filterMapM"/>
                <NullNode start="(449, 53)" end="(449, 54)">
                  <IdentNode start="(449, 53)" end="(449, 54)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(449, 55)" end="(453, 34)">
          <AtomNode start="(449, 55)" end="(449, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(449, 58)" end="(453, 34)">
            <AtomNode start="(449, 58)" end="(449, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(450, 3)" end="(453, 34)">
              <TacticTacticseq1IndentedNode start="(450, 3)" end="(453, 34)">
                <NullNode start="(450, 3)" end="(453, 34)">
                  <OtherNode start="(450, 3)" end="(450, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;stop : Nat&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;w : stop = xs.size&#10;⊢ filterMapM f xs 0 stop = filterMapM g xs.unattach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ filterMapM f xs = filterMapM g xs.unattach" tactic="subst w">
                    <AtomNode start="(450, 3)" end="(450, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(450, 9)" end="(450, 10)">
                      <IdentNode start="(450, 9)" end="(450, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(451, 3)" end="(451, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ filterMapM f xs = filterMapM g xs.unattach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ filterMapM f { toList := xs } = filterMapM g { toList := xs }.unattach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(451, 3)" end="(451, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(451, 10)" end="(451, 12)">
                      <OtherNode start="(451, 10)" end="(451, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(451, 10)" end="(451, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(451, 13)" end="(451, 22)">
                      <AtomNode start="(451, 13)" end="(451, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(451, 18)" end="(451, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(451, 18)" end="(451, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(451, 18)" end="(451, 22)">
                            <OtherNode start="(451, 18)" end="(451, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(451, 18)" end="(451, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(451, 19)" end="(451, 21)">
                                <OtherNode start="(451, 19)" end="(451, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(451, 19)" end="(451, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(451, 19)" end="(451, 21)">
                                      <OtherNode start="(451, 19)" end="(451, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(451, 19)" end="(451, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(451, 21)" end="(451, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(452, 3)" end="(452, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ filterMapM f { toList := xs } = filterMapM g { toList := xs }.unattach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ List.filterMapM f xs = List.filterMapM (fun a =&amp;gt; g a) xs.unattach" tactic="simp">
                    <AtomNode start="(452, 3)" end="(452, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(453, 3)" end="(453, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ List.filterMapM f xs = List.filterMapM (fun a =&amp;gt; g a) xs.unattach" state_after="no goals" tactic="rw [List.filterMapM_subtype hf]">
                    <AtomNode start="(453, 3)" end="(453, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(453, 6)" end="(453, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(453, 6)" end="(453, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(453, 7)" end="(453, 33)">
                        <OtherNode start="(453, 7)" end="(453, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(453, 7)" end="(453, 33)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(453, 7)" end="(453, 30)" leading="" trailing=" " raw_val="List.filterMapM_subtype" val="List.filterMapM_subtype" full_name="List.filterMapM_subtype" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                            <NullNode start="(453, 31)" end="(453, 33)">
                              <IdentNode start="(453, 31)" end="(453, 33)" leading="" trailing="" raw_val="hf" val="hf"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(453, 33)" end="(453, 34)" leading="" trailing="&#10;&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(456, 1)" end="(459, 17)" name="filterMapM_wfParam" full_name="Array.filterMapM_wfParam">
      <CommandDeclmodifiersNode start="(456, 1)" end="(456, 17)">
        <NullNode/>
        <NullNode start="(456, 1)" end="(456, 17)">
          <OtherNode start="(456, 1)" end="(456, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(456, 1)" end="(456, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(456, 3)" end="(456, 16)">
              <OtherNode start="(456, 3)" end="(456, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(456, 3)" end="(456, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(456, 3)" end="(456, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(456, 16)" end="(456, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(456, 18)" end="(459, 17)" name="filterMapM_wfParam" full_name="Array.filterMapM_wfParam" _is_private_decl="False">
        <AtomNode start="(456, 18)" end="(456, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(456, 26)" end="(456, 44)">
          <IdentNode start="(456, 26)" end="(456, 44)" leading="" trailing=" " raw_val="filterMapM_wfParam" val="filterMapM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(456, 45)" end="(458, 64)">
          <NullNode start="(456, 45)" end="(457, 42)">
            <OtherNode start="(456, 45)" end="(456, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(456, 45)" end="(456, 46)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(456, 46)" end="(456, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(456, 46)" end="(456, 51)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(456, 52)" end="(456, 53)">
                  <IdentNode start="(456, 52)" end="(456, 53)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(456, 53)" end="(456, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(456, 55)" end="(456, 70)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(456, 55)" end="(456, 56)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(456, 56)" end="(456, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(456, 56)" end="(456, 67)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(456, 68)" end="(456, 69)">
                  <IdentNode start="(456, 68)" end="(456, 69)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(456, 69)" end="(456, 70)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(457, 5)" end="(457, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(457, 5)" end="(457, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(457, 6)" end="(457, 8)">
                <IdentNode start="(457, 6)" end="(457, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(457, 9)" end="(457, 18)">
                <AtomNode start="(457, 9)" end="(457, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(457, 11)" end="(457, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(457, 11)" end="(457, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(457, 17)" end="(457, 18)">
                    <IdentNode start="(457, 17)" end="(457, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(457, 18)" end="(457, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(457, 20)" end="(457, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(457, 20)" end="(457, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(457, 21)" end="(457, 22)">
                <IdentNode start="(457, 21)" end="(457, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(457, 23)" end="(457, 41)">
                <AtomNode start="(457, 23)" end="(457, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(457, 25)" end="(457, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(457, 25)" end="(457, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(457, 27)" end="(457, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(457, 29)" end="(457, 41)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(457, 29)" end="(457, 30)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(457, 31)" end="(457, 41)">
                      <OtherNode start="(457, 31)" end="(457, 41)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(457, 31)" end="(457, 32)" leading="" trailing="" val="("/>
                        <OtherNode start="(457, 32)" end="(457, 40)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(457, 32)" end="(457, 38)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(457, 39)" end="(457, 40)">
                            <IdentNode start="(457, 39)" end="(457, 40)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(457, 40)" end="(457, 41)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(457, 41)" end="(457, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(457, 43)" end="(458, 64)">
            <AtomNode start="(457, 43)" end="(457, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(458, 5)" end="(458, 64)" kind="«term_=_»">
              <OtherNode start="(458, 5)" end="(458, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(458, 5)" end="(458, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(458, 5)" end="(458, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(458, 5)" end="(458, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(458, 6)" end="(458, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(458, 6)" end="(458, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(458, 14)" end="(458, 16)">
                        <IdentNode start="(458, 14)" end="(458, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(458, 16)" end="(458, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(458, 17)" end="(458, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(458, 18)" end="(458, 28)" leading="" trailing=" " raw_val="filterMapM" val="filterMapM" full_name="Array.filterMapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(458, 29)" end="(458, 30)">
                  <IdentNode start="(458, 29)" end="(458, 30)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(458, 31)" end="(458, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(458, 33)" end="(458, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(458, 33)" end="(458, 62)" leading="" trailing=" " raw_val="xs.attach.unattach.filterMapM" val="xs.attach.unattach.filterMapM"/>
                <NullNode start="(458, 63)" end="(458, 64)">
                  <IdentNode start="(458, 63)" end="(458, 64)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(458, 65)" end="(459, 17)">
          <AtomNode start="(458, 65)" end="(458, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(458, 68)" end="(459, 17)">
            <AtomNode start="(458, 68)" end="(458, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(459, 3)" end="(459, 17)">
              <TacticTacticseq1IndentedNode start="(459, 3)" end="(459, 17)">
                <NullNode start="(459, 3)" end="(459, 17)">
                  <OtherNode start="(459, 3)" end="(459, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Option β)&#10;⊢ filterMapM f (wfParam xs) = filterMapM f xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(459, 3)" end="(459, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(459, 8)" end="(459, 17)">
                      <AtomNode start="(459, 8)" end="(459, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(459, 9)" end="(459, 16)">
                        <OtherNode start="(459, 9)" end="(459, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(459, 9)" end="(459, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(459, 16)" end="(459, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(461, 1)" end="(465, 17)" name="filterMapM_unattach" full_name="Array.filterMapM_unattach">
      <CommandDeclmodifiersNode start="(461, 1)" end="(461, 17)">
        <NullNode/>
        <NullNode start="(461, 1)" end="(461, 17)">
          <OtherNode start="(461, 1)" end="(461, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(461, 1)" end="(461, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(461, 3)" end="(461, 16)">
              <OtherNode start="(461, 3)" end="(461, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(461, 3)" end="(461, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(461, 3)" end="(461, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(461, 16)" end="(461, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(461, 18)" end="(465, 17)" name="filterMapM_unattach" full_name="Array.filterMapM_unattach" _is_private_decl="False">
        <AtomNode start="(461, 18)" end="(461, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(461, 26)" end="(461, 45)">
          <IdentNode start="(461, 26)" end="(461, 45)" leading="" trailing=" " raw_val="filterMapM_unattach" val="filterMapM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(461, 46)" end="(464, 65)">
          <NullNode start="(461, 46)" end="(462, 67)">
            <OtherNode start="(461, 46)" end="(461, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(461, 46)" end="(461, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(461, 47)" end="(461, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(461, 47)" end="(461, 52)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(461, 53)" end="(461, 54)">
                  <IdentNode start="(461, 53)" end="(461, 54)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(461, 54)" end="(461, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(461, 56)" end="(461, 71)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(461, 56)" end="(461, 57)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(461, 57)" end="(461, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(461, 57)" end="(461, 68)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(461, 69)" end="(461, 70)">
                  <IdentNode start="(461, 69)" end="(461, 70)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(461, 70)" end="(461, 71)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(462, 5)" end="(462, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(462, 5)" end="(462, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(462, 6)" end="(462, 7)">
                <IdentNode start="(462, 6)" end="(462, 7)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(462, 8)" end="(462, 18)">
                <AtomNode start="(462, 8)" end="(462, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(462, 10)" end="(462, 18)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(462, 10)" end="(462, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(462, 12)" end="(462, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(462, 14)" end="(462, 18)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(462, 14)" end="(462, 18)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(462, 18)" end="(462, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(462, 20)" end="(462, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(462, 20)" end="(462, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(462, 21)" end="(462, 23)">
                <IdentNode start="(462, 21)" end="(462, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(462, 24)" end="(462, 43)">
                <AtomNode start="(462, 24)" end="(462, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(462, 26)" end="(462, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(462, 26)" end="(462, 31)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(462, 32)" end="(462, 43)">
                    <OtherNode start="(462, 32)" end="(462, 43)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(462, 32)" end="(462, 33)" leading="" trailing="" val="("/>
                      <OtherNode start="(462, 33)" end="(462, 42)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(462, 33)" end="(462, 40)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(462, 41)" end="(462, 42)">
                          <IdentNode start="(462, 41)" end="(462, 42)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(462, 42)" end="(462, 43)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(462, 43)" end="(462, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(462, 45)" end="(462, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(462, 45)" end="(462, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(462, 46)" end="(462, 47)">
                <IdentNode start="(462, 46)" end="(462, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(462, 48)" end="(462, 66)">
                <AtomNode start="(462, 48)" end="(462, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(462, 50)" end="(462, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(462, 50)" end="(462, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(462, 52)" end="(462, 53)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(462, 54)" end="(462, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(462, 54)" end="(462, 55)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(462, 56)" end="(462, 66)">
                      <OtherNode start="(462, 56)" end="(462, 66)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(462, 56)" end="(462, 57)" leading="" trailing="" val="("/>
                        <OtherNode start="(462, 57)" end="(462, 65)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(462, 57)" end="(462, 63)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(462, 64)" end="(462, 65)">
                            <IdentNode start="(462, 64)" end="(462, 65)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(462, 65)" end="(462, 66)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(462, 66)" end="(462, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(462, 68)" end="(464, 65)">
            <AtomNode start="(462, 68)" end="(462, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(463, 5)" end="(464, 65)" kind="«term_=_»">
              <OtherNode start="(463, 5)" end="(463, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(463, 5)" end="(463, 27)" leading="" trailing=" " raw_val="xs.unattach.filterMapM" val="xs.unattach.filterMapM"/>
                <NullNode start="(463, 28)" end="(463, 29)">
                  <IdentNode start="(463, 28)" end="(463, 29)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(463, 30)" end="(463, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(463, 32)" end="(464, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(463, 32)" end="(463, 45)" leading="" trailing=" " raw_val="xs.filterMapM" val="xs.filterMapM"/>
                <NullNode start="(463, 46)" end="(464, 65)">
                  <OtherNode start="(463, 46)" end="(464, 65)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(463, 46)" end="(463, 49)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(463, 50)" end="(464, 65)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(463, 50)" end="(463, 56)">
                        <OtherNode start="(463, 50)" end="(463, 56)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(463, 50)" end="(463, 51)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(463, 51)" end="(463, 55)">
                            <IdentNode start="(463, 51)" end="(463, 52)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(463, 52)" end="(463, 53)" leading="" trailing=" " val=","/>
                            <IdentNode start="(463, 54)" end="(463, 55)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(463, 55)" end="(463, 56)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(463, 57)" end="(463, 59)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(464, 7)" end="(464, 65)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(464, 7)" end="(464, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(464, 7)" end="(464, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(464, 22)" end="(464, 25)">
                            <IdentNode start="(464, 22)" end="(464, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(464, 24)" end="(464, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(464, 26)" end="(464, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(464, 29)" end="(464, 65)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(464, 29)" end="(464, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(464, 29)" end="(464, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(464, 44)" end="(464, 48)">
                              <IdentNode start="(464, 44)" end="(464, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(464, 46)" end="(464, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(464, 46)" end="(464, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(464, 47)" end="(464, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(464, 49)" end="(464, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(464, 52)" end="(464, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(464, 52)" end="(464, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(464, 54)" end="(464, 65)">
                              <OtherNode start="(464, 54)" end="(464, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(464, 54)" end="(464, 55)" leading="" trailing="" val="("/>
                                <OtherNode start="(464, 55)" end="(464, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(464, 55)" end="(464, 62)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                  <NullNode start="(464, 63)" end="(464, 64)">
                                    <IdentNode start="(464, 63)" end="(464, 64)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(464, 64)" end="(464, 65)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(464, 66)" end="(465, 17)">
          <AtomNode start="(464, 66)" end="(464, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(464, 69)" end="(465, 17)">
            <AtomNode start="(464, 69)" end="(464, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(465, 3)" end="(465, 17)">
              <TacticTacticseq1IndentedNode start="(465, 3)" end="(465, 17)">
                <NullNode start="(465, 3)" end="(465, 17)">
                  <OtherNode start="(465, 3)" end="(465, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : Array (Subtype P)&#10;f : α → m (Option β)&#10;⊢ filterMapM f xs.unattach =&#10;    filterMapM&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))&#10;      xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(465, 3)" end="(465, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(465, 8)" end="(465, 17)">
                      <AtomNode start="(465, 8)" end="(465, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(465, 9)" end="(465, 16)">
                        <OtherNode start="(465, 9)" end="(465, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(465, 9)" end="(465, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(465, 16)" end="(465, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(467, 1)" end="(473, 12)" name="flatMapM_subtype" full_name="Array.flatMapM_subtype">
      <CommandDeclmodifiersNode start="(467, 1)" end="(467, 8)">
        <NullNode/>
        <NullNode start="(467, 1)" end="(467, 8)">
          <OtherNode start="(467, 1)" end="(467, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(467, 1)" end="(467, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(467, 3)" end="(467, 7)">
              <OtherNode start="(467, 3)" end="(467, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(467, 3)" end="(467, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(467, 3)" end="(467, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(467, 7)" end="(467, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(467, 9)" end="(473, 12)" name="flatMapM_subtype" full_name="Array.flatMapM_subtype" _is_private_decl="False">
        <AtomNode start="(467, 9)" end="(467, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(467, 17)" end="(467, 33)">
          <IdentNode start="(467, 17)" end="(467, 33)" leading="" trailing=" " raw_val="flatMapM_subtype" val="flatMapM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(467, 34)" end="(469, 45)">
          <NullNode start="(467, 34)" end="(468, 88)">
            <OtherNode start="(467, 34)" end="(467, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(467, 34)" end="(467, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(467, 35)" end="(467, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(467, 35)" end="(467, 40)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(467, 41)" end="(467, 42)">
                  <IdentNode start="(467, 41)" end="(467, 42)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(467, 42)" end="(467, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(467, 44)" end="(467, 59)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(467, 44)" end="(467, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(467, 45)" end="(467, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(467, 45)" end="(467, 56)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(467, 57)" end="(467, 58)">
                  <IdentNode start="(467, 57)" end="(467, 58)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(467, 58)" end="(467, 59)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(467, 60)" end="(467, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(467, 60)" end="(467, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(467, 61)" end="(467, 62)">
                <IdentNode start="(467, 61)" end="(467, 62)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(467, 63)" end="(467, 73)">
                <AtomNode start="(467, 63)" end="(467, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(467, 65)" end="(467, 73)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(467, 65)" end="(467, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(467, 67)" end="(467, 68)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(467, 69)" end="(467, 73)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(467, 69)" end="(467, 73)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(467, 73)" end="(467, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(467, 75)" end="(467, 100)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(467, 75)" end="(467, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(467, 76)" end="(467, 78)">
                <IdentNode start="(467, 76)" end="(467, 78)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(467, 79)" end="(467, 99)">
                <AtomNode start="(467, 79)" end="(467, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(467, 81)" end="(467, 99)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(467, 81)" end="(467, 86)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(467, 87)" end="(467, 99)">
                    <OtherNode start="(467, 87)" end="(467, 99)" kind="«term{_:_//_}»">
                      <AtomNode start="(467, 87)" end="(467, 88)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(467, 89)" end="(467, 90)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(467, 91)" end="(467, 93)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(467, 94)" end="(467, 97)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(467, 94)" end="(467, 95)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(467, 96)" end="(467, 97)">
                          <IdentNode start="(467, 96)" end="(467, 97)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(467, 98)" end="(467, 99)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(467, 99)" end="(467, 100)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(468, 5)" end="(468, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(468, 5)" end="(468, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(468, 6)" end="(468, 7)">
                <IdentNode start="(468, 6)" end="(468, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(468, 8)" end="(468, 36)">
                <AtomNode start="(468, 8)" end="(468, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(468, 10)" end="(468, 36)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(468, 10)" end="(468, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(468, 10)" end="(468, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(468, 12)" end="(468, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(468, 14)" end="(468, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(468, 17)" end="(468, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(468, 17)" end="(468, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(468, 19)" end="(468, 20)">
                        <IdentNode start="(468, 19)" end="(468, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(468, 21)" end="(468, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(468, 23)" end="(468, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(468, 25)" end="(468, 36)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(468, 25)" end="(468, 26)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(468, 27)" end="(468, 36)">
                      <OtherNode start="(468, 27)" end="(468, 36)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(468, 27)" end="(468, 28)" leading="" trailing="" val="("/>
                        <OtherNode start="(468, 28)" end="(468, 35)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(468, 28)" end="(468, 33)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(468, 34)" end="(468, 35)">
                            <IdentNode start="(468, 34)" end="(468, 35)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(468, 35)" end="(468, 36)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(468, 36)" end="(468, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(468, 38)" end="(468, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(468, 38)" end="(468, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(468, 39)" end="(468, 40)">
                <IdentNode start="(468, 39)" end="(468, 40)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(468, 41)" end="(468, 58)">
                <AtomNode start="(468, 41)" end="(468, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(468, 43)" end="(468, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(468, 43)" end="(468, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(468, 45)" end="(468, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(468, 47)" end="(468, 58)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(468, 47)" end="(468, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(468, 49)" end="(468, 58)">
                      <OtherNode start="(468, 49)" end="(468, 58)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(468, 49)" end="(468, 50)" leading="" trailing="" val="("/>
                        <OtherNode start="(468, 50)" end="(468, 57)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(468, 50)" end="(468, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(468, 56)" end="(468, 57)">
                            <IdentNode start="(468, 56)" end="(468, 57)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(468, 57)" end="(468, 58)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(468, 58)" end="(468, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(468, 60)" end="(468, 88)">
              <AtomNode start="(468, 60)" end="(468, 61)" leading="" trailing="" val="("/>
              <NullNode start="(468, 61)" end="(468, 63)">
                <IdentNode start="(468, 61)" end="(468, 63)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(468, 64)" end="(468, 87)">
                <AtomNode start="(468, 64)" end="(468, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(468, 66)" end="(468, 87)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(468, 66)" end="(468, 67)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(468, 68)" end="(468, 71)">
                    <IdentNode start="(468, 68)" end="(468, 69)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(468, 70)" end="(468, 71)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(468, 71)" end="(468, 72)" leading="" trailing=" " val=","/>
                  <OtherNode start="(468, 73)" end="(468, 87)" kind="«term_=_»">
                    <OtherNode start="(468, 73)" end="(468, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(468, 73)" end="(468, 74)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(468, 75)" end="(468, 81)">
                        <OtherNode start="(468, 75)" end="(468, 81)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(468, 75)" end="(468, 76)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(468, 76)" end="(468, 80)">
                            <IdentNode start="(468, 76)" end="(468, 77)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(468, 77)" end="(468, 78)" leading="" trailing=" " val=","/>
                            <IdentNode start="(468, 79)" end="(468, 80)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(468, 80)" end="(468, 81)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(468, 82)" end="(468, 83)" leading="" trailing=" " val="="/>
                    <OtherNode start="(468, 84)" end="(468, 87)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(468, 84)" end="(468, 85)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(468, 86)" end="(468, 87)">
                        <IdentNode start="(468, 86)" end="(468, 87)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(468, 87)" end="(468, 88)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(468, 89)" end="(469, 45)">
            <AtomNode start="(468, 89)" end="(468, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(469, 5)" end="(469, 45)" kind="«term_=_»">
              <OtherNode start="(469, 5)" end="(469, 20)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(469, 5)" end="(469, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(469, 6)" end="(469, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(469, 6)" end="(469, 17)" leading="" trailing=" " raw_val="xs.flatMapM" val="xs.flatMapM"/>
                  <NullNode start="(469, 18)" end="(469, 19)">
                    <IdentNode start="(469, 18)" end="(469, 19)" leading="" trailing="" raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(469, 19)" end="(469, 20)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(469, 21)" end="(469, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(469, 23)" end="(469, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(469, 23)" end="(469, 43)" leading="" trailing=" " raw_val="xs.unattach.flatMapM" val="xs.unattach.flatMapM"/>
                <NullNode start="(469, 44)" end="(469, 45)">
                  <IdentNode start="(469, 44)" end="(469, 45)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(469, 46)" end="(473, 12)">
          <AtomNode start="(469, 46)" end="(469, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(469, 49)" end="(473, 12)">
            <AtomNode start="(469, 49)" end="(469, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(470, 3)" end="(473, 12)">
              <TacticTacticseq1IndentedNode start="(470, 3)" end="(473, 12)">
                <NullNode start="(470, 3)" end="(473, 12)">
                  <OtherNode start="(470, 3)" end="(470, 22)" kind="Lean.Parser.Tactic.rcases" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → m (Array β)&#10;g : α → m (Array β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ flatMapM f xs = flatMapM g xs.unattach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Array β)&#10;g : α → m (Array β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ flatMapM f { toList := xs } = flatMapM g { toList := xs }.unattach" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(470, 3)" end="(470, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(470, 10)" end="(470, 12)">
                      <OtherNode start="(470, 10)" end="(470, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(470, 10)" end="(470, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(470, 13)" end="(470, 22)">
                      <AtomNode start="(470, 13)" end="(470, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(470, 18)" end="(470, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(470, 18)" end="(470, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(470, 18)" end="(470, 22)">
                            <OtherNode start="(470, 18)" end="(470, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(470, 18)" end="(470, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(470, 19)" end="(470, 21)">
                                <OtherNode start="(470, 19)" end="(470, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(470, 19)" end="(470, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(470, 19)" end="(470, 21)">
                                      <OtherNode start="(470, 19)" end="(470, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(470, 19)" end="(470, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(470, 21)" end="(470, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(471, 3)" end="(471, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Array β)&#10;g : α → m (Array β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ flatMapM f { toList := xs } = flatMapM g { toList := xs }.unattach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Array β)&#10;g : α → m (Array β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; f a) xs = List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; g a) xs.unattach" tactic="simp">
                    <AtomNode start="(471, 3)" end="(471, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(472, 3)" end="(472, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Array β)&#10;g : α → m (Array β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; f a) xs = List.flatMapM (fun a =&amp;gt; toList &amp;lt;$&amp;gt; g a) xs.unattach" state_after="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Array β)&#10;g : α → m (Array β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ ∀ (x : α) (h : p x), toList &amp;lt;$&amp;gt; f ⟨x, h⟩ = toList &amp;lt;$&amp;gt; g x" tactic="rw [List.flatMapM_subtype]">
                    <AtomNode start="(472, 3)" end="(472, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(472, 6)" end="(472, 29)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(472, 6)" end="(472, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(472, 7)" end="(472, 28)">
                        <OtherNode start="(472, 7)" end="(472, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(472, 7)" end="(472, 28)" leading="" trailing="" raw_val="List.flatMapM_subtype" val="List.flatMapM_subtype" full_name="List.flatMapM_subtype" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(472, 28)" end="(472, 29)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(473, 3)" end="(473, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Array β)&#10;g : α → m (Array β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : List { x // p x }&#10;⊢ ∀ (x : α) (h : p x), toList &amp;lt;$&amp;gt; f ⟨x, h⟩ = toList &amp;lt;$&amp;gt; g x" state_after="no goals" tactic="simp [hf]">
                    <AtomNode start="(473, 3)" end="(473, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(473, 8)" end="(473, 12)">
                      <AtomNode start="(473, 8)" end="(473, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(473, 9)" end="(473, 11)">
                        <OtherNode start="(473, 9)" end="(473, 11)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(473, 9)" end="(473, 11)" leading="" trailing="" raw_val="hf" val="hf"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(473, 11)" end="(473, 12)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(475, 1)" end="(478, 17)" name="flatMapM_wfParam" full_name="Array.flatMapM_wfParam">
      <CommandDeclmodifiersNode start="(475, 1)" end="(475, 17)">
        <NullNode/>
        <NullNode start="(475, 1)" end="(475, 17)">
          <OtherNode start="(475, 1)" end="(475, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(475, 1)" end="(475, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(475, 3)" end="(475, 16)">
              <OtherNode start="(475, 3)" end="(475, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(475, 3)" end="(475, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(475, 3)" end="(475, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(475, 16)" end="(475, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(475, 18)" end="(478, 17)" name="flatMapM_wfParam" full_name="Array.flatMapM_wfParam" _is_private_decl="False">
        <AtomNode start="(475, 18)" end="(475, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(475, 26)" end="(475, 42)">
          <IdentNode start="(475, 26)" end="(475, 42)" leading="" trailing=" " raw_val="flatMapM_wfParam" val="flatMapM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(475, 43)" end="(477, 60)">
          <NullNode start="(475, 43)" end="(476, 41)">
            <OtherNode start="(475, 43)" end="(475, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(475, 43)" end="(475, 44)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(475, 44)" end="(475, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(475, 44)" end="(475, 49)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(475, 50)" end="(475, 51)">
                  <IdentNode start="(475, 50)" end="(475, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(475, 51)" end="(475, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(475, 53)" end="(475, 68)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(475, 53)" end="(475, 54)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(475, 54)" end="(475, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(475, 54)" end="(475, 65)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(475, 66)" end="(475, 67)">
                  <IdentNode start="(475, 66)" end="(475, 67)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(475, 67)" end="(475, 68)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(476, 5)" end="(476, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(476, 5)" end="(476, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(476, 6)" end="(476, 8)">
                <IdentNode start="(476, 6)" end="(476, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(476, 9)" end="(476, 18)">
                <AtomNode start="(476, 9)" end="(476, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(476, 11)" end="(476, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(476, 11)" end="(476, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(476, 17)" end="(476, 18)">
                    <IdentNode start="(476, 17)" end="(476, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(476, 18)" end="(476, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(476, 20)" end="(476, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(476, 20)" end="(476, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(476, 21)" end="(476, 22)">
                <IdentNode start="(476, 21)" end="(476, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(476, 23)" end="(476, 40)">
                <AtomNode start="(476, 23)" end="(476, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(476, 25)" end="(476, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(476, 25)" end="(476, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(476, 27)" end="(476, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(476, 29)" end="(476, 40)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(476, 29)" end="(476, 30)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(476, 31)" end="(476, 40)">
                      <OtherNode start="(476, 31)" end="(476, 40)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(476, 31)" end="(476, 32)" leading="" trailing="" val="("/>
                        <OtherNode start="(476, 32)" end="(476, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(476, 32)" end="(476, 37)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(476, 38)" end="(476, 39)">
                            <IdentNode start="(476, 38)" end="(476, 39)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(476, 39)" end="(476, 40)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(476, 40)" end="(476, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(476, 42)" end="(477, 60)">
            <AtomNode start="(476, 42)" end="(476, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(477, 5)" end="(477, 60)" kind="«term_=_»">
              <OtherNode start="(477, 5)" end="(477, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(477, 5)" end="(477, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(477, 5)" end="(477, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(477, 5)" end="(477, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(477, 6)" end="(477, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(477, 6)" end="(477, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(477, 14)" end="(477, 16)">
                        <IdentNode start="(477, 14)" end="(477, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(477, 16)" end="(477, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(477, 17)" end="(477, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(477, 18)" end="(477, 26)" leading="" trailing=" " raw_val="flatMapM" val="flatMapM" full_name="Array.flatMapM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(477, 27)" end="(477, 28)">
                  <IdentNode start="(477, 27)" end="(477, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(477, 29)" end="(477, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(477, 31)" end="(477, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(477, 31)" end="(477, 58)" leading="" trailing=" " raw_val="xs.attach.unattach.flatMapM" val="xs.attach.unattach.flatMapM"/>
                <NullNode start="(477, 59)" end="(477, 60)">
                  <IdentNode start="(477, 59)" end="(477, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(477, 61)" end="(478, 17)">
          <AtomNode start="(477, 61)" end="(477, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(477, 64)" end="(478, 17)">
            <AtomNode start="(477, 64)" end="(477, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(478, 3)" end="(478, 17)">
              <TacticTacticseq1IndentedNode start="(478, 3)" end="(478, 17)">
                <NullNode start="(478, 3)" end="(478, 17)">
                  <OtherNode start="(478, 3)" end="(478, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : Array α&#10;f : α → m (Array β)&#10;⊢ flatMapM f (wfParam xs) = flatMapM f xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(478, 3)" end="(478, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(478, 8)" end="(478, 17)">
                      <AtomNode start="(478, 8)" end="(478, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(478, 9)" end="(478, 16)">
                        <OtherNode start="(478, 9)" end="(478, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(478, 9)" end="(478, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(478, 16)" end="(478, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(480, 1)" end="(484, 17)" name="flatMapM_unattach" full_name="Array.flatMapM_unattach">
      <CommandDeclmodifiersNode start="(480, 1)" end="(480, 17)">
        <NullNode/>
        <NullNode start="(480, 1)" end="(480, 17)">
          <OtherNode start="(480, 1)" end="(480, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(480, 1)" end="(480, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(480, 3)" end="(480, 16)">
              <OtherNode start="(480, 3)" end="(480, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(480, 3)" end="(480, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(480, 3)" end="(480, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(480, 16)" end="(480, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(480, 18)" end="(484, 17)" name="flatMapM_unattach" full_name="Array.flatMapM_unattach" _is_private_decl="False">
        <AtomNode start="(480, 18)" end="(480, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(480, 26)" end="(480, 43)">
          <IdentNode start="(480, 26)" end="(480, 43)" leading="" trailing=" " raw_val="flatMapM_unattach" val="flatMapM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(480, 44)" end="(483, 65)">
          <NullNode start="(480, 44)" end="(481, 66)">
            <OtherNode start="(480, 44)" end="(480, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(480, 44)" end="(480, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(480, 45)" end="(480, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(480, 45)" end="(480, 50)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(480, 51)" end="(480, 52)">
                  <IdentNode start="(480, 51)" end="(480, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(480, 52)" end="(480, 53)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(480, 54)" end="(480, 69)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(480, 54)" end="(480, 55)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(480, 55)" end="(480, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(480, 55)" end="(480, 66)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(480, 67)" end="(480, 68)">
                  <IdentNode start="(480, 67)" end="(480, 68)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(480, 68)" end="(480, 69)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(481, 5)" end="(481, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(481, 5)" end="(481, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(481, 6)" end="(481, 7)">
                <IdentNode start="(481, 6)" end="(481, 7)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(481, 8)" end="(481, 18)">
                <AtomNode start="(481, 8)" end="(481, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(481, 10)" end="(481, 18)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(481, 10)" end="(481, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(481, 12)" end="(481, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(481, 14)" end="(481, 18)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(481, 14)" end="(481, 18)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(481, 18)" end="(481, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(481, 20)" end="(481, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(481, 20)" end="(481, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(481, 21)" end="(481, 23)">
                <IdentNode start="(481, 21)" end="(481, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(481, 24)" end="(481, 43)">
                <AtomNode start="(481, 24)" end="(481, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(481, 26)" end="(481, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(481, 26)" end="(481, 31)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(481, 32)" end="(481, 43)">
                    <OtherNode start="(481, 32)" end="(481, 43)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(481, 32)" end="(481, 33)" leading="" trailing="" val="("/>
                      <OtherNode start="(481, 33)" end="(481, 42)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(481, 33)" end="(481, 40)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(481, 41)" end="(481, 42)">
                          <IdentNode start="(481, 41)" end="(481, 42)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(481, 42)" end="(481, 43)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(481, 43)" end="(481, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(481, 45)" end="(481, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(481, 45)" end="(481, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(481, 46)" end="(481, 47)">
                <IdentNode start="(481, 46)" end="(481, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(481, 48)" end="(481, 65)">
                <AtomNode start="(481, 48)" end="(481, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(481, 50)" end="(481, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(481, 50)" end="(481, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(481, 52)" end="(481, 53)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(481, 54)" end="(481, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(481, 54)" end="(481, 55)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(481, 56)" end="(481, 65)">
                      <OtherNode start="(481, 56)" end="(481, 65)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(481, 56)" end="(481, 57)" leading="" trailing="" val="("/>
                        <OtherNode start="(481, 57)" end="(481, 64)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(481, 57)" end="(481, 62)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(481, 63)" end="(481, 64)">
                            <IdentNode start="(481, 63)" end="(481, 64)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(481, 64)" end="(481, 65)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(481, 65)" end="(481, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(481, 67)" end="(483, 65)">
            <AtomNode start="(481, 67)" end="(481, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(482, 5)" end="(483, 65)" kind="«term_=_»">
              <OtherNode start="(482, 5)" end="(482, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(482, 5)" end="(482, 25)" leading="" trailing=" " raw_val="xs.unattach.flatMapM" val="xs.unattach.flatMapM"/>
                <NullNode start="(482, 26)" end="(482, 27)">
                  <IdentNode start="(482, 26)" end="(482, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(482, 28)" end="(482, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(482, 30)" end="(483, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(482, 30)" end="(482, 41)" leading="" trailing=" " raw_val="xs.flatMapM" val="xs.flatMapM"/>
                <NullNode start="(482, 42)" end="(483, 65)">
                  <OtherNode start="(482, 42)" end="(483, 65)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(482, 42)" end="(482, 45)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(482, 46)" end="(483, 65)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(482, 46)" end="(482, 52)">
                        <OtherNode start="(482, 46)" end="(482, 52)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(482, 46)" end="(482, 47)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(482, 47)" end="(482, 51)">
                            <IdentNode start="(482, 47)" end="(482, 48)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(482, 48)" end="(482, 49)" leading="" trailing=" " val=","/>
                            <IdentNode start="(482, 50)" end="(482, 51)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(482, 51)" end="(482, 52)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(482, 53)" end="(482, 55)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(483, 7)" end="(483, 65)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(483, 7)" end="(483, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(483, 7)" end="(483, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(483, 22)" end="(483, 25)">
                            <IdentNode start="(483, 22)" end="(483, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(483, 24)" end="(483, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(483, 26)" end="(483, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(483, 29)" end="(483, 65)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(483, 29)" end="(483, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(483, 29)" end="(483, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(483, 44)" end="(483, 48)">
                              <IdentNode start="(483, 44)" end="(483, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(483, 46)" end="(483, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(483, 46)" end="(483, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(483, 47)" end="(483, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(483, 49)" end="(483, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(483, 52)" end="(483, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(483, 52)" end="(483, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(483, 54)" end="(483, 65)">
                              <OtherNode start="(483, 54)" end="(483, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(483, 54)" end="(483, 55)" leading="" trailing="" val="("/>
                                <OtherNode start="(483, 55)" end="(483, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(483, 55)" end="(483, 62)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                  <NullNode start="(483, 63)" end="(483, 64)">
                                    <IdentNode start="(483, 63)" end="(483, 64)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(483, 64)" end="(483, 65)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(483, 66)" end="(484, 17)">
          <AtomNode start="(483, 66)" end="(483, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(483, 69)" end="(484, 17)">
            <AtomNode start="(483, 69)" end="(483, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(484, 3)" end="(484, 17)">
              <TacticTacticseq1IndentedNode start="(484, 3)" end="(484, 17)">
                <NullNode start="(484, 3)" end="(484, 17)">
                  <OtherNode start="(484, 3)" end="(484, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : Array (Subtype P)&#10;f : α → m (Array β)&#10;⊢ flatMapM f xs.unattach =&#10;    flatMapM&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))&#10;      xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(484, 3)" end="(484, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(484, 8)" end="(484, 17)">
                      <AtomNode start="(484, 8)" end="(484, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(484, 9)" end="(484, 16)">
                        <OtherNode start="(484, 9)" end="(484, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(484, 9)" end="(484, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(484, 16)" end="(484, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(486, 1)" end="(486, 10)" name="Array">
      <AtomNode start="(486, 1)" end="(486, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(486, 5)" end="(486, 10)">
        <IdentNode start="(486, 5)" end="(486, 10)" leading="" trailing="&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(13, 1)" end="(15, 3)" text="# Lemmas about `Array.forIn'` and `Array.forIn`.&#10;-/"/>
    <Comment start="(17, 38)" end="(18, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(18, 39)" end="(20, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(24, 1)" end="(24, 29)" text="## Monadic operations -/"/>
    <Comment start="(26, 1)" end="(26, 16)" text="### mapM -/"/>
    <Comment start="(56, 1)" end="(56, 29)" text="### foldlM and foldrM -/"/>
    <Comment start="(122, 1)" end="(122, 16)" text="### forM -/"/>
    <Comment start="(141, 1)" end="(141, 18)" text="### forIn' -/"/>
    <Comment start="(153, 1)" end="(156, 3)" text="We can express a for loop over an array as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
    <Comment start="(167, 1)" end="(167, 78)" text="We can express a for loop over an array which always yields as a fold. -/"/>
    <Comment start="(195, 1)" end="(198, 3)" text="We can express a for loop over an array as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
    <Comment start="(209, 1)" end="(209, 78)" text="We can express a for loop over an array which always yields as a fold. -/"/>
    <Comment start="(237, 1)" end="(237, 25)" text="### allM and anyM -/"/>
    <Comment start="(249, 1)" end="(249, 33)" text="### findM? and findSomeM? -/"/>
    <Comment start="(281, 1)" end="(281, 81)" text="Variant of `filterM_toArray` with a side condition for the stop position. -/"/>
    <Comment start="(293, 1)" end="(293, 85)" text="Variant of `filterRevM_toArray` with a side condition for the start position. -/"/>
    <Comment start="(311, 1)" end="(311, 84)" text="Variant of `filterMapM_toArray` with a side condition for the stop position. -/"/>
    <Comment start="(378, 1)" end="(378, 95)" text="### Recognizing higher order functions using a function that only depends on the value. -/"/>
    <Comment start="(380, 1)" end="(383, 3)" text="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
    <Comment start="(403, 1)" end="(406, 3)" text="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
    <Comment start="(427, 1)" end="(430, 3)" text="This lemma identifies monadic maps over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
  </Comments>
</TracedFile>
