<TracedFile path="src/lean/Init/Data/Array/Find.lean" md5="ca02b30159a75bbb7559dd6ced8cc35d">
  <FileNode start="(1, 1)" end="(756, 10)">
    <ModuleHeaderNode start="(6, 1)" end="(12, 29)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(12, 29)">
        <ModuleImportNode start="(9, 1)" end="(9, 31)" module="Init.Data.List.Nat.Find" path="src/lean/Init/Data/List/Nat/Find.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 31)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.Find" val="Init.Data.List.Nat.Find"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 30)" module="Init.Data.Array.Lemmas" path="src/lean/Init/Data/Array/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Lemmas" val="Init.Data.Array.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 30)" module="Init.Data.Array.Attach" path="src/lean/Init/Data/Array/Attach.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Attach" val="Init.Data.Array.Attach"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 29)" module="Init.Data.Array.Range" path="src/lean/Init/Data/Array/Range.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 29)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Array.Range" val="Init.Data.Array.Range"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(14, 1)" end="(16, 3)" comment="# Lemmas about `Array.findSome?`, `Array.find?, `Array.findIdx`, `Array.findIdx?`, `Array.idxOf`.&#10;-/">
      <AtomNode start="(14, 1)" end="(14, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(15, 1)" end="(16, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `Array.findSome?`, `Array.find?, `Array.findIdx`, `Array.findIdx?`, `Array.idxOf`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(18, 1)" end="(18, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(18, 1)" end="(18, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(18, 12)" end="(18, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(18, 33)" end="(18, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(19, 1)" end="(19, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(19, 1)" end="(19, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(19, 12)" end="(19, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(19, 34)" end="(19, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(20, 1)" end="(20, 16)" name="Array">
      <AtomNode start="(20, 1)" end="(20, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(20, 11)" end="(20, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(22, 1)" end="(22, 9)">
      <AtomNode start="(22, 1)" end="(22, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(22, 6)" end="(22, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(22, 6)" end="(22, 9)">
          <IdentNode start="(22, 6)" end="(22, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(24, 1)" end="(24, 21)" comment="### findSome? -/">
      <AtomNode start="(24, 1)" end="(24, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(24, 5)" end="(24, 21)" leading="" trailing="&#10;&#10;" val="### findSome? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(26, 1)" end="(26, 83)" name="findSome?_empty" full_name="Array.findSome?_empty">
      <CommandDeclmodifiersNode start="(26, 1)" end="(26, 15)">
        <NullNode/>
        <NullNode start="(26, 1)" end="(26, 15)">
          <OtherNode start="(26, 1)" end="(26, 15)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(26, 1)" end="(26, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(26, 3)" end="(26, 14)">
              <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(26, 3)" end="(26, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(26, 7)" end="(26, 8)" leading="" trailing=" " val=","/>
              <OtherNode start="(26, 9)" end="(26, 14)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(26, 9)" end="(26, 14)" kind="Lean.Parser.Attr.grind">
                  <AtomNode start="(26, 9)" end="(26, 14)" leading="" trailing="" val="grind"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(26, 14)" end="(26, 15)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(26, 16)" end="(26, 83)" name="findSome?_empty" full_name="Array.findSome?_empty" _is_private_decl="False">
        <AtomNode start="(26, 16)" end="(26, 23)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(26, 24)" end="(26, 39)">
          <IdentNode start="(26, 24)" end="(26, 39)" leading="" trailing=" " raw_val="findSome?_empty" val="findSome?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(26, 40)" end="(26, 76)">
          <NullNode/>
          <TermTypespecNode start="(26, 40)" end="(26, 76)">
            <AtomNode start="(26, 40)" end="(26, 41)" leading="" trailing=" " val=":"/>
            <OtherNode start="(26, 42)" end="(26, 76)" kind="«term_=_»">
              <OtherNode start="(26, 42)" end="(26, 69)" kind="Lean.Parser.Term.app">
                <OtherNode start="(26, 42)" end="(26, 67)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(26, 42)" end="(26, 57)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(26, 42)" end="(26, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(26, 43)" end="(26, 46)" kind="«term#[_,]»">
                      <AtomNode start="(26, 43)" end="(26, 45)" leading="" trailing="" val="#["/>
                      <NullNode/>
                      <AtomNode start="(26, 45)" end="(26, 46)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(26, 47)" end="(26, 48)" leading="" trailing=" " val=":"/>
                    <NullNode start="(26, 49)" end="(26, 56)">
                      <OtherNode start="(26, 49)" end="(26, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(26, 49)" end="(26, 54)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(26, 55)" end="(26, 56)">
                          <IdentNode start="(26, 55)" end="(26, 56)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(26, 56)" end="(26, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(26, 57)" end="(26, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(26, 58)" end="(26, 67)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(26, 68)" end="(26, 69)">
                  <IdentNode start="(26, 68)" end="(26, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(26, 70)" end="(26, 71)" leading="" trailing=" " val="="/>
              <IdentNode start="(26, 72)" end="(26, 76)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(26, 77)" end="(26, 83)">
          <AtomNode start="(26, 77)" end="(26, 79)" leading="" trailing=" " val=":="/>
          <IdentNode start="(26, 80)" end="(26, 83)" leading="" trailing="&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(27, 1)" end="(28, 41)" name="findSome?_push" full_name="Array.findSome?_push">
      <CommandDeclmodifiersNode start="(27, 1)" end="(27, 15)">
        <NullNode/>
        <NullNode start="(27, 1)" end="(27, 15)">
          <OtherNode start="(27, 1)" end="(27, 15)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(27, 1)" end="(27, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(27, 3)" end="(27, 14)">
              <OtherNode start="(27, 3)" end="(27, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(27, 3)" end="(27, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(27, 3)" end="(27, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(27, 7)" end="(27, 8)" leading="" trailing=" " val=","/>
              <OtherNode start="(27, 9)" end="(27, 14)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(27, 9)" end="(27, 14)" kind="Lean.Parser.Attr.grind">
                  <AtomNode start="(27, 9)" end="(27, 14)" leading="" trailing="" val="grind"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(27, 14)" end="(27, 15)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(27, 16)" end="(28, 41)" name="findSome?_push" full_name="Array.findSome?_push" _is_private_decl="False">
        <AtomNode start="(27, 16)" end="(27, 23)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(27, 24)" end="(27, 38)">
          <IdentNode start="(27, 24)" end="(27, 38)" leading="" trailing=" " raw_val="findSome?_push" val="findSome?_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(27, 39)" end="(27, 107)">
          <NullNode start="(27, 39)" end="(27, 53)">
            <OtherNode start="(27, 39)" end="(27, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(27, 39)" end="(27, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(27, 40)" end="(27, 42)">
                <IdentNode start="(27, 40)" end="(27, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(27, 43)" end="(27, 52)">
                <AtomNode start="(27, 43)" end="(27, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 45)" end="(27, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(27, 45)" end="(27, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(27, 51)" end="(27, 52)">
                    <IdentNode start="(27, 51)" end="(27, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(27, 52)" end="(27, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(27, 54)" end="(27, 107)">
            <AtomNode start="(27, 54)" end="(27, 55)" leading="" trailing=" " val=":"/>
            <OtherNode start="(27, 56)" end="(27, 107)" kind="«term_=_»">
              <OtherNode start="(27, 56)" end="(27, 79)" kind="Lean.Parser.Term.app">
                <OtherNode start="(27, 56)" end="(27, 77)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(27, 56)" end="(27, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(27, 56)" end="(27, 57)" leading="" trailing="" val="("/>
                    <OtherNode start="(27, 57)" end="(27, 66)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(27, 57)" end="(27, 64)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(27, 65)" end="(27, 66)">
                        <IdentNode start="(27, 65)" end="(27, 66)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(27, 66)" end="(27, 67)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(27, 67)" end="(27, 68)" leading="" trailing="" val="."/>
                  <IdentNode start="(27, 68)" end="(27, 77)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(27, 78)" end="(27, 79)">
                  <IdentNode start="(27, 78)" end="(27, 79)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(27, 80)" end="(27, 81)" leading="" trailing=" " val="="/>
              <OtherNode start="(27, 82)" end="(27, 107)" kind="Lean.Parser.Term.app">
                <OtherNode start="(27, 82)" end="(27, 101)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(27, 82)" end="(27, 98)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(27, 82)" end="(27, 83)" leading="" trailing="" val="("/>
                    <OtherNode start="(27, 83)" end="(27, 97)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(27, 83)" end="(27, 95)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(27, 96)" end="(27, 97)">
                        <IdentNode start="(27, 96)" end="(27, 97)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(27, 97)" end="(27, 98)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(27, 98)" end="(27, 99)" leading="" trailing="" val="."/>
                  <IdentNode start="(27, 99)" end="(27, 101)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(27, 102)" end="(27, 107)">
                  <OtherNode start="(27, 102)" end="(27, 107)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(27, 102)" end="(27, 103)" leading="" trailing="" val="("/>
                    <OtherNode start="(27, 103)" end="(27, 106)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(27, 103)" end="(27, 104)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(27, 105)" end="(27, 106)">
                        <IdentNode start="(27, 105)" end="(27, 106)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(27, 106)" end="(27, 107)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(27, 108)" end="(28, 41)">
          <AtomNode start="(27, 108)" end="(27, 110)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(27, 111)" end="(28, 41)">
            <AtomNode start="(27, 111)" end="(27, 113)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(28, 3)" end="(28, 41)">
              <TacticTacticseq1IndentedNode start="(28, 3)" end="(28, 41)">
                <NullNode start="(28, 3)" end="(28, 41)">
                  <OtherNode start="(28, 3)" end="(28, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;a : α&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;xs : Array α&#10;⊢ findSome? f (xs.push a) = (findSome? f xs).or (f a)" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toList✝ : List α&#10;⊢ findSome? f ({ toList := toList✝ }.push a) = (findSome? f { toList := toList✝ }).or (f a)" tactic="cases xs">
                    <AtomNode start="(28, 3)" end="(28, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(28, 9)" end="(28, 11)">
                      <OtherNode start="(28, 9)" end="(28, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(28, 9)" end="(28, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(28, 11)" end="(28, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(28, 13)" end="(28, 41)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toList✝ : List α&#10;⊢ findSome? f ({ toList := toList✝ }.push a) = (findSome? f { toList := toList✝ }).or (f a)" state_after="no goals" tactic="simp [List.findSome?_append]">
                    <AtomNode start="(28, 13)" end="(28, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(28, 18)" end="(28, 41)">
                      <AtomNode start="(28, 18)" end="(28, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(28, 19)" end="(28, 40)">
                        <OtherNode start="(28, 19)" end="(28, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(28, 19)" end="(28, 40)" leading="" trailing="" raw_val="List.findSome?_append" val="List.findSome?_append" full_name="List.findSome?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(28, 40)" end="(28, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(30, 1)" end="(32, 7)" name="findSome?_singleton" full_name="Array.findSome?_singleton">
      <CommandDeclmodifiersNode start="(30, 1)" end="(30, 9)">
        <NullNode/>
        <NullNode start="(30, 1)" end="(30, 9)">
          <OtherNode start="(30, 1)" end="(30, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(30, 1)" end="(30, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(30, 3)" end="(30, 8)">
              <OtherNode start="(30, 3)" end="(30, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(30, 3)" end="(30, 8)" kind="Lean.Parser.Attr.grind">
                  <AtomNode start="(30, 3)" end="(30, 8)" leading="" trailing="" val="grind"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(30, 8)" end="(30, 9)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(31, 1)" end="(32, 7)" name="findSome?_singleton" full_name="Array.findSome?_singleton" _is_private_decl="False">
        <AtomNode start="(31, 1)" end="(31, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(31, 9)" end="(31, 28)">
          <IdentNode start="(31, 9)" end="(31, 28)" leading="" trailing=" " raw_val="findSome?_singleton" val="findSome?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(31, 29)" end="(31, 80)">
          <NullNode start="(31, 29)" end="(31, 55)">
            <OtherNode start="(31, 29)" end="(31, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(31, 29)" end="(31, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(31, 30)" end="(31, 31)">
                <IdentNode start="(31, 30)" end="(31, 31)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(31, 32)" end="(31, 35)">
                <AtomNode start="(31, 32)" end="(31, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(31, 34)" end="(31, 35)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(31, 35)" end="(31, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(31, 37)" end="(31, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(31, 37)" end="(31, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(31, 38)" end="(31, 39)">
                <IdentNode start="(31, 38)" end="(31, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(31, 40)" end="(31, 54)">
                <AtomNode start="(31, 40)" end="(31, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(31, 42)" end="(31, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(31, 42)" end="(31, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(31, 44)" end="(31, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(31, 46)" end="(31, 54)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(31, 46)" end="(31, 52)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(31, 53)" end="(31, 54)">
                      <IdentNode start="(31, 53)" end="(31, 54)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(31, 54)" end="(31, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(31, 56)" end="(31, 80)">
            <AtomNode start="(31, 56)" end="(31, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(31, 58)" end="(31, 80)" kind="«term_=_»">
              <OtherNode start="(31, 58)" end="(31, 74)" kind="Lean.Parser.Term.app">
                <OtherNode start="(31, 58)" end="(31, 72)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(31, 58)" end="(31, 62)" kind="«term#[_,]»">
                    <AtomNode start="(31, 58)" end="(31, 60)" leading="" trailing="" val="#["/>
                    <NullNode start="(31, 60)" end="(31, 61)">
                      <IdentNode start="(31, 60)" end="(31, 61)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(31, 61)" end="(31, 62)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(31, 62)" end="(31, 63)" leading="" trailing="" val="."/>
                  <IdentNode start="(31, 63)" end="(31, 72)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(31, 73)" end="(31, 74)">
                  <IdentNode start="(31, 73)" end="(31, 74)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(31, 75)" end="(31, 76)" leading="" trailing=" " val="="/>
              <OtherNode start="(31, 77)" end="(31, 80)" kind="Lean.Parser.Term.app">
                <IdentNode start="(31, 77)" end="(31, 78)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(31, 79)" end="(31, 80)">
                  <IdentNode start="(31, 79)" end="(31, 80)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(31, 81)" end="(32, 7)">
          <AtomNode start="(31, 81)" end="(31, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(31, 84)" end="(32, 7)">
            <AtomNode start="(31, 84)" end="(31, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(32, 3)" end="(32, 7)">
              <TacticTacticseq1IndentedNode start="(32, 3)" end="(32, 7)">
                <NullNode start="(32, 3)" end="(32, 7)">
                  <OtherNode start="(32, 3)" end="(32, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;f : α → Option β&#10;⊢ findSome? f #[a] = f a" state_after="no goals" tactic="simp">
                    <AtomNode start="(32, 3)" end="(32, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(34, 1)" end="(35, 21)" name="findSomeRev?_push_of_isSome" full_name="Array.findSomeRev?_push_of_isSome">
      <CommandDeclmodifiersNode start="(34, 1)" end="(34, 8)">
        <NullNode/>
        <NullNode start="(34, 1)" end="(34, 8)">
          <OtherNode start="(34, 1)" end="(34, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(34, 1)" end="(34, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(34, 3)" end="(34, 7)">
              <OtherNode start="(34, 3)" end="(34, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(34, 3)" end="(34, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(34, 3)" end="(34, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(34, 7)" end="(34, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(34, 9)" end="(35, 21)" name="findSomeRev?_push_of_isSome" full_name="Array.findSomeRev?_push_of_isSome" _is_private_decl="False">
        <AtomNode start="(34, 9)" end="(34, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(34, 17)" end="(34, 44)">
          <IdentNode start="(34, 17)" end="(34, 44)" leading="" trailing=" " raw_val="findSomeRev?_push_of_isSome" val="findSomeRev?_push_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(34, 45)" end="(34, 113)">
          <NullNode start="(34, 45)" end="(34, 78)">
            <OtherNode start="(34, 45)" end="(34, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 45)" end="(34, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 46)" end="(34, 48)">
                <IdentNode start="(34, 46)" end="(34, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(34, 49)" end="(34, 58)">
                <AtomNode start="(34, 49)" end="(34, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 51)" end="(34, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(34, 51)" end="(34, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(34, 57)" end="(34, 58)">
                    <IdentNode start="(34, 57)" end="(34, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(34, 58)" end="(34, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(34, 60)" end="(34, 78)">
              <AtomNode start="(34, 60)" end="(34, 61)" leading="" trailing="" val="("/>
              <NullNode start="(34, 61)" end="(34, 62)">
                <IdentNode start="(34, 61)" end="(34, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(34, 63)" end="(34, 77)">
                <AtomNode start="(34, 63)" end="(34, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 65)" end="(34, 77)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(34, 65)" end="(34, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(34, 65)" end="(34, 66)" leading="" trailing="" val="("/>
                    <OtherNode start="(34, 66)" end="(34, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(34, 66)" end="(34, 67)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(34, 68)" end="(34, 69)">
                        <IdentNode start="(34, 68)" end="(34, 69)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(34, 69)" end="(34, 70)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(34, 70)" end="(34, 71)" leading="" trailing="" val="."/>
                  <IdentNode start="(34, 71)" end="(34, 77)" leading="" trailing="" raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(34, 77)" end="(34, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(34, 79)" end="(34, 113)">
            <AtomNode start="(34, 79)" end="(34, 80)" leading="" trailing=" " val=":"/>
            <OtherNode start="(34, 81)" end="(34, 113)" kind="«term_=_»">
              <OtherNode start="(34, 81)" end="(34, 107)" kind="Lean.Parser.Term.app">
                <OtherNode start="(34, 81)" end="(34, 105)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(34, 81)" end="(34, 92)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(34, 81)" end="(34, 82)" leading="" trailing="" val="("/>
                    <OtherNode start="(34, 82)" end="(34, 91)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(34, 82)" end="(34, 89)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(34, 90)" end="(34, 91)">
                        <IdentNode start="(34, 90)" end="(34, 91)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(34, 91)" end="(34, 92)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(34, 92)" end="(34, 93)" leading="" trailing="" val="."/>
                  <IdentNode start="(34, 93)" end="(34, 105)" leading="" trailing=" " raw_val="findSomeRev?" val="findSomeRev?" full_name="Array.findSomeRev?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(34, 106)" end="(34, 107)">
                  <IdentNode start="(34, 106)" end="(34, 107)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 108)" end="(34, 109)" leading="" trailing=" " val="="/>
              <OtherNode start="(34, 110)" end="(34, 113)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 110)" end="(34, 111)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(34, 112)" end="(34, 113)">
                  <IdentNode start="(34, 112)" end="(34, 113)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 114)" end="(35, 21)">
          <AtomNode start="(34, 114)" end="(34, 116)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(34, 117)" end="(35, 21)">
            <AtomNode start="(34, 117)" end="(34, 119)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(35, 3)" end="(35, 21)">
              <TacticTacticseq1IndentedNode start="(35, 3)" end="(35, 21)">
                <NullNode start="(35, 3)" end="(35, 21)">
                  <OtherNode start="(35, 3)" end="(35, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;xs : Array α&#10;h : (f a).isSome = true&#10;⊢ findSomeRev? f (xs.push a) = f a" state_after="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isSome = true&#10;toList✝ : List α&#10;⊢ findSomeRev? f ({ toList := toList✝ }.push a) = f a" tactic="cases xs">
                    <AtomNode start="(35, 3)" end="(35, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(35, 9)" end="(35, 11)">
                      <OtherNode start="(35, 9)" end="(35, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(35, 9)" end="(35, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(35, 11)" end="(35, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(35, 13)" end="(35, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isSome = true&#10;toList✝ : List α&#10;⊢ findSomeRev? f ({ toList := toList✝ }.push a) = f a" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(35, 13)" end="(35, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(37, 1)" end="(38, 21)" name="findSomeRev?_push_of_isNone" full_name="Array.findSomeRev?_push_of_isNone">
      <CommandDeclmodifiersNode start="(37, 1)" end="(37, 8)">
        <NullNode/>
        <NullNode start="(37, 1)" end="(37, 8)">
          <OtherNode start="(37, 1)" end="(37, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(37, 1)" end="(37, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(37, 3)" end="(37, 7)">
              <OtherNode start="(37, 3)" end="(37, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(37, 3)" end="(37, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(37, 3)" end="(37, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(37, 7)" end="(37, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(37, 9)" end="(38, 21)" name="findSomeRev?_push_of_isNone" full_name="Array.findSomeRev?_push_of_isNone" _is_private_decl="False">
        <AtomNode start="(37, 9)" end="(37, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(37, 17)" end="(37, 44)">
          <IdentNode start="(37, 17)" end="(37, 44)" leading="" trailing=" " raw_val="findSomeRev?_push_of_isNone" val="findSomeRev?_push_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(37, 45)" end="(37, 127)">
          <NullNode start="(37, 45)" end="(37, 78)">
            <OtherNode start="(37, 45)" end="(37, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(37, 45)" end="(37, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(37, 46)" end="(37, 48)">
                <IdentNode start="(37, 46)" end="(37, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(37, 49)" end="(37, 58)">
                <AtomNode start="(37, 49)" end="(37, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(37, 51)" end="(37, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(37, 51)" end="(37, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(37, 57)" end="(37, 58)">
                    <IdentNode start="(37, 57)" end="(37, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(37, 58)" end="(37, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(37, 60)" end="(37, 78)">
              <AtomNode start="(37, 60)" end="(37, 61)" leading="" trailing="" val="("/>
              <NullNode start="(37, 61)" end="(37, 62)">
                <IdentNode start="(37, 61)" end="(37, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(37, 63)" end="(37, 77)">
                <AtomNode start="(37, 63)" end="(37, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(37, 65)" end="(37, 77)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(37, 65)" end="(37, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(37, 65)" end="(37, 66)" leading="" trailing="" val="("/>
                    <OtherNode start="(37, 66)" end="(37, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(37, 66)" end="(37, 67)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(37, 68)" end="(37, 69)">
                        <IdentNode start="(37, 68)" end="(37, 69)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(37, 69)" end="(37, 70)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(37, 70)" end="(37, 71)" leading="" trailing="" val="."/>
                  <IdentNode start="(37, 71)" end="(37, 77)" leading="" trailing="" raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(37, 77)" end="(37, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(37, 79)" end="(37, 127)">
            <AtomNode start="(37, 79)" end="(37, 80)" leading="" trailing=" " val=":"/>
            <OtherNode start="(37, 81)" end="(37, 127)" kind="«term_=_»">
              <OtherNode start="(37, 81)" end="(37, 107)" kind="Lean.Parser.Term.app">
                <OtherNode start="(37, 81)" end="(37, 105)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(37, 81)" end="(37, 92)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(37, 81)" end="(37, 82)" leading="" trailing="" val="("/>
                    <OtherNode start="(37, 82)" end="(37, 91)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(37, 82)" end="(37, 89)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(37, 90)" end="(37, 91)">
                        <IdentNode start="(37, 90)" end="(37, 91)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(37, 91)" end="(37, 92)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(37, 92)" end="(37, 93)" leading="" trailing="" val="."/>
                  <IdentNode start="(37, 93)" end="(37, 105)" leading="" trailing=" " raw_val="findSomeRev?" val="findSomeRev?" full_name="Array.findSomeRev?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(37, 106)" end="(37, 107)">
                  <IdentNode start="(37, 106)" end="(37, 107)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(37, 108)" end="(37, 109)" leading="" trailing=" " val="="/>
              <OtherNode start="(37, 110)" end="(37, 127)" kind="Lean.Parser.Term.app">
                <IdentNode start="(37, 110)" end="(37, 125)" leading="" trailing=" " raw_val="xs.findSomeRev?" val="xs.findSomeRev?"/>
                <NullNode start="(37, 126)" end="(37, 127)">
                  <IdentNode start="(37, 126)" end="(37, 127)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(37, 128)" end="(38, 21)">
          <AtomNode start="(37, 128)" end="(37, 130)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(37, 131)" end="(38, 21)">
            <AtomNode start="(37, 131)" end="(37, 133)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(38, 3)" end="(38, 21)">
              <TacticTacticseq1IndentedNode start="(38, 3)" end="(38, 21)">
                <NullNode start="(38, 3)" end="(38, 21)">
                  <OtherNode start="(38, 3)" end="(38, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;xs : Array α&#10;h : (f a).isNone = true&#10;⊢ findSomeRev? f (xs.push a) = findSomeRev? f xs" state_after="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isNone = true&#10;toList✝ : List α&#10;⊢ findSomeRev? f ({ toList := toList✝ }.push a) = findSomeRev? f { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(38, 3)" end="(38, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(38, 9)" end="(38, 11)">
                      <OtherNode start="(38, 9)" end="(38, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(38, 9)" end="(38, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(38, 11)" end="(38, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(38, 13)" end="(38, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isNone = true&#10;toList✝ : List α&#10;⊢ findSomeRev? f ({ toList := toList✝ }.push a) = findSomeRev? f { toList := toList✝ }" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(38, 13)" end="(38, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(40, 1)" end="(42, 56)" name="exists_of_findSome?_eq_some" full_name="Array.exists_of_findSome?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(40, 1)" end="(42, 56)" name="exists_of_findSome?_eq_some" full_name="Array.exists_of_findSome?_eq_some" _is_private_decl="False">
        <AtomNode start="(40, 1)" end="(40, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(40, 9)" end="(40, 36)">
          <IdentNode start="(40, 9)" end="(40, 36)" leading="" trailing=" " raw_val="exists_of_findSome?_eq_some" val="exists_of_findSome?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(40, 37)" end="(41, 31)">
          <NullNode start="(40, 37)" end="(40, 100)">
            <OtherNode start="(40, 37)" end="(40, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(40, 37)" end="(40, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(40, 38)" end="(40, 39)">
                <IdentNode start="(40, 38)" end="(40, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(40, 40)" end="(40, 54)">
                <AtomNode start="(40, 40)" end="(40, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(40, 42)" end="(40, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(40, 42)" end="(40, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(40, 44)" end="(40, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(40, 46)" end="(40, 54)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 46)" end="(40, 52)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(40, 53)" end="(40, 54)">
                      <IdentNode start="(40, 53)" end="(40, 54)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(40, 54)" end="(40, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(40, 56)" end="(40, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(40, 56)" end="(40, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(40, 57)" end="(40, 59)">
                <IdentNode start="(40, 57)" end="(40, 59)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(40, 60)" end="(40, 69)">
                <AtomNode start="(40, 60)" end="(40, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(40, 62)" end="(40, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(40, 62)" end="(40, 67)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(40, 68)" end="(40, 69)">
                    <IdentNode start="(40, 68)" end="(40, 69)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(40, 69)" end="(40, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(40, 71)" end="(40, 100)">
              <AtomNode start="(40, 71)" end="(40, 72)" leading="" trailing="" val="("/>
              <NullNode start="(40, 72)" end="(40, 73)">
                <IdentNode start="(40, 72)" end="(40, 73)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(40, 74)" end="(40, 99)">
                <AtomNode start="(40, 74)" end="(40, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(40, 76)" end="(40, 99)" kind="«term_=_»">
                  <OtherNode start="(40, 76)" end="(40, 90)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 76)" end="(40, 88)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                    <NullNode start="(40, 89)" end="(40, 90)">
                      <IdentNode start="(40, 89)" end="(40, 90)" leading="" trailing=" " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(40, 91)" end="(40, 92)" leading="" trailing=" " val="="/>
                  <OtherNode start="(40, 93)" end="(40, 99)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 93)" end="(40, 97)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(40, 98)" end="(40, 99)">
                      <IdentNode start="(40, 98)" end="(40, 99)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(40, 99)" end="(40, 100)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(40, 101)" end="(41, 31)">
            <AtomNode start="(40, 101)" end="(40, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(41, 5)" end="(41, 31)" kind="«term∃_,_»">
              <AtomNode start="(41, 5)" end="(41, 6)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(41, 7)" end="(41, 8)" kind="Lean.explicitBinders">
                <OtherNode start="(41, 7)" end="(41, 8)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(41, 7)" end="(41, 8)">
                    <LeanBinderidentNode start="(41, 7)" end="(41, 8)">
                      <IdentNode start="(41, 7)" end="(41, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(41, 8)" end="(41, 9)" leading="" trailing=" " val=","/>
              <OtherNode start="(41, 10)" end="(41, 31)" kind="«term_∧_»">
                <OtherNode start="(41, 10)" end="(41, 16)" kind="«term_∈_»">
                  <IdentNode start="(41, 10)" end="(41, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(41, 12)" end="(41, 13)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(41, 14)" end="(41, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(41, 17)" end="(41, 18)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(41, 19)" end="(41, 31)" kind="«term_=_»">
                  <OtherNode start="(41, 19)" end="(41, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(41, 19)" end="(41, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(41, 21)" end="(41, 22)">
                      <IdentNode start="(41, 21)" end="(41, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(41, 23)" end="(41, 24)" leading="" trailing=" " val="="/>
                  <OtherNode start="(41, 25)" end="(41, 31)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(41, 25)" end="(41, 29)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(41, 30)" end="(41, 31)">
                      <IdentNode start="(41, 30)" end="(41, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(41, 32)" end="(42, 56)">
          <AtomNode start="(41, 32)" end="(41, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(41, 35)" end="(42, 56)">
            <AtomNode start="(41, 35)" end="(41, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(42, 3)" end="(42, 56)">
              <TacticTacticseq1IndentedNode start="(42, 3)" end="(42, 56)">
                <NullNode start="(42, 3)" end="(42, 56)">
                  <OtherNode start="(42, 3)" end="(42, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;xs : Array α&#10;w : findSome? f xs = some b&#10;⊢ ∃ a, a ∈ xs ∧ f a = some b" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;toList✝ : List α&#10;w : findSome? f { toList := toList✝ } = some b&#10;⊢ ∃ a, a ∈ { toList := toList✝ } ∧ f a = some b" tactic="cases xs">
                    <AtomNode start="(42, 3)" end="(42, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(42, 9)" end="(42, 11)">
                      <OtherNode start="(42, 9)" end="(42, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(42, 9)" end="(42, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(42, 11)" end="(42, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(42, 13)" end="(42, 56)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;toList✝ : List α&#10;w : findSome? f { toList := toList✝ } = some b&#10;⊢ ∃ a, a ∈ { toList := toList✝ } ∧ f a = some b" state_after="no goals" tactic="simp_all [List.exists_of_findSome?_eq_some]">
                    <AtomNode start="(42, 13)" end="(42, 21)" leading="" trailing=" " val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(42, 22)" end="(42, 56)">
                      <AtomNode start="(42, 22)" end="(42, 23)" leading="" trailing="" val="["/>
                      <NullNode start="(42, 23)" end="(42, 55)">
                        <OtherNode start="(42, 23)" end="(42, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(42, 23)" end="(42, 55)" leading="" trailing="" raw_val="List.exists_of_findSome?_eq_some" val="List.exists_of_findSome?_eq_some" full_name="List.exists_of_findSome?_eq_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(42, 55)" end="(42, 56)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(44, 1)" end="(45, 17)" name="findSome?_eq_none_iff" full_name="Array.findSome?_eq_none_iff">
      <CommandDeclmodifiersNode start="(44, 1)" end="(44, 8)">
        <NullNode/>
        <NullNode start="(44, 1)" end="(44, 8)">
          <OtherNode start="(44, 1)" end="(44, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(44, 1)" end="(44, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(44, 3)" end="(44, 7)">
              <OtherNode start="(44, 3)" end="(44, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(44, 3)" end="(44, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(44, 3)" end="(44, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(44, 7)" end="(44, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(44, 9)" end="(45, 17)" name="findSome?_eq_none_iff" full_name="Array.findSome?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(44, 9)" end="(44, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(44, 17)" end="(44, 38)">
          <IdentNode start="(44, 17)" end="(44, 38)" leading="" trailing=" " raw_val="findSome?_eq_none_iff" val="findSome?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(44, 39)" end="(44, 85)">
          <NullNode/>
          <TermTypespecNode start="(44, 39)" end="(44, 85)">
            <AtomNode start="(44, 39)" end="(44, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(44, 41)" end="(44, 85)" kind="«term_↔_»">
              <OtherNode start="(44, 41)" end="(44, 62)" kind="«term_=_»">
                <OtherNode start="(44, 41)" end="(44, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(44, 41)" end="(44, 50)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(44, 51)" end="(44, 55)">
                    <IdentNode start="(44, 51)" end="(44, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(44, 53)" end="(44, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(44, 56)" end="(44, 57)" leading="" trailing=" " val="="/>
                <IdentNode start="(44, 58)" end="(44, 62)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(44, 63)" end="(44, 64)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(44, 65)" end="(44, 85)" kind="Lean.«term∀__,_»">
                <AtomNode start="(44, 65)" end="(44, 66)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(44, 67)" end="(44, 68)">
                  <IdentNode start="(44, 67)" end="(44, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(44, 69)" end="(44, 73)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(44, 69)" end="(44, 70)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(44, 71)" end="(44, 73)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(44, 73)" end="(44, 74)" leading="" trailing=" " val=","/>
                <OtherNode start="(44, 75)" end="(44, 85)" kind="«term_=_»">
                  <OtherNode start="(44, 75)" end="(44, 78)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(44, 75)" end="(44, 76)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(44, 77)" end="(44, 78)">
                      <IdentNode start="(44, 77)" end="(44, 78)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(44, 79)" end="(44, 80)" leading="" trailing=" " val="="/>
                  <IdentNode start="(44, 81)" end="(44, 85)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(44, 86)" end="(45, 17)">
          <AtomNode start="(44, 86)" end="(44, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(44, 89)" end="(45, 17)">
            <AtomNode start="(44, 89)" end="(44, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(45, 3)" end="(45, 17)">
              <TacticTacticseq1IndentedNode start="(45, 3)" end="(45, 17)">
                <NullNode start="(45, 3)" end="(45, 17)">
                  <OtherNode start="(45, 3)" end="(45, 11)" kind="Lean.Parser.Tactic.cases" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;p : α✝¹ → Option α✝&#10;xs : Array α✝¹&#10;⊢ findSome? p xs = none ↔ ∀ (x : α✝¹), x ∈ xs → p x = none" state_after="case mk&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;p : α✝¹ → Option α✝&#10;toList✝ : List α✝¹&#10;⊢ findSome? p { toList := toList✝ } = none ↔ ∀ (x : α✝¹), x ∈ { toList := toList✝ } → p x = none" tactic="cases xs">
                    <AtomNode start="(45, 3)" end="(45, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(45, 9)" end="(45, 11)">
                      <OtherNode start="(45, 9)" end="(45, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(45, 9)" end="(45, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(45, 11)" end="(45, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(45, 13)" end="(45, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;p : α✝¹ → Option α✝&#10;toList✝ : List α✝¹&#10;⊢ findSome? p { toList := toList✝ } = none ↔ ∀ (x : α✝¹), x ∈ { toList := toList✝ } → p x = none" state_after="no goals" tactic="simp">
                    <AtomNode start="(45, 13)" end="(45, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(47, 1)" end="(49, 17)" name="findSome?_isSome_iff" full_name="Array.findSome?_isSome_iff">
      <CommandDeclmodifiersNode start="(47, 1)" end="(47, 8)">
        <NullNode/>
        <NullNode start="(47, 1)" end="(47, 8)">
          <OtherNode start="(47, 1)" end="(47, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(47, 1)" end="(47, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(47, 3)" end="(47, 7)">
              <OtherNode start="(47, 3)" end="(47, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(47, 3)" end="(47, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(47, 3)" end="(47, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(47, 7)" end="(47, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(47, 9)" end="(49, 17)" name="findSome?_isSome_iff" full_name="Array.findSome?_isSome_iff" _is_private_decl="False">
        <AtomNode start="(47, 9)" end="(47, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(47, 17)" end="(47, 37)">
          <IdentNode start="(47, 17)" end="(47, 37)" leading="" trailing=" " raw_val="findSome?_isSome_iff" val="findSome?_isSome_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(47, 38)" end="(48, 57)">
          <NullNode start="(47, 38)" end="(47, 71)">
            <OtherNode start="(47, 38)" end="(47, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(47, 38)" end="(47, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(47, 39)" end="(47, 40)">
                <IdentNode start="(47, 39)" end="(47, 40)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(47, 41)" end="(47, 55)">
                <AtomNode start="(47, 41)" end="(47, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 43)" end="(47, 55)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(47, 43)" end="(47, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(47, 45)" end="(47, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(47, 47)" end="(47, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(47, 47)" end="(47, 53)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(47, 54)" end="(47, 55)">
                      <IdentNode start="(47, 54)" end="(47, 55)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(47, 55)" end="(47, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(47, 57)" end="(47, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(47, 57)" end="(47, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(47, 58)" end="(47, 60)">
                <IdentNode start="(47, 58)" end="(47, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(47, 61)" end="(47, 70)">
                <AtomNode start="(47, 61)" end="(47, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 63)" end="(47, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(47, 63)" end="(47, 68)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(47, 69)" end="(47, 70)">
                    <IdentNode start="(47, 69)" end="(47, 70)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(47, 70)" end="(47, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(47, 72)" end="(48, 57)">
            <AtomNode start="(47, 72)" end="(47, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(48, 5)" end="(48, 57)" kind="«term_↔_»">
              <OtherNode start="(48, 5)" end="(48, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(48, 5)" end="(48, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(48, 5)" end="(48, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(48, 6)" end="(48, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(48, 6)" end="(48, 18)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                    <NullNode start="(48, 19)" end="(48, 20)">
                      <IdentNode start="(48, 19)" end="(48, 20)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(48, 20)" end="(48, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(48, 21)" end="(48, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(48, 22)" end="(48, 28)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(48, 29)" end="(48, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(48, 31)" end="(48, 57)" kind="«term∃_,_»">
                <AtomNode start="(48, 31)" end="(48, 32)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(48, 33)" end="(48, 34)" kind="Lean.explicitBinders">
                  <OtherNode start="(48, 33)" end="(48, 34)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(48, 33)" end="(48, 34)">
                      <LeanBinderidentNode start="(48, 33)" end="(48, 34)">
                        <IdentNode start="(48, 33)" end="(48, 34)" leading="" trailing="" raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(48, 34)" end="(48, 35)" leading="" trailing=" " val=","/>
                <OtherNode start="(48, 36)" end="(48, 57)" kind="«term_∧_»">
                  <OtherNode start="(48, 36)" end="(48, 42)" kind="«term_∈_»">
                    <IdentNode start="(48, 36)" end="(48, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(48, 38)" end="(48, 39)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(48, 40)" end="(48, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(48, 43)" end="(48, 44)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(48, 45)" end="(48, 57)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(48, 45)" end="(48, 50)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(48, 45)" end="(48, 46)" leading="" trailing="" val="("/>
                      <OtherNode start="(48, 46)" end="(48, 49)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(48, 46)" end="(48, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(48, 48)" end="(48, 49)">
                          <IdentNode start="(48, 48)" end="(48, 49)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(48, 49)" end="(48, 50)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(48, 50)" end="(48, 51)" leading="" trailing="" val="."/>
                    <IdentNode start="(48, 51)" end="(48, 57)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(48, 58)" end="(49, 17)">
          <AtomNode start="(48, 58)" end="(48, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(48, 61)" end="(49, 17)">
            <AtomNode start="(48, 61)" end="(48, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(49, 3)" end="(49, 17)">
              <TacticTacticseq1IndentedNode start="(49, 3)" end="(49, 17)">
                <NullNode start="(49, 3)" end="(49, 17)">
                  <OtherNode start="(49, 3)" end="(49, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;⊢ (findSome? f xs).isSome = true ↔ ∃ x, x ∈ xs ∧ (f x).isSome = true" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (findSome? f { toList := toList✝ }).isSome = true ↔ ∃ x, x ∈ { toList := toList✝ } ∧ (f x).isSome = true" tactic="cases xs">
                    <AtomNode start="(49, 3)" end="(49, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(49, 9)" end="(49, 11)">
                      <OtherNode start="(49, 9)" end="(49, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(49, 9)" end="(49, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(49, 11)" end="(49, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(49, 13)" end="(49, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (findSome? f { toList := toList✝ }).isSome = true ↔ ∃ x, x ∈ { toList := toList✝ } ∧ (f x).isSome = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(49, 13)" end="(49, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(51, 1)" end="(59, 85)" name="findSome?_eq_some_iff" full_name="Array.findSome?_eq_some_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(51, 1)" end="(59, 85)" name="findSome?_eq_some_iff" full_name="Array.findSome?_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(51, 1)" end="(51, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(51, 9)" end="(51, 30)">
          <IdentNode start="(51, 9)" end="(51, 30)" leading="" trailing=" " raw_val="findSome?_eq_some_iff" val="findSome?_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(51, 31)" end="(52, 130)">
          <NullNode start="(51, 31)" end="(51, 72)">
            <OtherNode start="(51, 31)" end="(51, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(51, 31)" end="(51, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(51, 32)" end="(51, 33)">
                <IdentNode start="(51, 32)" end="(51, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(51, 34)" end="(51, 48)">
                <AtomNode start="(51, 34)" end="(51, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(51, 36)" end="(51, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(51, 36)" end="(51, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(51, 38)" end="(51, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(51, 40)" end="(51, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(51, 40)" end="(51, 46)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(51, 47)" end="(51, 48)">
                      <IdentNode start="(51, 47)" end="(51, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(51, 48)" end="(51, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(51, 50)" end="(51, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(51, 50)" end="(51, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(51, 51)" end="(51, 53)">
                <IdentNode start="(51, 51)" end="(51, 53)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(51, 54)" end="(51, 63)">
                <AtomNode start="(51, 54)" end="(51, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(51, 56)" end="(51, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(51, 56)" end="(51, 61)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(51, 62)" end="(51, 63)">
                    <IdentNode start="(51, 62)" end="(51, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(51, 63)" end="(51, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(51, 65)" end="(51, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(51, 65)" end="(51, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(51, 66)" end="(51, 67)">
                <IdentNode start="(51, 66)" end="(51, 67)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(51, 68)" end="(51, 71)">
                <AtomNode start="(51, 68)" end="(51, 69)" leading="" trailing=" " val=":"/>
                <IdentNode start="(51, 70)" end="(51, 71)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(51, 71)" end="(51, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(51, 73)" end="(52, 130)">
            <AtomNode start="(51, 73)" end="(51, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(52, 5)" end="(52, 130)" kind="«term_↔_»">
              <OtherNode start="(52, 5)" end="(52, 28)" kind="«term_=_»">
                <OtherNode start="(52, 5)" end="(52, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(52, 5)" end="(52, 17)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                  <NullNode start="(52, 18)" end="(52, 19)">
                    <IdentNode start="(52, 18)" end="(52, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(52, 20)" end="(52, 21)" leading="" trailing=" " val="="/>
                <OtherNode start="(52, 22)" end="(52, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(52, 22)" end="(52, 26)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(52, 27)" end="(52, 28)">
                    <IdentNode start="(52, 27)" end="(52, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(52, 29)" end="(52, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(52, 31)" end="(52, 130)" kind="«term∃_,_»">
                <AtomNode start="(52, 31)" end="(52, 32)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(52, 33)" end="(52, 70)" kind="Lean.explicitBinders">
                  <NullNode start="(52, 33)" end="(52, 70)">
                    <OtherNode start="(52, 33)" end="(52, 47)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(52, 33)" end="(52, 34)" leading="" trailing="" val="("/>
                      <NullNode start="(52, 34)" end="(52, 36)">
                        <LeanBinderidentNode start="(52, 34)" end="(52, 36)">
                          <IdentNode start="(52, 34)" end="(52, 36)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(52, 37)" end="(52, 38)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(52, 39)" end="(52, 46)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(52, 39)" end="(52, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(52, 45)" end="(52, 46)">
                          <IdentNode start="(52, 45)" end="(52, 46)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(52, 46)" end="(52, 47)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(52, 48)" end="(52, 55)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(52, 48)" end="(52, 49)" leading="" trailing="" val="("/>
                      <NullNode start="(52, 49)" end="(52, 50)">
                        <LeanBinderidentNode start="(52, 49)" end="(52, 50)">
                          <IdentNode start="(52, 49)" end="(52, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(52, 51)" end="(52, 52)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(52, 53)" end="(52, 54)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(52, 54)" end="(52, 55)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(52, 56)" end="(52, 70)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(52, 56)" end="(52, 57)" leading="" trailing="" val="("/>
                      <NullNode start="(52, 57)" end="(52, 59)">
                        <LeanBinderidentNode start="(52, 57)" end="(52, 59)">
                          <IdentNode start="(52, 57)" end="(52, 59)" leading="" trailing=" " raw_val="zs" val="zs"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(52, 60)" end="(52, 61)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(52, 62)" end="(52, 69)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(52, 62)" end="(52, 67)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(52, 68)" end="(52, 69)">
                          <IdentNode start="(52, 68)" end="(52, 69)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(52, 69)" end="(52, 70)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(52, 70)" end="(52, 71)" leading="" trailing=" " val=","/>
                <OtherNode start="(52, 72)" end="(52, 130)" kind="«term_∧_»">
                  <OtherNode start="(52, 72)" end="(52, 92)" kind="«term_=_»">
                    <IdentNode start="(52, 72)" end="(52, 74)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <AtomNode start="(52, 75)" end="(52, 76)" leading="" trailing=" " val="="/>
                    <OtherNode start="(52, 77)" end="(52, 92)" kind="«term_++_»">
                      <OtherNode start="(52, 77)" end="(52, 86)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(52, 77)" end="(52, 84)" leading="" trailing=" " raw_val="ys.push" val="ys.push"/>
                        <NullNode start="(52, 85)" end="(52, 86)">
                          <IdentNode start="(52, 85)" end="(52, 86)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(52, 87)" end="(52, 89)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(52, 90)" end="(52, 92)" leading="" trailing=" " raw_val="zs" val="zs"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(52, 93)" end="(52, 94)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(52, 95)" end="(52, 130)" kind="«term_∧_»">
                    <OtherNode start="(52, 95)" end="(52, 107)" kind="«term_=_»">
                      <OtherNode start="(52, 95)" end="(52, 98)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(52, 95)" end="(52, 96)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(52, 97)" end="(52, 98)">
                          <IdentNode start="(52, 97)" end="(52, 98)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(52, 99)" end="(52, 100)" leading="" trailing=" " val="="/>
                      <OtherNode start="(52, 101)" end="(52, 107)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(52, 101)" end="(52, 105)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(52, 106)" end="(52, 107)">
                          <IdentNode start="(52, 106)" end="(52, 107)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(52, 108)" end="(52, 109)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(52, 110)" end="(52, 130)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(52, 110)" end="(52, 111)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(52, 112)" end="(52, 113)">
                        <IdentNode start="(52, 112)" end="(52, 113)" leading="" trailing=" " raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(52, 114)" end="(52, 118)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(52, 114)" end="(52, 115)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(52, 116)" end="(52, 118)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </OtherNode>
                      <AtomNode start="(52, 118)" end="(52, 119)" leading="" trailing=" " val=","/>
                      <OtherNode start="(52, 120)" end="(52, 130)" kind="«term_=_»">
                        <OtherNode start="(52, 120)" end="(52, 123)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(52, 120)" end="(52, 121)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(52, 122)" end="(52, 123)">
                            <IdentNode start="(52, 122)" end="(52, 123)" leading="" trailing=" " raw_val="x" val="x"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(52, 124)" end="(52, 125)" leading="" trailing=" " val="="/>
                        <IdentNode start="(52, 126)" end="(52, 130)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(52, 131)" end="(59, 85)">
          <AtomNode start="(52, 131)" end="(52, 133)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(52, 134)" end="(59, 85)">
            <AtomNode start="(52, 134)" end="(52, 136)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(53, 3)" end="(59, 85)">
              <TacticTacticseq1IndentedNode start="(53, 3)" end="(59, 85)">
                <NullNode start="(53, 3)" end="(59, 85)">
                  <OtherNode start="(53, 3)" end="(53, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;b : β&#10;⊢ findSome? f xs = some b ↔ ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ findSome? f { toList := toList✝ } = some b ↔&#10;    ∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="cases xs">
                    <AtomNode start="(53, 3)" end="(53, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(53, 9)" end="(53, 11)">
                      <OtherNode start="(53, 9)" end="(53, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(53, 9)" end="(53, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(54, 3)" end="(54, 65)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ findSome? f { toList := toList✝ } = some b ↔&#10;    ∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) ↔&#10;    ∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="simp only [List.findSome?_toArray, List.findSome?_eq_some_iff]">
                    <AtomNode start="(54, 3)" end="(54, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(54, 8)" end="(54, 12)">
                      <AtomNode start="(54, 8)" end="(54, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(54, 13)" end="(54, 65)">
                      <AtomNode start="(54, 13)" end="(54, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(54, 14)" end="(54, 64)">
                        <OtherNode start="(54, 14)" end="(54, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(54, 14)" end="(54, 36)" leading="" trailing="" raw_val="List.findSome?_toArray" val="List.findSome?_toArray" full_name="List.findSome?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(54, 36)" end="(54, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(54, 38)" end="(54, 64)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(54, 38)" end="(54, 64)" leading="" trailing="" raw_val="List.findSome?_eq_some_iff" val="List.findSome?_eq_some_iff" full_name="List.findSome?_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(54, 64)" end="(54, 65)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(55, 3)" end="(55, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) ↔&#10;    ∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="constructor">
                    <AtomNode start="(55, 3)" end="(55, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(56, 3)" end="(57, 51)" kind="Lean.cdot" state_before="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="· rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩&#10;  exact ⟨l₁.toArray, a, l₂.toArray, by simp_all⟩">
                    <OtherNode start="(56, 3)" end="(56, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(56, 3)" end="(56, 4)" kind="patternIgnore">
                        <OtherNode start="(56, 3)" end="(56, 4)" kind="token.«· »">
                          <AtomNode start="(56, 3)" end="(56, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(56, 5)" end="(57, 51)">
                      <TacticTacticseq1IndentedNode start="(56, 5)" end="(57, 51)">
                        <NullNode start="(56, 5)" end="(57, 51)">
                          <OtherNode start="(56, 5)" end="(56, 36)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ ys a_1 zs, { toList := l₁ ++ a :: l₂ } = ys.push a_1 ++ zs ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩">
                            <AtomNode start="(56, 5)" end="(56, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(56, 12)" end="(56, 36)">
                              <OtherNode start="(56, 12)" end="(56, 36)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(56, 12)" end="(56, 36)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(56, 12)" end="(56, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(56, 13)" end="(56, 35)">
                                    <OtherNode start="(56, 13)" end="(56, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(56, 13)" end="(56, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(56, 13)" end="(56, 15)">
                                          <OtherNode start="(56, 13)" end="(56, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(56, 13)" end="(56, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(56, 15)" end="(56, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(56, 17)" end="(56, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(56, 17)" end="(56, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(56, 17)" end="(56, 18)">
                                          <OtherNode start="(56, 17)" end="(56, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(56, 17)" end="(56, 18)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(56, 18)" end="(56, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(56, 20)" end="(56, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(56, 20)" end="(56, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(56, 20)" end="(56, 22)">
                                          <OtherNode start="(56, 20)" end="(56, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(56, 20)" end="(56, 22)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(56, 22)" end="(56, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(56, 24)" end="(56, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(56, 24)" end="(56, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(56, 24)" end="(56, 27)">
                                          <OtherNode start="(56, 24)" end="(56, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(56, 24)" end="(56, 27)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(56, 27)" end="(56, 28)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(56, 29)" end="(56, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(56, 29)" end="(56, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(56, 29)" end="(56, 31)">
                                          <OtherNode start="(56, 29)" end="(56, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(56, 29)" end="(56, 31)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(56, 31)" end="(56, 32)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(56, 33)" end="(56, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(56, 33)" end="(56, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(56, 33)" end="(56, 35)">
                                          <OtherNode start="(56, 33)" end="(56, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(56, 33)" end="(56, 35)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(56, 35)" end="(56, 36)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(57, 5)" end="(57, 51)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ ys a_1 zs, { toList := l₁ ++ a :: l₂ } = ys.push a_1 ++ zs ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="no goals" tactic="exact ⟨l₁.toArray, a, l₂.toArray, by simp_all⟩">
                            <AtomNode start="(57, 5)" end="(57, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(57, 11)" end="(57, 51)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(57, 11)" end="(57, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(57, 12)" end="(57, 50)">
                                <IdentNode start="(57, 12)" end="(57, 22)" leading="" trailing="" raw_val="l₁.toArray" val="l₁.toArray"/>
                                <AtomNode start="(57, 22)" end="(57, 23)" leading="" trailing=" " val=","/>
                                <IdentNode start="(57, 24)" end="(57, 25)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(57, 25)" end="(57, 26)" leading="" trailing=" " val=","/>
                                <IdentNode start="(57, 27)" end="(57, 37)" leading="" trailing="" raw_val="l₂.toArray" val="l₂.toArray"/>
                                <AtomNode start="(57, 37)" end="(57, 38)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(57, 39)" end="(57, 50)">
                                  <AtomNode start="(57, 39)" end="(57, 41)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(57, 42)" end="(57, 50)">
                                    <TacticTacticseq1IndentedNode start="(57, 42)" end="(57, 50)">
                                      <NullNode start="(57, 42)" end="(57, 50)">
                                        <OtherNode start="(57, 42)" end="(57, 50)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ { toList := l₁ ++ a :: l₂ } = l₁.toArray.push a ++ l₂.toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁.toArray → f x = none" state_after="no goals" tactic="simp_all">
                                          <AtomNode start="(57, 42)" end="(57, 50)" leading="" trailing="" val="simp_all"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(57, 50)" end="(57, 51)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(58, 3)" end="(59, 85)" kind="Lean.cdot" state_before="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="· rintro ⟨xs, a, ys, h₀, h₁, h₂⟩&#10;  exact ⟨xs.toList, a, ys.toList, by simpa using congrArg toList h₀, h₁, by simpa⟩">
                    <OtherNode start="(58, 3)" end="(58, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(58, 3)" end="(58, 4)" kind="patternIgnore">
                        <OtherNode start="(58, 3)" end="(58, 4)" kind="token.«· »">
                          <AtomNode start="(58, 3)" end="(58, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(58, 5)" end="(59, 85)">
                      <TacticTacticseq1IndentedNode start="(58, 5)" end="(59, 85)">
                        <NullNode start="(58, 5)" end="(59, 85)">
                          <OtherNode start="(58, 5)" end="(58, 35)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;⊢ (∃ ys a zs, { toList := toList✝ } = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case mk.mpr.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;xs : Array α&#10;a : α&#10;ys : Array α&#10;h₀ : { toList := toList✝ } = xs.push a ++ ys&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ xs → f x = none&#10;⊢ ∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="rintro ⟨xs, a, ys, h₀, h₁, h₂⟩">
                            <AtomNode start="(58, 5)" end="(58, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(58, 12)" end="(58, 35)">
                              <OtherNode start="(58, 12)" end="(58, 35)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(58, 12)" end="(58, 35)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(58, 12)" end="(58, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(58, 13)" end="(58, 34)">
                                    <OtherNode start="(58, 13)" end="(58, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(58, 13)" end="(58, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(58, 13)" end="(58, 15)">
                                          <OtherNode start="(58, 13)" end="(58, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(58, 13)" end="(58, 15)" leading="" trailing="" raw_val="xs" val="xs"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(58, 15)" end="(58, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(58, 17)" end="(58, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(58, 17)" end="(58, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(58, 17)" end="(58, 18)">
                                          <OtherNode start="(58, 17)" end="(58, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(58, 17)" end="(58, 18)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(58, 18)" end="(58, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(58, 20)" end="(58, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(58, 20)" end="(58, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(58, 20)" end="(58, 22)">
                                          <OtherNode start="(58, 20)" end="(58, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(58, 20)" end="(58, 22)" leading="" trailing="" raw_val="ys" val="ys"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(58, 22)" end="(58, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(58, 24)" end="(58, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(58, 24)" end="(58, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(58, 24)" end="(58, 26)">
                                          <OtherNode start="(58, 24)" end="(58, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(58, 24)" end="(58, 26)" leading="" trailing="" raw_val="h₀" val="h₀"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(58, 26)" end="(58, 27)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(58, 28)" end="(58, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(58, 28)" end="(58, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(58, 28)" end="(58, 30)">
                                          <OtherNode start="(58, 28)" end="(58, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(58, 28)" end="(58, 30)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(58, 30)" end="(58, 31)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(58, 32)" end="(58, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(58, 32)" end="(58, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(58, 32)" end="(58, 34)">
                                          <OtherNode start="(58, 32)" end="(58, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(58, 32)" end="(58, 34)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(58, 34)" end="(58, 35)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(59, 5)" end="(59, 85)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mpr.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;xs : Array α&#10;a : α&#10;ys : Array α&#10;h₀ : { toList := toList✝ } = xs.push a ++ ys&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ xs → f x = none&#10;⊢ ∃ l₁ a l₂, toList✝ = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="exact ⟨xs.toList, a, ys.toList, by simpa using congrArg toList h₀, h₁, by simpa⟩">
                            <AtomNode start="(59, 5)" end="(59, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(59, 11)" end="(59, 85)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(59, 11)" end="(59, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(59, 12)" end="(59, 84)">
                                <IdentNode start="(59, 12)" end="(59, 21)" leading="" trailing="" raw_val="xs.toList" val="xs.toList"/>
                                <AtomNode start="(59, 21)" end="(59, 22)" leading="" trailing=" " val=","/>
                                <IdentNode start="(59, 23)" end="(59, 24)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(59, 24)" end="(59, 25)" leading="" trailing=" " val=","/>
                                <IdentNode start="(59, 26)" end="(59, 35)" leading="" trailing="" raw_val="ys.toList" val="ys.toList"/>
                                <AtomNode start="(59, 35)" end="(59, 36)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(59, 37)" end="(59, 70)">
                                  <AtomNode start="(59, 37)" end="(59, 39)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(59, 40)" end="(59, 70)">
                                    <TacticTacticseq1IndentedNode start="(59, 40)" end="(59, 70)">
                                      <NullNode start="(59, 40)" end="(59, 70)">
                                        <OtherNode start="(59, 40)" end="(59, 70)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;xs : Array α&#10;a : α&#10;ys : Array α&#10;h₀ : { toList := toList✝ } = xs.push a ++ ys&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ xs → f x = none&#10;⊢ toList✝ = xs.toList ++ a :: ys.toList" state_after="no goals" tactic="simpa using congrArg toList h₀">
                                          <AtomNode start="(59, 40)" end="(59, 45)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(59, 46)" end="(59, 70)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(59, 46)" end="(59, 70)">
                                              <AtomNode start="(59, 46)" end="(59, 51)" leading="" trailing=" " val="using"/>
                                              <OtherNode start="(59, 52)" end="(59, 70)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(59, 52)" end="(59, 60)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                <NullNode start="(59, 61)" end="(59, 70)">
                                                  <IdentNode start="(59, 61)" end="(59, 67)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  <IdentNode start="(59, 68)" end="(59, 70)" leading="" trailing="" raw_val="h₀" val="h₀"/>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(59, 70)" end="(59, 71)" leading="" trailing=" " val=","/>
                                <IdentNode start="(59, 72)" end="(59, 74)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                <AtomNode start="(59, 74)" end="(59, 75)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(59, 76)" end="(59, 84)">
                                  <AtomNode start="(59, 76)" end="(59, 78)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(59, 79)" end="(59, 84)">
                                    <TacticTacticseq1IndentedNode start="(59, 79)" end="(59, 84)">
                                      <NullNode start="(59, 79)" end="(59, 84)">
                                        <OtherNode start="(59, 79)" end="(59, 84)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;toList✝ : List α&#10;xs : Array α&#10;a : α&#10;ys : Array α&#10;h₀ : { toList := toList✝ } = xs.push a ++ ys&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ xs → f x = none&#10;⊢ ∀ (x : α), x ∈ xs.toList → f x = none" state_after="no goals" tactic="simpa">
                                          <AtomNode start="(59, 79)" end="(59, 84)" leading="" trailing="" val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(59, 84)" end="(59, 85)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(61, 1)" end="(62, 17)" name="findSome?_guard" full_name="Array.findSome?_guard">
      <CommandDeclmodifiersNode start="(61, 1)" end="(61, 8)">
        <NullNode/>
        <NullNode start="(61, 1)" end="(61, 8)">
          <OtherNode start="(61, 1)" end="(61, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(61, 1)" end="(61, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(61, 3)" end="(61, 7)">
              <OtherNode start="(61, 3)" end="(61, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(61, 3)" end="(61, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(61, 3)" end="(61, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(61, 7)" end="(61, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(61, 9)" end="(62, 17)" name="findSome?_guard" full_name="Array.findSome?_guard" _is_private_decl="False">
        <AtomNode start="(61, 9)" end="(61, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(61, 17)" end="(61, 32)">
          <IdentNode start="(61, 17)" end="(61, 32)" leading="" trailing=" " raw_val="findSome?_guard" val="findSome?_guard"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(61, 33)" end="(61, 103)">
          <NullNode start="(61, 33)" end="(61, 47)">
            <OtherNode start="(61, 33)" end="(61, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 33)" end="(61, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 34)" end="(61, 36)">
                <IdentNode start="(61, 34)" end="(61, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(61, 37)" end="(61, 46)">
                <AtomNode start="(61, 37)" end="(61, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 39)" end="(61, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 39)" end="(61, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(61, 45)" end="(61, 46)">
                    <IdentNode start="(61, 45)" end="(61, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(61, 46)" end="(61, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(61, 48)" end="(61, 103)">
            <AtomNode start="(61, 48)" end="(61, 49)" leading="" trailing=" " val=":"/>
            <OtherNode start="(61, 50)" end="(61, 103)" kind="«term_=_»">
              <OtherNode start="(61, 50)" end="(61, 90)" kind="Lean.Parser.Term.app">
                <IdentNode start="(61, 50)" end="(61, 59)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(61, 60)" end="(61, 90)">
                  <OtherNode start="(61, 60)" end="(61, 87)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(61, 60)" end="(61, 61)" leading="" trailing="" val="("/>
                    <OtherNode start="(61, 61)" end="(61, 86)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(61, 61)" end="(61, 73)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                      <NullNode start="(61, 74)" end="(61, 86)">
                        <OtherNode start="(61, 74)" end="(61, 86)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(61, 74)" end="(61, 77)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(61, 78)" end="(61, 86)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(61, 78)" end="(61, 79)">
                              <IdentNode start="(61, 78)" end="(61, 79)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(61, 80)" end="(61, 82)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(61, 83)" end="(61, 86)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(61, 83)" end="(61, 84)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(61, 85)" end="(61, 86)">
                                <IdentNode start="(61, 85)" end="(61, 86)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(61, 86)" end="(61, 87)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(61, 88)" end="(61, 90)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(61, 91)" end="(61, 92)" leading="" trailing=" " val="="/>
              <OtherNode start="(61, 93)" end="(61, 103)" kind="Lean.Parser.Term.app">
                <IdentNode start="(61, 93)" end="(61, 98)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(61, 99)" end="(61, 103)">
                  <IdentNode start="(61, 99)" end="(61, 100)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(61, 101)" end="(61, 103)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(61, 104)" end="(62, 17)">
          <AtomNode start="(61, 104)" end="(61, 106)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(61, 107)" end="(62, 17)">
            <AtomNode start="(61, 107)" end="(61, 109)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(62, 3)" end="(62, 17)">
              <TacticTacticseq1IndentedNode start="(62, 3)" end="(62, 17)">
                <NullNode start="(62, 3)" end="(62, 17)">
                  <OtherNode start="(62, 3)" end="(62, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) { toList := toList✝ } = find? p { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(62, 3)" end="(62, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(62, 9)" end="(62, 11)">
                      <OtherNode start="(62, 9)" end="(62, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(62, 9)" end="(62, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(62, 11)" end="(62, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(62, 13)" end="(62, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) { toList := toList✝ } = find? p { toList := toList✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(62, 13)" end="(62, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(64, 1)" end="(65, 23)" name="find?_eq_findSome?_guard" full_name="Array.find?_eq_findSome?_guard">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(64, 1)" end="(65, 23)" name="find?_eq_findSome?_guard" full_name="Array.find?_eq_findSome?_guard" _is_private_decl="False">
        <AtomNode start="(64, 1)" end="(64, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(64, 9)" end="(64, 33)">
          <IdentNode start="(64, 9)" end="(64, 33)" leading="" trailing=" " raw_val="find?_eq_findSome?_guard" val="find?_eq_findSome?_guard"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(64, 34)" end="(64, 104)">
          <NullNode start="(64, 34)" end="(64, 48)">
            <OtherNode start="(64, 34)" end="(64, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(64, 34)" end="(64, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(64, 35)" end="(64, 37)">
                <IdentNode start="(64, 35)" end="(64, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(64, 38)" end="(64, 47)">
                <AtomNode start="(64, 38)" end="(64, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(64, 40)" end="(64, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(64, 40)" end="(64, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(64, 46)" end="(64, 47)">
                    <IdentNode start="(64, 46)" end="(64, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(64, 47)" end="(64, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(64, 49)" end="(64, 104)">
            <AtomNode start="(64, 49)" end="(64, 50)" leading="" trailing=" " val=":"/>
            <OtherNode start="(64, 51)" end="(64, 104)" kind="«term_=_»">
              <OtherNode start="(64, 51)" end="(64, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(64, 51)" end="(64, 56)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(64, 57)" end="(64, 61)">
                  <IdentNode start="(64, 57)" end="(64, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(64, 59)" end="(64, 61)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(64, 62)" end="(64, 63)" leading="" trailing=" " val="="/>
              <OtherNode start="(64, 64)" end="(64, 104)" kind="Lean.Parser.Term.app">
                <IdentNode start="(64, 64)" end="(64, 73)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(64, 74)" end="(64, 104)">
                  <OtherNode start="(64, 74)" end="(64, 101)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(64, 74)" end="(64, 75)" leading="" trailing="" val="("/>
                    <OtherNode start="(64, 75)" end="(64, 100)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(64, 75)" end="(64, 87)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                      <NullNode start="(64, 88)" end="(64, 100)">
                        <OtherNode start="(64, 88)" end="(64, 100)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(64, 88)" end="(64, 91)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(64, 92)" end="(64, 100)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(64, 92)" end="(64, 93)">
                              <IdentNode start="(64, 92)" end="(64, 93)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(64, 94)" end="(64, 96)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(64, 97)" end="(64, 100)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(64, 97)" end="(64, 98)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(64, 99)" end="(64, 100)">
                                <IdentNode start="(64, 99)" end="(64, 100)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(64, 100)" end="(64, 101)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(64, 102)" end="(64, 104)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(64, 105)" end="(65, 23)">
          <AtomNode start="(64, 105)" end="(64, 107)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(65, 3)" end="(65, 23)" leading="" trailing="&#10;&#10;" raw_val="findSome?_guard.symm" val="findSome?_guard.symm"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(67, 1)" end="(68, 44)" name="getElem?_zero_filterMap" full_name="Array.getElem?_zero_filterMap">
      <CommandDeclmodifiersNode start="(67, 1)" end="(67, 8)">
        <NullNode/>
        <NullNode start="(67, 1)" end="(67, 8)">
          <OtherNode start="(67, 1)" end="(67, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(67, 1)" end="(67, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(67, 3)" end="(67, 7)">
              <OtherNode start="(67, 3)" end="(67, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(67, 3)" end="(67, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(67, 3)" end="(67, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(67, 7)" end="(67, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(67, 9)" end="(68, 44)" name="getElem?_zero_filterMap" full_name="Array.getElem?_zero_filterMap" _is_private_decl="False">
        <AtomNode start="(67, 9)" end="(67, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(67, 17)" end="(67, 40)">
          <IdentNode start="(67, 17)" end="(67, 40)" leading="" trailing=" " raw_val="getElem?_zero_filterMap" val="getElem?_zero_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(67, 41)" end="(67, 114)">
          <NullNode start="(67, 41)" end="(67, 74)">
            <OtherNode start="(67, 41)" end="(67, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(67, 41)" end="(67, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(67, 42)" end="(67, 43)">
                <IdentNode start="(67, 42)" end="(67, 43)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(67, 44)" end="(67, 58)">
                <AtomNode start="(67, 44)" end="(67, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(67, 46)" end="(67, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(67, 46)" end="(67, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(67, 48)" end="(67, 49)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(67, 50)" end="(67, 58)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(67, 50)" end="(67, 56)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(67, 57)" end="(67, 58)">
                      <IdentNode start="(67, 57)" end="(67, 58)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(67, 58)" end="(67, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(67, 60)" end="(67, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(67, 60)" end="(67, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(67, 61)" end="(67, 63)">
                <IdentNode start="(67, 61)" end="(67, 63)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(67, 64)" end="(67, 73)">
                <AtomNode start="(67, 64)" end="(67, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(67, 66)" end="(67, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(67, 66)" end="(67, 71)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(67, 72)" end="(67, 73)">
                    <IdentNode start="(67, 72)" end="(67, 73)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(67, 73)" end="(67, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(67, 75)" end="(67, 114)">
            <AtomNode start="(67, 75)" end="(67, 76)" leading="" trailing=" " val=":"/>
            <OtherNode start="(67, 77)" end="(67, 114)" kind="«term_=_»">
              <OtherNode start="(67, 77)" end="(67, 97)" kind="«term__[_]_?»">
                <OtherNode start="(67, 77)" end="(67, 93)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(67, 77)" end="(67, 78)" leading="" trailing="" val="("/>
                  <OtherNode start="(67, 78)" end="(67, 92)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(67, 78)" end="(67, 90)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                    <NullNode start="(67, 91)" end="(67, 92)">
                      <IdentNode start="(67, 91)" end="(67, 92)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(67, 92)" end="(67, 93)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(67, 93)" end="(67, 94)" leading="" trailing="" val="["/>
                <OtherNode start="(67, 94)" end="(67, 95)" kind="num">
                  <AtomNode start="(67, 94)" end="(67, 95)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(67, 95)" end="(67, 96)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(67, 96)" end="(67, 97)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(67, 98)" end="(67, 99)" leading="" trailing=" " val="="/>
              <OtherNode start="(67, 100)" end="(67, 114)" kind="Lean.Parser.Term.app">
                <IdentNode start="(67, 100)" end="(67, 112)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(67, 113)" end="(67, 114)">
                  <IdentNode start="(67, 113)" end="(67, 114)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(67, 115)" end="(68, 44)">
          <AtomNode start="(67, 115)" end="(67, 117)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(67, 118)" end="(68, 44)">
            <AtomNode start="(67, 118)" end="(67, 120)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(68, 3)" end="(68, 44)">
              <TacticTacticseq1IndentedNode start="(68, 3)" end="(68, 44)">
                <NullNode start="(68, 3)" end="(68, 44)">
                  <OtherNode start="(68, 3)" end="(68, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;⊢ (filterMap f xs)[0]? = findSome? f xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (filterMap f { toList := toList✝ })[0]? = findSome? f { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(68, 3)" end="(68, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(68, 9)" end="(68, 11)">
                      <OtherNode start="(68, 9)" end="(68, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(68, 9)" end="(68, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(68, 11)" end="(68, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(68, 13)" end="(68, 44)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (filterMap f { toList := toList✝ })[0]? = findSome? f { toList := toList✝ }" state_after="no goals" tactic="simp [← List.head?_eq_getElem?]">
                    <AtomNode start="(68, 13)" end="(68, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(68, 18)" end="(68, 44)">
                      <AtomNode start="(68, 18)" end="(68, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(68, 19)" end="(68, 43)">
                        <OtherNode start="(68, 19)" end="(68, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(68, 19)" end="(68, 20)">
                            <OtherNode start="(68, 19)" end="(68, 20)" kind="patternIgnore">
                              <OtherNode start="(68, 19)" end="(68, 20)" kind="token.«← »">
                                <AtomNode start="(68, 19)" end="(68, 20)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(68, 21)" end="(68, 43)" leading="" trailing="" raw_val="List.head?_eq_getElem?" val="List.head?_eq_getElem?" full_name="List.head?_eq_getElem?" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(68, 43)" end="(68, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(70, 1)" end="(72, 69)" name="getElem_zero_filterMap" full_name="Array.getElem_zero_filterMap">
      <CommandDeclmodifiersNode start="(70, 1)" end="(70, 8)">
        <NullNode/>
        <NullNode start="(70, 1)" end="(70, 8)">
          <OtherNode start="(70, 1)" end="(70, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(70, 1)" end="(70, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(70, 3)" end="(70, 7)">
              <OtherNode start="(70, 3)" end="(70, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(70, 3)" end="(70, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(70, 3)" end="(70, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(70, 7)" end="(70, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(70, 9)" end="(72, 69)" name="getElem_zero_filterMap" full_name="Array.getElem_zero_filterMap" _is_private_decl="False">
        <AtomNode start="(70, 9)" end="(70, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(70, 17)" end="(70, 39)">
          <IdentNode start="(70, 17)" end="(70, 39)" leading="" trailing=" " raw_val="getElem_zero_filterMap" val="getElem_zero_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(70, 40)" end="(71, 110)">
          <NullNode start="(70, 40)" end="(70, 77)">
            <OtherNode start="(70, 40)" end="(70, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(70, 40)" end="(70, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(70, 41)" end="(70, 42)">
                <IdentNode start="(70, 41)" end="(70, 42)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(70, 43)" end="(70, 57)">
                <AtomNode start="(70, 43)" end="(70, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(70, 45)" end="(70, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(70, 45)" end="(70, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(70, 47)" end="(70, 48)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(70, 49)" end="(70, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(70, 49)" end="(70, 55)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(70, 56)" end="(70, 57)">
                      <IdentNode start="(70, 56)" end="(70, 57)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(70, 57)" end="(70, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(70, 59)" end="(70, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(70, 59)" end="(70, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(70, 60)" end="(70, 62)">
                <IdentNode start="(70, 60)" end="(70, 62)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(70, 63)" end="(70, 72)">
                <AtomNode start="(70, 63)" end="(70, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(70, 65)" end="(70, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(70, 65)" end="(70, 70)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(70, 71)" end="(70, 72)">
                    <IdentNode start="(70, 71)" end="(70, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(70, 72)" end="(70, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(70, 74)" end="(70, 77)">
              <AtomNode start="(70, 74)" end="(70, 75)" leading="" trailing="" val="("/>
              <NullNode start="(70, 75)" end="(70, 76)">
                <IdentNode start="(70, 75)" end="(70, 76)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(70, 76)" end="(70, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(70, 78)" end="(71, 110)">
            <AtomNode start="(70, 78)" end="(70, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(71, 5)" end="(71, 110)" kind="«term_=_»">
              <OtherNode start="(71, 5)" end="(71, 24)" kind="«term__[_]»">
                <OtherNode start="(71, 5)" end="(71, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(71, 5)" end="(71, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(71, 6)" end="(71, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(71, 6)" end="(71, 18)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                    <NullNode start="(71, 19)" end="(71, 20)">
                      <IdentNode start="(71, 19)" end="(71, 20)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(71, 20)" end="(71, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(71, 21)" end="(71, 22)" leading="" trailing="" val="["/>
                <OtherNode start="(71, 22)" end="(71, 23)" kind="num">
                  <AtomNode start="(71, 22)" end="(71, 23)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(71, 23)" end="(71, 24)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(71, 25)" end="(71, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(71, 27)" end="(71, 110)" kind="Lean.Parser.Term.app">
                <OtherNode start="(71, 27)" end="(71, 47)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(71, 27)" end="(71, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(71, 27)" end="(71, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(71, 28)" end="(71, 42)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(71, 28)" end="(71, 40)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(71, 41)" end="(71, 42)">
                        <IdentNode start="(71, 41)" end="(71, 42)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(71, 42)" end="(71, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(71, 43)" end="(71, 44)" leading="" trailing="" val="."/>
                  <IdentNode start="(71, 44)" end="(71, 47)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(71, 48)" end="(71, 110)">
                  <OtherNode start="(71, 48)" end="(71, 110)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(71, 48)" end="(71, 49)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(71, 49)" end="(71, 109)">
                      <AtomNode start="(71, 49)" end="(71, 51)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(71, 52)" end="(71, 109)">
                        <TacticTacticseq1IndentedNode start="(71, 52)" end="(71, 109)">
                          <NullNode start="(71, 52)" end="(71, 109)">
                            <OtherNode start="(71, 52)" end="(71, 60)" kind="Lean.Parser.Tactic.cases" state_before="α : Type ?u.9478&#10;β : Type ?u.9475&#10;f : α → Option β&#10;xs : Array α&#10;h : 0 &amp;lt; (filterMap f xs).size&#10;⊢ (findSome? f xs).isSome = true" state_after="case mk&#10;α : Type ?u.9478&#10;β : Type ?u.9475&#10;f : α → Option β&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filterMap f { toList := toList✝ }).size&#10;⊢ (findSome? f { toList := toList✝ }).isSome = true" tactic="cases xs">
                              <AtomNode start="(71, 52)" end="(71, 57)" leading="" trailing=" " val="cases"/>
                              <NullNode start="(71, 58)" end="(71, 60)">
                                <OtherNode start="(71, 58)" end="(71, 60)" kind="Lean.Parser.Tactic.elimTarget">
                                  <NullNode/>
                                  <IdentNode start="(71, 58)" end="(71, 60)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(71, 60)" end="(71, 61)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(71, 62)" end="(71, 109)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type ?u.9478&#10;β : Type ?u.9475&#10;f : α → Option β&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filterMap f { toList := toList✝ }).size&#10;⊢ (findSome? f { toList := toList✝ }).isSome = true" state_after="no goals" tactic="simpa [List.length_filterMap_eq_countP] using h">
                              <AtomNode start="(71, 62)" end="(71, 67)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(71, 68)" end="(71, 109)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(71, 68)" end="(71, 101)">
                                  <OtherNode start="(71, 68)" end="(71, 101)" kind="Lean.Parser.Tactic.simpArgs">
                                    <AtomNode start="(71, 68)" end="(71, 69)" leading="" trailing="" val="["/>
                                    <NullNode start="(71, 69)" end="(71, 100)">
                                      <OtherNode start="(71, 69)" end="(71, 100)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(71, 69)" end="(71, 100)" leading="" trailing="" raw_val="List.length_filterMap_eq_countP" val="List.length_filterMap_eq_countP" full_name="List.length_filterMap_eq_countP" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(71, 100)" end="(71, 101)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode start="(71, 102)" end="(71, 109)">
                                  <AtomNode start="(71, 102)" end="(71, 107)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(71, 108)" end="(71, 109)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(71, 109)" end="(71, 110)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(71, 111)" end="(72, 69)">
          <AtomNode start="(71, 111)" end="(71, 113)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(71, 114)" end="(72, 69)">
            <AtomNode start="(71, 114)" end="(71, 116)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(72, 3)" end="(72, 69)">
              <TacticTacticseq1IndentedNode start="(72, 3)" end="(72, 69)">
                <NullNode start="(72, 3)" end="(72, 69)">
                  <OtherNode start="(72, 3)" end="(72, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;h : 0 &amp;lt; (filterMap f xs).size&#10;⊢ (filterMap f xs)[0] = (findSome? f xs).get ⋯" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filterMap f { toList := toList✝ }).size&#10;⊢ (filterMap f { toList := toList✝ })[0] = (findSome? f { toList := toList✝ }).get ⋯" tactic="cases xs">
                    <AtomNode start="(72, 3)" end="(72, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(72, 9)" end="(72, 11)">
                      <OtherNode start="(72, 9)" end="(72, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(72, 9)" end="(72, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(72, 11)" end="(72, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(72, 13)" end="(72, 69)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filterMap f { toList := toList✝ }).size&#10;⊢ (filterMap f { toList := toList✝ })[0] = (findSome? f { toList := toList✝ }).get ⋯" state_after="no goals" tactic="simp [← List.head_eq_getElem, ← getElem?_zero_filterMap]">
                    <AtomNode start="(72, 13)" end="(72, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(72, 18)" end="(72, 69)">
                      <AtomNode start="(72, 18)" end="(72, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(72, 19)" end="(72, 68)">
                        <OtherNode start="(72, 19)" end="(72, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(72, 19)" end="(72, 20)">
                            <OtherNode start="(72, 19)" end="(72, 20)" kind="patternIgnore">
                              <OtherNode start="(72, 19)" end="(72, 20)" kind="token.«← »">
                                <AtomNode start="(72, 19)" end="(72, 20)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(72, 21)" end="(72, 41)" leading="" trailing="" raw_val="List.head_eq_getElem" val="List.head_eq_getElem" full_name="List.head_eq_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(72, 41)" end="(72, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(72, 43)" end="(72, 68)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(72, 43)" end="(72, 44)">
                            <OtherNode start="(72, 43)" end="(72, 44)" kind="patternIgnore">
                              <OtherNode start="(72, 43)" end="(72, 44)" kind="token.«← »">
                                <AtomNode start="(72, 43)" end="(72, 44)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(72, 45)" end="(72, 68)" leading="" trailing="" raw_val="getElem?_zero_filterMap" val="getElem?_zero_filterMap" full_name="Array.getElem?_zero_filterMap" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(67, 17)" def_end="(67, 40)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(72, 68)" end="(72, 69)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(74, 1)" end="(75, 17)" name="back?_filterMap" full_name="Array.back?_filterMap">
      <CommandDeclmodifiersNode start="(74, 1)" end="(74, 8)">
        <NullNode/>
        <NullNode start="(74, 1)" end="(74, 8)">
          <OtherNode start="(74, 1)" end="(74, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(74, 1)" end="(74, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(74, 3)" end="(74, 7)">
              <OtherNode start="(74, 3)" end="(74, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(74, 3)" end="(74, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(74, 3)" end="(74, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(74, 7)" end="(74, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(74, 9)" end="(75, 17)" name="back?_filterMap" full_name="Array.back?_filterMap" _is_private_decl="False">
        <AtomNode start="(74, 9)" end="(74, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(74, 17)" end="(74, 32)">
          <IdentNode start="(74, 17)" end="(74, 32)" leading="" trailing=" " raw_val="back?_filterMap" val="back?_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(74, 33)" end="(74, 111)">
          <NullNode start="(74, 33)" end="(74, 66)">
            <OtherNode start="(74, 33)" end="(74, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(74, 33)" end="(74, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(74, 34)" end="(74, 35)">
                <IdentNode start="(74, 34)" end="(74, 35)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(74, 36)" end="(74, 50)">
                <AtomNode start="(74, 36)" end="(74, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(74, 38)" end="(74, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(74, 38)" end="(74, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(74, 40)" end="(74, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(74, 42)" end="(74, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(74, 42)" end="(74, 48)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(74, 49)" end="(74, 50)">
                      <IdentNode start="(74, 49)" end="(74, 50)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(74, 50)" end="(74, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(74, 52)" end="(74, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(74, 52)" end="(74, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(74, 53)" end="(74, 55)">
                <IdentNode start="(74, 53)" end="(74, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(74, 56)" end="(74, 65)">
                <AtomNode start="(74, 56)" end="(74, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(74, 58)" end="(74, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(74, 58)" end="(74, 63)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(74, 64)" end="(74, 65)">
                    <IdentNode start="(74, 64)" end="(74, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(74, 65)" end="(74, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(74, 67)" end="(74, 111)">
            <AtomNode start="(74, 67)" end="(74, 68)" leading="" trailing=" " val=":"/>
            <OtherNode start="(74, 69)" end="(74, 111)" kind="«term_=_»">
              <OtherNode start="(74, 69)" end="(74, 91)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(74, 69)" end="(74, 85)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(74, 69)" end="(74, 70)" leading="" trailing="" val="("/>
                  <OtherNode start="(74, 70)" end="(74, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(74, 70)" end="(74, 82)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                    <NullNode start="(74, 83)" end="(74, 84)">
                      <IdentNode start="(74, 83)" end="(74, 84)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(74, 84)" end="(74, 85)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(74, 85)" end="(74, 86)" leading="" trailing="" val="."/>
                <IdentNode start="(74, 86)" end="(74, 91)" leading="" trailing=" " raw_val="back?" val="back?" full_name="Array.back?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(74, 92)" end="(74, 93)" leading="" trailing=" " val="="/>
              <OtherNode start="(74, 94)" end="(74, 111)" kind="Lean.Parser.Term.app">
                <IdentNode start="(74, 94)" end="(74, 109)" leading="" trailing=" " raw_val="xs.findSomeRev?" val="xs.findSomeRev?"/>
                <NullNode start="(74, 110)" end="(74, 111)">
                  <IdentNode start="(74, 110)" end="(74, 111)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(74, 112)" end="(75, 17)">
          <AtomNode start="(74, 112)" end="(74, 114)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(74, 115)" end="(75, 17)">
            <AtomNode start="(74, 115)" end="(74, 117)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(75, 3)" end="(75, 17)">
              <TacticTacticseq1IndentedNode start="(75, 3)" end="(75, 17)">
                <NullNode start="(75, 3)" end="(75, 17)">
                  <OtherNode start="(75, 3)" end="(75, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;⊢ (filterMap f xs).back? = findSomeRev? f xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (filterMap f { toList := toList✝ }).back? = findSomeRev? f { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(75, 3)" end="(75, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(75, 9)" end="(75, 11)">
                      <OtherNode start="(75, 9)" end="(75, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(75, 9)" end="(75, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(75, 11)" end="(75, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(75, 13)" end="(75, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (filterMap f { toList := toList✝ }).back? = findSomeRev? f { toList := toList✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(75, 13)" end="(75, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(77, 1)" end="(79, 17)" name="back!_filterMap" full_name="Array.back!_filterMap">
      <CommandDeclmodifiersNode start="(77, 1)" end="(77, 8)">
        <NullNode/>
        <NullNode start="(77, 1)" end="(77, 8)">
          <OtherNode start="(77, 1)" end="(77, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(77, 1)" end="(77, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(77, 3)" end="(77, 7)">
              <OtherNode start="(77, 3)" end="(77, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(77, 3)" end="(77, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(77, 3)" end="(77, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(77, 7)" end="(77, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(77, 9)" end="(79, 17)" name="back!_filterMap" full_name="Array.back!_filterMap" _is_private_decl="False">
        <AtomNode start="(77, 9)" end="(77, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(77, 17)" end="(77, 32)">
          <IdentNode start="(77, 17)" end="(77, 32)" leading="" trailing=" " raw_val="back!_filterMap" val="back!_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(77, 33)" end="(78, 62)">
          <NullNode start="(77, 33)" end="(77, 80)">
            <OtherNode start="(77, 33)" end="(77, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(77, 33)" end="(77, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(77, 34)" end="(77, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(77, 34)" end="(77, 43)" leading="" trailing=" " raw_val="Inhabited" val="Inhabited" full_name="Inhabited" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(77, 44)" end="(77, 45)">
                  <IdentNode start="(77, 44)" end="(77, 45)" leading="" trailing="" raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(77, 45)" end="(77, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(77, 47)" end="(77, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(77, 47)" end="(77, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(77, 48)" end="(77, 49)">
                <IdentNode start="(77, 48)" end="(77, 49)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(77, 50)" end="(77, 64)">
                <AtomNode start="(77, 50)" end="(77, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(77, 52)" end="(77, 64)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(77, 52)" end="(77, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(77, 54)" end="(77, 55)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(77, 56)" end="(77, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(77, 56)" end="(77, 62)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(77, 63)" end="(77, 64)">
                      <IdentNode start="(77, 63)" end="(77, 64)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(77, 64)" end="(77, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(77, 66)" end="(77, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(77, 66)" end="(77, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(77, 67)" end="(77, 69)">
                <IdentNode start="(77, 67)" end="(77, 69)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(77, 70)" end="(77, 79)">
                <AtomNode start="(77, 70)" end="(77, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(77, 72)" end="(77, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(77, 72)" end="(77, 77)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(77, 78)" end="(77, 79)">
                    <IdentNode start="(77, 78)" end="(77, 79)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(77, 79)" end="(77, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(77, 81)" end="(78, 62)">
            <AtomNode start="(77, 81)" end="(77, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(78, 5)" end="(78, 62)" kind="«term_=_»">
              <OtherNode start="(78, 5)" end="(78, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(78, 5)" end="(78, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(78, 5)" end="(78, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(78, 6)" end="(78, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(78, 6)" end="(78, 18)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                    <NullNode start="(78, 19)" end="(78, 20)">
                      <IdentNode start="(78, 19)" end="(78, 20)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(78, 20)" end="(78, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(78, 21)" end="(78, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(78, 22)" end="(78, 27)" leading="" trailing=" " raw_val="back!" val="back!" full_name="Array.back!" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(78, 28)" end="(78, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(78, 30)" end="(78, 62)" kind="Lean.Parser.Term.app">
                <OtherNode start="(78, 30)" end="(78, 54)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(78, 30)" end="(78, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(78, 30)" end="(78, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(78, 31)" end="(78, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(78, 31)" end="(78, 46)" leading="" trailing=" " raw_val="xs.findSomeRev?" val="xs.findSomeRev?"/>
                      <NullNode start="(78, 47)" end="(78, 48)">
                        <IdentNode start="(78, 47)" end="(78, 48)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(78, 48)" end="(78, 49)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(78, 49)" end="(78, 50)" leading="" trailing="" val="."/>
                  <IdentNode start="(78, 50)" end="(78, 54)" leading="" trailing=" " raw_val="getD" val="getD" full_name="Option.getD" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(78, 55)" end="(78, 62)">
                  <IdentNode start="(78, 55)" end="(78, 62)" leading="" trailing=" " raw_val="default" val="default" full_name="Inhabited.default" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(78, 63)" end="(79, 17)">
          <AtomNode start="(78, 63)" end="(78, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(78, 66)" end="(79, 17)">
            <AtomNode start="(78, 66)" end="(78, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(79, 3)" end="(79, 17)">
              <TacticTacticseq1IndentedNode start="(79, 3)" end="(79, 17)">
                <NullNode start="(79, 3)" end="(79, 17)">
                  <OtherNode start="(79, 3)" end="(79, 11)" kind="Lean.Parser.Tactic.cases" state_before="β : Type u_1&#10;α : Type u_2&#10;inst✝ : Inhabited β&#10;f : α → Option β&#10;xs : Array α&#10;⊢ (filterMap f xs).back! = (findSomeRev? f xs).getD default" state_after="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;inst✝ : Inhabited β&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (filterMap f { toList := toList✝ }).back! = (findSomeRev? f { toList := toList✝ }).getD default" tactic="cases xs">
                    <AtomNode start="(79, 3)" end="(79, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(79, 9)" end="(79, 11)">
                      <OtherNode start="(79, 9)" end="(79, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(79, 9)" end="(79, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(79, 11)" end="(79, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(79, 13)" end="(79, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;inst✝ : Inhabited β&#10;f : α → Option β&#10;toList✝ : List α&#10;⊢ (filterMap f { toList := toList✝ }).back! = (findSomeRev? f { toList := toList✝ }).getD default" state_after="no goals" tactic="simp">
                    <AtomNode start="(79, 13)" end="(79, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(81, 1)" end="(83, 17)" name="map_findSome?" full_name="Array.map_findSome?">
      <CommandDeclmodifiersNode start="(81, 1)" end="(81, 8)">
        <NullNode/>
        <NullNode start="(81, 1)" end="(81, 8)">
          <OtherNode start="(81, 1)" end="(81, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(81, 1)" end="(81, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(81, 3)" end="(81, 7)">
              <OtherNode start="(81, 3)" end="(81, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(81, 3)" end="(81, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(81, 3)" end="(81, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(81, 7)" end="(81, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(81, 9)" end="(83, 17)" name="map_findSome?" full_name="Array.map_findSome?" _is_private_decl="False">
        <AtomNode start="(81, 9)" end="(81, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(81, 17)" end="(81, 30)">
          <IdentNode start="(81, 17)" end="(81, 30)" leading="" trailing=" " raw_val="map_findSome?" val="map_findSome?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(81, 31)" end="(82, 61)">
          <NullNode start="(81, 31)" end="(81, 76)">
            <OtherNode start="(81, 31)" end="(81, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(81, 31)" end="(81, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(81, 32)" end="(81, 33)">
                <IdentNode start="(81, 32)" end="(81, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(81, 34)" end="(81, 48)">
                <AtomNode start="(81, 34)" end="(81, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(81, 36)" end="(81, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(81, 36)" end="(81, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(81, 38)" end="(81, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(81, 40)" end="(81, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(81, 40)" end="(81, 46)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(81, 47)" end="(81, 48)">
                      <IdentNode start="(81, 47)" end="(81, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(81, 48)" end="(81, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(81, 50)" end="(81, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(81, 50)" end="(81, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(81, 51)" end="(81, 52)">
                <IdentNode start="(81, 51)" end="(81, 52)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(81, 53)" end="(81, 60)">
                <AtomNode start="(81, 53)" end="(81, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(81, 55)" end="(81, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(81, 55)" end="(81, 56)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(81, 57)" end="(81, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(81, 59)" end="(81, 60)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(81, 60)" end="(81, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(81, 62)" end="(81, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(81, 62)" end="(81, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(81, 63)" end="(81, 65)">
                <IdentNode start="(81, 63)" end="(81, 65)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(81, 66)" end="(81, 75)">
                <AtomNode start="(81, 66)" end="(81, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(81, 68)" end="(81, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(81, 68)" end="(81, 73)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(81, 74)" end="(81, 75)">
                    <IdentNode start="(81, 74)" end="(81, 75)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(81, 75)" end="(81, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(81, 77)" end="(82, 61)">
            <AtomNode start="(81, 77)" end="(81, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(82, 5)" end="(82, 61)" kind="«term_=_»">
              <OtherNode start="(82, 5)" end="(82, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(82, 5)" end="(82, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(82, 5)" end="(82, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(82, 5)" end="(82, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(82, 6)" end="(82, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(82, 6)" end="(82, 18)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(82, 19)" end="(82, 20)">
                        <IdentNode start="(82, 19)" end="(82, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(82, 20)" end="(82, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(82, 21)" end="(82, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(82, 22)" end="(82, 25)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(82, 26)" end="(82, 27)">
                  <IdentNode start="(82, 26)" end="(82, 27)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(82, 28)" end="(82, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(82, 30)" end="(82, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(82, 30)" end="(82, 42)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(82, 43)" end="(82, 61)">
                  <OtherNode start="(82, 43)" end="(82, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(82, 43)" end="(82, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(82, 44)" end="(82, 60)" kind="«term_∘_»">
                      <OtherNode start="(82, 44)" end="(82, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(82, 44)" end="(82, 54)" leading="" trailing=" " raw_val="Option.map" val="Option.map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(82, 55)" end="(82, 56)">
                          <IdentNode start="(82, 55)" end="(82, 56)" leading="" trailing=" " raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(82, 57)" end="(82, 58)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(82, 59)" end="(82, 60)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(82, 60)" end="(82, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(82, 62)" end="(83, 17)">
          <AtomNode start="(82, 62)" end="(82, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(82, 65)" end="(83, 17)">
            <AtomNode start="(82, 65)" end="(82, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(83, 3)" end="(83, 17)">
              <TacticTacticseq1IndentedNode start="(83, 3)" end="(83, 17)">
                <NullNode start="(83, 3)" end="(83, 17)">
                  <OtherNode start="(83, 3)" end="(83, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → Option β&#10;g : β → γ&#10;xs : Array α&#10;⊢ Option.map g (findSome? f xs) = findSome? (Option.map g ∘ f) xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → Option β&#10;g : β → γ&#10;toList✝ : List α&#10;⊢ Option.map g (findSome? f { toList := toList✝ }) = findSome? (Option.map g ∘ f) { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(83, 3)" end="(83, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(83, 9)" end="(83, 11)">
                      <OtherNode start="(83, 9)" end="(83, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(83, 9)" end="(83, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(83, 11)" end="(83, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(83, 13)" end="(83, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → Option β&#10;g : β → γ&#10;toList✝ : List α&#10;⊢ Option.map g (findSome? f { toList := toList✝ }) = findSome? (Option.map g ∘ f) { toList := toList✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(83, 13)" end="(83, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(85, 1)" end="(86, 38)" name="findSome?_map" full_name="Array.findSome?_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(85, 1)" end="(86, 38)" name="findSome?_map" full_name="Array.findSome?_map" _is_private_decl="False">
        <AtomNode start="(85, 1)" end="(85, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(85, 9)" end="(85, 22)">
          <IdentNode start="(85, 9)" end="(85, 22)" leading="" trailing=" " raw_val="findSome?_map" val="findSome?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(85, 23)" end="(85, 97)">
          <NullNode start="(85, 23)" end="(85, 49)">
            <OtherNode start="(85, 23)" end="(85, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(85, 23)" end="(85, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(85, 24)" end="(85, 25)">
                <IdentNode start="(85, 24)" end="(85, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(85, 26)" end="(85, 33)">
                <AtomNode start="(85, 26)" end="(85, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(85, 28)" end="(85, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(85, 28)" end="(85, 29)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(85, 30)" end="(85, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(85, 32)" end="(85, 33)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(85, 33)" end="(85, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(85, 35)" end="(85, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(85, 35)" end="(85, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(85, 36)" end="(85, 38)">
                <IdentNode start="(85, 36)" end="(85, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(85, 39)" end="(85, 48)">
                <AtomNode start="(85, 39)" end="(85, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(85, 41)" end="(85, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(85, 41)" end="(85, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(85, 47)" end="(85, 48)">
                    <IdentNode start="(85, 47)" end="(85, 48)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(85, 48)" end="(85, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(85, 50)" end="(85, 97)">
            <AtomNode start="(85, 50)" end="(85, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(85, 52)" end="(85, 97)" kind="«term_=_»">
              <OtherNode start="(85, 52)" end="(85, 74)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 52)" end="(85, 61)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(85, 62)" end="(85, 74)">
                  <IdentNode start="(85, 62)" end="(85, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(85, 64)" end="(85, 74)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(85, 64)" end="(85, 65)" leading="" trailing="" val="("/>
                    <OtherNode start="(85, 65)" end="(85, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(85, 65)" end="(85, 71)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(85, 72)" end="(85, 73)">
                        <IdentNode start="(85, 72)" end="(85, 73)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(85, 73)" end="(85, 74)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(85, 75)" end="(85, 76)" leading="" trailing=" " val="="/>
              <OtherNode start="(85, 77)" end="(85, 97)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 77)" end="(85, 89)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(85, 90)" end="(85, 97)">
                  <OtherNode start="(85, 90)" end="(85, 97)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(85, 90)" end="(85, 91)" leading="" trailing="" val="("/>
                    <OtherNode start="(85, 91)" end="(85, 96)" kind="«term_∘_»">
                      <IdentNode start="(85, 91)" end="(85, 92)" leading="" trailing=" " raw_val="p" val="p"/>
                      <AtomNode start="(85, 93)" end="(85, 94)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(85, 95)" end="(85, 96)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(85, 96)" end="(85, 97)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(85, 98)" end="(86, 38)">
          <AtomNode start="(85, 98)" end="(85, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(85, 101)" end="(86, 38)">
            <AtomNode start="(85, 101)" end="(85, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(86, 3)" end="(86, 38)">
              <TacticTacticseq1IndentedNode start="(86, 3)" end="(86, 38)">
                <NullNode start="(86, 3)" end="(86, 38)">
                  <OtherNode start="(86, 3)" end="(86, 11)" kind="Lean.Parser.Tactic.cases" state_before="β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;xs : Array β&#10;⊢ findSome? p (map f xs) = findSome? (p ∘ f) xs" state_after="case mk&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;toList✝ : List β&#10;⊢ findSome? p (map f { toList := toList✝ }) = findSome? (p ∘ f) { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(86, 3)" end="(86, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(86, 9)" end="(86, 11)">
                      <OtherNode start="(86, 9)" end="(86, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(86, 9)" end="(86, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(86, 11)" end="(86, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(86, 13)" end="(86, 38)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;toList✝ : List β&#10;⊢ findSome? p (map f { toList := toList✝ }) = findSome? (p ∘ f) { toList := toList✝ }" state_after="no goals" tactic="simp [List.findSome?_map]">
                    <AtomNode start="(86, 13)" end="(86, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(86, 18)" end="(86, 38)">
                      <AtomNode start="(86, 18)" end="(86, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 19)" end="(86, 37)">
                        <OtherNode start="(86, 19)" end="(86, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 19)" end="(86, 37)" leading="" trailing="" raw_val="List.findSome?_map" val="List.findSome?_map" full_name="List.findSome?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 37)" end="(86, 38)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(88, 1)" end="(89, 51)" name="findSome?_append" full_name="Array.findSome?_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 1)" end="(89, 51)" name="findSome?_append" full_name="Array.findSome?_append" _is_private_decl="False">
        <AtomNode start="(88, 1)" end="(88, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 9)" end="(88, 25)">
          <IdentNode start="(88, 9)" end="(88, 25)" leading="" trailing=" " raw_val="findSome?_append" val="findSome?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 26)" end="(88, 107)">
          <NullNode start="(88, 26)" end="(88, 43)">
            <OtherNode start="(88, 26)" end="(88, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 26)" end="(88, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 27)" end="(88, 32)">
                <IdentNode start="(88, 27)" end="(88, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(88, 30)" end="(88, 32)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(88, 33)" end="(88, 42)">
                <AtomNode start="(88, 33)" end="(88, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 35)" end="(88, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 35)" end="(88, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(88, 41)" end="(88, 42)">
                    <IdentNode start="(88, 41)" end="(88, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 42)" end="(88, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(88, 44)" end="(88, 107)">
            <AtomNode start="(88, 44)" end="(88, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(88, 46)" end="(88, 107)" kind="«term_=_»">
              <OtherNode start="(88, 46)" end="(88, 68)" kind="Lean.Parser.Term.app">
                <OtherNode start="(88, 46)" end="(88, 66)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(88, 46)" end="(88, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(88, 46)" end="(88, 47)" leading="" trailing="" val="("/>
                    <OtherNode start="(88, 47)" end="(88, 55)" kind="«term_++_»">
                      <IdentNode start="(88, 47)" end="(88, 49)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(88, 50)" end="(88, 52)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(88, 53)" end="(88, 55)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(88, 55)" end="(88, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(88, 56)" end="(88, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(88, 57)" end="(88, 66)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(88, 67)" end="(88, 68)">
                  <IdentNode start="(88, 67)" end="(88, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(88, 69)" end="(88, 70)" leading="" trailing=" " val="="/>
              <OtherNode start="(88, 71)" end="(88, 107)" kind="Lean.Parser.Term.app">
                <OtherNode start="(88, 71)" end="(88, 90)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(88, 71)" end="(88, 87)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(88, 71)" end="(88, 72)" leading="" trailing="" val="("/>
                    <OtherNode start="(88, 72)" end="(88, 86)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(88, 72)" end="(88, 84)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(88, 85)" end="(88, 86)">
                        <IdentNode start="(88, 85)" end="(88, 86)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(88, 86)" end="(88, 87)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(88, 87)" end="(88, 88)" leading="" trailing="" val="."/>
                  <IdentNode start="(88, 88)" end="(88, 90)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(88, 91)" end="(88, 107)">
                  <OtherNode start="(88, 91)" end="(88, 107)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(88, 91)" end="(88, 92)" leading="" trailing="" val="("/>
                    <OtherNode start="(88, 92)" end="(88, 106)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(88, 92)" end="(88, 104)" leading="" trailing=" " raw_val="ys.findSome?" val="ys.findSome?"/>
                      <NullNode start="(88, 105)" end="(88, 106)">
                        <IdentNode start="(88, 105)" end="(88, 106)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(88, 106)" end="(88, 107)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(88, 108)" end="(89, 51)">
          <AtomNode start="(88, 108)" end="(88, 110)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(88, 111)" end="(89, 51)">
            <AtomNode start="(88, 111)" end="(88, 113)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(89, 3)" end="(89, 51)">
              <TacticTacticseq1IndentedNode start="(89, 3)" end="(89, 51)">
                <NullNode start="(89, 3)" end="(89, 51)">
                  <OtherNode start="(89, 3)" end="(89, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;xs ys : Array α&#10;⊢ findSome? f (xs ++ ys) = (findSome? f xs).or (findSome? f ys)" state_after="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : Array α&#10;toList✝ : List α&#10;⊢ findSome? f ({ toList := toList✝ } ++ ys) = (findSome? f { toList := toList✝ }).or (findSome? f ys)" tactic="cases xs">
                    <AtomNode start="(89, 3)" end="(89, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(89, 9)" end="(89, 11)">
                      <OtherNode start="(89, 9)" end="(89, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(89, 9)" end="(89, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(89, 11)" end="(89, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(89, 13)" end="(89, 21)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : Array α&#10;toList✝ : List α&#10;⊢ findSome? f ({ toList := toList✝ } ++ ys) = (findSome? f { toList := toList✝ }).or (findSome? f ys)" state_after="case mk.mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toList✝¹ toList✝ : List α&#10;⊢ findSome? f ({ toList := toList✝¹ } ++ { toList := toList✝ }) =&#10;    (findSome? f { toList := toList✝¹ }).or (findSome? f { toList := toList✝ })" tactic="cases ys">
                    <AtomNode start="(89, 13)" end="(89, 18)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(89, 19)" end="(89, 21)">
                      <OtherNode start="(89, 19)" end="(89, 21)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(89, 19)" end="(89, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(89, 21)" end="(89, 22)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(89, 23)" end="(89, 51)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toList✝¹ toList✝ : List α&#10;⊢ findSome? f ({ toList := toList✝¹ } ++ { toList := toList✝ }) =&#10;    (findSome? f { toList := toList✝¹ }).or (findSome? f { toList := toList✝ })" state_after="no goals" tactic="simp [List.findSome?_append]">
                    <AtomNode start="(89, 23)" end="(89, 27)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(89, 28)" end="(89, 51)">
                      <AtomNode start="(89, 28)" end="(89, 29)" leading="" trailing="" val="["/>
                      <NullNode start="(89, 29)" end="(89, 50)">
                        <OtherNode start="(89, 29)" end="(89, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(89, 29)" end="(89, 50)" leading="" trailing="" raw_val="List.findSome?_append" val="List.findSome?_append" full_name="List.findSome?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(89, 50)" end="(89, 51)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(91, 1)" end="(94, 93)" name="getElem?_zero_flatten" full_name="Array.getElem?_zero_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(91, 1)" end="(94, 93)" name="getElem?_zero_flatten" full_name="Array.getElem?_zero_flatten" _is_private_decl="False">
        <AtomNode start="(91, 1)" end="(91, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(91, 9)" end="(91, 30)">
          <IdentNode start="(91, 9)" end="(91, 30)" leading="" trailing=" " raw_val="getElem?_zero_flatten" val="getElem?_zero_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(91, 31)" end="(92, 55)">
          <NullNode start="(91, 31)" end="(91, 54)">
            <TermExplicitbinderNode start="(91, 31)" end="(91, 54)">
              <AtomNode start="(91, 31)" end="(91, 32)" leading="" trailing="" val="("/>
              <NullNode start="(91, 32)" end="(91, 35)">
                <IdentNode start="(91, 32)" end="(91, 35)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(91, 36)" end="(91, 53)">
                <AtomNode start="(91, 36)" end="(91, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(91, 38)" end="(91, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(91, 38)" end="(91, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(91, 44)" end="(91, 53)">
                    <OtherNode start="(91, 44)" end="(91, 53)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(91, 44)" end="(91, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(91, 45)" end="(91, 52)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(91, 45)" end="(91, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(91, 51)" end="(91, 52)">
                          <IdentNode start="(91, 51)" end="(91, 52)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(91, 52)" end="(91, 53)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(91, 53)" end="(91, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(91, 55)" end="(92, 55)">
            <AtomNode start="(91, 55)" end="(91, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(92, 5)" end="(92, 55)" kind="«term_=_»">
              <OtherNode start="(92, 5)" end="(92, 22)" kind="«term__[_]_?»">
                <OtherNode start="(92, 5)" end="(92, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(92, 5)" end="(92, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(92, 6)" end="(92, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(92, 6)" end="(92, 13)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="Array.flatten" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                    <NullNode start="(92, 14)" end="(92, 17)">
                      <IdentNode start="(92, 14)" end="(92, 17)" leading="" trailing="" raw_val="xss" val="xss"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(92, 17)" end="(92, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(92, 18)" end="(92, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(92, 19)" end="(92, 20)" kind="num">
                  <AtomNode start="(92, 19)" end="(92, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(92, 20)" end="(92, 21)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(92, 21)" end="(92, 22)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(92, 23)" end="(92, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(92, 25)" end="(92, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(92, 25)" end="(92, 38)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                <NullNode start="(92, 39)" end="(92, 55)">
                  <OtherNode start="(92, 39)" end="(92, 55)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(92, 39)" end="(92, 42)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(92, 43)" end="(92, 55)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(92, 43)" end="(92, 45)">
                        <IdentNode start="(92, 43)" end="(92, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(92, 46)" end="(92, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(92, 49)" end="(92, 55)" kind="«term__[_]_?»">
                        <IdentNode start="(92, 49)" end="(92, 51)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <GroupNode/>
                        <AtomNode start="(92, 51)" end="(92, 52)" leading="" trailing="" val="["/>
                        <OtherNode start="(92, 52)" end="(92, 53)" kind="num">
                          <AtomNode start="(92, 52)" end="(92, 53)" leading="" trailing="" val="0"/>
                        </OtherNode>
                        <AtomNode start="(92, 53)" end="(92, 54)" leading="" trailing="" val="]"/>
                        <GroupNode/>
                        <AtomNode start="(92, 54)" end="(92, 55)" leading="" trailing=" " val="?"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(92, 56)" end="(94, 93)">
          <AtomNode start="(92, 56)" end="(92, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(92, 59)" end="(94, 93)">
            <AtomNode start="(92, 59)" end="(92, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(93, 3)" end="(94, 93)">
              <TacticTacticseq1IndentedNode start="(93, 3)" end="(94, 93)">
                <NullNode start="(93, 3)" end="(94, 93)">
                  <OtherNode start="(93, 3)" end="(93, 35)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;⊢ xss.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) xss" state_after="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;⊢ (List.map List.toArray xss✝).toArray.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) (List.map List.toArray xss✝).toArray" tactic="cases xss using array₂_induction">
                    <AtomNode start="(93, 3)" end="(93, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(93, 9)" end="(93, 12)">
                      <OtherNode start="(93, 9)" end="(93, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(93, 9)" end="(93, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(93, 13)" end="(93, 35)">
                      <AtomNode start="(93, 13)" end="(93, 18)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(93, 19)" end="(93, 35)" leading="" trailing="&#10;  " raw_val="array₂_induction" val="array₂_induction" full_name="Array.array₂_induction" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(94, 3)" end="(94, 93)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;⊢ (List.map List.toArray xss✝).toArray.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) (List.map List.toArray xss✝).toArray" state_after="no goals" tactic="simp [← List.head?_eq_getElem?, List.head?_flatten, List.findSome?_map, Function.comp_def]">
                    <AtomNode start="(94, 3)" end="(94, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(94, 8)" end="(94, 93)">
                      <AtomNode start="(94, 8)" end="(94, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(94, 9)" end="(94, 92)">
                        <OtherNode start="(94, 9)" end="(94, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(94, 9)" end="(94, 10)">
                            <OtherNode start="(94, 9)" end="(94, 10)" kind="patternIgnore">
                              <OtherNode start="(94, 9)" end="(94, 10)" kind="token.«← »">
                                <AtomNode start="(94, 9)" end="(94, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(94, 11)" end="(94, 33)" leading="" trailing="" raw_val="List.head?_eq_getElem?" val="List.head?_eq_getElem?" full_name="List.head?_eq_getElem?" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(94, 33)" end="(94, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 35)" end="(94, 53)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(94, 35)" end="(94, 53)" leading="" trailing="" raw_val="List.head?_flatten" val="List.head?_flatten" full_name="List.head?_flatten" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(94, 53)" end="(94, 54)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 55)" end="(94, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(94, 55)" end="(94, 73)" leading="" trailing="" raw_val="List.findSome?_map" val="List.findSome?_map" full_name="List.findSome?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(94, 73)" end="(94, 74)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 75)" end="(94, 92)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(94, 75)" end="(94, 92)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(94, 92)" end="(94, 93)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(96, 1)" end="(104, 34)" name="getElem_zero_flatten.proof" full_name="Array.getElem_zero_flatten.proof">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(96, 1)" end="(104, 34)" name="getElem_zero_flatten.proof" full_name="Array.getElem_zero_flatten.proof" _is_private_decl="False">
        <AtomNode start="(96, 1)" end="(96, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(96, 9)" end="(96, 35)">
          <IdentNode start="(96, 9)" end="(96, 35)" leading="" trailing=" " raw_val="getElem_zero_flatten.proof" val="getElem_zero_flatten.proof"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(96, 36)" end="(97, 44)">
          <NullNode start="(96, 36)" end="(96, 86)">
            <OtherNode start="(96, 36)" end="(96, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(96, 36)" end="(96, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(96, 37)" end="(96, 40)">
                <IdentNode start="(96, 37)" end="(96, 40)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(96, 41)" end="(96, 58)">
                <AtomNode start="(96, 41)" end="(96, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(96, 43)" end="(96, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(96, 43)" end="(96, 48)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(96, 49)" end="(96, 58)">
                    <OtherNode start="(96, 49)" end="(96, 58)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(96, 49)" end="(96, 50)" leading="" trailing="" val="("/>
                      <OtherNode start="(96, 50)" end="(96, 57)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(96, 50)" end="(96, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(96, 56)" end="(96, 57)">
                          <IdentNode start="(96, 56)" end="(96, 57)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(96, 57)" end="(96, 58)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(96, 58)" end="(96, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(96, 60)" end="(96, 86)">
              <AtomNode start="(96, 60)" end="(96, 61)" leading="" trailing="" val="("/>
              <NullNode start="(96, 61)" end="(96, 62)">
                <IdentNode start="(96, 61)" end="(96, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(96, 63)" end="(96, 85)">
                <AtomNode start="(96, 63)" end="(96, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(96, 65)" end="(96, 85)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(96, 65)" end="(96, 66)" kind="num">
                    <AtomNode start="(96, 65)" end="(96, 66)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(96, 67)" end="(96, 68)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(96, 69)" end="(96, 85)" leading="" trailing="" raw_val="xss.flatten.size" val="xss.flatten.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(96, 85)" end="(96, 86)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(96, 87)" end="(97, 44)">
            <AtomNode start="(96, 87)" end="(96, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(97, 5)" end="(97, 44)" kind="Lean.Parser.Term.proj">
              <OtherNode start="(97, 5)" end="(97, 37)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(97, 5)" end="(97, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(97, 6)" end="(97, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(97, 6)" end="(97, 19)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                  <NullNode start="(97, 20)" end="(97, 36)">
                    <OtherNode start="(97, 20)" end="(97, 36)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(97, 20)" end="(97, 23)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(97, 24)" end="(97, 36)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(97, 24)" end="(97, 26)">
                          <IdentNode start="(97, 24)" end="(97, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(97, 27)" end="(97, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(97, 30)" end="(97, 36)" kind="«term__[_]_?»">
                          <IdentNode start="(97, 30)" end="(97, 32)" leading="" trailing="" raw_val="xs" val="xs"/>
                          <GroupNode/>
                          <AtomNode start="(97, 32)" end="(97, 33)" leading="" trailing="" val="["/>
                          <OtherNode start="(97, 33)" end="(97, 34)" kind="num">
                            <AtomNode start="(97, 33)" end="(97, 34)" leading="" trailing="" val="0"/>
                          </OtherNode>
                          <AtomNode start="(97, 34)" end="(97, 35)" leading="" trailing="" val="]"/>
                          <GroupNode/>
                          <AtomNode start="(97, 35)" end="(97, 36)" leading="" trailing="" val="?"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(97, 36)" end="(97, 37)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(97, 37)" end="(97, 38)" leading="" trailing="" val="."/>
              <IdentNode start="(97, 38)" end="(97, 44)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(97, 45)" end="(104, 34)">
          <AtomNode start="(97, 45)" end="(97, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(97, 48)" end="(104, 34)">
            <AtomNode start="(97, 48)" end="(97, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(98, 3)" end="(104, 34)">
              <TacticTacticseq1IndentedNode start="(98, 3)" end="(104, 34)">
                <NullNode start="(98, 3)" end="(104, 34)">
                  <OtherNode start="(98, 3)" end="(98, 35)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;h : 0 &amp;lt; xss.flatten.size&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?) xss).isSome = true" state_after="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;h : 0 &amp;lt; (List.map List.toArray xss✝).toArray.flatten.size&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?) (List.map List.toArray xss✝).toArray).isSome = true" tactic="cases xss using array₂_induction">
                    <AtomNode start="(98, 3)" end="(98, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(98, 9)" end="(98, 12)">
                      <OtherNode start="(98, 9)" end="(98, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(98, 9)" end="(98, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(98, 13)" end="(98, 35)">
                      <AtomNode start="(98, 13)" end="(98, 18)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(98, 19)" end="(98, 35)" leading="" trailing="&#10;  " raw_val="array₂_induction" val="array₂_induction" full_name="Array.array₂_induction" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(99, 3)" end="(100, 48)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;h : 0 &amp;lt; (List.map List.toArray xss✝).toArray.flatten.size&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?) (List.map List.toArray xss✝).toArray).isSome = true" state_after="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;h : 0 &amp;lt; (List.map List.toArray xss✝).toArray.flatten.size&#10;⊢ ∃ x, x ∈ xss✝ ∧ 0 &amp;lt; x.length" tactic="simp only [List.findSome?_toArray, List.findSome?_map, Function.comp_def, List.getElem?_toArray,&#10;  List.findSome?_isSome_iff, isSome_getElem?]">
                    <AtomNode start="(99, 3)" end="(99, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(99, 8)" end="(99, 12)">
                      <AtomNode start="(99, 8)" end="(99, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(99, 13)" end="(100, 48)">
                      <AtomNode start="(99, 13)" end="(99, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(99, 14)" end="(100, 47)">
                        <OtherNode start="(99, 14)" end="(99, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(99, 14)" end="(99, 36)" leading="" trailing="" raw_val="List.findSome?_toArray" val="List.findSome?_toArray" full_name="List.findSome?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(99, 36)" end="(99, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(99, 38)" end="(99, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(99, 38)" end="(99, 56)" leading="" trailing="" raw_val="List.findSome?_map" val="List.findSome?_map" full_name="List.findSome?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(99, 56)" end="(99, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(99, 58)" end="(99, 75)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(99, 58)" end="(99, 75)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(99, 75)" end="(99, 76)" leading="" trailing=" " val=","/>
                        <OtherNode start="(99, 77)" end="(99, 98)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(99, 77)" end="(99, 98)" leading="" trailing="" raw_val="List.getElem?_toArray" val="List.getElem?_toArray" full_name="List.getElem?_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(99, 98)" end="(99, 99)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(100, 5)" end="(100, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(100, 5)" end="(100, 30)" leading="" trailing="" raw_val="List.findSome?_isSome_iff" val="List.findSome?_isSome_iff" full_name="List.findSome?_isSome_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(100, 30)" end="(100, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(100, 32)" end="(100, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(100, 32)" end="(100, 47)" leading="" trailing="" raw_val="isSome_getElem?" val="isSome_getElem?" full_name="isSome_getElem?" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(100, 47)" end="(100, 48)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(101, 3)" end="(102, 51)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;h : 0 &amp;lt; (List.map List.toArray xss✝).toArray.flatten.size&#10;⊢ ∃ x, x ∈ xss✝ ∧ 0 &amp;lt; x.length" state_after="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;h : ∃ x, (∃ a, a ∈ xss✝ ∧ a.length = x) ∧ 0 &amp;lt; x&#10;⊢ ∃ x, x ∈ xss✝ ∧ 0 &amp;lt; x.length" tactic="simp only [flatten_toArray_map_toArray, List.size_toArray, List.length_flatten,&#10;  Nat.sum_pos_iff_exists_pos, List.mem_map] at h">
                    <AtomNode start="(101, 3)" end="(101, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(101, 8)" end="(101, 12)">
                      <AtomNode start="(101, 8)" end="(101, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(101, 13)" end="(102, 46)">
                      <AtomNode start="(101, 13)" end="(101, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(101, 14)" end="(102, 45)">
                        <OtherNode start="(101, 14)" end="(101, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(101, 14)" end="(101, 41)" leading="" trailing="" raw_val="flatten_toArray_map_toArray" val="flatten_toArray_map_toArray" full_name="Array.flatten_toArray_map_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(101, 41)" end="(101, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(101, 43)" end="(101, 60)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(101, 43)" end="(101, 60)" leading="" trailing="" raw_val="List.size_toArray" val="List.size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(101, 60)" end="(101, 61)" leading="" trailing=" " val=","/>
                        <OtherNode start="(101, 62)" end="(101, 81)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(101, 62)" end="(101, 81)" leading="" trailing="" raw_val="List.length_flatten" val="List.length_flatten" full_name="List.length_flatten" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(101, 81)" end="(101, 82)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(102, 5)" end="(102, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(102, 5)" end="(102, 31)" leading="" trailing="" raw_val="Nat.sum_pos_iff_exists_pos" val="Nat.sum_pos_iff_exists_pos" full_name="Nat.sum_pos_iff_exists_pos" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(102, 31)" end="(102, 32)" leading="" trailing=" " val=","/>
                        <OtherNode start="(102, 33)" end="(102, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(102, 33)" end="(102, 45)" leading="" trailing="" raw_val="List.mem_map" val="List.mem_map" full_name="List.mem_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(102, 45)" end="(102, 46)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(102, 47)" end="(102, 51)">
                      <OtherNode start="(102, 47)" end="(102, 51)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(102, 47)" end="(102, 49)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(102, 50)" end="(102, 51)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(102, 50)" end="(102, 51)">
                            <IdentNode start="(102, 50)" end="(102, 51)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(103, 3)" end="(103, 35)" kind="Lean.Parser.Tactic.obtain" state_before="case of&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;h : ∃ x, (∃ a, a ∈ xss✝ ∧ a.length = x) ∧ 0 &amp;lt; x&#10;⊢ ∃ x, x ∈ xss✝ ∧ 0 &amp;lt; x.length" state_after="case of.intro.intro.intro.intro&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;xs : List α&#10;m : xs ∈ xss✝&#10;h : 0 &amp;lt; xs.length&#10;⊢ ∃ x, x ∈ xss✝ ∧ 0 &amp;lt; x.length" tactic="obtain ⟨_, ⟨xs, m, rfl⟩, h⟩ := h">
                    <AtomNode start="(103, 3)" end="(103, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(103, 10)" end="(103, 30)">
                      <OtherNode start="(103, 10)" end="(103, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(103, 10)" end="(103, 30)">
                          <OtherNode start="(103, 10)" end="(103, 30)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(103, 10)" end="(103, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(103, 11)" end="(103, 29)">
                              <OtherNode start="(103, 11)" end="(103, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(103, 11)" end="(103, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(103, 11)" end="(103, 12)">
                                    <OtherNode start="(103, 11)" end="(103, 12)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                      <AtomNode start="(103, 11)" end="(103, 12)" leading="" trailing="" val="_"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(103, 12)" end="(103, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(103, 14)" end="(103, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(103, 14)" end="(103, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(103, 14)" end="(103, 26)">
                                    <OtherNode start="(103, 14)" end="(103, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                      <AtomNode start="(103, 14)" end="(103, 15)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(103, 15)" end="(103, 25)">
                                        <OtherNode start="(103, 15)" end="(103, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                          <OtherNode start="(103, 15)" end="(103, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                            <NullNode start="(103, 15)" end="(103, 17)">
                                              <OtherNode start="(103, 15)" end="(103, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                <IdentNode start="(103, 15)" end="(103, 17)" leading="" trailing="" raw_val="xs" val="xs"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(103, 17)" end="(103, 18)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(103, 19)" end="(103, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                          <OtherNode start="(103, 19)" end="(103, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                            <NullNode start="(103, 19)" end="(103, 20)">
                                              <OtherNode start="(103, 19)" end="(103, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                <IdentNode start="(103, 19)" end="(103, 20)" leading="" trailing="" raw_val="m" val="m"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(103, 20)" end="(103, 21)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(103, 22)" end="(103, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                          <OtherNode start="(103, 22)" end="(103, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                            <NullNode start="(103, 22)" end="(103, 25)">
                                              <OtherNode start="(103, 22)" end="(103, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                <IdentNode start="(103, 22)" end="(103, 25)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(103, 25)" end="(103, 26)" leading="" trailing="" val="⟩"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(103, 26)" end="(103, 27)" leading="" trailing=" " val=","/>
                              <OtherNode start="(103, 28)" end="(103, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(103, 28)" end="(103, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(103, 28)" end="(103, 29)">
                                    <OtherNode start="(103, 28)" end="(103, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(103, 28)" end="(103, 29)" leading="" trailing="" raw_val="h" val="h"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(103, 29)" end="(103, 30)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(103, 31)" end="(103, 35)">
                      <AtomNode start="(103, 31)" end="(103, 33)" leading="" trailing=" " val=":="/>
                      <NullNode start="(103, 34)" end="(103, 35)">
                        <IdentNode start="(103, 34)" end="(103, 35)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(104, 3)" end="(104, 34)" kind="Lean.Parser.Tactic.exact" state_before="case of.intro.intro.intro.intro&#10;α : Type u_1&#10;xss✝ : List (List α)&#10;xs : List α&#10;m : xs ∈ xss✝&#10;h : 0 &amp;lt; xs.length&#10;⊢ ∃ x, x ∈ xss✝ ∧ 0 &amp;lt; x.length" state_after="no goals" tactic="exact ⟨xs, m, by simpa using h⟩">
                    <AtomNode start="(104, 3)" end="(104, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(104, 9)" end="(104, 34)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(104, 9)" end="(104, 10)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(104, 10)" end="(104, 33)">
                        <IdentNode start="(104, 10)" end="(104, 12)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <AtomNode start="(104, 12)" end="(104, 13)" leading="" trailing=" " val=","/>
                        <IdentNode start="(104, 14)" end="(104, 15)" leading="" trailing="" raw_val="m" val="m"/>
                        <AtomNode start="(104, 15)" end="(104, 16)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(104, 17)" end="(104, 33)">
                          <AtomNode start="(104, 17)" end="(104, 19)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(104, 20)" end="(104, 33)">
                            <TacticTacticseq1IndentedNode start="(104, 20)" end="(104, 33)">
                              <NullNode start="(104, 20)" end="(104, 33)">
                                <OtherNode start="(104, 20)" end="(104, 33)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;xss✝ : List (List α)&#10;xs : List α&#10;m : xs ∈ xss✝&#10;h : 0 &amp;lt; xs.length&#10;⊢ 0 &amp;lt; xs.length" state_after="no goals" tactic="simpa using h">
                                  <AtomNode start="(104, 20)" end="(104, 25)" leading="" trailing=" " val="simpa"/>
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(104, 26)" end="(104, 33)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(104, 26)" end="(104, 33)">
                                      <AtomNode start="(104, 26)" end="(104, 31)" leading="" trailing=" " val="using"/>
                                      <IdentNode start="(104, 32)" end="(104, 33)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                      <AtomNode start="(104, 33)" end="(104, 34)" leading="" trailing="&#10;&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(106, 1)" end="(110, 13)" name="getElem_zero_flatten" full_name="Array.getElem_zero_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(106, 1)" end="(110, 13)" name="getElem_zero_flatten" full_name="Array.getElem_zero_flatten" _is_private_decl="False">
        <AtomNode start="(106, 1)" end="(106, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(106, 9)" end="(106, 29)">
          <IdentNode start="(106, 9)" end="(106, 29)" leading="" trailing=" " raw_val="getElem_zero_flatten" val="getElem_zero_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(106, 30)" end="(107, 91)">
          <NullNode start="(106, 30)" end="(106, 57)">
            <OtherNode start="(106, 30)" end="(106, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 30)" end="(106, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 31)" end="(106, 34)">
                <IdentNode start="(106, 31)" end="(106, 34)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(106, 35)" end="(106, 52)">
                <AtomNode start="(106, 35)" end="(106, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 37)" end="(106, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(106, 37)" end="(106, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(106, 43)" end="(106, 52)">
                    <OtherNode start="(106, 43)" end="(106, 52)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(106, 43)" end="(106, 44)" leading="" trailing="" val="("/>
                      <OtherNode start="(106, 44)" end="(106, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(106, 44)" end="(106, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(106, 50)" end="(106, 51)">
                          <IdentNode start="(106, 50)" end="(106, 51)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(106, 51)" end="(106, 52)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 52)" end="(106, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(106, 54)" end="(106, 57)">
              <AtomNode start="(106, 54)" end="(106, 55)" leading="" trailing="" val="("/>
              <NullNode start="(106, 55)" end="(106, 56)">
                <IdentNode start="(106, 55)" end="(106, 56)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(106, 56)" end="(106, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(106, 58)" end="(107, 91)">
            <AtomNode start="(106, 58)" end="(106, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(107, 5)" end="(107, 91)" kind="«term_=_»">
              <OtherNode start="(107, 5)" end="(107, 21)" kind="«term__[_]»">
                <OtherNode start="(107, 5)" end="(107, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(107, 5)" end="(107, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(107, 6)" end="(107, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(107, 6)" end="(107, 13)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="Array.flatten" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                    <NullNode start="(107, 14)" end="(107, 17)">
                      <IdentNode start="(107, 14)" end="(107, 17)" leading="" trailing="" raw_val="xss" val="xss"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(107, 17)" end="(107, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(107, 18)" end="(107, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(107, 19)" end="(107, 20)" kind="num">
                  <AtomNode start="(107, 19)" end="(107, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(107, 20)" end="(107, 21)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(107, 22)" end="(107, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(107, 24)" end="(107, 91)" kind="Lean.Parser.Term.app">
                <OtherNode start="(107, 24)" end="(107, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(107, 24)" end="(107, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(107, 24)" end="(107, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(107, 25)" end="(107, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(107, 25)" end="(107, 38)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                      <NullNode start="(107, 39)" end="(107, 55)">
                        <OtherNode start="(107, 39)" end="(107, 55)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(107, 39)" end="(107, 42)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(107, 43)" end="(107, 55)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(107, 43)" end="(107, 45)">
                              <IdentNode start="(107, 43)" end="(107, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(107, 46)" end="(107, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(107, 49)" end="(107, 55)" kind="«term__[_]_?»">
                              <IdentNode start="(107, 49)" end="(107, 51)" leading="" trailing="" raw_val="xs" val="xs"/>
                              <GroupNode/>
                              <AtomNode start="(107, 51)" end="(107, 52)" leading="" trailing="" val="["/>
                              <OtherNode start="(107, 52)" end="(107, 53)" kind="num">
                                <AtomNode start="(107, 52)" end="(107, 53)" leading="" trailing="" val="0"/>
                              </OtherNode>
                              <AtomNode start="(107, 53)" end="(107, 54)" leading="" trailing="" val="]"/>
                              <GroupNode/>
                              <AtomNode start="(107, 54)" end="(107, 55)" leading="" trailing="" val="?"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(107, 55)" end="(107, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(107, 56)" end="(107, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(107, 57)" end="(107, 60)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(107, 61)" end="(107, 91)">
                  <OtherNode start="(107, 61)" end="(107, 91)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(107, 61)" end="(107, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(107, 62)" end="(107, 90)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(107, 62)" end="(107, 88)" leading="" trailing=" " raw_val="getElem_zero_flatten.proof" val="getElem_zero_flatten.proof" full_name="Array.getElem_zero_flatten.proof" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(96, 9)" def_end="(96, 35)"/>
                      <NullNode start="(107, 89)" end="(107, 90)">
                        <IdentNode start="(107, 89)" end="(107, 90)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(107, 90)" end="(107, 91)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(107, 92)" end="(110, 13)">
          <AtomNode start="(107, 92)" end="(107, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(107, 95)" end="(110, 13)">
            <AtomNode start="(107, 95)" end="(107, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(108, 3)" end="(110, 13)">
              <TacticTacticseq1IndentedNode start="(108, 3)" end="(110, 13)">
                <NullNode start="(108, 3)" end="(110, 13)">
                  <OtherNode start="(108, 3)" end="(108, 38)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;h : 0 &amp;lt; xss.flatten.size&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" state_after="α : Type u_1&#10;xss : Array (Array α)&#10;h : 0 &amp;lt; xss.flatten.size&#10;t : xss.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) xss&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" tactic="have t := getElem?_zero_flatten xss">
                    <AtomNode start="(108, 3)" end="(108, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(108, 8)" end="(108, 38)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(108, 8)" end="(108, 38)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(108, 8)" end="(108, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(108, 8)" end="(108, 9)" leading="" trailing=" " raw_val="t" val="t"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(108, 10)" end="(108, 12)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(108, 13)" end="(108, 38)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(108, 13)" end="(108, 34)" leading="" trailing=" " raw_val="getElem?_zero_flatten" val="getElem?_zero_flatten" full_name="Array.getElem?_zero_flatten" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(91, 9)" def_end="(91, 30)"/>
                          <NullNode start="(108, 35)" end="(108, 38)">
                            <IdentNode start="(108, 35)" end="(108, 38)" leading="" trailing="&#10;  " raw_val="xss" val="xss"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(109, 3)" end="(109, 37)" kind="Lean.Parser.Tactic.simp">
                    <AtomNode start="(109, 3)" end="(109, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(109, 8)" end="(109, 32)">
                      <AtomNode start="(109, 8)" end="(109, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(109, 9)" end="(109, 31)">
                        <OtherNode start="(109, 9)" end="(109, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(109, 9)" end="(109, 28)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="Array.getElem?_eq_getElem" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(109, 28)" end="(109, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(109, 30)" end="(109, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(109, 30)" end="(109, 31)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(109, 31)" end="(109, 32)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(109, 33)" end="(109, 37)">
                      <OtherNode start="(109, 33)" end="(109, 37)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(109, 33)" end="(109, 35)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(109, 36)" end="(109, 37)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(109, 36)" end="(109, 37)">
                            <IdentNode start="(109, 36)" end="(109, 37)" leading="" trailing="&#10;  " raw_val="t" val="t"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(110, 3)" end="(110, 13)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;h : 0 &amp;lt; xss.flatten.size&#10;t : xss.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) xss&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" state_after="no goals" tactic="simp [← t]">
                    <AtomNode start="(110, 3)" end="(110, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(110, 8)" end="(110, 13)">
                      <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(110, 9)" end="(110, 12)">
                        <OtherNode start="(110, 9)" end="(110, 12)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(110, 9)" end="(110, 10)">
                            <OtherNode start="(110, 9)" end="(110, 10)" kind="patternIgnore">
                              <OtherNode start="(110, 9)" end="(110, 10)" kind="token.«← »">
                                <AtomNode start="(110, 9)" end="(110, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(110, 11)" end="(110, 12)" leading="" trailing="" raw_val="t" val="t"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(110, 12)" end="(110, 13)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(112, 1)" end="(113, 60)" name="findSome?_replicate" full_name="Array.findSome?_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(112, 1)" end="(113, 60)" name="findSome?_replicate" full_name="Array.findSome?_replicate" _is_private_decl="False">
        <AtomNode start="(112, 1)" end="(112, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(112, 9)" end="(112, 28)">
          <IdentNode start="(112, 9)" end="(112, 28)" leading="" trailing=" " raw_val="findSome?_replicate" val="findSome?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(112, 29)" end="(112, 88)">
          <NullNode/>
          <TermTypespecNode start="(112, 29)" end="(112, 88)">
            <AtomNode start="(112, 29)" end="(112, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(112, 31)" end="(112, 88)" kind="«term_=_»">
              <OtherNode start="(112, 31)" end="(112, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(112, 31)" end="(112, 40)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(112, 41)" end="(112, 58)">
                  <IdentNode start="(112, 41)" end="(112, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(112, 43)" end="(112, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(112, 43)" end="(112, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(112, 44)" end="(112, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(112, 44)" end="(112, 53)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(112, 54)" end="(112, 57)">
                        <IdentNode start="(112, 54)" end="(112, 55)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(112, 56)" end="(112, 57)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(112, 57)" end="(112, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(112, 59)" end="(112, 60)" leading="" trailing=" " val="="/>
              <OtherNode start="(112, 61)" end="(112, 88)" kind="termIfThenElse">
                <AtomNode start="(112, 61)" end="(112, 63)" leading="" trailing=" " val="if"/>
                <OtherNode start="(112, 64)" end="(112, 69)" kind="«term_=_»">
                  <IdentNode start="(112, 64)" end="(112, 65)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(112, 66)" end="(112, 67)" leading="" trailing=" " val="="/>
                  <OtherNode start="(112, 68)" end="(112, 69)" kind="num">
                    <AtomNode start="(112, 68)" end="(112, 69)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(112, 70)" end="(112, 74)" leading="" trailing=" " val="then"/>
                <IdentNode start="(112, 75)" end="(112, 79)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(112, 80)" end="(112, 84)" leading="" trailing=" " val="else"/>
                <OtherNode start="(112, 85)" end="(112, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(112, 85)" end="(112, 86)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(112, 87)" end="(112, 88)">
                    <IdentNode start="(112, 87)" end="(112, 88)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(112, 89)" end="(113, 60)">
          <AtomNode start="(112, 89)" end="(112, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(112, 92)" end="(113, 60)">
            <AtomNode start="(112, 92)" end="(112, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(113, 3)" end="(113, 60)">
              <TacticTacticseq1IndentedNode start="(113, 3)" end="(113, 60)">
                <NullNode start="(113, 3)" end="(113, 60)">
                  <OtherNode start="(113, 3)" end="(113, 60)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;⊢ findSome? f (replicate n a) = if n = 0 then none else f a" state_after="no goals" tactic="simp [← List.toArray_replicate, List.findSome?_replicate]">
                    <AtomNode start="(113, 3)" end="(113, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(113, 8)" end="(113, 60)">
                      <AtomNode start="(113, 8)" end="(113, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(113, 9)" end="(113, 59)">
                        <OtherNode start="(113, 9)" end="(113, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(113, 9)" end="(113, 10)">
                            <OtherNode start="(113, 9)" end="(113, 10)" kind="patternIgnore">
                              <OtherNode start="(113, 9)" end="(113, 10)" kind="token.«← »">
                                <AtomNode start="(113, 9)" end="(113, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(113, 11)" end="(113, 33)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(113, 33)" end="(113, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(113, 35)" end="(113, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(113, 35)" end="(113, 59)" leading="" trailing="" raw_val="List.findSome?_replicate" val="List.findSome?_replicate" full_name="List.findSome?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(113, 59)" end="(113, 60)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(115, 1)" end="(116, 49)" name="findSome?_mkArray" full_name="Array.findSome?_mkArray">
      <CommandDeclmodifiersNode start="(115, 1)" end="(115, 58)">
        <NullNode/>
        <NullNode start="(115, 1)" end="(115, 58)">
          <OtherNode start="(115, 1)" end="(115, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(115, 1)" end="(115, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(115, 3)" end="(115, 57)">
              <OtherNode start="(115, 3)" end="(115, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(115, 3)" end="(115, 57)" kind="Lean.deprecated">
                  <AtomNode start="(115, 3)" end="(115, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(115, 14)" end="(115, 33)">
                    <IdentNode start="(115, 14)" end="(115, 33)" leading="" trailing=" " raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Array.findSome?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(112, 9)" def_end="(112, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(115, 34)" end="(115, 57)">
                    <AtomNode start="(115, 34)" end="(115, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(115, 35)" end="(115, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(115, 41)" end="(115, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(115, 44)" end="(115, 56)" kind="str">
                      <AtomNode start="(115, 44)" end="(115, 56)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(115, 56)" end="(115, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(115, 57)" end="(115, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(116, 1)" end="(116, 49)" name="findSome?_mkArray">
        <AtomNode start="(116, 1)" end="(116, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(116, 8)" end="(116, 25)">
          <IdentNode start="(116, 8)" end="(116, 25)" leading="" trailing=" " raw_val="findSome?_mkArray" val="findSome?_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(116, 26)" end="(116, 49)">
          <AtomNode start="(116, 26)" end="(116, 28)" leading="" trailing=" " val=":="/>
          <OtherNode start="(116, 29)" end="(116, 49)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(116, 29)" end="(116, 30)" leading="" trailing="" val="@"/>
            <IdentNode start="(116, 30)" end="(116, 49)" leading="" trailing="&#10;&#10;" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Array.findSome?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(112, 9)" def_end="(112, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(118, 1)" end="(119, 45)" name="findSome?_replicate_of_pos" full_name="Array.findSome?_replicate_of_pos">
      <CommandDeclmodifiersNode start="(118, 1)" end="(118, 8)">
        <NullNode/>
        <NullNode start="(118, 1)" end="(118, 8)">
          <OtherNode start="(118, 1)" end="(118, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(118, 1)" end="(118, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(118, 3)" end="(118, 7)">
              <OtherNode start="(118, 3)" end="(118, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(118, 3)" end="(118, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(118, 3)" end="(118, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(118, 7)" end="(118, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(118, 9)" end="(119, 45)" name="findSome?_replicate_of_pos" full_name="Array.findSome?_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(118, 9)" end="(118, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(118, 17)" end="(118, 43)">
          <IdentNode start="(118, 17)" end="(118, 43)" leading="" trailing=" " raw_val="findSome?_replicate_of_pos" val="findSome?_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(118, 44)" end="(118, 91)">
          <NullNode start="(118, 44)" end="(118, 55)">
            <TermExplicitbinderNode start="(118, 44)" end="(118, 55)">
              <AtomNode start="(118, 44)" end="(118, 45)" leading="" trailing="" val="("/>
              <NullNode start="(118, 45)" end="(118, 46)">
                <IdentNode start="(118, 45)" end="(118, 46)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(118, 47)" end="(118, 54)">
                <AtomNode start="(118, 47)" end="(118, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(118, 49)" end="(118, 54)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(118, 49)" end="(118, 50)" kind="num">
                    <AtomNode start="(118, 49)" end="(118, 50)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(118, 51)" end="(118, 52)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(118, 53)" end="(118, 54)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(118, 54)" end="(118, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(118, 56)" end="(118, 91)">
            <AtomNode start="(118, 56)" end="(118, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(118, 58)" end="(118, 91)" kind="«term_=_»">
              <OtherNode start="(118, 58)" end="(118, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(118, 58)" end="(118, 67)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(118, 68)" end="(118, 85)">
                  <IdentNode start="(118, 68)" end="(118, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(118, 70)" end="(118, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(118, 70)" end="(118, 71)" leading="" trailing="" val="("/>
                    <OtherNode start="(118, 71)" end="(118, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(118, 71)" end="(118, 80)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(118, 81)" end="(118, 84)">
                        <IdentNode start="(118, 81)" end="(118, 82)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(118, 83)" end="(118, 84)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(118, 84)" end="(118, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(118, 86)" end="(118, 87)" leading="" trailing=" " val="="/>
              <OtherNode start="(118, 88)" end="(118, 91)" kind="Lean.Parser.Term.app">
                <IdentNode start="(118, 88)" end="(118, 89)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(118, 90)" end="(118, 91)">
                  <IdentNode start="(118, 90)" end="(118, 91)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(118, 92)" end="(119, 45)">
          <AtomNode start="(118, 92)" end="(118, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(118, 95)" end="(119, 45)">
            <AtomNode start="(118, 95)" end="(118, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(119, 3)" end="(119, 45)">
              <TacticTacticseq1IndentedNode start="(119, 3)" end="(119, 45)">
                <NullNode start="(119, 3)" end="(119, 45)">
                  <OtherNode start="(119, 3)" end="(119, 45)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;h : 0 &amp;lt; n&#10;⊢ findSome? f (replicate n a) = f a" state_after="no goals" tactic="simp [findSome?_replicate, Nat.ne_of_gt h]">
                    <AtomNode start="(119, 3)" end="(119, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(119, 8)" end="(119, 45)">
                      <AtomNode start="(119, 8)" end="(119, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(119, 9)" end="(119, 44)">
                        <OtherNode start="(119, 9)" end="(119, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(119, 9)" end="(119, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Array.findSome?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(112, 9)" def_end="(112, 28)"/>
                        </OtherNode>
                        <AtomNode start="(119, 28)" end="(119, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(119, 30)" end="(119, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(119, 30)" end="(119, 44)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(119, 30)" end="(119, 42)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(119, 43)" end="(119, 44)">
                              <IdentNode start="(119, 43)" end="(119, 44)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(119, 44)" end="(119, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(121, 1)" end="(122, 63)" name="findSome?_mkArray_of_pos" full_name="Array.findSome?_mkArray_of_pos">
      <CommandDeclmodifiersNode start="(121, 1)" end="(121, 65)">
        <NullNode/>
        <NullNode start="(121, 1)" end="(121, 65)">
          <OtherNode start="(121, 1)" end="(121, 65)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(121, 1)" end="(121, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(121, 3)" end="(121, 64)">
              <OtherNode start="(121, 3)" end="(121, 64)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(121, 3)" end="(121, 64)" kind="Lean.deprecated">
                  <AtomNode start="(121, 3)" end="(121, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(121, 14)" end="(121, 40)">
                    <IdentNode start="(121, 14)" end="(121, 40)" leading="" trailing=" " raw_val="findSome?_replicate_of_pos" val="findSome?_replicate_of_pos" full_name="Array.findSome?_replicate_of_pos" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(118, 17)" def_end="(118, 43)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(121, 41)" end="(121, 64)">
                    <AtomNode start="(121, 41)" end="(121, 42)" leading="" trailing="" val="("/>
                    <AtomNode start="(121, 42)" end="(121, 47)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(121, 48)" end="(121, 50)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(121, 51)" end="(121, 63)" kind="str">
                      <AtomNode start="(121, 51)" end="(121, 63)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(121, 63)" end="(121, 64)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(121, 64)" end="(121, 65)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(122, 1)" end="(122, 63)" name="findSome?_mkArray_of_pos">
        <AtomNode start="(122, 1)" end="(122, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(122, 8)" end="(122, 32)">
          <IdentNode start="(122, 8)" end="(122, 32)" leading="" trailing=" " raw_val="findSome?_mkArray_of_pos" val="findSome?_mkArray_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(122, 33)" end="(122, 63)">
          <AtomNode start="(122, 33)" end="(122, 35)" leading="" trailing=" " val=":="/>
          <OtherNode start="(122, 36)" end="(122, 63)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(122, 36)" end="(122, 37)" leading="" trailing="" val="@"/>
            <IdentNode start="(122, 37)" end="(122, 63)" leading="" trailing="&#10;&#10;-- Argument is unused, but used to decide whether `simp` should unfold.&#10;" raw_val="findSome?_replicate_of_pos" val="findSome?_replicate_of_pos" full_name="Array.findSome?_replicate_of_pos" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(118, 17)" def_end="(118, 43)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(125, 1)" end="(127, 29)" name="findSome?_replicate_of_isSome" full_name="Array.findSome?_replicate_of_isSome">
      <CommandDeclmodifiersNode start="(125, 1)" end="(125, 8)">
        <NullNode/>
        <NullNode start="(125, 1)" end="(125, 8)">
          <OtherNode start="(125, 1)" end="(125, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(125, 1)" end="(125, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(125, 3)" end="(125, 7)">
              <OtherNode start="(125, 3)" end="(125, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(125, 3)" end="(125, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(125, 3)" end="(125, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(125, 7)" end="(125, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(125, 9)" end="(127, 29)" name="findSome?_replicate_of_isSome" full_name="Array.findSome?_replicate_of_isSome" _is_private_decl="False">
        <AtomNode start="(125, 9)" end="(125, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(125, 17)" end="(125, 46)">
          <IdentNode start="(125, 17)" end="(125, 46)" leading="" trailing=" " raw_val="findSome?_replicate_of_isSome" val="findSome?_replicate_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(125, 47)" end="(126, 61)">
          <NullNode start="(125, 47)" end="(125, 65)">
            <TermExplicitbinderNode start="(125, 47)" end="(125, 65)">
              <AtomNode start="(125, 47)" end="(125, 48)" leading="" trailing="" val="("/>
              <NullNode start="(125, 48)" end="(125, 49)">
                <TermHoleNode start="(125, 48)" end="(125, 49)">
                  <AtomNode start="(125, 48)" end="(125, 49)" leading="" trailing=" " val="_"/>
                </TermHoleNode>
              </NullNode>
              <NullNode start="(125, 50)" end="(125, 64)">
                <AtomNode start="(125, 50)" end="(125, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(125, 52)" end="(125, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(125, 52)" end="(125, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(125, 52)" end="(125, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(125, 53)" end="(125, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(125, 53)" end="(125, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(125, 55)" end="(125, 56)">
                        <IdentNode start="(125, 55)" end="(125, 56)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(125, 56)" end="(125, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(125, 57)" end="(125, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(125, 58)" end="(125, 64)" leading="" trailing="" raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(125, 64)" end="(125, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(125, 66)" end="(126, 61)">
            <AtomNode start="(125, 66)" end="(125, 67)" leading="" trailing="&#10;   " val=":"/>
            <OtherNode start="(126, 4)" end="(126, 61)" kind="«term_=_»">
              <OtherNode start="(126, 4)" end="(126, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(126, 4)" end="(126, 13)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(126, 14)" end="(126, 31)">
                  <IdentNode start="(126, 14)" end="(126, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(126, 16)" end="(126, 31)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(126, 16)" end="(126, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(126, 17)" end="(126, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(126, 17)" end="(126, 26)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(126, 27)" end="(126, 30)">
                        <IdentNode start="(126, 27)" end="(126, 28)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(126, 29)" end="(126, 30)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(126, 30)" end="(126, 31)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(126, 32)" end="(126, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(126, 34)" end="(126, 61)" kind="termIfThenElse">
                <AtomNode start="(126, 34)" end="(126, 36)" leading="" trailing=" " val="if"/>
                <OtherNode start="(126, 37)" end="(126, 42)" kind="«term_=_»">
                  <IdentNode start="(126, 37)" end="(126, 38)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(126, 39)" end="(126, 40)" leading="" trailing=" " val="="/>
                  <OtherNode start="(126, 41)" end="(126, 42)" kind="num">
                    <AtomNode start="(126, 41)" end="(126, 42)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(126, 43)" end="(126, 47)" leading="" trailing=" " val="then"/>
                <IdentNode start="(126, 48)" end="(126, 52)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(126, 53)" end="(126, 57)" leading="" trailing=" " val="else"/>
                <OtherNode start="(126, 58)" end="(126, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(126, 58)" end="(126, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(126, 60)" end="(126, 61)">
                    <IdentNode start="(126, 60)" end="(126, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(126, 62)" end="(127, 29)">
          <AtomNode start="(126, 62)" end="(126, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(126, 65)" end="(127, 29)">
            <AtomNode start="(126, 65)" end="(126, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(127, 3)" end="(127, 29)">
              <TacticTacticseq1IndentedNode start="(127, 3)" end="(127, 29)">
                <NullNode start="(127, 3)" end="(127, 29)">
                  <OtherNode start="(127, 3)" end="(127, 29)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;x✝ : (f a).isSome = true&#10;⊢ findSome? f (replicate n a) = if n = 0 then none else f a" state_after="no goals" tactic="simp [findSome?_replicate]">
                    <AtomNode start="(127, 3)" end="(127, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(127, 8)" end="(127, 29)">
                      <AtomNode start="(127, 8)" end="(127, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(127, 9)" end="(127, 28)">
                        <OtherNode start="(127, 9)" end="(127, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(127, 9)" end="(127, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Array.findSome?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(112, 9)" def_end="(112, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(127, 28)" end="(127, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(129, 1)" end="(130, 69)" name="findSome?_mkArray_of_isSome" full_name="Array.findSome?_mkArray_of_isSome">
      <CommandDeclmodifiersNode start="(129, 1)" end="(129, 68)">
        <NullNode/>
        <NullNode start="(129, 1)" end="(129, 68)">
          <OtherNode start="(129, 1)" end="(129, 68)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(129, 1)" end="(129, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(129, 3)" end="(129, 67)">
              <OtherNode start="(129, 3)" end="(129, 67)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(129, 3)" end="(129, 67)" kind="Lean.deprecated">
                  <AtomNode start="(129, 3)" end="(129, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(129, 14)" end="(129, 43)">
                    <IdentNode start="(129, 14)" end="(129, 43)" leading="" trailing=" " raw_val="findSome?_replicate_of_isSome" val="findSome?_replicate_of_isSome" full_name="Array.findSome?_replicate_of_isSome" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(125, 17)" def_end="(125, 46)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(129, 44)" end="(129, 67)">
                    <AtomNode start="(129, 44)" end="(129, 45)" leading="" trailing="" val="("/>
                    <AtomNode start="(129, 45)" end="(129, 50)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(129, 51)" end="(129, 53)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(129, 54)" end="(129, 66)" kind="str">
                      <AtomNode start="(129, 54)" end="(129, 66)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(129, 66)" end="(129, 67)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(129, 67)" end="(129, 68)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(130, 1)" end="(130, 69)" name="findSome?_mkArray_of_isSome">
        <AtomNode start="(130, 1)" end="(130, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(130, 8)" end="(130, 35)">
          <IdentNode start="(130, 8)" end="(130, 35)" leading="" trailing=" " raw_val="findSome?_mkArray_of_isSome" val="findSome?_mkArray_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(130, 36)" end="(130, 69)">
          <AtomNode start="(130, 36)" end="(130, 38)" leading="" trailing=" " val=":="/>
          <OtherNode start="(130, 39)" end="(130, 69)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(130, 39)" end="(130, 40)" leading="" trailing="" val="@"/>
            <IdentNode start="(130, 40)" end="(130, 69)" leading="" trailing="&#10;&#10;" raw_val="findSome?_replicate_of_isSome" val="findSome?_replicate_of_isSome" full_name="Array.findSome?_replicate_of_isSome" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(125, 17)" def_end="(125, 46)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(132, 1)" end="(135, 32)" name="findSome?_replicate_of_isNone" full_name="Array.findSome?_replicate_of_isNone">
      <CommandDeclmodifiersNode start="(132, 1)" end="(132, 8)">
        <NullNode/>
        <NullNode start="(132, 1)" end="(132, 8)">
          <OtherNode start="(132, 1)" end="(132, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(132, 1)" end="(132, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(132, 3)" end="(132, 7)">
              <OtherNode start="(132, 3)" end="(132, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(132, 3)" end="(132, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(132, 3)" end="(132, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(132, 7)" end="(132, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(132, 9)" end="(135, 32)" name="findSome?_replicate_of_isNone" full_name="Array.findSome?_replicate_of_isNone" _is_private_decl="False">
        <AtomNode start="(132, 9)" end="(132, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(132, 17)" end="(132, 46)">
          <IdentNode start="(132, 17)" end="(132, 46)" leading="" trailing=" " raw_val="findSome?_replicate_of_isNone" val="findSome?_replicate_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(132, 47)" end="(133, 39)">
          <NullNode start="(132, 47)" end="(132, 65)">
            <TermExplicitbinderNode start="(132, 47)" end="(132, 65)">
              <AtomNode start="(132, 47)" end="(132, 48)" leading="" trailing="" val="("/>
              <NullNode start="(132, 48)" end="(132, 49)">
                <IdentNode start="(132, 48)" end="(132, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(132, 50)" end="(132, 64)">
                <AtomNode start="(132, 50)" end="(132, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(132, 52)" end="(132, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(132, 52)" end="(132, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(132, 52)" end="(132, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(132, 53)" end="(132, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(132, 53)" end="(132, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(132, 55)" end="(132, 56)">
                        <IdentNode start="(132, 55)" end="(132, 56)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(132, 56)" end="(132, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(132, 57)" end="(132, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(132, 58)" end="(132, 64)" leading="" trailing="" raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(132, 64)" end="(132, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(132, 66)" end="(133, 39)">
            <AtomNode start="(132, 66)" end="(132, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(133, 5)" end="(133, 39)" kind="«term_=_»">
              <OtherNode start="(133, 5)" end="(133, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(133, 5)" end="(133, 14)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(133, 15)" end="(133, 32)">
                  <IdentNode start="(133, 15)" end="(133, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(133, 17)" end="(133, 32)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(133, 17)" end="(133, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(133, 18)" end="(133, 31)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(133, 18)" end="(133, 27)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(133, 28)" end="(133, 31)">
                        <IdentNode start="(133, 28)" end="(133, 29)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(133, 30)" end="(133, 31)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(133, 31)" end="(133, 32)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(133, 33)" end="(133, 34)" leading="" trailing=" " val="="/>
              <IdentNode start="(133, 35)" end="(133, 39)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(133, 40)" end="(135, 32)">
          <AtomNode start="(133, 40)" end="(133, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(133, 43)" end="(135, 32)">
            <AtomNode start="(133, 43)" end="(133, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(134, 3)" end="(135, 32)">
              <TacticTacticseq1IndentedNode start="(134, 3)" end="(135, 32)">
                <NullNode start="(134, 3)" end="(135, 32)">
                  <OtherNode start="(134, 3)" end="(134, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : (f a).isNone = true&#10;⊢ findSome? f (replicate n a) = none" state_after="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : f a = none&#10;⊢ findSome? f (replicate n a) = none" tactic="rw [Option.isNone_iff_eq_none] at h">
                    <AtomNode start="(134, 3)" end="(134, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(134, 6)" end="(134, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(134, 6)" end="(134, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(134, 7)" end="(134, 32)">
                        <OtherNode start="(134, 7)" end="(134, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(134, 7)" end="(134, 32)" leading="" trailing="" raw_val="Option.isNone_iff_eq_none" val="Option.isNone_iff_eq_none" full_name="Option.isNone_iff_eq_none" mod_name="Init.Data.Option.Instances" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Instances.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(134, 32)" end="(134, 33)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(134, 34)" end="(134, 38)">
                      <OtherNode start="(134, 34)" end="(134, 38)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(134, 34)" end="(134, 36)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(134, 37)" end="(134, 38)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(134, 37)" end="(134, 38)">
                            <IdentNode start="(134, 37)" end="(134, 38)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(135, 3)" end="(135, 32)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : f a = none&#10;⊢ findSome? f (replicate n a) = none" state_after="no goals" tactic="simp [findSome?_replicate, h]">
                    <AtomNode start="(135, 3)" end="(135, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(135, 8)" end="(135, 32)">
                      <AtomNode start="(135, 8)" end="(135, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(135, 9)" end="(135, 31)">
                        <OtherNode start="(135, 9)" end="(135, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(135, 9)" end="(135, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Array.findSome?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(112, 9)" def_end="(112, 28)"/>
                        </OtherNode>
                        <AtomNode start="(135, 28)" end="(135, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(135, 30)" end="(135, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(135, 30)" end="(135, 31)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(135, 31)" end="(135, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(137, 1)" end="(138, 69)" name="findSome?_mkArray_of_isNone" full_name="Array.findSome?_mkArray_of_isNone">
      <CommandDeclmodifiersNode start="(137, 1)" end="(137, 68)">
        <NullNode/>
        <NullNode start="(137, 1)" end="(137, 68)">
          <OtherNode start="(137, 1)" end="(137, 68)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(137, 1)" end="(137, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(137, 3)" end="(137, 67)">
              <OtherNode start="(137, 3)" end="(137, 67)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(137, 3)" end="(137, 67)" kind="Lean.deprecated">
                  <AtomNode start="(137, 3)" end="(137, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(137, 14)" end="(137, 43)">
                    <IdentNode start="(137, 14)" end="(137, 43)" leading="" trailing=" " raw_val="findSome?_replicate_of_isNone" val="findSome?_replicate_of_isNone" full_name="Array.findSome?_replicate_of_isNone" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(132, 17)" def_end="(132, 46)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(137, 44)" end="(137, 67)">
                    <AtomNode start="(137, 44)" end="(137, 45)" leading="" trailing="" val="("/>
                    <AtomNode start="(137, 45)" end="(137, 50)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(137, 51)" end="(137, 53)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(137, 54)" end="(137, 66)" kind="str">
                      <AtomNode start="(137, 54)" end="(137, 66)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(137, 66)" end="(137, 67)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(137, 67)" end="(137, 68)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(138, 1)" end="(138, 69)" name="findSome?_mkArray_of_isNone">
        <AtomNode start="(138, 1)" end="(138, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(138, 8)" end="(138, 35)">
          <IdentNode start="(138, 8)" end="(138, 35)" leading="" trailing=" " raw_val="findSome?_mkArray_of_isNone" val="findSome?_mkArray_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(138, 36)" end="(138, 69)">
          <AtomNode start="(138, 36)" end="(138, 38)" leading="" trailing=" " val=":="/>
          <OtherNode start="(138, 39)" end="(138, 69)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(138, 39)" end="(138, 40)" leading="" trailing="" val="@"/>
            <IdentNode start="(138, 40)" end="(138, 69)" leading="" trailing="&#10;&#10;" raw_val="findSome?_replicate_of_isNone" val="findSome?_replicate_of_isNone" full_name="Array.findSome?_replicate_of_isNone" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(132, 17)" def_end="(132, 46)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(140, 1)" end="(140, 17)" comment="### find? -/">
      <AtomNode start="(140, 1)" end="(140, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(140, 5)" end="(140, 17)" leading="" trailing="&#10;&#10;" val="### find? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(142, 1)" end="(142, 56)" name="find?_empty" full_name="Array.find?_empty">
      <CommandDeclmodifiersNode start="(142, 1)" end="(142, 8)">
        <NullNode/>
        <NullNode start="(142, 1)" end="(142, 8)">
          <OtherNode start="(142, 1)" end="(142, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(142, 1)" end="(142, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(142, 3)" end="(142, 7)">
              <OtherNode start="(142, 3)" end="(142, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(142, 3)" end="(142, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(142, 3)" end="(142, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(142, 7)" end="(142, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(142, 9)" end="(142, 56)" name="find?_empty" full_name="Array.find?_empty" _is_private_decl="False">
        <AtomNode start="(142, 9)" end="(142, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(142, 17)" end="(142, 28)">
          <IdentNode start="(142, 17)" end="(142, 28)" leading="" trailing=" " raw_val="find?_empty" val="find?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(142, 29)" end="(142, 49)">
          <NullNode/>
          <TermTypespecNode start="(142, 29)" end="(142, 49)">
            <AtomNode start="(142, 29)" end="(142, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(142, 31)" end="(142, 49)" kind="«term_=_»">
              <OtherNode start="(142, 31)" end="(142, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(142, 31)" end="(142, 36)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(142, 37)" end="(142, 42)">
                  <IdentNode start="(142, 37)" end="(142, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(142, 39)" end="(142, 42)" kind="«term#[_,]»">
                    <AtomNode start="(142, 39)" end="(142, 41)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(142, 41)" end="(142, 42)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(142, 43)" end="(142, 44)" leading="" trailing=" " val="="/>
              <IdentNode start="(142, 45)" end="(142, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(142, 50)" end="(142, 56)">
          <AtomNode start="(142, 50)" end="(142, 52)" leading="" trailing=" " val=":="/>
          <IdentNode start="(142, 53)" end="(142, 56)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(144, 1)" end="(146, 40)" name="find?_singleton" full_name="Array.find?_singleton">
      <CommandDeclmodifiersNode start="(144, 1)" end="(144, 8)">
        <NullNode/>
        <NullNode start="(144, 1)" end="(144, 8)">
          <OtherNode start="(144, 1)" end="(144, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(144, 1)" end="(144, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(144, 3)" end="(144, 7)">
              <OtherNode start="(144, 3)" end="(144, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(144, 3)" end="(144, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(144, 3)" end="(144, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(144, 7)" end="(144, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(144, 9)" end="(146, 40)" name="find?_singleton" full_name="Array.find?_singleton" _is_private_decl="False">
        <AtomNode start="(144, 9)" end="(144, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(144, 17)" end="(144, 32)">
          <IdentNode start="(144, 17)" end="(144, 32)" leading="" trailing=" " raw_val="find?_singleton" val="find?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(144, 33)" end="(145, 48)">
          <NullNode start="(144, 33)" end="(144, 55)">
            <OtherNode start="(144, 33)" end="(144, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 33)" end="(144, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 34)" end="(144, 35)">
                <IdentNode start="(144, 34)" end="(144, 35)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(144, 36)" end="(144, 39)">
                <AtomNode start="(144, 36)" end="(144, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(144, 38)" end="(144, 39)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(144, 39)" end="(144, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(144, 41)" end="(144, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 41)" end="(144, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 42)" end="(144, 43)">
                <IdentNode start="(144, 42)" end="(144, 43)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(144, 44)" end="(144, 54)">
                <AtomNode start="(144, 44)" end="(144, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 46)" end="(144, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(144, 46)" end="(144, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(144, 48)" end="(144, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(144, 50)" end="(144, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(144, 54)" end="(144, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(144, 56)" end="(145, 48)">
            <AtomNode start="(144, 56)" end="(144, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(145, 5)" end="(145, 48)" kind="«term_=_»">
              <OtherNode start="(145, 5)" end="(145, 17)" kind="Lean.Parser.Term.app">
                <OtherNode start="(145, 5)" end="(145, 15)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(145, 5)" end="(145, 9)" kind="«term#[_,]»">
                    <AtomNode start="(145, 5)" end="(145, 7)" leading="" trailing="" val="#["/>
                    <NullNode start="(145, 7)" end="(145, 8)">
                      <IdentNode start="(145, 7)" end="(145, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(145, 8)" end="(145, 9)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(145, 9)" end="(145, 10)" leading="" trailing="" val="."/>
                  <IdentNode start="(145, 10)" end="(145, 15)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(145, 16)" end="(145, 17)">
                  <IdentNode start="(145, 16)" end="(145, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(145, 18)" end="(145, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(145, 20)" end="(145, 48)" kind="termIfThenElse">
                <AtomNode start="(145, 20)" end="(145, 22)" leading="" trailing=" " val="if"/>
                <OtherNode start="(145, 23)" end="(145, 26)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(145, 23)" end="(145, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(145, 25)" end="(145, 26)">
                    <IdentNode start="(145, 25)" end="(145, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(145, 27)" end="(145, 31)" leading="" trailing=" " val="then"/>
                <OtherNode start="(145, 32)" end="(145, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(145, 32)" end="(145, 36)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(145, 37)" end="(145, 38)">
                    <IdentNode start="(145, 37)" end="(145, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(145, 39)" end="(145, 43)" leading="" trailing=" " val="else"/>
                <IdentNode start="(145, 44)" end="(145, 48)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(145, 49)" end="(146, 40)">
          <AtomNode start="(145, 49)" end="(145, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(145, 52)" end="(146, 40)">
            <AtomNode start="(145, 52)" end="(145, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(146, 3)" end="(146, 40)">
              <TacticTacticseq1IndentedNode start="(146, 3)" end="(146, 40)">
                <NullNode start="(146, 3)" end="(146, 40)">
                  <OtherNode start="(146, 3)" end="(146, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ find? p #[a] = if p a = true then some a else none" state_after="no goals" tactic="simp [singleton_eq_toArray_singleton]">
                    <AtomNode start="(146, 3)" end="(146, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(146, 8)" end="(146, 40)">
                      <AtomNode start="(146, 8)" end="(146, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(146, 9)" end="(146, 39)">
                        <OtherNode start="(146, 9)" end="(146, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(146, 9)" end="(146, 39)" leading="" trailing="" raw_val="singleton_eq_toArray_singleton" val="singleton_eq_toArray_singleton" full_name="Array.singleton_eq_toArray_singleton" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(146, 39)" end="(146, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(148, 1)" end="(150, 21)" name="findRev?_push_of_pos" full_name="Array.findRev?_push_of_pos">
      <CommandDeclmodifiersNode start="(148, 1)" end="(148, 8)">
        <NullNode/>
        <NullNode start="(148, 1)" end="(148, 8)">
          <OtherNode start="(148, 1)" end="(148, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(148, 1)" end="(148, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(148, 3)" end="(148, 7)">
              <OtherNode start="(148, 3)" end="(148, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(148, 3)" end="(148, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(148, 3)" end="(148, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(148, 7)" end="(148, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(148, 9)" end="(150, 21)" name="findRev?_push_of_pos" full_name="Array.findRev?_push_of_pos" _is_private_decl="False">
        <AtomNode start="(148, 9)" end="(148, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(148, 17)" end="(148, 37)">
          <IdentNode start="(148, 17)" end="(148, 37)" leading="" trailing=" " raw_val="findRev?_push_of_pos" val="findRev?_push_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(148, 38)" end="(149, 36)">
          <NullNode start="(148, 38)" end="(148, 62)">
            <OtherNode start="(148, 38)" end="(148, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(148, 38)" end="(148, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(148, 39)" end="(148, 41)">
                <IdentNode start="(148, 39)" end="(148, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(148, 42)" end="(148, 51)">
                <AtomNode start="(148, 42)" end="(148, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(148, 44)" end="(148, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(148, 44)" end="(148, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(148, 50)" end="(148, 51)">
                    <IdentNode start="(148, 50)" end="(148, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(148, 51)" end="(148, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(148, 53)" end="(148, 62)">
              <AtomNode start="(148, 53)" end="(148, 54)" leading="" trailing="" val="("/>
              <NullNode start="(148, 54)" end="(148, 55)">
                <IdentNode start="(148, 54)" end="(148, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(148, 56)" end="(148, 61)">
                <AtomNode start="(148, 56)" end="(148, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(148, 58)" end="(148, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(148, 58)" end="(148, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(148, 60)" end="(148, 61)">
                    <IdentNode start="(148, 60)" end="(148, 61)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(148, 61)" end="(148, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(148, 63)" end="(149, 36)">
            <AtomNode start="(148, 63)" end="(148, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(149, 5)" end="(149, 36)" kind="«term_=_»">
              <OtherNode start="(149, 5)" end="(149, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 5)" end="(149, 13)" leading="" trailing=" " raw_val="findRev?" val="findRev?" full_name="Array.findRev?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(149, 14)" end="(149, 27)">
                  <IdentNode start="(149, 14)" end="(149, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(149, 16)" end="(149, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(149, 16)" end="(149, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(149, 17)" end="(149, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(149, 17)" end="(149, 24)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(149, 25)" end="(149, 26)">
                        <IdentNode start="(149, 25)" end="(149, 26)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(149, 26)" end="(149, 27)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(149, 28)" end="(149, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(149, 30)" end="(149, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 30)" end="(149, 34)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(149, 35)" end="(149, 36)">
                  <IdentNode start="(149, 35)" end="(149, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(149, 37)" end="(150, 21)">
          <AtomNode start="(149, 37)" end="(149, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(149, 40)" end="(150, 21)">
            <AtomNode start="(149, 40)" end="(149, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(150, 3)" end="(150, 21)">
              <TacticTacticseq1IndentedNode start="(150, 3)" end="(150, 21)">
                <NullNode start="(150, 3)" end="(150, 21)">
                  <OtherNode start="(150, 3)" end="(150, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : p a = true&#10;⊢ findRev? p (xs.push a) = some a" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;toList✝ : List α&#10;⊢ findRev? p ({ toList := toList✝ }.push a) = some a" tactic="cases xs">
                    <AtomNode start="(150, 3)" end="(150, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(150, 9)" end="(150, 11)">
                      <OtherNode start="(150, 9)" end="(150, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(150, 9)" end="(150, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(150, 11)" end="(150, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(150, 13)" end="(150, 21)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;toList✝ : List α&#10;⊢ findRev? p ({ toList := toList✝ }.push a) = some a" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(150, 13)" end="(150, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(150, 18)" end="(150, 21)">
                      <AtomNode start="(150, 18)" end="(150, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(150, 19)" end="(150, 20)">
                        <OtherNode start="(150, 19)" end="(150, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(150, 19)" end="(150, 20)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(150, 20)" end="(150, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(152, 1)" end="(154, 21)" name="findRev?_cons_of_neg" full_name="Array.findRev?_cons_of_neg">
      <CommandDeclmodifiersNode start="(152, 1)" end="(152, 8)">
        <NullNode/>
        <NullNode start="(152, 1)" end="(152, 8)">
          <OtherNode start="(152, 1)" end="(152, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(152, 1)" end="(152, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(152, 3)" end="(152, 7)">
              <OtherNode start="(152, 3)" end="(152, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(152, 3)" end="(152, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(152, 3)" end="(152, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(152, 7)" end="(152, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(152, 9)" end="(154, 21)" name="findRev?_cons_of_neg" full_name="Array.findRev?_cons_of_neg" _is_private_decl="False">
        <AtomNode start="(152, 9)" end="(152, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(152, 17)" end="(152, 37)">
          <IdentNode start="(152, 17)" end="(152, 37)" leading="" trailing=" " raw_val="findRev?_cons_of_neg" val="findRev?_cons_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(152, 38)" end="(153, 43)">
          <NullNode start="(152, 38)" end="(152, 63)">
            <OtherNode start="(152, 38)" end="(152, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(152, 38)" end="(152, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(152, 39)" end="(152, 41)">
                <IdentNode start="(152, 39)" end="(152, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(152, 42)" end="(152, 51)">
                <AtomNode start="(152, 42)" end="(152, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 44)" end="(152, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(152, 44)" end="(152, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(152, 50)" end="(152, 51)">
                    <IdentNode start="(152, 50)" end="(152, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(152, 51)" end="(152, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(152, 53)" end="(152, 63)">
              <AtomNode start="(152, 53)" end="(152, 54)" leading="" trailing="" val="("/>
              <NullNode start="(152, 54)" end="(152, 55)">
                <IdentNode start="(152, 54)" end="(152, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(152, 56)" end="(152, 62)">
                <AtomNode start="(152, 56)" end="(152, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 58)" end="(152, 62)" kind="«term¬_»">
                  <AtomNode start="(152, 58)" end="(152, 59)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(152, 59)" end="(152, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(152, 59)" end="(152, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(152, 61)" end="(152, 62)">
                      <IdentNode start="(152, 61)" end="(152, 62)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(152, 62)" end="(152, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(152, 64)" end="(153, 43)">
            <AtomNode start="(152, 64)" end="(152, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(153, 5)" end="(153, 43)" kind="«term_=_»">
              <OtherNode start="(153, 5)" end="(153, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(153, 5)" end="(153, 13)" leading="" trailing=" " raw_val="findRev?" val="findRev?" full_name="Array.findRev?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(153, 14)" end="(153, 27)">
                  <IdentNode start="(153, 14)" end="(153, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(153, 16)" end="(153, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(153, 16)" end="(153, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(153, 17)" end="(153, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(153, 17)" end="(153, 24)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(153, 25)" end="(153, 26)">
                        <IdentNode start="(153, 25)" end="(153, 26)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(153, 26)" end="(153, 27)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(153, 28)" end="(153, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(153, 30)" end="(153, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(153, 30)" end="(153, 38)" leading="" trailing=" " raw_val="findRev?" val="findRev?" full_name="Array.findRev?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(153, 39)" end="(153, 43)">
                  <IdentNode start="(153, 39)" end="(153, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(153, 41)" end="(153, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(153, 44)" end="(154, 21)">
          <AtomNode start="(153, 44)" end="(153, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(153, 47)" end="(154, 21)">
            <AtomNode start="(153, 47)" end="(153, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(154, 3)" end="(154, 21)">
              <TacticTacticseq1IndentedNode start="(154, 3)" end="(154, 21)">
                <NullNode start="(154, 3)" end="(154, 21)">
                  <OtherNode start="(154, 3)" end="(154, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : ¬p a = true&#10;⊢ findRev? p (xs.push a) = findRev? p xs" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;h : ¬p a = true&#10;toList✝ : List α&#10;⊢ findRev? p ({ toList := toList✝ }.push a) = findRev? p { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(154, 3)" end="(154, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(154, 9)" end="(154, 11)">
                      <OtherNode start="(154, 9)" end="(154, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(154, 9)" end="(154, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(154, 11)" end="(154, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(154, 13)" end="(154, 21)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;h : ¬p a = true&#10;toList✝ : List α&#10;⊢ findRev? p ({ toList := toList✝ }.push a) = findRev? p { toList := toList✝ }" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(154, 13)" end="(154, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(154, 18)" end="(154, 21)">
                      <AtomNode start="(154, 18)" end="(154, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(154, 19)" end="(154, 20)">
                        <OtherNode start="(154, 19)" end="(154, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(154, 19)" end="(154, 20)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(154, 20)" end="(154, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(156, 1)" end="(157, 17)" name="find?_eq_none" full_name="Array.find?_eq_none">
      <CommandDeclmodifiersNode start="(156, 1)" end="(156, 8)">
        <NullNode/>
        <NullNode start="(156, 1)" end="(156, 8)">
          <OtherNode start="(156, 1)" end="(156, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(156, 1)" end="(156, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(156, 3)" end="(156, 7)">
              <OtherNode start="(156, 3)" end="(156, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(156, 3)" end="(156, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(156, 3)" end="(156, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(156, 7)" end="(156, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(156, 9)" end="(157, 17)" name="find?_eq_none" full_name="Array.find?_eq_none" _is_private_decl="False">
        <AtomNode start="(156, 9)" end="(156, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(156, 17)" end="(156, 30)">
          <IdentNode start="(156, 17)" end="(156, 30)" leading="" trailing=" " raw_val="find?_eq_none" val="find?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(156, 31)" end="(156, 68)">
          <NullNode/>
          <TermTypespecNode start="(156, 31)" end="(156, 68)">
            <AtomNode start="(156, 31)" end="(156, 32)" leading="" trailing=" " val=":"/>
            <OtherNode start="(156, 33)" end="(156, 68)" kind="«term_↔_»">
              <OtherNode start="(156, 33)" end="(156, 50)" kind="«term_=_»">
                <OtherNode start="(156, 33)" end="(156, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(156, 33)" end="(156, 38)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(156, 39)" end="(156, 43)">
                    <IdentNode start="(156, 39)" end="(156, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(156, 41)" end="(156, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(156, 44)" end="(156, 45)" leading="" trailing=" " val="="/>
                <IdentNode start="(156, 46)" end="(156, 50)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(156, 51)" end="(156, 52)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(156, 53)" end="(156, 68)" kind="Lean.«term∀__,_»">
                <AtomNode start="(156, 53)" end="(156, 54)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(156, 55)" end="(156, 56)">
                  <IdentNode start="(156, 55)" end="(156, 56)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(156, 57)" end="(156, 61)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(156, 57)" end="(156, 58)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(156, 59)" end="(156, 61)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(156, 61)" end="(156, 62)" leading="" trailing=" " val=","/>
                <OtherNode start="(156, 63)" end="(156, 68)" kind="«term¬_»">
                  <AtomNode start="(156, 63)" end="(156, 64)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(156, 65)" end="(156, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(156, 65)" end="(156, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(156, 67)" end="(156, 68)">
                      <IdentNode start="(156, 67)" end="(156, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(156, 69)" end="(157, 17)">
          <AtomNode start="(156, 69)" end="(156, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(156, 72)" end="(157, 17)">
            <AtomNode start="(156, 72)" end="(156, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(157, 3)" end="(157, 17)">
              <TacticTacticseq1IndentedNode start="(157, 3)" end="(157, 17)">
                <NullNode start="(157, 3)" end="(157, 17)">
                  <OtherNode start="(157, 3)" end="(157, 11)" kind="Lean.Parser.Tactic.cases" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;xs : Array α✝&#10;⊢ find? p xs = none ↔ ∀ (x : α✝), x ∈ xs → ¬p x = true" state_after="case mk&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;toList✝ : List α✝&#10;⊢ find? p { toList := toList✝ } = none ↔ ∀ (x : α✝), x ∈ { toList := toList✝ } → ¬p x = true" tactic="cases xs">
                    <AtomNode start="(157, 3)" end="(157, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(157, 9)" end="(157, 11)">
                      <OtherNode start="(157, 9)" end="(157, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(157, 9)" end="(157, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(157, 11)" end="(157, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(157, 13)" end="(157, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;toList✝ : List α✝&#10;⊢ find? p { toList := toList✝ } = none ↔ ∀ (x : α✝), x ∈ { toList := toList✝ } → ¬p x = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(157, 13)" end="(157, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(159, 1)" end="(170, 24)" name="find?_eq_some_iff_append" full_name="Array.find?_eq_some_iff_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(159, 1)" end="(170, 24)" name="find?_eq_some_iff_append" full_name="Array.find?_eq_some_iff_append" _is_private_decl="False">
        <AtomNode start="(159, 1)" end="(159, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(159, 9)" end="(159, 33)">
          <IdentNode start="(159, 9)" end="(159, 33)" leading="" trailing=" " raw_val="find?_eq_some_iff_append" val="find?_eq_some_iff_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(159, 34)" end="(160, 91)">
          <NullNode start="(159, 34)" end="(159, 48)">
            <OtherNode start="(159, 34)" end="(159, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(159, 34)" end="(159, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(159, 35)" end="(159, 37)">
                <IdentNode start="(159, 35)" end="(159, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(159, 38)" end="(159, 47)">
                <AtomNode start="(159, 38)" end="(159, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(159, 40)" end="(159, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(159, 40)" end="(159, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(159, 46)" end="(159, 47)">
                    <IdentNode start="(159, 46)" end="(159, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(159, 47)" end="(159, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(159, 49)" end="(160, 91)">
            <AtomNode start="(159, 49)" end="(159, 50)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(160, 5)" end="(160, 91)" kind="«term_↔_»">
              <OtherNode start="(160, 5)" end="(160, 24)" kind="«term_=_»">
                <OtherNode start="(160, 5)" end="(160, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(160, 5)" end="(160, 13)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                  <NullNode start="(160, 14)" end="(160, 15)">
                    <IdentNode start="(160, 14)" end="(160, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(160, 16)" end="(160, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(160, 18)" end="(160, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(160, 18)" end="(160, 22)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(160, 23)" end="(160, 24)">
                    <IdentNode start="(160, 23)" end="(160, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(160, 25)" end="(160, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(160, 27)" end="(160, 91)" kind="«term_∧_»">
                <OtherNode start="(160, 27)" end="(160, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(160, 27)" end="(160, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(160, 29)" end="(160, 30)">
                    <IdentNode start="(160, 29)" end="(160, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(160, 31)" end="(160, 32)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(160, 33)" end="(160, 91)" kind="«term∃_,_»">
                  <AtomNode start="(160, 33)" end="(160, 34)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(160, 35)" end="(160, 52)" kind="Lean.explicitBinders">
                    <NullNode start="(160, 35)" end="(160, 52)">
                      <OtherNode start="(160, 35)" end="(160, 52)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(160, 35)" end="(160, 36)" leading="" trailing="" val="("/>
                        <NullNode start="(160, 36)" end="(160, 41)">
                          <LeanBinderidentNode start="(160, 36)" end="(160, 38)">
                            <IdentNode start="(160, 36)" end="(160, 38)" leading="" trailing=" " raw_val="as" val="as"/>
                          </LeanBinderidentNode>
                          <LeanBinderidentNode start="(160, 39)" end="(160, 41)">
                            <IdentNode start="(160, 39)" end="(160, 41)" leading="" trailing=" " raw_val="bs" val="bs"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(160, 42)" end="(160, 43)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(160, 44)" end="(160, 51)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(160, 44)" end="(160, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(160, 50)" end="(160, 51)">
                            <IdentNode start="(160, 50)" end="(160, 51)" leading="" trailing="" raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(160, 51)" end="(160, 52)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(160, 52)" end="(160, 53)" leading="" trailing=" " val=","/>
                  <OtherNode start="(160, 54)" end="(160, 91)" kind="«term_∧_»">
                    <OtherNode start="(160, 54)" end="(160, 74)" kind="«term_=_»">
                      <IdentNode start="(160, 54)" end="(160, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(160, 57)" end="(160, 58)" leading="" trailing=" " val="="/>
                      <OtherNode start="(160, 59)" end="(160, 74)" kind="«term_++_»">
                        <OtherNode start="(160, 59)" end="(160, 68)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(160, 59)" end="(160, 66)" leading="" trailing=" " raw_val="as.push" val="as.push"/>
                          <NullNode start="(160, 67)" end="(160, 68)">
                            <IdentNode start="(160, 67)" end="(160, 68)" leading="" trailing=" " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(160, 69)" end="(160, 71)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(160, 72)" end="(160, 74)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(160, 75)" end="(160, 76)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(160, 77)" end="(160, 91)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(160, 77)" end="(160, 78)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(160, 79)" end="(160, 80)">
                        <IdentNode start="(160, 79)" end="(160, 80)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(160, 81)" end="(160, 85)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(160, 81)" end="(160, 82)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(160, 83)" end="(160, 85)" leading="" trailing="" raw_val="as" val="as"/>
                      </OtherNode>
                      <AtomNode start="(160, 85)" end="(160, 86)" leading="" trailing=" " val=","/>
                      <OtherNode start="(160, 87)" end="(160, 91)" kind="term!_">
                        <AtomNode start="(160, 87)" end="(160, 88)" leading="" trailing="" val="!"/>
                        <OtherNode start="(160, 88)" end="(160, 91)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(160, 88)" end="(160, 89)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(160, 90)" end="(160, 91)">
                            <IdentNode start="(160, 90)" end="(160, 91)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(160, 92)" end="(170, 24)">
          <AtomNode start="(160, 92)" end="(160, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(160, 95)" end="(170, 24)">
            <AtomNode start="(160, 95)" end="(160, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(161, 3)" end="(170, 24)">
              <TacticTacticseq1IndentedNode start="(161, 3)" end="(170, 24)">
                <NullNode start="(161, 3)" end="(170, 24)">
                  <OtherNode start="(161, 3)" end="(161, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;⊢ find? p { toList := xs } = some b ↔&#10;    p b = true ∧ ∃ as bs, { toList := xs } = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(161, 3)" end="(161, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(161, 10)" end="(161, 12)">
                      <OtherNode start="(161, 10)" end="(161, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(161, 10)" end="(161, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(161, 13)" end="(161, 22)">
                      <AtomNode start="(161, 13)" end="(161, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(161, 18)" end="(161, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(161, 18)" end="(161, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(161, 18)" end="(161, 22)">
                            <OtherNode start="(161, 18)" end="(161, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(161, 18)" end="(161, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(161, 19)" end="(161, 21)">
                                <OtherNode start="(161, 19)" end="(161, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(161, 19)" end="(161, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(161, 19)" end="(161, 21)">
                                      <OtherNode start="(161, 19)" end="(161, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(161, 19)" end="(161, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(161, 21)" end="(161, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(162, 3)" end="(163, 58)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;⊢ find? p { toList := xs } = some b ↔&#10;    p b = true ∧ ∃ as bs, { toList := xs } = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;⊢ p b = true →&#10;    ((∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false) ↔&#10;      ∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false)" tactic="simp only [List.find?_toArray, List.find?_eq_some_iff_append, Bool.not_eq_eq_eq_not,&#10;  Bool.not_true, exists_and_right, and_congr_right_iff]">
                    <AtomNode start="(162, 3)" end="(162, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(162, 8)" end="(162, 12)">
                      <AtomNode start="(162, 8)" end="(162, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(162, 13)" end="(163, 58)">
                      <AtomNode start="(162, 13)" end="(162, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(162, 14)" end="(163, 57)">
                        <OtherNode start="(162, 14)" end="(162, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(162, 14)" end="(162, 32)" leading="" trailing="" raw_val="List.find?_toArray" val="List.find?_toArray" full_name="List.find?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(162, 32)" end="(162, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(162, 34)" end="(162, 63)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(162, 34)" end="(162, 63)" leading="" trailing="" raw_val="List.find?_eq_some_iff_append" val="List.find?_eq_some_iff_append" full_name="List.find?_eq_some_iff_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(162, 63)" end="(162, 64)" leading="" trailing=" " val=","/>
                        <OtherNode start="(162, 65)" end="(162, 86)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(162, 65)" end="(162, 86)" leading="" trailing="" raw_val="Bool.not_eq_eq_eq_not" val="Bool.not_eq_eq_eq_not" full_name="Bool.not_eq_eq_eq_not" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(162, 86)" end="(162, 87)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(163, 5)" end="(163, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(163, 5)" end="(163, 18)" leading="" trailing="" raw_val="Bool.not_true" val="Bool.not_true" full_name="Bool.not_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(163, 18)" end="(163, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(163, 20)" end="(163, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(163, 20)" end="(163, 36)" leading="" trailing="" raw_val="exists_and_right" val="exists_and_right" full_name="exists_and_right" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(163, 36)" end="(163, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(163, 38)" end="(163, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(163, 38)" end="(163, 57)" leading="" trailing="" raw_val="and_congr_right_iff" val="and_congr_right_iff" full_name="and_congr_right_iff" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(163, 57)" end="(163, 58)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(164, 3)" end="(164, 10)" kind="Lean.Parser.Tactic.intro" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;⊢ p b = true →&#10;    ((∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false) ↔&#10;      ∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false)" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false) ↔&#10;    ∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false" tactic="intro w">
                    <AtomNode start="(164, 3)" end="(164, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(164, 9)" end="(164, 10)">
                      <IdentNode start="(164, 9)" end="(164, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(165, 3)" end="(165, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false) ↔&#10;    ∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false" state_after="case mk.mp&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false" tactic="constructor">
                    <AtomNode start="(165, 3)" end="(165, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(166, 3)" end="(167, 65)" kind="Lean.cdot" state_before="case mk.mp&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false" state_after="case mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false" tactic="· rintro ⟨as, ⟨⟨xs, rfl⟩, h⟩⟩&#10;  exact ⟨as.toArray, ⟨xs.toArray, by simp⟩ , by simpa using h⟩">
                    <OtherNode start="(166, 3)" end="(166, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(166, 3)" end="(166, 4)" kind="patternIgnore">
                        <OtherNode start="(166, 3)" end="(166, 4)" kind="token.«· »">
                          <AtomNode start="(166, 3)" end="(166, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(166, 5)" end="(167, 65)">
                      <TacticTacticseq1IndentedNode start="(166, 5)" end="(167, 65)">
                        <NullNode start="(166, 5)" end="(167, 65)">
                          <OtherNode start="(166, 5)" end="(166, 32)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mp&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false" state_after="case mk.mp.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;w : p b = true&#10;as : List α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;xs : List α&#10;⊢ ∃ as_1, (∃ x, { toList := as ++ b :: xs } = as_1.push b ++ x) ∧ ∀ (a : α), a ∈ as_1 → p a = false" tactic="rintro ⟨as, ⟨⟨xs, rfl⟩, h⟩⟩">
                            <AtomNode start="(166, 5)" end="(166, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(166, 12)" end="(166, 32)">
                              <OtherNode start="(166, 12)" end="(166, 32)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(166, 12)" end="(166, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(166, 12)" end="(166, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(166, 13)" end="(166, 31)">
                                    <OtherNode start="(166, 13)" end="(166, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(166, 13)" end="(166, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(166, 13)" end="(166, 15)">
                                          <OtherNode start="(166, 13)" end="(166, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(166, 13)" end="(166, 15)" leading="" trailing="" raw_val="as" val="as"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(166, 15)" end="(166, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(166, 17)" end="(166, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(166, 17)" end="(166, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(166, 17)" end="(166, 31)">
                                          <OtherNode start="(166, 17)" end="(166, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(166, 17)" end="(166, 18)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(166, 18)" end="(166, 30)">
                                              <OtherNode start="(166, 18)" end="(166, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(166, 18)" end="(166, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(166, 18)" end="(166, 27)">
                                                    <OtherNode start="(166, 18)" end="(166, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(166, 18)" end="(166, 19)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(166, 19)" end="(166, 26)">
                                                        <OtherNode start="(166, 19)" end="(166, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(166, 19)" end="(166, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(166, 19)" end="(166, 21)">
                                                            <OtherNode start="(166, 19)" end="(166, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(166, 19)" end="(166, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(166, 21)" end="(166, 22)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(166, 23)" end="(166, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(166, 23)" end="(166, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(166, 23)" end="(166, 26)">
                                                            <OtherNode start="(166, 23)" end="(166, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(166, 23)" end="(166, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(166, 26)" end="(166, 27)" leading="" trailing="" val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(166, 27)" end="(166, 28)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(166, 29)" end="(166, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(166, 29)" end="(166, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(166, 29)" end="(166, 30)">
                                                    <OtherNode start="(166, 29)" end="(166, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(166, 29)" end="(166, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(166, 30)" end="(166, 31)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(166, 31)" end="(166, 32)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(167, 5)" end="(167, 65)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mp.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;w : p b = true&#10;as : List α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;xs : List α&#10;⊢ ∃ as_1, (∃ x, { toList := as ++ b :: xs } = as_1.push b ++ x) ∧ ∀ (a : α), a ∈ as_1 → p a = false" state_after="no goals" tactic="exact ⟨as.toArray, ⟨xs.toArray, by simp⟩ , by simpa using h⟩">
                            <AtomNode start="(167, 5)" end="(167, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(167, 11)" end="(167, 65)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(167, 11)" end="(167, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(167, 12)" end="(167, 64)">
                                <IdentNode start="(167, 12)" end="(167, 22)" leading="" trailing="" raw_val="as.toArray" val="as.toArray"/>
                                <AtomNode start="(167, 22)" end="(167, 23)" leading="" trailing=" " val=","/>
                                <OtherNode start="(167, 24)" end="(167, 45)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(167, 24)" end="(167, 25)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(167, 25)" end="(167, 44)">
                                    <IdentNode start="(167, 25)" end="(167, 35)" leading="" trailing="" raw_val="xs.toArray" val="xs.toArray"/>
                                    <AtomNode start="(167, 35)" end="(167, 36)" leading="" trailing=" " val=","/>
                                    <TermBytacticNode start="(167, 37)" end="(167, 44)">
                                      <AtomNode start="(167, 37)" end="(167, 39)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(167, 40)" end="(167, 44)">
                                        <TacticTacticseq1IndentedNode start="(167, 40)" end="(167, 44)">
                                          <NullNode start="(167, 40)" end="(167, 44)">
                                            <OtherNode start="(167, 40)" end="(167, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;b : α&#10;w : p b = true&#10;as : List α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;xs : List α&#10;⊢ { toList := as ++ b :: xs } = as.toArray.push b ++ xs.toArray" state_after="no goals" tactic="simp">
                                              <AtomNode start="(167, 40)" end="(167, 44)" leading="" trailing="" val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </NullNode>
                                  <AtomNode start="(167, 44)" end="(167, 45)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(167, 46)" end="(167, 47)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(167, 48)" end="(167, 64)">
                                  <AtomNode start="(167, 48)" end="(167, 50)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(167, 51)" end="(167, 64)">
                                    <TacticTacticseq1IndentedNode start="(167, 51)" end="(167, 64)">
                                      <NullNode start="(167, 51)" end="(167, 64)">
                                        <OtherNode start="(167, 51)" end="(167, 64)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;b : α&#10;w : p b = true&#10;as : List α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;xs : List α&#10;⊢ ∀ (a : α), a ∈ as.toArray → p a = false" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(167, 51)" end="(167, 56)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(167, 57)" end="(167, 64)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(167, 57)" end="(167, 64)">
                                              <AtomNode start="(167, 57)" end="(167, 62)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(167, 63)" end="(167, 64)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(167, 64)" end="(167, 65)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(168, 3)" end="(170, 24)" kind="Lean.cdot" state_before="case mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false" state_after="no goals" tactic="· rintro ⟨as, ⟨⟨⟨l⟩, h'⟩, h⟩⟩&#10;  exact ⟨as.toList, ⟨l, by simpa using congrArg Array.toList h'⟩,&#10;    by simpa using h⟩">
                    <OtherNode start="(168, 3)" end="(168, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(168, 3)" end="(168, 4)" kind="patternIgnore">
                        <OtherNode start="(168, 3)" end="(168, 4)" kind="token.«· »">
                          <AtomNode start="(168, 3)" end="(168, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(168, 5)" end="(170, 24)">
                      <TacticTacticseq1IndentedNode start="(168, 5)" end="(170, 24)">
                        <NullNode start="(168, 5)" end="(170, 24)">
                          <OtherNode start="(168, 5)" end="(168, 32)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;⊢ (∃ as, (∃ x, { toList := xs } = as.push b ++ x) ∧ ∀ (a : α), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false" state_after="case mk.mpr.intro.intro.intro.mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;as : Array α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;l : List α&#10;h' : { toList := xs } = as.push b ++ { toList := l }&#10;⊢ ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false" tactic="rintro ⟨as, ⟨⟨⟨l⟩, h'⟩, h⟩⟩">
                            <AtomNode start="(168, 5)" end="(168, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(168, 12)" end="(168, 32)">
                              <OtherNode start="(168, 12)" end="(168, 32)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(168, 12)" end="(168, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(168, 12)" end="(168, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(168, 13)" end="(168, 31)">
                                    <OtherNode start="(168, 13)" end="(168, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(168, 13)" end="(168, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(168, 13)" end="(168, 15)">
                                          <OtherNode start="(168, 13)" end="(168, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(168, 13)" end="(168, 15)" leading="" trailing="" raw_val="as" val="as"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(168, 15)" end="(168, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(168, 17)" end="(168, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(168, 17)" end="(168, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(168, 17)" end="(168, 31)">
                                          <OtherNode start="(168, 17)" end="(168, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(168, 17)" end="(168, 18)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(168, 18)" end="(168, 30)">
                                              <OtherNode start="(168, 18)" end="(168, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(168, 18)" end="(168, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(168, 18)" end="(168, 27)">
                                                    <OtherNode start="(168, 18)" end="(168, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(168, 18)" end="(168, 19)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(168, 19)" end="(168, 26)">
                                                        <OtherNode start="(168, 19)" end="(168, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(168, 19)" end="(168, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(168, 19)" end="(168, 22)">
                                                            <OtherNode start="(168, 19)" end="(168, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(168, 19)" end="(168, 20)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(168, 20)" end="(168, 21)">
                                                            <OtherNode start="(168, 20)" end="(168, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(168, 20)" end="(168, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(168, 20)" end="(168, 21)">
                                                            <OtherNode start="(168, 20)" end="(168, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(168, 20)" end="(168, 21)" leading="" trailing="" raw_val="l" val="l"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(168, 21)" end="(168, 22)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(168, 22)" end="(168, 23)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(168, 24)" end="(168, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(168, 24)" end="(168, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(168, 24)" end="(168, 26)">
                                                            <OtherNode start="(168, 24)" end="(168, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(168, 24)" end="(168, 26)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(168, 26)" end="(168, 27)" leading="" trailing="" val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(168, 27)" end="(168, 28)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(168, 29)" end="(168, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(168, 29)" end="(168, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(168, 29)" end="(168, 30)">
                                                    <OtherNode start="(168, 29)" end="(168, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(168, 29)" end="(168, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(168, 30)" end="(168, 31)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(168, 31)" end="(168, 32)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(169, 5)" end="(170, 24)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mpr.intro.intro.intro.mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;as : Array α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;l : List α&#10;h' : { toList := xs } = as.push b ++ { toList := l }&#10;⊢ ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α), a ∈ as → p a = false" state_after="no goals" tactic="exact ⟨as.toList, ⟨l, by simpa using congrArg Array.toList h'⟩,&#10;  by simpa using h⟩">
                            <AtomNode start="(169, 5)" end="(169, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(169, 11)" end="(170, 24)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(169, 11)" end="(169, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(169, 12)" end="(170, 23)">
                                <IdentNode start="(169, 12)" end="(169, 21)" leading="" trailing="" raw_val="as.toList" val="as.toList"/>
                                <AtomNode start="(169, 21)" end="(169, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(169, 23)" end="(169, 67)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(169, 23)" end="(169, 24)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(169, 24)" end="(169, 66)">
                                    <IdentNode start="(169, 24)" end="(169, 25)" leading="" trailing="" raw_val="l" val="l"/>
                                    <AtomNode start="(169, 25)" end="(169, 26)" leading="" trailing=" " val=","/>
                                    <TermBytacticNode start="(169, 27)" end="(169, 66)">
                                      <AtomNode start="(169, 27)" end="(169, 29)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(169, 30)" end="(169, 66)">
                                        <TacticTacticseq1IndentedNode start="(169, 30)" end="(169, 66)">
                                          <NullNode start="(169, 30)" end="(169, 66)">
                                            <OtherNode start="(169, 30)" end="(169, 66)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;as : Array α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;l : List α&#10;h' : { toList := xs } = as.push b ++ { toList := l }&#10;⊢ xs = as.toList ++ b :: l" state_after="no goals" tactic="simpa using congrArg Array.toList h'">
                                              <AtomNode start="(169, 30)" end="(169, 35)" leading="" trailing=" " val="simpa"/>
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(169, 36)" end="(169, 66)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(169, 36)" end="(169, 66)">
                                                  <AtomNode start="(169, 36)" end="(169, 41)" leading="" trailing=" " val="using"/>
                                                  <OtherNode start="(169, 42)" end="(169, 66)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(169, 42)" end="(169, 50)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    <NullNode start="(169, 51)" end="(169, 66)">
                                                      <IdentNode start="(169, 51)" end="(169, 63)" leading="" trailing=" " raw_val="Array.toList" val="Array.toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                      <IdentNode start="(169, 64)" end="(169, 66)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </NullNode>
                                  <AtomNode start="(169, 66)" end="(169, 67)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(169, 67)" end="(169, 68)" leading="" trailing="&#10;      " val=","/>
                                <TermBytacticNode start="(170, 7)" end="(170, 23)">
                                  <AtomNode start="(170, 7)" end="(170, 9)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(170, 10)" end="(170, 23)">
                                    <TacticTacticseq1IndentedNode start="(170, 10)" end="(170, 23)">
                                      <NullNode start="(170, 10)" end="(170, 23)">
                                        <OtherNode start="(170, 10)" end="(170, 23)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;w : p b = true&#10;as : Array α&#10;h : ∀ (a : α), a ∈ as → p a = false&#10;l : List α&#10;h' : { toList := xs } = as.push b ++ { toList := l }&#10;⊢ ∀ (a : α), a ∈ as.toList → p a = false" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(170, 10)" end="(170, 15)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(170, 16)" end="(170, 23)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(170, 16)" end="(170, 23)">
                                              <AtomNode start="(170, 16)" end="(170, 21)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(170, 22)" end="(170, 23)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(170, 23)" end="(170, 24)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(172, 1)" end="(173, 17)" name="find?_push" full_name="Array.find?_push">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(172, 1)" end="(173, 17)" name="find?_push" full_name="Array.find?_push" _is_private_decl="False">
        <AtomNode start="(172, 1)" end="(172, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(172, 9)" end="(172, 19)">
          <IdentNode start="(172, 9)" end="(172, 19)" leading="" trailing=" " raw_val="find?_push" val="find?_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(172, 20)" end="(172, 105)">
          <NullNode start="(172, 20)" end="(172, 34)">
            <OtherNode start="(172, 20)" end="(172, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(172, 20)" end="(172, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(172, 21)" end="(172, 23)">
                <IdentNode start="(172, 21)" end="(172, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(172, 24)" end="(172, 33)">
                <AtomNode start="(172, 24)" end="(172, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(172, 26)" end="(172, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(172, 26)" end="(172, 31)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(172, 32)" end="(172, 33)">
                    <IdentNode start="(172, 32)" end="(172, 33)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(172, 33)" end="(172, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(172, 35)" end="(172, 105)">
            <AtomNode start="(172, 35)" end="(172, 36)" leading="" trailing=" " val=":"/>
            <OtherNode start="(172, 37)" end="(172, 105)" kind="«term_=_»">
              <OtherNode start="(172, 37)" end="(172, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(172, 37)" end="(172, 54)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(172, 37)" end="(172, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(172, 37)" end="(172, 38)" leading="" trailing="" val="("/>
                    <OtherNode start="(172, 38)" end="(172, 47)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(172, 38)" end="(172, 45)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(172, 46)" end="(172, 47)">
                        <IdentNode start="(172, 46)" end="(172, 47)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(172, 47)" end="(172, 48)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(172, 48)" end="(172, 49)" leading="" trailing="" val="."/>
                  <IdentNode start="(172, 49)" end="(172, 54)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(172, 55)" end="(172, 56)">
                  <IdentNode start="(172, 55)" end="(172, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(172, 57)" end="(172, 58)" leading="" trailing=" " val="="/>
              <OtherNode start="(172, 59)" end="(172, 105)" kind="Lean.Parser.Term.app">
                <OtherNode start="(172, 59)" end="(172, 74)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(172, 59)" end="(172, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(172, 59)" end="(172, 60)" leading="" trailing="" val="("/>
                    <OtherNode start="(172, 60)" end="(172, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(172, 60)" end="(172, 68)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(172, 69)" end="(172, 70)">
                        <IdentNode start="(172, 69)" end="(172, 70)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(172, 70)" end="(172, 71)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(172, 71)" end="(172, 72)" leading="" trailing="" val="."/>
                  <IdentNode start="(172, 72)" end="(172, 74)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(172, 75)" end="(172, 105)">
                  <OtherNode start="(172, 75)" end="(172, 105)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(172, 75)" end="(172, 76)" leading="" trailing="" val="("/>
                    <OtherNode start="(172, 76)" end="(172, 104)" kind="termIfThenElse">
                      <AtomNode start="(172, 76)" end="(172, 78)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(172, 79)" end="(172, 82)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(172, 79)" end="(172, 80)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(172, 81)" end="(172, 82)">
                          <IdentNode start="(172, 81)" end="(172, 82)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(172, 83)" end="(172, 87)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(172, 88)" end="(172, 94)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(172, 88)" end="(172, 92)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(172, 93)" end="(172, 94)">
                          <IdentNode start="(172, 93)" end="(172, 94)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(172, 95)" end="(172, 99)" leading="" trailing=" " val="else"/>
                      <IdentNode start="(172, 100)" end="(172, 104)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(172, 104)" end="(172, 105)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(172, 106)" end="(173, 17)">
          <AtomNode start="(172, 106)" end="(172, 108)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(172, 109)" end="(173, 17)">
            <AtomNode start="(172, 109)" end="(172, 111)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(173, 3)" end="(173, 17)">
              <TacticTacticseq1IndentedNode start="(173, 3)" end="(173, 17)">
                <NullNode start="(173, 3)" end="(173, 17)">
                  <OtherNode start="(173, 3)" end="(173, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ find? p (xs.push a) = (find? p xs).or (if p a = true then some a else none)" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ find? p ({ toList := toList✝ }.push a) = (find? p { toList := toList✝ }).or (if p a = true then some a else none)" tactic="cases xs">
                    <AtomNode start="(173, 3)" end="(173, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(173, 9)" end="(173, 11)">
                      <OtherNode start="(173, 9)" end="(173, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(173, 9)" end="(173, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(173, 11)" end="(173, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(173, 13)" end="(173, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ find? p ({ toList := toList✝ }.push a) = (find? p { toList := toList✝ }).or (if p a = true then some a else none)" state_after="no goals" tactic="simp">
                    <AtomNode start="(173, 13)" end="(173, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(175, 1)" end="(178, 17)" name="find?_push_eq_some" full_name="Array.find?_push_eq_some">
      <CommandDeclmodifiersNode start="(175, 1)" end="(175, 8)">
        <NullNode/>
        <NullNode start="(175, 1)" end="(175, 8)">
          <OtherNode start="(175, 1)" end="(175, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(175, 1)" end="(175, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(175, 3)" end="(175, 7)">
              <OtherNode start="(175, 3)" end="(175, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(175, 3)" end="(175, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(175, 3)" end="(175, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(175, 7)" end="(175, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(176, 1)" end="(178, 17)" name="find?_push_eq_some" full_name="Array.find?_push_eq_some" _is_private_decl="False">
        <AtomNode start="(176, 1)" end="(176, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(176, 9)" end="(176, 27)">
          <IdentNode start="(176, 9)" end="(176, 27)" leading="" trailing=" " raw_val="find?_push_eq_some" val="find?_push_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(176, 28)" end="(177, 93)">
          <NullNode start="(176, 28)" end="(176, 42)">
            <OtherNode start="(176, 28)" end="(176, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(176, 28)" end="(176, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(176, 29)" end="(176, 31)">
                <IdentNode start="(176, 29)" end="(176, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(176, 32)" end="(176, 41)">
                <AtomNode start="(176, 32)" end="(176, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(176, 34)" end="(176, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(176, 34)" end="(176, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(176, 40)" end="(176, 41)">
                    <IdentNode start="(176, 40)" end="(176, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(176, 41)" end="(176, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(176, 43)" end="(177, 93)">
            <AtomNode start="(176, 43)" end="(176, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(177, 5)" end="(177, 93)" kind="«term_↔_»">
              <OtherNode start="(177, 5)" end="(177, 33)" kind="«term_=_»">
                <OtherNode start="(177, 5)" end="(177, 24)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(177, 5)" end="(177, 22)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(177, 5)" end="(177, 16)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(177, 5)" end="(177, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(177, 6)" end="(177, 15)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(177, 6)" end="(177, 13)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                        <NullNode start="(177, 14)" end="(177, 15)">
                          <IdentNode start="(177, 14)" end="(177, 15)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(177, 15)" end="(177, 16)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(177, 16)" end="(177, 17)" leading="" trailing="" val="."/>
                    <IdentNode start="(177, 17)" end="(177, 22)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(177, 23)" end="(177, 24)">
                    <IdentNode start="(177, 23)" end="(177, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(177, 25)" end="(177, 26)" leading="" trailing=" " val="="/>
                <OtherNode start="(177, 27)" end="(177, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(177, 27)" end="(177, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(177, 32)" end="(177, 33)">
                    <IdentNode start="(177, 32)" end="(177, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(177, 34)" end="(177, 35)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(177, 36)" end="(177, 93)" kind="«term_∨_»">
                <OtherNode start="(177, 36)" end="(177, 55)" kind="«term_=_»">
                  <OtherNode start="(177, 36)" end="(177, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(177, 36)" end="(177, 44)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                    <NullNode start="(177, 45)" end="(177, 46)">
                      <IdentNode start="(177, 45)" end="(177, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(177, 47)" end="(177, 48)" leading="" trailing=" " val="="/>
                  <OtherNode start="(177, 49)" end="(177, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(177, 49)" end="(177, 53)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(177, 54)" end="(177, 55)">
                      <IdentNode start="(177, 54)" end="(177, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(177, 56)" end="(177, 57)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(177, 58)" end="(177, 93)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(177, 58)" end="(177, 59)" leading="" trailing="" val="("/>
                  <OtherNode start="(177, 59)" end="(177, 92)" kind="«term_∧_»">
                    <OtherNode start="(177, 59)" end="(177, 76)" kind="«term_=_»">
                      <OtherNode start="(177, 59)" end="(177, 69)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(177, 59)" end="(177, 67)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                        <NullNode start="(177, 68)" end="(177, 69)">
                          <IdentNode start="(177, 68)" end="(177, 69)" leading="" trailing=" " raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(177, 70)" end="(177, 71)" leading="" trailing=" " val="="/>
                      <IdentNode start="(177, 72)" end="(177, 76)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(177, 77)" end="(177, 78)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(177, 79)" end="(177, 92)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(177, 79)" end="(177, 80)" leading="" trailing="" val="("/>
                      <OtherNode start="(177, 80)" end="(177, 91)" kind="«term_∧_»">
                        <OtherNode start="(177, 80)" end="(177, 83)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(177, 80)" end="(177, 81)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(177, 82)" end="(177, 83)">
                            <IdentNode start="(177, 82)" end="(177, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(177, 84)" end="(177, 85)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(177, 86)" end="(177, 91)" kind="«term_=_»">
                          <IdentNode start="(177, 86)" end="(177, 87)" leading="" trailing=" " raw_val="a" val="a"/>
                          <AtomNode start="(177, 88)" end="(177, 89)" leading="" trailing=" " val="="/>
                          <IdentNode start="(177, 90)" end="(177, 91)" leading="" trailing="" raw_val="b" val="b"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(177, 91)" end="(177, 92)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(177, 92)" end="(177, 93)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(177, 94)" end="(178, 17)">
          <AtomNode start="(177, 94)" end="(177, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(177, 97)" end="(178, 17)">
            <AtomNode start="(177, 97)" end="(177, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(178, 3)" end="(178, 17)">
              <TacticTacticseq1IndentedNode start="(178, 3)" end="(178, 17)">
                <NullNode start="(178, 3)" end="(178, 17)">
                  <OtherNode start="(178, 3)" end="(178, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ find? p (xs.push a) = some b ↔ find? p xs = some b ∨ find? p xs = none ∧ p a = true ∧ a = b" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;b : α&#10;toList✝ : List α&#10;⊢ find? p ({ toList := toList✝ }.push a) = some b ↔&#10;    find? p { toList := toList✝ } = some b ∨ find? p { toList := toList✝ } = none ∧ p a = true ∧ a = b" tactic="cases xs">
                    <AtomNode start="(178, 3)" end="(178, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(178, 9)" end="(178, 11)">
                      <OtherNode start="(178, 9)" end="(178, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(178, 9)" end="(178, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(178, 11)" end="(178, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(178, 13)" end="(178, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;b : α&#10;toList✝ : List α&#10;⊢ find? p ({ toList := toList✝ }.push a) = some b ↔&#10;    find? p { toList := toList✝ } = some b ∨ find? p { toList := toList✝ } = none ∧ p a = true ∧ a = b" state_after="no goals" tactic="simp">
                    <AtomNode start="(178, 13)" end="(178, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(180, 1)" end="(181, 17)" name="find?_isSome" full_name="Array.find?_isSome">
      <CommandDeclmodifiersNode start="(180, 1)" end="(180, 8)">
        <NullNode/>
        <NullNode start="(180, 1)" end="(180, 8)">
          <OtherNode start="(180, 1)" end="(180, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(180, 1)" end="(180, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(180, 3)" end="(180, 7)">
              <OtherNode start="(180, 3)" end="(180, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(180, 3)" end="(180, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(180, 3)" end="(180, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(180, 7)" end="(180, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(180, 9)" end="(181, 17)" name="find?_isSome" full_name="Array.find?_isSome" _is_private_decl="False">
        <AtomNode start="(180, 9)" end="(180, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(180, 17)" end="(180, 29)">
          <IdentNode start="(180, 17)" end="(180, 29)" leading="" trailing=" " raw_val="find?_isSome" val="find?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(180, 30)" end="(180, 101)">
          <NullNode start="(180, 30)" end="(180, 59)">
            <OtherNode start="(180, 30)" end="(180, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(180, 30)" end="(180, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(180, 31)" end="(180, 33)">
                <IdentNode start="(180, 31)" end="(180, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(180, 34)" end="(180, 43)">
                <AtomNode start="(180, 34)" end="(180, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(180, 36)" end="(180, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(180, 36)" end="(180, 41)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(180, 42)" end="(180, 43)">
                    <IdentNode start="(180, 42)" end="(180, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(180, 43)" end="(180, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(180, 45)" end="(180, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(180, 45)" end="(180, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(180, 46)" end="(180, 47)">
                <IdentNode start="(180, 46)" end="(180, 47)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(180, 48)" end="(180, 58)">
                <AtomNode start="(180, 48)" end="(180, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(180, 50)" end="(180, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(180, 50)" end="(180, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(180, 52)" end="(180, 53)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(180, 54)" end="(180, 58)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(180, 58)" end="(180, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(180, 60)" end="(180, 101)">
            <AtomNode start="(180, 60)" end="(180, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(180, 62)" end="(180, 101)" kind="«term_↔_»">
              <OtherNode start="(180, 62)" end="(180, 81)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(180, 62)" end="(180, 74)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(180, 62)" end="(180, 63)" leading="" trailing="" val="("/>
                  <OtherNode start="(180, 63)" end="(180, 73)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(180, 63)" end="(180, 71)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                    <NullNode start="(180, 72)" end="(180, 73)">
                      <IdentNode start="(180, 72)" end="(180, 73)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(180, 73)" end="(180, 74)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(180, 74)" end="(180, 75)" leading="" trailing="" val="."/>
                <IdentNode start="(180, 75)" end="(180, 81)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(180, 82)" end="(180, 83)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(180, 84)" end="(180, 101)" kind="«term∃_,_»">
                <AtomNode start="(180, 84)" end="(180, 85)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(180, 86)" end="(180, 87)" kind="Lean.explicitBinders">
                  <OtherNode start="(180, 86)" end="(180, 87)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(180, 86)" end="(180, 87)">
                      <LeanBinderidentNode start="(180, 86)" end="(180, 87)">
                        <IdentNode start="(180, 86)" end="(180, 87)" leading="" trailing="" raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(180, 87)" end="(180, 88)" leading="" trailing=" " val=","/>
                <OtherNode start="(180, 89)" end="(180, 101)" kind="«term_∧_»">
                  <OtherNode start="(180, 89)" end="(180, 95)" kind="«term_∈_»">
                    <IdentNode start="(180, 89)" end="(180, 90)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(180, 91)" end="(180, 92)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(180, 93)" end="(180, 95)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(180, 96)" end="(180, 97)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(180, 98)" end="(180, 101)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(180, 98)" end="(180, 99)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(180, 100)" end="(180, 101)">
                      <IdentNode start="(180, 100)" end="(180, 101)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(180, 102)" end="(181, 17)">
          <AtomNode start="(180, 102)" end="(180, 104)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(180, 105)" end="(181, 17)">
            <AtomNode start="(180, 105)" end="(180, 107)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(181, 3)" end="(181, 17)">
              <TacticTacticseq1IndentedNode start="(181, 3)" end="(181, 17)">
                <NullNode start="(181, 3)" end="(181, 17)">
                  <OtherNode start="(181, 3)" end="(181, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ (find? p xs).isSome = true ↔ ∃ x, x ∈ xs ∧ p x = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (find? p { toList := toList✝ }).isSome = true ↔ ∃ x, x ∈ { toList := toList✝ } ∧ p x = true" tactic="cases xs">
                    <AtomNode start="(181, 3)" end="(181, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(181, 9)" end="(181, 11)">
                      <OtherNode start="(181, 9)" end="(181, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(181, 9)" end="(181, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(181, 11)" end="(181, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(181, 13)" end="(181, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (find? p { toList := toList✝ }).isSome = true ↔ ∃ x, x ∈ { toList := toList✝ } ∧ p x = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(181, 13)" end="(181, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(183, 1)" end="(186, 26)" name="find?_some" full_name="Array.find?_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(183, 1)" end="(186, 26)" name="find?_some" full_name="Array.find?_some" _is_private_decl="False">
        <AtomNode start="(183, 1)" end="(183, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(183, 9)" end="(183, 19)">
          <IdentNode start="(183, 9)" end="(183, 19)" leading="" trailing=" " raw_val="find?_some" val="find?_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(183, 20)" end="(183, 66)">
          <NullNode start="(183, 20)" end="(183, 60)">
            <OtherNode start="(183, 20)" end="(183, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(183, 20)" end="(183, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(183, 21)" end="(183, 23)">
                <IdentNode start="(183, 21)" end="(183, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(183, 24)" end="(183, 33)">
                <AtomNode start="(183, 24)" end="(183, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 26)" end="(183, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(183, 26)" end="(183, 31)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(183, 32)" end="(183, 33)">
                    <IdentNode start="(183, 32)" end="(183, 33)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(183, 33)" end="(183, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(183, 35)" end="(183, 60)">
              <AtomNode start="(183, 35)" end="(183, 36)" leading="" trailing="" val="("/>
              <NullNode start="(183, 36)" end="(183, 37)">
                <IdentNode start="(183, 36)" end="(183, 37)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(183, 38)" end="(183, 59)">
                <AtomNode start="(183, 38)" end="(183, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 40)" end="(183, 59)" kind="«term_=_»">
                  <OtherNode start="(183, 40)" end="(183, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(183, 40)" end="(183, 45)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                    <NullNode start="(183, 46)" end="(183, 50)">
                      <IdentNode start="(183, 46)" end="(183, 47)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(183, 48)" end="(183, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(183, 51)" end="(183, 52)" leading="" trailing=" " val="="/>
                  <OtherNode start="(183, 53)" end="(183, 59)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(183, 53)" end="(183, 57)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(183, 58)" end="(183, 59)">
                      <IdentNode start="(183, 58)" end="(183, 59)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(183, 59)" end="(183, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(183, 61)" end="(183, 66)">
            <AtomNode start="(183, 61)" end="(183, 62)" leading="" trailing=" " val=":"/>
            <OtherNode start="(183, 63)" end="(183, 66)" kind="Lean.Parser.Term.app">
              <IdentNode start="(183, 63)" end="(183, 64)" leading="" trailing=" " raw_val="p" val="p"/>
              <NullNode start="(183, 65)" end="(183, 66)">
                <IdentNode start="(183, 65)" end="(183, 66)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(183, 67)" end="(186, 26)">
          <AtomNode start="(183, 67)" end="(183, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(183, 70)" end="(186, 26)">
            <AtomNode start="(183, 70)" end="(183, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(184, 3)" end="(186, 26)">
              <TacticTacticseq1IndentedNode start="(184, 3)" end="(186, 26)">
                <NullNode start="(184, 3)" end="(186, 26)">
                  <OtherNode start="(184, 3)" end="(184, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : find? p xs = some a&#10;⊢ p a = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : find? p { toList := toList✝ } = some a&#10;⊢ p a = true" tactic="cases xs">
                    <AtomNode start="(184, 3)" end="(184, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(184, 9)" end="(184, 11)">
                      <OtherNode start="(184, 9)" end="(184, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(184, 9)" end="(184, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(185, 3)" end="(185, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : find? p { toList := toList✝ } = some a&#10;⊢ p a = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : List.find? p toList✝ = some a&#10;⊢ p a = true" tactic="simp at h">
                    <AtomNode start="(185, 3)" end="(185, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(185, 8)" end="(185, 12)">
                      <OtherNode start="(185, 8)" end="(185, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(185, 8)" end="(185, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(185, 11)" end="(185, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(185, 11)" end="(185, 12)">
                            <IdentNode start="(185, 11)" end="(185, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(186, 3)" end="(186, 26)" kind="Lean.Parser.Tactic.exact" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : List.find? p toList✝ = some a&#10;⊢ p a = true" state_after="no goals" tactic="exact List.find?_some h">
                    <AtomNode start="(186, 3)" end="(186, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(186, 9)" end="(186, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(186, 9)" end="(186, 24)" leading="" trailing=" " raw_val="List.find?_some" val="List.find?_some" full_name="List.find?_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                      <NullNode start="(186, 25)" end="(186, 26)">
                        <IdentNode start="(186, 25)" end="(186, 26)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(188, 1)" end="(191, 42)" name="mem_of_find?_eq_some" full_name="Array.mem_of_find?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(188, 1)" end="(191, 42)" name="mem_of_find?_eq_some" full_name="Array.mem_of_find?_eq_some" _is_private_decl="False">
        <AtomNode start="(188, 1)" end="(188, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(188, 9)" end="(188, 29)">
          <IdentNode start="(188, 9)" end="(188, 29)" leading="" trailing=" " raw_val="mem_of_find?_eq_some" val="mem_of_find?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(188, 30)" end="(188, 79)">
          <NullNode start="(188, 30)" end="(188, 70)">
            <OtherNode start="(188, 30)" end="(188, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 30)" end="(188, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 31)" end="(188, 33)">
                <IdentNode start="(188, 31)" end="(188, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(188, 34)" end="(188, 43)">
                <AtomNode start="(188, 34)" end="(188, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 36)" end="(188, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(188, 36)" end="(188, 41)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(188, 42)" end="(188, 43)">
                    <IdentNode start="(188, 42)" end="(188, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(188, 43)" end="(188, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(188, 45)" end="(188, 70)">
              <AtomNode start="(188, 45)" end="(188, 46)" leading="" trailing="" val="("/>
              <NullNode start="(188, 46)" end="(188, 47)">
                <IdentNode start="(188, 46)" end="(188, 47)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(188, 48)" end="(188, 69)">
                <AtomNode start="(188, 48)" end="(188, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 50)" end="(188, 69)" kind="«term_=_»">
                  <OtherNode start="(188, 50)" end="(188, 60)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(188, 50)" end="(188, 55)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                    <NullNode start="(188, 56)" end="(188, 60)">
                      <IdentNode start="(188, 56)" end="(188, 57)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(188, 58)" end="(188, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(188, 61)" end="(188, 62)" leading="" trailing=" " val="="/>
                  <OtherNode start="(188, 63)" end="(188, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(188, 63)" end="(188, 67)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(188, 68)" end="(188, 69)">
                      <IdentNode start="(188, 68)" end="(188, 69)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(188, 69)" end="(188, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(188, 71)" end="(188, 79)">
            <AtomNode start="(188, 71)" end="(188, 72)" leading="" trailing=" " val=":"/>
            <OtherNode start="(188, 73)" end="(188, 79)" kind="«term_∈_»">
              <IdentNode start="(188, 73)" end="(188, 74)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(188, 75)" end="(188, 76)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(188, 77)" end="(188, 79)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(188, 80)" end="(191, 42)">
          <AtomNode start="(188, 80)" end="(188, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(188, 83)" end="(191, 42)">
            <AtomNode start="(188, 83)" end="(188, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(189, 3)" end="(191, 42)">
              <TacticTacticseq1IndentedNode start="(189, 3)" end="(191, 42)">
                <NullNode start="(189, 3)" end="(191, 42)">
                  <OtherNode start="(189, 3)" end="(189, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : find? p xs = some a&#10;⊢ a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : find? p { toList := toList✝ } = some a&#10;⊢ a ∈ { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(189, 3)" end="(189, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(189, 9)" end="(189, 11)">
                      <OtherNode start="(189, 9)" end="(189, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(189, 9)" end="(189, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(190, 3)" end="(190, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : find? p { toList := toList✝ } = some a&#10;⊢ a ∈ { toList := toList✝ }" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : List.find? p toList✝ = some a&#10;⊢ a ∈ { toList := toList✝ }" tactic="simp at h">
                    <AtomNode start="(190, 3)" end="(190, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(190, 8)" end="(190, 12)">
                      <OtherNode start="(190, 8)" end="(190, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(190, 8)" end="(190, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(190, 11)" end="(190, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(190, 11)" end="(190, 12)">
                            <IdentNode start="(190, 11)" end="(190, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(191, 3)" end="(191, 42)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;toList✝ : List α&#10;h : List.find? p toList✝ = some a&#10;⊢ a ∈ { toList := toList✝ }" state_after="no goals" tactic="simpa using List.mem_of_find?_eq_some h">
                    <AtomNode start="(191, 3)" end="(191, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(191, 9)" end="(191, 42)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(191, 9)" end="(191, 42)">
                        <AtomNode start="(191, 9)" end="(191, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(191, 15)" end="(191, 42)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(191, 15)" end="(191, 40)" leading="" trailing=" " raw_val="List.mem_of_find?_eq_some" val="List.mem_of_find?_eq_some" full_name="List.mem_of_find?_eq_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                          <NullNode start="(191, 41)" end="(191, 42)">
                            <IdentNode start="(191, 41)" end="(191, 42)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(193, 1)" end="(195, 28)" name="get_find?_mem" full_name="Array.get_find?_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(193, 1)" end="(195, 28)" name="get_find?_mem" full_name="Array.get_find?_mem" _is_private_decl="False">
        <AtomNode start="(193, 1)" end="(193, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(193, 9)" end="(193, 22)">
          <IdentNode start="(193, 9)" end="(193, 22)" leading="" trailing=" " raw_val="get_find?_mem" val="get_find?_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(193, 23)" end="(193, 67)">
          <NullNode start="(193, 23)" end="(193, 41)">
            <OtherNode start="(193, 23)" end="(193, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(193, 23)" end="(193, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(193, 24)" end="(193, 26)">
                <IdentNode start="(193, 24)" end="(193, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(193, 27)" end="(193, 36)">
                <AtomNode start="(193, 27)" end="(193, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(193, 29)" end="(193, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(193, 29)" end="(193, 34)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(193, 35)" end="(193, 36)">
                    <IdentNode start="(193, 35)" end="(193, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(193, 36)" end="(193, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(193, 38)" end="(193, 41)">
              <AtomNode start="(193, 38)" end="(193, 39)" leading="" trailing="" val="("/>
              <NullNode start="(193, 39)" end="(193, 40)">
                <IdentNode start="(193, 39)" end="(193, 40)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(193, 40)" end="(193, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(193, 42)" end="(193, 67)">
            <AtomNode start="(193, 42)" end="(193, 43)" leading="" trailing=" " val=":"/>
            <OtherNode start="(193, 44)" end="(193, 67)" kind="«term_∈_»">
              <OtherNode start="(193, 44)" end="(193, 62)" kind="Lean.Parser.Term.app">
                <OtherNode start="(193, 44)" end="(193, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(193, 44)" end="(193, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(193, 44)" end="(193, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(193, 45)" end="(193, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(193, 45)" end="(193, 53)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(193, 54)" end="(193, 55)">
                        <IdentNode start="(193, 54)" end="(193, 55)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(193, 55)" end="(193, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(193, 56)" end="(193, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(193, 57)" end="(193, 60)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(193, 61)" end="(193, 62)">
                  <IdentNode start="(193, 61)" end="(193, 62)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(193, 63)" end="(193, 64)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(193, 65)" end="(193, 67)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(193, 68)" end="(195, 28)">
          <AtomNode start="(193, 68)" end="(193, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(193, 71)" end="(195, 28)">
            <AtomNode start="(193, 71)" end="(193, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(194, 3)" end="(195, 28)">
              <TacticTacticseq1IndentedNode start="(194, 3)" end="(195, 28)">
                <NullNode start="(194, 3)" end="(195, 28)">
                  <OtherNode start="(194, 3)" end="(194, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : (find? p xs).isSome = true&#10;⊢ (find? p xs).get h ∈ xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;h : (find? p { toList := toList✝ }).isSome = true&#10;⊢ (find? p { toList := toList✝ }).get h ∈ { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(194, 3)" end="(194, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(194, 9)" end="(194, 11)">
                      <OtherNode start="(194, 9)" end="(194, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(194, 9)" end="(194, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(195, 3)" end="(195, 28)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;h : (find? p { toList := toList✝ }).isSome = true&#10;⊢ (find? p { toList := toList✝ }).get h ∈ { toList := toList✝ }" state_after="no goals" tactic="simp [List.get_find?_mem]">
                    <AtomNode start="(195, 3)" end="(195, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(195, 8)" end="(195, 28)">
                      <AtomNode start="(195, 8)" end="(195, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(195, 9)" end="(195, 27)">
                        <OtherNode start="(195, 9)" end="(195, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(195, 9)" end="(195, 27)" leading="" trailing="" raw_val="List.get_find?_mem" val="List.get_find?_mem" full_name="List.get_find?_mem" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(195, 27)" end="(195, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(197, 1)" end="(199, 17)" name="find?_filter" full_name="Array.find?_filter">
      <CommandDeclmodifiersNode start="(197, 1)" end="(197, 8)">
        <NullNode/>
        <NullNode start="(197, 1)" end="(197, 8)">
          <OtherNode start="(197, 1)" end="(197, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(197, 1)" end="(197, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(197, 3)" end="(197, 7)">
              <OtherNode start="(197, 3)" end="(197, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(197, 3)" end="(197, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(197, 3)" end="(197, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(197, 7)" end="(197, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(197, 9)" end="(199, 17)" name="find?_filter" full_name="Array.find?_filter" _is_private_decl="False">
        <AtomNode start="(197, 9)" end="(197, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(197, 17)" end="(197, 29)">
          <IdentNode start="(197, 17)" end="(197, 29)" leading="" trailing=" " raw_val="find?_filter" val="find?_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(197, 30)" end="(198, 58)">
          <NullNode start="(197, 30)" end="(197, 61)">
            <OtherNode start="(197, 30)" end="(197, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(197, 30)" end="(197, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(197, 31)" end="(197, 33)">
                <IdentNode start="(197, 31)" end="(197, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(197, 34)" end="(197, 43)">
                <AtomNode start="(197, 34)" end="(197, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(197, 36)" end="(197, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(197, 36)" end="(197, 41)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(197, 42)" end="(197, 43)">
                    <IdentNode start="(197, 42)" end="(197, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(197, 43)" end="(197, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(197, 45)" end="(197, 61)">
              <AtomNode start="(197, 45)" end="(197, 46)" leading="" trailing="" val="("/>
              <NullNode start="(197, 46)" end="(197, 49)">
                <IdentNode start="(197, 46)" end="(197, 47)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(197, 48)" end="(197, 49)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(197, 50)" end="(197, 60)">
                <AtomNode start="(197, 50)" end="(197, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(197, 52)" end="(197, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(197, 52)" end="(197, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(197, 54)" end="(197, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(197, 56)" end="(197, 60)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(197, 60)" end="(197, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(197, 62)" end="(198, 58)">
            <AtomNode start="(197, 62)" end="(197, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(198, 5)" end="(198, 58)" kind="«term_=_»">
              <OtherNode start="(198, 5)" end="(198, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(198, 5)" end="(198, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(198, 5)" end="(198, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(198, 5)" end="(198, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(198, 6)" end="(198, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(198, 6)" end="(198, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                      <NullNode start="(198, 16)" end="(198, 17)">
                        <IdentNode start="(198, 16)" end="(198, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(198, 17)" end="(198, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(198, 18)" end="(198, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(198, 19)" end="(198, 24)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(198, 25)" end="(198, 26)">
                  <IdentNode start="(198, 25)" end="(198, 26)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(198, 27)" end="(198, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(198, 29)" end="(198, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(198, 29)" end="(198, 37)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                <NullNode start="(198, 38)" end="(198, 58)">
                  <OtherNode start="(198, 38)" end="(198, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(198, 38)" end="(198, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(198, 39)" end="(198, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(198, 39)" end="(198, 42)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(198, 43)" end="(198, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(198, 43)" end="(198, 44)">
                          <IdentNode start="(198, 43)" end="(198, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(198, 45)" end="(198, 47)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(198, 48)" end="(198, 57)" kind="«term_∧_»">
                          <OtherNode start="(198, 48)" end="(198, 51)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(198, 48)" end="(198, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(198, 50)" end="(198, 51)">
                              <IdentNode start="(198, 50)" end="(198, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(198, 52)" end="(198, 53)" leading="" trailing=" " val="∧"/>
                          <OtherNode start="(198, 54)" end="(198, 57)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(198, 54)" end="(198, 55)" leading="" trailing=" " raw_val="q" val="q"/>
                            <NullNode start="(198, 56)" end="(198, 57)">
                              <IdentNode start="(198, 56)" end="(198, 57)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(198, 57)" end="(198, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(198, 59)" end="(199, 17)">
          <AtomNode start="(198, 59)" end="(198, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(198, 62)" end="(199, 17)">
            <AtomNode start="(198, 62)" end="(198, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(199, 3)" end="(199, 17)">
              <TacticTacticseq1IndentedNode start="(199, 3)" end="(199, 17)">
                <NullNode start="(199, 3)" end="(199, 17)">
                  <OtherNode start="(199, 3)" end="(199, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xs : Array α&#10;p q : α → Bool&#10;⊢ find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;toList✝ : List α&#10;⊢ find? q (filter p { toList := toList✝ }) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(199, 3)" end="(199, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(199, 9)" end="(199, 11)">
                      <OtherNode start="(199, 9)" end="(199, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(199, 9)" end="(199, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(199, 11)" end="(199, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(199, 13)" end="(199, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;toList✝ : List α&#10;⊢ find? q (filter p { toList := toList✝ }) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) { toList := toList✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(199, 13)" end="(199, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(201, 1)" end="(203, 44)" name="getElem?_zero_filter" full_name="Array.getElem?_zero_filter">
      <CommandDeclmodifiersNode start="(201, 1)" end="(201, 8)">
        <NullNode/>
        <NullNode start="(201, 1)" end="(201, 8)">
          <OtherNode start="(201, 1)" end="(201, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(201, 1)" end="(201, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(201, 3)" end="(201, 7)">
              <OtherNode start="(201, 3)" end="(201, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(201, 3)" end="(201, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(201, 3)" end="(201, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(201, 7)" end="(201, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(201, 9)" end="(203, 44)" name="getElem?_zero_filter" full_name="Array.getElem?_zero_filter" _is_private_decl="False">
        <AtomNode start="(201, 9)" end="(201, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(201, 17)" end="(201, 37)">
          <IdentNode start="(201, 17)" end="(201, 37)" leading="" trailing=" " raw_val="getElem?_zero_filter" val="getElem?_zero_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(201, 38)" end="(202, 35)">
          <NullNode start="(201, 38)" end="(201, 67)">
            <OtherNode start="(201, 38)" end="(201, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(201, 38)" end="(201, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(201, 39)" end="(201, 40)">
                <IdentNode start="(201, 39)" end="(201, 40)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(201, 41)" end="(201, 51)">
                <AtomNode start="(201, 41)" end="(201, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 43)" end="(201, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(201, 43)" end="(201, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(201, 45)" end="(201, 46)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(201, 47)" end="(201, 51)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(201, 51)" end="(201, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(201, 53)" end="(201, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(201, 53)" end="(201, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(201, 54)" end="(201, 56)">
                <IdentNode start="(201, 54)" end="(201, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(201, 57)" end="(201, 66)">
                <AtomNode start="(201, 57)" end="(201, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 59)" end="(201, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(201, 59)" end="(201, 64)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(201, 65)" end="(201, 66)">
                    <IdentNode start="(201, 65)" end="(201, 66)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(201, 66)" end="(201, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(201, 68)" end="(202, 35)">
            <AtomNode start="(201, 68)" end="(201, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(202, 5)" end="(202, 35)" kind="«term_=_»">
              <OtherNode start="(202, 5)" end="(202, 22)" kind="«term__[_]_?»">
                <OtherNode start="(202, 5)" end="(202, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(202, 5)" end="(202, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(202, 6)" end="(202, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(202, 6)" end="(202, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                    <NullNode start="(202, 16)" end="(202, 17)">
                      <IdentNode start="(202, 16)" end="(202, 17)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(202, 17)" end="(202, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(202, 18)" end="(202, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(202, 19)" end="(202, 20)" kind="num">
                  <AtomNode start="(202, 19)" end="(202, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(202, 20)" end="(202, 21)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(202, 21)" end="(202, 22)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(202, 23)" end="(202, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(202, 25)" end="(202, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(202, 25)" end="(202, 33)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                <NullNode start="(202, 34)" end="(202, 35)">
                  <IdentNode start="(202, 34)" end="(202, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(202, 36)" end="(203, 44)">
          <AtomNode start="(202, 36)" end="(202, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(202, 39)" end="(203, 44)">
            <AtomNode start="(202, 39)" end="(202, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(203, 3)" end="(203, 44)">
              <TacticTacticseq1IndentedNode start="(203, 3)" end="(203, 44)">
                <NullNode start="(203, 3)" end="(203, 44)">
                  <OtherNode start="(203, 3)" end="(203, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (filter p xs)[0]? = find? p xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (filter p { toList := toList✝ })[0]? = find? p { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(203, 3)" end="(203, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(203, 9)" end="(203, 11)">
                      <OtherNode start="(203, 9)" end="(203, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(203, 9)" end="(203, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(203, 11)" end="(203, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(203, 13)" end="(203, 44)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (filter p { toList := toList✝ })[0]? = find? p { toList := toList✝ }" state_after="no goals" tactic="simp [← List.head?_eq_getElem?]">
                    <AtomNode start="(203, 13)" end="(203, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(203, 18)" end="(203, 44)">
                      <AtomNode start="(203, 18)" end="(203, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(203, 19)" end="(203, 43)">
                        <OtherNode start="(203, 19)" end="(203, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(203, 19)" end="(203, 20)">
                            <OtherNode start="(203, 19)" end="(203, 20)" kind="patternIgnore">
                              <OtherNode start="(203, 19)" end="(203, 20)" kind="token.«← »">
                                <AtomNode start="(203, 19)" end="(203, 20)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(203, 21)" end="(203, 43)" leading="" trailing="" raw_val="List.head?_eq_getElem?" val="List.head?_eq_getElem?" full_name="List.head?_eq_getElem?" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(203, 43)" end="(203, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(205, 1)" end="(209, 35)" name="getElem_zero_filter" full_name="Array.getElem_zero_filter">
      <CommandDeclmodifiersNode start="(205, 1)" end="(205, 8)">
        <NullNode/>
        <NullNode start="(205, 1)" end="(205, 8)">
          <OtherNode start="(205, 1)" end="(205, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(205, 1)" end="(205, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(205, 3)" end="(205, 7)">
              <OtherNode start="(205, 3)" end="(205, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(205, 3)" end="(205, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(205, 3)" end="(205, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(205, 7)" end="(205, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(205, 9)" end="(209, 35)" name="getElem_zero_filter" full_name="Array.getElem_zero_filter" _is_private_decl="False">
        <AtomNode start="(205, 9)" end="(205, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(205, 17)" end="(205, 36)">
          <IdentNode start="(205, 17)" end="(205, 36)" leading="" trailing=" " raw_val="getElem_zero_filter" val="getElem_zero_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(205, 37)" end="(207, 85)">
          <NullNode start="(205, 37)" end="(205, 70)">
            <OtherNode start="(205, 37)" end="(205, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(205, 37)" end="(205, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(205, 38)" end="(205, 39)">
                <IdentNode start="(205, 38)" end="(205, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(205, 40)" end="(205, 50)">
                <AtomNode start="(205, 40)" end="(205, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(205, 42)" end="(205, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(205, 42)" end="(205, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(205, 44)" end="(205, 45)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(205, 46)" end="(205, 50)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(205, 50)" end="(205, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(205, 52)" end="(205, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(205, 52)" end="(205, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(205, 53)" end="(205, 55)">
                <IdentNode start="(205, 53)" end="(205, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(205, 56)" end="(205, 65)">
                <AtomNode start="(205, 56)" end="(205, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(205, 58)" end="(205, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(205, 58)" end="(205, 63)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(205, 64)" end="(205, 65)">
                    <IdentNode start="(205, 64)" end="(205, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(205, 65)" end="(205, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(205, 67)" end="(205, 70)">
              <AtomNode start="(205, 67)" end="(205, 68)" leading="" trailing="" val="("/>
              <NullNode start="(205, 68)" end="(205, 69)">
                <IdentNode start="(205, 68)" end="(205, 69)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(205, 69)" end="(205, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(205, 71)" end="(207, 85)">
            <AtomNode start="(205, 71)" end="(205, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(206, 5)" end="(207, 85)" kind="«term_=_»">
              <OtherNode start="(206, 5)" end="(206, 21)" kind="«term__[_]»">
                <OtherNode start="(206, 5)" end="(206, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(206, 5)" end="(206, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(206, 6)" end="(206, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(206, 6)" end="(206, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                    <NullNode start="(206, 16)" end="(206, 17)">
                      <IdentNode start="(206, 16)" end="(206, 17)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(206, 17)" end="(206, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(206, 18)" end="(206, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(206, 19)" end="(206, 20)" kind="num">
                  <AtomNode start="(206, 19)" end="(206, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(206, 20)" end="(206, 21)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(206, 22)" end="(206, 23)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(207, 7)" end="(207, 85)" kind="Lean.Parser.Term.app">
                <OtherNode start="(207, 7)" end="(207, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(207, 7)" end="(207, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(207, 7)" end="(207, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(207, 8)" end="(207, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(207, 8)" end="(207, 16)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(207, 17)" end="(207, 18)">
                        <IdentNode start="(207, 17)" end="(207, 18)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(207, 18)" end="(207, 19)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(207, 19)" end="(207, 20)" leading="" trailing="" val="."/>
                  <IdentNode start="(207, 20)" end="(207, 23)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(207, 24)" end="(207, 85)">
                  <OtherNode start="(207, 24)" end="(207, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(207, 24)" end="(207, 25)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(207, 25)" end="(207, 84)">
                      <AtomNode start="(207, 25)" end="(207, 27)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(207, 28)" end="(207, 84)">
                        <TacticTacticseq1IndentedNode start="(207, 28)" end="(207, 84)">
                          <NullNode start="(207, 28)" end="(207, 84)">
                            <OtherNode start="(207, 28)" end="(207, 36)" kind="Lean.Parser.Tactic.cases" state_before="α : Type ?u.33681&#10;p : α → Bool&#10;xs : Array α&#10;h : 0 &amp;lt; (filter p xs).size&#10;⊢ (find? p xs).isSome = true" state_after="case mk&#10;α : Type ?u.33681&#10;p : α → Bool&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filter p { toList := toList✝ }).size&#10;⊢ (find? p { toList := toList✝ }).isSome = true" tactic="cases xs">
                              <AtomNode start="(207, 28)" end="(207, 33)" leading="" trailing=" " val="cases"/>
                              <NullNode start="(207, 34)" end="(207, 36)">
                                <OtherNode start="(207, 34)" end="(207, 36)" kind="Lean.Parser.Tactic.elimTarget">
                                  <NullNode/>
                                  <IdentNode start="(207, 34)" end="(207, 36)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(207, 36)" end="(207, 37)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(207, 38)" end="(207, 84)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type ?u.33681&#10;p : α → Bool&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filter p { toList := toList✝ }).size&#10;⊢ (find? p { toList := toList✝ }).isSome = true" state_after="no goals" tactic="simpa [← List.countP_eq_length_filter] using h">
                              <AtomNode start="(207, 38)" end="(207, 43)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(207, 44)" end="(207, 84)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(207, 44)" end="(207, 76)">
                                  <OtherNode start="(207, 44)" end="(207, 76)" kind="Lean.Parser.Tactic.simpArgs">
                                    <AtomNode start="(207, 44)" end="(207, 45)" leading="" trailing="" val="["/>
                                    <NullNode start="(207, 45)" end="(207, 75)">
                                      <OtherNode start="(207, 45)" end="(207, 75)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode start="(207, 45)" end="(207, 46)">
                                          <OtherNode start="(207, 45)" end="(207, 46)" kind="patternIgnore">
                                            <OtherNode start="(207, 45)" end="(207, 46)" kind="token.«← »">
                                              <AtomNode start="(207, 45)" end="(207, 46)" leading="" trailing=" " val="←"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <IdentNode start="(207, 47)" end="(207, 75)" leading="" trailing="" raw_val="List.countP_eq_length_filter" val="List.countP_eq_length_filter" full_name="List.countP_eq_length_filter" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(207, 75)" end="(207, 76)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode start="(207, 77)" end="(207, 84)">
                                  <AtomNode start="(207, 77)" end="(207, 82)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(207, 83)" end="(207, 84)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(207, 84)" end="(207, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(207, 86)" end="(209, 35)">
          <AtomNode start="(207, 86)" end="(207, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(207, 89)" end="(209, 35)">
            <AtomNode start="(207, 89)" end="(207, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(208, 3)" end="(209, 35)">
              <TacticTacticseq1IndentedNode start="(208, 3)" end="(209, 35)">
                <NullNode start="(208, 3)" end="(209, 35)">
                  <OtherNode start="(208, 3)" end="(208, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : 0 &amp;lt; (filter p xs).size&#10;⊢ (filter p xs)[0] = (find? p xs).get ⋯" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filter p { toList := toList✝ }).size&#10;⊢ (filter p { toList := toList✝ })[0] = (find? p { toList := toList✝ }).get ⋯" tactic="cases xs">
                    <AtomNode start="(208, 3)" end="(208, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(208, 9)" end="(208, 11)">
                      <OtherNode start="(208, 9)" end="(208, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(208, 9)" end="(208, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(209, 3)" end="(209, 35)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;h : 0 &amp;lt; (filter p { toList := toList✝ }).size&#10;⊢ (filter p { toList := toList✝ })[0] = (find? p { toList := toList✝ }).get ⋯" state_after="no goals" tactic="simp [List.getElem_zero_eq_head]">
                    <AtomNode start="(209, 3)" end="(209, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(209, 8)" end="(209, 35)">
                      <AtomNode start="(209, 8)" end="(209, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(209, 9)" end="(209, 34)">
                        <OtherNode start="(209, 9)" end="(209, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(209, 9)" end="(209, 34)" leading="" trailing="" raw_val="List.getElem_zero_eq_head" val="List.getElem_zero_eq_head" full_name="List.getElem_zero_eq_head" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(209, 34)" end="(209, 35)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(211, 1)" end="(212, 17)" name="back?_filter" full_name="Array.back?_filter">
      <CommandDeclmodifiersNode start="(211, 1)" end="(211, 8)">
        <NullNode/>
        <NullNode start="(211, 1)" end="(211, 8)">
          <OtherNode start="(211, 1)" end="(211, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(211, 1)" end="(211, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(211, 3)" end="(211, 7)">
              <OtherNode start="(211, 3)" end="(211, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(211, 3)" end="(211, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(211, 3)" end="(211, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(211, 7)" end="(211, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(211, 9)" end="(212, 17)" name="back?_filter" full_name="Array.back?_filter" _is_private_decl="False">
        <AtomNode start="(211, 9)" end="(211, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(211, 17)" end="(211, 29)">
          <IdentNode start="(211, 17)" end="(211, 29)" leading="" trailing=" " raw_val="back?_filter" val="back?_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(211, 30)" end="(211, 97)">
          <NullNode start="(211, 30)" end="(211, 59)">
            <OtherNode start="(211, 30)" end="(211, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(211, 30)" end="(211, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(211, 31)" end="(211, 32)">
                <IdentNode start="(211, 31)" end="(211, 32)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(211, 33)" end="(211, 43)">
                <AtomNode start="(211, 33)" end="(211, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 35)" end="(211, 43)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(211, 35)" end="(211, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(211, 37)" end="(211, 38)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(211, 39)" end="(211, 43)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(211, 43)" end="(211, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(211, 45)" end="(211, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(211, 45)" end="(211, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(211, 46)" end="(211, 48)">
                <IdentNode start="(211, 46)" end="(211, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(211, 49)" end="(211, 58)">
                <AtomNode start="(211, 49)" end="(211, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 51)" end="(211, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 51)" end="(211, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(211, 57)" end="(211, 58)">
                    <IdentNode start="(211, 57)" end="(211, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(211, 58)" end="(211, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(211, 60)" end="(211, 97)">
            <AtomNode start="(211, 60)" end="(211, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(211, 62)" end="(211, 97)" kind="«term_=_»">
              <OtherNode start="(211, 62)" end="(211, 81)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(211, 62)" end="(211, 75)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(211, 62)" end="(211, 63)" leading="" trailing="" val="("/>
                  <OtherNode start="(211, 63)" end="(211, 74)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(211, 63)" end="(211, 72)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                    <NullNode start="(211, 73)" end="(211, 74)">
                      <IdentNode start="(211, 73)" end="(211, 74)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(211, 74)" end="(211, 75)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(211, 75)" end="(211, 76)" leading="" trailing="" val="."/>
                <IdentNode start="(211, 76)" end="(211, 81)" leading="" trailing=" " raw_val="back?" val="back?" full_name="Array.back?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(211, 82)" end="(211, 83)" leading="" trailing=" " val="="/>
              <OtherNode start="(211, 84)" end="(211, 97)" kind="Lean.Parser.Term.app">
                <IdentNode start="(211, 84)" end="(211, 95)" leading="" trailing=" " raw_val="xs.findRev?" val="xs.findRev?"/>
                <NullNode start="(211, 96)" end="(211, 97)">
                  <IdentNode start="(211, 96)" end="(211, 97)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(211, 98)" end="(212, 17)">
          <AtomNode start="(211, 98)" end="(211, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(211, 101)" end="(212, 17)">
            <AtomNode start="(211, 101)" end="(211, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(212, 3)" end="(212, 17)">
              <TacticTacticseq1IndentedNode start="(212, 3)" end="(212, 17)">
                <NullNode start="(212, 3)" end="(212, 17)">
                  <OtherNode start="(212, 3)" end="(212, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (filter p xs).back? = findRev? p xs" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (filter p { toList := toList✝ }).back? = findRev? p { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(212, 3)" end="(212, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(212, 9)" end="(212, 11)">
                      <OtherNode start="(212, 9)" end="(212, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(212, 9)" end="(212, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(212, 11)" end="(212, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(212, 13)" end="(212, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (filter p { toList := toList✝ }).back? = findRev? p { toList := toList✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(212, 13)" end="(212, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(214, 1)" end="(216, 39)" name="back!_filter" full_name="Array.back!_filter">
      <CommandDeclmodifiersNode start="(214, 1)" end="(214, 8)">
        <NullNode/>
        <NullNode start="(214, 1)" end="(214, 8)">
          <OtherNode start="(214, 1)" end="(214, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(214, 1)" end="(214, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(214, 3)" end="(214, 7)">
              <OtherNode start="(214, 3)" end="(214, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(214, 3)" end="(214, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(214, 3)" end="(214, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(214, 7)" end="(214, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(214, 9)" end="(216, 39)" name="back!_filter" full_name="Array.back!_filter" _is_private_decl="False">
        <AtomNode start="(214, 9)" end="(214, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(214, 17)" end="(214, 29)">
          <IdentNode start="(214, 17)" end="(214, 29)" leading="" trailing=" " raw_val="back!_filter" val="back!_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(214, 30)" end="(215, 47)">
          <NullNode start="(214, 30)" end="(214, 73)">
            <OtherNode start="(214, 30)" end="(214, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(214, 30)" end="(214, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(214, 31)" end="(214, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(214, 31)" end="(214, 40)" leading="" trailing=" " raw_val="Inhabited" val="Inhabited" full_name="Inhabited" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(214, 41)" end="(214, 42)">
                  <IdentNode start="(214, 41)" end="(214, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(214, 42)" end="(214, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(214, 44)" end="(214, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(214, 44)" end="(214, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(214, 45)" end="(214, 46)">
                <IdentNode start="(214, 45)" end="(214, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(214, 47)" end="(214, 57)">
                <AtomNode start="(214, 47)" end="(214, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(214, 49)" end="(214, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(214, 49)" end="(214, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(214, 51)" end="(214, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(214, 53)" end="(214, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(214, 57)" end="(214, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(214, 59)" end="(214, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(214, 59)" end="(214, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(214, 60)" end="(214, 62)">
                <IdentNode start="(214, 60)" end="(214, 62)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(214, 63)" end="(214, 72)">
                <AtomNode start="(214, 63)" end="(214, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(214, 65)" end="(214, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(214, 65)" end="(214, 70)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(214, 71)" end="(214, 72)">
                    <IdentNode start="(214, 71)" end="(214, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(214, 72)" end="(214, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(214, 74)" end="(215, 47)">
            <AtomNode start="(214, 74)" end="(214, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(215, 5)" end="(215, 47)" kind="«term_=_»">
              <OtherNode start="(215, 5)" end="(215, 24)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(215, 5)" end="(215, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(215, 5)" end="(215, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(215, 6)" end="(215, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(215, 6)" end="(215, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                    <NullNode start="(215, 16)" end="(215, 17)">
                      <IdentNode start="(215, 16)" end="(215, 17)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(215, 17)" end="(215, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(215, 18)" end="(215, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(215, 19)" end="(215, 24)" leading="" trailing=" " raw_val="back!" val="back!" full_name="Array.back!" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(215, 25)" end="(215, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(215, 27)" end="(215, 47)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(215, 27)" end="(215, 42)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(215, 27)" end="(215, 28)" leading="" trailing="" val="("/>
                  <OtherNode start="(215, 28)" end="(215, 41)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(215, 28)" end="(215, 39)" leading="" trailing=" " raw_val="xs.findRev?" val="xs.findRev?"/>
                    <NullNode start="(215, 40)" end="(215, 41)">
                      <IdentNode start="(215, 40)" end="(215, 41)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(215, 41)" end="(215, 42)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(215, 42)" end="(215, 43)" leading="" trailing="" val="."/>
                <IdentNode start="(215, 43)" end="(215, 47)" leading="" trailing=" " raw_val="get!" val="get!" full_name="Option.get!" mod_name="Init.Data.Option.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/BasicAux.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(215, 48)" end="(216, 39)">
          <AtomNode start="(215, 48)" end="(215, 50)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(215, 51)" end="(216, 39)">
            <AtomNode start="(215, 51)" end="(215, 53)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(216, 3)" end="(216, 39)">
              <TacticTacticseq1IndentedNode start="(216, 3)" end="(216, 39)">
                <NullNode start="(216, 3)" end="(216, 39)">
                  <OtherNode start="(216, 3)" end="(216, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;inst✝ : Inhabited α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (filter p xs).back! = (findRev? p xs).get!" state_after="case mk&#10;α : Type&#10;inst✝ : Inhabited α&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (filter p { toList := toList✝ }).back! = (findRev? p { toList := toList✝ }).get!" tactic="cases xs">
                    <AtomNode start="(216, 3)" end="(216, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(216, 9)" end="(216, 11)">
                      <OtherNode start="(216, 9)" end="(216, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(216, 9)" end="(216, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(216, 11)" end="(216, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(216, 13)" end="(216, 39)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;inst✝ : Inhabited α&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ (filter p { toList := toList✝ }).back! = (findRev? p { toList := toList✝ }).get!" state_after="no goals" tactic="simp [Option.get!_eq_getD]">
                    <AtomNode start="(216, 13)" end="(216, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(216, 18)" end="(216, 39)">
                      <AtomNode start="(216, 18)" end="(216, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(216, 19)" end="(216, 38)">
                        <OtherNode start="(216, 19)" end="(216, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(216, 19)" end="(216, 38)" leading="" trailing="" raw_val="Option.get!_eq_getD" val="Option.get!_eq_getD" full_name="Option.get!_eq_getD" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(216, 38)" end="(216, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(218, 1)" end="(220, 17)" name="find?_filterMap" full_name="Array.find?_filterMap">
      <CommandDeclmodifiersNode start="(218, 1)" end="(218, 8)">
        <NullNode/>
        <NullNode start="(218, 1)" end="(218, 8)">
          <OtherNode start="(218, 1)" end="(218, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(218, 1)" end="(218, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(218, 3)" end="(218, 7)">
              <OtherNode start="(218, 3)" end="(218, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(218, 3)" end="(218, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(218, 3)" end="(218, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(218, 7)" end="(218, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(218, 9)" end="(220, 17)" name="find?_filterMap" full_name="Array.find?_filterMap" _is_private_decl="False">
        <AtomNode start="(218, 9)" end="(218, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(218, 17)" end="(218, 32)">
          <IdentNode start="(218, 17)" end="(218, 32)" leading="" trailing=" " raw_val="find?_filterMap" val="find?_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(218, 33)" end="(219, 72)">
          <NullNode start="(218, 33)" end="(218, 81)">
            <OtherNode start="(218, 33)" end="(218, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(218, 33)" end="(218, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(218, 34)" end="(218, 36)">
                <IdentNode start="(218, 34)" end="(218, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(218, 37)" end="(218, 46)">
                <AtomNode start="(218, 37)" end="(218, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(218, 39)" end="(218, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(218, 39)" end="(218, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(218, 45)" end="(218, 46)">
                    <IdentNode start="(218, 45)" end="(218, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(218, 46)" end="(218, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(218, 48)" end="(218, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(218, 48)" end="(218, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(218, 49)" end="(218, 50)">
                <IdentNode start="(218, 49)" end="(218, 50)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(218, 51)" end="(218, 65)">
                <AtomNode start="(218, 51)" end="(218, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(218, 53)" end="(218, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(218, 53)" end="(218, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(218, 55)" end="(218, 56)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(218, 57)" end="(218, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(218, 57)" end="(218, 63)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(218, 64)" end="(218, 65)">
                      <IdentNode start="(218, 64)" end="(218, 65)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(218, 65)" end="(218, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(218, 67)" end="(218, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(218, 67)" end="(218, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(218, 68)" end="(218, 69)">
                <IdentNode start="(218, 68)" end="(218, 69)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(218, 70)" end="(218, 80)">
                <AtomNode start="(218, 70)" end="(218, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(218, 72)" end="(218, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(218, 72)" end="(218, 73)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(218, 74)" end="(218, 75)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(218, 76)" end="(218, 80)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(218, 80)" end="(218, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(218, 82)" end="(219, 72)">
            <AtomNode start="(218, 82)" end="(218, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(219, 5)" end="(219, 72)" kind="«term_=_»">
              <OtherNode start="(219, 5)" end="(219, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(219, 5)" end="(219, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(219, 5)" end="(219, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(219, 5)" end="(219, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(219, 6)" end="(219, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(219, 6)" end="(219, 18)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                      <NullNode start="(219, 19)" end="(219, 20)">
                        <IdentNode start="(219, 19)" end="(219, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(219, 20)" end="(219, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(219, 21)" end="(219, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(219, 22)" end="(219, 27)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(219, 28)" end="(219, 29)">
                  <IdentNode start="(219, 28)" end="(219, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(219, 30)" end="(219, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(219, 32)" end="(219, 72)" kind="Lean.Parser.Term.app">
                <OtherNode start="(219, 32)" end="(219, 70)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(219, 32)" end="(219, 65)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(219, 32)" end="(219, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(219, 33)" end="(219, 64)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(219, 33)" end="(219, 41)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(219, 42)" end="(219, 64)">
                        <OtherNode start="(219, 42)" end="(219, 64)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(219, 42)" end="(219, 43)" leading="" trailing="" val="("/>
                          <OtherNode start="(219, 43)" end="(219, 63)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(219, 43)" end="(219, 46)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(219, 47)" end="(219, 63)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(219, 47)" end="(219, 48)">
                                <IdentNode start="(219, 47)" end="(219, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(219, 49)" end="(219, 51)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(219, 52)" end="(219, 63)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(219, 52)" end="(219, 61)" kind="Lean.Parser.Term.proj">
                                  <OtherNode start="(219, 52)" end="(219, 57)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(219, 52)" end="(219, 53)" leading="" trailing="" val="("/>
                                    <OtherNode start="(219, 53)" end="(219, 56)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(219, 53)" end="(219, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(219, 55)" end="(219, 56)">
                                        <IdentNode start="(219, 55)" end="(219, 56)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(219, 56)" end="(219, 57)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(219, 57)" end="(219, 58)" leading="" trailing="" val="."/>
                                  <IdentNode start="(219, 58)" end="(219, 61)" leading="" trailing=" " raw_val="any" val="any" full_name="Option.any" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                </OtherNode>
                                <NullNode start="(219, 62)" end="(219, 63)">
                                  <IdentNode start="(219, 62)" end="(219, 63)" leading="" trailing="" raw_val="p" val="p"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(219, 63)" end="(219, 64)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(219, 64)" end="(219, 65)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(219, 65)" end="(219, 66)" leading="" trailing="" val="."/>
                  <IdentNode start="(219, 66)" end="(219, 70)" leading="" trailing=" " raw_val="bind" val="bind" full_name="Option.bind" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(219, 71)" end="(219, 72)">
                  <IdentNode start="(219, 71)" end="(219, 72)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(219, 73)" end="(220, 17)">
          <AtomNode start="(219, 73)" end="(219, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(219, 76)" end="(220, 17)">
            <AtomNode start="(219, 76)" end="(219, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(220, 3)" end="(220, 17)">
              <TacticTacticseq1IndentedNode start="(220, 3)" end="(220, 17)">
                <NullNode start="(220, 3)" end="(220, 17)">
                  <OtherNode start="(220, 3)" end="(220, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : Array α&#10;f : α → Option β&#10;p : β → Bool&#10;⊢ find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;toList✝ : List α&#10;⊢ find? p (filterMap f { toList := toList✝ }) = (find? (fun a =&amp;gt; Option.any p (f a)) { toList := toList✝ }).bind f" tactic="cases xs">
                    <AtomNode start="(220, 3)" end="(220, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(220, 9)" end="(220, 11)">
                      <OtherNode start="(220, 9)" end="(220, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(220, 9)" end="(220, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(220, 11)" end="(220, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(220, 13)" end="(220, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;toList✝ : List α&#10;⊢ find? p (filterMap f { toList := toList✝ }) = (find? (fun a =&amp;gt; Option.any p (f a)) { toList := toList✝ }).bind f" state_after="no goals" tactic="simp">
                    <AtomNode start="(220, 13)" end="(220, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(222, 1)" end="(224, 17)" name="find?_map" full_name="Array.find?_map">
      <CommandDeclmodifiersNode start="(222, 1)" end="(222, 8)">
        <NullNode/>
        <NullNode start="(222, 1)" end="(222, 8)">
          <OtherNode start="(222, 1)" end="(222, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(222, 1)" end="(222, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(222, 3)" end="(222, 7)">
              <OtherNode start="(222, 3)" end="(222, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(222, 3)" end="(222, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(222, 3)" end="(222, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(222, 7)" end="(222, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(222, 9)" end="(224, 17)" name="find?_map" full_name="Array.find?_map" _is_private_decl="False">
        <AtomNode start="(222, 9)" end="(222, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(222, 17)" end="(222, 26)">
          <IdentNode start="(222, 17)" end="(222, 26)" leading="" trailing=" " raw_val="find?_map" val="find?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(222, 27)" end="(223, 50)">
          <NullNode start="(222, 27)" end="(222, 53)">
            <OtherNode start="(222, 27)" end="(222, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(222, 27)" end="(222, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(222, 28)" end="(222, 29)">
                <IdentNode start="(222, 28)" end="(222, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(222, 30)" end="(222, 37)">
                <AtomNode start="(222, 30)" end="(222, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(222, 32)" end="(222, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(222, 32)" end="(222, 33)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(222, 34)" end="(222, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(222, 36)" end="(222, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(222, 37)" end="(222, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(222, 39)" end="(222, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(222, 39)" end="(222, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(222, 40)" end="(222, 42)">
                <IdentNode start="(222, 40)" end="(222, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(222, 43)" end="(222, 52)">
                <AtomNode start="(222, 43)" end="(222, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(222, 45)" end="(222, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(222, 45)" end="(222, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(222, 51)" end="(222, 52)">
                    <IdentNode start="(222, 51)" end="(222, 52)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(222, 52)" end="(222, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(222, 54)" end="(223, 50)">
            <AtomNode start="(222, 54)" end="(222, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(223, 5)" end="(223, 50)" kind="«term_=_»">
              <OtherNode start="(223, 5)" end="(223, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(223, 5)" end="(223, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(223, 11)" end="(223, 23)">
                  <IdentNode start="(223, 11)" end="(223, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(223, 13)" end="(223, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(223, 13)" end="(223, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(223, 14)" end="(223, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(223, 14)" end="(223, 20)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(223, 21)" end="(223, 22)">
                        <IdentNode start="(223, 21)" end="(223, 22)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(223, 22)" end="(223, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(223, 24)" end="(223, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(223, 26)" end="(223, 50)" kind="Lean.Parser.Term.app">
                <OtherNode start="(223, 26)" end="(223, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(223, 26)" end="(223, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(223, 26)" end="(223, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(223, 27)" end="(223, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(223, 27)" end="(223, 35)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(223, 36)" end="(223, 43)">
                        <OtherNode start="(223, 36)" end="(223, 43)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(223, 36)" end="(223, 37)" leading="" trailing="" val="("/>
                          <OtherNode start="(223, 37)" end="(223, 42)" kind="«term_∘_»">
                            <IdentNode start="(223, 37)" end="(223, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                            <AtomNode start="(223, 39)" end="(223, 40)" leading="" trailing=" " val="∘"/>
                            <IdentNode start="(223, 41)" end="(223, 42)" leading="" trailing="" raw_val="f" val="f"/>
                          </OtherNode>
                          <AtomNode start="(223, 42)" end="(223, 43)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(223, 43)" end="(223, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(223, 44)" end="(223, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(223, 45)" end="(223, 48)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(223, 49)" end="(223, 50)">
                  <IdentNode start="(223, 49)" end="(223, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(223, 51)" end="(224, 17)">
          <AtomNode start="(223, 51)" end="(223, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(223, 54)" end="(224, 17)">
            <AtomNode start="(223, 54)" end="(223, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(224, 3)" end="(224, 17)">
              <TacticTacticseq1IndentedNode start="(224, 3)" end="(224, 17)">
                <NullNode start="(224, 3)" end="(224, 17)">
                  <OtherNode start="(224, 3)" end="(224, 11)" kind="Lean.Parser.Tactic.cases" state_before="β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;xs : Array β&#10;⊢ find? p (map f xs) = Option.map f (find? (p ∘ f) xs)" state_after="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;toList✝ : List β&#10;⊢ find? p (map f { toList := toList✝ }) = Option.map f (find? (p ∘ f) { toList := toList✝ })" tactic="cases xs">
                    <AtomNode start="(224, 3)" end="(224, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(224, 9)" end="(224, 11)">
                      <OtherNode start="(224, 9)" end="(224, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(224, 9)" end="(224, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(224, 11)" end="(224, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(224, 13)" end="(224, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;toList✝ : List β&#10;⊢ find? p (map f { toList := toList✝ }) = Option.map f (find? (p ∘ f) { toList := toList✝ })" state_after="no goals" tactic="simp">
                    <AtomNode start="(224, 13)" end="(224, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(226, 1)" end="(230, 7)" name="find?_append" full_name="Array.find?_append">
      <CommandDeclmodifiersNode start="(226, 1)" end="(226, 8)">
        <NullNode/>
        <NullNode start="(226, 1)" end="(226, 8)">
          <OtherNode start="(226, 1)" end="(226, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(226, 1)" end="(226, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(226, 3)" end="(226, 7)">
              <OtherNode start="(226, 3)" end="(226, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(226, 3)" end="(226, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(226, 3)" end="(226, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(226, 7)" end="(226, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(226, 9)" end="(230, 7)" name="find?_append" full_name="Array.find?_append" _is_private_decl="False">
        <AtomNode start="(226, 9)" end="(226, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(226, 17)" end="(226, 29)">
          <IdentNode start="(226, 17)" end="(226, 29)" leading="" trailing=" " raw_val="find?_append" val="find?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(226, 30)" end="(227, 54)">
          <NullNode start="(226, 30)" end="(226, 47)">
            <OtherNode start="(226, 30)" end="(226, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(226, 30)" end="(226, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(226, 31)" end="(226, 36)">
                <IdentNode start="(226, 31)" end="(226, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(226, 34)" end="(226, 36)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(226, 37)" end="(226, 46)">
                <AtomNode start="(226, 37)" end="(226, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(226, 39)" end="(226, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(226, 39)" end="(226, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(226, 45)" end="(226, 46)">
                    <IdentNode start="(226, 45)" end="(226, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(226, 46)" end="(226, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(226, 48)" end="(227, 54)">
            <AtomNode start="(226, 48)" end="(226, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(227, 5)" end="(227, 54)" kind="«term_=_»">
              <OtherNode start="(227, 5)" end="(227, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(227, 5)" end="(227, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(227, 5)" end="(227, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(227, 5)" end="(227, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(227, 6)" end="(227, 14)" kind="«term_++_»">
                      <IdentNode start="(227, 6)" end="(227, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(227, 9)" end="(227, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(227, 12)" end="(227, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(227, 14)" end="(227, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(227, 15)" end="(227, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(227, 16)" end="(227, 21)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(227, 22)" end="(227, 23)">
                  <IdentNode start="(227, 22)" end="(227, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(227, 24)" end="(227, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(227, 26)" end="(227, 54)" kind="Lean.Parser.Term.app">
                <OtherNode start="(227, 26)" end="(227, 41)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(227, 26)" end="(227, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(227, 26)" end="(227, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(227, 27)" end="(227, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(227, 27)" end="(227, 35)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(227, 36)" end="(227, 37)">
                        <IdentNode start="(227, 36)" end="(227, 37)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(227, 37)" end="(227, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(227, 38)" end="(227, 39)" leading="" trailing="" val="."/>
                  <IdentNode start="(227, 39)" end="(227, 41)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(227, 42)" end="(227, 54)">
                  <OtherNode start="(227, 42)" end="(227, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(227, 42)" end="(227, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(227, 43)" end="(227, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(227, 43)" end="(227, 51)" leading="" trailing=" " raw_val="ys.find?" val="ys.find?"/>
                      <NullNode start="(227, 52)" end="(227, 53)">
                        <IdentNode start="(227, 52)" end="(227, 53)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(227, 53)" end="(227, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(227, 55)" end="(230, 7)">
          <AtomNode start="(227, 55)" end="(227, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(227, 58)" end="(230, 7)">
            <AtomNode start="(227, 58)" end="(227, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(228, 3)" end="(230, 7)">
              <TacticTacticseq1IndentedNode start="(228, 3)" end="(230, 7)">
                <NullNode start="(228, 3)" end="(230, 7)">
                  <OtherNode start="(228, 3)" end="(228, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;⊢ find? p (xs ++ ys) = (find? p xs).or (find? p ys)" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;toList✝ : List α&#10;⊢ find? p ({ toList := toList✝ } ++ ys) = (find? p { toList := toList✝ }).or (find? p ys)" tactic="cases xs">
                    <AtomNode start="(228, 3)" end="(228, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(228, 9)" end="(228, 11)">
                      <OtherNode start="(228, 9)" end="(228, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(228, 9)" end="(228, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(229, 3)" end="(229, 11)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;toList✝ : List α&#10;⊢ find? p ({ toList := toList✝ } ++ ys) = (find? p { toList := toList✝ }).or (find? p ys)" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝¹ toList✝ : List α&#10;⊢ find? p ({ toList := toList✝¹ } ++ { toList := toList✝ }) =&#10;    (find? p { toList := toList✝¹ }).or (find? p { toList := toList✝ })" tactic="cases ys">
                    <AtomNode start="(229, 3)" end="(229, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(229, 9)" end="(229, 11)">
                      <OtherNode start="(229, 9)" end="(229, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(229, 9)" end="(229, 11)" leading="" trailing="&#10;  " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(230, 3)" end="(230, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝¹ toList✝ : List α&#10;⊢ find? p ({ toList := toList✝¹ } ++ { toList := toList✝ }) =&#10;    (find? p { toList := toList✝¹ }).or (find? p { toList := toList✝ })" state_after="no goals" tactic="simp">
                    <AtomNode start="(230, 3)" end="(230, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(232, 1)" end="(235, 47)" name="find?_flatten" full_name="Array.find?_flatten">
      <CommandDeclmodifiersNode start="(232, 1)" end="(232, 8)">
        <NullNode/>
        <NullNode start="(232, 1)" end="(232, 8)">
          <OtherNode start="(232, 1)" end="(232, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(232, 1)" end="(232, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(232, 3)" end="(232, 7)">
              <OtherNode start="(232, 3)" end="(232, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(232, 3)" end="(232, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(232, 3)" end="(232, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(232, 7)" end="(232, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(232, 9)" end="(235, 47)" name="find?_flatten" full_name="Array.find?_flatten" _is_private_decl="False">
        <AtomNode start="(232, 9)" end="(232, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(232, 17)" end="(232, 30)">
          <IdentNode start="(232, 17)" end="(232, 30)" leading="" trailing=" " raw_val="find?_flatten" val="find?_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(232, 31)" end="(233, 52)">
          <NullNode start="(232, 31)" end="(232, 69)">
            <OtherNode start="(232, 31)" end="(232, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 31)" end="(232, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 32)" end="(232, 35)">
                <IdentNode start="(232, 32)" end="(232, 35)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(232, 36)" end="(232, 53)">
                <AtomNode start="(232, 36)" end="(232, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 38)" end="(232, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(232, 38)" end="(232, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(232, 44)" end="(232, 53)">
                    <OtherNode start="(232, 44)" end="(232, 53)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(232, 44)" end="(232, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(232, 45)" end="(232, 52)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(232, 45)" end="(232, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(232, 51)" end="(232, 52)">
                          <IdentNode start="(232, 51)" end="(232, 52)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(232, 52)" end="(232, 53)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 53)" end="(232, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(232, 55)" end="(232, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 55)" end="(232, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 56)" end="(232, 57)">
                <IdentNode start="(232, 56)" end="(232, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(232, 58)" end="(232, 68)">
                <AtomNode start="(232, 58)" end="(232, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 60)" end="(232, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(232, 60)" end="(232, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(232, 62)" end="(232, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(232, 64)" end="(232, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 68)" end="(232, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(232, 70)" end="(233, 52)">
            <AtomNode start="(232, 70)" end="(232, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(233, 5)" end="(233, 52)" kind="«term_=_»">
              <OtherNode start="(233, 5)" end="(233, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(233, 5)" end="(233, 22)" leading="" trailing=" " raw_val="xss.flatten.find?" val="xss.flatten.find?"/>
                <NullNode start="(233, 23)" end="(233, 24)">
                  <IdentNode start="(233, 23)" end="(233, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(233, 25)" end="(233, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(233, 27)" end="(233, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(233, 27)" end="(233, 40)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                <NullNode start="(233, 41)" end="(233, 52)">
                  <OtherNode start="(233, 41)" end="(233, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(233, 41)" end="(233, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(233, 42)" end="(233, 51)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(233, 42)" end="(233, 49)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(233, 42)" end="(233, 43)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(233, 42)" end="(233, 43)" leading="" trailing="" val="·"/>
                        </OtherNode>
                        <AtomNode start="(233, 43)" end="(233, 44)" leading="" trailing="" val="."/>
                        <IdentNode start="(233, 44)" end="(233, 49)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      </OtherNode>
                      <NullNode start="(233, 50)" end="(233, 51)">
                        <IdentNode start="(233, 50)" end="(233, 51)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(233, 51)" end="(233, 52)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(233, 53)" end="(235, 47)">
          <AtomNode start="(233, 53)" end="(233, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(233, 56)" end="(235, 47)">
            <AtomNode start="(233, 56)" end="(233, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(234, 3)" end="(235, 47)">
              <TacticTacticseq1IndentedNode start="(234, 3)" end="(235, 47)">
                <NullNode start="(234, 3)" end="(235, 47)">
                  <OtherNode start="(234, 3)" end="(234, 35)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;p : α → Bool&#10;⊢ find? p xss.flatten = findSome? (fun x =&amp;gt; find? p x) xss" state_after="case of&#10;α : Type u_1&#10;p : α → Bool&#10;xss✝ : List (List α)&#10;⊢ find? p (List.map List.toArray xss✝).toArray.flatten =&#10;    findSome? (fun x =&amp;gt; find? p x) (List.map List.toArray xss✝).toArray" tactic="cases xss using array₂_induction">
                    <AtomNode start="(234, 3)" end="(234, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(234, 9)" end="(234, 12)">
                      <OtherNode start="(234, 9)" end="(234, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(234, 9)" end="(234, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(234, 13)" end="(234, 35)">
                      <AtomNode start="(234, 13)" end="(234, 18)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(234, 19)" end="(234, 35)" leading="" trailing="&#10;  " raw_val="array₂_induction" val="array₂_induction" full_name="Array.array₂_induction" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(235, 3)" end="(235, 47)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;p : α → Bool&#10;xss✝ : List (List α)&#10;⊢ find? p (List.map List.toArray xss✝).toArray.flatten =&#10;    findSome? (fun x =&amp;gt; find? p x) (List.map List.toArray xss✝).toArray" state_after="no goals" tactic="simp [List.findSome?_map, Function.comp_def]">
                    <AtomNode start="(235, 3)" end="(235, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(235, 8)" end="(235, 47)">
                      <AtomNode start="(235, 8)" end="(235, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(235, 9)" end="(235, 46)">
                        <OtherNode start="(235, 9)" end="(235, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(235, 9)" end="(235, 27)" leading="" trailing="" raw_val="List.findSome?_map" val="List.findSome?_map" full_name="List.findSome?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(235, 27)" end="(235, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(235, 29)" end="(235, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(235, 29)" end="(235, 46)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(235, 46)" end="(235, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(237, 1)" end="(239, 7)" name="find?_flatten_eq_none_iff" full_name="Array.find?_flatten_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(237, 1)" end="(239, 7)" name="find?_flatten_eq_none_iff" full_name="Array.find?_flatten_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(237, 1)" end="(237, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(237, 9)" end="(237, 34)">
          <IdentNode start="(237, 9)" end="(237, 34)" leading="" trailing=" " raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(237, 35)" end="(238, 60)">
          <NullNode start="(237, 35)" end="(237, 73)">
            <OtherNode start="(237, 35)" end="(237, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(237, 35)" end="(237, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(237, 36)" end="(237, 39)">
                <IdentNode start="(237, 36)" end="(237, 39)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(237, 40)" end="(237, 57)">
                <AtomNode start="(237, 40)" end="(237, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(237, 42)" end="(237, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(237, 42)" end="(237, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(237, 48)" end="(237, 57)">
                    <OtherNode start="(237, 48)" end="(237, 57)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(237, 48)" end="(237, 49)" leading="" trailing="" val="("/>
                      <OtherNode start="(237, 49)" end="(237, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(237, 49)" end="(237, 54)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(237, 55)" end="(237, 56)">
                          <IdentNode start="(237, 55)" end="(237, 56)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(237, 56)" end="(237, 57)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(237, 57)" end="(237, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(237, 59)" end="(237, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(237, 59)" end="(237, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(237, 60)" end="(237, 61)">
                <IdentNode start="(237, 60)" end="(237, 61)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(237, 62)" end="(237, 72)">
                <AtomNode start="(237, 62)" end="(237, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(237, 64)" end="(237, 72)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(237, 64)" end="(237, 65)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(237, 66)" end="(237, 67)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(237, 68)" end="(237, 72)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(237, 72)" end="(237, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(237, 74)" end="(238, 60)">
            <AtomNode start="(237, 74)" end="(237, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(238, 5)" end="(238, 60)" kind="«term_↔_»">
              <OtherNode start="(238, 5)" end="(238, 31)" kind="«term_=_»">
                <OtherNode start="(238, 5)" end="(238, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(238, 5)" end="(238, 22)" leading="" trailing=" " raw_val="xss.flatten.find?" val="xss.flatten.find?"/>
                  <NullNode start="(238, 23)" end="(238, 24)">
                    <IdentNode start="(238, 23)" end="(238, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(238, 25)" end="(238, 26)" leading="" trailing=" " val="="/>
                <IdentNode start="(238, 27)" end="(238, 31)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(238, 32)" end="(238, 33)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(238, 34)" end="(238, 60)" kind="Lean.«term∀__,_»">
                <AtomNode start="(238, 34)" end="(238, 35)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(238, 36)" end="(238, 38)">
                  <IdentNode start="(238, 36)" end="(238, 38)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </LeanBinderidentNode>
                <OtherNode start="(238, 39)" end="(238, 44)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(238, 39)" end="(238, 40)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(238, 41)" end="(238, 44)" leading="" trailing="" raw_val="xss" val="xss"/>
                </OtherNode>
                <AtomNode start="(238, 44)" end="(238, 45)" leading="" trailing=" " val=","/>
                <OtherNode start="(238, 46)" end="(238, 60)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(238, 46)" end="(238, 47)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(238, 48)" end="(238, 49)">
                    <IdentNode start="(238, 48)" end="(238, 49)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(238, 50)" end="(238, 54)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(238, 50)" end="(238, 51)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(238, 52)" end="(238, 54)" leading="" trailing="" raw_val="ys" val="ys"/>
                  </OtherNode>
                  <AtomNode start="(238, 54)" end="(238, 55)" leading="" trailing=" " val=","/>
                  <OtherNode start="(238, 56)" end="(238, 60)" kind="term!_">
                    <AtomNode start="(238, 56)" end="(238, 57)" leading="" trailing="" val="!"/>
                    <OtherNode start="(238, 57)" end="(238, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(238, 57)" end="(238, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(238, 59)" end="(238, 60)">
                        <IdentNode start="(238, 59)" end="(238, 60)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(238, 61)" end="(239, 7)">
          <AtomNode start="(238, 61)" end="(238, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(238, 64)" end="(239, 7)">
            <AtomNode start="(238, 64)" end="(238, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(239, 3)" end="(239, 7)">
              <TacticTacticseq1IndentedNode start="(239, 3)" end="(239, 7)">
                <NullNode start="(239, 3)" end="(239, 7)">
                  <OtherNode start="(239, 3)" end="(239, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;p : α → Bool&#10;⊢ find? p xss.flatten = none ↔ ∀ (ys : Array α), ys ∈ xss → ∀ (x : α), x ∈ ys → (!p x) = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(239, 3)" end="(239, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(241, 1)" end="(242, 59)" name="find?_flatten_eq_none" full_name="Array.find?_flatten_eq_none">
      <CommandDeclmodifiersNode start="(241, 1)" end="(241, 64)">
        <NullNode/>
        <NullNode start="(241, 1)" end="(241, 64)">
          <OtherNode start="(241, 1)" end="(241, 64)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(241, 1)" end="(241, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(241, 3)" end="(241, 63)">
              <OtherNode start="(241, 3)" end="(241, 63)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(241, 3)" end="(241, 63)" kind="Lean.deprecated">
                  <AtomNode start="(241, 3)" end="(241, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(241, 14)" end="(241, 39)">
                    <IdentNode start="(241, 14)" end="(241, 39)" leading="" trailing=" " raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff" full_name="Array.find?_flatten_eq_none_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(237, 9)" def_end="(237, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(241, 40)" end="(241, 63)">
                    <AtomNode start="(241, 40)" end="(241, 41)" leading="" trailing="" val="("/>
                    <AtomNode start="(241, 41)" end="(241, 46)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(241, 47)" end="(241, 49)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(241, 50)" end="(241, 62)" kind="str">
                      <AtomNode start="(241, 50)" end="(241, 62)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(241, 62)" end="(241, 63)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(241, 63)" end="(241, 64)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(242, 1)" end="(242, 59)" name="find?_flatten_eq_none">
        <AtomNode start="(242, 1)" end="(242, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(242, 8)" end="(242, 29)">
          <IdentNode start="(242, 8)" end="(242, 29)" leading="" trailing=" " raw_val="find?_flatten_eq_none" val="find?_flatten_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(242, 30)" end="(242, 59)">
          <AtomNode start="(242, 30)" end="(242, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(242, 33)" end="(242, 59)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(242, 33)" end="(242, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(242, 34)" end="(242, 59)" leading="" trailing="&#10;&#10;" raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff" full_name="Array.find?_flatten_eq_none_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(237, 9)" def_end="(237, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(244, 1)" end="(267, 46)" name="find?_flatten_eq_some_iff" full_name="Array.find?_flatten_eq_some_iff">
      <CommandDeclmodifiersNode start="(244, 1)" end="(248, 3)">
        <NullNode start="(244, 1)" end="(248, 3)">
          <CommandDoccommentNode start="(244, 1)" end="(248, 3)" comment="If `find? p` returns `some a` from `xs.flatten`, then `p a` holds, and&#10;some array in `xs` contains `a`, and no earlier element of that array satisfies `p`.&#10;Moreover, no earlier array in `xs` has an element satisfying `p`.&#10;-/">
            <AtomNode start="(244, 1)" end="(244, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(245, 1)" end="(248, 3)" leading="" trailing="&#10;" val="If `find? p` returns `some a` from `xs.flatten`, then `p a` holds, and&#10;some array in `xs` contains `a`, and no earlier element of that array satisfies `p`.&#10;Moreover, no earlier array in `xs` has an element satisfying `p`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(249, 1)" end="(267, 46)" name="find?_flatten_eq_some_iff" full_name="Array.find?_flatten_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(249, 1)" end="(249, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(249, 9)" end="(249, 34)">
          <IdentNode start="(249, 9)" end="(249, 34)" leading="" trailing=" " raw_val="find?_flatten_eq_some_iff" val="find?_flatten_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(249, 35)" end="(253, 55)">
          <NullNode start="(249, 35)" end="(249, 81)">
            <OtherNode start="(249, 35)" end="(249, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(249, 35)" end="(249, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(249, 36)" end="(249, 39)">
                <IdentNode start="(249, 36)" end="(249, 39)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(249, 40)" end="(249, 57)">
                <AtomNode start="(249, 40)" end="(249, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(249, 42)" end="(249, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(249, 42)" end="(249, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(249, 48)" end="(249, 57)">
                    <OtherNode start="(249, 48)" end="(249, 57)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(249, 48)" end="(249, 49)" leading="" trailing="" val="("/>
                      <OtherNode start="(249, 49)" end="(249, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(249, 49)" end="(249, 54)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(249, 55)" end="(249, 56)">
                          <IdentNode start="(249, 55)" end="(249, 56)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(249, 56)" end="(249, 57)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(249, 57)" end="(249, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(249, 59)" end="(249, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(249, 59)" end="(249, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(249, 60)" end="(249, 61)">
                <IdentNode start="(249, 60)" end="(249, 61)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(249, 62)" end="(249, 72)">
                <AtomNode start="(249, 62)" end="(249, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(249, 64)" end="(249, 72)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(249, 64)" end="(249, 65)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(249, 66)" end="(249, 67)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(249, 68)" end="(249, 72)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(249, 72)" end="(249, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(249, 74)" end="(249, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(249, 74)" end="(249, 75)" leading="" trailing="" val="{"/>
              <NullNode start="(249, 75)" end="(249, 76)">
                <IdentNode start="(249, 75)" end="(249, 76)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(249, 77)" end="(249, 80)">
                <AtomNode start="(249, 77)" end="(249, 78)" leading="" trailing=" " val=":"/>
                <IdentNode start="(249, 79)" end="(249, 80)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(249, 80)" end="(249, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(249, 82)" end="(253, 55)">
            <AtomNode start="(249, 82)" end="(249, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(250, 5)" end="(253, 55)" kind="«term_↔_»">
              <OtherNode start="(250, 5)" end="(250, 33)" kind="«term_=_»">
                <OtherNode start="(250, 5)" end="(250, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(250, 5)" end="(250, 22)" leading="" trailing=" " raw_val="xss.flatten.find?" val="xss.flatten.find?"/>
                  <NullNode start="(250, 23)" end="(250, 24)">
                    <IdentNode start="(250, 23)" end="(250, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(250, 25)" end="(250, 26)" leading="" trailing=" " val="="/>
                <OtherNode start="(250, 27)" end="(250, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(250, 27)" end="(250, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(250, 32)" end="(250, 33)">
                    <IdentNode start="(250, 32)" end="(250, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(250, 34)" end="(250, 35)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(251, 7)" end="(253, 55)" kind="«term_∧_»">
                <OtherNode start="(251, 7)" end="(251, 10)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(251, 7)" end="(251, 8)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(251, 9)" end="(251, 10)">
                    <IdentNode start="(251, 9)" end="(251, 10)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(251, 11)" end="(251, 12)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(251, 13)" end="(253, 55)" kind="«term∃_,_»">
                  <AtomNode start="(251, 13)" end="(251, 14)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(251, 15)" end="(251, 78)" kind="Lean.explicitBinders">
                    <NullNode start="(251, 15)" end="(251, 78)">
                      <OtherNode start="(251, 15)" end="(251, 37)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(251, 15)" end="(251, 16)" leading="" trailing="" val="("/>
                        <NullNode start="(251, 16)" end="(251, 18)">
                          <LeanBinderidentNode start="(251, 16)" end="(251, 18)">
                            <IdentNode start="(251, 16)" end="(251, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(251, 19)" end="(251, 20)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(251, 21)" end="(251, 36)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(251, 21)" end="(251, 26)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(251, 27)" end="(251, 36)">
                            <OtherNode start="(251, 27)" end="(251, 36)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(251, 27)" end="(251, 28)" leading="" trailing="" val="("/>
                              <OtherNode start="(251, 28)" end="(251, 35)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(251, 28)" end="(251, 33)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(251, 34)" end="(251, 35)">
                                  <IdentNode start="(251, 34)" end="(251, 35)" leading="" trailing="" raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(251, 35)" end="(251, 36)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(251, 36)" end="(251, 37)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(251, 38)" end="(251, 55)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(251, 38)" end="(251, 39)" leading="" trailing="" val="("/>
                        <NullNode start="(251, 39)" end="(251, 44)">
                          <LeanBinderidentNode start="(251, 39)" end="(251, 41)">
                            <IdentNode start="(251, 39)" end="(251, 41)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          </LeanBinderidentNode>
                          <LeanBinderidentNode start="(251, 42)" end="(251, 44)">
                            <IdentNode start="(251, 42)" end="(251, 44)" leading="" trailing=" " raw_val="zs" val="zs"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(251, 45)" end="(251, 46)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(251, 47)" end="(251, 54)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(251, 47)" end="(251, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(251, 53)" end="(251, 54)">
                            <IdentNode start="(251, 53)" end="(251, 54)" leading="" trailing="" raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(251, 54)" end="(251, 55)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(251, 56)" end="(251, 78)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(251, 56)" end="(251, 57)" leading="" trailing="" val="("/>
                        <NullNode start="(251, 57)" end="(251, 59)">
                          <LeanBinderidentNode start="(251, 57)" end="(251, 59)">
                            <IdentNode start="(251, 57)" end="(251, 59)" leading="" trailing=" " raw_val="bs" val="bs"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(251, 60)" end="(251, 61)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(251, 62)" end="(251, 77)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(251, 62)" end="(251, 67)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(251, 68)" end="(251, 77)">
                            <OtherNode start="(251, 68)" end="(251, 77)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(251, 68)" end="(251, 69)" leading="" trailing="" val="("/>
                              <OtherNode start="(251, 69)" end="(251, 76)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(251, 69)" end="(251, 74)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(251, 75)" end="(251, 76)">
                                  <IdentNode start="(251, 75)" end="(251, 76)" leading="" trailing="" raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(251, 76)" end="(251, 77)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(251, 77)" end="(251, 78)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(251, 78)" end="(251, 79)" leading="" trailing="&#10;        " val=","/>
                  <OtherNode start="(252, 9)" end="(253, 55)" kind="«term_∧_»">
                    <OtherNode start="(252, 9)" end="(252, 46)" kind="«term_=_»">
                      <IdentNode start="(252, 9)" end="(252, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      <AtomNode start="(252, 13)" end="(252, 14)" leading="" trailing=" " val="="/>
                      <OtherNode start="(252, 15)" end="(252, 46)" kind="«term_++_»">
                        <OtherNode start="(252, 15)" end="(252, 40)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(252, 15)" end="(252, 22)" leading="" trailing=" " raw_val="as.push" val="as.push"/>
                          <NullNode start="(252, 23)" end="(252, 40)">
                            <OtherNode start="(252, 23)" end="(252, 40)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(252, 23)" end="(252, 24)" leading="" trailing="" val="("/>
                              <OtherNode start="(252, 24)" end="(252, 39)" kind="«term_++_»">
                                <OtherNode start="(252, 24)" end="(252, 33)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(252, 24)" end="(252, 31)" leading="" trailing=" " raw_val="ys.push" val="ys.push"/>
                                  <NullNode start="(252, 32)" end="(252, 33)">
                                    <IdentNode start="(252, 32)" end="(252, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(252, 34)" end="(252, 36)" leading="" trailing=" " val="++"/>
                                <IdentNode start="(252, 37)" end="(252, 39)" leading="" trailing="" raw_val="zs" val="zs"/>
                              </OtherNode>
                              <AtomNode start="(252, 39)" end="(252, 40)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(252, 41)" end="(252, 43)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(252, 44)" end="(252, 46)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(252, 47)" end="(252, 48)" leading="" trailing="&#10;        " val="∧"/>
                    <OtherNode start="(253, 9)" end="(253, 55)" kind="«term_∧_»">
                      <OtherNode start="(253, 9)" end="(253, 36)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(253, 9)" end="(253, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(253, 10)" end="(253, 35)" kind="Lean.«term∀__,_»">
                          <AtomNode start="(253, 10)" end="(253, 11)" leading="" trailing=" " val="∀"/>
                          <LeanBinderidentNode start="(253, 12)" end="(253, 14)">
                            <IdentNode start="(253, 12)" end="(253, 14)" leading="" trailing=" " raw_val="ws" val="ws"/>
                          </LeanBinderidentNode>
                          <OtherNode start="(253, 15)" end="(253, 19)" kind="Lean.«binderTerm∈_»">
                            <AtomNode start="(253, 15)" end="(253, 16)" leading="" trailing=" " val="∈"/>
                            <IdentNode start="(253, 17)" end="(253, 19)" leading="" trailing="" raw_val="as" val="as"/>
                          </OtherNode>
                          <AtomNode start="(253, 19)" end="(253, 20)" leading="" trailing=" " val=","/>
                          <OtherNode start="(253, 21)" end="(253, 35)" kind="Lean.«term∀__,_»">
                            <AtomNode start="(253, 21)" end="(253, 22)" leading="" trailing=" " val="∀"/>
                            <LeanBinderidentNode start="(253, 23)" end="(253, 24)">
                              <IdentNode start="(253, 23)" end="(253, 24)" leading="" trailing=" " raw_val="x" val="x"/>
                            </LeanBinderidentNode>
                            <OtherNode start="(253, 25)" end="(253, 29)" kind="Lean.«binderTerm∈_»">
                              <AtomNode start="(253, 25)" end="(253, 26)" leading="" trailing=" " val="∈"/>
                              <IdentNode start="(253, 27)" end="(253, 29)" leading="" trailing="" raw_val="ws" val="ws"/>
                            </OtherNode>
                            <AtomNode start="(253, 29)" end="(253, 30)" leading="" trailing=" " val=","/>
                            <OtherNode start="(253, 31)" end="(253, 35)" kind="term!_">
                              <AtomNode start="(253, 31)" end="(253, 32)" leading="" trailing="" val="!"/>
                              <OtherNode start="(253, 32)" end="(253, 35)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(253, 32)" end="(253, 33)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(253, 34)" end="(253, 35)">
                                  <IdentNode start="(253, 34)" end="(253, 35)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(253, 35)" end="(253, 36)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(253, 37)" end="(253, 38)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(253, 39)" end="(253, 55)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(253, 39)" end="(253, 40)" leading="" trailing="" val="("/>
                        <OtherNode start="(253, 40)" end="(253, 54)" kind="Lean.«term∀__,_»">
                          <AtomNode start="(253, 40)" end="(253, 41)" leading="" trailing=" " val="∀"/>
                          <LeanBinderidentNode start="(253, 42)" end="(253, 43)">
                            <IdentNode start="(253, 42)" end="(253, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                          </LeanBinderidentNode>
                          <OtherNode start="(253, 44)" end="(253, 48)" kind="Lean.«binderTerm∈_»">
                            <AtomNode start="(253, 44)" end="(253, 45)" leading="" trailing=" " val="∈"/>
                            <IdentNode start="(253, 46)" end="(253, 48)" leading="" trailing="" raw_val="ys" val="ys"/>
                          </OtherNode>
                          <AtomNode start="(253, 48)" end="(253, 49)" leading="" trailing=" " val=","/>
                          <OtherNode start="(253, 50)" end="(253, 54)" kind="term!_">
                            <AtomNode start="(253, 50)" end="(253, 51)" leading="" trailing="" val="!"/>
                            <OtherNode start="(253, 51)" end="(253, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(253, 51)" end="(253, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(253, 53)" end="(253, 54)">
                                <IdentNode start="(253, 53)" end="(253, 54)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(253, 54)" end="(253, 55)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(253, 56)" end="(267, 46)">
          <AtomNode start="(253, 56)" end="(253, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(253, 59)" end="(267, 46)">
            <AtomNode start="(253, 59)" end="(253, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(254, 3)" end="(267, 46)">
              <TacticTacticseq1IndentedNode start="(254, 3)" end="(267, 46)">
                <NullNode start="(254, 3)" end="(267, 46)">
                  <OtherNode start="(254, 3)" end="(254, 35)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;p : α → Bool&#10;a : α&#10;⊢ find? p xss.flatten = some a ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xss = as.push (ys.push a ++ zs) ++ bs ∧&#10;          (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;⊢ find? p (List.map List.toArray xss✝).toArray.flatten = some a ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ zs) ++ bs ∧&#10;          (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="cases xss using array₂_induction">
                    <AtomNode start="(254, 3)" end="(254, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(254, 9)" end="(254, 12)">
                      <OtherNode start="(254, 9)" end="(254, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(254, 9)" end="(254, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(254, 13)" end="(254, 35)">
                      <AtomNode start="(254, 13)" end="(254, 18)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(254, 19)" end="(254, 35)" leading="" trailing="&#10;  " raw_val="array₂_induction" val="array₂_induction" full_name="Array.array₂_induction" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(255, 3)" end="(255, 94)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;⊢ find? p (List.map List.toArray xss✝).toArray.flatten = some a ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ zs) ++ bs ∧&#10;          (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;⊢ (p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xss✝ = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true) ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ zs) ++ bs ∧&#10;          (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="simp only [flatten_toArray_map_toArray, List.find?_toArray, List.find?_flatten_eq_some_iff]">
                    <AtomNode start="(255, 3)" end="(255, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(255, 8)" end="(255, 12)">
                      <AtomNode start="(255, 8)" end="(255, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(255, 13)" end="(255, 94)">
                      <AtomNode start="(255, 13)" end="(255, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(255, 14)" end="(255, 93)">
                        <OtherNode start="(255, 14)" end="(255, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(255, 14)" end="(255, 41)" leading="" trailing="" raw_val="flatten_toArray_map_toArray" val="flatten_toArray_map_toArray" full_name="Array.flatten_toArray_map_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(255, 41)" end="(255, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(255, 43)" end="(255, 61)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(255, 43)" end="(255, 61)" leading="" trailing="" raw_val="List.find?_toArray" val="List.find?_toArray" full_name="List.find?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(255, 61)" end="(255, 62)" leading="" trailing=" " val=","/>
                        <OtherNode start="(255, 63)" end="(255, 93)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(255, 63)" end="(255, 93)" leading="" trailing="" raw_val="List.find?_flatten_eq_some_iff" val="List.find?_flatten_eq_some_iff" full_name="List.find?_flatten_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(255, 93)" end="(255, 94)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(256, 3)" end="(256, 90)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;⊢ (p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xss✝ = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true) ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ zs) ++ bs ∧&#10;          (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;⊢ p a = true →&#10;    ((∃ as ys,&#10;        (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) ↔&#10;      ∃ as ys,&#10;        (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;          (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false)" tactic="simp only [Bool.not_eq_eq_eq_not, Bool.not_true, exists_and_right, and_congr_right_iff]">
                    <AtomNode start="(256, 3)" end="(256, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(256, 8)" end="(256, 12)">
                      <AtomNode start="(256, 8)" end="(256, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(256, 13)" end="(256, 90)">
                      <AtomNode start="(256, 13)" end="(256, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(256, 14)" end="(256, 89)">
                        <OtherNode start="(256, 14)" end="(256, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(256, 14)" end="(256, 35)" leading="" trailing="" raw_val="Bool.not_eq_eq_eq_not" val="Bool.not_eq_eq_eq_not" full_name="Bool.not_eq_eq_eq_not" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(256, 35)" end="(256, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(256, 37)" end="(256, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(256, 37)" end="(256, 50)" leading="" trailing="" raw_val="Bool.not_true" val="Bool.not_true" full_name="Bool.not_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(256, 50)" end="(256, 51)" leading="" trailing=" " val=","/>
                        <OtherNode start="(256, 52)" end="(256, 68)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(256, 52)" end="(256, 68)" leading="" trailing="" raw_val="exists_and_right" val="exists_and_right" full_name="exists_and_right" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(256, 68)" end="(256, 69)" leading="" trailing=" " val=","/>
                        <OtherNode start="(256, 70)" end="(256, 89)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(256, 70)" end="(256, 89)" leading="" trailing="" raw_val="and_congr_right_iff" val="and_congr_right_iff" full_name="and_congr_right_iff" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(256, 89)" end="(256, 90)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(257, 3)" end="(257, 10)" kind="Lean.Parser.Tactic.intro" state_before="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;⊢ p a = true →&#10;    ((∃ as ys,&#10;        (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) ↔&#10;      ∃ as ys,&#10;        (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;          (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false)" state_after="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) ↔&#10;    ∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" tactic="intro w">
                    <AtomNode start="(257, 3)" end="(257, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(257, 9)" end="(257, 10)">
                      <IdentNode start="(257, 9)" end="(257, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(258, 3)" end="(258, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case of&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) ↔&#10;    ∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="case of.mp&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false&#10;&#10;case of.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" tactic="constructor">
                    <AtomNode start="(258, 3)" end="(258, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(259, 3)" end="(261, 96)" kind="Lean.cdot" state_before="case of.mp&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false&#10;&#10;case of.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="case of.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" tactic="· rintro ⟨as, ys, ⟨⟨zs, bs, rfl⟩, h₁, h₂⟩⟩&#10;  exact ⟨as.toArray.map List.toArray, ys.toArray,&#10;    ⟨zs.toArray, bs.toArray.map List.toArray, by simp⟩, by simpa using h₁, by simpa using h₂⟩">
                    <OtherNode start="(259, 3)" end="(259, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(259, 3)" end="(259, 4)" kind="patternIgnore">
                        <OtherNode start="(259, 3)" end="(259, 4)" kind="token.«· »">
                          <AtomNode start="(259, 3)" end="(259, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(259, 5)" end="(261, 96)">
                      <TacticTacticseq1IndentedNode start="(259, 5)" end="(261, 96)">
                        <NullNode start="(259, 5)" end="(261, 96)">
                          <OtherNode start="(259, 5)" end="(259, 45)" kind="Lean.Parser.Tactic.rintro" state_before="case of.mp&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="case of.mp.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;w : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;⊢ ∃ as_1 ys_1,&#10;    (∃ x x_1, (List.map List.toArray (as ++ (ys ++ a :: zs) :: bs)).toArray = as_1.push (ys_1.push a ++ x) ++ x_1) ∧&#10;      (∀ (ws : Array α), ws ∈ as_1 → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys_1 → p x = false" tactic="rintro ⟨as, ys, ⟨⟨zs, bs, rfl⟩, h₁, h₂⟩⟩">
                            <AtomNode start="(259, 5)" end="(259, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(259, 12)" end="(259, 45)">
                              <OtherNode start="(259, 12)" end="(259, 45)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(259, 12)" end="(259, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(259, 12)" end="(259, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(259, 13)" end="(259, 44)">
                                    <OtherNode start="(259, 13)" end="(259, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(259, 13)" end="(259, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(259, 13)" end="(259, 15)">
                                          <OtherNode start="(259, 13)" end="(259, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(259, 13)" end="(259, 15)" leading="" trailing="" raw_val="as" val="as"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(259, 15)" end="(259, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(259, 17)" end="(259, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(259, 17)" end="(259, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(259, 17)" end="(259, 19)">
                                          <OtherNode start="(259, 17)" end="(259, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(259, 17)" end="(259, 19)" leading="" trailing="" raw_val="ys" val="ys"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(259, 19)" end="(259, 20)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(259, 21)" end="(259, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(259, 21)" end="(259, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(259, 21)" end="(259, 44)">
                                          <OtherNode start="(259, 21)" end="(259, 44)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(259, 21)" end="(259, 22)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(259, 22)" end="(259, 43)">
                                              <OtherNode start="(259, 22)" end="(259, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(259, 22)" end="(259, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(259, 22)" end="(259, 35)">
                                                    <OtherNode start="(259, 22)" end="(259, 35)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(259, 22)" end="(259, 23)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(259, 23)" end="(259, 34)">
                                                        <OtherNode start="(259, 23)" end="(259, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(259, 23)" end="(259, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(259, 23)" end="(259, 25)">
                                                            <OtherNode start="(259, 23)" end="(259, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(259, 23)" end="(259, 25)" leading="" trailing="" raw_val="zs" val="zs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(259, 25)" end="(259, 26)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(259, 27)" end="(259, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(259, 27)" end="(259, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(259, 27)" end="(259, 29)">
                                                            <OtherNode start="(259, 27)" end="(259, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(259, 27)" end="(259, 29)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(259, 29)" end="(259, 30)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(259, 31)" end="(259, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(259, 31)" end="(259, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(259, 31)" end="(259, 34)">
                                                            <OtherNode start="(259, 31)" end="(259, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(259, 31)" end="(259, 34)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(259, 34)" end="(259, 35)" leading="" trailing="" val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(259, 35)" end="(259, 36)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(259, 37)" end="(259, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(259, 37)" end="(259, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(259, 37)" end="(259, 39)">
                                                    <OtherNode start="(259, 37)" end="(259, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(259, 37)" end="(259, 39)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(259, 39)" end="(259, 40)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(259, 41)" end="(259, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(259, 41)" end="(259, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(259, 41)" end="(259, 43)">
                                                    <OtherNode start="(259, 41)" end="(259, 43)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(259, 41)" end="(259, 43)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(259, 43)" end="(259, 44)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(259, 44)" end="(259, 45)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(260, 5)" end="(261, 96)" kind="Lean.Parser.Tactic.exact" state_before="case of.mp.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;w : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;⊢ ∃ as_1 ys_1,&#10;    (∃ x x_1, (List.map List.toArray (as ++ (ys ++ a :: zs) :: bs)).toArray = as_1.push (ys_1.push a ++ x) ++ x_1) ∧&#10;      (∀ (ws : Array α), ws ∈ as_1 → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys_1 → p x = false" state_after="no goals" tactic="exact ⟨as.toArray.map List.toArray, ys.toArray,&#10;  ⟨zs.toArray, bs.toArray.map List.toArray, by simp⟩, by simpa using h₁, by simpa using h₂⟩">
                            <AtomNode start="(260, 5)" end="(260, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(260, 11)" end="(261, 96)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(260, 11)" end="(260, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(260, 12)" end="(261, 95)">
                                <OtherNode start="(260, 12)" end="(260, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(260, 12)" end="(260, 26)" leading="" trailing=" " raw_val="as.toArray.map" val="as.toArray.map"/>
                                  <NullNode start="(260, 27)" end="(260, 39)">
                                    <IdentNode start="(260, 27)" end="(260, 39)" leading="" trailing="" raw_val="List.toArray" val="List.toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(260, 39)" end="(260, 40)" leading="" trailing=" " val=","/>
                                <IdentNode start="(260, 41)" end="(260, 51)" leading="" trailing="" raw_val="ys.toArray" val="ys.toArray"/>
                                <AtomNode start="(260, 51)" end="(260, 52)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(261, 7)" end="(261, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(261, 7)" end="(261, 8)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(261, 8)" end="(261, 56)">
                                    <IdentNode start="(261, 8)" end="(261, 18)" leading="" trailing="" raw_val="zs.toArray" val="zs.toArray"/>
                                    <AtomNode start="(261, 18)" end="(261, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(261, 20)" end="(261, 47)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(261, 20)" end="(261, 34)" leading="" trailing=" " raw_val="bs.toArray.map" val="bs.toArray.map"/>
                                      <NullNode start="(261, 35)" end="(261, 47)">
                                        <IdentNode start="(261, 35)" end="(261, 47)" leading="" trailing="" raw_val="List.toArray" val="List.toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(261, 47)" end="(261, 48)" leading="" trailing=" " val=","/>
                                    <TermBytacticNode start="(261, 49)" end="(261, 56)">
                                      <AtomNode start="(261, 49)" end="(261, 51)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(261, 52)" end="(261, 56)">
                                        <TacticTacticseq1IndentedNode start="(261, 52)" end="(261, 56)">
                                          <NullNode start="(261, 52)" end="(261, 56)">
                                            <OtherNode start="(261, 52)" end="(261, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;w : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;⊢ (List.map List.toArray (as ++ (ys ++ a :: zs) :: bs)).toArray =&#10;    (map List.toArray as.toArray).push (ys.toArray.push a ++ zs.toArray) ++ map List.toArray bs.toArray" state_after="no goals" tactic="simp">
                                              <AtomNode start="(261, 52)" end="(261, 56)" leading="" trailing="" val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </NullNode>
                                  <AtomNode start="(261, 56)" end="(261, 57)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(261, 57)" end="(261, 58)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(261, 59)" end="(261, 76)">
                                  <AtomNode start="(261, 59)" end="(261, 61)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(261, 62)" end="(261, 76)">
                                    <TacticTacticseq1IndentedNode start="(261, 62)" end="(261, 76)">
                                      <NullNode start="(261, 62)" end="(261, 76)">
                                        <OtherNode start="(261, 62)" end="(261, 76)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;w : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;⊢ ∀ (ws : Array α), ws ∈ map List.toArray as.toArray → ∀ (x : α), x ∈ ws → p x = false" state_after="no goals" tactic="simpa using h₁">
                                          <AtomNode start="(261, 62)" end="(261, 67)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(261, 68)" end="(261, 76)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(261, 68)" end="(261, 76)">
                                              <AtomNode start="(261, 68)" end="(261, 73)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(261, 74)" end="(261, 76)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(261, 76)" end="(261, 77)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(261, 78)" end="(261, 95)">
                                  <AtomNode start="(261, 78)" end="(261, 80)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(261, 81)" end="(261, 95)">
                                    <TacticTacticseq1IndentedNode start="(261, 81)" end="(261, 95)">
                                      <NullNode start="(261, 81)" end="(261, 95)">
                                        <OtherNode start="(261, 81)" end="(261, 95)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;w : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;⊢ ∀ (x : α), x ∈ ys.toArray → p x = false" state_after="no goals" tactic="simpa using h₂">
                                          <AtomNode start="(261, 81)" end="(261, 86)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(261, 87)" end="(261, 95)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(261, 87)" end="(261, 95)">
                                              <AtomNode start="(261, 87)" end="(261, 92)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(261, 93)" end="(261, 95)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(261, 95)" end="(261, 96)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(262, 3)" end="(267, 46)" kind="Lean.cdot" state_before="case of.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="no goals" tactic="· rintro ⟨as, ys, ⟨⟨zs, bs, h⟩, h₁, h₂⟩⟩&#10;  replace h := congrArg (·.map Array.toList) (congrArg Array.toList h)&#10;  simp [Function.comp_def] at h&#10;  exact ⟨as.toList.map Array.toList, ys.toList,&#10;    ⟨zs.toList, bs.toList.map Array.toList, by simpa using h⟩,&#10;      by simpa using h₁, by simpa using h₂⟩">
                    <OtherNode start="(262, 3)" end="(262, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(262, 3)" end="(262, 4)" kind="patternIgnore">
                        <OtherNode start="(262, 3)" end="(262, 4)" kind="token.«· »">
                          <AtomNode start="(262, 3)" end="(262, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(262, 5)" end="(267, 46)">
                      <TacticTacticseq1IndentedNode start="(262, 5)" end="(267, 46)">
                        <NullNode start="(262, 5)" end="(267, 46)">
                          <OtherNode start="(262, 5)" end="(262, 43)" kind="Lean.Parser.Tactic.rintro" state_before="case of.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;⊢ (∃ as ys,&#10;      (∃ x x_1, (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ x) ++ x_1) ∧&#10;        (∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false) →&#10;    ∃ as ys,&#10;      (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="case of.mpr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h : (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ zs) ++ bs&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;⊢ ∃ as ys,&#10;    (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" tactic="rintro ⟨as, ys, ⟨⟨zs, bs, h⟩, h₁, h₂⟩⟩">
                            <AtomNode start="(262, 5)" end="(262, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(262, 12)" end="(262, 43)">
                              <OtherNode start="(262, 12)" end="(262, 43)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(262, 12)" end="(262, 43)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(262, 12)" end="(262, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(262, 13)" end="(262, 42)">
                                    <OtherNode start="(262, 13)" end="(262, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(262, 13)" end="(262, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(262, 13)" end="(262, 15)">
                                          <OtherNode start="(262, 13)" end="(262, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(262, 13)" end="(262, 15)" leading="" trailing="" raw_val="as" val="as"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(262, 15)" end="(262, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(262, 17)" end="(262, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(262, 17)" end="(262, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(262, 17)" end="(262, 19)">
                                          <OtherNode start="(262, 17)" end="(262, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(262, 17)" end="(262, 19)" leading="" trailing="" raw_val="ys" val="ys"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(262, 19)" end="(262, 20)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(262, 21)" end="(262, 42)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(262, 21)" end="(262, 42)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(262, 21)" end="(262, 42)">
                                          <OtherNode start="(262, 21)" end="(262, 42)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(262, 21)" end="(262, 22)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(262, 22)" end="(262, 41)">
                                              <OtherNode start="(262, 22)" end="(262, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(262, 22)" end="(262, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(262, 22)" end="(262, 33)">
                                                    <OtherNode start="(262, 22)" end="(262, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(262, 22)" end="(262, 23)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(262, 23)" end="(262, 32)">
                                                        <OtherNode start="(262, 23)" end="(262, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(262, 23)" end="(262, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(262, 23)" end="(262, 25)">
                                                            <OtherNode start="(262, 23)" end="(262, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(262, 23)" end="(262, 25)" leading="" trailing="" raw_val="zs" val="zs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(262, 25)" end="(262, 26)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(262, 27)" end="(262, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(262, 27)" end="(262, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(262, 27)" end="(262, 29)">
                                                            <OtherNode start="(262, 27)" end="(262, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(262, 27)" end="(262, 29)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(262, 29)" end="(262, 30)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(262, 31)" end="(262, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(262, 31)" end="(262, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(262, 31)" end="(262, 32)">
                                                            <OtherNode start="(262, 31)" end="(262, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(262, 31)" end="(262, 32)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(262, 32)" end="(262, 33)" leading="" trailing="" val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(262, 33)" end="(262, 34)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(262, 35)" end="(262, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(262, 35)" end="(262, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(262, 35)" end="(262, 37)">
                                                    <OtherNode start="(262, 35)" end="(262, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(262, 35)" end="(262, 37)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(262, 37)" end="(262, 38)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(262, 39)" end="(262, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(262, 39)" end="(262, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(262, 39)" end="(262, 41)">
                                                    <OtherNode start="(262, 39)" end="(262, 41)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(262, 39)" end="(262, 41)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(262, 41)" end="(262, 42)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(262, 42)" end="(262, 43)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(263, 5)" end="(263, 73)" kind="Lean.Parser.Tactic.replace" state_before="case of.mpr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h : (List.map List.toArray xss✝).toArray = as.push (ys.push a ++ zs) ++ bs&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;⊢ ∃ as ys,&#10;    (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="case of.mpr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;h :&#10;  (fun x =&amp;gt; List.map toList x) (List.map List.toArray xss✝).toArray.toList =&#10;    (fun x =&amp;gt; List.map toList x) (as.push (ys.push a ++ zs) ++ bs).toList&#10;⊢ ∃ as ys,&#10;    (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" tactic="replace h := congrArg (·.map Array.toList) (congrArg Array.toList h)">
                            <AtomNode start="(263, 5)" end="(263, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(263, 13)" end="(263, 73)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(263, 13)" end="(263, 73)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(263, 13)" end="(263, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(263, 13)" end="(263, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(263, 15)" end="(263, 17)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(263, 18)" end="(263, 73)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(263, 18)" end="(263, 26)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(263, 27)" end="(263, 73)">
                                    <OtherNode start="(263, 27)" end="(263, 47)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(263, 27)" end="(263, 28)" leading="" trailing="" val="("/>
                                      <OtherNode start="(263, 28)" end="(263, 46)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(263, 28)" end="(263, 33)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(263, 28)" end="(263, 29)" kind="Lean.Parser.Term.cdot">
                                            <AtomNode start="(263, 28)" end="(263, 29)" leading="" trailing="" val="·"/>
                                          </OtherNode>
                                          <AtomNode start="(263, 29)" end="(263, 30)" leading="" trailing="" val="."/>
                                          <IdentNode start="(263, 30)" end="(263, 33)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                        <NullNode start="(263, 34)" end="(263, 46)">
                                          <IdentNode start="(263, 34)" end="(263, 46)" leading="" trailing="" raw_val="Array.toList" val="Array.toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(263, 46)" end="(263, 47)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <OtherNode start="(263, 48)" end="(263, 73)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(263, 48)" end="(263, 49)" leading="" trailing="" val="("/>
                                      <OtherNode start="(263, 49)" end="(263, 72)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(263, 49)" end="(263, 57)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <NullNode start="(263, 58)" end="(263, 72)">
                                          <IdentNode start="(263, 58)" end="(263, 70)" leading="" trailing=" " raw_val="Array.toList" val="Array.toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          <IdentNode start="(263, 71)" end="(263, 72)" leading="" trailing="" raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(263, 72)" end="(263, 73)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(264, 5)" end="(264, 34)" kind="Lean.Parser.Tactic.simp" state_before="case of.mpr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;h :&#10;  (fun x =&amp;gt; List.map toList x) (List.map List.toArray xss✝).toArray.toList =&#10;    (fun x =&amp;gt; List.map toList x) (as.push (ys.push a ++ zs) ++ bs).toList&#10;⊢ ∃ as ys,&#10;    (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="case of.mpr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;h : xss✝ = List.map toList as.toList ++ (ys.toList ++ a :: zs.toList) :: List.map toList bs.toList&#10;⊢ ∃ as ys,&#10;    (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" tactic="simp [Function.comp_def] at h">
                            <AtomNode start="(264, 5)" end="(264, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(264, 10)" end="(264, 29)">
                              <AtomNode start="(264, 10)" end="(264, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(264, 11)" end="(264, 28)">
                                <OtherNode start="(264, 11)" end="(264, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(264, 11)" end="(264, 28)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(264, 28)" end="(264, 29)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(264, 30)" end="(264, 34)">
                              <OtherNode start="(264, 30)" end="(264, 34)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(264, 30)" end="(264, 32)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(264, 33)" end="(264, 34)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(264, 33)" end="(264, 34)">
                                    <IdentNode start="(264, 33)" end="(264, 34)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(265, 5)" end="(267, 46)" kind="Lean.Parser.Tactic.exact" state_before="case of.mpr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;h : xss✝ = List.map toList as.toList ++ (ys.toList ++ a :: zs.toList) :: List.map toList bs.toList&#10;⊢ ∃ as ys,&#10;    (∃ x x_1, xss✝ = as ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="no goals" tactic="exact ⟨as.toList.map Array.toList, ys.toList,&#10;  ⟨zs.toList, bs.toList.map Array.toList, by simpa using h⟩,&#10;    by simpa using h₁, by simpa using h₂⟩">
                            <AtomNode start="(265, 5)" end="(265, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(265, 11)" end="(267, 46)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(265, 11)" end="(265, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(265, 12)" end="(267, 45)">
                                <OtherNode start="(265, 12)" end="(265, 38)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(265, 12)" end="(265, 25)" leading="" trailing=" " raw_val="as.toList.map" val="as.toList.map"/>
                                  <NullNode start="(265, 26)" end="(265, 38)">
                                    <IdentNode start="(265, 26)" end="(265, 38)" leading="" trailing="" raw_val="Array.toList" val="Array.toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(265, 38)" end="(265, 39)" leading="" trailing=" " val=","/>
                                <IdentNode start="(265, 40)" end="(265, 49)" leading="" trailing="" raw_val="ys.toList" val="ys.toList"/>
                                <AtomNode start="(265, 49)" end="(265, 50)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(266, 7)" end="(266, 64)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(266, 7)" end="(266, 8)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(266, 8)" end="(266, 63)">
                                    <IdentNode start="(266, 8)" end="(266, 17)" leading="" trailing="" raw_val="zs.toList" val="zs.toList"/>
                                    <AtomNode start="(266, 17)" end="(266, 18)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(266, 19)" end="(266, 45)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(266, 19)" end="(266, 32)" leading="" trailing=" " raw_val="bs.toList.map" val="bs.toList.map"/>
                                      <NullNode start="(266, 33)" end="(266, 45)">
                                        <IdentNode start="(266, 33)" end="(266, 45)" leading="" trailing="" raw_val="Array.toList" val="Array.toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(266, 45)" end="(266, 46)" leading="" trailing=" " val=","/>
                                    <TermBytacticNode start="(266, 47)" end="(266, 63)">
                                      <AtomNode start="(266, 47)" end="(266, 49)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(266, 50)" end="(266, 63)">
                                        <TacticTacticseq1IndentedNode start="(266, 50)" end="(266, 63)">
                                          <NullNode start="(266, 50)" end="(266, 63)">
                                            <OtherNode start="(266, 50)" end="(266, 63)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;h : xss✝ = List.map toList as.toList ++ (ys.toList ++ a :: zs.toList) :: List.map toList bs.toList&#10;⊢ xss✝ = List.map toList as.toList ++ (ys.toList ++ a :: zs.toList) :: List.map toList bs.toList" state_after="no goals" tactic="simpa using h">
                                              <AtomNode start="(266, 50)" end="(266, 55)" leading="" trailing=" " val="simpa"/>
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(266, 56)" end="(266, 63)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(266, 56)" end="(266, 63)">
                                                  <AtomNode start="(266, 56)" end="(266, 61)" leading="" trailing=" " val="using"/>
                                                  <IdentNode start="(266, 62)" end="(266, 63)" leading="" trailing="" raw_val="h" val="h"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </NullNode>
                                  <AtomNode start="(266, 63)" end="(266, 64)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(266, 64)" end="(266, 65)" leading="" trailing="&#10;        " val=","/>
                                <TermBytacticNode start="(267, 9)" end="(267, 26)">
                                  <AtomNode start="(267, 9)" end="(267, 11)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(267, 12)" end="(267, 26)">
                                    <TacticTacticseq1IndentedNode start="(267, 12)" end="(267, 26)">
                                      <NullNode start="(267, 12)" end="(267, 26)">
                                        <OtherNode start="(267, 12)" end="(267, 26)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;h : xss✝ = List.map toList as.toList ++ (ys.toList ++ a :: zs.toList) :: List.map toList bs.toList&#10;⊢ ∀ (l : List α), l ∈ List.map toList as.toList → ∀ (x : α), x ∈ l → p x = false" state_after="no goals" tactic="simpa using h₁">
                                          <AtomNode start="(267, 12)" end="(267, 17)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(267, 18)" end="(267, 26)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(267, 18)" end="(267, 26)">
                                              <AtomNode start="(267, 18)" end="(267, 23)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(267, 24)" end="(267, 26)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(267, 26)" end="(267, 27)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(267, 28)" end="(267, 45)">
                                  <AtomNode start="(267, 28)" end="(267, 30)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(267, 31)" end="(267, 45)">
                                    <TacticTacticseq1IndentedNode start="(267, 31)" end="(267, 45)">
                                      <NullNode start="(267, 31)" end="(267, 45)">
                                        <OtherNode start="(267, 31)" end="(267, 45)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xss✝ : List (List α)&#10;w : p a = true&#10;as : Array (Array α)&#10;ys zs : Array α&#10;bs : Array (Array α)&#10;h₁ : ∀ (ws : Array α), ws ∈ as → ∀ (x : α), x ∈ ws → p x = false&#10;h₂ : ∀ (x : α), x ∈ ys → p x = false&#10;h : xss✝ = List.map toList as.toList ++ (ys.toList ++ a :: zs.toList) :: List.map toList bs.toList&#10;⊢ ∀ (x : α), x ∈ ys.toList → p x = false" state_after="no goals" tactic="simpa using h₂">
                                          <AtomNode start="(267, 31)" end="(267, 36)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(267, 37)" end="(267, 45)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(267, 37)" end="(267, 45)">
                                              <AtomNode start="(267, 37)" end="(267, 42)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(267, 43)" end="(267, 45)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(267, 45)" end="(267, 46)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(269, 1)" end="(270, 59)" name="find?_flatten_eq_some" full_name="Array.find?_flatten_eq_some">
      <CommandDeclmodifiersNode start="(269, 1)" end="(269, 64)">
        <NullNode/>
        <NullNode start="(269, 1)" end="(269, 64)">
          <OtherNode start="(269, 1)" end="(269, 64)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(269, 1)" end="(269, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(269, 3)" end="(269, 63)">
              <OtherNode start="(269, 3)" end="(269, 63)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(269, 3)" end="(269, 63)" kind="Lean.deprecated">
                  <AtomNode start="(269, 3)" end="(269, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(269, 14)" end="(269, 39)">
                    <IdentNode start="(269, 14)" end="(269, 39)" leading="" trailing=" " raw_val="find?_flatten_eq_some_iff" val="find?_flatten_eq_some_iff" full_name="Array.find?_flatten_eq_some_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(249, 9)" def_end="(249, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(269, 40)" end="(269, 63)">
                    <AtomNode start="(269, 40)" end="(269, 41)" leading="" trailing="" val="("/>
                    <AtomNode start="(269, 41)" end="(269, 46)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(269, 47)" end="(269, 49)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(269, 50)" end="(269, 62)" kind="str">
                      <AtomNode start="(269, 50)" end="(269, 62)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(269, 62)" end="(269, 63)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(269, 63)" end="(269, 64)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(270, 1)" end="(270, 59)" name="find?_flatten_eq_some">
        <AtomNode start="(270, 1)" end="(270, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(270, 8)" end="(270, 29)">
          <IdentNode start="(270, 8)" end="(270, 29)" leading="" trailing=" " raw_val="find?_flatten_eq_some" val="find?_flatten_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(270, 30)" end="(270, 59)">
          <AtomNode start="(270, 30)" end="(270, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(270, 33)" end="(270, 59)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(270, 33)" end="(270, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(270, 34)" end="(270, 59)" leading="" trailing="&#10;&#10;" raw_val="find?_flatten_eq_some_iff" val="find?_flatten_eq_some_iff" full_name="Array.find?_flatten_eq_some_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(249, 9)" def_end="(249, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(272, 1)" end="(275, 51)" name="find?_flatMap" full_name="Array.find?_flatMap">
      <CommandDeclmodifiersNode start="(272, 1)" end="(272, 8)">
        <NullNode/>
        <NullNode start="(272, 1)" end="(272, 8)">
          <OtherNode start="(272, 1)" end="(272, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(272, 1)" end="(272, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(272, 3)" end="(272, 7)">
              <OtherNode start="(272, 3)" end="(272, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(272, 3)" end="(272, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(272, 3)" end="(272, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(272, 7)" end="(272, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(272, 9)" end="(275, 51)" name="find?_flatMap" full_name="Array.find?_flatMap" _is_private_decl="False">
        <AtomNode start="(272, 9)" end="(272, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(272, 17)" end="(272, 30)">
          <IdentNode start="(272, 17)" end="(272, 30)" leading="" trailing=" " raw_val="find?_flatMap" val="find?_flatMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(272, 31)" end="(273, 67)">
          <NullNode start="(272, 31)" end="(272, 78)">
            <OtherNode start="(272, 31)" end="(272, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(272, 31)" end="(272, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(272, 32)" end="(272, 34)">
                <IdentNode start="(272, 32)" end="(272, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(272, 35)" end="(272, 44)">
                <AtomNode start="(272, 35)" end="(272, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(272, 37)" end="(272, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(272, 37)" end="(272, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(272, 43)" end="(272, 44)">
                    <IdentNode start="(272, 43)" end="(272, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(272, 44)" end="(272, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(272, 46)" end="(272, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(272, 46)" end="(272, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(272, 47)" end="(272, 48)">
                <IdentNode start="(272, 47)" end="(272, 48)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(272, 49)" end="(272, 62)">
                <AtomNode start="(272, 49)" end="(272, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(272, 51)" end="(272, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(272, 51)" end="(272, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(272, 53)" end="(272, 54)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(272, 55)" end="(272, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(272, 55)" end="(272, 60)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(272, 61)" end="(272, 62)">
                      <IdentNode start="(272, 61)" end="(272, 62)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(272, 62)" end="(272, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(272, 64)" end="(272, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(272, 64)" end="(272, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(272, 65)" end="(272, 66)">
                <IdentNode start="(272, 65)" end="(272, 66)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(272, 67)" end="(272, 77)">
                <AtomNode start="(272, 67)" end="(272, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(272, 69)" end="(272, 77)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(272, 69)" end="(272, 70)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(272, 71)" end="(272, 72)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(272, 73)" end="(272, 77)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(272, 77)" end="(272, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(272, 79)" end="(273, 67)">
            <AtomNode start="(272, 79)" end="(272, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(273, 5)" end="(273, 67)" kind="«term_=_»">
              <OtherNode start="(273, 5)" end="(273, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(273, 5)" end="(273, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(273, 5)" end="(273, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(273, 5)" end="(273, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(273, 6)" end="(273, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(273, 6)" end="(273, 16)" leading="" trailing=" " raw_val="xs.flatMap" val="xs.flatMap"/>
                      <NullNode start="(273, 17)" end="(273, 18)">
                        <IdentNode start="(273, 17)" end="(273, 18)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(273, 18)" end="(273, 19)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(273, 19)" end="(273, 20)" leading="" trailing="" val="."/>
                  <IdentNode start="(273, 20)" end="(273, 25)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(273, 26)" end="(273, 27)">
                  <IdentNode start="(273, 26)" end="(273, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(273, 28)" end="(273, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(273, 30)" end="(273, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(273, 30)" end="(273, 42)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(273, 43)" end="(273, 67)">
                  <OtherNode start="(273, 43)" end="(273, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(273, 43)" end="(273, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(273, 44)" end="(273, 66)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(273, 44)" end="(273, 47)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(273, 48)" end="(273, 66)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(273, 48)" end="(273, 49)">
                          <IdentNode start="(273, 48)" end="(273, 49)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(273, 50)" end="(273, 52)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(273, 53)" end="(273, 66)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(273, 53)" end="(273, 64)" kind="Lean.Parser.Term.proj">
                            <OtherNode start="(273, 53)" end="(273, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(273, 53)" end="(273, 54)" leading="" trailing="" val="("/>
                              <OtherNode start="(273, 54)" end="(273, 57)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(273, 54)" end="(273, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(273, 56)" end="(273, 57)">
                                  <IdentNode start="(273, 56)" end="(273, 57)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(273, 57)" end="(273, 58)" leading="" trailing="" val=")"/>
                            </OtherNode>
                            <AtomNode start="(273, 58)" end="(273, 59)" leading="" trailing="" val="."/>
                            <IdentNode start="(273, 59)" end="(273, 64)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                          </OtherNode>
                          <NullNode start="(273, 65)" end="(273, 66)">
                            <IdentNode start="(273, 65)" end="(273, 66)" leading="" trailing="" raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(273, 66)" end="(273, 67)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(273, 68)" end="(275, 51)">
          <AtomNode start="(273, 68)" end="(273, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(273, 71)" end="(275, 51)">
            <AtomNode start="(273, 71)" end="(273, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(274, 3)" end="(275, 51)">
              <TacticTacticseq1IndentedNode start="(274, 3)" end="(275, 51)">
                <NullNode start="(274, 3)" end="(275, 51)">
                  <OtherNode start="(274, 3)" end="(274, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : Array α&#10;f : α → Array β&#10;p : β → Bool&#10;⊢ find? p (flatMap f xs) = findSome? (fun x =&amp;gt; find? p (f x)) xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;p : β → Bool&#10;toList✝ : List α&#10;⊢ find? p (flatMap f { toList := toList✝ }) = findSome? (fun x =&amp;gt; find? p (f x)) { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(274, 3)" end="(274, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(274, 9)" end="(274, 11)">
                      <OtherNode start="(274, 9)" end="(274, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(274, 9)" end="(274, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(275, 3)" end="(275, 51)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;p : β → Bool&#10;toList✝ : List α&#10;⊢ find? p (flatMap f { toList := toList✝ }) = findSome? (fun x =&amp;gt; find? p (f x)) { toList := toList✝ }" state_after="no goals" tactic="simp [List.find?_flatMap, Array.flatMap_toArray]">
                    <AtomNode start="(275, 3)" end="(275, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(275, 8)" end="(275, 51)">
                      <AtomNode start="(275, 8)" end="(275, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(275, 9)" end="(275, 50)">
                        <OtherNode start="(275, 9)" end="(275, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(275, 9)" end="(275, 27)" leading="" trailing="" raw_val="List.find?_flatMap" val="List.find?_flatMap" full_name="List.find?_flatMap" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(275, 27)" end="(275, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(275, 29)" end="(275, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(275, 29)" end="(275, 50)" leading="" trailing="" raw_val="Array.flatMap_toArray" val="Array.flatMap_toArray" full_name="Array.flatMap_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(275, 50)" end="(275, 51)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(277, 1)" end="(279, 7)" name="find?_flatMap_eq_none_iff" full_name="Array.find?_flatMap_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(277, 1)" end="(279, 7)" name="find?_flatMap_eq_none_iff" full_name="Array.find?_flatMap_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(277, 1)" end="(277, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(277, 9)" end="(277, 34)">
          <IdentNode start="(277, 9)" end="(277, 34)" leading="" trailing=" " raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(277, 35)" end="(278, 62)">
          <NullNode start="(277, 35)" end="(277, 82)">
            <OtherNode start="(277, 35)" end="(277, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(277, 35)" end="(277, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(277, 36)" end="(277, 38)">
                <IdentNode start="(277, 36)" end="(277, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(277, 39)" end="(277, 48)">
                <AtomNode start="(277, 39)" end="(277, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(277, 41)" end="(277, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(277, 41)" end="(277, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(277, 47)" end="(277, 48)">
                    <IdentNode start="(277, 47)" end="(277, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(277, 48)" end="(277, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(277, 50)" end="(277, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(277, 50)" end="(277, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(277, 51)" end="(277, 52)">
                <IdentNode start="(277, 51)" end="(277, 52)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(277, 53)" end="(277, 66)">
                <AtomNode start="(277, 53)" end="(277, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(277, 55)" end="(277, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(277, 55)" end="(277, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(277, 57)" end="(277, 58)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(277, 59)" end="(277, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(277, 59)" end="(277, 64)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(277, 65)" end="(277, 66)">
                      <IdentNode start="(277, 65)" end="(277, 66)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(277, 66)" end="(277, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(277, 68)" end="(277, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(277, 68)" end="(277, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(277, 69)" end="(277, 70)">
                <IdentNode start="(277, 69)" end="(277, 70)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(277, 71)" end="(277, 81)">
                <AtomNode start="(277, 71)" end="(277, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(277, 73)" end="(277, 81)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(277, 73)" end="(277, 74)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(277, 75)" end="(277, 76)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(277, 77)" end="(277, 81)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(277, 81)" end="(277, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(277, 83)" end="(278, 62)">
            <AtomNode start="(277, 83)" end="(277, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(278, 5)" end="(278, 62)" kind="«term_↔_»">
              <OtherNode start="(278, 5)" end="(278, 34)" kind="«term_=_»">
                <OtherNode start="(278, 5)" end="(278, 27)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(278, 5)" end="(278, 25)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(278, 5)" end="(278, 19)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(278, 5)" end="(278, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(278, 6)" end="(278, 18)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(278, 6)" end="(278, 16)" leading="" trailing=" " raw_val="xs.flatMap" val="xs.flatMap"/>
                        <NullNode start="(278, 17)" end="(278, 18)">
                          <IdentNode start="(278, 17)" end="(278, 18)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(278, 18)" end="(278, 19)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(278, 19)" end="(278, 20)" leading="" trailing="" val="."/>
                    <IdentNode start="(278, 20)" end="(278, 25)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(278, 26)" end="(278, 27)">
                    <IdentNode start="(278, 26)" end="(278, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(278, 28)" end="(278, 29)" leading="" trailing=" " val="="/>
                <IdentNode start="(278, 30)" end="(278, 34)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(278, 35)" end="(278, 36)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(278, 37)" end="(278, 62)" kind="Lean.«term∀__,_»">
                <AtomNode start="(278, 37)" end="(278, 38)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(278, 39)" end="(278, 40)">
                  <IdentNode start="(278, 39)" end="(278, 40)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(278, 41)" end="(278, 45)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(278, 41)" end="(278, 42)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(278, 43)" end="(278, 45)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(278, 45)" end="(278, 46)" leading="" trailing=" " val=","/>
                <OtherNode start="(278, 47)" end="(278, 62)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(278, 47)" end="(278, 48)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(278, 49)" end="(278, 50)">
                    <IdentNode start="(278, 49)" end="(278, 50)" leading="" trailing=" " raw_val="y" val="y"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(278, 51)" end="(278, 56)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(278, 51)" end="(278, 52)" leading="" trailing=" " val="∈"/>
                    <OtherNode start="(278, 53)" end="(278, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(278, 53)" end="(278, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(278, 55)" end="(278, 56)">
                        <IdentNode start="(278, 55)" end="(278, 56)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(278, 56)" end="(278, 57)" leading="" trailing=" " val=","/>
                  <OtherNode start="(278, 58)" end="(278, 62)" kind="term!_">
                    <AtomNode start="(278, 58)" end="(278, 59)" leading="" trailing="" val="!"/>
                    <OtherNode start="(278, 59)" end="(278, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(278, 59)" end="(278, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(278, 61)" end="(278, 62)">
                        <IdentNode start="(278, 61)" end="(278, 62)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(278, 63)" end="(279, 7)">
          <AtomNode start="(278, 63)" end="(278, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(278, 66)" end="(279, 7)">
            <AtomNode start="(278, 66)" end="(278, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(279, 3)" end="(279, 7)">
              <TacticTacticseq1IndentedNode start="(279, 3)" end="(279, 7)">
                <NullNode start="(279, 3)" end="(279, 7)">
                  <OtherNode start="(279, 3)" end="(279, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : Array α&#10;f : α → Array β&#10;p : β → Bool&#10;⊢ find? p (flatMap f xs) = none ↔ ∀ (x : α), x ∈ xs → ∀ (y : β), y ∈ f x → (!p y) = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(279, 3)" end="(279, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(281, 1)" end="(282, 59)" name="find?_flatMap_eq_none" full_name="Array.find?_flatMap_eq_none">
      <CommandDeclmodifiersNode start="(281, 1)" end="(281, 64)">
        <NullNode/>
        <NullNode start="(281, 1)" end="(281, 64)">
          <OtherNode start="(281, 1)" end="(281, 64)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(281, 1)" end="(281, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(281, 3)" end="(281, 63)">
              <OtherNode start="(281, 3)" end="(281, 63)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(281, 3)" end="(281, 63)" kind="Lean.deprecated">
                  <AtomNode start="(281, 3)" end="(281, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(281, 14)" end="(281, 39)">
                    <IdentNode start="(281, 14)" end="(281, 39)" leading="" trailing=" " raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff" full_name="Array.find?_flatMap_eq_none_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(277, 9)" def_end="(277, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(281, 40)" end="(281, 63)">
                    <AtomNode start="(281, 40)" end="(281, 41)" leading="" trailing="" val="("/>
                    <AtomNode start="(281, 41)" end="(281, 46)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(281, 47)" end="(281, 49)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(281, 50)" end="(281, 62)" kind="str">
                      <AtomNode start="(281, 50)" end="(281, 62)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(281, 62)" end="(281, 63)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(281, 63)" end="(281, 64)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(282, 1)" end="(282, 59)" name="find?_flatMap_eq_none">
        <AtomNode start="(282, 1)" end="(282, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(282, 8)" end="(282, 29)">
          <IdentNode start="(282, 8)" end="(282, 29)" leading="" trailing=" " raw_val="find?_flatMap_eq_none" val="find?_flatMap_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(282, 30)" end="(282, 59)">
          <AtomNode start="(282, 30)" end="(282, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(282, 33)" end="(282, 59)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(282, 33)" end="(282, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(282, 34)" end="(282, 59)" leading="" trailing="&#10;&#10;" raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff" full_name="Array.find?_flatMap_eq_none_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(277, 9)" def_end="(277, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(284, 1)" end="(286, 56)" name="find?_replicate" full_name="Array.find?_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(284, 1)" end="(286, 56)" name="find?_replicate" full_name="Array.find?_replicate" _is_private_decl="False">
        <AtomNode start="(284, 1)" end="(284, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(284, 9)" end="(284, 24)">
          <IdentNode start="(284, 9)" end="(284, 24)" leading="" trailing=" " raw_val="find?_replicate" val="find?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(284, 25)" end="(285, 83)">
          <NullNode/>
          <TermTypespecNode start="(284, 25)" end="(285, 83)">
            <AtomNode start="(284, 25)" end="(284, 26)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(285, 5)" end="(285, 83)" kind="«term_=_»">
              <OtherNode start="(285, 5)" end="(285, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(285, 5)" end="(285, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(285, 11)" end="(285, 28)">
                  <IdentNode start="(285, 11)" end="(285, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(285, 13)" end="(285, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(285, 13)" end="(285, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(285, 14)" end="(285, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(285, 14)" end="(285, 23)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(285, 24)" end="(285, 27)">
                        <IdentNode start="(285, 24)" end="(285, 25)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(285, 26)" end="(285, 27)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(285, 27)" end="(285, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(285, 29)" end="(285, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(285, 31)" end="(285, 83)" kind="termIfThenElse">
                <AtomNode start="(285, 31)" end="(285, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(285, 34)" end="(285, 39)" kind="«term_=_»">
                  <IdentNode start="(285, 34)" end="(285, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(285, 36)" end="(285, 37)" leading="" trailing=" " val="="/>
                  <OtherNode start="(285, 38)" end="(285, 39)" kind="num">
                    <AtomNode start="(285, 38)" end="(285, 39)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(285, 40)" end="(285, 44)" leading="" trailing=" " val="then"/>
                <IdentNode start="(285, 45)" end="(285, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(285, 50)" end="(285, 54)" leading="" trailing=" " val="else"/>
                <OtherNode start="(285, 55)" end="(285, 83)" kind="termIfThenElse">
                  <AtomNode start="(285, 55)" end="(285, 57)" leading="" trailing=" " val="if"/>
                  <OtherNode start="(285, 58)" end="(285, 61)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(285, 58)" end="(285, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(285, 60)" end="(285, 61)">
                      <IdentNode start="(285, 60)" end="(285, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(285, 62)" end="(285, 66)" leading="" trailing=" " val="then"/>
                  <OtherNode start="(285, 67)" end="(285, 73)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(285, 67)" end="(285, 71)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(285, 72)" end="(285, 73)">
                      <IdentNode start="(285, 72)" end="(285, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(285, 74)" end="(285, 78)" leading="" trailing=" " val="else"/>
                  <IdentNode start="(285, 79)" end="(285, 83)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(285, 84)" end="(286, 56)">
          <AtomNode start="(285, 84)" end="(285, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(285, 87)" end="(286, 56)">
            <AtomNode start="(285, 87)" end="(285, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(286, 3)" end="(286, 56)">
              <TacticTacticseq1IndentedNode start="(286, 3)" end="(286, 56)">
                <NullNode start="(286, 3)" end="(286, 56)">
                  <OtherNode start="(286, 3)" end="(286, 56)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;⊢ find? p (replicate n a) = if n = 0 then none else if p a = true then some a else none" state_after="no goals" tactic="simp [← List.toArray_replicate, List.find?_replicate]">
                    <AtomNode start="(286, 3)" end="(286, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(286, 8)" end="(286, 56)">
                      <AtomNode start="(286, 8)" end="(286, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(286, 9)" end="(286, 55)">
                        <OtherNode start="(286, 9)" end="(286, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(286, 9)" end="(286, 10)">
                            <OtherNode start="(286, 9)" end="(286, 10)" kind="patternIgnore">
                              <OtherNode start="(286, 9)" end="(286, 10)" kind="token.«← »">
                                <AtomNode start="(286, 9)" end="(286, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(286, 11)" end="(286, 33)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(286, 33)" end="(286, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(286, 35)" end="(286, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(286, 35)" end="(286, 55)" leading="" trailing="" raw_val="List.find?_replicate" val="List.find?_replicate" full_name="List.find?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(286, 55)" end="(286, 56)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(288, 1)" end="(289, 41)" name="find?_mkArray" full_name="Array.find?_mkArray">
      <CommandDeclmodifiersNode start="(288, 1)" end="(288, 54)">
        <NullNode/>
        <NullNode start="(288, 1)" end="(288, 54)">
          <OtherNode start="(288, 1)" end="(288, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(288, 1)" end="(288, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(288, 3)" end="(288, 53)">
              <OtherNode start="(288, 3)" end="(288, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(288, 3)" end="(288, 53)" kind="Lean.deprecated">
                  <AtomNode start="(288, 3)" end="(288, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(288, 14)" end="(288, 29)">
                    <IdentNode start="(288, 14)" end="(288, 29)" leading="" trailing=" " raw_val="find?_replicate" val="find?_replicate" full_name="Array.find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(284, 9)" def_end="(284, 24)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(288, 30)" end="(288, 53)">
                    <AtomNode start="(288, 30)" end="(288, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(288, 31)" end="(288, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(288, 37)" end="(288, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(288, 40)" end="(288, 52)" kind="str">
                      <AtomNode start="(288, 40)" end="(288, 52)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(288, 52)" end="(288, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(288, 53)" end="(288, 54)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(289, 1)" end="(289, 41)" name="find?_mkArray">
        <AtomNode start="(289, 1)" end="(289, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(289, 8)" end="(289, 21)">
          <IdentNode start="(289, 8)" end="(289, 21)" leading="" trailing=" " raw_val="find?_mkArray" val="find?_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(289, 22)" end="(289, 41)">
          <AtomNode start="(289, 22)" end="(289, 24)" leading="" trailing=" " val=":="/>
          <OtherNode start="(289, 25)" end="(289, 41)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(289, 25)" end="(289, 26)" leading="" trailing="" val="@"/>
            <IdentNode start="(289, 26)" end="(289, 41)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate" val="find?_replicate" full_name="Array.find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(284, 9)" def_end="(284, 24)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(291, 1)" end="(293, 41)" name="find?_replicate_of_size_pos" full_name="Array.find?_replicate_of_size_pos">
      <CommandDeclmodifiersNode start="(291, 1)" end="(291, 8)">
        <NullNode/>
        <NullNode start="(291, 1)" end="(291, 8)">
          <OtherNode start="(291, 1)" end="(291, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(291, 1)" end="(291, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(291, 3)" end="(291, 7)">
              <OtherNode start="(291, 3)" end="(291, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(291, 3)" end="(291, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(291, 3)" end="(291, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(291, 7)" end="(291, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(291, 9)" end="(293, 41)" name="find?_replicate_of_size_pos" full_name="Array.find?_replicate_of_size_pos" _is_private_decl="False">
        <AtomNode start="(291, 9)" end="(291, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(291, 17)" end="(291, 44)">
          <IdentNode start="(291, 17)" end="(291, 44)" leading="" trailing=" " raw_val="find?_replicate_of_size_pos" val="find?_replicate_of_size_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(291, 45)" end="(292, 59)">
          <NullNode start="(291, 45)" end="(291, 56)">
            <TermExplicitbinderNode start="(291, 45)" end="(291, 56)">
              <AtomNode start="(291, 45)" end="(291, 46)" leading="" trailing="" val="("/>
              <NullNode start="(291, 46)" end="(291, 47)">
                <IdentNode start="(291, 46)" end="(291, 47)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(291, 48)" end="(291, 55)">
                <AtomNode start="(291, 48)" end="(291, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(291, 50)" end="(291, 55)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(291, 50)" end="(291, 51)" kind="num">
                    <AtomNode start="(291, 50)" end="(291, 51)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(291, 52)" end="(291, 53)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(291, 54)" end="(291, 55)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(291, 55)" end="(291, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(291, 57)" end="(292, 59)">
            <AtomNode start="(291, 57)" end="(291, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(292, 5)" end="(292, 59)" kind="«term_=_»">
              <OtherNode start="(292, 5)" end="(292, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(292, 5)" end="(292, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(292, 11)" end="(292, 28)">
                  <IdentNode start="(292, 11)" end="(292, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(292, 13)" end="(292, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(292, 13)" end="(292, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(292, 14)" end="(292, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(292, 14)" end="(292, 23)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(292, 24)" end="(292, 27)">
                        <IdentNode start="(292, 24)" end="(292, 25)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(292, 26)" end="(292, 27)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(292, 27)" end="(292, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(292, 29)" end="(292, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(292, 31)" end="(292, 59)" kind="termIfThenElse">
                <AtomNode start="(292, 31)" end="(292, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(292, 34)" end="(292, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(292, 34)" end="(292, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(292, 36)" end="(292, 37)">
                    <IdentNode start="(292, 36)" end="(292, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(292, 38)" end="(292, 42)" leading="" trailing=" " val="then"/>
                <OtherNode start="(292, 43)" end="(292, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(292, 43)" end="(292, 47)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(292, 48)" end="(292, 49)">
                    <IdentNode start="(292, 48)" end="(292, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(292, 50)" end="(292, 54)" leading="" trailing=" " val="else"/>
                <IdentNode start="(292, 55)" end="(292, 59)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(292, 60)" end="(293, 41)">
          <AtomNode start="(292, 60)" end="(292, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(292, 63)" end="(293, 41)">
            <AtomNode start="(292, 63)" end="(292, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(293, 3)" end="(293, 41)">
              <TacticTacticseq1IndentedNode start="(293, 3)" end="(293, 41)">
                <NullNode start="(293, 3)" end="(293, 41)">
                  <OtherNode start="(293, 3)" end="(293, 41)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;h : 0 &amp;lt; n&#10;⊢ find? p (replicate n a) = if p a = true then some a else none" state_after="no goals" tactic="simp [find?_replicate, Nat.ne_of_gt h]">
                    <AtomNode start="(293, 3)" end="(293, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(293, 8)" end="(293, 41)">
                      <AtomNode start="(293, 8)" end="(293, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(293, 9)" end="(293, 40)">
                        <OtherNode start="(293, 9)" end="(293, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(293, 9)" end="(293, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="Array.find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(284, 9)" def_end="(284, 24)"/>
                        </OtherNode>
                        <AtomNode start="(293, 24)" end="(293, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(293, 26)" end="(293, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(293, 26)" end="(293, 40)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(293, 26)" end="(293, 38)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(293, 39)" end="(293, 40)">
                              <IdentNode start="(293, 39)" end="(293, 40)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(293, 40)" end="(293, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(295, 1)" end="(296, 67)" name="find?_mkArray_of_length_pos" full_name="Array.find?_mkArray_of_length_pos">
      <CommandDeclmodifiersNode start="(295, 1)" end="(295, 66)">
        <NullNode/>
        <NullNode start="(295, 1)" end="(295, 66)">
          <OtherNode start="(295, 1)" end="(295, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(295, 1)" end="(295, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(295, 3)" end="(295, 65)">
              <OtherNode start="(295, 3)" end="(295, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(295, 3)" end="(295, 65)" kind="Lean.deprecated">
                  <AtomNode start="(295, 3)" end="(295, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(295, 14)" end="(295, 41)">
                    <IdentNode start="(295, 14)" end="(295, 41)" leading="" trailing=" " raw_val="find?_replicate_of_size_pos" val="find?_replicate_of_size_pos" full_name="Array.find?_replicate_of_size_pos" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(291, 17)" def_end="(291, 44)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(295, 42)" end="(295, 65)">
                    <AtomNode start="(295, 42)" end="(295, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(295, 43)" end="(295, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(295, 49)" end="(295, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(295, 52)" end="(295, 64)" kind="str">
                      <AtomNode start="(295, 52)" end="(295, 64)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(295, 64)" end="(295, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(295, 65)" end="(295, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(296, 1)" end="(296, 67)" name="find?_mkArray_of_length_pos">
        <AtomNode start="(296, 1)" end="(296, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(296, 8)" end="(296, 35)">
          <IdentNode start="(296, 8)" end="(296, 35)" leading="" trailing=" " raw_val="find?_mkArray_of_length_pos" val="find?_mkArray_of_length_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(296, 36)" end="(296, 67)">
          <AtomNode start="(296, 36)" end="(296, 38)" leading="" trailing=" " val=":="/>
          <OtherNode start="(296, 39)" end="(296, 67)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(296, 39)" end="(296, 40)" leading="" trailing="" val="@"/>
            <IdentNode start="(296, 40)" end="(296, 67)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_of_size_pos" val="find?_replicate_of_size_pos" full_name="Array.find?_replicate_of_size_pos" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(291, 17)" def_end="(291, 44)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(298, 1)" end="(300, 28)" name="find?_replicate_of_pos" full_name="Array.find?_replicate_of_pos">
      <CommandDeclmodifiersNode start="(298, 1)" end="(298, 8)">
        <NullNode/>
        <NullNode start="(298, 1)" end="(298, 8)">
          <OtherNode start="(298, 1)" end="(298, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(298, 1)" end="(298, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(298, 3)" end="(298, 7)">
              <OtherNode start="(298, 3)" end="(298, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(298, 3)" end="(298, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(298, 3)" end="(298, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(298, 7)" end="(298, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(298, 9)" end="(300, 28)" name="find?_replicate_of_pos" full_name="Array.find?_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(298, 9)" end="(298, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(298, 17)" end="(298, 39)">
          <IdentNode start="(298, 17)" end="(298, 39)" leading="" trailing=" " raw_val="find?_replicate_of_pos" val="find?_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(298, 40)" end="(299, 61)">
          <NullNode start="(298, 40)" end="(298, 49)">
            <TermExplicitbinderNode start="(298, 40)" end="(298, 49)">
              <AtomNode start="(298, 40)" end="(298, 41)" leading="" trailing="" val="("/>
              <NullNode start="(298, 41)" end="(298, 42)">
                <IdentNode start="(298, 41)" end="(298, 42)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(298, 43)" end="(298, 48)">
                <AtomNode start="(298, 43)" end="(298, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(298, 45)" end="(298, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(298, 45)" end="(298, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(298, 47)" end="(298, 48)">
                    <IdentNode start="(298, 47)" end="(298, 48)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(298, 48)" end="(298, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(298, 50)" end="(299, 61)">
            <AtomNode start="(298, 50)" end="(298, 51)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(299, 5)" end="(299, 61)" kind="«term_=_»">
              <OtherNode start="(299, 5)" end="(299, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(299, 5)" end="(299, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(299, 11)" end="(299, 28)">
                  <IdentNode start="(299, 11)" end="(299, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(299, 13)" end="(299, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(299, 13)" end="(299, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(299, 14)" end="(299, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(299, 14)" end="(299, 23)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(299, 24)" end="(299, 27)">
                        <IdentNode start="(299, 24)" end="(299, 25)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(299, 26)" end="(299, 27)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(299, 27)" end="(299, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(299, 29)" end="(299, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(299, 31)" end="(299, 61)" kind="termIfThenElse">
                <AtomNode start="(299, 31)" end="(299, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(299, 34)" end="(299, 39)" kind="«term_=_»">
                  <IdentNode start="(299, 34)" end="(299, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(299, 36)" end="(299, 37)" leading="" trailing=" " val="="/>
                  <OtherNode start="(299, 38)" end="(299, 39)" kind="num">
                    <AtomNode start="(299, 38)" end="(299, 39)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(299, 40)" end="(299, 44)" leading="" trailing=" " val="then"/>
                <IdentNode start="(299, 45)" end="(299, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(299, 50)" end="(299, 54)" leading="" trailing=" " val="else"/>
                <OtherNode start="(299, 55)" end="(299, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(299, 55)" end="(299, 59)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(299, 60)" end="(299, 61)">
                    <IdentNode start="(299, 60)" end="(299, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(299, 62)" end="(300, 28)">
          <AtomNode start="(299, 62)" end="(299, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(299, 65)" end="(300, 28)">
            <AtomNode start="(299, 65)" end="(299, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(300, 3)" end="(300, 28)">
              <TacticTacticseq1IndentedNode start="(300, 3)" end="(300, 28)">
                <NullNode start="(300, 3)" end="(300, 28)">
                  <OtherNode start="(300, 3)" end="(300, 28)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;h : p a = true&#10;⊢ find? p (replicate n a) = if n = 0 then none else some a" state_after="no goals" tactic="simp [find?_replicate, h]">
                    <AtomNode start="(300, 3)" end="(300, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(300, 8)" end="(300, 28)">
                      <AtomNode start="(300, 8)" end="(300, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(300, 9)" end="(300, 27)">
                        <OtherNode start="(300, 9)" end="(300, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(300, 9)" end="(300, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="Array.find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(284, 9)" def_end="(284, 24)"/>
                        </OtherNode>
                        <AtomNode start="(300, 24)" end="(300, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(300, 26)" end="(300, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(300, 26)" end="(300, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(300, 27)" end="(300, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(302, 1)" end="(303, 55)" name="find?_mkArray_of_pos" full_name="Array.find?_mkArray_of_pos">
      <CommandDeclmodifiersNode start="(302, 1)" end="(302, 61)">
        <NullNode/>
        <NullNode start="(302, 1)" end="(302, 61)">
          <OtherNode start="(302, 1)" end="(302, 61)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(302, 1)" end="(302, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(302, 3)" end="(302, 60)">
              <OtherNode start="(302, 3)" end="(302, 60)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(302, 3)" end="(302, 60)" kind="Lean.deprecated">
                  <AtomNode start="(302, 3)" end="(302, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(302, 14)" end="(302, 36)">
                    <IdentNode start="(302, 14)" end="(302, 36)" leading="" trailing=" " raw_val="find?_replicate_of_pos" val="find?_replicate_of_pos" full_name="Array.find?_replicate_of_pos" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(298, 17)" def_end="(298, 39)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(302, 37)" end="(302, 60)">
                    <AtomNode start="(302, 37)" end="(302, 38)" leading="" trailing="" val="("/>
                    <AtomNode start="(302, 38)" end="(302, 43)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(302, 44)" end="(302, 46)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(302, 47)" end="(302, 59)" kind="str">
                      <AtomNode start="(302, 47)" end="(302, 59)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(302, 59)" end="(302, 60)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(302, 60)" end="(302, 61)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(303, 1)" end="(303, 55)" name="find?_mkArray_of_pos">
        <AtomNode start="(303, 1)" end="(303, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(303, 8)" end="(303, 28)">
          <IdentNode start="(303, 8)" end="(303, 28)" leading="" trailing=" " raw_val="find?_mkArray_of_pos" val="find?_mkArray_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(303, 29)" end="(303, 55)">
          <AtomNode start="(303, 29)" end="(303, 31)" leading="" trailing=" " val=":="/>
          <OtherNode start="(303, 32)" end="(303, 55)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(303, 32)" end="(303, 33)" leading="" trailing="" val="@"/>
            <IdentNode start="(303, 33)" end="(303, 55)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_of_pos" val="find?_replicate_of_pos" full_name="Array.find?_replicate_of_pos" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(298, 17)" def_end="(298, 39)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(305, 1)" end="(306, 28)" name="find?_replicate_of_neg" full_name="Array.find?_replicate_of_neg">
      <CommandDeclmodifiersNode start="(305, 1)" end="(305, 8)">
        <NullNode/>
        <NullNode start="(305, 1)" end="(305, 8)">
          <OtherNode start="(305, 1)" end="(305, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(305, 1)" end="(305, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(305, 3)" end="(305, 7)">
              <OtherNode start="(305, 3)" end="(305, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(305, 3)" end="(305, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(305, 3)" end="(305, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(305, 7)" end="(305, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(305, 9)" end="(306, 28)" name="find?_replicate_of_neg" full_name="Array.find?_replicate_of_neg" _is_private_decl="False">
        <AtomNode start="(305, 9)" end="(305, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(305, 17)" end="(305, 39)">
          <IdentNode start="(305, 17)" end="(305, 39)" leading="" trailing=" " raw_val="find?_replicate_of_neg" val="find?_replicate_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(305, 40)" end="(305, 84)">
          <NullNode start="(305, 40)" end="(305, 51)">
            <TermExplicitbinderNode start="(305, 40)" end="(305, 51)">
              <AtomNode start="(305, 40)" end="(305, 41)" leading="" trailing="" val="("/>
              <NullNode start="(305, 41)" end="(305, 42)">
                <IdentNode start="(305, 41)" end="(305, 42)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(305, 43)" end="(305, 50)">
                <AtomNode start="(305, 43)" end="(305, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(305, 45)" end="(305, 50)" kind="«term¬_»">
                  <AtomNode start="(305, 45)" end="(305, 46)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(305, 47)" end="(305, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(305, 47)" end="(305, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(305, 49)" end="(305, 50)">
                      <IdentNode start="(305, 49)" end="(305, 50)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(305, 50)" end="(305, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(305, 52)" end="(305, 84)">
            <AtomNode start="(305, 52)" end="(305, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(305, 54)" end="(305, 84)" kind="«term_=_»">
              <OtherNode start="(305, 54)" end="(305, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(305, 54)" end="(305, 59)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(305, 60)" end="(305, 77)">
                  <IdentNode start="(305, 60)" end="(305, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(305, 62)" end="(305, 77)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(305, 62)" end="(305, 63)" leading="" trailing="" val="("/>
                    <OtherNode start="(305, 63)" end="(305, 76)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(305, 63)" end="(305, 72)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(305, 73)" end="(305, 76)">
                        <IdentNode start="(305, 73)" end="(305, 74)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(305, 75)" end="(305, 76)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(305, 76)" end="(305, 77)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(305, 78)" end="(305, 79)" leading="" trailing=" " val="="/>
              <IdentNode start="(305, 80)" end="(305, 84)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(305, 85)" end="(306, 28)">
          <AtomNode start="(305, 85)" end="(305, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(305, 88)" end="(306, 28)">
            <AtomNode start="(305, 88)" end="(305, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(306, 3)" end="(306, 28)">
              <TacticTacticseq1IndentedNode start="(306, 3)" end="(306, 28)">
                <NullNode start="(306, 3)" end="(306, 28)">
                  <OtherNode start="(306, 3)" end="(306, 28)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;h : ¬p a = true&#10;⊢ find? p (replicate n a) = none" state_after="no goals" tactic="simp [find?_replicate, h]">
                    <AtomNode start="(306, 3)" end="(306, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(306, 8)" end="(306, 28)">
                      <AtomNode start="(306, 8)" end="(306, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(306, 9)" end="(306, 27)">
                        <OtherNode start="(306, 9)" end="(306, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(306, 9)" end="(306, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="Array.find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(284, 9)" def_end="(284, 24)"/>
                        </OtherNode>
                        <AtomNode start="(306, 24)" end="(306, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(306, 26)" end="(306, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(306, 26)" end="(306, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(306, 27)" end="(306, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(308, 1)" end="(309, 55)" name="find?_mkArray_of_neg" full_name="Array.find?_mkArray_of_neg">
      <CommandDeclmodifiersNode start="(308, 1)" end="(308, 61)">
        <NullNode/>
        <NullNode start="(308, 1)" end="(308, 61)">
          <OtherNode start="(308, 1)" end="(308, 61)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(308, 1)" end="(308, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(308, 3)" end="(308, 60)">
              <OtherNode start="(308, 3)" end="(308, 60)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(308, 3)" end="(308, 60)" kind="Lean.deprecated">
                  <AtomNode start="(308, 3)" end="(308, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(308, 14)" end="(308, 36)">
                    <IdentNode start="(308, 14)" end="(308, 36)" leading="" trailing=" " raw_val="find?_replicate_of_neg" val="find?_replicate_of_neg" full_name="Array.find?_replicate_of_neg" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(305, 17)" def_end="(305, 39)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(308, 37)" end="(308, 60)">
                    <AtomNode start="(308, 37)" end="(308, 38)" leading="" trailing="" val="("/>
                    <AtomNode start="(308, 38)" end="(308, 43)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(308, 44)" end="(308, 46)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(308, 47)" end="(308, 59)" kind="str">
                      <AtomNode start="(308, 47)" end="(308, 59)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(308, 59)" end="(308, 60)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(308, 60)" end="(308, 61)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(309, 1)" end="(309, 55)" name="find?_mkArray_of_neg">
        <AtomNode start="(309, 1)" end="(309, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(309, 8)" end="(309, 28)">
          <IdentNode start="(309, 8)" end="(309, 28)" leading="" trailing=" " raw_val="find?_mkArray_of_neg" val="find?_mkArray_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(309, 29)" end="(309, 55)">
          <AtomNode start="(309, 29)" end="(309, 31)" leading="" trailing=" " val=":="/>
          <OtherNode start="(309, 32)" end="(309, 55)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(309, 32)" end="(309, 33)" leading="" trailing="" val="@"/>
            <IdentNode start="(309, 33)" end="(309, 55)" leading="" trailing="&#10;&#10;-- This isn't a `@[simp]` lemma since there is already a lemma for `l.find? p = none` for any `l`.&#10;" raw_val="find?_replicate_of_neg" val="find?_replicate_of_neg" full_name="Array.find?_replicate_of_neg" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(305, 17)" def_end="(305, 39)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(312, 1)" end="(314, 99)" name="find?_replicate_eq_none_iff" full_name="Array.find?_replicate_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(312, 1)" end="(314, 99)" name="find?_replicate_eq_none_iff" full_name="Array.find?_replicate_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(312, 1)" end="(312, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(312, 9)" end="(312, 36)">
          <IdentNode start="(312, 9)" end="(312, 36)" leading="" trailing=" " raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(312, 37)" end="(313, 50)">
          <NullNode start="(312, 37)" end="(312, 69)">
            <OtherNode start="(312, 37)" end="(312, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(312, 37)" end="(312, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(312, 38)" end="(312, 39)">
                <IdentNode start="(312, 38)" end="(312, 39)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(312, 40)" end="(312, 45)">
                <AtomNode start="(312, 40)" end="(312, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(312, 42)" end="(312, 45)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(312, 45)" end="(312, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(312, 47)" end="(312, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(312, 47)" end="(312, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(312, 48)" end="(312, 49)">
                <IdentNode start="(312, 48)" end="(312, 49)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(312, 50)" end="(312, 53)">
                <AtomNode start="(312, 50)" end="(312, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(312, 52)" end="(312, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(312, 53)" end="(312, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(312, 55)" end="(312, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(312, 55)" end="(312, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(312, 56)" end="(312, 57)">
                <IdentNode start="(312, 56)" end="(312, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(312, 58)" end="(312, 68)">
                <AtomNode start="(312, 58)" end="(312, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(312, 60)" end="(312, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(312, 60)" end="(312, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(312, 62)" end="(312, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(312, 64)" end="(312, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(312, 68)" end="(312, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(312, 70)" end="(313, 50)">
            <AtomNode start="(312, 70)" end="(312, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(313, 5)" end="(313, 50)" kind="«term_↔_»">
              <OtherNode start="(313, 5)" end="(313, 35)" kind="«term_=_»">
                <OtherNode start="(313, 5)" end="(313, 28)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(313, 5)" end="(313, 26)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(313, 5)" end="(313, 20)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(313, 5)" end="(313, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(313, 6)" end="(313, 19)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(313, 6)" end="(313, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        <NullNode start="(313, 16)" end="(313, 19)">
                          <IdentNode start="(313, 16)" end="(313, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          <IdentNode start="(313, 18)" end="(313, 19)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(313, 19)" end="(313, 20)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(313, 20)" end="(313, 21)" leading="" trailing="" val="."/>
                    <IdentNode start="(313, 21)" end="(313, 26)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(313, 27)" end="(313, 28)">
                    <IdentNode start="(313, 27)" end="(313, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(313, 29)" end="(313, 30)" leading="" trailing=" " val="="/>
                <IdentNode start="(313, 31)" end="(313, 35)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(313, 36)" end="(313, 37)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(313, 38)" end="(313, 50)" kind="«term_∨_»">
                <OtherNode start="(313, 38)" end="(313, 43)" kind="«term_=_»">
                  <IdentNode start="(313, 38)" end="(313, 39)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(313, 40)" end="(313, 41)" leading="" trailing=" " val="="/>
                  <OtherNode start="(313, 42)" end="(313, 43)" kind="num">
                    <AtomNode start="(313, 42)" end="(313, 43)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(313, 44)" end="(313, 45)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(313, 46)" end="(313, 50)" kind="term!_">
                  <AtomNode start="(313, 46)" end="(313, 47)" leading="" trailing="" val="!"/>
                  <OtherNode start="(313, 47)" end="(313, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(313, 47)" end="(313, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(313, 49)" end="(313, 50)">
                      <IdentNode start="(313, 49)" end="(313, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(313, 51)" end="(314, 99)">
          <AtomNode start="(313, 51)" end="(313, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(313, 54)" end="(314, 99)">
            <AtomNode start="(313, 54)" end="(313, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(314, 3)" end="(314, 99)">
              <TacticTacticseq1IndentedNode start="(314, 3)" end="(314, 99)">
                <NullNode start="(314, 3)" end="(314, 99)">
                  <OtherNode start="(314, 3)" end="(314, 99)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ find? p (replicate n a) = none ↔ n = 0 ∨ (!p a) = true" state_after="no goals" tactic="simp [← List.toArray_replicate, List.find?_replicate_eq_none_iff, Classical.or_iff_not_imp_left]">
                    <AtomNode start="(314, 3)" end="(314, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(314, 8)" end="(314, 99)">
                      <AtomNode start="(314, 8)" end="(314, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(314, 9)" end="(314, 98)">
                        <OtherNode start="(314, 9)" end="(314, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(314, 9)" end="(314, 10)">
                            <OtherNode start="(314, 9)" end="(314, 10)" kind="patternIgnore">
                              <OtherNode start="(314, 9)" end="(314, 10)" kind="token.«← »">
                                <AtomNode start="(314, 9)" end="(314, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(314, 11)" end="(314, 33)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(314, 33)" end="(314, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(314, 35)" end="(314, 67)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(314, 35)" end="(314, 67)" leading="" trailing="" raw_val="List.find?_replicate_eq_none_iff" val="List.find?_replicate_eq_none_iff" full_name="List.find?_replicate_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(314, 67)" end="(314, 68)" leading="" trailing=" " val=","/>
                        <OtherNode start="(314, 69)" end="(314, 98)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(314, 69)" end="(314, 98)" leading="" trailing="" raw_val="Classical.or_iff_not_imp_left" val="Classical.or_iff_not_imp_left" full_name="Classical.or_iff_not_imp_left" mod_name="Init.Classical" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Classical.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(314, 98)" end="(314, 99)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(316, 1)" end="(317, 65)" name="find?_mkArray_eq_none_iff" full_name="Array.find?_mkArray_eq_none_iff">
      <CommandDeclmodifiersNode start="(316, 1)" end="(316, 66)">
        <NullNode/>
        <NullNode start="(316, 1)" end="(316, 66)">
          <OtherNode start="(316, 1)" end="(316, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(316, 1)" end="(316, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(316, 3)" end="(316, 65)">
              <OtherNode start="(316, 3)" end="(316, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(316, 3)" end="(316, 65)" kind="Lean.deprecated">
                  <AtomNode start="(316, 3)" end="(316, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(316, 14)" end="(316, 41)">
                    <IdentNode start="(316, 14)" end="(316, 41)" leading="" trailing=" " raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff" full_name="Array.find?_replicate_eq_none_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(312, 9)" def_end="(312, 36)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(316, 42)" end="(316, 65)">
                    <AtomNode start="(316, 42)" end="(316, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(316, 43)" end="(316, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(316, 49)" end="(316, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(316, 52)" end="(316, 64)" kind="str">
                      <AtomNode start="(316, 52)" end="(316, 64)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(316, 64)" end="(316, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(316, 65)" end="(316, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(317, 1)" end="(317, 65)" name="find?_mkArray_eq_none_iff">
        <AtomNode start="(317, 1)" end="(317, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(317, 8)" end="(317, 33)">
          <IdentNode start="(317, 8)" end="(317, 33)" leading="" trailing=" " raw_val="find?_mkArray_eq_none_iff" val="find?_mkArray_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(317, 34)" end="(317, 65)">
          <AtomNode start="(317, 34)" end="(317, 36)" leading="" trailing=" " val=":="/>
          <OtherNode start="(317, 37)" end="(317, 65)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(317, 37)" end="(317, 38)" leading="" trailing="" val="@"/>
            <IdentNode start="(317, 38)" end="(317, 65)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff" full_name="Array.find?_replicate_eq_none_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(312, 9)" def_end="(312, 36)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(319, 1)" end="(321, 34)" name="find?_replicate_eq_some_iff" full_name="Array.find?_replicate_eq_some_iff">
      <CommandDeclmodifiersNode start="(319, 1)" end="(319, 8)">
        <NullNode/>
        <NullNode start="(319, 1)" end="(319, 8)">
          <OtherNode start="(319, 1)" end="(319, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(319, 1)" end="(319, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(319, 3)" end="(319, 7)">
              <OtherNode start="(319, 3)" end="(319, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(319, 3)" end="(319, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(319, 3)" end="(319, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(319, 7)" end="(319, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(319, 9)" end="(321, 34)" name="find?_replicate_eq_some_iff" full_name="Array.find?_replicate_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(319, 9)" end="(319, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(319, 17)" end="(319, 44)">
          <IdentNode start="(319, 17)" end="(319, 44)" leading="" trailing=" " raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(319, 45)" end="(320, 59)">
          <NullNode start="(319, 45)" end="(319, 79)">
            <OtherNode start="(319, 45)" end="(319, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(319, 45)" end="(319, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(319, 46)" end="(319, 47)">
                <IdentNode start="(319, 46)" end="(319, 47)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(319, 48)" end="(319, 53)">
                <AtomNode start="(319, 48)" end="(319, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(319, 50)" end="(319, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(319, 53)" end="(319, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(319, 55)" end="(319, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(319, 55)" end="(319, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(319, 56)" end="(319, 59)">
                <IdentNode start="(319, 56)" end="(319, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(319, 58)" end="(319, 59)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(319, 60)" end="(319, 63)">
                <AtomNode start="(319, 60)" end="(319, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(319, 62)" end="(319, 63)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(319, 63)" end="(319, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(319, 65)" end="(319, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(319, 65)" end="(319, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(319, 66)" end="(319, 67)">
                <IdentNode start="(319, 66)" end="(319, 67)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(319, 68)" end="(319, 78)">
                <AtomNode start="(319, 68)" end="(319, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(319, 70)" end="(319, 78)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(319, 70)" end="(319, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(319, 72)" end="(319, 73)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(319, 74)" end="(319, 78)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(319, 78)" end="(319, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(319, 80)" end="(320, 59)">
            <AtomNode start="(319, 80)" end="(319, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(320, 5)" end="(320, 59)" kind="«term_↔_»">
              <OtherNode start="(320, 5)" end="(320, 37)" kind="«term_=_»">
                <OtherNode start="(320, 5)" end="(320, 28)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(320, 5)" end="(320, 26)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(320, 5)" end="(320, 20)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(320, 5)" end="(320, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(320, 6)" end="(320, 19)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(320, 6)" end="(320, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        <NullNode start="(320, 16)" end="(320, 19)">
                          <IdentNode start="(320, 16)" end="(320, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          <IdentNode start="(320, 18)" end="(320, 19)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(320, 19)" end="(320, 20)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(320, 20)" end="(320, 21)" leading="" trailing="" val="."/>
                    <IdentNode start="(320, 21)" end="(320, 26)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(320, 27)" end="(320, 28)">
                    <IdentNode start="(320, 27)" end="(320, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(320, 29)" end="(320, 30)" leading="" trailing=" " val="="/>
                <OtherNode start="(320, 31)" end="(320, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(320, 31)" end="(320, 35)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(320, 36)" end="(320, 37)">
                    <IdentNode start="(320, 36)" end="(320, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(320, 38)" end="(320, 39)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(320, 40)" end="(320, 59)" kind="«term_∧_»">
                <OtherNode start="(320, 40)" end="(320, 45)" kind="«term_≠_»">
                  <IdentNode start="(320, 40)" end="(320, 41)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(320, 42)" end="(320, 43)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(320, 44)" end="(320, 45)" kind="num">
                    <AtomNode start="(320, 44)" end="(320, 45)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(320, 46)" end="(320, 47)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(320, 48)" end="(320, 59)" kind="«term_∧_»">
                  <OtherNode start="(320, 48)" end="(320, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(320, 48)" end="(320, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(320, 50)" end="(320, 51)">
                      <IdentNode start="(320, 50)" end="(320, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(320, 52)" end="(320, 53)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(320, 54)" end="(320, 59)" kind="«term_=_»">
                    <IdentNode start="(320, 54)" end="(320, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(320, 56)" end="(320, 57)" leading="" trailing=" " val="="/>
                    <IdentNode start="(320, 58)" end="(320, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(320, 60)" end="(321, 34)">
          <AtomNode start="(320, 60)" end="(320, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(320, 63)" end="(321, 34)">
            <AtomNode start="(320, 63)" end="(320, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(321, 3)" end="(321, 34)">
              <TacticTacticseq1IndentedNode start="(321, 3)" end="(321, 34)">
                <NullNode start="(321, 3)" end="(321, 34)">
                  <OtherNode start="(321, 3)" end="(321, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a b : α&#10;p : α → Bool&#10;⊢ find? p (replicate n a) = some b ↔ n ≠ 0 ∧ p a = true ∧ a = b" state_after="no goals" tactic="simp [← List.toArray_replicate]">
                    <AtomNode start="(321, 3)" end="(321, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(321, 8)" end="(321, 34)">
                      <AtomNode start="(321, 8)" end="(321, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(321, 9)" end="(321, 33)">
                        <OtherNode start="(321, 9)" end="(321, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(321, 9)" end="(321, 10)">
                            <OtherNode start="(321, 9)" end="(321, 10)" kind="patternIgnore">
                              <OtherNode start="(321, 9)" end="(321, 10)" kind="token.«← »">
                                <AtomNode start="(321, 9)" end="(321, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(321, 11)" end="(321, 33)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(321, 33)" end="(321, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(323, 1)" end="(324, 65)" name="find?_mkArray_eq_some_iff" full_name="Array.find?_mkArray_eq_some_iff">
      <CommandDeclmodifiersNode start="(323, 1)" end="(323, 66)">
        <NullNode/>
        <NullNode start="(323, 1)" end="(323, 66)">
          <OtherNode start="(323, 1)" end="(323, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(323, 1)" end="(323, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(323, 3)" end="(323, 65)">
              <OtherNode start="(323, 3)" end="(323, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(323, 3)" end="(323, 65)" kind="Lean.deprecated">
                  <AtomNode start="(323, 3)" end="(323, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(323, 14)" end="(323, 41)">
                    <IdentNode start="(323, 14)" end="(323, 41)" leading="" trailing=" " raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="Array.find?_replicate_eq_some_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(319, 17)" def_end="(319, 44)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(323, 42)" end="(323, 65)">
                    <AtomNode start="(323, 42)" end="(323, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(323, 43)" end="(323, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(323, 49)" end="(323, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(323, 52)" end="(323, 64)" kind="str">
                      <AtomNode start="(323, 52)" end="(323, 64)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(323, 64)" end="(323, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(323, 65)" end="(323, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(324, 1)" end="(324, 65)" name="find?_mkArray_eq_some_iff">
        <AtomNode start="(324, 1)" end="(324, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(324, 8)" end="(324, 33)">
          <IdentNode start="(324, 8)" end="(324, 33)" leading="" trailing=" " raw_val="find?_mkArray_eq_some_iff" val="find?_mkArray_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(324, 34)" end="(324, 65)">
          <AtomNode start="(324, 34)" end="(324, 36)" leading="" trailing=" " val=":="/>
          <OtherNode start="(324, 37)" end="(324, 65)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(324, 37)" end="(324, 38)" leading="" trailing="" val="@"/>
            <IdentNode start="(324, 38)" end="(324, 65)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="Array.find?_replicate_eq_some_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(319, 17)" def_end="(319, 44)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(326, 1)" end="(327, 61)" name="find?_mkArray_eq_some" full_name="Array.find?_mkArray_eq_some">
      <CommandDeclmodifiersNode start="(326, 1)" end="(326, 66)">
        <NullNode/>
        <NullNode start="(326, 1)" end="(326, 66)">
          <OtherNode start="(326, 1)" end="(326, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(326, 1)" end="(326, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(326, 3)" end="(326, 65)">
              <OtherNode start="(326, 3)" end="(326, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(326, 3)" end="(326, 65)" kind="Lean.deprecated">
                  <AtomNode start="(326, 3)" end="(326, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(326, 14)" end="(326, 41)">
                    <IdentNode start="(326, 14)" end="(326, 41)" leading="" trailing=" " raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="Array.find?_replicate_eq_some_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(319, 17)" def_end="(319, 44)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(326, 42)" end="(326, 65)">
                    <AtomNode start="(326, 42)" end="(326, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(326, 43)" end="(326, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(326, 49)" end="(326, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(326, 52)" end="(326, 64)" kind="str">
                      <AtomNode start="(326, 52)" end="(326, 64)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(326, 64)" end="(326, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(326, 65)" end="(326, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(327, 1)" end="(327, 61)" name="find?_mkArray_eq_some">
        <AtomNode start="(327, 1)" end="(327, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(327, 8)" end="(327, 29)">
          <IdentNode start="(327, 8)" end="(327, 29)" leading="" trailing=" " raw_val="find?_mkArray_eq_some" val="find?_mkArray_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(327, 30)" end="(327, 61)">
          <AtomNode start="(327, 30)" end="(327, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(327, 33)" end="(327, 61)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(327, 33)" end="(327, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(327, 34)" end="(327, 61)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="Array.find?_replicate_eq_some_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(319, 17)" def_end="(319, 44)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(329, 1)" end="(331, 34)" name="get_find?_replicate" full_name="Array.get_find?_replicate">
      <CommandDeclmodifiersNode start="(329, 1)" end="(329, 8)">
        <NullNode/>
        <NullNode start="(329, 1)" end="(329, 8)">
          <OtherNode start="(329, 1)" end="(329, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(329, 1)" end="(329, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(329, 3)" end="(329, 7)">
              <OtherNode start="(329, 3)" end="(329, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(329, 3)" end="(329, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(329, 3)" end="(329, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(329, 7)" end="(329, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(329, 9)" end="(331, 34)" name="get_find?_replicate" full_name="Array.get_find?_replicate" _is_private_decl="False">
        <AtomNode start="(329, 9)" end="(329, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(329, 17)" end="(329, 36)">
          <IdentNode start="(329, 17)" end="(329, 36)" leading="" trailing=" " raw_val="get_find?_replicate" val="get_find?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(329, 37)" end="(330, 40)">
          <NullNode start="(329, 37)" end="(329, 73)">
            <OtherNode start="(329, 37)" end="(329, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(329, 37)" end="(329, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(329, 38)" end="(329, 39)">
                <IdentNode start="(329, 38)" end="(329, 39)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(329, 40)" end="(329, 45)">
                <AtomNode start="(329, 40)" end="(329, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(329, 42)" end="(329, 45)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(329, 45)" end="(329, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(329, 47)" end="(329, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(329, 47)" end="(329, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(329, 48)" end="(329, 49)">
                <IdentNode start="(329, 48)" end="(329, 49)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(329, 50)" end="(329, 53)">
                <AtomNode start="(329, 50)" end="(329, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(329, 52)" end="(329, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(329, 53)" end="(329, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(329, 55)" end="(329, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(329, 55)" end="(329, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(329, 56)" end="(329, 57)">
                <IdentNode start="(329, 56)" end="(329, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(329, 58)" end="(329, 68)">
                <AtomNode start="(329, 58)" end="(329, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(329, 60)" end="(329, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(329, 60)" end="(329, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(329, 62)" end="(329, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(329, 64)" end="(329, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(329, 68)" end="(329, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(329, 70)" end="(329, 73)">
              <AtomNode start="(329, 70)" end="(329, 71)" leading="" trailing="" val="("/>
              <NullNode start="(329, 71)" end="(329, 72)">
                <IdentNode start="(329, 71)" end="(329, 72)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(329, 72)" end="(329, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(329, 74)" end="(330, 40)">
            <AtomNode start="(329, 74)" end="(329, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(330, 5)" end="(330, 40)" kind="«term_=_»">
              <OtherNode start="(330, 5)" end="(330, 36)" kind="Lean.Parser.Term.app">
                <OtherNode start="(330, 5)" end="(330, 34)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(330, 5)" end="(330, 30)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(330, 5)" end="(330, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(330, 6)" end="(330, 29)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(330, 6)" end="(330, 27)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(330, 6)" end="(330, 21)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(330, 6)" end="(330, 7)" leading="" trailing="" val="("/>
                          <OtherNode start="(330, 7)" end="(330, 20)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(330, 7)" end="(330, 16)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                            <NullNode start="(330, 17)" end="(330, 20)">
                              <IdentNode start="(330, 17)" end="(330, 18)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(330, 19)" end="(330, 20)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(330, 20)" end="(330, 21)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(330, 21)" end="(330, 22)" leading="" trailing="" val="."/>
                        <IdentNode start="(330, 22)" end="(330, 27)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      </OtherNode>
                      <NullNode start="(330, 28)" end="(330, 29)">
                        <IdentNode start="(330, 28)" end="(330, 29)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(330, 29)" end="(330, 30)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(330, 30)" end="(330, 31)" leading="" trailing="" val="."/>
                  <IdentNode start="(330, 31)" end="(330, 34)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(330, 35)" end="(330, 36)">
                  <IdentNode start="(330, 35)" end="(330, 36)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(330, 37)" end="(330, 38)" leading="" trailing=" " val="="/>
              <IdentNode start="(330, 39)" end="(330, 40)" leading="" trailing=" " raw_val="a" val="a"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(330, 41)" end="(331, 34)">
          <AtomNode start="(330, 41)" end="(330, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(330, 44)" end="(331, 34)">
            <AtomNode start="(330, 44)" end="(330, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(331, 3)" end="(331, 34)">
              <TacticTacticseq1IndentedNode start="(331, 3)" end="(331, 34)">
                <NullNode start="(331, 3)" end="(331, 34)">
                  <OtherNode start="(331, 3)" end="(331, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;h : (find? p (replicate n a)).isSome = true&#10;⊢ (find? p (replicate n a)).get h = a" state_after="no goals" tactic="simp [← List.toArray_replicate]">
                    <AtomNode start="(331, 3)" end="(331, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(331, 8)" end="(331, 34)">
                      <AtomNode start="(331, 8)" end="(331, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(331, 9)" end="(331, 33)">
                        <OtherNode start="(331, 9)" end="(331, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(331, 9)" end="(331, 10)">
                            <OtherNode start="(331, 9)" end="(331, 10)" kind="patternIgnore">
                              <OtherNode start="(331, 9)" end="(331, 10)" kind="token.«← »">
                                <AtomNode start="(331, 9)" end="(331, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(331, 11)" end="(331, 33)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(331, 33)" end="(331, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(333, 1)" end="(334, 49)" name="get_find?_mkArray" full_name="Array.get_find?_mkArray">
      <CommandDeclmodifiersNode start="(333, 1)" end="(333, 58)">
        <NullNode/>
        <NullNode start="(333, 1)" end="(333, 58)">
          <OtherNode start="(333, 1)" end="(333, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(333, 1)" end="(333, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(333, 3)" end="(333, 57)">
              <OtherNode start="(333, 3)" end="(333, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(333, 3)" end="(333, 57)" kind="Lean.deprecated">
                  <AtomNode start="(333, 3)" end="(333, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(333, 14)" end="(333, 33)">
                    <IdentNode start="(333, 14)" end="(333, 33)" leading="" trailing=" " raw_val="get_find?_replicate" val="get_find?_replicate" full_name="Array.get_find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(329, 17)" def_end="(329, 36)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(333, 34)" end="(333, 57)">
                    <AtomNode start="(333, 34)" end="(333, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(333, 35)" end="(333, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(333, 41)" end="(333, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(333, 44)" end="(333, 56)" kind="str">
                      <AtomNode start="(333, 44)" end="(333, 56)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(333, 56)" end="(333, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(333, 57)" end="(333, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(334, 1)" end="(334, 49)" name="get_find?_mkArray">
        <AtomNode start="(334, 1)" end="(334, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(334, 8)" end="(334, 25)">
          <IdentNode start="(334, 8)" end="(334, 25)" leading="" trailing=" " raw_val="get_find?_mkArray" val="get_find?_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(334, 26)" end="(334, 49)">
          <AtomNode start="(334, 26)" end="(334, 28)" leading="" trailing=" " val=":="/>
          <OtherNode start="(334, 29)" end="(334, 49)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(334, 29)" end="(334, 30)" leading="" trailing="" val="@"/>
            <IdentNode start="(334, 30)" end="(334, 49)" leading="" trailing="&#10;&#10;" raw_val="get_find?_replicate" val="get_find?_replicate" full_name="Array.get_find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(329, 17)" def_end="(329, 36)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(336, 1)" end="(340, 6)" name="find?_pmap" full_name="Array.find?_pmap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(336, 1)" end="(340, 6)" name="find?_pmap" full_name="Array.find?_pmap" _is_private_decl="False">
        <AtomNode start="(336, 1)" end="(336, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(336, 9)" end="(336, 19)">
          <IdentNode start="(336, 9)" end="(336, 19)" leading="" trailing=" " raw_val="find?_pmap" val="find?_pmap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(336, 20)" end="(338, 108)">
          <NullNode start="(336, 20)" end="(337, 49)">
            <OtherNode start="(336, 20)" end="(336, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(336, 20)" end="(336, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(336, 21)" end="(336, 22)">
                <IdentNode start="(336, 21)" end="(336, 22)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(336, 23)" end="(336, 33)">
                <AtomNode start="(336, 23)" end="(336, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(336, 25)" end="(336, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(336, 25)" end="(336, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(336, 27)" end="(336, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(336, 29)" end="(336, 33)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(336, 29)" end="(336, 33)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(336, 33)" end="(336, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(336, 35)" end="(336, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(336, 35)" end="(336, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(336, 36)" end="(336, 37)">
                <IdentNode start="(336, 36)" end="(336, 37)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(336, 38)" end="(336, 57)">
                <AtomNode start="(336, 38)" end="(336, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(336, 40)" end="(336, 57)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(336, 40)" end="(336, 47)">
                    <AtomNode start="(336, 40)" end="(336, 41)" leading="" trailing="" val="("/>
                    <NullNode start="(336, 41)" end="(336, 42)">
                      <IdentNode start="(336, 41)" end="(336, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(336, 43)" end="(336, 46)">
                      <AtomNode start="(336, 43)" end="(336, 44)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(336, 45)" end="(336, 46)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(336, 46)" end="(336, 47)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(336, 48)" end="(336, 49)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(336, 50)" end="(336, 57)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(336, 50)" end="(336, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(336, 50)" end="(336, 51)" leading="" trailing=" " raw_val="P" val="P"/>
                      <NullNode start="(336, 52)" end="(336, 53)">
                        <IdentNode start="(336, 52)" end="(336, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(336, 54)" end="(336, 55)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(336, 56)" end="(336, 57)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(336, 57)" end="(336, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(336, 59)" end="(336, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(336, 59)" end="(336, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(336, 60)" end="(336, 62)">
                <IdentNode start="(336, 60)" end="(336, 62)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(336, 63)" end="(336, 72)">
                <AtomNode start="(336, 63)" end="(336, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(336, 65)" end="(336, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(336, 65)" end="(336, 70)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(336, 71)" end="(336, 72)">
                    <IdentNode start="(336, 71)" end="(336, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(336, 72)" end="(336, 73)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(337, 5)" end="(337, 34)">
              <AtomNode start="(337, 5)" end="(337, 6)" leading="" trailing="" val="("/>
              <NullNode start="(337, 6)" end="(337, 7)">
                <IdentNode start="(337, 6)" end="(337, 7)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode start="(337, 8)" end="(337, 33)">
                <AtomNode start="(337, 8)" end="(337, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(337, 10)" end="(337, 33)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(337, 10)" end="(337, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(337, 12)" end="(337, 19)">
                    <TermExplicitbinderNode start="(337, 12)" end="(337, 19)">
                      <AtomNode start="(337, 12)" end="(337, 13)" leading="" trailing="" val="("/>
                      <NullNode start="(337, 13)" end="(337, 14)">
                        <IdentNode start="(337, 13)" end="(337, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                      <NullNode start="(337, 15)" end="(337, 18)">
                        <AtomNode start="(337, 15)" end="(337, 16)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(337, 17)" end="(337, 18)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(337, 18)" end="(337, 19)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(337, 19)" end="(337, 20)" leading="" trailing=" " val=","/>
                  <OtherNode start="(337, 21)" end="(337, 33)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(337, 21)" end="(337, 27)" kind="«term_∈_»">
                      <IdentNode start="(337, 21)" end="(337, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(337, 23)" end="(337, 24)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(337, 25)" end="(337, 27)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(337, 28)" end="(337, 29)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(337, 30)" end="(337, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(337, 30)" end="(337, 31)" leading="" trailing=" " raw_val="P" val="P"/>
                      <NullNode start="(337, 32)" end="(337, 33)">
                        <IdentNode start="(337, 32)" end="(337, 33)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(337, 33)" end="(337, 34)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(337, 35)" end="(337, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(337, 35)" end="(337, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(337, 36)" end="(337, 37)">
                <IdentNode start="(337, 36)" end="(337, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(337, 38)" end="(337, 48)">
                <AtomNode start="(337, 38)" end="(337, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(337, 40)" end="(337, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(337, 40)" end="(337, 41)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(337, 42)" end="(337, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(337, 44)" end="(337, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(337, 48)" end="(337, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(337, 50)" end="(338, 108)">
            <AtomNode start="(337, 50)" end="(337, 51)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(338, 5)" end="(338, 108)" kind="«term_=_»">
              <OtherNode start="(338, 5)" end="(338, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(338, 5)" end="(338, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(338, 5)" end="(338, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(338, 5)" end="(338, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(338, 6)" end="(338, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(338, 6)" end="(338, 13)" leading="" trailing=" " raw_val="xs.pmap" val="xs.pmap"/>
                      <NullNode start="(338, 14)" end="(338, 17)">
                        <IdentNode start="(338, 14)" end="(338, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(338, 16)" end="(338, 17)" leading="" trailing="" raw_val="H" val="H"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(338, 17)" end="(338, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(338, 18)" end="(338, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(338, 19)" end="(338, 24)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(338, 25)" end="(338, 26)">
                  <IdentNode start="(338, 25)" end="(338, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(338, 27)" end="(338, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(338, 29)" end="(338, 108)" kind="Lean.Parser.Term.app">
                <OtherNode start="(338, 29)" end="(338, 82)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(338, 29)" end="(338, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(338, 29)" end="(338, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(338, 30)" end="(338, 77)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(338, 30)" end="(338, 45)" leading="" trailing=" " raw_val="xs.attach.find?" val="xs.attach.find?"/>
                      <NullNode start="(338, 46)" end="(338, 77)">
                        <OtherNode start="(338, 46)" end="(338, 77)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(338, 46)" end="(338, 47)" leading="" trailing="" val="("/>
                          <OtherNode start="(338, 47)" end="(338, 76)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(338, 47)" end="(338, 50)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(338, 51)" end="(338, 76)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(338, 51)" end="(338, 57)">
                                <OtherNode start="(338, 51)" end="(338, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(338, 51)" end="(338, 52)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(338, 52)" end="(338, 56)">
                                    <IdentNode start="(338, 52)" end="(338, 53)" leading="" trailing="" raw_val="a" val="a"/>
                                    <AtomNode start="(338, 53)" end="(338, 54)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(338, 55)" end="(338, 56)" leading="" trailing="" raw_val="m" val="m"/>
                                  </NullNode>
                                  <AtomNode start="(338, 56)" end="(338, 57)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(338, 58)" end="(338, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(338, 61)" end="(338, 76)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(338, 61)" end="(338, 62)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(338, 63)" end="(338, 76)">
                                  <OtherNode start="(338, 63)" end="(338, 76)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(338, 63)" end="(338, 64)" leading="" trailing="" val="("/>
                                    <OtherNode start="(338, 64)" end="(338, 75)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(338, 64)" end="(338, 65)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(338, 66)" end="(338, 75)">
                                        <IdentNode start="(338, 66)" end="(338, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <OtherNode start="(338, 68)" end="(338, 75)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(338, 68)" end="(338, 69)" leading="" trailing="" val="("/>
                                          <OtherNode start="(338, 69)" end="(338, 74)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(338, 69)" end="(338, 70)" leading="" trailing=" " raw_val="H" val="H"/>
                                            <NullNode start="(338, 71)" end="(338, 74)">
                                              <IdentNode start="(338, 71)" end="(338, 72)" leading="" trailing=" " raw_val="a" val="a"/>
                                              <IdentNode start="(338, 73)" end="(338, 74)" leading="" trailing="" raw_val="m" val="m"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(338, 74)" end="(338, 75)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(338, 75)" end="(338, 76)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(338, 76)" end="(338, 77)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(338, 77)" end="(338, 78)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(338, 78)" end="(338, 79)" leading="" trailing="" val="."/>
                  <IdentNode start="(338, 79)" end="(338, 82)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(338, 83)" end="(338, 108)">
                  <OtherNode start="(338, 83)" end="(338, 108)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(338, 83)" end="(338, 86)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(338, 87)" end="(338, 108)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(338, 87)" end="(338, 93)">
                        <OtherNode start="(338, 87)" end="(338, 93)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(338, 87)" end="(338, 88)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(338, 88)" end="(338, 92)">
                            <IdentNode start="(338, 88)" end="(338, 89)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(338, 89)" end="(338, 90)" leading="" trailing=" " val=","/>
                            <IdentNode start="(338, 91)" end="(338, 92)" leading="" trailing="" raw_val="m" val="m"/>
                          </NullNode>
                          <AtomNode start="(338, 92)" end="(338, 93)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(338, 94)" end="(338, 96)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(338, 97)" end="(338, 108)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(338, 97)" end="(338, 98)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(338, 99)" end="(338, 108)">
                          <IdentNode start="(338, 99)" end="(338, 100)" leading="" trailing=" " raw_val="a" val="a"/>
                          <OtherNode start="(338, 101)" end="(338, 108)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(338, 101)" end="(338, 102)" leading="" trailing="" val="("/>
                            <OtherNode start="(338, 102)" end="(338, 107)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(338, 102)" end="(338, 103)" leading="" trailing=" " raw_val="H" val="H"/>
                              <NullNode start="(338, 104)" end="(338, 107)">
                                <IdentNode start="(338, 104)" end="(338, 105)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(338, 106)" end="(338, 107)" leading="" trailing="" raw_val="m" val="m"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(338, 107)" end="(338, 108)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(338, 109)" end="(340, 6)">
          <AtomNode start="(338, 109)" end="(338, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(338, 112)" end="(340, 6)">
            <AtomNode start="(338, 112)" end="(338, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(339, 3)" end="(340, 6)">
              <TacticTacticseq1IndentedNode start="(339, 3)" end="(340, 6)">
                <NullNode start="(339, 3)" end="(340, 6)">
                  <OtherNode start="(339, 3)" end="(339, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : Array α&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ find? p (pmap f xs H) =&#10;    Option.map&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨a, m⟩ =&amp;gt; f a ⋯)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m⟩ =&amp;gt; p (f a ⋯))&#10;        xs.attach)" state_after="α : Type u_1&#10;β : Type u_2&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : Array α&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ Option.map (fun x =&amp;gt; f x.val ⋯) (find? (p ∘ fun x =&amp;gt; f x.val ⋯) xs.attach) =&#10;    Option.map (fun x =&amp;gt; f x.val ⋯) (find? (fun x =&amp;gt; p (f x.val ⋯)) xs.attach)" tactic="simp only [pmap_eq_map_attach, find?_map]">
                    <AtomNode start="(339, 3)" end="(339, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(339, 8)" end="(339, 12)">
                      <AtomNode start="(339, 8)" end="(339, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(339, 13)" end="(339, 44)">
                      <AtomNode start="(339, 13)" end="(339, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(339, 14)" end="(339, 43)">
                        <OtherNode start="(339, 14)" end="(339, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(339, 14)" end="(339, 32)" leading="" trailing="" raw_val="pmap_eq_map_attach" val="pmap_eq_map_attach" full_name="Array.pmap_eq_map_attach" mod_name="Init.Data.Array.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Attach.lean"/>
                        </OtherNode>
                        <AtomNode start="(339, 32)" end="(339, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(339, 34)" end="(339, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(339, 34)" end="(339, 43)" leading="" trailing="" raw_val="find?_map" val="find?_map" full_name="Array.find?_map" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(222, 17)" def_end="(222, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(339, 43)" end="(339, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(340, 3)" end="(340, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : Array α&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ Option.map (fun x =&amp;gt; f x.val ⋯) (find? (p ∘ fun x =&amp;gt; f x.val ⋯) xs.attach) =&#10;    Option.map (fun x =&amp;gt; f x.val ⋯) (find? (fun x =&amp;gt; p (f x.val ⋯)) xs.attach)" state_after="no goals" tactic="rfl">
                    <AtomNode start="(340, 3)" end="(340, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(342, 1)" end="(345, 40)" name="find?_eq_some_iff_getElem" full_name="Array.find?_eq_some_iff_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(342, 1)" end="(345, 40)" name="find?_eq_some_iff_getElem" full_name="Array.find?_eq_some_iff_getElem" _is_private_decl="False">
        <AtomNode start="(342, 1)" end="(342, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(342, 9)" end="(342, 34)">
          <IdentNode start="(342, 9)" end="(342, 34)" leading="" trailing=" " raw_val="find?_eq_some_iff_getElem" val="find?_eq_some_iff_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(342, 35)" end="(343, 86)">
          <NullNode start="(342, 35)" end="(342, 72)">
            <OtherNode start="(342, 35)" end="(342, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 35)" end="(342, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 36)" end="(342, 38)">
                <IdentNode start="(342, 36)" end="(342, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(342, 39)" end="(342, 48)">
                <AtomNode start="(342, 39)" end="(342, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 41)" end="(342, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(342, 41)" end="(342, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(342, 47)" end="(342, 48)">
                    <IdentNode start="(342, 47)" end="(342, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 48)" end="(342, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(342, 50)" end="(342, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 50)" end="(342, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 51)" end="(342, 52)">
                <IdentNode start="(342, 51)" end="(342, 52)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(342, 53)" end="(342, 63)">
                <AtomNode start="(342, 53)" end="(342, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 55)" end="(342, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(342, 55)" end="(342, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(342, 57)" end="(342, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(342, 59)" end="(342, 63)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 63)" end="(342, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(342, 65)" end="(342, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 65)" end="(342, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 66)" end="(342, 67)">
                <IdentNode start="(342, 66)" end="(342, 67)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(342, 68)" end="(342, 71)">
                <AtomNode start="(342, 68)" end="(342, 69)" leading="" trailing=" " val=":"/>
                <IdentNode start="(342, 70)" end="(342, 71)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(342, 71)" end="(342, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(342, 73)" end="(343, 86)">
            <AtomNode start="(342, 73)" end="(342, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(343, 5)" end="(343, 86)" kind="«term_↔_»">
              <OtherNode start="(343, 5)" end="(343, 24)" kind="«term_=_»">
                <OtherNode start="(343, 5)" end="(343, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(343, 5)" end="(343, 13)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                  <NullNode start="(343, 14)" end="(343, 15)">
                    <IdentNode start="(343, 14)" end="(343, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(343, 16)" end="(343, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(343, 18)" end="(343, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(343, 18)" end="(343, 22)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(343, 23)" end="(343, 24)">
                    <IdentNode start="(343, 23)" end="(343, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(343, 25)" end="(343, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(343, 27)" end="(343, 86)" kind="«term_∧_»">
                <OtherNode start="(343, 27)" end="(343, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(343, 27)" end="(343, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(343, 29)" end="(343, 30)">
                    <IdentNode start="(343, 29)" end="(343, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(343, 31)" end="(343, 32)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(343, 33)" end="(343, 86)" kind="«term∃_,_»">
                  <AtomNode start="(343, 33)" end="(343, 34)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(343, 35)" end="(343, 38)" kind="Lean.explicitBinders">
                    <OtherNode start="(343, 35)" end="(343, 38)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(343, 35)" end="(343, 38)">
                        <LeanBinderidentNode start="(343, 35)" end="(343, 36)">
                          <IdentNode start="(343, 35)" end="(343, 36)" leading="" trailing=" " raw_val="i" val="i"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(343, 37)" end="(343, 38)">
                          <IdentNode start="(343, 37)" end="(343, 38)" leading="" trailing="" raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(343, 38)" end="(343, 39)" leading="" trailing=" " val=","/>
                  <OtherNode start="(343, 40)" end="(343, 86)" kind="«term_∧_»">
                    <OtherNode start="(343, 40)" end="(343, 49)" kind="«term_=_»">
                      <OtherNode start="(343, 40)" end="(343, 45)" kind="«term__[_]»">
                        <IdentNode start="(343, 40)" end="(343, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <AtomNode start="(343, 42)" end="(343, 43)" leading="" trailing="" val="["/>
                        <IdentNode start="(343, 43)" end="(343, 44)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(343, 44)" end="(343, 45)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <AtomNode start="(343, 46)" end="(343, 47)" leading="" trailing=" " val="="/>
                      <IdentNode start="(343, 48)" end="(343, 49)" leading="" trailing=" " raw_val="b" val="b"/>
                    </OtherNode>
                    <AtomNode start="(343, 50)" end="(343, 51)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(343, 52)" end="(343, 86)" kind="Lean.Parser.Term.forall">
                      <AtomNode start="(343, 52)" end="(343, 53)" leading="" trailing=" " val="∀"/>
                      <NullNode start="(343, 54)" end="(343, 55)">
                        <IdentNode start="(343, 54)" end="(343, 55)" leading="" trailing=" " raw_val="j" val="j"/>
                      </NullNode>
                      <NullNode start="(343, 56)" end="(343, 61)">
                        <TermTypespecNode start="(343, 56)" end="(343, 61)">
                          <AtomNode start="(343, 56)" end="(343, 57)" leading="" trailing=" " val=":"/>
                          <IdentNode start="(343, 58)" end="(343, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </TermTypespecNode>
                      </NullNode>
                      <AtomNode start="(343, 61)" end="(343, 62)" leading="" trailing=" " val=","/>
                      <OtherNode start="(343, 63)" end="(343, 86)" kind="Lean.Parser.Term.depArrow">
                        <TermExplicitbinderNode start="(343, 63)" end="(343, 75)">
                          <AtomNode start="(343, 63)" end="(343, 64)" leading="" trailing="" val="("/>
                          <NullNode start="(343, 64)" end="(343, 66)">
                            <IdentNode start="(343, 64)" end="(343, 66)" leading="" trailing=" " raw_val="hj" val="hj"/>
                          </NullNode>
                          <NullNode start="(343, 67)" end="(343, 74)">
                            <AtomNode start="(343, 67)" end="(343, 68)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(343, 69)" end="(343, 74)" kind="«term_&amp;lt;_»">
                              <IdentNode start="(343, 69)" end="(343, 70)" leading="" trailing=" " raw_val="j" val="j"/>
                              <AtomNode start="(343, 71)" end="(343, 72)" leading="" trailing=" " val="&amp;lt;"/>
                              <IdentNode start="(343, 73)" end="(343, 74)" leading="" trailing="" raw_val="i" val="i"/>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(343, 74)" end="(343, 75)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                        <AtomNode start="(343, 76)" end="(343, 77)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(343, 78)" end="(343, 86)" kind="term!_">
                          <AtomNode start="(343, 78)" end="(343, 79)" leading="" trailing="" val="!"/>
                          <OtherNode start="(343, 79)" end="(343, 86)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(343, 79)" end="(343, 80)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(343, 81)" end="(343, 86)">
                              <OtherNode start="(343, 81)" end="(343, 86)" kind="«term__[_]»">
                                <IdentNode start="(343, 81)" end="(343, 83)" leading="" trailing="" raw_val="xs" val="xs"/>
                                <AtomNode start="(343, 83)" end="(343, 84)" leading="" trailing="" val="["/>
                                <IdentNode start="(343, 84)" end="(343, 85)" leading="" trailing="" raw_val="j" val="j"/>
                                <AtomNode start="(343, 85)" end="(343, 86)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(343, 87)" end="(345, 40)">
          <AtomNode start="(343, 87)" end="(343, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(343, 90)" end="(345, 40)">
            <AtomNode start="(343, 90)" end="(343, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(344, 3)" end="(345, 40)">
              <TacticTacticseq1IndentedNode start="(344, 3)" end="(345, 40)">
                <NullNode start="(344, 3)" end="(345, 40)">
                  <OtherNode start="(344, 3)" end="(344, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;b : α&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ i h, xs[i] = b ∧ ∀ (j : Nat) (hj : j &amp;lt; i), (!p xs[j]) = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;⊢ find? p { toList := xs } = some b ↔&#10;    p b = true ∧ ∃ i h, { toList := xs }[i] = b ∧ ∀ (j : Nat) (hj : j &amp;lt; i), (!p { toList := xs }[j]) = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(344, 3)" end="(344, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(344, 10)" end="(344, 12)">
                      <OtherNode start="(344, 10)" end="(344, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(344, 10)" end="(344, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(344, 13)" end="(344, 22)">
                      <AtomNode start="(344, 13)" end="(344, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(344, 18)" end="(344, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(344, 18)" end="(344, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(344, 18)" end="(344, 22)">
                            <OtherNode start="(344, 18)" end="(344, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(344, 18)" end="(344, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(344, 19)" end="(344, 21)">
                                <OtherNode start="(344, 19)" end="(344, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(344, 19)" end="(344, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(344, 19)" end="(344, 21)">
                                      <OtherNode start="(344, 19)" end="(344, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(344, 19)" end="(344, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(344, 21)" end="(344, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(345, 3)" end="(345, 40)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;xs : List α&#10;⊢ find? p { toList := xs } = some b ↔&#10;    p b = true ∧ ∃ i h, { toList := xs }[i] = b ∧ ∀ (j : Nat) (hj : j &amp;lt; i), (!p { toList := xs }[j]) = true" state_after="no goals" tactic="simp [List.find?_eq_some_iff_getElem]">
                    <AtomNode start="(345, 3)" end="(345, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(345, 8)" end="(345, 40)">
                      <AtomNode start="(345, 8)" end="(345, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(345, 9)" end="(345, 39)">
                        <OtherNode start="(345, 9)" end="(345, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(345, 9)" end="(345, 39)" leading="" trailing="" raw_val="List.find?_eq_some_iff_getElem" val="List.find?_eq_some_iff_getElem" full_name="List.find?_eq_some_iff_getElem" mod_name="Init.Data.List.Nat.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(345, 39)" end="(345, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(347, 1)" end="(347, 19)" comment="### findIdx -/">
      <AtomNode start="(347, 1)" end="(347, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(347, 5)" end="(347, 19)" leading="" trailing="&#10;&#10;" val="### findIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(349, 1)" end="(349, 57)" name="findIdx_empty" full_name="Array.findIdx_empty">
      <CommandDeclmodifiersNode start="(349, 1)" end="(349, 8)">
        <NullNode/>
        <NullNode start="(349, 1)" end="(349, 8)">
          <OtherNode start="(349, 1)" end="(349, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(349, 1)" end="(349, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(349, 3)" end="(349, 7)">
              <OtherNode start="(349, 3)" end="(349, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(349, 3)" end="(349, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(349, 3)" end="(349, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(349, 7)" end="(349, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(349, 9)" end="(349, 57)" name="findIdx_empty" full_name="Array.findIdx_empty" _is_private_decl="False">
        <AtomNode start="(349, 9)" end="(349, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(349, 17)" end="(349, 30)">
          <IdentNode start="(349, 17)" end="(349, 30)" leading="" trailing=" " raw_val="findIdx_empty" val="findIdx_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(349, 31)" end="(349, 50)">
          <NullNode/>
          <TermTypespecNode start="(349, 31)" end="(349, 50)">
            <AtomNode start="(349, 31)" end="(349, 32)" leading="" trailing=" " val=":"/>
            <OtherNode start="(349, 33)" end="(349, 50)" kind="«term_=_»">
              <OtherNode start="(349, 33)" end="(349, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(349, 33)" end="(349, 40)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="Array.findIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(349, 41)" end="(349, 46)">
                  <IdentNode start="(349, 41)" end="(349, 42)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(349, 43)" end="(349, 46)" kind="«term#[_,]»">
                    <AtomNode start="(349, 43)" end="(349, 45)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(349, 45)" end="(349, 46)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(349, 47)" end="(349, 48)" leading="" trailing=" " val="="/>
              <OtherNode start="(349, 49)" end="(349, 50)" kind="num">
                <AtomNode start="(349, 49)" end="(349, 50)" leading="" trailing=" " val="0"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(349, 51)" end="(349, 57)">
          <AtomNode start="(349, 51)" end="(349, 53)" leading="" trailing=" " val=":="/>
          <IdentNode start="(349, 54)" end="(349, 57)" leading="" trailing="&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(350, 1)" end="(352, 7)" name="findIdx_singleton" full_name="Array.findIdx_singleton">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(350, 1)" end="(352, 7)" name="findIdx_singleton" full_name="Array.findIdx_singleton" _is_private_decl="False">
        <AtomNode start="(350, 1)" end="(350, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(350, 9)" end="(350, 26)">
          <IdentNode start="(350, 9)" end="(350, 26)" leading="" trailing=" " raw_val="findIdx_singleton" val="findIdx_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(350, 27)" end="(351, 42)">
          <NullNode start="(350, 27)" end="(350, 49)">
            <OtherNode start="(350, 27)" end="(350, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(350, 27)" end="(350, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(350, 28)" end="(350, 29)">
                <IdentNode start="(350, 28)" end="(350, 29)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(350, 30)" end="(350, 33)">
                <AtomNode start="(350, 30)" end="(350, 31)" leading="" trailing=" " val=":"/>
                <IdentNode start="(350, 32)" end="(350, 33)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(350, 33)" end="(350, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(350, 35)" end="(350, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(350, 35)" end="(350, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(350, 36)" end="(350, 37)">
                <IdentNode start="(350, 36)" end="(350, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(350, 38)" end="(350, 48)">
                <AtomNode start="(350, 38)" end="(350, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(350, 40)" end="(350, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(350, 40)" end="(350, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(350, 42)" end="(350, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(350, 44)" end="(350, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(350, 48)" end="(350, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(350, 50)" end="(351, 42)">
            <AtomNode start="(350, 50)" end="(350, 51)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(351, 5)" end="(351, 42)" kind="«term_=_»">
              <OtherNode start="(351, 5)" end="(351, 19)" kind="Lean.Parser.Term.app">
                <OtherNode start="(351, 5)" end="(351, 17)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(351, 5)" end="(351, 9)" kind="«term#[_,]»">
                    <AtomNode start="(351, 5)" end="(351, 7)" leading="" trailing="" val="#["/>
                    <NullNode start="(351, 7)" end="(351, 8)">
                      <IdentNode start="(351, 7)" end="(351, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(351, 8)" end="(351, 9)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(351, 9)" end="(351, 10)" leading="" trailing="" val="."/>
                  <IdentNode start="(351, 10)" end="(351, 17)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="Array.findIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(351, 18)" end="(351, 19)">
                  <IdentNode start="(351, 18)" end="(351, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(351, 20)" end="(351, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(351, 22)" end="(351, 42)" kind="termIfThenElse">
                <AtomNode start="(351, 22)" end="(351, 24)" leading="" trailing=" " val="if"/>
                <OtherNode start="(351, 25)" end="(351, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(351, 25)" end="(351, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(351, 27)" end="(351, 28)">
                    <IdentNode start="(351, 27)" end="(351, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(351, 29)" end="(351, 33)" leading="" trailing=" " val="then"/>
                <OtherNode start="(351, 34)" end="(351, 35)" kind="num">
                  <AtomNode start="(351, 34)" end="(351, 35)" leading="" trailing=" " val="0"/>
                </OtherNode>
                <AtomNode start="(351, 36)" end="(351, 40)" leading="" trailing=" " val="else"/>
                <OtherNode start="(351, 41)" end="(351, 42)" kind="num">
                  <AtomNode start="(351, 41)" end="(351, 42)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(351, 43)" end="(352, 7)">
          <AtomNode start="(351, 43)" end="(351, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(351, 46)" end="(352, 7)">
            <AtomNode start="(351, 46)" end="(351, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(352, 3)" end="(352, 7)">
              <TacticTacticseq1IndentedNode start="(352, 3)" end="(352, 7)">
                <NullNode start="(352, 3)" end="(352, 7)">
                  <OtherNode start="(352, 3)" end="(352, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ findIdx p #[a] = if p a = true then 0 else 1" state_after="no goals" tactic="simp">
                    <AtomNode start="(352, 3)" end="(352, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(354, 1)" end="(356, 60)" name="findIdx_of_getElem?_eq_some" full_name="Array.findIdx_of_getElem?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(354, 1)" end="(356, 60)" name="findIdx_of_getElem?_eq_some" full_name="Array.findIdx_of_getElem?_eq_some" _is_private_decl="False">
        <AtomNode start="(354, 1)" end="(354, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(354, 9)" end="(354, 36)">
          <IdentNode start="(354, 9)" end="(354, 36)" leading="" trailing=" " raw_val="findIdx_of_getElem?_eq_some" val="findIdx_of_getElem?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(354, 37)" end="(354, 90)">
          <NullNode start="(354, 37)" end="(354, 84)">
            <OtherNode start="(354, 37)" end="(354, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(354, 37)" end="(354, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(354, 38)" end="(354, 40)">
                <IdentNode start="(354, 38)" end="(354, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(354, 41)" end="(354, 50)">
                <AtomNode start="(354, 41)" end="(354, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(354, 43)" end="(354, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(354, 43)" end="(354, 48)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(354, 49)" end="(354, 50)">
                    <IdentNode start="(354, 49)" end="(354, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(354, 50)" end="(354, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(354, 52)" end="(354, 84)">
              <AtomNode start="(354, 52)" end="(354, 53)" leading="" trailing="" val="("/>
              <NullNode start="(354, 53)" end="(354, 54)">
                <IdentNode start="(354, 53)" end="(354, 54)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(354, 55)" end="(354, 83)">
                <AtomNode start="(354, 55)" end="(354, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(354, 57)" end="(354, 83)" kind="«term_=_»">
                  <OtherNode start="(354, 57)" end="(354, 74)" kind="«term__[_]_?»">
                    <IdentNode start="(354, 57)" end="(354, 59)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <GroupNode/>
                    <AtomNode start="(354, 59)" end="(354, 60)" leading="" trailing="" val="["/>
                    <OtherNode start="(354, 60)" end="(354, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(354, 60)" end="(354, 70)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(354, 71)" end="(354, 72)">
                        <IdentNode start="(354, 71)" end="(354, 72)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(354, 72)" end="(354, 73)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(354, 73)" end="(354, 74)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(354, 75)" end="(354, 76)" leading="" trailing=" " val="="/>
                  <OtherNode start="(354, 77)" end="(354, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(354, 77)" end="(354, 81)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(354, 82)" end="(354, 83)">
                      <IdentNode start="(354, 82)" end="(354, 83)" leading="" trailing="" raw_val="y" val="y"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(354, 83)" end="(354, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(354, 85)" end="(354, 90)">
            <AtomNode start="(354, 85)" end="(354, 86)" leading="" trailing=" " val=":"/>
            <OtherNode start="(354, 87)" end="(354, 90)" kind="Lean.Parser.Term.app">
              <IdentNode start="(354, 87)" end="(354, 88)" leading="" trailing=" " raw_val="p" val="p"/>
              <NullNode start="(354, 89)" end="(354, 90)">
                <IdentNode start="(354, 89)" end="(354, 90)" leading="" trailing=" " raw_val="y" val="y"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(354, 91)" end="(356, 60)">
          <AtomNode start="(354, 91)" end="(354, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(354, 94)" end="(356, 60)">
            <AtomNode start="(354, 94)" end="(354, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(355, 3)" end="(356, 60)">
              <TacticTacticseq1IndentedNode start="(355, 3)" end="(356, 60)">
                <NullNode start="(355, 3)" end="(356, 60)">
                  <OtherNode start="(355, 3)" end="(355, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;y : α&#10;xs : Array α&#10;w : xs[findIdx p xs]? = some y&#10;⊢ p y = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;y : α&#10;xs : List α&#10;w : { toList := xs }[findIdx p { toList := xs }]? = some y&#10;⊢ p y = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(355, 3)" end="(355, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(355, 10)" end="(355, 12)">
                      <OtherNode start="(355, 10)" end="(355, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(355, 10)" end="(355, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(355, 13)" end="(355, 22)">
                      <AtomNode start="(355, 13)" end="(355, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(355, 18)" end="(355, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(355, 18)" end="(355, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(355, 18)" end="(355, 22)">
                            <OtherNode start="(355, 18)" end="(355, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(355, 18)" end="(355, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(355, 19)" end="(355, 21)">
                                <OtherNode start="(355, 19)" end="(355, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(355, 19)" end="(355, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(355, 19)" end="(355, 21)">
                                      <OtherNode start="(355, 19)" end="(355, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(355, 19)" end="(355, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(355, 21)" end="(355, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(356, 3)" end="(356, 60)" kind="Lean.Parser.Tactic.exact" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;y : α&#10;xs : List α&#10;w : { toList := xs }[findIdx p { toList := xs }]? = some y&#10;⊢ p y = true" state_after="no goals" tactic="exact List.findIdx_of_getElem?_eq_some (by simpa using w)">
                    <AtomNode start="(356, 3)" end="(356, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(356, 9)" end="(356, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(356, 9)" end="(356, 41)" leading="" trailing=" " raw_val="List.findIdx_of_getElem?_eq_some" val="List.findIdx_of_getElem?_eq_some" full_name="List.findIdx_of_getElem?_eq_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                      <NullNode start="(356, 42)" end="(356, 60)">
                        <OtherNode start="(356, 42)" end="(356, 60)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(356, 42)" end="(356, 43)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(356, 43)" end="(356, 59)">
                            <AtomNode start="(356, 43)" end="(356, 45)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(356, 46)" end="(356, 59)">
                              <TacticTacticseq1IndentedNode start="(356, 46)" end="(356, 59)">
                                <NullNode start="(356, 46)" end="(356, 59)">
                                  <OtherNode start="(356, 46)" end="(356, 59)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;y : α&#10;xs : List α&#10;w : { toList := xs }[findIdx p { toList := xs }]? = some y&#10;⊢ ?m.63321[List.findIdx p ?m.63321]? = some y" state_after="no goals" tactic="simpa using w">
                                    <AtomNode start="(356, 46)" end="(356, 51)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(356, 52)" end="(356, 59)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(356, 52)" end="(356, 59)">
                                        <AtomNode start="(356, 52)" end="(356, 57)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(356, 58)" end="(356, 59)" leading="" trailing="" raw_val="w" val="w"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(356, 59)" end="(356, 60)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(358, 1)" end="(360, 57)" name="findIdx_getElem" full_name="Array.findIdx_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(358, 1)" end="(360, 57)" name="findIdx_getElem" full_name="Array.findIdx_getElem" _is_private_decl="False">
        <AtomNode start="(358, 1)" end="(358, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(358, 9)" end="(358, 24)">
          <IdentNode start="(358, 9)" end="(358, 24)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(358, 25)" end="(359, 23)">
          <NullNode start="(358, 25)" end="(358, 68)">
            <OtherNode start="(358, 25)" end="(358, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(358, 25)" end="(358, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(358, 26)" end="(358, 28)">
                <IdentNode start="(358, 26)" end="(358, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(358, 29)" end="(358, 38)">
                <AtomNode start="(358, 29)" end="(358, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(358, 31)" end="(358, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(358, 31)" end="(358, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(358, 37)" end="(358, 38)">
                    <IdentNode start="(358, 37)" end="(358, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(358, 38)" end="(358, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(358, 40)" end="(358, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(358, 40)" end="(358, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(358, 41)" end="(358, 42)">
                <IdentNode start="(358, 41)" end="(358, 42)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(358, 43)" end="(358, 67)">
                <AtomNode start="(358, 43)" end="(358, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(358, 45)" end="(358, 67)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(358, 45)" end="(358, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(358, 45)" end="(358, 55)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(358, 56)" end="(358, 57)">
                      <IdentNode start="(358, 56)" end="(358, 57)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(358, 58)" end="(358, 59)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(358, 60)" end="(358, 67)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(358, 67)" end="(358, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(358, 69)" end="(359, 23)">
            <AtomNode start="(358, 69)" end="(358, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(359, 5)" end="(359, 23)" kind="Lean.Parser.Term.app">
              <IdentNode start="(359, 5)" end="(359, 6)" leading="" trailing=" " raw_val="p" val="p"/>
              <NullNode start="(359, 7)" end="(359, 23)">
                <OtherNode start="(359, 7)" end="(359, 23)" kind="«term__[_]»">
                  <IdentNode start="(359, 7)" end="(359, 9)" leading="" trailing="" raw_val="xs" val="xs"/>
                  <AtomNode start="(359, 9)" end="(359, 10)" leading="" trailing="" val="["/>
                  <OtherNode start="(359, 10)" end="(359, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(359, 10)" end="(359, 20)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(359, 21)" end="(359, 22)">
                      <IdentNode start="(359, 21)" end="(359, 22)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(359, 22)" end="(359, 23)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(359, 24)" end="(360, 57)">
          <AtomNode start="(359, 24)" end="(359, 26)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(360, 3)" end="(360, 57)" kind="Lean.Parser.Term.app">
            <IdentNode start="(360, 3)" end="(360, 33)" leading="" trailing=" " raw_val="xs.findIdx_of_getElem?_eq_some" val="xs.findIdx_of_getElem?_eq_some"/>
            <NullNode start="(360, 34)" end="(360, 57)">
              <OtherNode start="(360, 34)" end="(360, 57)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(360, 34)" end="(360, 35)" leading="" trailing="" val="("/>
                <OtherNode start="(360, 35)" end="(360, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(360, 35)" end="(360, 54)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="Array.getElem?_eq_getElem" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                  <NullNode start="(360, 55)" end="(360, 56)">
                    <IdentNode start="(360, 55)" end="(360, 56)" leading="" trailing="" raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(360, 56)" end="(360, 57)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(362, 1)" end="(365, 66)" name="findIdx_lt_size_of_exists" full_name="Array.findIdx_lt_size_of_exists">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(362, 1)" end="(365, 66)" name="findIdx_lt_size_of_exists" full_name="Array.findIdx_lt_size_of_exists" _is_private_decl="False">
        <AtomNode start="(362, 1)" end="(362, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(362, 9)" end="(362, 34)">
          <IdentNode start="(362, 9)" end="(362, 34)" leading="" trailing=" " raw_val="findIdx_lt_size_of_exists" val="findIdx_lt_size_of_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(362, 35)" end="(363, 27)">
          <NullNode start="(362, 35)" end="(362, 69)">
            <OtherNode start="(362, 35)" end="(362, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(362, 35)" end="(362, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(362, 36)" end="(362, 38)">
                <IdentNode start="(362, 36)" end="(362, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(362, 39)" end="(362, 48)">
                <AtomNode start="(362, 39)" end="(362, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(362, 41)" end="(362, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(362, 41)" end="(362, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(362, 47)" end="(362, 48)">
                    <IdentNode start="(362, 47)" end="(362, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(362, 48)" end="(362, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(362, 50)" end="(362, 69)">
              <AtomNode start="(362, 50)" end="(362, 51)" leading="" trailing="" val="("/>
              <NullNode start="(362, 51)" end="(362, 52)">
                <IdentNode start="(362, 51)" end="(362, 52)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(362, 53)" end="(362, 68)">
                <AtomNode start="(362, 53)" end="(362, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(362, 55)" end="(362, 68)" kind="Lean.«term∃__,_»">
                  <AtomNode start="(362, 55)" end="(362, 56)" leading="" trailing=" " val="∃"/>
                  <LeanBinderidentNode start="(362, 57)" end="(362, 58)">
                    <IdentNode start="(362, 57)" end="(362, 58)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(362, 59)" end="(362, 63)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(362, 59)" end="(362, 60)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(362, 61)" end="(362, 63)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(362, 63)" end="(362, 64)" leading="" trailing=" " val=","/>
                  <OtherNode start="(362, 65)" end="(362, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(362, 65)" end="(362, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(362, 67)" end="(362, 68)">
                      <IdentNode start="(362, 67)" end="(362, 68)" leading="" trailing="" raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(362, 68)" end="(362, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(362, 70)" end="(363, 27)">
            <AtomNode start="(362, 70)" end="(362, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(363, 5)" end="(363, 27)" kind="«term_&amp;lt;_»">
              <OtherNode start="(363, 5)" end="(363, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(363, 5)" end="(363, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(363, 16)" end="(363, 17)">
                  <IdentNode start="(363, 16)" end="(363, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(363, 18)" end="(363, 19)" leading="" trailing=" " val="&amp;lt;"/>
              <IdentNode start="(363, 20)" end="(363, 27)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(363, 28)" end="(365, 66)">
          <AtomNode start="(363, 28)" end="(363, 30)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(363, 31)" end="(365, 66)">
            <AtomNode start="(363, 31)" end="(363, 33)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(364, 3)" end="(365, 66)">
              <TacticTacticseq1IndentedNode start="(364, 3)" end="(365, 66)">
                <NullNode start="(364, 3)" end="(365, 66)">
                  <OtherNode start="(364, 3)" end="(364, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs &amp;lt; xs.size" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∃ x, x ∈ { toList := xs } ∧ p x = true&#10;⊢ findIdx p { toList := xs } &amp;lt; { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(364, 3)" end="(364, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(364, 10)" end="(364, 12)">
                      <OtherNode start="(364, 10)" end="(364, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(364, 10)" end="(364, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(364, 13)" end="(364, 22)">
                      <AtomNode start="(364, 13)" end="(364, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(364, 18)" end="(364, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(364, 18)" end="(364, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(364, 18)" end="(364, 22)">
                            <OtherNode start="(364, 18)" end="(364, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(364, 18)" end="(364, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(364, 19)" end="(364, 21)">
                                <OtherNode start="(364, 19)" end="(364, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(364, 19)" end="(364, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(364, 19)" end="(364, 21)">
                                      <OtherNode start="(364, 19)" end="(364, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(364, 19)" end="(364, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(364, 21)" end="(364, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(365, 3)" end="(365, 66)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∃ x, x ∈ { toList := xs } ∧ p x = true&#10;⊢ findIdx p { toList := xs } &amp;lt; { toList := xs }.size" state_after="no goals" tactic="simpa using List.findIdx_lt_length_of_exists (by simpa using h)">
                    <AtomNode start="(365, 3)" end="(365, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(365, 9)" end="(365, 66)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(365, 9)" end="(365, 66)">
                        <AtomNode start="(365, 9)" end="(365, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(365, 15)" end="(365, 66)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(365, 15)" end="(365, 47)" leading="" trailing=" " raw_val="List.findIdx_lt_length_of_exists" val="List.findIdx_lt_length_of_exists" full_name="List.findIdx_lt_length_of_exists" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                          <NullNode start="(365, 48)" end="(365, 66)">
                            <OtherNode start="(365, 48)" end="(365, 66)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(365, 48)" end="(365, 49)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(365, 49)" end="(365, 65)">
                                <AtomNode start="(365, 49)" end="(365, 51)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(365, 52)" end="(365, 65)">
                                  <TacticTacticseq1IndentedNode start="(365, 52)" end="(365, 65)">
                                    <NullNode start="(365, 52)" end="(365, 65)">
                                      <OtherNode start="(365, 52)" end="(365, 65)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∃ x, x ∈ { toList := xs } ∧ p x = true&#10;⊢ ∃ x, x ∈ xs ∧ p x = true" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(365, 52)" end="(365, 57)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(365, 58)" end="(365, 65)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(365, 58)" end="(365, 65)">
                                            <AtomNode start="(365, 58)" end="(365, 63)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(365, 64)" end="(365, 65)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(365, 65)" end="(365, 66)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(367, 1)" end="(369, 52)" name="findIdx_getElem?_eq_getElem_of_exists" full_name="Array.findIdx_getElem?_eq_getElem_of_exists">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(367, 1)" end="(369, 52)" name="findIdx_getElem?_eq_getElem_of_exists" full_name="Array.findIdx_getElem?_eq_getElem_of_exists" _is_private_decl="False">
        <AtomNode start="(367, 1)" end="(367, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(367, 9)" end="(367, 46)">
          <IdentNode start="(367, 9)" end="(367, 46)" leading="" trailing=" " raw_val="findIdx_getElem?_eq_getElem_of_exists" val="findIdx_getElem?_eq_getElem_of_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(367, 47)" end="(368, 81)">
          <NullNode start="(367, 47)" end="(367, 81)">
            <OtherNode start="(367, 47)" end="(367, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(367, 47)" end="(367, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(367, 48)" end="(367, 50)">
                <IdentNode start="(367, 48)" end="(367, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(367, 51)" end="(367, 60)">
                <AtomNode start="(367, 51)" end="(367, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(367, 53)" end="(367, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(367, 53)" end="(367, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(367, 59)" end="(367, 60)">
                    <IdentNode start="(367, 59)" end="(367, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(367, 60)" end="(367, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(367, 62)" end="(367, 81)">
              <AtomNode start="(367, 62)" end="(367, 63)" leading="" trailing="" val="("/>
              <NullNode start="(367, 63)" end="(367, 64)">
                <IdentNode start="(367, 63)" end="(367, 64)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(367, 65)" end="(367, 80)">
                <AtomNode start="(367, 65)" end="(367, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(367, 67)" end="(367, 80)" kind="Lean.«term∃__,_»">
                  <AtomNode start="(367, 67)" end="(367, 68)" leading="" trailing=" " val="∃"/>
                  <LeanBinderidentNode start="(367, 69)" end="(367, 70)">
                    <IdentNode start="(367, 69)" end="(367, 70)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(367, 71)" end="(367, 75)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(367, 71)" end="(367, 72)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(367, 73)" end="(367, 75)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(367, 75)" end="(367, 76)" leading="" trailing=" " val=","/>
                  <OtherNode start="(367, 77)" end="(367, 80)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(367, 77)" end="(367, 78)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(367, 79)" end="(367, 80)">
                      <IdentNode start="(367, 79)" end="(367, 80)" leading="" trailing="" raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(367, 80)" end="(367, 81)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(367, 82)" end="(368, 81)">
            <AtomNode start="(367, 82)" end="(367, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(368, 5)" end="(368, 81)" kind="«term_=_»">
              <OtherNode start="(368, 5)" end="(368, 22)" kind="«term__[_]_?»">
                <IdentNode start="(368, 5)" end="(368, 7)" leading="" trailing="" raw_val="xs" val="xs"/>
                <GroupNode/>
                <AtomNode start="(368, 7)" end="(368, 8)" leading="" trailing="" val="["/>
                <OtherNode start="(368, 8)" end="(368, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(368, 8)" end="(368, 18)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(368, 19)" end="(368, 20)">
                    <IdentNode start="(368, 19)" end="(368, 20)" leading="" trailing="" raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(368, 20)" end="(368, 21)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(368, 21)" end="(368, 22)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(368, 23)" end="(368, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(368, 25)" end="(368, 81)" kind="Lean.Parser.Term.app">
                <IdentNode start="(368, 25)" end="(368, 29)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(368, 30)" end="(368, 81)">
                  <OtherNode start="(368, 30)" end="(368, 81)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(368, 30)" end="(368, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(368, 31)" end="(368, 80)" kind="«term__[_]'_»">
                      <IdentNode start="(368, 31)" end="(368, 33)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(368, 33)" end="(368, 34)" leading="" trailing="" val="["/>
                      <OtherNode start="(368, 34)" end="(368, 46)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(368, 34)" end="(368, 44)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                        <NullNode start="(368, 45)" end="(368, 46)">
                          <IdentNode start="(368, 45)" end="(368, 46)" leading="" trailing="" raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(368, 46)" end="(368, 48)" leading="" trailing="" val="]'"/>
                      <OtherNode start="(368, 48)" end="(368, 80)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(368, 48)" end="(368, 49)" leading="" trailing="" val="("/>
                        <OtherNode start="(368, 49)" end="(368, 79)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(368, 49)" end="(368, 77)" leading="" trailing=" " raw_val="xs.findIdx_lt_size_of_exists" val="xs.findIdx_lt_size_of_exists"/>
                          <NullNode start="(368, 78)" end="(368, 79)">
                            <IdentNode start="(368, 78)" end="(368, 79)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(368, 79)" end="(368, 80)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(368, 80)" end="(368, 81)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(368, 82)" end="(369, 52)">
          <AtomNode start="(368, 82)" end="(368, 84)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(369, 3)" end="(369, 52)" kind="Lean.Parser.Term.app">
            <IdentNode start="(369, 3)" end="(369, 22)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="Array.getElem?_eq_getElem" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
            <NullNode start="(369, 23)" end="(369, 52)">
              <OtherNode start="(369, 23)" end="(369, 52)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(369, 23)" end="(369, 24)" leading="" trailing="" val="("/>
                <OtherNode start="(369, 24)" end="(369, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(369, 24)" end="(369, 49)" leading="" trailing=" " raw_val="findIdx_lt_size_of_exists" val="findIdx_lt_size_of_exists" full_name="Array.findIdx_lt_size_of_exists" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(362, 9)" def_end="(362, 34)"/>
                  <NullNode start="(369, 50)" end="(369, 51)">
                    <IdentNode start="(369, 50)" end="(369, 51)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(369, 51)" end="(369, 52)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(371, 1)" end="(375, 7)" name="findIdx_eq_size" full_name="Array.findIdx_eq_size">
      <CommandDeclmodifiersNode start="(371, 1)" end="(371, 8)">
        <NullNode/>
        <NullNode start="(371, 1)" end="(371, 8)">
          <OtherNode start="(371, 1)" end="(371, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(371, 1)" end="(371, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(371, 3)" end="(371, 7)">
              <OtherNode start="(371, 3)" end="(371, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(371, 3)" end="(371, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(371, 3)" end="(371, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(371, 7)" end="(371, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(372, 1)" end="(375, 7)" name="findIdx_eq_size" full_name="Array.findIdx_eq_size" _is_private_decl="False">
        <AtomNode start="(372, 1)" end="(372, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(372, 9)" end="(372, 24)">
          <IdentNode start="(372, 9)" end="(372, 24)" leading="" trailing=" " raw_val="findIdx_eq_size" val="findIdx_eq_size"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(372, 25)" end="(373, 51)">
          <NullNode start="(372, 25)" end="(372, 54)">
            <OtherNode start="(372, 25)" end="(372, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(372, 25)" end="(372, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(372, 26)" end="(372, 27)">
                <IdentNode start="(372, 26)" end="(372, 27)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(372, 28)" end="(372, 38)">
                <AtomNode start="(372, 28)" end="(372, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(372, 30)" end="(372, 38)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(372, 30)" end="(372, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(372, 32)" end="(372, 33)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(372, 34)" end="(372, 38)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(372, 38)" end="(372, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(372, 40)" end="(372, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(372, 40)" end="(372, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(372, 41)" end="(372, 43)">
                <IdentNode start="(372, 41)" end="(372, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(372, 44)" end="(372, 53)">
                <AtomNode start="(372, 44)" end="(372, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(372, 46)" end="(372, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(372, 46)" end="(372, 51)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(372, 52)" end="(372, 53)">
                    <IdentNode start="(372, 52)" end="(372, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(372, 53)" end="(372, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(372, 55)" end="(373, 51)">
            <AtomNode start="(372, 55)" end="(372, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(373, 5)" end="(373, 51)" kind="«term_↔_»">
              <OtherNode start="(373, 5)" end="(373, 27)" kind="«term_=_»">
                <OtherNode start="(373, 5)" end="(373, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(373, 5)" end="(373, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(373, 16)" end="(373, 17)">
                    <IdentNode start="(373, 16)" end="(373, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(373, 18)" end="(373, 19)" leading="" trailing=" " val="="/>
                <IdentNode start="(373, 20)" end="(373, 27)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
              </OtherNode>
              <AtomNode start="(373, 28)" end="(373, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(373, 30)" end="(373, 51)" kind="Lean.«term∀__,_»">
                <AtomNode start="(373, 30)" end="(373, 31)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(373, 32)" end="(373, 33)">
                  <IdentNode start="(373, 32)" end="(373, 33)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(373, 34)" end="(373, 38)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(373, 34)" end="(373, 35)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(373, 36)" end="(373, 38)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(373, 38)" end="(373, 39)" leading="" trailing=" " val=","/>
                <OtherNode start="(373, 40)" end="(373, 51)" kind="«term_=_»">
                  <OtherNode start="(373, 40)" end="(373, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(373, 40)" end="(373, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(373, 42)" end="(373, 43)">
                      <IdentNode start="(373, 42)" end="(373, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(373, 44)" end="(373, 45)" leading="" trailing=" " val="="/>
                  <IdentNode start="(373, 46)" end="(373, 51)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(373, 52)" end="(375, 7)">
          <AtomNode start="(373, 52)" end="(373, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(373, 55)" end="(375, 7)">
            <AtomNode start="(373, 55)" end="(373, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(374, 3)" end="(375, 7)">
              <TacticTacticseq1IndentedNode start="(374, 3)" end="(375, 7)">
                <NullNode start="(374, 3)" end="(375, 7)">
                  <OtherNode start="(374, 3)" end="(374, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findIdx p xs = xs.size ↔ ∀ (x : α), x ∈ xs → p x = false" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p { toList := xs } = { toList := xs }.size ↔ ∀ (x : α), x ∈ { toList := xs } → p x = false" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(374, 3)" end="(374, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(374, 10)" end="(374, 12)">
                      <OtherNode start="(374, 10)" end="(374, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(374, 10)" end="(374, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(374, 13)" end="(374, 22)">
                      <AtomNode start="(374, 13)" end="(374, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(374, 18)" end="(374, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(374, 18)" end="(374, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(374, 18)" end="(374, 22)">
                            <OtherNode start="(374, 18)" end="(374, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(374, 18)" end="(374, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(374, 19)" end="(374, 21)">
                                <OtherNode start="(374, 19)" end="(374, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(374, 19)" end="(374, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(374, 19)" end="(374, 21)">
                                      <OtherNode start="(374, 19)" end="(374, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(374, 19)" end="(374, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(374, 21)" end="(374, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(375, 3)" end="(375, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p { toList := xs } = { toList := xs }.size ↔ ∀ (x : α), x ∈ { toList := xs } → p x = false" state_after="no goals" tactic="simp">
                    <AtomNode start="(375, 3)" end="(375, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(377, 1)" end="(380, 11)" name="findIdx_eq_size_of_false" full_name="Array.findIdx_eq_size_of_false">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(377, 1)" end="(380, 11)" name="findIdx_eq_size_of_false" full_name="Array.findIdx_eq_size_of_false" _is_private_decl="False">
        <AtomNode start="(377, 1)" end="(377, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(377, 9)" end="(377, 33)">
          <IdentNode start="(377, 9)" end="(377, 33)" leading="" trailing=" " raw_val="findIdx_eq_size_of_false" val="findIdx_eq_size_of_false"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(377, 34)" end="(378, 27)">
          <NullNode start="(377, 34)" end="(377, 91)">
            <OtherNode start="(377, 34)" end="(377, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(377, 34)" end="(377, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(377, 35)" end="(377, 36)">
                <IdentNode start="(377, 35)" end="(377, 36)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(377, 37)" end="(377, 47)">
                <AtomNode start="(377, 37)" end="(377, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(377, 39)" end="(377, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(377, 39)" end="(377, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(377, 41)" end="(377, 42)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(377, 43)" end="(377, 47)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(377, 47)" end="(377, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(377, 49)" end="(377, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(377, 49)" end="(377, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(377, 50)" end="(377, 52)">
                <IdentNode start="(377, 50)" end="(377, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(377, 53)" end="(377, 62)">
                <AtomNode start="(377, 53)" end="(377, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(377, 55)" end="(377, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(377, 55)" end="(377, 60)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(377, 61)" end="(377, 62)">
                    <IdentNode start="(377, 61)" end="(377, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(377, 62)" end="(377, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(377, 64)" end="(377, 91)">
              <AtomNode start="(377, 64)" end="(377, 65)" leading="" trailing="" val="("/>
              <NullNode start="(377, 65)" end="(377, 66)">
                <IdentNode start="(377, 65)" end="(377, 66)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(377, 67)" end="(377, 90)">
                <AtomNode start="(377, 67)" end="(377, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(377, 69)" end="(377, 90)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(377, 69)" end="(377, 70)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(377, 71)" end="(377, 72)">
                    <IdentNode start="(377, 71)" end="(377, 72)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(377, 73)" end="(377, 77)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(377, 73)" end="(377, 74)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(377, 75)" end="(377, 77)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(377, 77)" end="(377, 78)" leading="" trailing=" " val=","/>
                  <OtherNode start="(377, 79)" end="(377, 90)" kind="«term_=_»">
                    <OtherNode start="(377, 79)" end="(377, 82)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(377, 79)" end="(377, 80)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(377, 81)" end="(377, 82)">
                        <IdentNode start="(377, 81)" end="(377, 82)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(377, 83)" end="(377, 84)" leading="" trailing=" " val="="/>
                    <IdentNode start="(377, 85)" end="(377, 90)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(377, 90)" end="(377, 91)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(377, 92)" end="(378, 27)">
            <AtomNode start="(377, 92)" end="(377, 93)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(378, 5)" end="(378, 27)" kind="«term_=_»">
              <OtherNode start="(378, 5)" end="(378, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(378, 5)" end="(378, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(378, 16)" end="(378, 17)">
                  <IdentNode start="(378, 16)" end="(378, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(378, 18)" end="(378, 19)" leading="" trailing=" " val="="/>
              <IdentNode start="(378, 20)" end="(378, 27)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(378, 28)" end="(380, 11)">
          <AtomNode start="(378, 28)" end="(378, 30)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(378, 31)" end="(380, 11)">
            <AtomNode start="(378, 31)" end="(378, 33)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(379, 3)" end="(380, 11)">
              <TacticTacticseq1IndentedNode start="(379, 3)" end="(380, 11)">
                <NullNode start="(379, 3)" end="(380, 11)">
                  <OtherNode start="(379, 3)" end="(379, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx p xs = xs.size" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (x : α), x ∈ { toList := xs } → p x = false&#10;⊢ findIdx p { toList := xs } = { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(379, 3)" end="(379, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(379, 10)" end="(379, 12)">
                      <OtherNode start="(379, 10)" end="(379, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(379, 10)" end="(379, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(379, 13)" end="(379, 22)">
                      <AtomNode start="(379, 13)" end="(379, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(379, 18)" end="(379, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(379, 18)" end="(379, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(379, 18)" end="(379, 22)">
                            <OtherNode start="(379, 18)" end="(379, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(379, 18)" end="(379, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(379, 19)" end="(379, 21)">
                                <OtherNode start="(379, 19)" end="(379, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(379, 19)" end="(379, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(379, 19)" end="(379, 21)">
                                      <OtherNode start="(379, 19)" end="(379, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(379, 19)" end="(379, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(379, 21)" end="(379, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(380, 3)" end="(380, 11)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (x : α), x ∈ { toList := xs } → p x = false&#10;⊢ findIdx p { toList := xs } = { toList := xs }.size" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(380, 3)" end="(380, 11)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(382, 1)" end="(386, 47)" name="findIdx_le_size" full_name="Array.findIdx_le_size">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(382, 1)" end="(386, 47)" name="findIdx_le_size" full_name="Array.findIdx_le_size" _is_private_decl="False">
        <AtomNode start="(382, 1)" end="(382, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(382, 9)" end="(382, 24)">
          <IdentNode start="(382, 9)" end="(382, 24)" leading="" trailing=" " raw_val="findIdx_le_size" val="findIdx_le_size"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(382, 25)" end="(382, 79)">
          <NullNode start="(382, 25)" end="(382, 54)">
            <OtherNode start="(382, 25)" end="(382, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(382, 25)" end="(382, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(382, 26)" end="(382, 27)">
                <IdentNode start="(382, 26)" end="(382, 27)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(382, 28)" end="(382, 38)">
                <AtomNode start="(382, 28)" end="(382, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(382, 30)" end="(382, 38)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(382, 30)" end="(382, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(382, 32)" end="(382, 33)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(382, 34)" end="(382, 38)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(382, 38)" end="(382, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(382, 40)" end="(382, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(382, 40)" end="(382, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(382, 41)" end="(382, 43)">
                <IdentNode start="(382, 41)" end="(382, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(382, 44)" end="(382, 53)">
                <AtomNode start="(382, 44)" end="(382, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(382, 46)" end="(382, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(382, 46)" end="(382, 51)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(382, 52)" end="(382, 53)">
                    <IdentNode start="(382, 52)" end="(382, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(382, 53)" end="(382, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(382, 55)" end="(382, 79)">
            <AtomNode start="(382, 55)" end="(382, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(382, 57)" end="(382, 79)" kind="«term_≤_»">
              <OtherNode start="(382, 57)" end="(382, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(382, 57)" end="(382, 67)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(382, 68)" end="(382, 69)">
                  <IdentNode start="(382, 68)" end="(382, 69)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(382, 70)" end="(382, 71)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(382, 72)" end="(382, 79)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(382, 80)" end="(386, 47)">
          <AtomNode start="(382, 80)" end="(382, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(382, 83)" end="(386, 47)">
            <AtomNode start="(382, 83)" end="(382, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(383, 3)" end="(386, 47)">
              <TacticTacticseq1IndentedNode start="(383, 3)" end="(386, 47)">
                <NullNode start="(383, 3)" end="(386, 47)">
                  <OtherNode start="(383, 3)" end="(383, 29)" kind="«tacticBy_cases_:_»" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findIdx p xs ≤ xs.size" state_after="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size" tactic="by_cases e : ∃ x ∈ xs, p x">
                    <AtomNode start="(383, 3)" end="(383, 11)" leading="" trailing=" " val="by_cases"/>
                    <NullNode start="(383, 12)" end="(383, 15)">
                      <IdentNode start="(383, 12)" end="(383, 13)" leading="" trailing=" " raw_val="e" val="e"/>
                      <AtomNode start="(383, 14)" end="(383, 15)" leading="" trailing=" " val=":"/>
                    </NullNode>
                    <OtherNode start="(383, 16)" end="(383, 29)" kind="Lean.«term∃__,_»">
                      <AtomNode start="(383, 16)" end="(383, 17)" leading="" trailing=" " val="∃"/>
                      <LeanBinderidentNode start="(383, 18)" end="(383, 19)">
                        <IdentNode start="(383, 18)" end="(383, 19)" leading="" trailing=" " raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(383, 20)" end="(383, 24)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(383, 20)" end="(383, 21)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(383, 22)" end="(383, 24)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(383, 24)" end="(383, 25)" leading="" trailing=" " val=","/>
                      <OtherNode start="(383, 26)" end="(383, 29)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(383, 26)" end="(383, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(383, 28)" end="(383, 29)">
                          <IdentNode start="(383, 28)" end="(383, 29)" leading="" trailing="&#10;  " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(384, 3)" end="(384, 53)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size" tactic="· exact Nat.le_of_lt (findIdx_lt_size_of_exists e)">
                    <OtherNode start="(384, 3)" end="(384, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(384, 3)" end="(384, 4)" kind="patternIgnore">
                        <OtherNode start="(384, 3)" end="(384, 4)" kind="token.«· »">
                          <AtomNode start="(384, 3)" end="(384, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(384, 5)" end="(384, 53)">
                      <TacticTacticseq1IndentedNode start="(384, 5)" end="(384, 53)">
                        <NullNode start="(384, 5)" end="(384, 53)">
                          <OtherNode start="(384, 5)" end="(384, 53)" kind="Lean.Parser.Tactic.exact" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size" state_after="no goals" tactic="exact Nat.le_of_lt (findIdx_lt_size_of_exists e)">
                            <AtomNode start="(384, 5)" end="(384, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(384, 11)" end="(384, 53)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(384, 11)" end="(384, 23)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                              <NullNode start="(384, 24)" end="(384, 53)">
                                <OtherNode start="(384, 24)" end="(384, 53)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(384, 24)" end="(384, 25)" leading="" trailing="" val="("/>
                                  <OtherNode start="(384, 25)" end="(384, 52)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(384, 25)" end="(384, 50)" leading="" trailing=" " raw_val="findIdx_lt_size_of_exists" val="findIdx_lt_size_of_exists" full_name="Array.findIdx_lt_size_of_exists" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(362, 9)" def_end="(362, 34)"/>
                                    <NullNode start="(384, 51)" end="(384, 52)">
                                      <IdentNode start="(384, 51)" end="(384, 52)" leading="" trailing="" raw_val="e" val="e"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(384, 52)" end="(384, 53)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(385, 3)" end="(386, 47)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size" state_after="no goals" tactic="· simp at e&#10;  exact Nat.le_of_eq (findIdx_eq_size.mpr e)">
                    <OtherNode start="(385, 3)" end="(385, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(385, 3)" end="(385, 4)" kind="patternIgnore">
                        <OtherNode start="(385, 3)" end="(385, 4)" kind="token.«· »">
                          <AtomNode start="(385, 3)" end="(385, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(385, 5)" end="(386, 47)">
                      <TacticTacticseq1IndentedNode start="(385, 5)" end="(386, 47)">
                        <NullNode start="(385, 5)" end="(386, 47)">
                          <OtherNode start="(385, 5)" end="(385, 14)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.size" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx p xs ≤ xs.size" tactic="simp at e">
                            <AtomNode start="(385, 5)" end="(385, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(385, 10)" end="(385, 14)">
                              <OtherNode start="(385, 10)" end="(385, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(385, 10)" end="(385, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(385, 13)" end="(385, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(385, 13)" end="(385, 14)">
                                    <IdentNode start="(385, 13)" end="(385, 14)" leading="" trailing="&#10;    " raw_val="e" val="e"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(386, 5)" end="(386, 47)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;e : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx p xs ≤ xs.size" state_after="no goals" tactic="exact Nat.le_of_eq (findIdx_eq_size.mpr e)">
                            <AtomNode start="(386, 5)" end="(386, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(386, 11)" end="(386, 47)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(386, 11)" end="(386, 23)" leading="" trailing=" " raw_val="Nat.le_of_eq" val="Nat.le_of_eq" full_name="Nat.le_of_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                              <NullNode start="(386, 24)" end="(386, 47)">
                                <OtherNode start="(386, 24)" end="(386, 47)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(386, 24)" end="(386, 25)" leading="" trailing="" val="("/>
                                  <OtherNode start="(386, 25)" end="(386, 46)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(386, 25)" end="(386, 44)" leading="" trailing=" " raw_val="findIdx_eq_size.mpr" val="findIdx_eq_size.mpr"/>
                                    <NullNode start="(386, 45)" end="(386, 46)">
                                      <IdentNode start="(386, 45)" end="(386, 46)" leading="" trailing="" raw_val="e" val="e"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(386, 46)" end="(386, 47)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(388, 1)" end="(392, 7)" name="findIdx_lt_size" full_name="Array.findIdx_lt_size">
      <CommandDeclmodifiersNode start="(388, 1)" end="(388, 8)">
        <NullNode/>
        <NullNode start="(388, 1)" end="(388, 8)">
          <OtherNode start="(388, 1)" end="(388, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(388, 1)" end="(388, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(388, 3)" end="(388, 7)">
              <OtherNode start="(388, 3)" end="(388, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(388, 3)" end="(388, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(388, 3)" end="(388, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(388, 7)" end="(388, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(389, 1)" end="(392, 7)" name="findIdx_lt_size" full_name="Array.findIdx_lt_size" _is_private_decl="False">
        <AtomNode start="(389, 1)" end="(389, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(389, 9)" end="(389, 24)">
          <IdentNode start="(389, 9)" end="(389, 24)" leading="" trailing=" " raw_val="findIdx_lt_size" val="findIdx_lt_size"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(389, 25)" end="(390, 43)">
          <NullNode start="(389, 25)" end="(389, 54)">
            <OtherNode start="(389, 25)" end="(389, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(389, 25)" end="(389, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(389, 26)" end="(389, 27)">
                <IdentNode start="(389, 26)" end="(389, 27)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(389, 28)" end="(389, 38)">
                <AtomNode start="(389, 28)" end="(389, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(389, 30)" end="(389, 38)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(389, 30)" end="(389, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(389, 32)" end="(389, 33)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(389, 34)" end="(389, 38)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(389, 38)" end="(389, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(389, 40)" end="(389, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(389, 40)" end="(389, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(389, 41)" end="(389, 43)">
                <IdentNode start="(389, 41)" end="(389, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(389, 44)" end="(389, 53)">
                <AtomNode start="(389, 44)" end="(389, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(389, 46)" end="(389, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(389, 46)" end="(389, 51)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(389, 52)" end="(389, 53)">
                    <IdentNode start="(389, 52)" end="(389, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(389, 53)" end="(389, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(389, 55)" end="(390, 43)">
            <AtomNode start="(389, 55)" end="(389, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(390, 5)" end="(390, 43)" kind="«term_↔_»">
              <OtherNode start="(390, 5)" end="(390, 27)" kind="«term_&amp;lt;_»">
                <OtherNode start="(390, 5)" end="(390, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(390, 5)" end="(390, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(390, 16)" end="(390, 17)">
                    <IdentNode start="(390, 16)" end="(390, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(390, 18)" end="(390, 19)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(390, 20)" end="(390, 27)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
              </OtherNode>
              <AtomNode start="(390, 28)" end="(390, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(390, 30)" end="(390, 43)" kind="Lean.«term∃__,_»">
                <AtomNode start="(390, 30)" end="(390, 31)" leading="" trailing=" " val="∃"/>
                <LeanBinderidentNode start="(390, 32)" end="(390, 33)">
                  <IdentNode start="(390, 32)" end="(390, 33)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(390, 34)" end="(390, 38)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(390, 34)" end="(390, 35)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(390, 36)" end="(390, 38)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(390, 38)" end="(390, 39)" leading="" trailing=" " val=","/>
                <OtherNode start="(390, 40)" end="(390, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(390, 40)" end="(390, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(390, 42)" end="(390, 43)">
                    <IdentNode start="(390, 42)" end="(390, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(390, 44)" end="(392, 7)">
          <AtomNode start="(390, 44)" end="(390, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(390, 47)" end="(392, 7)">
            <AtomNode start="(390, 47)" end="(390, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(391, 3)" end="(392, 7)">
              <TacticTacticseq1IndentedNode start="(391, 3)" end="(392, 7)">
                <NullNode start="(391, 3)" end="(392, 7)">
                  <OtherNode start="(391, 3)" end="(391, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findIdx p xs &amp;lt; xs.size ↔ ∃ x, x ∈ xs ∧ p x = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p { toList := xs } &amp;lt; { toList := xs }.size ↔ ∃ x, x ∈ { toList := xs } ∧ p x = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(391, 3)" end="(391, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(391, 10)" end="(391, 12)">
                      <OtherNode start="(391, 10)" end="(391, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(391, 10)" end="(391, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(391, 13)" end="(391, 22)">
                      <AtomNode start="(391, 13)" end="(391, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(391, 18)" end="(391, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(391, 18)" end="(391, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(391, 18)" end="(391, 22)">
                            <OtherNode start="(391, 18)" end="(391, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(391, 18)" end="(391, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(391, 19)" end="(391, 21)">
                                <OtherNode start="(391, 19)" end="(391, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(391, 19)" end="(391, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(391, 19)" end="(391, 21)">
                                      <OtherNode start="(391, 19)" end="(391, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(391, 19)" end="(391, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(391, 21)" end="(391, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(392, 3)" end="(392, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p { toList := xs } &amp;lt; { toList := xs }.size ↔ ∃ x, x ∈ { toList := xs } ∧ p x = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(392, 3)" end="(392, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(394, 1)" end="(398, 56)" name="not_of_lt_findIdx" full_name="Array.not_of_lt_findIdx">
      <CommandDeclmodifiersNode start="(394, 1)" end="(394, 77)">
        <NullNode start="(394, 1)" end="(394, 77)">
          <CommandDoccommentNode start="(394, 1)" end="(394, 77)" comment="`p` does not hold for elements with indices less than `xs.findIdx p`. -/">
            <AtomNode start="(394, 1)" end="(394, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(394, 5)" end="(394, 77)" leading="" trailing="&#10;" val="`p` does not hold for elements with indices less than `xs.findIdx p`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(395, 1)" end="(398, 56)" name="not_of_lt_findIdx" full_name="Array.not_of_lt_findIdx" _is_private_decl="False">
        <AtomNode start="(395, 1)" end="(395, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(395, 9)" end="(395, 26)">
          <IdentNode start="(395, 9)" end="(395, 26)" leading="" trailing=" " raw_val="not_of_lt_findIdx" val="not_of_lt_findIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(395, 27)" end="(396, 55)">
          <NullNode start="(395, 27)" end="(395, 89)">
            <OtherNode start="(395, 27)" end="(395, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 27)" end="(395, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 28)" end="(395, 29)">
                <IdentNode start="(395, 28)" end="(395, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(395, 30)" end="(395, 40)">
                <AtomNode start="(395, 30)" end="(395, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(395, 32)" end="(395, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(395, 32)" end="(395, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(395, 34)" end="(395, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(395, 36)" end="(395, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(395, 40)" end="(395, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(395, 42)" end="(395, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 42)" end="(395, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 43)" end="(395, 45)">
                <IdentNode start="(395, 43)" end="(395, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(395, 46)" end="(395, 55)">
                <AtomNode start="(395, 46)" end="(395, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(395, 48)" end="(395, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(395, 48)" end="(395, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(395, 54)" end="(395, 55)">
                    <IdentNode start="(395, 54)" end="(395, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(395, 55)" end="(395, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(395, 57)" end="(395, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 57)" end="(395, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 58)" end="(395, 59)">
                <IdentNode start="(395, 58)" end="(395, 59)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(395, 60)" end="(395, 65)">
                <AtomNode start="(395, 60)" end="(395, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(395, 62)" end="(395, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(395, 65)" end="(395, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(395, 67)" end="(395, 89)">
              <AtomNode start="(395, 67)" end="(395, 68)" leading="" trailing="" val="("/>
              <NullNode start="(395, 68)" end="(395, 69)">
                <IdentNode start="(395, 68)" end="(395, 69)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(395, 70)" end="(395, 88)">
                <AtomNode start="(395, 70)" end="(395, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(395, 72)" end="(395, 88)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(395, 72)" end="(395, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(395, 74)" end="(395, 75)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(395, 76)" end="(395, 88)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(395, 76)" end="(395, 86)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(395, 87)" end="(395, 88)">
                      <IdentNode start="(395, 87)" end="(395, 88)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(395, 88)" end="(395, 89)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(395, 90)" end="(396, 55)">
            <AtomNode start="(395, 90)" end="(395, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(396, 5)" end="(396, 55)" kind="«term_=_»">
              <OtherNode start="(396, 5)" end="(396, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(396, 5)" end="(396, 6)" leading="" trailing=" " raw_val="p" val="p"/>
                <NullNode start="(396, 7)" end="(396, 47)">
                  <OtherNode start="(396, 7)" end="(396, 47)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(396, 7)" end="(396, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(396, 8)" end="(396, 46)" kind="«term__[_]'_»">
                      <IdentNode start="(396, 8)" end="(396, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(396, 10)" end="(396, 11)" leading="" trailing="" val="["/>
                      <IdentNode start="(396, 11)" end="(396, 12)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(396, 12)" end="(396, 14)" leading="" trailing="" val="]'"/>
                      <OtherNode start="(396, 14)" end="(396, 46)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(396, 14)" end="(396, 15)" leading="" trailing="" val="("/>
                        <OtherNode start="(396, 15)" end="(396, 45)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(396, 15)" end="(396, 27)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(396, 28)" end="(396, 45)">
                            <IdentNode start="(396, 28)" end="(396, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                            <IdentNode start="(396, 30)" end="(396, 45)" leading="" trailing="" raw_val="findIdx_le_size" val="findIdx_le_size" full_name="Array.findIdx_le_size" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(382, 9)" def_end="(382, 24)"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(396, 45)" end="(396, 46)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(396, 46)" end="(396, 47)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(396, 48)" end="(396, 49)" leading="" trailing=" " val="="/>
              <IdentNode start="(396, 50)" end="(396, 55)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(396, 56)" end="(398, 56)">
          <AtomNode start="(396, 56)" end="(396, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(396, 59)" end="(398, 56)">
            <AtomNode start="(396, 59)" end="(396, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(397, 3)" end="(398, 56)">
              <TacticTacticseq1IndentedNode start="(397, 3)" end="(398, 56)">
                <NullNode start="(397, 3)" end="(398, 56)">
                  <OtherNode start="(397, 3)" end="(397, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; findIdx p xs&#10;⊢ p xs[i] = false" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; findIdx p { toList := xs }&#10;⊢ p { toList := xs }[i] = false" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(397, 3)" end="(397, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(397, 10)" end="(397, 12)">
                      <OtherNode start="(397, 10)" end="(397, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(397, 10)" end="(397, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(397, 13)" end="(397, 22)">
                      <AtomNode start="(397, 13)" end="(397, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(397, 18)" end="(397, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(397, 18)" end="(397, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(397, 18)" end="(397, 22)">
                            <OtherNode start="(397, 18)" end="(397, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(397, 18)" end="(397, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(397, 19)" end="(397, 21)">
                                <OtherNode start="(397, 19)" end="(397, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(397, 19)" end="(397, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(397, 19)" end="(397, 21)">
                                      <OtherNode start="(397, 19)" end="(397, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(397, 19)" end="(397, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(397, 21)" end="(397, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(398, 3)" end="(398, 56)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; findIdx p { toList := xs }&#10;⊢ p { toList := xs }[i] = false" state_after="no goals" tactic="simpa using List.not_of_lt_findIdx (by simpa using h)">
                    <AtomNode start="(398, 3)" end="(398, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(398, 9)" end="(398, 56)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(398, 9)" end="(398, 56)">
                        <AtomNode start="(398, 9)" end="(398, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(398, 15)" end="(398, 56)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(398, 15)" end="(398, 37)" leading="" trailing=" " raw_val="List.not_of_lt_findIdx" val="List.not_of_lt_findIdx" full_name="List.not_of_lt_findIdx" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                          <NullNode start="(398, 38)" end="(398, 56)">
                            <OtherNode start="(398, 38)" end="(398, 56)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(398, 38)" end="(398, 39)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(398, 39)" end="(398, 55)">
                                <AtomNode start="(398, 39)" end="(398, 41)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(398, 42)" end="(398, 55)">
                                  <TacticTacticseq1IndentedNode start="(398, 42)" end="(398, 55)">
                                    <NullNode start="(398, 42)" end="(398, 55)">
                                      <OtherNode start="(398, 42)" end="(398, 55)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; findIdx p { toList := xs }&#10;⊢ i &amp;lt; List.findIdx p xs" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(398, 42)" end="(398, 47)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(398, 48)" end="(398, 55)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(398, 48)" end="(398, 55)">
                                            <AtomNode start="(398, 48)" end="(398, 53)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(398, 54)" end="(398, 55)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(398, 55)" end="(398, 56)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(400, 1)" end="(406, 97)" name="le_findIdx_of_not" full_name="Array.le_findIdx_of_not">
      <CommandDeclmodifiersNode start="(400, 1)" end="(400, 64)">
        <NullNode start="(400, 1)" end="(400, 64)">
          <CommandDoccommentNode start="(400, 1)" end="(400, 64)" comment="If `¬ p xs[j]` for all `j &amp;lt; i`, then `i ≤ xs.findIdx p`. -/">
            <AtomNode start="(400, 1)" end="(400, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(400, 5)" end="(400, 64)" leading="" trailing="&#10;" val="If `¬ p xs[j]` for all `j &amp;lt; i`, then `i ≤ xs.findIdx p`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(401, 1)" end="(406, 97)" name="le_findIdx_of_not" full_name="Array.le_findIdx_of_not" _is_private_decl="False">
        <AtomNode start="(401, 1)" end="(401, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(401, 9)" end="(401, 26)">
          <IdentNode start="(401, 9)" end="(401, 26)" leading="" trailing=" " raw_val="le_findIdx_of_not" val="le_findIdx_of_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(401, 27)" end="(402, 88)">
          <NullNode start="(401, 27)" end="(402, 69)">
            <OtherNode start="(401, 27)" end="(401, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(401, 27)" end="(401, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(401, 28)" end="(401, 29)">
                <IdentNode start="(401, 28)" end="(401, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(401, 30)" end="(401, 40)">
                <AtomNode start="(401, 30)" end="(401, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(401, 32)" end="(401, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(401, 32)" end="(401, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(401, 34)" end="(401, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(401, 36)" end="(401, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(401, 40)" end="(401, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(401, 42)" end="(401, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(401, 42)" end="(401, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(401, 43)" end="(401, 45)">
                <IdentNode start="(401, 43)" end="(401, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(401, 46)" end="(401, 55)">
                <AtomNode start="(401, 46)" end="(401, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(401, 48)" end="(401, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(401, 48)" end="(401, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(401, 54)" end="(401, 55)">
                    <IdentNode start="(401, 54)" end="(401, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(401, 55)" end="(401, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(401, 57)" end="(401, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(401, 57)" end="(401, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(401, 58)" end="(401, 59)">
                <IdentNode start="(401, 58)" end="(401, 59)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(401, 60)" end="(401, 65)">
                <AtomNode start="(401, 60)" end="(401, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(401, 62)" end="(401, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(401, 65)" end="(401, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(401, 67)" end="(401, 84)">
              <AtomNode start="(401, 67)" end="(401, 68)" leading="" trailing="" val="("/>
              <NullNode start="(401, 68)" end="(401, 69)">
                <IdentNode start="(401, 68)" end="(401, 69)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(401, 70)" end="(401, 83)">
                <AtomNode start="(401, 70)" end="(401, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(401, 72)" end="(401, 83)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(401, 72)" end="(401, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(401, 74)" end="(401, 75)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(401, 76)" end="(401, 83)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(401, 83)" end="(401, 84)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(402, 5)" end="(402, 69)">
              <AtomNode start="(402, 5)" end="(402, 6)" leading="" trailing="" val="("/>
              <NullNode start="(402, 6)" end="(402, 8)">
                <IdentNode start="(402, 6)" end="(402, 8)" leading="" trailing=" " raw_val="h2" val="h2"/>
              </NullNode>
              <NullNode start="(402, 9)" end="(402, 68)">
                <AtomNode start="(402, 9)" end="(402, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(402, 11)" end="(402, 68)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(402, 11)" end="(402, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(402, 13)" end="(402, 28)">
                    <IdentNode start="(402, 13)" end="(402, 14)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(402, 15)" end="(402, 28)">
                      <AtomNode start="(402, 15)" end="(402, 16)" leading="" trailing="" val="("/>
                      <NullNode start="(402, 16)" end="(402, 19)">
                        <IdentNode start="(402, 16)" end="(402, 19)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(402, 20)" end="(402, 27)">
                        <AtomNode start="(402, 20)" end="(402, 21)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(402, 22)" end="(402, 27)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(402, 22)" end="(402, 23)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(402, 24)" end="(402, 25)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(402, 26)" end="(402, 27)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(402, 27)" end="(402, 28)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(402, 28)" end="(402, 29)" leading="" trailing=" " val=","/>
                  <OtherNode start="(402, 30)" end="(402, 68)" kind="«term_=_»">
                    <OtherNode start="(402, 30)" end="(402, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(402, 30)" end="(402, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(402, 32)" end="(402, 60)">
                        <OtherNode start="(402, 32)" end="(402, 60)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(402, 32)" end="(402, 33)" leading="" trailing="" val="("/>
                          <OtherNode start="(402, 33)" end="(402, 59)" kind="«term__[_]'_»">
                            <IdentNode start="(402, 33)" end="(402, 35)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(402, 35)" end="(402, 36)" leading="" trailing="" val="["/>
                            <IdentNode start="(402, 36)" end="(402, 37)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(402, 37)" end="(402, 39)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(402, 39)" end="(402, 59)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(402, 39)" end="(402, 40)" leading="" trailing="" val="("/>
                              <OtherNode start="(402, 40)" end="(402, 58)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(402, 40)" end="(402, 52)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(402, 53)" end="(402, 58)">
                                  <IdentNode start="(402, 53)" end="(402, 56)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <IdentNode start="(402, 57)" end="(402, 58)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(402, 58)" end="(402, 59)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(402, 59)" end="(402, 60)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(402, 61)" end="(402, 62)" leading="" trailing=" " val="="/>
                    <IdentNode start="(402, 63)" end="(402, 68)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(402, 68)" end="(402, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(402, 70)" end="(402, 88)">
            <AtomNode start="(402, 70)" end="(402, 71)" leading="" trailing=" " val=":"/>
            <OtherNode start="(402, 72)" end="(402, 88)" kind="«term_≤_»">
              <IdentNode start="(402, 72)" end="(402, 73)" leading="" trailing=" " raw_val="i" val="i"/>
              <AtomNode start="(402, 74)" end="(402, 75)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(402, 76)" end="(402, 88)" kind="Lean.Parser.Term.app">
                <IdentNode start="(402, 76)" end="(402, 86)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(402, 87)" end="(402, 88)">
                  <IdentNode start="(402, 87)" end="(402, 88)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(402, 89)" end="(406, 97)">
          <AtomNode start="(402, 89)" end="(402, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(402, 92)" end="(406, 97)">
            <AtomNode start="(402, 92)" end="(402, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(403, 3)" end="(406, 97)">
              <TacticTacticseq1IndentedNode start="(403, 3)" end="(406, 97)">
                <NullNode start="(403, 3)" end="(406, 97)">
                  <OtherNode start="(403, 3)" end="(403, 34)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ i ≤ findIdx p xs" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬i ≤ findIdx p xs → False" tactic="apply Decidable.byContradiction">
                    <AtomNode start="(403, 3)" end="(403, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(403, 9)" end="(403, 34)" leading="" trailing="&#10;  " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(404, 3)" end="(404, 10)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬i ≤ findIdx p xs → False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : ¬i ≤ findIdx p xs&#10;⊢ False" tactic="intro f">
                    <AtomNode start="(404, 3)" end="(404, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(404, 9)" end="(404, 10)">
                      <IdentNode start="(404, 9)" end="(404, 10)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(405, 3)" end="(405, 30)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : ¬i ≤ findIdx p xs&#10;⊢ False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : findIdx p xs &amp;lt; i&#10;⊢ False" tactic="simp only [Nat.not_le] at f">
                    <AtomNode start="(405, 3)" end="(405, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(405, 8)" end="(405, 12)">
                      <AtomNode start="(405, 8)" end="(405, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(405, 13)" end="(405, 25)">
                      <AtomNode start="(405, 13)" end="(405, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(405, 14)" end="(405, 24)">
                        <OtherNode start="(405, 14)" end="(405, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(405, 14)" end="(405, 24)" leading="" trailing="" raw_val="Nat.not_le" val="Nat.not_le" full_name="Nat.not_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(405, 24)" end="(405, 25)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(405, 26)" end="(405, 30)">
                      <OtherNode start="(405, 26)" end="(405, 30)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(405, 26)" end="(405, 28)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(405, 29)" end="(405, 30)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(405, 29)" end="(405, 30)">
                            <IdentNode start="(405, 29)" end="(405, 30)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(406, 3)" end="(406, 97)" kind="Lean.Parser.Tactic.exact" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : findIdx p xs &amp;lt; i&#10;⊢ False" state_after="no goals" tactic="exact absurd (@findIdx_getElem _ p xs (Nat.lt_trans f h)) (by simpa using h2 (xs.findIdx p) f)">
                    <AtomNode start="(406, 3)" end="(406, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(406, 9)" end="(406, 97)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(406, 9)" end="(406, 15)" leading="" trailing=" " raw_val="absurd" val="absurd" full_name="absurd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(406, 16)" end="(406, 97)">
                        <OtherNode start="(406, 16)" end="(406, 60)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(406, 16)" end="(406, 17)" leading="" trailing="" val="("/>
                          <OtherNode start="(406, 17)" end="(406, 59)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(406, 17)" end="(406, 33)" kind="Lean.Parser.Term.explicit">
                              <AtomNode start="(406, 17)" end="(406, 18)" leading="" trailing="" val="@"/>
                              <IdentNode start="(406, 18)" end="(406, 33)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem" full_name="Array.findIdx_getElem" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(358, 9)" def_end="(358, 24)"/>
                            </OtherNode>
                            <NullNode start="(406, 34)" end="(406, 59)">
                              <TermHoleNode start="(406, 34)" end="(406, 35)">
                                <AtomNode start="(406, 34)" end="(406, 35)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                              <IdentNode start="(406, 36)" end="(406, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                              <IdentNode start="(406, 38)" end="(406, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              <OtherNode start="(406, 41)" end="(406, 59)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(406, 41)" end="(406, 42)" leading="" trailing="" val="("/>
                                <OtherNode start="(406, 42)" end="(406, 58)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(406, 42)" end="(406, 54)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(406, 55)" end="(406, 58)">
                                    <IdentNode start="(406, 55)" end="(406, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <IdentNode start="(406, 57)" end="(406, 58)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(406, 58)" end="(406, 59)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(406, 59)" end="(406, 60)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(406, 61)" end="(406, 97)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(406, 61)" end="(406, 62)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(406, 62)" end="(406, 96)">
                            <AtomNode start="(406, 62)" end="(406, 64)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(406, 65)" end="(406, 96)">
                              <TacticTacticseq1IndentedNode start="(406, 65)" end="(406, 96)">
                                <NullNode start="(406, 65)" end="(406, 96)">
                                  <OtherNode start="(406, 65)" end="(406, 96)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : findIdx p xs &amp;lt; i&#10;⊢ ¬p xs[findIdx p xs] = true" state_after="no goals" tactic="simpa using h2 (xs.findIdx p) f">
                                    <AtomNode start="(406, 65)" end="(406, 70)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(406, 71)" end="(406, 96)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(406, 71)" end="(406, 96)">
                                        <AtomNode start="(406, 71)" end="(406, 76)" leading="" trailing=" " val="using"/>
                                        <OtherNode start="(406, 77)" end="(406, 96)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(406, 77)" end="(406, 79)" leading="" trailing=" " raw_val="h2" val="h2"/>
                                          <NullNode start="(406, 80)" end="(406, 96)">
                                            <OtherNode start="(406, 80)" end="(406, 94)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(406, 80)" end="(406, 81)" leading="" trailing="" val="("/>
                                              <OtherNode start="(406, 81)" end="(406, 93)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(406, 81)" end="(406, 91)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                                                <NullNode start="(406, 92)" end="(406, 93)">
                                                  <IdentNode start="(406, 92)" end="(406, 93)" leading="" trailing="" raw_val="p" val="p"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(406, 93)" end="(406, 94)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                            <IdentNode start="(406, 95)" end="(406, 96)" leading="" trailing="" raw_val="f" val="f"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(406, 96)" end="(406, 97)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(408, 1)" end="(414, 88)" name="lt_findIdx_of_not" full_name="Array.lt_findIdx_of_not">
      <CommandDeclmodifiersNode start="(408, 1)" end="(408, 64)">
        <NullNode start="(408, 1)" end="(408, 64)">
          <CommandDoccommentNode start="(408, 1)" end="(408, 64)" comment="If `¬ p xs[j]` for all `j ≤ i`, then `i &amp;lt; xs.findIdx p`. -/">
            <AtomNode start="(408, 1)" end="(408, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(408, 5)" end="(408, 64)" leading="" trailing="&#10;" val="If `¬ p xs[j]` for all `j ≤ i`, then `i &amp;lt; xs.findIdx p`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(409, 1)" end="(414, 88)" name="lt_findIdx_of_not" full_name="Array.lt_findIdx_of_not" _is_private_decl="False">
        <AtomNode start="(409, 1)" end="(409, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(409, 9)" end="(409, 26)">
          <IdentNode start="(409, 9)" end="(409, 26)" leading="" trailing=" " raw_val="lt_findIdx_of_not" val="lt_findIdx_of_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(409, 27)" end="(410, 87)">
          <NullNode start="(409, 27)" end="(410, 68)">
            <OtherNode start="(409, 27)" end="(409, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(409, 27)" end="(409, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(409, 28)" end="(409, 29)">
                <IdentNode start="(409, 28)" end="(409, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(409, 30)" end="(409, 40)">
                <AtomNode start="(409, 30)" end="(409, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 32)" end="(409, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(409, 32)" end="(409, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(409, 34)" end="(409, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(409, 36)" end="(409, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(409, 40)" end="(409, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(409, 42)" end="(409, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(409, 42)" end="(409, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(409, 43)" end="(409, 45)">
                <IdentNode start="(409, 43)" end="(409, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(409, 46)" end="(409, 55)">
                <AtomNode start="(409, 46)" end="(409, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 48)" end="(409, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(409, 48)" end="(409, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(409, 54)" end="(409, 55)">
                    <IdentNode start="(409, 54)" end="(409, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(409, 55)" end="(409, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(409, 57)" end="(409, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(409, 57)" end="(409, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(409, 58)" end="(409, 59)">
                <IdentNode start="(409, 58)" end="(409, 59)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(409, 60)" end="(409, 65)">
                <AtomNode start="(409, 60)" end="(409, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(409, 62)" end="(409, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(409, 65)" end="(409, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(409, 67)" end="(409, 84)">
              <AtomNode start="(409, 67)" end="(409, 68)" leading="" trailing="" val="("/>
              <NullNode start="(409, 68)" end="(409, 69)">
                <IdentNode start="(409, 68)" end="(409, 69)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(409, 70)" end="(409, 83)">
                <AtomNode start="(409, 70)" end="(409, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 72)" end="(409, 83)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(409, 72)" end="(409, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(409, 74)" end="(409, 75)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(409, 76)" end="(409, 83)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(409, 83)" end="(409, 84)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(410, 5)" end="(410, 68)">
              <AtomNode start="(410, 5)" end="(410, 6)" leading="" trailing="" val="("/>
              <NullNode start="(410, 6)" end="(410, 8)">
                <IdentNode start="(410, 6)" end="(410, 8)" leading="" trailing=" " raw_val="h2" val="h2"/>
              </NullNode>
              <NullNode start="(410, 9)" end="(410, 67)">
                <AtomNode start="(410, 9)" end="(410, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(410, 11)" end="(410, 67)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(410, 11)" end="(410, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(410, 13)" end="(410, 28)">
                    <IdentNode start="(410, 13)" end="(410, 14)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(410, 15)" end="(410, 28)">
                      <AtomNode start="(410, 15)" end="(410, 16)" leading="" trailing="" val="("/>
                      <NullNode start="(410, 16)" end="(410, 19)">
                        <IdentNode start="(410, 16)" end="(410, 19)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(410, 20)" end="(410, 27)">
                        <AtomNode start="(410, 20)" end="(410, 21)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(410, 22)" end="(410, 27)" kind="«term_≤_»">
                          <IdentNode start="(410, 22)" end="(410, 23)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(410, 24)" end="(410, 25)" leading="" trailing=" " val="≤"/>
                          <IdentNode start="(410, 26)" end="(410, 27)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(410, 27)" end="(410, 28)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(410, 28)" end="(410, 29)" leading="" trailing=" " val=","/>
                  <OtherNode start="(410, 30)" end="(410, 67)" kind="«term¬_»">
                    <AtomNode start="(410, 30)" end="(410, 31)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(410, 31)" end="(410, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(410, 31)" end="(410, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(410, 33)" end="(410, 67)">
                        <OtherNode start="(410, 33)" end="(410, 67)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(410, 33)" end="(410, 34)" leading="" trailing="" val="("/>
                          <OtherNode start="(410, 34)" end="(410, 66)" kind="«term__[_]'_»">
                            <IdentNode start="(410, 34)" end="(410, 36)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(410, 36)" end="(410, 37)" leading="" trailing="" val="["/>
                            <IdentNode start="(410, 37)" end="(410, 38)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(410, 38)" end="(410, 40)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(410, 40)" end="(410, 66)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(410, 40)" end="(410, 41)" leading="" trailing="" val="("/>
                              <OtherNode start="(410, 41)" end="(410, 65)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(410, 41)" end="(410, 59)" leading="" trailing=" " raw_val="Nat.lt_of_le_of_lt" val="Nat.lt_of_le_of_lt" full_name="Nat.lt_of_le_of_lt" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(410, 60)" end="(410, 65)">
                                  <IdentNode start="(410, 60)" end="(410, 63)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <IdentNode start="(410, 64)" end="(410, 65)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(410, 65)" end="(410, 66)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(410, 66)" end="(410, 67)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(410, 67)" end="(410, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(410, 69)" end="(410, 87)">
            <AtomNode start="(410, 69)" end="(410, 70)" leading="" trailing=" " val=":"/>
            <OtherNode start="(410, 71)" end="(410, 87)" kind="«term_&amp;lt;_»">
              <IdentNode start="(410, 71)" end="(410, 72)" leading="" trailing=" " raw_val="i" val="i"/>
              <AtomNode start="(410, 73)" end="(410, 74)" leading="" trailing=" " val="&amp;lt;"/>
              <OtherNode start="(410, 75)" end="(410, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(410, 75)" end="(410, 85)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(410, 86)" end="(410, 87)">
                  <IdentNode start="(410, 86)" end="(410, 87)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(410, 88)" end="(414, 88)">
          <AtomNode start="(410, 88)" end="(410, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(410, 91)" end="(414, 88)">
            <AtomNode start="(410, 91)" end="(410, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(411, 3)" end="(414, 88)">
              <TacticTacticseq1IndentedNode start="(411, 3)" end="(414, 88)">
                <NullNode start="(411, 3)" end="(414, 88)">
                  <OtherNode start="(411, 3)" end="(411, 34)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;⊢ i &amp;lt; findIdx p xs" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;⊢ ¬i &amp;lt; findIdx p xs → False" tactic="apply Decidable.byContradiction">
                    <AtomNode start="(411, 3)" end="(411, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(411, 9)" end="(411, 34)" leading="" trailing="&#10;  " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(412, 3)" end="(412, 10)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;⊢ ¬i &amp;lt; findIdx p xs → False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : ¬i &amp;lt; findIdx p xs&#10;⊢ False" tactic="intro f">
                    <AtomNode start="(412, 3)" end="(412, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(412, 9)" end="(412, 10)">
                      <IdentNode start="(412, 9)" end="(412, 10)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(413, 3)" end="(413, 30)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : ¬i &amp;lt; findIdx p xs&#10;⊢ False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : findIdx p xs ≤ i&#10;⊢ False" tactic="simp only [Nat.not_lt] at f">
                    <AtomNode start="(413, 3)" end="(413, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(413, 8)" end="(413, 12)">
                      <AtomNode start="(413, 8)" end="(413, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(413, 13)" end="(413, 25)">
                      <AtomNode start="(413, 13)" end="(413, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(413, 14)" end="(413, 24)">
                        <OtherNode start="(413, 14)" end="(413, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(413, 14)" end="(413, 24)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(413, 24)" end="(413, 25)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(413, 26)" end="(413, 30)">
                      <OtherNode start="(413, 26)" end="(413, 30)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(413, 26)" end="(413, 28)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(413, 29)" end="(413, 30)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(413, 29)" end="(413, 30)">
                            <IdentNode start="(413, 29)" end="(413, 30)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(414, 3)" end="(414, 88)" kind="Lean.Parser.Tactic.exact" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : findIdx p xs ≤ i&#10;⊢ False" state_after="no goals" tactic="exact absurd (@findIdx_getElem _ p xs (Nat.lt_of_le_of_lt f h)) (h2 (xs.findIdx p) f)">
                    <AtomNode start="(414, 3)" end="(414, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(414, 9)" end="(414, 88)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(414, 9)" end="(414, 15)" leading="" trailing=" " raw_val="absurd" val="absurd" full_name="absurd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(414, 16)" end="(414, 88)">
                        <OtherNode start="(414, 16)" end="(414, 66)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(414, 16)" end="(414, 17)" leading="" trailing="" val="("/>
                          <OtherNode start="(414, 17)" end="(414, 65)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(414, 17)" end="(414, 33)" kind="Lean.Parser.Term.explicit">
                              <AtomNode start="(414, 17)" end="(414, 18)" leading="" trailing="" val="@"/>
                              <IdentNode start="(414, 18)" end="(414, 33)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem" full_name="Array.findIdx_getElem" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(358, 9)" def_end="(358, 24)"/>
                            </OtherNode>
                            <NullNode start="(414, 34)" end="(414, 65)">
                              <TermHoleNode start="(414, 34)" end="(414, 35)">
                                <AtomNode start="(414, 34)" end="(414, 35)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                              <IdentNode start="(414, 36)" end="(414, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                              <IdentNode start="(414, 38)" end="(414, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              <OtherNode start="(414, 41)" end="(414, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(414, 41)" end="(414, 42)" leading="" trailing="" val="("/>
                                <OtherNode start="(414, 42)" end="(414, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(414, 42)" end="(414, 60)" leading="" trailing=" " raw_val="Nat.lt_of_le_of_lt" val="Nat.lt_of_le_of_lt" full_name="Nat.lt_of_le_of_lt" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(414, 61)" end="(414, 64)">
                                    <IdentNode start="(414, 61)" end="(414, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <IdentNode start="(414, 63)" end="(414, 64)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(414, 64)" end="(414, 65)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(414, 65)" end="(414, 66)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(414, 67)" end="(414, 88)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(414, 67)" end="(414, 68)" leading="" trailing="" val="("/>
                          <OtherNode start="(414, 68)" end="(414, 87)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(414, 68)" end="(414, 70)" leading="" trailing=" " raw_val="h2" val="h2"/>
                            <NullNode start="(414, 71)" end="(414, 87)">
                              <OtherNode start="(414, 71)" end="(414, 85)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(414, 71)" end="(414, 72)" leading="" trailing="" val="("/>
                                <OtherNode start="(414, 72)" end="(414, 84)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(414, 72)" end="(414, 82)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                                  <NullNode start="(414, 83)" end="(414, 84)">
                                    <IdentNode start="(414, 83)" end="(414, 84)" leading="" trailing="" raw_val="p" val="p"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(414, 84)" end="(414, 85)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <IdentNode start="(414, 86)" end="(414, 87)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(414, 87)" end="(414, 88)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(416, 1)" end="(425, 34)" name="findIdx_eq" full_name="Array.findIdx_eq">
      <CommandDeclmodifiersNode start="(416, 1)" end="(416, 74)">
        <NullNode start="(416, 1)" end="(416, 74)">
          <CommandDoccommentNode start="(416, 1)" end="(416, 74)" comment="`xs.findIdx p = i` iff `p xs[i]` and `¬ p xs [j]` for all `j &amp;lt; i`. -/">
            <AtomNode start="(416, 1)" end="(416, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(416, 5)" end="(416, 74)" leading="" trailing="&#10;" val="`xs.findIdx p = i` iff `p xs[i]` and `¬ p xs [j]` for all `j &amp;lt; i`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(417, 1)" end="(425, 34)" name="findIdx_eq" full_name="Array.findIdx_eq" _is_private_decl="False">
        <AtomNode start="(417, 1)" end="(417, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(417, 9)" end="(417, 19)">
          <IdentNode start="(417, 9)" end="(417, 19)" leading="" trailing=" " raw_val="findIdx_eq" val="findIdx_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(417, 20)" end="(418, 91)">
          <NullNode start="(417, 20)" end="(417, 77)">
            <OtherNode start="(417, 20)" end="(417, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(417, 20)" end="(417, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(417, 21)" end="(417, 22)">
                <IdentNode start="(417, 21)" end="(417, 22)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(417, 23)" end="(417, 33)">
                <AtomNode start="(417, 23)" end="(417, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(417, 25)" end="(417, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(417, 25)" end="(417, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(417, 27)" end="(417, 28)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(417, 29)" end="(417, 33)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(417, 33)" end="(417, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(417, 35)" end="(417, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(417, 35)" end="(417, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(417, 36)" end="(417, 38)">
                <IdentNode start="(417, 36)" end="(417, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(417, 39)" end="(417, 48)">
                <AtomNode start="(417, 39)" end="(417, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(417, 41)" end="(417, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(417, 41)" end="(417, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(417, 47)" end="(417, 48)">
                    <IdentNode start="(417, 47)" end="(417, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(417, 48)" end="(417, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(417, 50)" end="(417, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(417, 50)" end="(417, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(417, 51)" end="(417, 52)">
                <IdentNode start="(417, 51)" end="(417, 52)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(417, 53)" end="(417, 58)">
                <AtomNode start="(417, 53)" end="(417, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(417, 55)" end="(417, 58)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(417, 58)" end="(417, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(417, 60)" end="(417, 77)">
              <AtomNode start="(417, 60)" end="(417, 61)" leading="" trailing="" val="("/>
              <NullNode start="(417, 61)" end="(417, 62)">
                <IdentNode start="(417, 61)" end="(417, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(417, 63)" end="(417, 76)">
                <AtomNode start="(417, 63)" end="(417, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(417, 65)" end="(417, 76)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(417, 65)" end="(417, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(417, 67)" end="(417, 68)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(417, 69)" end="(417, 76)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(417, 76)" end="(417, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(417, 78)" end="(418, 91)">
            <AtomNode start="(417, 78)" end="(417, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(418, 5)" end="(418, 91)" kind="«term_↔_»">
              <OtherNode start="(418, 5)" end="(418, 21)" kind="«term_=_»">
                <OtherNode start="(418, 5)" end="(418, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(418, 5)" end="(418, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(418, 16)" end="(418, 17)">
                    <IdentNode start="(418, 16)" end="(418, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(418, 18)" end="(418, 19)" leading="" trailing=" " val="="/>
                <IdentNode start="(418, 20)" end="(418, 21)" leading="" trailing=" " raw_val="i" val="i"/>
              </OtherNode>
              <AtomNode start="(418, 22)" end="(418, 23)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(418, 24)" end="(418, 91)" kind="«term_∧_»">
                <OtherNode start="(418, 24)" end="(418, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(418, 24)" end="(418, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(418, 26)" end="(418, 31)">
                    <OtherNode start="(418, 26)" end="(418, 31)" kind="«term__[_]»">
                      <IdentNode start="(418, 26)" end="(418, 28)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(418, 28)" end="(418, 29)" leading="" trailing="" val="["/>
                      <IdentNode start="(418, 29)" end="(418, 30)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(418, 30)" end="(418, 31)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(418, 32)" end="(418, 33)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(418, 34)" end="(418, 91)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(418, 34)" end="(418, 35)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(418, 36)" end="(418, 51)">
                    <IdentNode start="(418, 36)" end="(418, 37)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(418, 38)" end="(418, 51)">
                      <AtomNode start="(418, 38)" end="(418, 39)" leading="" trailing="" val="("/>
                      <NullNode start="(418, 39)" end="(418, 42)">
                        <IdentNode start="(418, 39)" end="(418, 42)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(418, 43)" end="(418, 50)">
                        <AtomNode start="(418, 43)" end="(418, 44)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(418, 45)" end="(418, 50)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(418, 45)" end="(418, 46)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(418, 47)" end="(418, 48)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(418, 49)" end="(418, 50)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(418, 50)" end="(418, 51)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(418, 51)" end="(418, 52)" leading="" trailing=" " val=","/>
                  <OtherNode start="(418, 53)" end="(418, 91)" kind="«term_=_»">
                    <OtherNode start="(418, 53)" end="(418, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(418, 53)" end="(418, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(418, 55)" end="(418, 83)">
                        <OtherNode start="(418, 55)" end="(418, 83)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(418, 55)" end="(418, 56)" leading="" trailing="" val="("/>
                          <OtherNode start="(418, 56)" end="(418, 82)" kind="«term__[_]'_»">
                            <IdentNode start="(418, 56)" end="(418, 58)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(418, 58)" end="(418, 59)" leading="" trailing="" val="["/>
                            <IdentNode start="(418, 59)" end="(418, 60)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(418, 60)" end="(418, 62)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(418, 62)" end="(418, 82)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(418, 62)" end="(418, 63)" leading="" trailing="" val="("/>
                              <OtherNode start="(418, 63)" end="(418, 81)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(418, 63)" end="(418, 75)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(418, 76)" end="(418, 81)">
                                  <IdentNode start="(418, 76)" end="(418, 79)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <IdentNode start="(418, 80)" end="(418, 81)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(418, 81)" end="(418, 82)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(418, 82)" end="(418, 83)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(418, 84)" end="(418, 85)" leading="" trailing=" " val="="/>
                    <IdentNode start="(418, 86)" end="(418, 91)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(418, 92)" end="(425, 34)">
          <AtomNode start="(418, 92)" end="(418, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(418, 95)" end="(425, 34)">
            <AtomNode start="(418, 95)" end="(418, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(419, 3)" end="(425, 34)">
              <TacticTacticseq1IndentedNode start="(419, 3)" end="(425, 34)">
                <NullNode start="(419, 3)" end="(425, 34)">
                  <OtherNode start="(419, 3)" end="(420, 22)" kind="Lean.Parser.Tactic.refine" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;⊢ findIdx p xs = i ↔ p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs = i" tactic="refine ⟨fun f ↦ ⟨f ▸ (@findIdx_getElem _ p xs (f ▸ h)), fun _ hji ↦ not_of_lt_findIdx (f ▸ hji)⟩,&#10;  fun ⟨_, h2⟩ ↦ ?_⟩">
                    <AtomNode start="(419, 3)" end="(419, 9)" leading="" trailing=" " val="refine"/>
                    <OtherNode start="(419, 10)" end="(420, 22)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(419, 10)" end="(419, 11)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(419, 11)" end="(420, 21)">
                        <OtherNode start="(419, 11)" end="(419, 99)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(419, 11)" end="(419, 14)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(419, 15)" end="(419, 99)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(419, 15)" end="(419, 16)">
                              <IdentNode start="(419, 15)" end="(419, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(419, 17)" end="(419, 18)" leading="" trailing=" " val="↦"/>
                            <OtherNode start="(419, 19)" end="(419, 99)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(419, 19)" end="(419, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(419, 20)" end="(419, 98)">
                                <OtherNode start="(419, 20)" end="(419, 57)" kind="Lean.Parser.Term.subst">
                                  <IdentNode start="(419, 20)" end="(419, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <AtomNode start="(419, 22)" end="(419, 23)" leading="" trailing=" " val="▸"/>
                                  <NullNode start="(419, 24)" end="(419, 57)">
                                    <OtherNode start="(419, 24)" end="(419, 57)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(419, 24)" end="(419, 25)" leading="" trailing="" val="("/>
                                      <OtherNode start="(419, 25)" end="(419, 56)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(419, 25)" end="(419, 41)" kind="Lean.Parser.Term.explicit">
                                          <AtomNode start="(419, 25)" end="(419, 26)" leading="" trailing="" val="@"/>
                                          <IdentNode start="(419, 26)" end="(419, 41)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem" full_name="Array.findIdx_getElem" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(358, 9)" def_end="(358, 24)"/>
                                        </OtherNode>
                                        <NullNode start="(419, 42)" end="(419, 56)">
                                          <TermHoleNode start="(419, 42)" end="(419, 43)">
                                            <AtomNode start="(419, 42)" end="(419, 43)" leading="" trailing=" " val="_"/>
                                          </TermHoleNode>
                                          <IdentNode start="(419, 44)" end="(419, 45)" leading="" trailing=" " raw_val="p" val="p"/>
                                          <IdentNode start="(419, 46)" end="(419, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                          <OtherNode start="(419, 49)" end="(419, 56)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(419, 49)" end="(419, 50)" leading="" trailing="" val="("/>
                                            <OtherNode start="(419, 50)" end="(419, 55)" kind="Lean.Parser.Term.subst">
                                              <IdentNode start="(419, 50)" end="(419, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                                              <AtomNode start="(419, 52)" end="(419, 53)" leading="" trailing=" " val="▸"/>
                                              <NullNode start="(419, 54)" end="(419, 55)">
                                                <IdentNode start="(419, 54)" end="(419, 55)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(419, 55)" end="(419, 56)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(419, 56)" end="(419, 57)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(419, 57)" end="(419, 58)" leading="" trailing=" " val=","/>
                                <OtherNode start="(419, 59)" end="(419, 98)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(419, 59)" end="(419, 62)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(419, 63)" end="(419, 98)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(419, 63)" end="(419, 68)">
                                      <TermHoleNode start="(419, 63)" end="(419, 64)">
                                        <AtomNode start="(419, 63)" end="(419, 64)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <IdentNode start="(419, 65)" end="(419, 68)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(419, 69)" end="(419, 70)" leading="" trailing=" " val="↦"/>
                                    <OtherNode start="(419, 71)" end="(419, 98)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(419, 71)" end="(419, 88)" leading="" trailing=" " raw_val="not_of_lt_findIdx" val="not_of_lt_findIdx" full_name="Array.not_of_lt_findIdx" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(395, 9)" def_end="(395, 26)"/>
                                      <NullNode start="(419, 89)" end="(419, 98)">
                                        <OtherNode start="(419, 89)" end="(419, 98)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(419, 89)" end="(419, 90)" leading="" trailing="" val="("/>
                                          <OtherNode start="(419, 90)" end="(419, 97)" kind="Lean.Parser.Term.subst">
                                            <IdentNode start="(419, 90)" end="(419, 91)" leading="" trailing=" " raw_val="f" val="f"/>
                                            <AtomNode start="(419, 92)" end="(419, 93)" leading="" trailing=" " val="▸"/>
                                            <NullNode start="(419, 94)" end="(419, 97)">
                                              <IdentNode start="(419, 94)" end="(419, 97)" leading="" trailing="" raw_val="hji" val="hji"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(419, 97)" end="(419, 98)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(419, 98)" end="(419, 99)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(419, 99)" end="(419, 100)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(420, 5)" end="(420, 21)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(420, 5)" end="(420, 8)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(420, 9)" end="(420, 21)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(420, 9)" end="(420, 16)">
                              <OtherNode start="(420, 9)" end="(420, 16)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(420, 9)" end="(420, 10)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(420, 10)" end="(420, 15)">
                                  <TermHoleNode start="(420, 10)" end="(420, 11)">
                                    <AtomNode start="(420, 10)" end="(420, 11)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(420, 11)" end="(420, 12)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(420, 13)" end="(420, 15)" leading="" trailing="" raw_val="h2" val="h2"/>
                                </NullNode>
                                <AtomNode start="(420, 15)" end="(420, 16)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(420, 17)" end="(420, 18)" leading="" trailing=" " val="↦"/>
                            <OtherNode start="(420, 19)" end="(420, 21)" kind="Lean.Parser.Term.syntheticHole">
                              <AtomNode start="(420, 19)" end="(420, 20)" leading="" trailing="" val="?"/>
                              <AtomNode start="(420, 20)" end="(420, 21)" leading="" trailing="" val="_"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(420, 21)" end="(420, 22)" leading="" trailing="&#10;  " val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(421, 3)" end="(421, 51)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs = i" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs ≤ i" tactic="apply Nat.le_antisymm _ (le_findIdx_of_not h h2)">
                    <AtomNode start="(421, 3)" end="(421, 8)" leading="" trailing=" " val="apply"/>
                    <OtherNode start="(421, 9)" end="(421, 51)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(421, 9)" end="(421, 24)" leading="" trailing=" " raw_val="Nat.le_antisymm" val="Nat.le_antisymm" full_name="Nat.le_antisymm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(421, 25)" end="(421, 51)">
                        <TermHoleNode start="(421, 25)" end="(421, 26)">
                          <AtomNode start="(421, 25)" end="(421, 26)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <OtherNode start="(421, 27)" end="(421, 51)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(421, 27)" end="(421, 28)" leading="" trailing="" val="("/>
                          <OtherNode start="(421, 28)" end="(421, 50)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(421, 28)" end="(421, 45)" leading="" trailing=" " raw_val="le_findIdx_of_not" val="le_findIdx_of_not" full_name="Array.le_findIdx_of_not" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(401, 9)" def_end="(401, 26)"/>
                            <NullNode start="(421, 46)" end="(421, 50)">
                              <IdentNode start="(421, 46)" end="(421, 47)" leading="" trailing=" " raw_val="h" val="h"/>
                              <IdentNode start="(421, 48)" end="(421, 50)" leading="" trailing="" raw_val="h2" val="h2"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(421, 50)" end="(421, 51)" leading="" trailing="&#10;  " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(422, 3)" end="(422, 34)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs ≤ i" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬findIdx p xs ≤ i → False" tactic="apply Decidable.byContradiction">
                    <AtomNode start="(422, 3)" end="(422, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(422, 9)" end="(422, 34)" leading="" trailing="&#10;  " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(423, 3)" end="(423, 11)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬findIdx p xs ≤ i → False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : ¬findIdx p xs ≤ i&#10;⊢ False" tactic="intro h3">
                    <AtomNode start="(423, 3)" end="(423, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(423, 9)" end="(423, 11)">
                      <IdentNode start="(423, 9)" end="(423, 11)" leading="" trailing="&#10;  " raw_val="h3" val="h3"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(424, 3)" end="(424, 13)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : ¬findIdx p xs ≤ i&#10;⊢ False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : i &amp;lt; findIdx p xs&#10;⊢ False" tactic="simp at h3">
                    <AtomNode start="(424, 3)" end="(424, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(424, 8)" end="(424, 13)">
                      <OtherNode start="(424, 8)" end="(424, 13)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(424, 8)" end="(424, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(424, 11)" end="(424, 13)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(424, 11)" end="(424, 13)">
                            <IdentNode start="(424, 11)" end="(424, 13)" leading="" trailing="&#10;  " raw_val="h3" val="h3"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(425, 3)" end="(425, 34)" kind="Lean.Parser.Tactic.simpAll" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : i &amp;lt; findIdx p xs&#10;⊢ False" state_after="no goals" tactic="simp_all [not_of_lt_findIdx h3]">
                    <AtomNode start="(425, 3)" end="(425, 11)" leading="" trailing=" " val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(425, 12)" end="(425, 34)">
                      <AtomNode start="(425, 12)" end="(425, 13)" leading="" trailing="" val="["/>
                      <NullNode start="(425, 13)" end="(425, 33)">
                        <OtherNode start="(425, 13)" end="(425, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(425, 13)" end="(425, 33)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(425, 13)" end="(425, 30)" leading="" trailing=" " raw_val="not_of_lt_findIdx" val="not_of_lt_findIdx" full_name="Array.not_of_lt_findIdx" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(395, 9)" def_end="(395, 26)"/>
                            <NullNode start="(425, 31)" end="(425, 33)">
                              <IdentNode start="(425, 31)" end="(425, 33)" leading="" trailing="" raw_val="h3" val="h3"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(425, 33)" end="(425, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(427, 1)" end="(432, 29)" name="findIdx_append" full_name="Array.findIdx_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(427, 1)" end="(432, 29)" name="findIdx_append" full_name="Array.findIdx_append" _is_private_decl="False">
        <AtomNode start="(427, 1)" end="(427, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(427, 9)" end="(427, 23)">
          <IdentNode start="(427, 9)" end="(427, 23)" leading="" trailing=" " raw_val="findIdx_append" val="findIdx_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(427, 24)" end="(429, 78)">
          <NullNode start="(427, 24)" end="(427, 56)">
            <OtherNode start="(427, 24)" end="(427, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(427, 24)" end="(427, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(427, 25)" end="(427, 26)">
                <IdentNode start="(427, 25)" end="(427, 26)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(427, 27)" end="(427, 37)">
                <AtomNode start="(427, 27)" end="(427, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(427, 29)" end="(427, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(427, 29)" end="(427, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(427, 31)" end="(427, 32)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(427, 33)" end="(427, 37)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(427, 37)" end="(427, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(427, 39)" end="(427, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(427, 39)" end="(427, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(427, 40)" end="(427, 45)">
                <IdentNode start="(427, 40)" end="(427, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(427, 43)" end="(427, 45)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(427, 46)" end="(427, 55)">
                <AtomNode start="(427, 46)" end="(427, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(427, 48)" end="(427, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(427, 48)" end="(427, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(427, 54)" end="(427, 55)">
                    <IdentNode start="(427, 54)" end="(427, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(427, 55)" end="(427, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(427, 57)" end="(429, 78)">
            <AtomNode start="(427, 57)" end="(427, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(428, 5)" end="(429, 78)" kind="«term_=_»">
              <OtherNode start="(428, 5)" end="(428, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(428, 5)" end="(428, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(428, 5)" end="(428, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(428, 5)" end="(428, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(428, 6)" end="(428, 14)" kind="«term_++_»">
                      <IdentNode start="(428, 6)" end="(428, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(428, 9)" end="(428, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(428, 12)" end="(428, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(428, 14)" end="(428, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(428, 15)" end="(428, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(428, 16)" end="(428, 23)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="Array.findIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(428, 24)" end="(428, 25)">
                  <IdentNode start="(428, 24)" end="(428, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(428, 26)" end="(428, 27)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(429, 7)" end="(429, 78)" kind="termIfThenElse">
                <AtomNode start="(429, 7)" end="(429, 9)" leading="" trailing=" " val="if"/>
                <OtherNode start="(429, 10)" end="(429, 32)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(429, 10)" end="(429, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(429, 10)" end="(429, 20)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(429, 21)" end="(429, 22)">
                      <IdentNode start="(429, 21)" end="(429, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(429, 23)" end="(429, 24)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(429, 25)" end="(429, 32)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                </OtherNode>
                <AtomNode start="(429, 33)" end="(429, 37)" leading="" trailing=" " val="then"/>
                <OtherNode start="(429, 38)" end="(429, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(429, 38)" end="(429, 48)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(429, 49)" end="(429, 50)">
                    <IdentNode start="(429, 49)" end="(429, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(429, 51)" end="(429, 55)" leading="" trailing=" " val="else"/>
                <OtherNode start="(429, 56)" end="(429, 78)" kind="«term_+_»">
                  <OtherNode start="(429, 56)" end="(429, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(429, 56)" end="(429, 66)" leading="" trailing=" " raw_val="ys.findIdx" val="ys.findIdx"/>
                    <NullNode start="(429, 67)" end="(429, 68)">
                      <IdentNode start="(429, 67)" end="(429, 68)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(429, 69)" end="(429, 70)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(429, 71)" end="(429, 78)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(429, 79)" end="(432, 29)">
          <AtomNode start="(429, 79)" end="(429, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(429, 82)" end="(432, 29)">
            <AtomNode start="(429, 82)" end="(429, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(430, 3)" end="(432, 29)">
              <TacticTacticseq1IndentedNode start="(430, 3)" end="(432, 29)">
                <NullNode start="(430, 3)" end="(432, 29)">
                  <OtherNode start="(430, 3)" end="(430, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;⊢ findIdx p (xs ++ ys) = if findIdx p xs &amp;lt; xs.size then findIdx p xs else findIdx p ys + xs.size" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ findIdx p ({ toList := xs } ++ ys) =&#10;    if findIdx p { toList := xs } &amp;lt; { toList := xs }.size then findIdx p { toList := xs }&#10;    else findIdx p ys + { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(430, 3)" end="(430, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(430, 10)" end="(430, 12)">
                      <OtherNode start="(430, 10)" end="(430, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(430, 10)" end="(430, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(430, 13)" end="(430, 22)">
                      <AtomNode start="(430, 13)" end="(430, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(430, 18)" end="(430, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(430, 18)" end="(430, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(430, 18)" end="(430, 22)">
                            <OtherNode start="(430, 18)" end="(430, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(430, 18)" end="(430, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(430, 19)" end="(430, 21)">
                                <OtherNode start="(430, 19)" end="(430, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(430, 19)" end="(430, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(430, 19)" end="(430, 21)">
                                      <OtherNode start="(430, 19)" end="(430, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(430, 19)" end="(430, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(430, 21)" end="(430, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(431, 3)" end="(431, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ findIdx p ({ toList := xs } ++ ys) =&#10;    if findIdx p { toList := xs } &amp;lt; { toList := xs }.size then findIdx p { toList := xs }&#10;    else findIdx p ys + { toList := xs }.size" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ findIdx p ({ toList := xs } ++ { toList := ys }) =&#10;    if findIdx p { toList := xs } &amp;lt; { toList := xs }.size then findIdx p { toList := xs }&#10;    else findIdx p { toList := ys } + { toList := xs }.size" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(431, 3)" end="(431, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(431, 10)" end="(431, 12)">
                      <OtherNode start="(431, 10)" end="(431, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(431, 10)" end="(431, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(431, 13)" end="(431, 22)">
                      <AtomNode start="(431, 13)" end="(431, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(431, 18)" end="(431, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(431, 18)" end="(431, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(431, 18)" end="(431, 22)">
                            <OtherNode start="(431, 18)" end="(431, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(431, 18)" end="(431, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(431, 19)" end="(431, 21)">
                                <OtherNode start="(431, 19)" end="(431, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(431, 19)" end="(431, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(431, 19)" end="(431, 21)">
                                      <OtherNode start="(431, 19)" end="(431, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(431, 19)" end="(431, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(431, 21)" end="(431, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(432, 3)" end="(432, 29)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ findIdx p ({ toList := xs } ++ { toList := ys }) =&#10;    if findIdx p { toList := xs } &amp;lt; { toList := xs }.size then findIdx p { toList := xs }&#10;    else findIdx p { toList := ys } + { toList := xs }.size" state_after="no goals" tactic="simp [List.findIdx_append]">
                    <AtomNode start="(432, 3)" end="(432, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(432, 8)" end="(432, 29)">
                      <AtomNode start="(432, 8)" end="(432, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(432, 9)" end="(432, 28)">
                        <OtherNode start="(432, 9)" end="(432, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(432, 9)" end="(432, 28)" leading="" trailing="" raw_val="List.findIdx_append" val="List.findIdx_append" full_name="List.findIdx_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(432, 28)" end="(432, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(434, 1)" end="(439, 43)" name="findIdx_push" full_name="Array.findIdx_push">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(434, 1)" end="(439, 43)" name="findIdx_push" full_name="Array.findIdx_push" _is_private_decl="False">
        <AtomNode start="(434, 1)" end="(434, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(434, 9)" end="(434, 21)">
          <IdentNode start="(434, 9)" end="(434, 21)" leading="" trailing=" " raw_val="findIdx_push" val="findIdx_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(434, 22)" end="(435, 108)">
          <NullNode start="(434, 22)" end="(434, 59)">
            <OtherNode start="(434, 22)" end="(434, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(434, 22)" end="(434, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(434, 23)" end="(434, 25)">
                <IdentNode start="(434, 23)" end="(434, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(434, 26)" end="(434, 35)">
                <AtomNode start="(434, 26)" end="(434, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(434, 28)" end="(434, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(434, 28)" end="(434, 33)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(434, 34)" end="(434, 35)">
                    <IdentNode start="(434, 34)" end="(434, 35)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(434, 35)" end="(434, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(434, 37)" end="(434, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(434, 37)" end="(434, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(434, 38)" end="(434, 39)">
                <IdentNode start="(434, 38)" end="(434, 39)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(434, 40)" end="(434, 43)">
                <AtomNode start="(434, 40)" end="(434, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(434, 42)" end="(434, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(434, 43)" end="(434, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(434, 45)" end="(434, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(434, 45)" end="(434, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(434, 46)" end="(434, 47)">
                <IdentNode start="(434, 46)" end="(434, 47)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(434, 48)" end="(434, 58)">
                <AtomNode start="(434, 48)" end="(434, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(434, 50)" end="(434, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(434, 50)" end="(434, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(434, 52)" end="(434, 53)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(434, 54)" end="(434, 58)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(434, 58)" end="(434, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(434, 60)" end="(435, 108)">
            <AtomNode start="(434, 60)" end="(434, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(435, 5)" end="(435, 108)" kind="«term_=_»">
              <OtherNode start="(435, 5)" end="(435, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(435, 5)" end="(435, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(435, 5)" end="(435, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(435, 5)" end="(435, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(435, 6)" end="(435, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(435, 6)" end="(435, 13)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(435, 14)" end="(435, 15)">
                        <IdentNode start="(435, 14)" end="(435, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(435, 15)" end="(435, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(435, 16)" end="(435, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(435, 17)" end="(435, 24)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="Array.findIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(435, 25)" end="(435, 26)">
                  <IdentNode start="(435, 25)" end="(435, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(435, 27)" end="(435, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(435, 29)" end="(435, 108)" kind="termIfThenElse">
                <AtomNode start="(435, 29)" end="(435, 31)" leading="" trailing=" " val="if"/>
                <OtherNode start="(435, 32)" end="(435, 54)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(435, 32)" end="(435, 44)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(435, 32)" end="(435, 42)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(435, 43)" end="(435, 44)">
                      <IdentNode start="(435, 43)" end="(435, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(435, 45)" end="(435, 46)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(435, 47)" end="(435, 54)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                </OtherNode>
                <AtomNode start="(435, 55)" end="(435, 59)" leading="" trailing=" " val="then"/>
                <OtherNode start="(435, 60)" end="(435, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(435, 60)" end="(435, 70)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(435, 71)" end="(435, 72)">
                    <IdentNode start="(435, 71)" end="(435, 72)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(435, 73)" end="(435, 77)" leading="" trailing=" " val="else"/>
                <OtherNode start="(435, 78)" end="(435, 108)" kind="«term_+_»">
                  <IdentNode start="(435, 78)" end="(435, 85)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(435, 86)" end="(435, 87)" leading="" trailing=" " val="+"/>
                  <OtherNode start="(435, 88)" end="(435, 108)" kind="termIfThenElse">
                    <AtomNode start="(435, 88)" end="(435, 90)" leading="" trailing=" " val="if"/>
                    <OtherNode start="(435, 91)" end="(435, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(435, 91)" end="(435, 92)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(435, 93)" end="(435, 94)">
                        <IdentNode start="(435, 93)" end="(435, 94)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(435, 95)" end="(435, 99)" leading="" trailing=" " val="then"/>
                    <OtherNode start="(435, 100)" end="(435, 101)" kind="num">
                      <AtomNode start="(435, 100)" end="(435, 101)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                    <AtomNode start="(435, 102)" end="(435, 106)" leading="" trailing=" " val="else"/>
                    <OtherNode start="(435, 107)" end="(435, 108)" kind="num">
                      <AtomNode start="(435, 107)" end="(435, 108)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(435, 109)" end="(439, 43)">
          <AtomNode start="(435, 109)" end="(435, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(435, 112)" end="(439, 43)">
            <AtomNode start="(435, 112)" end="(435, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(436, 3)" end="(439, 43)">
              <TacticTacticseq1IndentedNode start="(436, 3)" end="(439, 43)">
                <NullNode start="(436, 3)" end="(439, 43)">
                  <OtherNode start="(436, 3)" end="(436, 45)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ findIdx p (xs.push a) = if findIdx p xs &amp;lt; xs.size then findIdx p xs else xs.size + if p a = true then 0 else 1" state_after="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ (if findIdx p xs &amp;lt; xs.size then findIdx p xs else findIdx p #[a] + xs.size) =&#10;    if findIdx p xs &amp;lt; xs.size then findIdx p xs else xs.size + if p a = true then 0 else 1" tactic="simp only [push_eq_append, findIdx_append]">
                    <AtomNode start="(436, 3)" end="(436, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(436, 8)" end="(436, 12)">
                      <AtomNode start="(436, 8)" end="(436, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(436, 13)" end="(436, 45)">
                      <AtomNode start="(436, 13)" end="(436, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(436, 14)" end="(436, 44)">
                        <OtherNode start="(436, 14)" end="(436, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(436, 14)" end="(436, 28)" leading="" trailing="" raw_val="push_eq_append" val="push_eq_append" full_name="Array.push_eq_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(436, 28)" end="(436, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(436, 30)" end="(436, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(436, 30)" end="(436, 44)" leading="" trailing="" raw_val="findIdx_append" val="findIdx_append" full_name="Array.findIdx_append" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(427, 9)" def_end="(427, 23)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(436, 44)" end="(436, 45)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(437, 3)" end="(437, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ (if findIdx p xs &amp;lt; xs.size then findIdx p xs else findIdx p #[a] + xs.size) =&#10;    if findIdx p xs &amp;lt; xs.size then findIdx p xs else xs.size + if p a = true then 0 else 1" state_after="case isTrue&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p xs = findIdx p xs&#10;&#10;case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p #[a] + xs.size = xs.size + if p a = true then 0 else 1" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(437, 3)" end="(437, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(437, 3)" end="(437, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(437, 9)" end="(437, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(437, 13)" end="(437, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(437, 13)" end="(437, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(437, 22)" end="(437, 23)">
                        <LeanBinderidentNode start="(437, 22)" end="(437, 23)">
                          <IdentNode start="(437, 22)" end="(437, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(438, 3)" end="(438, 8)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p xs = findIdx p xs&#10;&#10;case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p #[a] + xs.size = xs.size + if p a = true then 0 else 1" state_after="case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p #[a] + xs.size = xs.size + if p a = true then 0 else 1" tactic="· rfl">
                    <OtherNode start="(438, 3)" end="(438, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(438, 3)" end="(438, 4)" kind="patternIgnore">
                        <OtherNode start="(438, 3)" end="(438, 4)" kind="token.«· »">
                          <AtomNode start="(438, 3)" end="(438, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(438, 5)" end="(438, 8)">
                      <TacticTacticseq1IndentedNode start="(438, 5)" end="(438, 8)">
                        <NullNode start="(438, 5)" end="(438, 8)">
                          <OtherNode start="(438, 5)" end="(438, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case isTrue&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p xs = findIdx p xs" state_after="no goals" tactic="rfl">
                            <AtomNode start="(438, 5)" end="(438, 8)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(439, 3)" end="(439, 43)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p #[a] + xs.size = xs.size + if p a = true then 0 else 1" state_after="no goals" tactic="· simp [findIdx_singleton, Nat.add_comm]">
                    <OtherNode start="(439, 3)" end="(439, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(439, 3)" end="(439, 4)" kind="patternIgnore">
                        <OtherNode start="(439, 3)" end="(439, 4)" kind="token.«· »">
                          <AtomNode start="(439, 3)" end="(439, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(439, 5)" end="(439, 43)">
                      <TacticTacticseq1IndentedNode start="(439, 5)" end="(439, 43)">
                        <NullNode start="(439, 5)" end="(439, 43)">
                          <OtherNode start="(439, 5)" end="(439, 43)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬findIdx p xs &amp;lt; xs.size&#10;⊢ findIdx p #[a] + xs.size = xs.size + if p a = true then 0 else 1" state_after="no goals" tactic="simp [findIdx_singleton, Nat.add_comm]">
                            <AtomNode start="(439, 5)" end="(439, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(439, 10)" end="(439, 43)">
                              <AtomNode start="(439, 10)" end="(439, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(439, 11)" end="(439, 42)">
                                <OtherNode start="(439, 11)" end="(439, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(439, 11)" end="(439, 28)" leading="" trailing="" raw_val="findIdx_singleton" val="findIdx_singleton" full_name="Array.findIdx_singleton" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(350, 9)" def_end="(350, 26)"/>
                                </OtherNode>
                                <AtomNode start="(439, 28)" end="(439, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(439, 30)" end="(439, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(439, 30)" end="(439, 42)" leading="" trailing="" raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(439, 42)" end="(439, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(441, 1)" end="(443, 37)" name="findIdx_le_findIdx" full_name="Array.findIdx_le_findIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(441, 1)" end="(443, 37)" name="findIdx_le_findIdx" full_name="Array.findIdx_le_findIdx" _is_private_decl="False">
        <AtomNode start="(441, 1)" end="(441, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(441, 9)" end="(441, 27)">
          <IdentNode start="(441, 9)" end="(441, 27)" leading="" trailing=" " raw_val="findIdx_le_findIdx" val="findIdx_le_findIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(441, 28)" end="(441, 115)">
          <NullNode start="(441, 28)" end="(441, 85)">
            <OtherNode start="(441, 28)" end="(441, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(441, 28)" end="(441, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(441, 29)" end="(441, 31)">
                <IdentNode start="(441, 29)" end="(441, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(441, 32)" end="(441, 41)">
                <AtomNode start="(441, 32)" end="(441, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 34)" end="(441, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(441, 34)" end="(441, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(441, 40)" end="(441, 41)">
                    <IdentNode start="(441, 40)" end="(441, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(441, 41)" end="(441, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(441, 43)" end="(441, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(441, 43)" end="(441, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(441, 44)" end="(441, 47)">
                <IdentNode start="(441, 44)" end="(441, 45)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(441, 46)" end="(441, 47)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(441, 48)" end="(441, 58)">
                <AtomNode start="(441, 48)" end="(441, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 50)" end="(441, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(441, 50)" end="(441, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(441, 52)" end="(441, 53)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(441, 54)" end="(441, 58)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(441, 58)" end="(441, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(441, 60)" end="(441, 85)">
              <AtomNode start="(441, 60)" end="(441, 61)" leading="" trailing="" val="("/>
              <NullNode start="(441, 61)" end="(441, 62)">
                <IdentNode start="(441, 61)" end="(441, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(441, 63)" end="(441, 84)">
                <AtomNode start="(441, 63)" end="(441, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 65)" end="(441, 84)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(441, 65)" end="(441, 66)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(441, 67)" end="(441, 68)">
                    <IdentNode start="(441, 67)" end="(441, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(441, 69)" end="(441, 73)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(441, 69)" end="(441, 70)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(441, 71)" end="(441, 73)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(441, 73)" end="(441, 74)" leading="" trailing=" " val=","/>
                  <OtherNode start="(441, 75)" end="(441, 84)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(441, 75)" end="(441, 78)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(441, 75)" end="(441, 76)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(441, 77)" end="(441, 78)">
                        <IdentNode start="(441, 77)" end="(441, 78)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(441, 79)" end="(441, 80)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(441, 81)" end="(441, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(441, 81)" end="(441, 82)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(441, 83)" end="(441, 84)">
                        <IdentNode start="(441, 83)" end="(441, 84)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(441, 84)" end="(441, 85)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(441, 86)" end="(441, 115)">
            <AtomNode start="(441, 86)" end="(441, 87)" leading="" trailing=" " val=":"/>
            <OtherNode start="(441, 88)" end="(441, 115)" kind="«term_≤_»">
              <OtherNode start="(441, 88)" end="(441, 100)" kind="Lean.Parser.Term.app">
                <IdentNode start="(441, 88)" end="(441, 98)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(441, 99)" end="(441, 100)">
                  <IdentNode start="(441, 99)" end="(441, 100)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(441, 101)" end="(441, 102)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(441, 103)" end="(441, 115)" kind="Lean.Parser.Term.app">
                <IdentNode start="(441, 103)" end="(441, 113)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(441, 114)" end="(441, 115)">
                  <IdentNode start="(441, 114)" end="(441, 115)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(441, 116)" end="(443, 37)">
          <AtomNode start="(441, 116)" end="(441, 118)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(441, 119)" end="(443, 37)">
            <AtomNode start="(441, 119)" end="(441, 121)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(442, 3)" end="(443, 37)">
              <TacticTacticseq1IndentedNode start="(442, 3)" end="(443, 37)">
                <NullNode start="(442, 3)" end="(443, 37)">
                  <OtherNode start="(442, 3)" end="(442, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p q : α → Bool&#10;h : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;⊢ findIdx q xs ≤ findIdx p xs" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;h : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;⊢ findIdx q { toList := xs } ≤ findIdx p { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(442, 3)" end="(442, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(442, 10)" end="(442, 12)">
                      <OtherNode start="(442, 10)" end="(442, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(442, 10)" end="(442, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(442, 13)" end="(442, 22)">
                      <AtomNode start="(442, 13)" end="(442, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(442, 18)" end="(442, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(442, 18)" end="(442, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(442, 18)" end="(442, 22)">
                            <OtherNode start="(442, 18)" end="(442, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(442, 18)" end="(442, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(442, 19)" end="(442, 21)">
                                <OtherNode start="(442, 19)" end="(442, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(442, 19)" end="(442, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(442, 19)" end="(442, 21)">
                                      <OtherNode start="(442, 19)" end="(442, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(442, 19)" end="(442, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(442, 21)" end="(442, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(443, 3)" end="(443, 37)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;h : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;⊢ findIdx q { toList := xs } ≤ findIdx p { toList := xs }" state_after="no goals" tactic="simp_all [List.findIdx_le_findIdx]">
                    <AtomNode start="(443, 3)" end="(443, 11)" leading="" trailing=" " val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(443, 12)" end="(443, 37)">
                      <AtomNode start="(443, 12)" end="(443, 13)" leading="" trailing="" val="["/>
                      <NullNode start="(443, 13)" end="(443, 36)">
                        <OtherNode start="(443, 13)" end="(443, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(443, 13)" end="(443, 36)" leading="" trailing="" raw_val="List.findIdx_le_findIdx" val="List.findIdx_le_findIdx" full_name="List.findIdx_le_findIdx" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(443, 36)" end="(443, 37)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(445, 1)" end="(449, 12)" name="findIdx_subtype" full_name="Array.findIdx_subtype">
      <CommandDeclmodifiersNode start="(445, 1)" end="(445, 8)">
        <NullNode/>
        <NullNode start="(445, 1)" end="(445, 8)">
          <OtherNode start="(445, 1)" end="(445, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(445, 1)" end="(445, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(445, 3)" end="(445, 7)">
              <OtherNode start="(445, 3)" end="(445, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(445, 3)" end="(445, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(445, 3)" end="(445, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(445, 7)" end="(445, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(445, 9)" end="(449, 12)" name="findIdx_subtype" full_name="Array.findIdx_subtype" _is_private_decl="False">
        <AtomNode start="(445, 9)" end="(445, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(445, 17)" end="(445, 32)">
          <IdentNode start="(445, 17)" end="(445, 32)" leading="" trailing=" " raw_val="findIdx_subtype" val="findIdx_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(445, 33)" end="(447, 41)">
          <NullNode start="(445, 33)" end="(446, 74)">
            <OtherNode start="(445, 33)" end="(445, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(445, 33)" end="(445, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(445, 34)" end="(445, 35)">
                <IdentNode start="(445, 34)" end="(445, 35)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(445, 36)" end="(445, 46)">
                <AtomNode start="(445, 36)" end="(445, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(445, 38)" end="(445, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(445, 38)" end="(445, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(445, 40)" end="(445, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(445, 42)" end="(445, 46)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(445, 42)" end="(445, 46)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(445, 46)" end="(445, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(445, 48)" end="(445, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(445, 48)" end="(445, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(445, 49)" end="(445, 51)">
                <IdentNode start="(445, 49)" end="(445, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(445, 52)" end="(445, 72)">
                <AtomNode start="(445, 52)" end="(445, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(445, 54)" end="(445, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(445, 54)" end="(445, 59)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(445, 60)" end="(445, 72)">
                    <OtherNode start="(445, 60)" end="(445, 72)" kind="«term{_:_//_}»">
                      <AtomNode start="(445, 60)" end="(445, 61)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(445, 62)" end="(445, 63)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(445, 64)" end="(445, 66)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(445, 67)" end="(445, 70)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(445, 67)" end="(445, 68)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(445, 69)" end="(445, 70)">
                          <IdentNode start="(445, 69)" end="(445, 70)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(445, 71)" end="(445, 72)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(445, 72)" end="(445, 73)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(446, 5)" end="(446, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(446, 5)" end="(446, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(446, 6)" end="(446, 7)">
                <IdentNode start="(446, 6)" end="(446, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(446, 8)" end="(446, 29)">
                <AtomNode start="(446, 8)" end="(446, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 10)" end="(446, 29)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(446, 10)" end="(446, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(446, 10)" end="(446, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(446, 12)" end="(446, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(446, 14)" end="(446, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(446, 17)" end="(446, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(446, 17)" end="(446, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(446, 19)" end="(446, 20)">
                        <IdentNode start="(446, 19)" end="(446, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(446, 21)" end="(446, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(446, 23)" end="(446, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(446, 25)" end="(446, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(446, 29)" end="(446, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(446, 31)" end="(446, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(446, 31)" end="(446, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(446, 32)" end="(446, 33)">
                <IdentNode start="(446, 32)" end="(446, 33)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(446, 34)" end="(446, 44)">
                <AtomNode start="(446, 34)" end="(446, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 36)" end="(446, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(446, 36)" end="(446, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(446, 38)" end="(446, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(446, 40)" end="(446, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(446, 44)" end="(446, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(446, 46)" end="(446, 74)">
              <AtomNode start="(446, 46)" end="(446, 47)" leading="" trailing="" val="("/>
              <NullNode start="(446, 47)" end="(446, 49)">
                <IdentNode start="(446, 47)" end="(446, 49)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(446, 50)" end="(446, 73)">
                <AtomNode start="(446, 50)" end="(446, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 52)" end="(446, 73)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(446, 52)" end="(446, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(446, 54)" end="(446, 57)">
                    <IdentNode start="(446, 54)" end="(446, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(446, 56)" end="(446, 57)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(446, 57)" end="(446, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(446, 59)" end="(446, 73)" kind="«term_=_»">
                    <OtherNode start="(446, 59)" end="(446, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(446, 59)" end="(446, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(446, 61)" end="(446, 67)">
                        <OtherNode start="(446, 61)" end="(446, 67)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(446, 61)" end="(446, 62)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(446, 62)" end="(446, 66)">
                            <IdentNode start="(446, 62)" end="(446, 63)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(446, 63)" end="(446, 64)" leading="" trailing=" " val=","/>
                            <IdentNode start="(446, 65)" end="(446, 66)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(446, 66)" end="(446, 67)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(446, 68)" end="(446, 69)" leading="" trailing=" " val="="/>
                    <OtherNode start="(446, 70)" end="(446, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(446, 70)" end="(446, 71)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(446, 72)" end="(446, 73)">
                        <IdentNode start="(446, 72)" end="(446, 73)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(446, 73)" end="(446, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(446, 75)" end="(447, 41)">
            <AtomNode start="(446, 75)" end="(446, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(447, 5)" end="(447, 41)" kind="«term_=_»">
              <OtherNode start="(447, 5)" end="(447, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(447, 5)" end="(447, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(447, 16)" end="(447, 17)">
                  <IdentNode start="(447, 16)" end="(447, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(447, 18)" end="(447, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(447, 20)" end="(447, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(447, 20)" end="(447, 39)" leading="" trailing=" " raw_val="xs.unattach.findIdx" val="xs.unattach.findIdx"/>
                <NullNode start="(447, 40)" end="(447, 41)">
                  <IdentNode start="(447, 40)" end="(447, 41)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(447, 42)" end="(449, 12)">
          <AtomNode start="(447, 42)" end="(447, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(447, 45)" end="(449, 12)">
            <AtomNode start="(447, 45)" end="(447, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(448, 3)" end="(449, 12)">
              <TacticTacticseq1IndentedNode start="(448, 3)" end="(449, 12)">
                <NullNode start="(448, 3)" end="(449, 12)">
                  <OtherNode start="(448, 3)" end="(448, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx f xs = findIdx g xs.unattach" state_after="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ findIdx f { toList := toList✝ } = findIdx g { toList := toList✝ }.unattach" tactic="cases xs">
                    <AtomNode start="(448, 3)" end="(448, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(448, 9)" end="(448, 11)">
                      <OtherNode start="(448, 9)" end="(448, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(448, 9)" end="(448, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(449, 3)" end="(449, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ findIdx f { toList := toList✝ } = findIdx g { toList := toList✝ }.unattach" state_after="no goals" tactic="simp [hf]">
                    <AtomNode start="(449, 3)" end="(449, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(449, 8)" end="(449, 12)">
                      <AtomNode start="(449, 8)" end="(449, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(449, 9)" end="(449, 11)">
                        <OtherNode start="(449, 9)" end="(449, 11)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(449, 9)" end="(449, 11)" leading="" trailing="" raw_val="hf" val="hf"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(449, 11)" end="(449, 12)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(451, 1)" end="(454, 58)" name="false_of_mem_extract_findIdx" full_name="Array.false_of_mem_extract_findIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(451, 1)" end="(454, 58)" name="false_of_mem_extract_findIdx" full_name="Array.false_of_mem_extract_findIdx" _is_private_decl="False">
        <AtomNode start="(451, 1)" end="(451, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(451, 9)" end="(451, 37)">
          <IdentNode start="(451, 9)" end="(451, 37)" leading="" trailing=" " raw_val="false_of_mem_extract_findIdx" val="false_of_mem_extract_findIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(451, 38)" end="(452, 16)">
          <NullNode start="(451, 38)" end="(451, 105)">
            <OtherNode start="(451, 38)" end="(451, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(451, 38)" end="(451, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(451, 39)" end="(451, 41)">
                <IdentNode start="(451, 39)" end="(451, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(451, 42)" end="(451, 51)">
                <AtomNode start="(451, 42)" end="(451, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(451, 44)" end="(451, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(451, 44)" end="(451, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(451, 50)" end="(451, 51)">
                    <IdentNode start="(451, 50)" end="(451, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(451, 51)" end="(451, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(451, 53)" end="(451, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(451, 53)" end="(451, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(451, 54)" end="(451, 55)">
                <IdentNode start="(451, 54)" end="(451, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(451, 56)" end="(451, 66)">
                <AtomNode start="(451, 56)" end="(451, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(451, 58)" end="(451, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(451, 58)" end="(451, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(451, 60)" end="(451, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(451, 62)" end="(451, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(451, 66)" end="(451, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(451, 68)" end="(451, 105)">
              <AtomNode start="(451, 68)" end="(451, 69)" leading="" trailing="" val="("/>
              <NullNode start="(451, 69)" end="(451, 70)">
                <IdentNode start="(451, 69)" end="(451, 70)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(451, 71)" end="(451, 104)">
                <AtomNode start="(451, 71)" end="(451, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(451, 73)" end="(451, 104)" kind="«term_∈_»">
                  <IdentNode start="(451, 73)" end="(451, 74)" leading="" trailing=" " raw_val="x" val="x"/>
                  <AtomNode start="(451, 75)" end="(451, 76)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(451, 77)" end="(451, 104)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(451, 77)" end="(451, 87)" leading="" trailing=" " raw_val="xs.extract" val="xs.extract"/>
                    <NullNode start="(451, 88)" end="(451, 104)">
                      <OtherNode start="(451, 88)" end="(451, 89)" kind="num">
                        <AtomNode start="(451, 88)" end="(451, 89)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                      <OtherNode start="(451, 90)" end="(451, 104)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(451, 90)" end="(451, 91)" leading="" trailing="" val="("/>
                        <OtherNode start="(451, 91)" end="(451, 103)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(451, 91)" end="(451, 101)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                          <NullNode start="(451, 102)" end="(451, 103)">
                            <IdentNode start="(451, 102)" end="(451, 103)" leading="" trailing="" raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(451, 103)" end="(451, 104)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(451, 104)" end="(451, 105)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(451, 106)" end="(452, 16)">
            <AtomNode start="(451, 106)" end="(451, 107)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(452, 5)" end="(452, 16)" kind="«term_=_»">
              <OtherNode start="(452, 5)" end="(452, 8)" kind="Lean.Parser.Term.app">
                <IdentNode start="(452, 5)" end="(452, 6)" leading="" trailing=" " raw_val="p" val="p"/>
                <NullNode start="(452, 7)" end="(452, 8)">
                  <IdentNode start="(452, 7)" end="(452, 8)" leading="" trailing=" " raw_val="x" val="x"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(452, 9)" end="(452, 10)" leading="" trailing=" " val="="/>
              <IdentNode start="(452, 11)" end="(452, 16)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(452, 17)" end="(454, 58)">
          <AtomNode start="(452, 17)" end="(452, 19)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(452, 20)" end="(454, 58)">
            <AtomNode start="(452, 20)" end="(452, 22)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(453, 3)" end="(454, 58)">
              <TacticTacticseq1IndentedNode start="(453, 3)" end="(454, 58)">
                <NullNode start="(453, 3)" end="(454, 58)">
                  <OtherNode start="(453, 3)" end="(453, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;x : α&#10;xs : Array α&#10;p : α → Bool&#10;h : x ∈ xs.extract 0 (findIdx p xs)&#10;⊢ p x = false" state_after="case mk&#10;α : Type u_1&#10;x : α&#10;p : α → Bool&#10;xs : List α&#10;h : x ∈ { toList := xs }.extract 0 (findIdx p { toList := xs })&#10;⊢ p x = false" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(453, 3)" end="(453, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(453, 10)" end="(453, 12)">
                      <OtherNode start="(453, 10)" end="(453, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(453, 10)" end="(453, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(453, 13)" end="(453, 22)">
                      <AtomNode start="(453, 13)" end="(453, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(453, 18)" end="(453, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(453, 18)" end="(453, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(453, 18)" end="(453, 22)">
                            <OtherNode start="(453, 18)" end="(453, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(453, 18)" end="(453, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(453, 19)" end="(453, 21)">
                                <OtherNode start="(453, 19)" end="(453, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(453, 19)" end="(453, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(453, 19)" end="(453, 21)">
                                      <OtherNode start="(453, 19)" end="(453, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(453, 19)" end="(453, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(453, 21)" end="(453, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(454, 3)" end="(454, 58)" kind="Lean.Parser.Tactic.exact" state_before="case mk&#10;α : Type u_1&#10;x : α&#10;p : α → Bool&#10;xs : List α&#10;h : x ∈ { toList := xs }.extract 0 (findIdx p { toList := xs })&#10;⊢ p x = false" state_after="no goals" tactic="exact List.false_of_mem_take_findIdx (by simpa using h)">
                    <AtomNode start="(454, 3)" end="(454, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(454, 9)" end="(454, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(454, 9)" end="(454, 39)" leading="" trailing=" " raw_val="List.false_of_mem_take_findIdx" val="List.false_of_mem_take_findIdx" full_name="List.false_of_mem_take_findIdx" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                      <NullNode start="(454, 40)" end="(454, 58)">
                        <OtherNode start="(454, 40)" end="(454, 58)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(454, 40)" end="(454, 41)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(454, 41)" end="(454, 57)">
                            <AtomNode start="(454, 41)" end="(454, 43)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(454, 44)" end="(454, 57)">
                              <TacticTacticseq1IndentedNode start="(454, 44)" end="(454, 57)">
                                <NullNode start="(454, 44)" end="(454, 57)">
                                  <OtherNode start="(454, 44)" end="(454, 57)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;x : α&#10;p : α → Bool&#10;xs : List α&#10;h : x ∈ { toList := xs }.extract 0 (findIdx p { toList := xs })&#10;⊢ x ∈ List.take (List.findIdx p ?m.77552) ?m.77552" state_after="no goals" tactic="simpa using h">
                                    <AtomNode start="(454, 44)" end="(454, 49)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(454, 50)" end="(454, 57)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(454, 50)" end="(454, 57)">
                                        <AtomNode start="(454, 50)" end="(454, 55)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(454, 56)" end="(454, 57)" leading="" trailing="" raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(454, 57)" end="(454, 58)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(456, 1)" end="(459, 7)" name="findIdx_extract" full_name="Array.findIdx_extract">
      <CommandDeclmodifiersNode start="(456, 1)" end="(456, 8)">
        <NullNode/>
        <NullNode start="(456, 1)" end="(456, 8)">
          <OtherNode start="(456, 1)" end="(456, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(456, 1)" end="(456, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(456, 3)" end="(456, 7)">
              <OtherNode start="(456, 3)" end="(456, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(456, 3)" end="(456, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(456, 3)" end="(456, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(456, 7)" end="(456, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(456, 9)" end="(459, 7)" name="findIdx_extract" full_name="Array.findIdx_extract" _is_private_decl="False">
        <AtomNode start="(456, 9)" end="(456, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(456, 17)" end="(456, 32)">
          <IdentNode start="(456, 17)" end="(456, 32)" leading="" trailing=" " raw_val="findIdx_extract" val="findIdx_extract"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(456, 33)" end="(457, 54)">
          <NullNode start="(456, 33)" end="(456, 72)">
            <OtherNode start="(456, 33)" end="(456, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(456, 33)" end="(456, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(456, 34)" end="(456, 36)">
                <IdentNode start="(456, 34)" end="(456, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(456, 37)" end="(456, 46)">
                <AtomNode start="(456, 37)" end="(456, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(456, 39)" end="(456, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(456, 39)" end="(456, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(456, 45)" end="(456, 46)">
                    <IdentNode start="(456, 45)" end="(456, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(456, 46)" end="(456, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(456, 48)" end="(456, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(456, 48)" end="(456, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(456, 49)" end="(456, 50)">
                <IdentNode start="(456, 49)" end="(456, 50)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(456, 51)" end="(456, 56)">
                <AtomNode start="(456, 51)" end="(456, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(456, 53)" end="(456, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(456, 56)" end="(456, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(456, 58)" end="(456, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(456, 58)" end="(456, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(456, 59)" end="(456, 60)">
                <IdentNode start="(456, 59)" end="(456, 60)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(456, 61)" end="(456, 71)">
                <AtomNode start="(456, 61)" end="(456, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(456, 63)" end="(456, 71)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(456, 63)" end="(456, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(456, 65)" end="(456, 66)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(456, 67)" end="(456, 71)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(456, 71)" end="(456, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(456, 73)" end="(457, 54)">
            <AtomNode start="(456, 73)" end="(456, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(457, 5)" end="(457, 54)" kind="«term_=_»">
              <OtherNode start="(457, 5)" end="(457, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(457, 5)" end="(457, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(457, 5)" end="(457, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(457, 5)" end="(457, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(457, 6)" end="(457, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(457, 6)" end="(457, 16)" leading="" trailing=" " raw_val="xs.extract" val="xs.extract"/>
                      <NullNode start="(457, 17)" end="(457, 20)">
                        <OtherNode start="(457, 17)" end="(457, 18)" kind="num">
                          <AtomNode start="(457, 17)" end="(457, 18)" leading="" trailing=" " val="0"/>
                        </OtherNode>
                        <IdentNode start="(457, 19)" end="(457, 20)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(457, 20)" end="(457, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(457, 21)" end="(457, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(457, 22)" end="(457, 29)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="Array.findIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(457, 30)" end="(457, 31)">
                  <IdentNode start="(457, 30)" end="(457, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(457, 32)" end="(457, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(457, 34)" end="(457, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(457, 34)" end="(457, 37)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(457, 38)" end="(457, 54)">
                  <IdentNode start="(457, 38)" end="(457, 39)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(457, 40)" end="(457, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(457, 40)" end="(457, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(457, 41)" end="(457, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(457, 41)" end="(457, 51)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(457, 52)" end="(457, 53)">
                        <IdentNode start="(457, 52)" end="(457, 53)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(457, 53)" end="(457, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(457, 55)" end="(459, 7)">
          <AtomNode start="(457, 55)" end="(457, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(457, 58)" end="(459, 7)">
            <AtomNode start="(457, 58)" end="(457, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(458, 3)" end="(459, 7)">
              <TacticTacticseq1IndentedNode start="(458, 3)" end="(459, 7)">
                <NullNode start="(458, 3)" end="(459, 7)">
                  <OtherNode start="(458, 3)" end="(458, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;p : α → Bool&#10;⊢ findIdx p (xs.extract 0 i) = min i (findIdx p xs)" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findIdx p ({ toList := toList✝ }.extract 0 i) = min i (findIdx p { toList := toList✝ })" tactic="cases xs">
                    <AtomNode start="(458, 3)" end="(458, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(458, 9)" end="(458, 11)">
                      <OtherNode start="(458, 9)" end="(458, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(458, 9)" end="(458, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(459, 3)" end="(459, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findIdx p ({ toList := toList✝ }.extract 0 i) = min i (findIdx p { toList := toList✝ })" state_after="no goals" tactic="simp">
                    <AtomNode start="(459, 3)" end="(459, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(461, 1)" end="(464, 7)" name="min_findIdx_findIdx" full_name="Array.min_findIdx_findIdx">
      <CommandDeclmodifiersNode start="(461, 1)" end="(461, 8)">
        <NullNode/>
        <NullNode start="(461, 1)" end="(461, 8)">
          <OtherNode start="(461, 1)" end="(461, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(461, 1)" end="(461, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(461, 3)" end="(461, 7)">
              <OtherNode start="(461, 3)" end="(461, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(461, 3)" end="(461, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(461, 3)" end="(461, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(461, 7)" end="(461, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(461, 9)" end="(464, 7)" name="min_findIdx_findIdx" full_name="Array.min_findIdx_findIdx" _is_private_decl="False">
        <AtomNode start="(461, 9)" end="(461, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(461, 17)" end="(461, 36)">
          <IdentNode start="(461, 17)" end="(461, 36)" leading="" trailing=" " raw_val="min_findIdx_findIdx" val="min_findIdx_findIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(461, 37)" end="(462, 73)">
          <NullNode start="(461, 37)" end="(461, 68)">
            <OtherNode start="(461, 37)" end="(461, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(461, 37)" end="(461, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(461, 38)" end="(461, 40)">
                <IdentNode start="(461, 38)" end="(461, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(461, 41)" end="(461, 50)">
                <AtomNode start="(461, 41)" end="(461, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(461, 43)" end="(461, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(461, 43)" end="(461, 48)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(461, 49)" end="(461, 50)">
                    <IdentNode start="(461, 49)" end="(461, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(461, 50)" end="(461, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(461, 52)" end="(461, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(461, 52)" end="(461, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(461, 53)" end="(461, 56)">
                <IdentNode start="(461, 53)" end="(461, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(461, 55)" end="(461, 56)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(461, 57)" end="(461, 67)">
                <AtomNode start="(461, 57)" end="(461, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(461, 59)" end="(461, 67)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(461, 59)" end="(461, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(461, 61)" end="(461, 62)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(461, 63)" end="(461, 67)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(461, 67)" end="(461, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(461, 69)" end="(462, 73)">
            <AtomNode start="(461, 69)" end="(461, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(462, 5)" end="(462, 73)" kind="«term_=_»">
              <OtherNode start="(462, 5)" end="(462, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(462, 5)" end="(462, 8)" leading="" trailing=" " raw_val="min" val="min" full_name="Min.min" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(462, 9)" end="(462, 38)">
                  <OtherNode start="(462, 9)" end="(462, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(462, 9)" end="(462, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(462, 10)" end="(462, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(462, 10)" end="(462, 20)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(462, 21)" end="(462, 22)">
                        <IdentNode start="(462, 21)" end="(462, 22)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(462, 22)" end="(462, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(462, 24)" end="(462, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(462, 24)" end="(462, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(462, 25)" end="(462, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(462, 25)" end="(462, 35)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(462, 36)" end="(462, 37)">
                        <IdentNode start="(462, 36)" end="(462, 37)" leading="" trailing="" raw_val="q" val="q"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(462, 37)" end="(462, 38)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(462, 39)" end="(462, 40)" leading="" trailing=" " val="="/>
              <OtherNode start="(462, 41)" end="(462, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(462, 41)" end="(462, 51)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(462, 52)" end="(462, 73)">
                  <OtherNode start="(462, 52)" end="(462, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(462, 52)" end="(462, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(462, 53)" end="(462, 72)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(462, 53)" end="(462, 56)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(462, 57)" end="(462, 72)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(462, 57)" end="(462, 58)">
                          <IdentNode start="(462, 57)" end="(462, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(462, 59)" end="(462, 61)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(462, 62)" end="(462, 72)" kind="«term_||_»">
                          <OtherNode start="(462, 62)" end="(462, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(462, 62)" end="(462, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(462, 64)" end="(462, 65)">
                              <IdentNode start="(462, 64)" end="(462, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(462, 66)" end="(462, 68)" leading="" trailing=" " val="||"/>
                          <OtherNode start="(462, 69)" end="(462, 72)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(462, 69)" end="(462, 70)" leading="" trailing=" " raw_val="q" val="q"/>
                            <NullNode start="(462, 71)" end="(462, 72)">
                              <IdentNode start="(462, 71)" end="(462, 72)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(462, 72)" end="(462, 73)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(462, 74)" end="(464, 7)">
          <AtomNode start="(462, 74)" end="(462, 76)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(462, 77)" end="(464, 7)">
            <AtomNode start="(462, 77)" end="(462, 79)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(463, 3)" end="(464, 7)">
              <TacticTacticseq1IndentedNode start="(463, 3)" end="(464, 7)">
                <NullNode start="(463, 3)" end="(464, 7)">
                  <OtherNode start="(463, 3)" end="(463, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xs : Array α&#10;p q : α → Bool&#10;⊢ min (findIdx p xs) (findIdx q xs) = findIdx (fun a =&amp;gt; p a || q a) xs" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;toList✝ : List α&#10;⊢ min (findIdx p { toList := toList✝ }) (findIdx q { toList := toList✝ }) =&#10;    findIdx (fun a =&amp;gt; p a || q a) { toList := toList✝ }" tactic="cases xs">
                    <AtomNode start="(463, 3)" end="(463, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(463, 9)" end="(463, 11)">
                      <OtherNode start="(463, 9)" end="(463, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(463, 9)" end="(463, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(464, 3)" end="(464, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;toList✝ : List α&#10;⊢ min (findIdx p { toList := toList✝ }) (findIdx q { toList := toList✝ }) =&#10;    findIdx (fun a =&amp;gt; p a || q a) { toList := toList✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(464, 3)" end="(464, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(466, 1)" end="(466, 20)" comment="### findIdx? -/">
      <AtomNode start="(466, 1)" end="(466, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(466, 5)" end="(466, 20)" leading="" trailing="&#10;&#10;" val="### findIdx? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(468, 1)" end="(468, 78)" name="findIdx?_empty" full_name="Array.findIdx?_empty">
      <CommandDeclmodifiersNode start="(468, 1)" end="(468, 8)">
        <NullNode/>
        <NullNode start="(468, 1)" end="(468, 8)">
          <OtherNode start="(468, 1)" end="(468, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(468, 1)" end="(468, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(468, 3)" end="(468, 7)">
              <OtherNode start="(468, 3)" end="(468, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(468, 3)" end="(468, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(468, 3)" end="(468, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(468, 7)" end="(468, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(468, 9)" end="(468, 78)" name="findIdx?_empty" full_name="Array.findIdx?_empty" _is_private_decl="False">
        <AtomNode start="(468, 9)" end="(468, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(468, 17)" end="(468, 31)">
          <IdentNode start="(468, 17)" end="(468, 31)" leading="" trailing=" " raw_val="findIdx?_empty" val="findIdx?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(468, 32)" end="(468, 67)">
          <NullNode/>
          <TermTypespecNode start="(468, 32)" end="(468, 67)">
            <AtomNode start="(468, 32)" end="(468, 33)" leading="" trailing=" " val=":"/>
            <OtherNode start="(468, 34)" end="(468, 67)" kind="«term_=_»">
              <OtherNode start="(468, 34)" end="(468, 60)" kind="Lean.Parser.Term.app">
                <OtherNode start="(468, 34)" end="(468, 58)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(468, 34)" end="(468, 49)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(468, 34)" end="(468, 35)" leading="" trailing="" val="("/>
                    <OtherNode start="(468, 35)" end="(468, 38)" kind="«term#[_,]»">
                      <AtomNode start="(468, 35)" end="(468, 37)" leading="" trailing="" val="#["/>
                      <NullNode/>
                      <AtomNode start="(468, 37)" end="(468, 38)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(468, 39)" end="(468, 40)" leading="" trailing=" " val=":"/>
                    <NullNode start="(468, 41)" end="(468, 48)">
                      <OtherNode start="(468, 41)" end="(468, 48)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(468, 41)" end="(468, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(468, 47)" end="(468, 48)">
                          <IdentNode start="(468, 47)" end="(468, 48)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(468, 48)" end="(468, 49)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(468, 49)" end="(468, 50)" leading="" trailing="" val="."/>
                  <IdentNode start="(468, 50)" end="(468, 58)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="Array.findIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(468, 59)" end="(468, 60)">
                  <IdentNode start="(468, 59)" end="(468, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(468, 61)" end="(468, 62)" leading="" trailing=" " val="="/>
              <IdentNode start="(468, 63)" end="(468, 67)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(468, 68)" end="(468, 78)">
          <AtomNode start="(468, 68)" end="(468, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(468, 71)" end="(468, 78)">
            <AtomNode start="(468, 71)" end="(468, 73)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(468, 74)" end="(468, 78)">
              <TacticTacticseq1IndentedNode start="(468, 74)" end="(468, 78)">
                <NullNode start="(468, 74)" end="(468, 78)">
                  <OtherNode start="(468, 74)" end="(468, 78)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;⊢ findIdx? p #[] = none" state_after="no goals" tactic="simp">
                    <AtomNode start="(468, 74)" end="(468, 78)" leading="" trailing="&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(469, 1)" end="(471, 7)" name="findIdx?_singleton" full_name="Array.findIdx?_singleton">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(469, 1)" end="(471, 7)" name="findIdx?_singleton" full_name="Array.findIdx?_singleton" _is_private_decl="False">
        <AtomNode start="(469, 1)" end="(469, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(469, 9)" end="(469, 27)">
          <IdentNode start="(469, 9)" end="(469, 27)" leading="" trailing=" " raw_val="findIdx?_singleton" val="findIdx?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(469, 28)" end="(470, 51)">
          <NullNode start="(469, 28)" end="(469, 50)">
            <OtherNode start="(469, 28)" end="(469, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(469, 28)" end="(469, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(469, 29)" end="(469, 30)">
                <IdentNode start="(469, 29)" end="(469, 30)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(469, 31)" end="(469, 34)">
                <AtomNode start="(469, 31)" end="(469, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(469, 33)" end="(469, 34)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(469, 34)" end="(469, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(469, 36)" end="(469, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(469, 36)" end="(469, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(469, 37)" end="(469, 38)">
                <IdentNode start="(469, 37)" end="(469, 38)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(469, 39)" end="(469, 49)">
                <AtomNode start="(469, 39)" end="(469, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(469, 41)" end="(469, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(469, 41)" end="(469, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(469, 43)" end="(469, 44)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(469, 45)" end="(469, 49)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(469, 49)" end="(469, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(469, 51)" end="(470, 51)">
            <AtomNode start="(469, 51)" end="(469, 52)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(470, 5)" end="(470, 51)" kind="«term_=_»">
              <OtherNode start="(470, 5)" end="(470, 20)" kind="Lean.Parser.Term.app">
                <OtherNode start="(470, 5)" end="(470, 18)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(470, 5)" end="(470, 9)" kind="«term#[_,]»">
                    <AtomNode start="(470, 5)" end="(470, 7)" leading="" trailing="" val="#["/>
                    <NullNode start="(470, 7)" end="(470, 8)">
                      <IdentNode start="(470, 7)" end="(470, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(470, 8)" end="(470, 9)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(470, 9)" end="(470, 10)" leading="" trailing="" val="."/>
                  <IdentNode start="(470, 10)" end="(470, 18)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="Array.findIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(470, 19)" end="(470, 20)">
                  <IdentNode start="(470, 19)" end="(470, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(470, 21)" end="(470, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(470, 23)" end="(470, 51)" kind="termIfThenElse">
                <AtomNode start="(470, 23)" end="(470, 25)" leading="" trailing=" " val="if"/>
                <OtherNode start="(470, 26)" end="(470, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(470, 26)" end="(470, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(470, 28)" end="(470, 29)">
                    <IdentNode start="(470, 28)" end="(470, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(470, 30)" end="(470, 34)" leading="" trailing=" " val="then"/>
                <OtherNode start="(470, 35)" end="(470, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(470, 35)" end="(470, 39)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(470, 40)" end="(470, 41)">
                    <OtherNode start="(470, 40)" end="(470, 41)" kind="num">
                      <AtomNode start="(470, 40)" end="(470, 41)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(470, 42)" end="(470, 46)" leading="" trailing=" " val="else"/>
                <IdentNode start="(470, 47)" end="(470, 51)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(470, 52)" end="(471, 7)">
          <AtomNode start="(470, 52)" end="(470, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(470, 55)" end="(471, 7)">
            <AtomNode start="(470, 55)" end="(470, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(471, 3)" end="(471, 7)">
              <TacticTacticseq1IndentedNode start="(471, 3)" end="(471, 7)">
                <NullNode start="(471, 3)" end="(471, 7)">
                  <OtherNode start="(471, 3)" end="(471, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ findIdx? p #[a] = if p a = true then some 0 else none" state_after="no goals" tactic="simp">
                    <AtomNode start="(471, 3)" end="(471, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(473, 1)" end="(477, 7)" name="findIdx?_eq_none_iff" full_name="Array.findIdx?_eq_none_iff">
      <CommandDeclmodifiersNode start="(473, 1)" end="(473, 8)">
        <NullNode/>
        <NullNode start="(473, 1)" end="(473, 8)">
          <OtherNode start="(473, 1)" end="(473, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(473, 1)" end="(473, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(473, 3)" end="(473, 7)">
              <OtherNode start="(473, 3)" end="(473, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(473, 3)" end="(473, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(473, 3)" end="(473, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(473, 7)" end="(473, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(474, 1)" end="(477, 7)" name="findIdx?_eq_none_iff" full_name="Array.findIdx?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(474, 1)" end="(474, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(474, 9)" end="(474, 29)">
          <IdentNode start="(474, 9)" end="(474, 29)" leading="" trailing=" " raw_val="findIdx?_eq_none_iff" val="findIdx?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(474, 30)" end="(475, 53)">
          <NullNode start="(474, 30)" end="(474, 59)">
            <OtherNode start="(474, 30)" end="(474, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(474, 30)" end="(474, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(474, 31)" end="(474, 33)">
                <IdentNode start="(474, 31)" end="(474, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(474, 34)" end="(474, 43)">
                <AtomNode start="(474, 34)" end="(474, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(474, 36)" end="(474, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(474, 36)" end="(474, 41)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(474, 42)" end="(474, 43)">
                    <IdentNode start="(474, 42)" end="(474, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(474, 43)" end="(474, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(474, 45)" end="(474, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(474, 45)" end="(474, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(474, 46)" end="(474, 47)">
                <IdentNode start="(474, 46)" end="(474, 47)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(474, 48)" end="(474, 58)">
                <AtomNode start="(474, 48)" end="(474, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(474, 50)" end="(474, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(474, 50)" end="(474, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(474, 52)" end="(474, 53)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(474, 54)" end="(474, 58)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(474, 58)" end="(474, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(474, 60)" end="(475, 53)">
            <AtomNode start="(474, 60)" end="(474, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(475, 5)" end="(475, 53)" kind="«term_↔_»">
              <OtherNode start="(475, 5)" end="(475, 25)" kind="«term_=_»">
                <OtherNode start="(475, 5)" end="(475, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(475, 5)" end="(475, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(475, 17)" end="(475, 18)">
                    <IdentNode start="(475, 17)" end="(475, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(475, 19)" end="(475, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(475, 21)" end="(475, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(475, 26)" end="(475, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(475, 28)" end="(475, 53)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(475, 28)" end="(475, 29)" leading="" trailing=" " val="∀"/>
                <NullNode start="(475, 30)" end="(475, 31)">
                  <IdentNode start="(475, 30)" end="(475, 31)" leading="" trailing="" raw_val="x" val="x"/>
                </NullNode>
                <NullNode/>
                <AtomNode start="(475, 31)" end="(475, 32)" leading="" trailing=" " val=","/>
                <OtherNode start="(475, 33)" end="(475, 53)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(475, 33)" end="(475, 39)" kind="«term_∈_»">
                    <IdentNode start="(475, 33)" end="(475, 34)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(475, 35)" end="(475, 36)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(475, 37)" end="(475, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(475, 40)" end="(475, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(475, 42)" end="(475, 53)" kind="«term_=_»">
                    <OtherNode start="(475, 42)" end="(475, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(475, 42)" end="(475, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(475, 44)" end="(475, 45)">
                        <IdentNode start="(475, 44)" end="(475, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(475, 46)" end="(475, 47)" leading="" trailing=" " val="="/>
                    <IdentNode start="(475, 48)" end="(475, 53)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(475, 54)" end="(477, 7)">
          <AtomNode start="(475, 54)" end="(475, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(475, 57)" end="(477, 7)">
            <AtomNode start="(475, 57)" end="(475, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(476, 3)" end="(477, 7)">
              <TacticTacticseq1IndentedNode start="(476, 3)" end="(477, 7)">
                <NullNode start="(476, 3)" end="(477, 7)">
                  <OtherNode start="(476, 3)" end="(476, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findIdx? p xs = none ↔ ∀ (x : α), x ∈ xs → p x = false" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = none ↔ ∀ (x : α), x ∈ { toList := xs } → p x = false" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(476, 3)" end="(476, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(476, 10)" end="(476, 12)">
                      <OtherNode start="(476, 10)" end="(476, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(476, 10)" end="(476, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(476, 13)" end="(476, 22)">
                      <AtomNode start="(476, 13)" end="(476, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(476, 18)" end="(476, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(476, 18)" end="(476, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(476, 18)" end="(476, 22)">
                            <OtherNode start="(476, 18)" end="(476, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(476, 18)" end="(476, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(476, 19)" end="(476, 21)">
                                <OtherNode start="(476, 19)" end="(476, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(476, 19)" end="(476, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(476, 19)" end="(476, 21)">
                                      <OtherNode start="(476, 19)" end="(476, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(476, 19)" end="(476, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(476, 21)" end="(476, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(477, 3)" end="(477, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = none ↔ ∀ (x : α), x ∈ { toList := xs } → p x = false" state_after="no goals" tactic="simp">
                    <AtomNode start="(477, 3)" end="(477, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(479, 1)" end="(483, 30)" name="findIdx?_isSome" full_name="Array.findIdx?_isSome">
      <CommandDeclmodifiersNode start="(479, 1)" end="(479, 8)">
        <NullNode/>
        <NullNode start="(479, 1)" end="(479, 8)">
          <OtherNode start="(479, 1)" end="(479, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(479, 1)" end="(479, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(479, 3)" end="(479, 7)">
              <OtherNode start="(479, 3)" end="(479, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(479, 3)" end="(479, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(479, 3)" end="(479, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(479, 7)" end="(479, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(480, 1)" end="(483, 30)" name="findIdx?_isSome" full_name="Array.findIdx?_isSome" _is_private_decl="False">
        <AtomNode start="(480, 1)" end="(480, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(480, 9)" end="(480, 24)">
          <IdentNode start="(480, 9)" end="(480, 24)" leading="" trailing=" " raw_val="findIdx?_isSome" val="findIdx?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(480, 25)" end="(481, 38)">
          <NullNode start="(480, 25)" end="(480, 54)">
            <OtherNode start="(480, 25)" end="(480, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(480, 25)" end="(480, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(480, 26)" end="(480, 28)">
                <IdentNode start="(480, 26)" end="(480, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(480, 29)" end="(480, 38)">
                <AtomNode start="(480, 29)" end="(480, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(480, 31)" end="(480, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(480, 31)" end="(480, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(480, 37)" end="(480, 38)">
                    <IdentNode start="(480, 37)" end="(480, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(480, 38)" end="(480, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(480, 40)" end="(480, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(480, 40)" end="(480, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(480, 41)" end="(480, 42)">
                <IdentNode start="(480, 41)" end="(480, 42)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(480, 43)" end="(480, 53)">
                <AtomNode start="(480, 43)" end="(480, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(480, 45)" end="(480, 53)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(480, 45)" end="(480, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(480, 47)" end="(480, 48)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(480, 49)" end="(480, 53)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(480, 53)" end="(480, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(480, 55)" end="(481, 38)">
            <AtomNode start="(480, 55)" end="(480, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(481, 5)" end="(481, 38)" kind="«term_=_»">
              <OtherNode start="(481, 5)" end="(481, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(481, 5)" end="(481, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(481, 5)" end="(481, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(481, 6)" end="(481, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(481, 6)" end="(481, 17)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(481, 18)" end="(481, 19)">
                      <IdentNode start="(481, 18)" end="(481, 19)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(481, 19)" end="(481, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(481, 20)" end="(481, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(481, 21)" end="(481, 27)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(481, 28)" end="(481, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(481, 30)" end="(481, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(481, 30)" end="(481, 36)" leading="" trailing=" " raw_val="xs.any" val="xs.any"/>
                <NullNode start="(481, 37)" end="(481, 38)">
                  <IdentNode start="(481, 37)" end="(481, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(481, 39)" end="(483, 30)">
          <AtomNode start="(481, 39)" end="(481, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(481, 42)" end="(483, 30)">
            <AtomNode start="(481, 42)" end="(481, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(482, 3)" end="(483, 30)">
              <TacticTacticseq1IndentedNode start="(482, 3)" end="(483, 30)">
                <NullNode start="(482, 3)" end="(483, 30)">
                  <OtherNode start="(482, 3)" end="(482, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ (findIdx? p xs).isSome = xs.any p" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findIdx? p { toList := xs }).isSome = { toList := xs }.any p" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(482, 3)" end="(482, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(482, 10)" end="(482, 12)">
                      <OtherNode start="(482, 10)" end="(482, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(482, 10)" end="(482, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(482, 13)" end="(482, 22)">
                      <AtomNode start="(482, 13)" end="(482, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(482, 18)" end="(482, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(482, 18)" end="(482, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(482, 18)" end="(482, 22)">
                            <OtherNode start="(482, 18)" end="(482, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(482, 18)" end="(482, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(482, 19)" end="(482, 21)">
                                <OtherNode start="(482, 19)" end="(482, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(482, 19)" end="(482, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(482, 19)" end="(482, 21)">
                                      <OtherNode start="(482, 19)" end="(482, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(482, 19)" end="(482, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(482, 21)" end="(482, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(483, 3)" end="(483, 30)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findIdx? p { toList := xs }).isSome = { toList := xs }.any p" state_after="no goals" tactic="simp [List.findIdx?_isSome]">
                    <AtomNode start="(483, 3)" end="(483, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(483, 8)" end="(483, 30)">
                      <AtomNode start="(483, 8)" end="(483, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(483, 9)" end="(483, 29)">
                        <OtherNode start="(483, 9)" end="(483, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(483, 9)" end="(483, 29)" leading="" trailing="" raw_val="List.findIdx?_isSome" val="List.findIdx?_isSome" full_name="List.findIdx?_isSome" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(483, 29)" end="(483, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(485, 1)" end="(489, 30)" name="findIdx?_isNone" full_name="Array.findIdx?_isNone">
      <CommandDeclmodifiersNode start="(485, 1)" end="(485, 8)">
        <NullNode/>
        <NullNode start="(485, 1)" end="(485, 8)">
          <OtherNode start="(485, 1)" end="(485, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(485, 1)" end="(485, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(485, 3)" end="(485, 7)">
              <OtherNode start="(485, 3)" end="(485, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(485, 3)" end="(485, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(485, 3)" end="(485, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(485, 7)" end="(485, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(486, 1)" end="(489, 30)" name="findIdx?_isNone" full_name="Array.findIdx?_isNone" _is_private_decl="False">
        <AtomNode start="(486, 1)" end="(486, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(486, 9)" end="(486, 24)">
          <IdentNode start="(486, 9)" end="(486, 24)" leading="" trailing=" " raw_val="findIdx?_isNone" val="findIdx?_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(486, 25)" end="(487, 43)">
          <NullNode start="(486, 25)" end="(486, 54)">
            <OtherNode start="(486, 25)" end="(486, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(486, 25)" end="(486, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(486, 26)" end="(486, 28)">
                <IdentNode start="(486, 26)" end="(486, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(486, 29)" end="(486, 38)">
                <AtomNode start="(486, 29)" end="(486, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(486, 31)" end="(486, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(486, 31)" end="(486, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(486, 37)" end="(486, 38)">
                    <IdentNode start="(486, 37)" end="(486, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(486, 38)" end="(486, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(486, 40)" end="(486, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(486, 40)" end="(486, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(486, 41)" end="(486, 42)">
                <IdentNode start="(486, 41)" end="(486, 42)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(486, 43)" end="(486, 53)">
                <AtomNode start="(486, 43)" end="(486, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(486, 45)" end="(486, 53)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(486, 45)" end="(486, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(486, 47)" end="(486, 48)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(486, 49)" end="(486, 53)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(486, 53)" end="(486, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(486, 55)" end="(487, 43)">
            <AtomNode start="(486, 55)" end="(486, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(487, 5)" end="(487, 43)" kind="«term_=_»">
              <OtherNode start="(487, 5)" end="(487, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(487, 5)" end="(487, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(487, 5)" end="(487, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(487, 6)" end="(487, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(487, 6)" end="(487, 17)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(487, 18)" end="(487, 19)">
                      <IdentNode start="(487, 18)" end="(487, 19)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(487, 19)" end="(487, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(487, 20)" end="(487, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(487, 21)" end="(487, 27)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(487, 28)" end="(487, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(487, 30)" end="(487, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(487, 30)" end="(487, 36)" leading="" trailing=" " raw_val="xs.all" val="xs.all"/>
                <NullNode start="(487, 37)" end="(487, 43)">
                  <OtherNode start="(487, 37)" end="(487, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(487, 37)" end="(487, 38)" leading="" trailing="" val="("/>
                    <OtherNode start="(487, 38)" end="(487, 42)" kind="«term¬_»">
                      <AtomNode start="(487, 38)" end="(487, 39)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(487, 39)" end="(487, 42)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(487, 39)" end="(487, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(487, 41)" end="(487, 42)">
                          <OtherNode start="(487, 41)" end="(487, 42)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(487, 41)" end="(487, 42)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(487, 42)" end="(487, 43)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(487, 44)" end="(489, 30)">
          <AtomNode start="(487, 44)" end="(487, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(487, 47)" end="(489, 30)">
            <AtomNode start="(487, 47)" end="(487, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(488, 3)" end="(489, 30)">
              <TacticTacticseq1IndentedNode start="(488, 3)" end="(489, 30)">
                <NullNode start="(488, 3)" end="(489, 30)">
                  <OtherNode start="(488, 3)" end="(488, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ (findIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findIdx? p { toList := xs }).isNone = { toList := xs }.all fun x =&amp;gt; decide ¬p x = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(488, 3)" end="(488, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(488, 10)" end="(488, 12)">
                      <OtherNode start="(488, 10)" end="(488, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(488, 10)" end="(488, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(488, 13)" end="(488, 22)">
                      <AtomNode start="(488, 13)" end="(488, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(488, 18)" end="(488, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(488, 18)" end="(488, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(488, 18)" end="(488, 22)">
                            <OtherNode start="(488, 18)" end="(488, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(488, 18)" end="(488, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(488, 19)" end="(488, 21)">
                                <OtherNode start="(488, 19)" end="(488, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(488, 19)" end="(488, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(488, 19)" end="(488, 21)">
                                      <OtherNode start="(488, 19)" end="(488, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(488, 19)" end="(488, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(488, 21)" end="(488, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(489, 3)" end="(489, 30)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findIdx? p { toList := xs }).isNone = { toList := xs }.all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="simp [List.findIdx?_isNone]">
                    <AtomNode start="(489, 3)" end="(489, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(489, 8)" end="(489, 30)">
                      <AtomNode start="(489, 8)" end="(489, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(489, 9)" end="(489, 29)">
                        <OtherNode start="(489, 9)" end="(489, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(489, 9)" end="(489, 29)" leading="" trailing="" raw_val="List.findIdx?_isNone" val="List.findIdx?_isNone" full_name="List.findIdx?_isNone" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(489, 29)" end="(489, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(491, 1)" end="(494, 46)" name="findIdx?_eq_some_iff_findIdx_eq" full_name="Array.findIdx?_eq_some_iff_findIdx_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(491, 1)" end="(494, 46)" name="findIdx?_eq_some_iff_findIdx_eq" full_name="Array.findIdx?_eq_some_iff_findIdx_eq" _is_private_decl="False">
        <AtomNode start="(491, 1)" end="(491, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(491, 9)" end="(491, 40)">
          <IdentNode start="(491, 9)" end="(491, 40)" leading="" trailing=" " raw_val="findIdx?_eq_some_iff_findIdx_eq" val="findIdx?_eq_some_iff_findIdx_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(491, 41)" end="(492, 60)">
          <NullNode start="(491, 41)" end="(491, 80)">
            <OtherNode start="(491, 41)" end="(491, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(491, 41)" end="(491, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(491, 42)" end="(491, 44)">
                <IdentNode start="(491, 42)" end="(491, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(491, 45)" end="(491, 54)">
                <AtomNode start="(491, 45)" end="(491, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(491, 47)" end="(491, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(491, 47)" end="(491, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(491, 53)" end="(491, 54)">
                    <IdentNode start="(491, 53)" end="(491, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(491, 54)" end="(491, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(491, 56)" end="(491, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(491, 56)" end="(491, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(491, 57)" end="(491, 58)">
                <IdentNode start="(491, 57)" end="(491, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(491, 59)" end="(491, 69)">
                <AtomNode start="(491, 59)" end="(491, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(491, 61)" end="(491, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(491, 61)" end="(491, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(491, 63)" end="(491, 64)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(491, 65)" end="(491, 69)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(491, 69)" end="(491, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(491, 71)" end="(491, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(491, 71)" end="(491, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(491, 72)" end="(491, 73)">
                <IdentNode start="(491, 72)" end="(491, 73)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(491, 74)" end="(491, 79)">
                <AtomNode start="(491, 74)" end="(491, 75)" leading="" trailing=" " val=":"/>
                <IdentNode start="(491, 76)" end="(491, 79)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(491, 79)" end="(491, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(491, 81)" end="(492, 60)">
            <AtomNode start="(491, 81)" end="(491, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(492, 5)" end="(492, 60)" kind="«term_↔_»">
              <OtherNode start="(492, 5)" end="(492, 27)" kind="«term_=_»">
                <OtherNode start="(492, 5)" end="(492, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(492, 5)" end="(492, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(492, 17)" end="(492, 18)">
                    <IdentNode start="(492, 17)" end="(492, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(492, 19)" end="(492, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(492, 21)" end="(492, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(492, 21)" end="(492, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(492, 26)" end="(492, 27)">
                    <IdentNode start="(492, 26)" end="(492, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(492, 28)" end="(492, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(492, 30)" end="(492, 60)" kind="«term_∧_»">
                <OtherNode start="(492, 30)" end="(492, 41)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(492, 30)" end="(492, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(492, 32)" end="(492, 33)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(492, 34)" end="(492, 41)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                </OtherNode>
                <AtomNode start="(492, 42)" end="(492, 43)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(492, 44)" end="(492, 60)" kind="«term_=_»">
                  <OtherNode start="(492, 44)" end="(492, 56)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(492, 44)" end="(492, 54)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(492, 55)" end="(492, 56)">
                      <IdentNode start="(492, 55)" end="(492, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(492, 57)" end="(492, 58)" leading="" trailing=" " val="="/>
                  <IdentNode start="(492, 59)" end="(492, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(492, 61)" end="(494, 46)">
          <AtomNode start="(492, 61)" end="(492, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(492, 64)" end="(494, 46)">
            <AtomNode start="(492, 64)" end="(492, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(493, 3)" end="(494, 46)">
              <TacticTacticseq1IndentedNode start="(493, 3)" end="(494, 46)">
                <NullNode start="(493, 3)" end="(494, 46)">
                  <OtherNode start="(493, 3)" end="(493, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Nat&#10;⊢ findIdx? p xs = some i ↔ i &amp;lt; xs.size ∧ findIdx p xs = i" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = some i ↔ i &amp;lt; { toList := xs }.size ∧ findIdx p { toList := xs } = i" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(493, 3)" end="(493, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(493, 10)" end="(493, 12)">
                      <OtherNode start="(493, 10)" end="(493, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(493, 10)" end="(493, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(493, 13)" end="(493, 22)">
                      <AtomNode start="(493, 13)" end="(493, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(493, 18)" end="(493, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(493, 18)" end="(493, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(493, 18)" end="(493, 22)">
                            <OtherNode start="(493, 18)" end="(493, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(493, 18)" end="(493, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(493, 19)" end="(493, 21)">
                                <OtherNode start="(493, 19)" end="(493, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(493, 19)" end="(493, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(493, 19)" end="(493, 21)">
                                      <OtherNode start="(493, 19)" end="(493, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(493, 19)" end="(493, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(493, 21)" end="(493, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(494, 3)" end="(494, 46)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = some i ↔ i &amp;lt; { toList := xs }.size ∧ findIdx p { toList := xs } = i" state_after="no goals" tactic="simp [List.findIdx?_eq_some_iff_findIdx_eq]">
                    <AtomNode start="(494, 3)" end="(494, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(494, 8)" end="(494, 46)">
                      <AtomNode start="(494, 8)" end="(494, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(494, 9)" end="(494, 45)">
                        <OtherNode start="(494, 9)" end="(494, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(494, 9)" end="(494, 45)" leading="" trailing="" raw_val="List.findIdx?_eq_some_iff_findIdx_eq" val="List.findIdx?_eq_some_iff_findIdx_eq" full_name="List.findIdx?_eq_some_iff_findIdx_eq" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(494, 45)" end="(494, 46)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(496, 1)" end="(499, 43)" name="findIdx?_eq_some_of_exists" full_name="Array.findIdx?_eq_some_of_exists">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(496, 1)" end="(499, 43)" name="findIdx?_eq_some_of_exists" full_name="Array.findIdx?_eq_some_of_exists" _is_private_decl="False">
        <AtomNode start="(496, 1)" end="(496, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(496, 9)" end="(496, 35)">
          <IdentNode start="(496, 9)" end="(496, 35)" leading="" trailing=" " raw_val="findIdx?_eq_some_of_exists" val="findIdx?_eq_some_of_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(496, 36)" end="(497, 40)">
          <NullNode start="(496, 36)" end="(496, 89)">
            <OtherNode start="(496, 36)" end="(496, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(496, 36)" end="(496, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(496, 37)" end="(496, 39)">
                <IdentNode start="(496, 37)" end="(496, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(496, 40)" end="(496, 49)">
                <AtomNode start="(496, 40)" end="(496, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(496, 42)" end="(496, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(496, 42)" end="(496, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(496, 48)" end="(496, 49)">
                    <IdentNode start="(496, 48)" end="(496, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(496, 49)" end="(496, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(496, 51)" end="(496, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(496, 51)" end="(496, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(496, 52)" end="(496, 53)">
                <IdentNode start="(496, 52)" end="(496, 53)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(496, 54)" end="(496, 64)">
                <AtomNode start="(496, 54)" end="(496, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(496, 56)" end="(496, 64)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(496, 56)" end="(496, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(496, 58)" end="(496, 59)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(496, 60)" end="(496, 64)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(496, 64)" end="(496, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(496, 66)" end="(496, 89)">
              <AtomNode start="(496, 66)" end="(496, 67)" leading="" trailing="" val="("/>
              <NullNode start="(496, 67)" end="(496, 68)">
                <IdentNode start="(496, 67)" end="(496, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(496, 69)" end="(496, 88)">
                <AtomNode start="(496, 69)" end="(496, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(496, 71)" end="(496, 88)" kind="«term∃_,_»">
                  <AtomNode start="(496, 71)" end="(496, 72)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(496, 73)" end="(496, 74)" kind="Lean.explicitBinders">
                    <OtherNode start="(496, 73)" end="(496, 74)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(496, 73)" end="(496, 74)">
                        <LeanBinderidentNode start="(496, 73)" end="(496, 74)">
                          <IdentNode start="(496, 73)" end="(496, 74)" leading="" trailing="" raw_val="x" val="x"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(496, 74)" end="(496, 75)" leading="" trailing=" " val=","/>
                  <OtherNode start="(496, 76)" end="(496, 88)" kind="«term_∧_»">
                    <OtherNode start="(496, 76)" end="(496, 82)" kind="«term_∈_»">
                      <IdentNode start="(496, 76)" end="(496, 77)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(496, 78)" end="(496, 79)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(496, 80)" end="(496, 82)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(496, 83)" end="(496, 84)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(496, 85)" end="(496, 88)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(496, 85)" end="(496, 86)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(496, 87)" end="(496, 88)">
                        <IdentNode start="(496, 87)" end="(496, 88)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(496, 88)" end="(496, 89)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(496, 90)" end="(497, 40)">
            <AtomNode start="(496, 90)" end="(496, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(497, 5)" end="(497, 40)" kind="«term_=_»">
              <OtherNode start="(497, 5)" end="(497, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(497, 5)" end="(497, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(497, 17)" end="(497, 18)">
                  <IdentNode start="(497, 17)" end="(497, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(497, 19)" end="(497, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(497, 21)" end="(497, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(497, 21)" end="(497, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(497, 26)" end="(497, 40)">
                  <OtherNode start="(497, 26)" end="(497, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(497, 26)" end="(497, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(497, 27)" end="(497, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(497, 27)" end="(497, 37)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(497, 38)" end="(497, 39)">
                        <IdentNode start="(497, 38)" end="(497, 39)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(497, 39)" end="(497, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(497, 41)" end="(499, 43)">
          <AtomNode start="(497, 41)" end="(497, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(497, 44)" end="(499, 43)">
            <AtomNode start="(497, 44)" end="(497, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(498, 3)" end="(499, 43)">
              <TacticTacticseq1IndentedNode start="(498, 3)" end="(499, 43)">
                <NullNode start="(498, 3)" end="(499, 43)">
                  <OtherNode start="(498, 3)" end="(498, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx? p xs = some (findIdx p xs)" state_after="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs &amp;lt; xs.size ∧ findIdx p xs = findIdx p xs" tactic="rw [findIdx?_eq_some_iff_findIdx_eq]">
                    <AtomNode start="(498, 3)" end="(498, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(498, 6)" end="(498, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(498, 6)" end="(498, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(498, 7)" end="(498, 38)">
                        <OtherNode start="(498, 7)" end="(498, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(498, 7)" end="(498, 38)" leading="" trailing="" raw_val="findIdx?_eq_some_iff_findIdx_eq" val="findIdx?_eq_some_iff_findIdx_eq" full_name="Array.findIdx?_eq_some_iff_findIdx_eq" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(491, 9)" def_end="(491, 40)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(498, 38)" end="(498, 39)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(499, 3)" end="(499, 43)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs &amp;lt; xs.size ∧ findIdx p xs = findIdx p xs" state_after="no goals" tactic="exact ⟨findIdx_lt_size_of_exists h, rfl⟩">
                    <AtomNode start="(499, 3)" end="(499, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(499, 9)" end="(499, 43)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(499, 9)" end="(499, 10)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(499, 10)" end="(499, 42)">
                        <OtherNode start="(499, 10)" end="(499, 37)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(499, 10)" end="(499, 35)" leading="" trailing=" " raw_val="findIdx_lt_size_of_exists" val="findIdx_lt_size_of_exists" full_name="Array.findIdx_lt_size_of_exists" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(362, 9)" def_end="(362, 34)"/>
                          <NullNode start="(499, 36)" end="(499, 37)">
                            <IdentNode start="(499, 36)" end="(499, 37)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(499, 37)" end="(499, 38)" leading="" trailing=" " val=","/>
                        <IdentNode start="(499, 39)" end="(499, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <AtomNode start="(499, 42)" end="(499, 43)" leading="" trailing="&#10;&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(501, 1)" end="(504, 46)" name="findIdx?_eq_none_iff_findIdx_eq" full_name="Array.findIdx?_eq_none_iff_findIdx_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(501, 1)" end="(504, 46)" name="findIdx?_eq_none_iff_findIdx_eq" full_name="Array.findIdx?_eq_none_iff_findIdx_eq" _is_private_decl="False">
        <AtomNode start="(501, 1)" end="(501, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(501, 9)" end="(501, 40)">
          <IdentNode start="(501, 9)" end="(501, 40)" leading="" trailing=" " raw_val="findIdx?_eq_none_iff_findIdx_eq" val="findIdx?_eq_none_iff_findIdx_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(501, 41)" end="(502, 50)">
          <NullNode start="(501, 41)" end="(501, 70)">
            <OtherNode start="(501, 41)" end="(501, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(501, 41)" end="(501, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(501, 42)" end="(501, 44)">
                <IdentNode start="(501, 42)" end="(501, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(501, 45)" end="(501, 54)">
                <AtomNode start="(501, 45)" end="(501, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 47)" end="(501, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(501, 47)" end="(501, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(501, 53)" end="(501, 54)">
                    <IdentNode start="(501, 53)" end="(501, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(501, 54)" end="(501, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(501, 56)" end="(501, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(501, 56)" end="(501, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(501, 57)" end="(501, 58)">
                <IdentNode start="(501, 57)" end="(501, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(501, 59)" end="(501, 69)">
                <AtomNode start="(501, 59)" end="(501, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 61)" end="(501, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(501, 61)" end="(501, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(501, 63)" end="(501, 64)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(501, 65)" end="(501, 69)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(501, 69)" end="(501, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(501, 71)" end="(502, 50)">
            <AtomNode start="(501, 71)" end="(501, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(502, 5)" end="(502, 50)" kind="«term_↔_»">
              <OtherNode start="(502, 5)" end="(502, 25)" kind="«term_=_»">
                <OtherNode start="(502, 5)" end="(502, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(502, 5)" end="(502, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(502, 17)" end="(502, 18)">
                    <IdentNode start="(502, 17)" end="(502, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(502, 19)" end="(502, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(502, 21)" end="(502, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(502, 26)" end="(502, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(502, 28)" end="(502, 50)" kind="«term_=_»">
                <OtherNode start="(502, 28)" end="(502, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(502, 28)" end="(502, 38)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(502, 39)" end="(502, 40)">
                    <IdentNode start="(502, 39)" end="(502, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(502, 41)" end="(502, 42)" leading="" trailing=" " val="="/>
                <IdentNode start="(502, 43)" end="(502, 50)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(502, 51)" end="(504, 46)">
          <AtomNode start="(502, 51)" end="(502, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(502, 54)" end="(504, 46)">
            <AtomNode start="(502, 54)" end="(502, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(503, 3)" end="(504, 46)">
              <TacticTacticseq1IndentedNode start="(503, 3)" end="(504, 46)">
                <NullNode start="(503, 3)" end="(504, 46)">
                  <OtherNode start="(503, 3)" end="(503, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findIdx? p xs = none ↔ findIdx p xs = xs.size" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = none ↔ findIdx p { toList := xs } = { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(503, 3)" end="(503, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(503, 10)" end="(503, 12)">
                      <OtherNode start="(503, 10)" end="(503, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(503, 10)" end="(503, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(503, 13)" end="(503, 22)">
                      <AtomNode start="(503, 13)" end="(503, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(503, 18)" end="(503, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(503, 18)" end="(503, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(503, 18)" end="(503, 22)">
                            <OtherNode start="(503, 18)" end="(503, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(503, 18)" end="(503, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(503, 19)" end="(503, 21)">
                                <OtherNode start="(503, 19)" end="(503, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(503, 19)" end="(503, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(503, 19)" end="(503, 21)">
                                      <OtherNode start="(503, 19)" end="(503, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(503, 19)" end="(503, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(503, 21)" end="(503, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(504, 3)" end="(504, 46)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = none ↔ findIdx p { toList := xs } = { toList := xs }.size" state_after="no goals" tactic="simp [List.findIdx?_eq_none_iff_findIdx_eq]">
                    <AtomNode start="(504, 3)" end="(504, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(504, 8)" end="(504, 46)">
                      <AtomNode start="(504, 8)" end="(504, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(504, 9)" end="(504, 45)">
                        <OtherNode start="(504, 9)" end="(504, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(504, 9)" end="(504, 45)" leading="" trailing="" raw_val="List.findIdx?_eq_none_iff_findIdx_eq" val="List.findIdx?_eq_none_iff_findIdx_eq" full_name="List.findIdx?_eq_none_iff_findIdx_eq" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(504, 45)" end="(504, 46)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(506, 1)" end="(509, 43)" name="findIdx?_eq_guard_findIdx_lt" full_name="Array.findIdx?_eq_guard_findIdx_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(506, 1)" end="(509, 43)" name="findIdx?_eq_guard_findIdx_lt" full_name="Array.findIdx?_eq_guard_findIdx_lt" _is_private_decl="False">
        <AtomNode start="(506, 1)" end="(506, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(506, 9)" end="(506, 37)">
          <IdentNode start="(506, 9)" end="(506, 37)" leading="" trailing=" " raw_val="findIdx?_eq_guard_findIdx_lt" val="findIdx?_eq_guard_findIdx_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(506, 38)" end="(507, 71)">
          <NullNode start="(506, 38)" end="(506, 67)">
            <OtherNode start="(506, 38)" end="(506, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(506, 38)" end="(506, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(506, 39)" end="(506, 41)">
                <IdentNode start="(506, 39)" end="(506, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(506, 42)" end="(506, 51)">
                <AtomNode start="(506, 42)" end="(506, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(506, 44)" end="(506, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(506, 44)" end="(506, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(506, 50)" end="(506, 51)">
                    <IdentNode start="(506, 50)" end="(506, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(506, 51)" end="(506, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(506, 53)" end="(506, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(506, 53)" end="(506, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(506, 54)" end="(506, 55)">
                <IdentNode start="(506, 54)" end="(506, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(506, 56)" end="(506, 66)">
                <AtomNode start="(506, 56)" end="(506, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(506, 58)" end="(506, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(506, 58)" end="(506, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(506, 60)" end="(506, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(506, 62)" end="(506, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(506, 66)" end="(506, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(506, 68)" end="(507, 71)">
            <AtomNode start="(506, 68)" end="(506, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(507, 5)" end="(507, 71)" kind="«term_=_»">
              <OtherNode start="(507, 5)" end="(507, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(507, 5)" end="(507, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(507, 17)" end="(507, 18)">
                  <IdentNode start="(507, 17)" end="(507, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(507, 19)" end="(507, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(507, 21)" end="(507, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(507, 21)" end="(507, 33)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                <NullNode start="(507, 34)" end="(507, 71)">
                  <OtherNode start="(507, 34)" end="(507, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(507, 34)" end="(507, 35)" leading="" trailing="" val="("/>
                    <OtherNode start="(507, 35)" end="(507, 55)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(507, 35)" end="(507, 38)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(507, 39)" end="(507, 55)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(507, 39)" end="(507, 40)">
                          <IdentNode start="(507, 39)" end="(507, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(507, 41)" end="(507, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(507, 44)" end="(507, 55)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(507, 44)" end="(507, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(507, 46)" end="(507, 47)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(507, 48)" end="(507, 55)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(507, 55)" end="(507, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(507, 57)" end="(507, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(507, 57)" end="(507, 58)" leading="" trailing="" val="("/>
                    <OtherNode start="(507, 58)" end="(507, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(507, 58)" end="(507, 68)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(507, 69)" end="(507, 70)">
                        <IdentNode start="(507, 69)" end="(507, 70)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(507, 70)" end="(507, 71)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(507, 72)" end="(509, 43)">
          <AtomNode start="(507, 72)" end="(507, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(507, 75)" end="(509, 43)">
            <AtomNode start="(507, 75)" end="(507, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(508, 3)" end="(509, 43)">
              <TacticTacticseq1IndentedNode start="(508, 3)" end="(509, 43)">
                <NullNode start="(508, 3)" end="(509, 43)">
                  <OtherNode start="(508, 3)" end="(508, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findIdx? p xs = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.size)) (findIdx p xs)" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = Option.guard (fun i =&amp;gt; decide (i &amp;lt; { toList := xs }.size)) (findIdx p { toList := xs })" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(508, 3)" end="(508, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(508, 10)" end="(508, 12)">
                      <OtherNode start="(508, 10)" end="(508, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(508, 10)" end="(508, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(508, 13)" end="(508, 22)">
                      <AtomNode start="(508, 13)" end="(508, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(508, 18)" end="(508, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(508, 18)" end="(508, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(508, 18)" end="(508, 22)">
                            <OtherNode start="(508, 18)" end="(508, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(508, 18)" end="(508, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(508, 19)" end="(508, 21)">
                                <OtherNode start="(508, 19)" end="(508, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(508, 19)" end="(508, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(508, 19)" end="(508, 21)">
                                      <OtherNode start="(508, 19)" end="(508, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(508, 19)" end="(508, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(508, 21)" end="(508, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(509, 3)" end="(509, 43)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = Option.guard (fun i =&amp;gt; decide (i &amp;lt; { toList := xs }.size)) (findIdx p { toList := xs })" state_after="no goals" tactic="simp [List.findIdx?_eq_guard_findIdx_lt]">
                    <AtomNode start="(509, 3)" end="(509, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(509, 8)" end="(509, 43)">
                      <AtomNode start="(509, 8)" end="(509, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(509, 9)" end="(509, 42)">
                        <OtherNode start="(509, 9)" end="(509, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(509, 9)" end="(509, 42)" leading="" trailing="" raw_val="List.findIdx?_eq_guard_findIdx_lt" val="List.findIdx?_eq_guard_findIdx_lt" full_name="List.findIdx?_eq_guard_findIdx_lt" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(509, 42)" end="(509, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(511, 1)" end="(515, 43)" name="findIdx?_eq_some_iff_getElem" full_name="Array.findIdx?_eq_some_iff_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(511, 1)" end="(515, 43)" name="findIdx?_eq_some_iff_getElem" full_name="Array.findIdx?_eq_some_iff_getElem" _is_private_decl="False">
        <AtomNode start="(511, 1)" end="(511, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(511, 9)" end="(511, 37)">
          <IdentNode start="(511, 9)" end="(511, 37)" leading="" trailing=" " raw_val="findIdx?_eq_some_iff_getElem" val="findIdx?_eq_some_iff_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(511, 38)" end="(513, 86)">
          <NullNode start="(511, 38)" end="(511, 77)">
            <OtherNode start="(511, 38)" end="(511, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(511, 38)" end="(511, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(511, 39)" end="(511, 41)">
                <IdentNode start="(511, 39)" end="(511, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(511, 42)" end="(511, 51)">
                <AtomNode start="(511, 42)" end="(511, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(511, 44)" end="(511, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(511, 44)" end="(511, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(511, 50)" end="(511, 51)">
                    <IdentNode start="(511, 50)" end="(511, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(511, 51)" end="(511, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(511, 53)" end="(511, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(511, 53)" end="(511, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(511, 54)" end="(511, 55)">
                <IdentNode start="(511, 54)" end="(511, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(511, 56)" end="(511, 66)">
                <AtomNode start="(511, 56)" end="(511, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(511, 58)" end="(511, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(511, 58)" end="(511, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(511, 60)" end="(511, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(511, 62)" end="(511, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(511, 66)" end="(511, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(511, 68)" end="(511, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(511, 68)" end="(511, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(511, 69)" end="(511, 70)">
                <IdentNode start="(511, 69)" end="(511, 70)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(511, 71)" end="(511, 76)">
                <AtomNode start="(511, 71)" end="(511, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(511, 73)" end="(511, 76)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(511, 76)" end="(511, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(511, 78)" end="(513, 86)">
            <AtomNode start="(511, 78)" end="(511, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(512, 5)" end="(513, 86)" kind="«term_↔_»">
              <OtherNode start="(512, 5)" end="(512, 27)" kind="«term_=_»">
                <OtherNode start="(512, 5)" end="(512, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(512, 5)" end="(512, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(512, 17)" end="(512, 18)">
                    <IdentNode start="(512, 17)" end="(512, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(512, 19)" end="(512, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(512, 21)" end="(512, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(512, 21)" end="(512, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(512, 26)" end="(512, 27)">
                    <IdentNode start="(512, 26)" end="(512, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(512, 28)" end="(512, 29)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(513, 7)" end="(513, 86)" kind="«term∃_,_»">
                <AtomNode start="(513, 7)" end="(513, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(513, 9)" end="(513, 24)" kind="Lean.explicitBinders">
                  <OtherNode start="(513, 9)" end="(513, 24)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(513, 9)" end="(513, 10)">
                      <LeanBinderidentNode start="(513, 9)" end="(513, 10)">
                        <IdentNode start="(513, 9)" end="(513, 10)" leading="" trailing=" " raw_val="h" val="h"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode start="(513, 11)" end="(513, 24)">
                      <AtomNode start="(513, 11)" end="(513, 12)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(513, 13)" end="(513, 24)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(513, 13)" end="(513, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(513, 15)" end="(513, 16)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(513, 17)" end="(513, 24)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(513, 24)" end="(513, 25)" leading="" trailing=" " val=","/>
                <OtherNode start="(513, 26)" end="(513, 86)" kind="«term_∧_»">
                  <OtherNode start="(513, 26)" end="(513, 33)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(513, 26)" end="(513, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(513, 28)" end="(513, 33)">
                      <OtherNode start="(513, 28)" end="(513, 33)" kind="«term__[_]»">
                        <IdentNode start="(513, 28)" end="(513, 30)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <AtomNode start="(513, 30)" end="(513, 31)" leading="" trailing="" val="["/>
                        <IdentNode start="(513, 31)" end="(513, 32)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(513, 32)" end="(513, 33)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(513, 34)" end="(513, 35)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(513, 36)" end="(513, 86)" kind="Lean.Parser.Term.forall">
                    <AtomNode start="(513, 36)" end="(513, 37)" leading="" trailing=" " val="∀"/>
                    <NullNode start="(513, 38)" end="(513, 53)">
                      <IdentNode start="(513, 38)" end="(513, 39)" leading="" trailing=" " raw_val="j" val="j"/>
                      <TermExplicitbinderNode start="(513, 40)" end="(513, 53)">
                        <AtomNode start="(513, 40)" end="(513, 41)" leading="" trailing="" val="("/>
                        <NullNode start="(513, 41)" end="(513, 44)">
                          <IdentNode start="(513, 41)" end="(513, 44)" leading="" trailing=" " raw_val="hji" val="hji"/>
                        </NullNode>
                        <NullNode start="(513, 45)" end="(513, 52)">
                          <AtomNode start="(513, 45)" end="(513, 46)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(513, 47)" end="(513, 52)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(513, 47)" end="(513, 48)" leading="" trailing=" " raw_val="j" val="j"/>
                            <AtomNode start="(513, 49)" end="(513, 50)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(513, 51)" end="(513, 52)" leading="" trailing="" raw_val="i" val="i"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(513, 52)" end="(513, 53)" leading="" trailing="" val=")"/>
                      </TermExplicitbinderNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(513, 53)" end="(513, 54)" leading="" trailing=" " val=","/>
                    <OtherNode start="(513, 55)" end="(513, 86)" kind="«term¬_»">
                      <AtomNode start="(513, 55)" end="(513, 56)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(513, 56)" end="(513, 86)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(513, 56)" end="(513, 57)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(513, 58)" end="(513, 86)">
                          <OtherNode start="(513, 58)" end="(513, 86)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(513, 58)" end="(513, 59)" leading="" trailing="" val="("/>
                            <OtherNode start="(513, 59)" end="(513, 85)" kind="«term__[_]'_»">
                              <IdentNode start="(513, 59)" end="(513, 61)" leading="" trailing="" raw_val="xs" val="xs"/>
                              <AtomNode start="(513, 61)" end="(513, 62)" leading="" trailing="" val="["/>
                              <IdentNode start="(513, 62)" end="(513, 63)" leading="" trailing="" raw_val="j" val="j"/>
                              <AtomNode start="(513, 63)" end="(513, 65)" leading="" trailing="" val="]'"/>
                              <OtherNode start="(513, 65)" end="(513, 85)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(513, 65)" end="(513, 66)" leading="" trailing="" val="("/>
                                <OtherNode start="(513, 66)" end="(513, 84)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(513, 66)" end="(513, 78)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(513, 79)" end="(513, 84)">
                                    <IdentNode start="(513, 79)" end="(513, 82)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                    <IdentNode start="(513, 83)" end="(513, 84)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(513, 84)" end="(513, 85)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(513, 85)" end="(513, 86)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(513, 87)" end="(515, 43)">
          <AtomNode start="(513, 87)" end="(513, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(513, 90)" end="(515, 43)">
            <AtomNode start="(513, 90)" end="(513, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(514, 3)" end="(515, 43)">
              <TacticTacticseq1IndentedNode start="(514, 3)" end="(515, 43)">
                <NullNode start="(514, 3)" end="(515, 43)">
                  <OtherNode start="(514, 3)" end="(514, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Nat&#10;⊢ findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = some i ↔&#10;    ∃ h, p { toList := xs }[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p { toList := xs }[j] = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(514, 3)" end="(514, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(514, 10)" end="(514, 12)">
                      <OtherNode start="(514, 10)" end="(514, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(514, 10)" end="(514, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(514, 13)" end="(514, 22)">
                      <AtomNode start="(514, 13)" end="(514, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(514, 18)" end="(514, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(514, 18)" end="(514, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(514, 18)" end="(514, 22)">
                            <OtherNode start="(514, 18)" end="(514, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(514, 18)" end="(514, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(514, 19)" end="(514, 21)">
                                <OtherNode start="(514, 19)" end="(514, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(514, 19)" end="(514, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(514, 19)" end="(514, 21)">
                                      <OtherNode start="(514, 19)" end="(514, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(514, 19)" end="(514, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(514, 21)" end="(514, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(515, 3)" end="(515, 43)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } = some i ↔&#10;    ∃ h, p { toList := xs }[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p { toList := xs }[j] = true" state_after="no goals" tactic="simp [List.findIdx?_eq_some_iff_getElem]">
                    <AtomNode start="(515, 3)" end="(515, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(515, 8)" end="(515, 43)">
                      <AtomNode start="(515, 8)" end="(515, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(515, 9)" end="(515, 42)">
                        <OtherNode start="(515, 9)" end="(515, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(515, 9)" end="(515, 42)" leading="" trailing="" raw_val="List.findIdx?_eq_some_iff_getElem" val="List.findIdx?_eq_some_iff_getElem" full_name="List.findIdx?_eq_some_iff_getElem" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(515, 42)" end="(515, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(517, 1)" end="(520, 58)" name="of_findIdx?_eq_some" full_name="Array.of_findIdx?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(517, 1)" end="(520, 58)" name="of_findIdx?_eq_some" full_name="Array.of_findIdx?_eq_some" _is_private_decl="False">
        <AtomNode start="(517, 1)" end="(517, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(517, 9)" end="(517, 28)">
          <IdentNode start="(517, 9)" end="(517, 28)" leading="" trailing=" " raw_val="of_findIdx?_eq_some" val="of_findIdx?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(517, 29)" end="(518, 54)">
          <NullNode start="(517, 29)" end="(517, 87)">
            <OtherNode start="(517, 29)" end="(517, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(517, 29)" end="(517, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(517, 30)" end="(517, 32)">
                <IdentNode start="(517, 30)" end="(517, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(517, 33)" end="(517, 42)">
                <AtomNode start="(517, 33)" end="(517, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(517, 35)" end="(517, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(517, 35)" end="(517, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(517, 41)" end="(517, 42)">
                    <IdentNode start="(517, 41)" end="(517, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(517, 42)" end="(517, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(517, 44)" end="(517, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(517, 44)" end="(517, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(517, 45)" end="(517, 46)">
                <IdentNode start="(517, 45)" end="(517, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(517, 47)" end="(517, 57)">
                <AtomNode start="(517, 47)" end="(517, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(517, 49)" end="(517, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(517, 49)" end="(517, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(517, 51)" end="(517, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(517, 53)" end="(517, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(517, 57)" end="(517, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(517, 59)" end="(517, 87)">
              <AtomNode start="(517, 59)" end="(517, 60)" leading="" trailing="" val="("/>
              <NullNode start="(517, 60)" end="(517, 61)">
                <IdentNode start="(517, 60)" end="(517, 61)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(517, 62)" end="(517, 86)">
                <AtomNode start="(517, 62)" end="(517, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(517, 64)" end="(517, 86)" kind="«term_=_»">
                  <OtherNode start="(517, 64)" end="(517, 77)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(517, 64)" end="(517, 75)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(517, 76)" end="(517, 77)">
                      <IdentNode start="(517, 76)" end="(517, 77)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(517, 78)" end="(517, 79)" leading="" trailing=" " val="="/>
                  <OtherNode start="(517, 80)" end="(517, 86)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(517, 80)" end="(517, 84)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(517, 85)" end="(517, 86)">
                      <IdentNode start="(517, 85)" end="(517, 86)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(517, 86)" end="(517, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(517, 88)" end="(518, 54)">
            <AtomNode start="(517, 88)" end="(517, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(518, 5)" end="(518, 54)" kind="Lean.Parser.Term.match">
              <AtomNode start="(518, 5)" end="(518, 10)" leading="" trailing=" " val="match"/>
              <NullNode/>
              <NullNode/>
              <NullNode start="(518, 11)" end="(518, 17)">
                <OtherNode start="(518, 11)" end="(518, 17)" kind="Lean.Parser.Term.matchDiscr">
                  <NullNode/>
                  <OtherNode start="(518, 11)" end="(518, 17)" kind="«term__[_]_?»">
                    <IdentNode start="(518, 11)" end="(518, 13)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <GroupNode/>
                    <AtomNode start="(518, 13)" end="(518, 14)" leading="" trailing="" val="["/>
                    <IdentNode start="(518, 14)" end="(518, 15)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(518, 15)" end="(518, 16)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(518, 16)" end="(518, 17)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(518, 18)" end="(518, 22)" leading="" trailing=" " val="with"/>
              <OtherNode start="(518, 23)" end="(518, 54)" kind="Lean.Parser.Term.matchAlts">
                <NullNode start="(518, 23)" end="(518, 54)">
                  <OtherNode start="(518, 23)" end="(518, 38)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(518, 23)" end="(518, 24)" leading="" trailing=" " val="|"/>
                    <NullNode start="(518, 25)" end="(518, 31)">
                      <NullNode start="(518, 25)" end="(518, 31)">
                        <OtherNode start="(518, 25)" end="(518, 31)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(518, 25)" end="(518, 29)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(518, 30)" end="(518, 31)">
                            <IdentNode start="(518, 30)" end="(518, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(518, 32)" end="(518, 34)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(518, 35)" end="(518, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(518, 35)" end="(518, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(518, 37)" end="(518, 38)">
                        <IdentNode start="(518, 37)" end="(518, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(518, 39)" end="(518, 54)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(518, 39)" end="(518, 40)" leading="" trailing=" " val="|"/>
                    <NullNode start="(518, 41)" end="(518, 45)">
                      <NullNode start="(518, 41)" end="(518, 45)">
                        <IdentNode start="(518, 41)" end="(518, 45)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(518, 46)" end="(518, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                    <IdentNode start="(518, 49)" end="(518, 54)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(518, 55)" end="(520, 58)">
          <AtomNode start="(518, 55)" end="(518, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(518, 58)" end="(520, 58)">
            <AtomNode start="(518, 58)" end="(518, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(519, 3)" end="(520, 58)">
              <TacticTacticseq1IndentedNode start="(519, 3)" end="(520, 58)">
                <NullNode start="(519, 3)" end="(520, 58)">
                  <OtherNode start="(519, 3)" end="(519, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;i : Nat&#10;xs : Array α&#10;p : α → Bool&#10;w : findIdx? p xs = some i&#10;⊢ match xs[i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;p : α → Bool&#10;xs : List α&#10;w : findIdx? p { toList := xs } = some i&#10;⊢ match { toList := xs }[i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(519, 3)" end="(519, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(519, 10)" end="(519, 12)">
                      <OtherNode start="(519, 10)" end="(519, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(519, 10)" end="(519, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(519, 13)" end="(519, 22)">
                      <AtomNode start="(519, 13)" end="(519, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(519, 18)" end="(519, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(519, 18)" end="(519, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(519, 18)" end="(519, 22)">
                            <OtherNode start="(519, 18)" end="(519, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(519, 18)" end="(519, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(519, 19)" end="(519, 21)">
                                <OtherNode start="(519, 19)" end="(519, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(519, 19)" end="(519, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(519, 19)" end="(519, 21)">
                                      <OtherNode start="(519, 19)" end="(519, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(519, 19)" end="(519, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(519, 21)" end="(519, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(520, 3)" end="(520, 58)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;p : α → Bool&#10;xs : List α&#10;w : findIdx? p { toList := xs } = some i&#10;⊢ match { toList := xs }[i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" state_after="no goals" tactic="simpa using List.of_findIdx?_eq_some (by simpa using w)">
                    <AtomNode start="(520, 3)" end="(520, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(520, 9)" end="(520, 58)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(520, 9)" end="(520, 58)">
                        <AtomNode start="(520, 9)" end="(520, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(520, 15)" end="(520, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(520, 15)" end="(520, 39)" leading="" trailing=" " raw_val="List.of_findIdx?_eq_some" val="List.of_findIdx?_eq_some" full_name="List.of_findIdx?_eq_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                          <NullNode start="(520, 40)" end="(520, 58)">
                            <OtherNode start="(520, 40)" end="(520, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(520, 40)" end="(520, 41)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(520, 41)" end="(520, 57)">
                                <AtomNode start="(520, 41)" end="(520, 43)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(520, 44)" end="(520, 57)">
                                  <TacticTacticseq1IndentedNode start="(520, 44)" end="(520, 57)">
                                    <NullNode start="(520, 44)" end="(520, 57)">
                                      <OtherNode start="(520, 44)" end="(520, 57)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;i : Nat&#10;p : α → Bool&#10;xs : List α&#10;w : findIdx? p { toList := xs } = some i&#10;⊢ List.findIdx? p xs = some i" state_after="no goals" tactic="simpa using w">
                                        <AtomNode start="(520, 44)" end="(520, 49)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(520, 50)" end="(520, 57)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(520, 50)" end="(520, 57)">
                                            <AtomNode start="(520, 50)" end="(520, 55)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(520, 56)" end="(520, 57)" leading="" trailing="" raw_val="w" val="w"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(520, 57)" end="(520, 58)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(522, 1)" end="(525, 58)" name="of_findIdx?_eq_none" full_name="Array.of_findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(522, 1)" end="(525, 58)" name="of_findIdx?_eq_none" full_name="Array.of_findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(522, 1)" end="(522, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(522, 9)" end="(522, 28)">
          <IdentNode start="(522, 9)" end="(522, 28)" leading="" trailing=" " raw_val="of_findIdx?_eq_none" val="of_findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(522, 29)" end="(523, 66)">
          <NullNode start="(522, 29)" end="(522, 85)">
            <OtherNode start="(522, 29)" end="(522, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(522, 29)" end="(522, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(522, 30)" end="(522, 32)">
                <IdentNode start="(522, 30)" end="(522, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(522, 33)" end="(522, 42)">
                <AtomNode start="(522, 33)" end="(522, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(522, 35)" end="(522, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(522, 35)" end="(522, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(522, 41)" end="(522, 42)">
                    <IdentNode start="(522, 41)" end="(522, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(522, 42)" end="(522, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(522, 44)" end="(522, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(522, 44)" end="(522, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(522, 45)" end="(522, 46)">
                <IdentNode start="(522, 45)" end="(522, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(522, 47)" end="(522, 57)">
                <AtomNode start="(522, 47)" end="(522, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(522, 49)" end="(522, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(522, 49)" end="(522, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(522, 51)" end="(522, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(522, 53)" end="(522, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(522, 57)" end="(522, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(522, 59)" end="(522, 85)">
              <AtomNode start="(522, 59)" end="(522, 60)" leading="" trailing="" val="("/>
              <NullNode start="(522, 60)" end="(522, 61)">
                <IdentNode start="(522, 60)" end="(522, 61)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(522, 62)" end="(522, 84)">
                <AtomNode start="(522, 62)" end="(522, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(522, 64)" end="(522, 84)" kind="«term_=_»">
                  <OtherNode start="(522, 64)" end="(522, 77)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(522, 64)" end="(522, 75)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(522, 76)" end="(522, 77)">
                      <IdentNode start="(522, 76)" end="(522, 77)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(522, 78)" end="(522, 79)" leading="" trailing=" " val="="/>
                  <IdentNode start="(522, 80)" end="(522, 84)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(522, 84)" end="(522, 85)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(522, 86)" end="(523, 66)">
            <AtomNode start="(522, 86)" end="(522, 87)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(523, 5)" end="(523, 66)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(523, 5)" end="(523, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(523, 7)" end="(523, 8)">
                <IdentNode start="(523, 7)" end="(523, 8)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(523, 9)" end="(523, 14)">
                <TermTypespecNode start="(523, 9)" end="(523, 14)">
                  <AtomNode start="(523, 9)" end="(523, 10)" leading="" trailing=" " val=":"/>
                  <IdentNode start="(523, 11)" end="(523, 14)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </TermTypespecNode>
              </NullNode>
              <AtomNode start="(523, 14)" end="(523, 15)" leading="" trailing=" " val=","/>
              <OtherNode start="(523, 16)" end="(523, 66)" kind="Lean.Parser.Term.match">
                <AtomNode start="(523, 16)" end="(523, 21)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(523, 22)" end="(523, 28)">
                  <OtherNode start="(523, 22)" end="(523, 28)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(523, 22)" end="(523, 28)" kind="«term__[_]_?»">
                      <IdentNode start="(523, 22)" end="(523, 24)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <GroupNode/>
                      <AtomNode start="(523, 24)" end="(523, 25)" leading="" trailing="" val="["/>
                      <IdentNode start="(523, 25)" end="(523, 26)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(523, 26)" end="(523, 27)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(523, 27)" end="(523, 28)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(523, 29)" end="(523, 33)" leading="" trailing=" " val="with"/>
                <OtherNode start="(523, 34)" end="(523, 66)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(523, 34)" end="(523, 66)">
                    <OtherNode start="(523, 34)" end="(523, 51)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(523, 34)" end="(523, 35)" leading="" trailing=" " val="|"/>
                      <NullNode start="(523, 36)" end="(523, 42)">
                        <NullNode start="(523, 36)" end="(523, 42)">
                          <OtherNode start="(523, 36)" end="(523, 42)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(523, 36)" end="(523, 40)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(523, 41)" end="(523, 42)">
                              <IdentNode start="(523, 41)" end="(523, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(523, 43)" end="(523, 45)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(523, 46)" end="(523, 51)" kind="«term¬_»">
                        <AtomNode start="(523, 46)" end="(523, 47)" leading="" trailing=" " val="¬"/>
                        <OtherNode start="(523, 48)" end="(523, 51)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(523, 48)" end="(523, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(523, 50)" end="(523, 51)">
                            <IdentNode start="(523, 50)" end="(523, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(523, 52)" end="(523, 66)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(523, 52)" end="(523, 53)" leading="" trailing=" " val="|"/>
                      <NullNode start="(523, 54)" end="(523, 58)">
                        <NullNode start="(523, 54)" end="(523, 58)">
                          <IdentNode start="(523, 54)" end="(523, 58)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(523, 59)" end="(523, 61)" leading="" trailing=" " val="=&amp;gt;"/>
                      <IdentNode start="(523, 62)" end="(523, 66)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(523, 67)" end="(525, 58)">
          <AtomNode start="(523, 67)" end="(523, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(523, 70)" end="(525, 58)">
            <AtomNode start="(523, 70)" end="(523, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(524, 3)" end="(525, 58)">
              <TacticTacticseq1IndentedNode start="(524, 3)" end="(525, 58)">
                <NullNode start="(524, 3)" end="(525, 58)">
                  <OtherNode start="(524, 3)" end="(524, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;w : findIdx? p xs = none&#10;⊢ ∀ (i : Nat),&#10;    match xs[i]? with&#10;    | some a =&amp;gt; ¬p a = true&#10;    | none =&amp;gt; true = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;w : findIdx? p { toList := xs } = none&#10;⊢ ∀ (i : Nat),&#10;    match { toList := xs }[i]? with&#10;    | some a =&amp;gt; ¬p a = true&#10;    | none =&amp;gt; true = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(524, 3)" end="(524, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(524, 10)" end="(524, 12)">
                      <OtherNode start="(524, 10)" end="(524, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(524, 10)" end="(524, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(524, 13)" end="(524, 22)">
                      <AtomNode start="(524, 13)" end="(524, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(524, 18)" end="(524, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(524, 18)" end="(524, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(524, 18)" end="(524, 22)">
                            <OtherNode start="(524, 18)" end="(524, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(524, 18)" end="(524, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(524, 19)" end="(524, 21)">
                                <OtherNode start="(524, 19)" end="(524, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(524, 19)" end="(524, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(524, 19)" end="(524, 21)">
                                      <OtherNode start="(524, 19)" end="(524, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(524, 19)" end="(524, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(524, 21)" end="(524, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(525, 3)" end="(525, 58)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;w : findIdx? p { toList := xs } = none&#10;⊢ ∀ (i : Nat),&#10;    match { toList := xs }[i]? with&#10;    | some a =&amp;gt; ¬p a = true&#10;    | none =&amp;gt; true = true" state_after="no goals" tactic="simpa using List.of_findIdx?_eq_none (by simpa using w)">
                    <AtomNode start="(525, 3)" end="(525, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(525, 9)" end="(525, 58)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(525, 9)" end="(525, 58)">
                        <AtomNode start="(525, 9)" end="(525, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(525, 15)" end="(525, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(525, 15)" end="(525, 39)" leading="" trailing=" " raw_val="List.of_findIdx?_eq_none" val="List.of_findIdx?_eq_none" full_name="List.of_findIdx?_eq_none" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                          <NullNode start="(525, 40)" end="(525, 58)">
                            <OtherNode start="(525, 40)" end="(525, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(525, 40)" end="(525, 41)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(525, 41)" end="(525, 57)">
                                <AtomNode start="(525, 41)" end="(525, 43)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(525, 44)" end="(525, 57)">
                                  <TacticTacticseq1IndentedNode start="(525, 44)" end="(525, 57)">
                                    <NullNode start="(525, 44)" end="(525, 57)">
                                      <OtherNode start="(525, 44)" end="(525, 57)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;w : findIdx? p { toList := xs } = none&#10;⊢ List.findIdx? p xs = none" state_after="no goals" tactic="simpa using w">
                                        <AtomNode start="(525, 44)" end="(525, 49)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(525, 50)" end="(525, 57)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(525, 50)" end="(525, 57)">
                                            <AtomNode start="(525, 50)" end="(525, 55)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(525, 56)" end="(525, 57)" leading="" trailing="" raw_val="w" val="w"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(525, 57)" end="(525, 58)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(527, 1)" end="(530, 27)" name="findIdx?_map" full_name="Array.findIdx?_map">
      <CommandDeclmodifiersNode start="(527, 1)" end="(527, 8)">
        <NullNode/>
        <NullNode start="(527, 1)" end="(527, 8)">
          <OtherNode start="(527, 1)" end="(527, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(527, 1)" end="(527, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(527, 3)" end="(527, 7)">
              <OtherNode start="(527, 3)" end="(527, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(527, 3)" end="(527, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(527, 3)" end="(527, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(527, 7)" end="(527, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(527, 9)" end="(530, 27)" name="findIdx?_map" full_name="Array.findIdx?_map" _is_private_decl="False">
        <AtomNode start="(527, 9)" end="(527, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(527, 17)" end="(527, 29)">
          <IdentNode start="(527, 17)" end="(527, 29)" leading="" trailing=" " raw_val="findIdx?_map" val="findIdx?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(527, 30)" end="(528, 48)">
          <NullNode start="(527, 30)" end="(527, 71)">
            <OtherNode start="(527, 30)" end="(527, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(527, 30)" end="(527, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(527, 31)" end="(527, 32)">
                <IdentNode start="(527, 31)" end="(527, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(527, 33)" end="(527, 40)">
                <AtomNode start="(527, 33)" end="(527, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(527, 35)" end="(527, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(527, 35)" end="(527, 36)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(527, 37)" end="(527, 38)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(527, 39)" end="(527, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(527, 40)" end="(527, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(527, 42)" end="(527, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(527, 42)" end="(527, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(527, 43)" end="(527, 45)">
                <IdentNode start="(527, 43)" end="(527, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(527, 46)" end="(527, 55)">
                <AtomNode start="(527, 46)" end="(527, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(527, 48)" end="(527, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(527, 48)" end="(527, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(527, 54)" end="(527, 55)">
                    <IdentNode start="(527, 54)" end="(527, 55)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(527, 55)" end="(527, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(527, 57)" end="(527, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(527, 57)" end="(527, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(527, 58)" end="(527, 59)">
                <IdentNode start="(527, 58)" end="(527, 59)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(527, 60)" end="(527, 70)">
                <AtomNode start="(527, 60)" end="(527, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(527, 62)" end="(527, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(527, 62)" end="(527, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(527, 64)" end="(527, 65)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(527, 66)" end="(527, 70)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(527, 70)" end="(527, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(527, 72)" end="(528, 48)">
            <AtomNode start="(527, 72)" end="(527, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(528, 5)" end="(528, 48)" kind="«term_=_»">
              <OtherNode start="(528, 5)" end="(528, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(528, 5)" end="(528, 13)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="Array.findIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(528, 14)" end="(528, 26)">
                  <IdentNode start="(528, 14)" end="(528, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(528, 16)" end="(528, 26)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(528, 16)" end="(528, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(528, 17)" end="(528, 25)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(528, 17)" end="(528, 23)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(528, 24)" end="(528, 25)">
                        <IdentNode start="(528, 24)" end="(528, 25)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(528, 25)" end="(528, 26)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(528, 27)" end="(528, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(528, 29)" end="(528, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(528, 29)" end="(528, 40)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(528, 41)" end="(528, 48)">
                  <OtherNode start="(528, 41)" end="(528, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(528, 41)" end="(528, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(528, 42)" end="(528, 47)" kind="«term_∘_»">
                      <IdentNode start="(528, 42)" end="(528, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                      <AtomNode start="(528, 44)" end="(528, 45)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(528, 46)" end="(528, 47)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(528, 47)" end="(528, 48)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(528, 49)" end="(530, 27)">
          <AtomNode start="(528, 49)" end="(528, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(528, 52)" end="(530, 27)">
            <AtomNode start="(528, 52)" end="(528, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(529, 3)" end="(530, 27)">
              <TacticTacticseq1IndentedNode start="(529, 3)" end="(530, 27)">
                <NullNode start="(529, 3)" end="(530, 27)">
                  <OtherNode start="(529, 3)" end="(529, 22)" kind="Lean.Parser.Tactic.rcases" state_before="β : Type u_1&#10;α : Type u_2&#10;f : β → α&#10;xs : Array β&#10;p : α → Bool&#10;⊢ findIdx? p (map f xs) = findIdx? (p ∘ f) xs" state_after="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;f : β → α&#10;p : α → Bool&#10;xs : List β&#10;⊢ findIdx? p (map f { toList := xs }) = findIdx? (p ∘ f) { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(529, 3)" end="(529, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(529, 10)" end="(529, 12)">
                      <OtherNode start="(529, 10)" end="(529, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(529, 10)" end="(529, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(529, 13)" end="(529, 22)">
                      <AtomNode start="(529, 13)" end="(529, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(529, 18)" end="(529, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(529, 18)" end="(529, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(529, 18)" end="(529, 22)">
                            <OtherNode start="(529, 18)" end="(529, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(529, 18)" end="(529, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(529, 19)" end="(529, 21)">
                                <OtherNode start="(529, 19)" end="(529, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(529, 19)" end="(529, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(529, 19)" end="(529, 21)">
                                      <OtherNode start="(529, 19)" end="(529, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(529, 19)" end="(529, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(529, 21)" end="(529, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(530, 3)" end="(530, 27)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;f : β → α&#10;p : α → Bool&#10;xs : List β&#10;⊢ findIdx? p (map f { toList := xs }) = findIdx? (p ∘ f) { toList := xs }" state_after="no goals" tactic="simp [List.findIdx?_map]">
                    <AtomNode start="(530, 3)" end="(530, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(530, 8)" end="(530, 27)">
                      <AtomNode start="(530, 8)" end="(530, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(530, 9)" end="(530, 26)">
                        <OtherNode start="(530, 9)" end="(530, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(530, 9)" end="(530, 26)" leading="" trailing="" raw_val="List.findIdx?_map" val="List.findIdx?_map" full_name="List.findIdx?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(530, 26)" end="(530, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(532, 1)" end="(537, 30)" name="findIdx?_append" full_name="Array.findIdx?_append">
      <CommandDeclmodifiersNode start="(532, 1)" end="(532, 8)">
        <NullNode/>
        <NullNode start="(532, 1)" end="(532, 8)">
          <OtherNode start="(532, 1)" end="(532, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(532, 1)" end="(532, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(532, 3)" end="(532, 7)">
              <OtherNode start="(532, 3)" end="(532, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(532, 3)" end="(532, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(532, 3)" end="(532, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(532, 7)" end="(532, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(532, 9)" end="(537, 30)" name="findIdx?_append" full_name="Array.findIdx?_append" _is_private_decl="False">
        <AtomNode start="(532, 9)" end="(532, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(532, 17)" end="(532, 32)">
          <IdentNode start="(532, 17)" end="(532, 32)" leading="" trailing=" " raw_val="findIdx?_append" val="findIdx?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(532, 33)" end="(534, 68)">
          <NullNode/>
          <TermTypespecNode start="(532, 33)" end="(534, 68)">
            <AtomNode start="(532, 33)" end="(532, 34)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(533, 5)" end="(534, 68)" kind="«term_=_»">
              <OtherNode start="(533, 5)" end="(533, 36)" kind="Lean.Parser.Term.app">
                <OtherNode start="(533, 5)" end="(533, 34)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(533, 5)" end="(533, 25)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(533, 5)" end="(533, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(533, 6)" end="(533, 14)" kind="«term_++_»">
                      <IdentNode start="(533, 6)" end="(533, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(533, 9)" end="(533, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(533, 12)" end="(533, 14)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(533, 15)" end="(533, 16)" leading="" trailing=" " val=":"/>
                    <NullNode start="(533, 17)" end="(533, 24)">
                      <OtherNode start="(533, 17)" end="(533, 24)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(533, 17)" end="(533, 22)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(533, 23)" end="(533, 24)">
                          <IdentNode start="(533, 23)" end="(533, 24)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(533, 24)" end="(533, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(533, 25)" end="(533, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(533, 26)" end="(533, 34)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="Array.findIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(533, 35)" end="(533, 36)">
                  <IdentNode start="(533, 35)" end="(533, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(533, 37)" end="(533, 38)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(534, 7)" end="(534, 68)" kind="Lean.Parser.Term.app">
                <OtherNode start="(534, 7)" end="(534, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(534, 7)" end="(534, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(534, 7)" end="(534, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(534, 8)" end="(534, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(534, 8)" end="(534, 19)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(534, 20)" end="(534, 21)">
                        <IdentNode start="(534, 20)" end="(534, 21)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(534, 21)" end="(534, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(534, 22)" end="(534, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(534, 23)" end="(534, 25)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(534, 26)" end="(534, 68)">
                  <OtherNode start="(534, 26)" end="(534, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(534, 26)" end="(534, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(534, 27)" end="(534, 67)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(534, 27)" end="(534, 46)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(534, 27)" end="(534, 42)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(534, 27)" end="(534, 28)" leading="" trailing="" val="("/>
                          <OtherNode start="(534, 28)" end="(534, 41)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(534, 28)" end="(534, 39)" leading="" trailing=" " raw_val="ys.findIdx?" val="ys.findIdx?"/>
                            <NullNode start="(534, 40)" end="(534, 41)">
                              <IdentNode start="(534, 40)" end="(534, 41)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(534, 41)" end="(534, 42)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(534, 42)" end="(534, 43)" leading="" trailing="" val="."/>
                        <IdentNode start="(534, 43)" end="(534, 46)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(534, 47)" end="(534, 67)">
                        <OtherNode start="(534, 47)" end="(534, 67)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(534, 47)" end="(534, 50)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(534, 51)" end="(534, 67)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(534, 51)" end="(534, 52)">
                              <IdentNode start="(534, 51)" end="(534, 52)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(534, 53)" end="(534, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(534, 56)" end="(534, 67)" kind="«term_+_»">
                              <IdentNode start="(534, 56)" end="(534, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(534, 58)" end="(534, 59)" leading="" trailing=" " val="+"/>
                              <IdentNode start="(534, 60)" end="(534, 67)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(534, 67)" end="(534, 68)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(534, 69)" end="(537, 30)">
          <AtomNode start="(534, 69)" end="(534, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(534, 72)" end="(537, 30)">
            <AtomNode start="(534, 72)" end="(534, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(535, 3)" end="(537, 30)">
              <TacticTacticseq1IndentedNode start="(535, 3)" end="(537, 30)">
                <NullNode start="(535, 3)" end="(537, 30)">
                  <OtherNode start="(535, 3)" end="(535, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;⊢ findIdx? p (xs ++ ys) = (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys))" state_after="case mk&#10;α : Type u_1&#10;ys : Array α&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p ({ toList := xs } ++ ys) =&#10;    (findIdx? p { toList := xs }).or (Option.map (fun i =&amp;gt; i + { toList := xs }.size) (findIdx? p ys))" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(535, 3)" end="(535, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(535, 10)" end="(535, 12)">
                      <OtherNode start="(535, 10)" end="(535, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(535, 10)" end="(535, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(535, 13)" end="(535, 22)">
                      <AtomNode start="(535, 13)" end="(535, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(535, 18)" end="(535, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(535, 18)" end="(535, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(535, 18)" end="(535, 22)">
                            <OtherNode start="(535, 18)" end="(535, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(535, 18)" end="(535, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(535, 19)" end="(535, 21)">
                                <OtherNode start="(535, 19)" end="(535, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(535, 19)" end="(535, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(535, 19)" end="(535, 21)">
                                      <OtherNode start="(535, 19)" end="(535, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(535, 19)" end="(535, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(535, 21)" end="(535, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(536, 3)" end="(536, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;ys : Array α&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p ({ toList := xs } ++ ys) =&#10;    (findIdx? p { toList := xs }).or (Option.map (fun i =&amp;gt; i + { toList := xs }.size) (findIdx? p ys))" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ findIdx? p ({ toList := xs } ++ { toList := ys }) =&#10;    (findIdx? p { toList := xs }).or (Option.map (fun i =&amp;gt; i + { toList := xs }.size) (findIdx? p { toList := ys }))" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(536, 3)" end="(536, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(536, 10)" end="(536, 12)">
                      <OtherNode start="(536, 10)" end="(536, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(536, 10)" end="(536, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(536, 13)" end="(536, 22)">
                      <AtomNode start="(536, 13)" end="(536, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(536, 18)" end="(536, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(536, 18)" end="(536, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(536, 18)" end="(536, 22)">
                            <OtherNode start="(536, 18)" end="(536, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(536, 18)" end="(536, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(536, 19)" end="(536, 21)">
                                <OtherNode start="(536, 19)" end="(536, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(536, 19)" end="(536, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(536, 19)" end="(536, 21)">
                                      <OtherNode start="(536, 19)" end="(536, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(536, 19)" end="(536, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(536, 21)" end="(536, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(537, 3)" end="(537, 30)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ findIdx? p ({ toList := xs } ++ { toList := ys }) =&#10;    (findIdx? p { toList := xs }).or (Option.map (fun i =&amp;gt; i + { toList := xs }.size) (findIdx? p { toList := ys }))" state_after="no goals" tactic="simp [List.findIdx?_append]">
                    <AtomNode start="(537, 3)" end="(537, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(537, 8)" end="(537, 30)">
                      <AtomNode start="(537, 8)" end="(537, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(537, 9)" end="(537, 29)">
                        <OtherNode start="(537, 9)" end="(537, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(537, 9)" end="(537, 29)" leading="" trailing="" raw_val="List.findIdx?_append" val="List.findIdx?_append" full_name="List.findIdx?_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(537, 29)" end="(537, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(539, 1)" end="(544, 62)" name="findIdx?_push" full_name="Array.findIdx?_push">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(539, 1)" end="(544, 62)" name="findIdx?_push" full_name="Array.findIdx?_push" _is_private_decl="False">
        <AtomNode start="(539, 1)" end="(539, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(539, 9)" end="(539, 22)">
          <IdentNode start="(539, 9)" end="(539, 22)" leading="" trailing=" " raw_val="findIdx?_push" val="findIdx?_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(539, 23)" end="(540, 85)">
          <NullNode start="(539, 23)" end="(539, 60)">
            <OtherNode start="(539, 23)" end="(539, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(539, 23)" end="(539, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(539, 24)" end="(539, 26)">
                <IdentNode start="(539, 24)" end="(539, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(539, 27)" end="(539, 36)">
                <AtomNode start="(539, 27)" end="(539, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(539, 29)" end="(539, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(539, 29)" end="(539, 34)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(539, 35)" end="(539, 36)">
                    <IdentNode start="(539, 35)" end="(539, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(539, 36)" end="(539, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(539, 38)" end="(539, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(539, 38)" end="(539, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(539, 39)" end="(539, 40)">
                <IdentNode start="(539, 39)" end="(539, 40)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(539, 41)" end="(539, 44)">
                <AtomNode start="(539, 41)" end="(539, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(539, 43)" end="(539, 44)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(539, 44)" end="(539, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(539, 46)" end="(539, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(539, 46)" end="(539, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(539, 47)" end="(539, 48)">
                <IdentNode start="(539, 47)" end="(539, 48)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(539, 49)" end="(539, 59)">
                <AtomNode start="(539, 49)" end="(539, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(539, 51)" end="(539, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(539, 51)" end="(539, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(539, 53)" end="(539, 54)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(539, 55)" end="(539, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(539, 59)" end="(539, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(539, 61)" end="(540, 85)">
            <AtomNode start="(539, 61)" end="(539, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(540, 5)" end="(540, 85)" kind="«term_=_»">
              <OtherNode start="(540, 5)" end="(540, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(540, 5)" end="(540, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(540, 5)" end="(540, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(540, 5)" end="(540, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(540, 6)" end="(540, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(540, 6)" end="(540, 13)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(540, 14)" end="(540, 15)">
                        <IdentNode start="(540, 14)" end="(540, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(540, 15)" end="(540, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(540, 16)" end="(540, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(540, 17)" end="(540, 25)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="Array.findIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(540, 26)" end="(540, 27)">
                  <IdentNode start="(540, 26)" end="(540, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(540, 28)" end="(540, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(540, 30)" end="(540, 85)" kind="Lean.Parser.Term.app">
                <OtherNode start="(540, 30)" end="(540, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(540, 30)" end="(540, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(540, 30)" end="(540, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(540, 31)" end="(540, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(540, 31)" end="(540, 42)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(540, 43)" end="(540, 44)">
                        <IdentNode start="(540, 43)" end="(540, 44)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(540, 44)" end="(540, 45)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(540, 45)" end="(540, 46)" leading="" trailing="" val="."/>
                  <IdentNode start="(540, 46)" end="(540, 48)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(540, 49)" end="(540, 85)">
                  <OtherNode start="(540, 49)" end="(540, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(540, 49)" end="(540, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(540, 50)" end="(540, 84)" kind="termIfThenElse">
                      <AtomNode start="(540, 50)" end="(540, 52)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(540, 53)" end="(540, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(540, 53)" end="(540, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(540, 55)" end="(540, 56)">
                          <IdentNode start="(540, 55)" end="(540, 56)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(540, 57)" end="(540, 61)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(540, 62)" end="(540, 74)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(540, 62)" end="(540, 66)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(540, 67)" end="(540, 74)">
                          <IdentNode start="(540, 67)" end="(540, 74)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(540, 75)" end="(540, 79)" leading="" trailing=" " val="else"/>
                      <IdentNode start="(540, 80)" end="(540, 84)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(540, 84)" end="(540, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(540, 86)" end="(544, 62)">
          <AtomNode start="(540, 86)" end="(540, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(540, 89)" end="(544, 62)">
            <AtomNode start="(540, 89)" end="(540, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(541, 3)" end="(544, 62)">
              <TacticTacticseq1IndentedNode start="(541, 3)" end="(544, 62)">
                <NullNode start="(541, 3)" end="(544, 62)">
                  <OtherNode start="(541, 3)" end="(541, 46)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ findIdx? p (xs.push a) = (findIdx? p xs).or (if p a = true then some xs.size else none)" state_after="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) =&#10;    (findIdx? p xs).or (if p a = true then some xs.size else none)" tactic="simp only [push_eq_append, findIdx?_append]">
                    <AtomNode start="(541, 3)" end="(541, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(541, 8)" end="(541, 12)">
                      <AtomNode start="(541, 8)" end="(541, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(541, 13)" end="(541, 46)">
                      <AtomNode start="(541, 13)" end="(541, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(541, 14)" end="(541, 45)">
                        <OtherNode start="(541, 14)" end="(541, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(541, 14)" end="(541, 28)" leading="" trailing="" raw_val="push_eq_append" val="push_eq_append" full_name="Array.push_eq_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(541, 28)" end="(541, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(541, 30)" end="(541, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(541, 30)" end="(541, 45)" leading="" trailing="" raw_val="findIdx?_append" val="findIdx?_append" full_name="Array.findIdx?_append" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(532, 17)" def_end="(532, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(541, 45)" end="(541, 46)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(542, 3)" end="(542, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) =&#10;    (findIdx? p xs).or (if p a = true then some xs.size else none)" state_after="case isTrue&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or (some xs.size)&#10;&#10;case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or none" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(542, 3)" end="(542, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(542, 3)" end="(542, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(542, 9)" end="(542, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(542, 13)" end="(542, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(542, 13)" end="(542, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(542, 22)" end="(542, 23)">
                        <LeanBinderidentNode start="(542, 22)" end="(542, 23)">
                          <IdentNode start="(542, 22)" end="(542, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(543, 3)" end="(543, 76)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or (some xs.size)&#10;&#10;case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or none" state_after="case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or none" tactic="· simp only [findIdx?_singleton, if_pos h, Option.map_some, Nat.zero_add]">
                    <OtherNode start="(543, 3)" end="(543, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(543, 3)" end="(543, 4)" kind="patternIgnore">
                        <OtherNode start="(543, 3)" end="(543, 4)" kind="token.«· »">
                          <AtomNode start="(543, 3)" end="(543, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(543, 5)" end="(543, 76)">
                      <TacticTacticseq1IndentedNode start="(543, 5)" end="(543, 76)">
                        <NullNode start="(543, 5)" end="(543, 76)">
                          <OtherNode start="(543, 5)" end="(543, 76)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or (some xs.size)" state_after="no goals" tactic="simp only [findIdx?_singleton, if_pos h, Option.map_some, Nat.zero_add]">
                            <AtomNode start="(543, 5)" end="(543, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(543, 10)" end="(543, 14)">
                              <AtomNode start="(543, 10)" end="(543, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(543, 15)" end="(543, 76)">
                              <AtomNode start="(543, 15)" end="(543, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(543, 16)" end="(543, 75)">
                                <OtherNode start="(543, 16)" end="(543, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(543, 16)" end="(543, 34)" leading="" trailing="" raw_val="findIdx?_singleton" val="findIdx?_singleton" full_name="Array.findIdx?_singleton" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(469, 9)" def_end="(469, 27)"/>
                                </OtherNode>
                                <AtomNode start="(543, 34)" end="(543, 35)" leading="" trailing=" " val=","/>
                                <OtherNode start="(543, 36)" end="(543, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(543, 36)" end="(543, 44)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(543, 36)" end="(543, 42)" leading="" trailing=" " raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                    <NullNode start="(543, 43)" end="(543, 44)">
                                      <IdentNode start="(543, 43)" end="(543, 44)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(543, 44)" end="(543, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(543, 46)" end="(543, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(543, 46)" end="(543, 61)" leading="" trailing="" raw_val="Option.map_some" val="Option.map_some" full_name="Option.map_some" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(543, 61)" end="(543, 62)" leading="" trailing=" " val=","/>
                                <OtherNode start="(543, 63)" end="(543, 75)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(543, 63)" end="(543, 75)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(543, 75)" end="(543, 76)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(544, 3)" end="(544, 62)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or none" state_after="no goals" tactic="· simp only [findIdx?_singleton, if_neg h, Option.map_none]">
                    <OtherNode start="(544, 3)" end="(544, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(544, 3)" end="(544, 4)" kind="patternIgnore">
                        <OtherNode start="(544, 3)" end="(544, 4)" kind="token.«· »">
                          <AtomNode start="(544, 3)" end="(544, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(544, 5)" end="(544, 62)">
                      <TacticTacticseq1IndentedNode start="(544, 5)" end="(544, 62)">
                        <NullNode start="(544, 5)" end="(544, 62)">
                          <OtherNode start="(544, 5)" end="(544, 62)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;h : ¬p a = true&#10;⊢ (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p #[a])) = (findIdx? p xs).or none" state_after="no goals" tactic="simp only [findIdx?_singleton, if_neg h, Option.map_none]">
                            <AtomNode start="(544, 5)" end="(544, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(544, 10)" end="(544, 14)">
                              <AtomNode start="(544, 10)" end="(544, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(544, 15)" end="(544, 62)">
                              <AtomNode start="(544, 15)" end="(544, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(544, 16)" end="(544, 61)">
                                <OtherNode start="(544, 16)" end="(544, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(544, 16)" end="(544, 34)" leading="" trailing="" raw_val="findIdx?_singleton" val="findIdx?_singleton" full_name="Array.findIdx?_singleton" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(469, 9)" def_end="(469, 27)"/>
                                </OtherNode>
                                <AtomNode start="(544, 34)" end="(544, 35)" leading="" trailing=" " val=","/>
                                <OtherNode start="(544, 36)" end="(544, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(544, 36)" end="(544, 44)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(544, 36)" end="(544, 42)" leading="" trailing=" " raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                    <NullNode start="(544, 43)" end="(544, 44)">
                                      <IdentNode start="(544, 43)" end="(544, 44)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(544, 44)" end="(544, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(544, 46)" end="(544, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(544, 46)" end="(544, 61)" leading="" trailing="" raw_val="Option.map_none" val="Option.map_none" full_name="Option.map_none" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(544, 61)" end="(544, 62)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(546, 1)" end="(552, 50)" name="findIdx?_flatten" full_name="Array.findIdx?_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(546, 1)" end="(552, 50)" name="findIdx?_flatten" full_name="Array.findIdx?_flatten" _is_private_decl="False">
        <AtomNode start="(546, 1)" end="(546, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(546, 9)" end="(546, 25)">
          <IdentNode start="(546, 9)" end="(546, 25)" leading="" trailing=" " raw_val="findIdx?_flatten" val="findIdx?_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(546, 26)" end="(550, 54)">
          <NullNode start="(546, 26)" end="(546, 64)">
            <OtherNode start="(546, 26)" end="(546, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(546, 26)" end="(546, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(546, 27)" end="(546, 30)">
                <IdentNode start="(546, 27)" end="(546, 30)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(546, 31)" end="(546, 48)">
                <AtomNode start="(546, 31)" end="(546, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(546, 33)" end="(546, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(546, 33)" end="(546, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(546, 39)" end="(546, 48)">
                    <OtherNode start="(546, 39)" end="(546, 48)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(546, 39)" end="(546, 40)" leading="" trailing="" val="("/>
                      <OtherNode start="(546, 40)" end="(546, 47)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(546, 40)" end="(546, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(546, 46)" end="(546, 47)">
                          <IdentNode start="(546, 46)" end="(546, 47)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(546, 47)" end="(546, 48)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(546, 48)" end="(546, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(546, 50)" end="(546, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(546, 50)" end="(546, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(546, 51)" end="(546, 52)">
                <IdentNode start="(546, 51)" end="(546, 52)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(546, 53)" end="(546, 63)">
                <AtomNode start="(546, 53)" end="(546, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(546, 55)" end="(546, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(546, 55)" end="(546, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(546, 57)" end="(546, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(546, 59)" end="(546, 63)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(546, 63)" end="(546, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(546, 65)" end="(550, 54)">
            <AtomNode start="(546, 65)" end="(546, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(547, 5)" end="(550, 54)" kind="«term_=_»">
              <OtherNode start="(547, 5)" end="(547, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(547, 5)" end="(547, 25)" leading="" trailing=" " raw_val="xss.flatten.findIdx?" val="xss.flatten.findIdx?"/>
                <NullNode start="(547, 26)" end="(547, 27)">
                  <IdentNode start="(547, 26)" end="(547, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(547, 28)" end="(547, 29)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(548, 7)" end="(550, 54)" kind="Lean.Parser.Term.app">
                <OtherNode start="(548, 7)" end="(548, 35)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(548, 7)" end="(548, 31)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(548, 7)" end="(548, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(548, 8)" end="(548, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(548, 8)" end="(548, 20)" leading="" trailing=" " raw_val="xss.findIdx?" val="xss.findIdx?"/>
                      <NullNode start="(548, 21)" end="(548, 30)">
                        <OtherNode start="(548, 21)" end="(548, 30)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(548, 21)" end="(548, 22)" leading="" trailing="" val="("/>
                          <OtherNode start="(548, 22)" end="(548, 29)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(548, 22)" end="(548, 27)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(548, 22)" end="(548, 23)" kind="Lean.Parser.Term.cdot">
                                <AtomNode start="(548, 22)" end="(548, 23)" leading="" trailing="" val="·"/>
                              </OtherNode>
                              <AtomNode start="(548, 23)" end="(548, 24)" leading="" trailing="" val="."/>
                              <IdentNode start="(548, 24)" end="(548, 27)" leading="" trailing=" " raw_val="any" val="any" full_name="Array.any" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                            </OtherNode>
                            <NullNode start="(548, 28)" end="(548, 29)">
                              <IdentNode start="(548, 28)" end="(548, 29)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(548, 29)" end="(548, 30)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(548, 30)" end="(548, 31)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(548, 31)" end="(548, 32)" leading="" trailing="" val="."/>
                  <IdentNode start="(548, 32)" end="(548, 35)" leading="" trailing="&#10;        " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(549, 9)" end="(550, 54)">
                  <OtherNode start="(549, 9)" end="(550, 54)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(549, 9)" end="(549, 12)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(549, 13)" end="(550, 54)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(549, 13)" end="(549, 14)">
                        <IdentNode start="(549, 13)" end="(549, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(549, 15)" end="(549, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(549, 18)" end="(550, 54)" kind="«term_+_»">
                        <OtherNode start="(549, 18)" end="(549, 51)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(549, 18)" end="(549, 47)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(549, 18)" end="(549, 19)" leading="" trailing="" val="("/>
                            <OtherNode start="(549, 19)" end="(549, 46)" kind="Lean.Parser.Term.app">
                              <OtherNode start="(549, 19)" end="(549, 35)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(549, 19)" end="(549, 31)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(549, 19)" end="(549, 20)" leading="" trailing="" val="("/>
                                  <OtherNode start="(549, 20)" end="(549, 30)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(549, 20)" end="(549, 28)" leading="" trailing=" " raw_val="xss.take" val="xss.take"/>
                                    <NullNode start="(549, 29)" end="(549, 30)">
                                      <IdentNode start="(549, 29)" end="(549, 30)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(549, 30)" end="(549, 31)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(549, 31)" end="(549, 32)" leading="" trailing="" val="."/>
                                <IdentNode start="(549, 32)" end="(549, 35)" leading="" trailing=" " raw_val="map" val="map" full_name="Array.map" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                              </OtherNode>
                              <NullNode start="(549, 36)" end="(549, 46)">
                                <IdentNode start="(549, 36)" end="(549, 46)" leading="" trailing="" raw_val="Array.size" val="Array.size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(549, 46)" end="(549, 47)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(549, 47)" end="(549, 48)" leading="" trailing="" val="."/>
                          <IdentNode start="(549, 48)" end="(549, 51)" leading="" trailing=" " raw_val="sum" val="sum" full_name="Array.sum" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(549, 52)" end="(549, 53)" leading="" trailing="&#10;          " val="+"/>
                        <OtherNode start="(550, 11)" end="(550, 54)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(550, 11)" end="(550, 52)" kind="Lean.Parser.Term.proj">
                            <OtherNode start="(550, 11)" end="(550, 47)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(550, 11)" end="(550, 12)" leading="" trailing="" val="("/>
                              <OtherNode start="(550, 12)" end="(550, 46)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(550, 12)" end="(550, 23)" kind="Lean.Parser.Term.proj">
                                  <OtherNode start="(550, 12)" end="(550, 19)" kind="«term__[_]_?»">
                                    <IdentNode start="(550, 12)" end="(550, 15)" leading="" trailing="" raw_val="xss" val="xss"/>
                                    <GroupNode/>
                                    <AtomNode start="(550, 15)" end="(550, 16)" leading="" trailing="" val="["/>
                                    <IdentNode start="(550, 16)" end="(550, 17)" leading="" trailing="" raw_val="i" val="i"/>
                                    <AtomNode start="(550, 17)" end="(550, 18)" leading="" trailing="" val="]"/>
                                    <GroupNode/>
                                    <AtomNode start="(550, 18)" end="(550, 19)" leading="" trailing="" val="?"/>
                                  </OtherNode>
                                  <AtomNode start="(550, 19)" end="(550, 20)" leading="" trailing="" val="."/>
                                  <IdentNode start="(550, 20)" end="(550, 23)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </OtherNode>
                                <NullNode start="(550, 24)" end="(550, 46)">
                                  <OtherNode start="(550, 24)" end="(550, 46)" kind="Lean.Parser.Term.fun">
                                    <AtomNode start="(550, 24)" end="(550, 27)" leading="" trailing=" " val="fun"/>
                                    <OtherNode start="(550, 28)" end="(550, 46)" kind="Lean.Parser.Term.basicFun">
                                      <NullNode start="(550, 28)" end="(550, 30)">
                                        <IdentNode start="(550, 28)" end="(550, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                      </NullNode>
                                      <NullNode/>
                                      <AtomNode start="(550, 31)" end="(550, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <OtherNode start="(550, 34)" end="(550, 46)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(550, 34)" end="(550, 44)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                                        <NullNode start="(550, 45)" end="(550, 46)">
                                          <IdentNode start="(550, 45)" end="(550, 46)" leading="" trailing="" raw_val="p" val="p"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(550, 46)" end="(550, 47)" leading="" trailing="" val=")"/>
                            </OtherNode>
                            <AtomNode start="(550, 47)" end="(550, 48)" leading="" trailing="" val="."/>
                            <IdentNode start="(550, 48)" end="(550, 52)" leading="" trailing=" " raw_val="getD" val="getD" full_name="Option.getD" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </OtherNode>
                          <NullNode start="(550, 53)" end="(550, 54)">
                            <OtherNode start="(550, 53)" end="(550, 54)" kind="num">
                              <AtomNode start="(550, 53)" end="(550, 54)" leading="" trailing=" " val="0"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(550, 55)" end="(552, 50)">
          <AtomNode start="(550, 55)" end="(550, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(550, 58)" end="(552, 50)">
            <AtomNode start="(550, 58)" end="(550, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(551, 3)" end="(552, 50)">
              <TacticTacticseq1IndentedNode start="(551, 3)" end="(552, 50)">
                <NullNode start="(551, 3)" end="(552, 50)">
                  <OtherNode start="(551, 3)" end="(551, 35)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xss : Array (Array α)&#10;p : α → Bool&#10;⊢ findIdx? p xss.flatten =&#10;    Option.map (fun i =&amp;gt; (map size (xss.take i)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) xss[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) xss)" state_after="case of&#10;α : Type u_1&#10;p : α → Bool&#10;xss✝ : List (List α)&#10;⊢ findIdx? p (List.map List.toArray xss✝).toArray.flatten =&#10;    Option.map&#10;      (fun i =&amp;gt;&#10;        (map size ((List.map List.toArray xss✝).toArray.take i)).sum +&#10;          (Option.map (fun xs =&amp;gt; findIdx p xs) (List.map List.toArray xss✝).toArray[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) (List.map List.toArray xss✝).toArray)" tactic="cases xss using array₂_induction">
                    <AtomNode start="(551, 3)" end="(551, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(551, 9)" end="(551, 12)">
                      <OtherNode start="(551, 9)" end="(551, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(551, 9)" end="(551, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(551, 13)" end="(551, 35)">
                      <AtomNode start="(551, 13)" end="(551, 18)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(551, 19)" end="(551, 35)" leading="" trailing="&#10;  " raw_val="array₂_induction" val="array₂_induction" full_name="Array.array₂_induction" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(552, 3)" end="(552, 50)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;p : α → Bool&#10;xss✝ : List (List α)&#10;⊢ findIdx? p (List.map List.toArray xss✝).toArray.flatten =&#10;    Option.map&#10;      (fun i =&amp;gt;&#10;        (map size ((List.map List.toArray xss✝).toArray.take i)).sum +&#10;          (Option.map (fun xs =&amp;gt; findIdx p xs) (List.map List.toArray xss✝).toArray[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) (List.map List.toArray xss✝).toArray)" state_after="no goals" tactic="simp [List.findIdx?_flatten, Function.comp_def]">
                    <AtomNode start="(552, 3)" end="(552, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(552, 8)" end="(552, 50)">
                      <AtomNode start="(552, 8)" end="(552, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(552, 9)" end="(552, 49)">
                        <OtherNode start="(552, 9)" end="(552, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(552, 9)" end="(552, 30)" leading="" trailing="" raw_val="List.findIdx?_flatten" val="List.findIdx?_flatten" full_name="List.findIdx?_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(552, 30)" end="(552, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(552, 32)" end="(552, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(552, 32)" end="(552, 49)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(552, 49)" end="(552, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(554, 1)" end="(558, 7)" name="findIdx?_replicate" full_name="Array.findIdx?_replicate">
      <CommandDeclmodifiersNode start="(554, 1)" end="(554, 8)">
        <NullNode/>
        <NullNode start="(554, 1)" end="(554, 8)">
          <OtherNode start="(554, 1)" end="(554, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(554, 1)" end="(554, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(554, 3)" end="(554, 7)">
              <OtherNode start="(554, 3)" end="(554, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(554, 3)" end="(554, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(554, 3)" end="(554, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(554, 7)" end="(554, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(554, 9)" end="(558, 7)" name="findIdx?_replicate" full_name="Array.findIdx?_replicate" _is_private_decl="False">
        <AtomNode start="(554, 9)" end="(554, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(554, 17)" end="(554, 35)">
          <IdentNode start="(554, 17)" end="(554, 35)" leading="" trailing=" " raw_val="findIdx?_replicate" val="findIdx?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(554, 36)" end="(555, 70)">
          <NullNode/>
          <TermTypespecNode start="(554, 36)" end="(555, 70)">
            <AtomNode start="(554, 36)" end="(554, 37)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(555, 5)" end="(555, 70)" kind="«term_=_»">
              <OtherNode start="(555, 5)" end="(555, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(555, 5)" end="(555, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(555, 5)" end="(555, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(555, 5)" end="(555, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(555, 6)" end="(555, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(555, 6)" end="(555, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(555, 16)" end="(555, 19)">
                        <IdentNode start="(555, 16)" end="(555, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(555, 18)" end="(555, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(555, 19)" end="(555, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(555, 20)" end="(555, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(555, 21)" end="(555, 29)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="Array.findIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(555, 30)" end="(555, 31)">
                  <IdentNode start="(555, 30)" end="(555, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(555, 32)" end="(555, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(555, 34)" end="(555, 70)" kind="termIfThenElse">
                <AtomNode start="(555, 34)" end="(555, 36)" leading="" trailing=" " val="if"/>
                <OtherNode start="(555, 37)" end="(555, 48)" kind="«term_∧_»">
                  <OtherNode start="(555, 37)" end="(555, 42)" kind="«term_&amp;lt;_»">
                    <OtherNode start="(555, 37)" end="(555, 38)" kind="num">
                      <AtomNode start="(555, 37)" end="(555, 38)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                    <AtomNode start="(555, 39)" end="(555, 40)" leading="" trailing=" " val="&amp;lt;"/>
                    <IdentNode start="(555, 41)" end="(555, 42)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(555, 43)" end="(555, 44)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(555, 45)" end="(555, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(555, 45)" end="(555, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(555, 47)" end="(555, 48)">
                      <IdentNode start="(555, 47)" end="(555, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(555, 49)" end="(555, 53)" leading="" trailing=" " val="then"/>
                <OtherNode start="(555, 54)" end="(555, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(555, 54)" end="(555, 58)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(555, 59)" end="(555, 60)">
                    <OtherNode start="(555, 59)" end="(555, 60)" kind="num">
                      <AtomNode start="(555, 59)" end="(555, 60)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(555, 61)" end="(555, 65)" leading="" trailing=" " val="else"/>
                <IdentNode start="(555, 66)" end="(555, 70)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(555, 71)" end="(558, 7)">
          <AtomNode start="(555, 71)" end="(555, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(555, 74)" end="(558, 7)">
            <AtomNode start="(555, 74)" end="(555, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(556, 3)" end="(558, 7)">
              <TacticTacticseq1IndentedNode start="(556, 3)" end="(558, 7)">
                <NullNode start="(556, 3)" end="(558, 7)">
                  <OtherNode start="(556, 3)" end="(556, 32)" kind="Lean.Parser.Tactic.rwSeq" state_before="n : Nat&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;⊢ findIdx? p (replicate n a) = if 0 &amp;lt; n ∧ p a = true then some 0 else none" state_after="n : Nat&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;⊢ findIdx? p (List.replicate n a).toArray = if 0 &amp;lt; n ∧ p a = true then some 0 else none" tactic="rw [← List.toArray_replicate]">
                    <AtomNode start="(556, 3)" end="(556, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(556, 6)" end="(556, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(556, 6)" end="(556, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(556, 7)" end="(556, 31)">
                        <OtherNode start="(556, 7)" end="(556, 31)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(556, 7)" end="(556, 8)">
                            <OtherNode start="(556, 7)" end="(556, 8)" kind="patternIgnore">
                              <OtherNode start="(556, 7)" end="(556, 8)" kind="token.«← »">
                                <AtomNode start="(556, 7)" end="(556, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(556, 9)" end="(556, 31)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(556, 31)" end="(556, 32)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(557, 3)" end="(557, 36)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;⊢ findIdx? p (List.replicate n a).toArray = if 0 &amp;lt; n ∧ p a = true then some 0 else none" state_after="n : Nat&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;⊢ List.findIdx? p (List.replicate n a) = if 0 &amp;lt; n ∧ p a = true then some 0 else none" tactic="simp only [List.findIdx?_toArray]">
                    <AtomNode start="(557, 3)" end="(557, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(557, 8)" end="(557, 12)">
                      <AtomNode start="(557, 8)" end="(557, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(557, 13)" end="(557, 36)">
                      <AtomNode start="(557, 13)" end="(557, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(557, 14)" end="(557, 35)">
                        <OtherNode start="(557, 14)" end="(557, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(557, 14)" end="(557, 35)" leading="" trailing="" raw_val="List.findIdx?_toArray" val="List.findIdx?_toArray" full_name="List.findIdx?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(557, 35)" end="(557, 36)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(558, 3)" end="(558, 7)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;⊢ List.findIdx? p (List.replicate n a) = if 0 &amp;lt; n ∧ p a = true then some 0 else none" state_after="no goals" tactic="simp">
                    <AtomNode start="(558, 3)" end="(558, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(560, 1)" end="(561, 47)" name="findIdx?_mkArray" full_name="Array.findIdx?_mkArray">
      <CommandDeclmodifiersNode start="(560, 1)" end="(560, 57)">
        <NullNode/>
        <NullNode start="(560, 1)" end="(560, 57)">
          <OtherNode start="(560, 1)" end="(560, 57)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(560, 1)" end="(560, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(560, 3)" end="(560, 56)">
              <OtherNode start="(560, 3)" end="(560, 56)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(560, 3)" end="(560, 56)" kind="Lean.deprecated">
                  <AtomNode start="(560, 3)" end="(560, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(560, 14)" end="(560, 32)">
                    <IdentNode start="(560, 14)" end="(560, 32)" leading="" trailing=" " raw_val="findIdx?_replicate" val="findIdx?_replicate" full_name="Array.findIdx?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(554, 17)" def_end="(554, 35)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(560, 33)" end="(560, 56)">
                    <AtomNode start="(560, 33)" end="(560, 34)" leading="" trailing="" val="("/>
                    <AtomNode start="(560, 34)" end="(560, 39)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(560, 40)" end="(560, 42)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(560, 43)" end="(560, 55)" kind="str">
                      <AtomNode start="(560, 43)" end="(560, 55)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(560, 55)" end="(560, 56)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(560, 56)" end="(560, 57)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(561, 1)" end="(561, 47)" name="findIdx?_mkArray">
        <AtomNode start="(561, 1)" end="(561, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(561, 8)" end="(561, 24)">
          <IdentNode start="(561, 8)" end="(561, 24)" leading="" trailing=" " raw_val="findIdx?_mkArray" val="findIdx?_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(561, 25)" end="(561, 47)">
          <AtomNode start="(561, 25)" end="(561, 27)" leading="" trailing=" " val=":="/>
          <OtherNode start="(561, 28)" end="(561, 47)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(561, 28)" end="(561, 29)" leading="" trailing="" val="@"/>
            <IdentNode start="(561, 29)" end="(561, 47)" leading="" trailing="&#10;&#10;" raw_val="findIdx?_replicate" val="findIdx?_replicate" full_name="Array.findIdx?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(554, 17)" def_end="(554, 35)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(563, 1)" end="(566, 43)" name="findIdx?_eq_findSome?_zipIdx" full_name="Array.findIdx?_eq_findSome?_zipIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(563, 1)" end="(566, 43)" name="findIdx?_eq_findSome?_zipIdx" full_name="Array.findIdx?_eq_findSome?_zipIdx" _is_private_decl="False">
        <AtomNode start="(563, 1)" end="(563, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(563, 9)" end="(563, 37)">
          <IdentNode start="(563, 9)" end="(563, 37)" leading="" trailing=" " raw_val="findIdx?_eq_findSome?_zipIdx" val="findIdx?_eq_findSome?_zipIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(563, 38)" end="(564, 83)">
          <NullNode start="(563, 38)" end="(563, 67)">
            <OtherNode start="(563, 38)" end="(563, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(563, 38)" end="(563, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(563, 39)" end="(563, 41)">
                <IdentNode start="(563, 39)" end="(563, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(563, 42)" end="(563, 51)">
                <AtomNode start="(563, 42)" end="(563, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(563, 44)" end="(563, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(563, 44)" end="(563, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(563, 50)" end="(563, 51)">
                    <IdentNode start="(563, 50)" end="(563, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(563, 51)" end="(563, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(563, 53)" end="(563, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(563, 53)" end="(563, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(563, 54)" end="(563, 55)">
                <IdentNode start="(563, 54)" end="(563, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(563, 56)" end="(563, 66)">
                <AtomNode start="(563, 56)" end="(563, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(563, 58)" end="(563, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(563, 58)" end="(563, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(563, 60)" end="(563, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(563, 62)" end="(563, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(563, 66)" end="(563, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(563, 68)" end="(564, 83)">
            <AtomNode start="(563, 68)" end="(563, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(564, 5)" end="(564, 83)" kind="«term_=_»">
              <OtherNode start="(564, 5)" end="(564, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(564, 5)" end="(564, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(564, 17)" end="(564, 18)">
                  <IdentNode start="(564, 17)" end="(564, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(564, 19)" end="(564, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(564, 21)" end="(564, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(564, 21)" end="(564, 40)" leading="" trailing=" " raw_val="xs.zipIdx.findSome?" val="xs.zipIdx.findSome?"/>
                <NullNode start="(564, 41)" end="(564, 83)">
                  <OtherNode start="(564, 41)" end="(564, 83)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(564, 41)" end="(564, 44)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(564, 45)" end="(564, 83)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(564, 45)" end="(564, 51)">
                        <OtherNode start="(564, 45)" end="(564, 51)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(564, 45)" end="(564, 46)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(564, 46)" end="(564, 50)">
                            <IdentNode start="(564, 46)" end="(564, 47)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(564, 47)" end="(564, 48)" leading="" trailing=" " val=","/>
                            <IdentNode start="(564, 49)" end="(564, 50)" leading="" trailing="" raw_val="i" val="i"/>
                          </NullNode>
                          <AtomNode start="(564, 50)" end="(564, 51)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(564, 52)" end="(564, 54)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(564, 55)" end="(564, 83)" kind="termIfThenElse">
                        <AtomNode start="(564, 55)" end="(564, 57)" leading="" trailing=" " val="if"/>
                        <OtherNode start="(564, 58)" end="(564, 61)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(564, 58)" end="(564, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(564, 60)" end="(564, 61)">
                            <IdentNode start="(564, 60)" end="(564, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(564, 62)" end="(564, 66)" leading="" trailing=" " val="then"/>
                        <OtherNode start="(564, 67)" end="(564, 73)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(564, 67)" end="(564, 71)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(564, 72)" end="(564, 73)">
                            <IdentNode start="(564, 72)" end="(564, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(564, 74)" end="(564, 78)" leading="" trailing=" " val="else"/>
                        <IdentNode start="(564, 79)" end="(564, 83)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(564, 84)" end="(566, 43)">
          <AtomNode start="(564, 84)" end="(564, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(564, 87)" end="(566, 43)">
            <AtomNode start="(564, 87)" end="(564, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(565, 3)" end="(566, 43)">
              <TacticTacticseq1IndentedNode start="(565, 3)" end="(566, 43)">
                <NullNode start="(565, 3)" end="(566, 43)">
                  <OtherNode start="(565, 3)" end="(565, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      { toList := xs }.zipIdx" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(565, 3)" end="(565, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(565, 10)" end="(565, 12)">
                      <OtherNode start="(565, 10)" end="(565, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(565, 10)" end="(565, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(565, 13)" end="(565, 22)">
                      <AtomNode start="(565, 13)" end="(565, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(565, 18)" end="(565, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(565, 18)" end="(565, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(565, 18)" end="(565, 22)">
                            <OtherNode start="(565, 18)" end="(565, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(565, 18)" end="(565, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(565, 19)" end="(565, 21)">
                                <OtherNode start="(565, 19)" end="(565, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(565, 19)" end="(565, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(565, 19)" end="(565, 21)">
                                      <OtherNode start="(565, 19)" end="(565, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(565, 19)" end="(565, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(565, 21)" end="(565, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(566, 3)" end="(566, 43)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      { toList := xs }.zipIdx" state_after="no goals" tactic="simp [List.findIdx?_eq_findSome?_zipIdx]">
                    <AtomNode start="(566, 3)" end="(566, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(566, 8)" end="(566, 43)">
                      <AtomNode start="(566, 8)" end="(566, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(566, 9)" end="(566, 42)">
                        <OtherNode start="(566, 9)" end="(566, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(566, 9)" end="(566, 42)" leading="" trailing="" raw_val="List.findIdx?_eq_findSome?_zipIdx" val="List.findIdx?_eq_findSome?_zipIdx" full_name="List.findIdx?_eq_findSome?_zipIdx" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(566, 42)" end="(566, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(568, 1)" end="(571, 43)" name="findIdx?_eq_fst_find?_zipIdx" full_name="Array.findIdx?_eq_fst_find?_zipIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(568, 1)" end="(571, 43)" name="findIdx?_eq_fst_find?_zipIdx" full_name="Array.findIdx?_eq_fst_find?_zipIdx" _is_private_decl="False">
        <AtomNode start="(568, 1)" end="(568, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(568, 9)" end="(568, 37)">
          <IdentNode start="(568, 9)" end="(568, 37)" leading="" trailing=" " raw_val="findIdx?_eq_fst_find?_zipIdx" val="findIdx?_eq_fst_find?_zipIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(568, 38)" end="(569, 66)">
          <NullNode start="(568, 38)" end="(568, 67)">
            <OtherNode start="(568, 38)" end="(568, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(568, 38)" end="(568, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(568, 39)" end="(568, 41)">
                <IdentNode start="(568, 39)" end="(568, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(568, 42)" end="(568, 51)">
                <AtomNode start="(568, 42)" end="(568, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(568, 44)" end="(568, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(568, 44)" end="(568, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(568, 50)" end="(568, 51)">
                    <IdentNode start="(568, 50)" end="(568, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(568, 51)" end="(568, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(568, 53)" end="(568, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(568, 53)" end="(568, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(568, 54)" end="(568, 55)">
                <IdentNode start="(568, 54)" end="(568, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(568, 56)" end="(568, 66)">
                <AtomNode start="(568, 56)" end="(568, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(568, 58)" end="(568, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(568, 58)" end="(568, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(568, 60)" end="(568, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(568, 62)" end="(568, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(568, 66)" end="(568, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(568, 68)" end="(569, 66)">
            <AtomNode start="(568, 68)" end="(568, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(569, 5)" end="(569, 66)" kind="«term_=_»">
              <OtherNode start="(569, 5)" end="(569, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(569, 5)" end="(569, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(569, 17)" end="(569, 18)">
                  <IdentNode start="(569, 17)" end="(569, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(569, 19)" end="(569, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(569, 21)" end="(569, 66)" kind="Lean.Parser.Term.app">
                <OtherNode start="(569, 21)" end="(569, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(569, 21)" end="(569, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(569, 21)" end="(569, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(569, 22)" end="(569, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(569, 22)" end="(569, 37)" leading="" trailing=" " raw_val="xs.zipIdx.find?" val="xs.zipIdx.find?"/>
                      <NullNode start="(569, 38)" end="(569, 55)">
                        <OtherNode start="(569, 38)" end="(569, 55)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(569, 38)" end="(569, 41)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(569, 42)" end="(569, 55)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(569, 42)" end="(569, 48)">
                              <OtherNode start="(569, 42)" end="(569, 48)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(569, 42)" end="(569, 43)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(569, 43)" end="(569, 47)">
                                  <IdentNode start="(569, 43)" end="(569, 44)" leading="" trailing="" raw_val="x" val="x"/>
                                  <AtomNode start="(569, 44)" end="(569, 45)" leading="" trailing=" " val=","/>
                                  <TermHoleNode start="(569, 46)" end="(569, 47)">
                                    <AtomNode start="(569, 46)" end="(569, 47)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                                <AtomNode start="(569, 47)" end="(569, 48)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(569, 49)" end="(569, 51)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(569, 52)" end="(569, 55)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(569, 52)" end="(569, 53)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(569, 54)" end="(569, 55)">
                                <IdentNode start="(569, 54)" end="(569, 55)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(569, 55)" end="(569, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(569, 56)" end="(569, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(569, 57)" end="(569, 60)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(569, 61)" end="(569, 66)">
                  <OtherNode start="(569, 61)" end="(569, 66)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(569, 61)" end="(569, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(569, 62)" end="(569, 65)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(569, 62)" end="(569, 63)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(569, 62)" end="(569, 63)" leading="" trailing="" val="·"/>
                      </OtherNode>
                      <AtomNode start="(569, 63)" end="(569, 64)" leading="" trailing="" val="."/>
                      <OtherNode start="(569, 64)" end="(569, 65)" kind="fieldIdx">
                        <AtomNode start="(569, 64)" end="(569, 65)" leading="" trailing="" val="2"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(569, 65)" end="(569, 66)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(569, 67)" end="(571, 43)">
          <AtomNode start="(569, 67)" end="(569, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(569, 70)" end="(571, 43)">
            <AtomNode start="(569, 70)" end="(569, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(570, 3)" end="(571, 43)">
              <TacticTacticseq1IndentedNode start="(570, 3)" end="(571, 43)">
                <NullNode start="(570, 3)" end="(571, 43)">
                  <OtherNode start="(570, 3)" end="(570, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        { toList := xs }.zipIdx)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(570, 3)" end="(570, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(570, 10)" end="(570, 12)">
                      <OtherNode start="(570, 10)" end="(570, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(570, 10)" end="(570, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(570, 13)" end="(570, 22)">
                      <AtomNode start="(570, 13)" end="(570, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(570, 18)" end="(570, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(570, 18)" end="(570, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(570, 18)" end="(570, 22)">
                            <OtherNode start="(570, 18)" end="(570, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(570, 18)" end="(570, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(570, 19)" end="(570, 21)">
                                <OtherNode start="(570, 19)" end="(570, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(570, 19)" end="(570, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(570, 19)" end="(570, 21)">
                                      <OtherNode start="(570, 19)" end="(570, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(570, 19)" end="(570, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(570, 21)" end="(570, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(571, 3)" end="(571, 43)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx? p { toList := xs } =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        { toList := xs }.zipIdx)" state_after="no goals" tactic="simp [List.findIdx?_eq_fst_find?_zipIdx]">
                    <AtomNode start="(571, 3)" end="(571, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(571, 8)" end="(571, 43)">
                      <AtomNode start="(571, 8)" end="(571, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(571, 9)" end="(571, 42)">
                        <OtherNode start="(571, 9)" end="(571, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(571, 9)" end="(571, 42)" leading="" trailing="" raw_val="List.findIdx?_eq_fst_find?_zipIdx" val="List.findIdx?_eq_fst_find?_zipIdx" full_name="List.findIdx?_eq_fst_find?_zipIdx" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(571, 42)" end="(571, 43)" leading="" trailing="&#10;&#10;-- See also `findIdx_le_findIdx`.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(574, 1)" end="(577, 75)" name="findIdx?_eq_none_of_findIdx?_eq_none" full_name="Array.findIdx?_eq_none_of_findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(574, 1)" end="(577, 75)" name="findIdx?_eq_none_of_findIdx?_eq_none" full_name="Array.findIdx?_eq_none_of_findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(574, 1)" end="(574, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(574, 9)" end="(574, 45)">
          <IdentNode start="(574, 9)" end="(574, 45)" leading="" trailing=" " raw_val="findIdx?_eq_none_of_findIdx?_eq_none" val="findIdx?_eq_none_of_findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(574, 46)" end="(575, 48)">
          <NullNode start="(574, 46)" end="(574, 103)">
            <OtherNode start="(574, 46)" end="(574, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(574, 46)" end="(574, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(574, 47)" end="(574, 49)">
                <IdentNode start="(574, 47)" end="(574, 49)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(574, 50)" end="(574, 59)">
                <AtomNode start="(574, 50)" end="(574, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(574, 52)" end="(574, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(574, 52)" end="(574, 57)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(574, 58)" end="(574, 59)">
                    <IdentNode start="(574, 58)" end="(574, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(574, 59)" end="(574, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(574, 61)" end="(574, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(574, 61)" end="(574, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(574, 62)" end="(574, 65)">
                <IdentNode start="(574, 62)" end="(574, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(574, 64)" end="(574, 65)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(574, 66)" end="(574, 76)">
                <AtomNode start="(574, 66)" end="(574, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(574, 68)" end="(574, 76)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(574, 68)" end="(574, 69)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(574, 70)" end="(574, 71)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(574, 72)" end="(574, 76)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(574, 76)" end="(574, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(574, 78)" end="(574, 103)">
              <AtomNode start="(574, 78)" end="(574, 79)" leading="" trailing="" val="("/>
              <NullNode start="(574, 79)" end="(574, 80)">
                <IdentNode start="(574, 79)" end="(574, 80)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(574, 81)" end="(574, 102)">
                <AtomNode start="(574, 81)" end="(574, 82)" leading="" trailing=" " val=":"/>
                <OtherNode start="(574, 83)" end="(574, 102)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(574, 83)" end="(574, 84)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(574, 85)" end="(574, 86)">
                    <IdentNode start="(574, 85)" end="(574, 86)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(574, 87)" end="(574, 91)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(574, 87)" end="(574, 88)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(574, 89)" end="(574, 91)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(574, 91)" end="(574, 92)" leading="" trailing=" " val=","/>
                  <OtherNode start="(574, 93)" end="(574, 102)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(574, 93)" end="(574, 96)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(574, 93)" end="(574, 94)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(574, 95)" end="(574, 96)">
                        <IdentNode start="(574, 95)" end="(574, 96)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(574, 97)" end="(574, 98)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(574, 99)" end="(574, 102)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(574, 99)" end="(574, 100)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(574, 101)" end="(574, 102)">
                        <IdentNode start="(574, 101)" end="(574, 102)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(574, 102)" end="(574, 103)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(574, 104)" end="(575, 48)">
            <AtomNode start="(574, 104)" end="(574, 105)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(575, 5)" end="(575, 48)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(575, 5)" end="(575, 25)" kind="«term_=_»">
                <OtherNode start="(575, 5)" end="(575, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(575, 5)" end="(575, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(575, 17)" end="(575, 18)">
                    <IdentNode start="(575, 17)" end="(575, 18)" leading="" trailing=" " raw_val="q" val="q"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(575, 19)" end="(575, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(575, 21)" end="(575, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(575, 26)" end="(575, 27)" leading="" trailing=" " val="→"/>
              <OtherNode start="(575, 28)" end="(575, 48)" kind="«term_=_»">
                <OtherNode start="(575, 28)" end="(575, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(575, 28)" end="(575, 39)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(575, 40)" end="(575, 41)">
                    <IdentNode start="(575, 40)" end="(575, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(575, 42)" end="(575, 43)" leading="" trailing=" " val="="/>
                <IdentNode start="(575, 44)" end="(575, 48)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(575, 49)" end="(577, 75)">
          <AtomNode start="(575, 49)" end="(575, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(575, 52)" end="(577, 75)">
            <AtomNode start="(575, 52)" end="(575, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(576, 3)" end="(577, 75)">
              <TacticTacticseq1IndentedNode start="(576, 3)" end="(577, 75)">
                <NullNode start="(576, 3)" end="(577, 75)">
                  <OtherNode start="(576, 3)" end="(576, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;⊢ findIdx? q xs = none → findIdx? p xs = none" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;w : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;⊢ findIdx? q { toList := xs } = none → findIdx? p { toList := xs } = none" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(576, 3)" end="(576, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(576, 10)" end="(576, 12)">
                      <OtherNode start="(576, 10)" end="(576, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(576, 10)" end="(576, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(576, 13)" end="(576, 22)">
                      <AtomNode start="(576, 13)" end="(576, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(576, 18)" end="(576, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(576, 18)" end="(576, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(576, 18)" end="(576, 22)">
                            <OtherNode start="(576, 18)" end="(576, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(576, 18)" end="(576, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(576, 19)" end="(576, 21)">
                                <OtherNode start="(576, 19)" end="(576, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(576, 19)" end="(576, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(576, 19)" end="(576, 21)">
                                      <OtherNode start="(576, 19)" end="(576, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(576, 19)" end="(576, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(576, 21)" end="(576, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(577, 3)" end="(577, 75)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;w : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;⊢ findIdx? q { toList := xs } = none → findIdx? p { toList := xs } = none" state_after="no goals" tactic="simpa using List.findIdx?_eq_none_of_findIdx?_eq_none (by simpa using w)">
                    <AtomNode start="(577, 3)" end="(577, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(577, 9)" end="(577, 75)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(577, 9)" end="(577, 75)">
                        <AtomNode start="(577, 9)" end="(577, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(577, 15)" end="(577, 75)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(577, 15)" end="(577, 56)" leading="" trailing=" " raw_val="List.findIdx?_eq_none_of_findIdx?_eq_none" val="List.findIdx?_eq_none_of_findIdx?_eq_none" full_name="List.findIdx?_eq_none_of_findIdx?_eq_none" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                          <NullNode start="(577, 57)" end="(577, 75)">
                            <OtherNode start="(577, 57)" end="(577, 75)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(577, 57)" end="(577, 58)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(577, 58)" end="(577, 74)">
                                <AtomNode start="(577, 58)" end="(577, 60)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(577, 61)" end="(577, 74)">
                                  <TacticTacticseq1IndentedNode start="(577, 61)" end="(577, 74)">
                                    <NullNode start="(577, 61)" end="(577, 74)">
                                      <OtherNode start="(577, 61)" end="(577, 74)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;w : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;⊢ ∀ (x : α), x ∈ xs → p x = true → q x = true" state_after="no goals" tactic="simpa using w">
                                        <AtomNode start="(577, 61)" end="(577, 66)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(577, 67)" end="(577, 74)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(577, 67)" end="(577, 74)">
                                            <AtomNode start="(577, 67)" end="(577, 72)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(577, 73)" end="(577, 74)" leading="" trailing="" raw_val="w" val="w"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(577, 74)" end="(577, 75)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(579, 1)" end="(582, 39)" name="findIdx_eq_getD_findIdx?" full_name="Array.findIdx_eq_getD_findIdx?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(579, 1)" end="(582, 39)" name="findIdx_eq_getD_findIdx?" full_name="Array.findIdx_eq_getD_findIdx?" _is_private_decl="False">
        <AtomNode start="(579, 1)" end="(579, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(579, 9)" end="(579, 33)">
          <IdentNode start="(579, 9)" end="(579, 33)" leading="" trailing=" " raw_val="findIdx_eq_getD_findIdx?" val="findIdx_eq_getD_findIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(579, 34)" end="(580, 48)">
          <NullNode start="(579, 34)" end="(579, 63)">
            <OtherNode start="(579, 34)" end="(579, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(579, 34)" end="(579, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(579, 35)" end="(579, 37)">
                <IdentNode start="(579, 35)" end="(579, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(579, 38)" end="(579, 47)">
                <AtomNode start="(579, 38)" end="(579, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(579, 40)" end="(579, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(579, 40)" end="(579, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(579, 46)" end="(579, 47)">
                    <IdentNode start="(579, 46)" end="(579, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(579, 47)" end="(579, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(579, 49)" end="(579, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(579, 49)" end="(579, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(579, 50)" end="(579, 51)">
                <IdentNode start="(579, 50)" end="(579, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(579, 52)" end="(579, 62)">
                <AtomNode start="(579, 52)" end="(579, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(579, 54)" end="(579, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(579, 54)" end="(579, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(579, 56)" end="(579, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(579, 58)" end="(579, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(579, 62)" end="(579, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(579, 64)" end="(580, 48)">
            <AtomNode start="(579, 64)" end="(579, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(580, 5)" end="(580, 48)" kind="«term_=_»">
              <OtherNode start="(580, 5)" end="(580, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(580, 5)" end="(580, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(580, 16)" end="(580, 17)">
                  <IdentNode start="(580, 16)" end="(580, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(580, 18)" end="(580, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(580, 20)" end="(580, 48)" kind="Lean.Parser.Term.app">
                <OtherNode start="(580, 20)" end="(580, 40)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(580, 20)" end="(580, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(580, 20)" end="(580, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(580, 21)" end="(580, 34)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(580, 21)" end="(580, 32)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(580, 33)" end="(580, 34)">
                        <IdentNode start="(580, 33)" end="(580, 34)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(580, 34)" end="(580, 35)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(580, 35)" end="(580, 36)" leading="" trailing="" val="."/>
                  <IdentNode start="(580, 36)" end="(580, 40)" leading="" trailing=" " raw_val="getD" val="getD" full_name="Option.getD" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(580, 41)" end="(580, 48)">
                  <IdentNode start="(580, 41)" end="(580, 48)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(580, 49)" end="(582, 39)">
          <AtomNode start="(580, 49)" end="(580, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(580, 52)" end="(582, 39)">
            <AtomNode start="(580, 52)" end="(580, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(581, 3)" end="(582, 39)">
              <TacticTacticseq1IndentedNode start="(581, 3)" end="(582, 39)">
                <NullNode start="(581, 3)" end="(582, 39)">
                  <OtherNode start="(581, 3)" end="(581, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findIdx p xs = (findIdx? p xs).getD xs.size" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p { toList := xs } = (findIdx? p { toList := xs }).getD { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(581, 3)" end="(581, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(581, 10)" end="(581, 12)">
                      <OtherNode start="(581, 10)" end="(581, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(581, 10)" end="(581, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(581, 13)" end="(581, 22)">
                      <AtomNode start="(581, 13)" end="(581, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(581, 18)" end="(581, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(581, 18)" end="(581, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(581, 18)" end="(581, 22)">
                            <OtherNode start="(581, 18)" end="(581, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(581, 18)" end="(581, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(581, 19)" end="(581, 21)">
                                <OtherNode start="(581, 19)" end="(581, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(581, 19)" end="(581, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(581, 19)" end="(581, 21)">
                                      <OtherNode start="(581, 19)" end="(581, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(581, 19)" end="(581, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(581, 21)" end="(581, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(582, 3)" end="(582, 39)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p { toList := xs } = (findIdx? p { toList := xs }).getD { toList := xs }.size" state_after="no goals" tactic="simp [List.findIdx_eq_getD_findIdx?]">
                    <AtomNode start="(582, 3)" end="(582, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(582, 8)" end="(582, 39)">
                      <AtomNode start="(582, 8)" end="(582, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(582, 9)" end="(582, 38)">
                        <OtherNode start="(582, 9)" end="(582, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(582, 9)" end="(582, 38)" leading="" trailing="" raw_val="List.findIdx_eq_getD_findIdx?" val="List.findIdx_eq_getD_findIdx?" full_name="List.findIdx_eq_getD_findIdx?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(582, 38)" end="(582, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(584, 1)" end="(587, 92)" name="findIdx?_eq_some_le_of_findIdx?_eq_some" full_name="Array.findIdx?_eq_some_le_of_findIdx?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(584, 1)" end="(587, 92)" name="findIdx?_eq_some_le_of_findIdx?_eq_some" full_name="Array.findIdx?_eq_some_le_of_findIdx?_eq_some" _is_private_decl="False">
        <AtomNode start="(584, 1)" end="(584, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(584, 9)" end="(584, 48)">
          <IdentNode start="(584, 9)" end="(584, 48)" leading="" trailing=" " raw_val="findIdx?_eq_some_le_of_findIdx?_eq_some" val="findIdx?_eq_some_le_of_findIdx?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(584, 49)" end="(585, 71)">
          <NullNode start="(584, 49)" end="(585, 33)">
            <OtherNode start="(584, 49)" end="(584, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(584, 49)" end="(584, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(584, 50)" end="(584, 52)">
                <IdentNode start="(584, 50)" end="(584, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(584, 53)" end="(584, 62)">
                <AtomNode start="(584, 53)" end="(584, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(584, 55)" end="(584, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(584, 55)" end="(584, 60)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(584, 61)" end="(584, 62)">
                    <IdentNode start="(584, 61)" end="(584, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(584, 62)" end="(584, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(584, 64)" end="(584, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(584, 64)" end="(584, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(584, 65)" end="(584, 68)">
                <IdentNode start="(584, 65)" end="(584, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(584, 67)" end="(584, 68)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(584, 69)" end="(584, 79)">
                <AtomNode start="(584, 69)" end="(584, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(584, 71)" end="(584, 79)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(584, 71)" end="(584, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(584, 73)" end="(584, 74)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(584, 75)" end="(584, 79)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(584, 79)" end="(584, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(584, 81)" end="(584, 106)">
              <AtomNode start="(584, 81)" end="(584, 82)" leading="" trailing="" val="("/>
              <NullNode start="(584, 82)" end="(584, 83)">
                <IdentNode start="(584, 82)" end="(584, 83)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(584, 84)" end="(584, 105)">
                <AtomNode start="(584, 84)" end="(584, 85)" leading="" trailing=" " val=":"/>
                <OtherNode start="(584, 86)" end="(584, 105)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(584, 86)" end="(584, 87)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(584, 88)" end="(584, 89)">
                    <IdentNode start="(584, 88)" end="(584, 89)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(584, 90)" end="(584, 94)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(584, 90)" end="(584, 91)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(584, 92)" end="(584, 94)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(584, 94)" end="(584, 95)" leading="" trailing=" " val=","/>
                  <OtherNode start="(584, 96)" end="(584, 105)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(584, 96)" end="(584, 99)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(584, 96)" end="(584, 97)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(584, 98)" end="(584, 99)">
                        <IdentNode start="(584, 98)" end="(584, 99)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(584, 100)" end="(584, 101)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(584, 102)" end="(584, 105)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(584, 102)" end="(584, 103)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(584, 104)" end="(584, 105)">
                        <IdentNode start="(584, 104)" end="(584, 105)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(584, 105)" end="(584, 106)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(584, 107)" end="(584, 116)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(584, 107)" end="(584, 108)" leading="" trailing="" val="{"/>
              <NullNode start="(584, 108)" end="(584, 109)">
                <IdentNode start="(584, 108)" end="(584, 109)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(584, 110)" end="(584, 115)">
                <AtomNode start="(584, 110)" end="(584, 111)" leading="" trailing=" " val=":"/>
                <IdentNode start="(584, 112)" end="(584, 115)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(584, 115)" end="(584, 116)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(585, 5)" end="(585, 33)">
              <AtomNode start="(585, 5)" end="(585, 6)" leading="" trailing="" val="("/>
              <NullNode start="(585, 6)" end="(585, 7)">
                <IdentNode start="(585, 6)" end="(585, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(585, 8)" end="(585, 32)">
                <AtomNode start="(585, 8)" end="(585, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(585, 10)" end="(585, 32)" kind="«term_=_»">
                  <OtherNode start="(585, 10)" end="(585, 23)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(585, 10)" end="(585, 21)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(585, 22)" end="(585, 23)">
                      <IdentNode start="(585, 22)" end="(585, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(585, 24)" end="(585, 25)" leading="" trailing=" " val="="/>
                  <OtherNode start="(585, 26)" end="(585, 32)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(585, 26)" end="(585, 30)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(585, 31)" end="(585, 32)">
                      <IdentNode start="(585, 31)" end="(585, 32)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(585, 32)" end="(585, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(585, 34)" end="(585, 71)">
            <AtomNode start="(585, 34)" end="(585, 35)" leading="" trailing=" " val=":"/>
            <OtherNode start="(585, 36)" end="(585, 71)" kind="«term∃_,_»">
              <AtomNode start="(585, 36)" end="(585, 37)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(585, 38)" end="(585, 39)" kind="Lean.explicitBinders">
                <OtherNode start="(585, 38)" end="(585, 39)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(585, 38)" end="(585, 39)">
                    <LeanBinderidentNode start="(585, 38)" end="(585, 39)">
                      <IdentNode start="(585, 38)" end="(585, 39)" leading="" trailing="" raw_val="j" val="j"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(585, 39)" end="(585, 40)" leading="" trailing=" " val=","/>
              <OtherNode start="(585, 41)" end="(585, 71)" kind="«term_∧_»">
                <OtherNode start="(585, 41)" end="(585, 46)" kind="«term_≤_»">
                  <IdentNode start="(585, 41)" end="(585, 42)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(585, 43)" end="(585, 44)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(585, 45)" end="(585, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(585, 47)" end="(585, 48)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(585, 49)" end="(585, 71)" kind="«term_=_»">
                  <OtherNode start="(585, 49)" end="(585, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(585, 49)" end="(585, 60)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(585, 61)" end="(585, 62)">
                      <IdentNode start="(585, 61)" end="(585, 62)" leading="" trailing=" " raw_val="q" val="q"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(585, 63)" end="(585, 64)" leading="" trailing=" " val="="/>
                  <OtherNode start="(585, 65)" end="(585, 71)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(585, 65)" end="(585, 69)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(585, 70)" end="(585, 71)">
                      <IdentNode start="(585, 70)" end="(585, 71)" leading="" trailing=" " raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(585, 72)" end="(587, 92)">
          <AtomNode start="(585, 72)" end="(585, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(585, 75)" end="(587, 92)">
            <AtomNode start="(585, 75)" end="(585, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(586, 3)" end="(587, 92)">
              <TacticTacticseq1IndentedNode start="(586, 3)" end="(587, 92)">
                <NullNode start="(586, 3)" end="(587, 92)">
                  <OtherNode start="(586, 3)" end="(586, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;i : Nat&#10;h : findIdx? p xs = some i&#10;⊢ ∃ j, j ≤ i ∧ findIdx? q xs = some j" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;i : Nat&#10;xs : List α&#10;w : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;h : findIdx? p { toList := xs } = some i&#10;⊢ ∃ j, j ≤ i ∧ findIdx? q { toList := xs } = some j" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(586, 3)" end="(586, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(586, 10)" end="(586, 12)">
                      <OtherNode start="(586, 10)" end="(586, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(586, 10)" end="(586, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(586, 13)" end="(586, 22)">
                      <AtomNode start="(586, 13)" end="(586, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(586, 18)" end="(586, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(586, 18)" end="(586, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(586, 18)" end="(586, 22)">
                            <OtherNode start="(586, 18)" end="(586, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(586, 18)" end="(586, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(586, 19)" end="(586, 21)">
                                <OtherNode start="(586, 19)" end="(586, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(586, 19)" end="(586, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(586, 19)" end="(586, 21)">
                                      <OtherNode start="(586, 19)" end="(586, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(586, 19)" end="(586, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(586, 21)" end="(586, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(587, 3)" end="(587, 92)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;i : Nat&#10;xs : List α&#10;w : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;h : findIdx? p { toList := xs } = some i&#10;⊢ ∃ j, j ≤ i ∧ findIdx? q { toList := xs } = some j" state_after="no goals" tactic="simp [List.findIdx?_eq_some_le_of_findIdx?_eq_some (by simpa using w) (by simpa using h)]">
                    <AtomNode start="(587, 3)" end="(587, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(587, 8)" end="(587, 92)">
                      <AtomNode start="(587, 8)" end="(587, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(587, 9)" end="(587, 91)">
                        <OtherNode start="(587, 9)" end="(587, 91)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(587, 9)" end="(587, 91)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(587, 9)" end="(587, 53)" leading="" trailing=" " raw_val="List.findIdx?_eq_some_le_of_findIdx?_eq_some" val="List.findIdx?_eq_some_le_of_findIdx?_eq_some" full_name="List.findIdx?_eq_some_le_of_findIdx?_eq_some" mod_name="Init.Data.List.Nat.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Find.lean"/>
                            <NullNode start="(587, 54)" end="(587, 91)">
                              <OtherNode start="(587, 54)" end="(587, 72)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(587, 54)" end="(587, 55)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(587, 55)" end="(587, 71)">
                                  <AtomNode start="(587, 55)" end="(587, 57)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(587, 58)" end="(587, 71)">
                                    <TacticTacticseq1IndentedNode start="(587, 58)" end="(587, 71)">
                                      <NullNode start="(587, 58)" end="(587, 71)">
                                        <OtherNode start="(587, 58)" end="(587, 71)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p q : α → Bool&#10;i : Nat&#10;xs : List α&#10;w : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;h : findIdx? p { toList := xs } = some i&#10;⊢ ∀ (x : ?m.101061), x ∈ ?m.101062 → ?m.101063 x = true → ?m.101064 x = true" state_after="no goals" tactic="simpa using w">
                                          <AtomNode start="(587, 58)" end="(587, 63)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(587, 64)" end="(587, 71)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(587, 64)" end="(587, 71)">
                                              <AtomNode start="(587, 64)" end="(587, 69)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(587, 70)" end="(587, 71)" leading="" trailing="" raw_val="w" val="w"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(587, 71)" end="(587, 72)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <OtherNode start="(587, 73)" end="(587, 91)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(587, 73)" end="(587, 74)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(587, 74)" end="(587, 90)">
                                  <AtomNode start="(587, 74)" end="(587, 76)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(587, 77)" end="(587, 90)">
                                    <TacticTacticseq1IndentedNode start="(587, 77)" end="(587, 90)">
                                      <NullNode start="(587, 77)" end="(587, 90)">
                                        <OtherNode start="(587, 77)" end="(587, 90)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p q : α → Bool&#10;i : Nat&#10;xs : List α&#10;w : ∀ (x : α), x ∈ { toList := xs } → p x = true → q x = true&#10;h : findIdx? p { toList := xs } = some i&#10;⊢ List.findIdx? p xs = some ?m.101066" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(587, 77)" end="(587, 82)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(587, 83)" end="(587, 90)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(587, 83)" end="(587, 90)">
                                              <AtomNode start="(587, 83)" end="(587, 88)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(587, 89)" end="(587, 90)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(587, 90)" end="(587, 91)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(587, 91)" end="(587, 92)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(589, 1)" end="(593, 12)" name="findIdx?_subtype" full_name="Array.findIdx?_subtype">
      <CommandDeclmodifiersNode start="(589, 1)" end="(589, 8)">
        <NullNode/>
        <NullNode start="(589, 1)" end="(589, 8)">
          <OtherNode start="(589, 1)" end="(589, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(589, 1)" end="(589, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(589, 3)" end="(589, 7)">
              <OtherNode start="(589, 3)" end="(589, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(589, 3)" end="(589, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(589, 3)" end="(589, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(589, 7)" end="(589, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(589, 9)" end="(593, 12)" name="findIdx?_subtype" full_name="Array.findIdx?_subtype" _is_private_decl="False">
        <AtomNode start="(589, 9)" end="(589, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(589, 17)" end="(589, 33)">
          <IdentNode start="(589, 17)" end="(589, 33)" leading="" trailing=" " raw_val="findIdx?_subtype" val="findIdx?_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(589, 34)" end="(591, 43)">
          <NullNode start="(589, 34)" end="(590, 74)">
            <OtherNode start="(589, 34)" end="(589, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(589, 34)" end="(589, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(589, 35)" end="(589, 36)">
                <IdentNode start="(589, 35)" end="(589, 36)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(589, 37)" end="(589, 47)">
                <AtomNode start="(589, 37)" end="(589, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(589, 39)" end="(589, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(589, 39)" end="(589, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(589, 41)" end="(589, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(589, 43)" end="(589, 47)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(589, 43)" end="(589, 47)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(589, 47)" end="(589, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(589, 49)" end="(589, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(589, 49)" end="(589, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(589, 50)" end="(589, 52)">
                <IdentNode start="(589, 50)" end="(589, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(589, 53)" end="(589, 73)">
                <AtomNode start="(589, 53)" end="(589, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(589, 55)" end="(589, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(589, 55)" end="(589, 60)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(589, 61)" end="(589, 73)">
                    <OtherNode start="(589, 61)" end="(589, 73)" kind="«term{_:_//_}»">
                      <AtomNode start="(589, 61)" end="(589, 62)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(589, 63)" end="(589, 64)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(589, 65)" end="(589, 67)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(589, 68)" end="(589, 71)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(589, 68)" end="(589, 69)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(589, 70)" end="(589, 71)">
                          <IdentNode start="(589, 70)" end="(589, 71)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(589, 72)" end="(589, 73)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(589, 73)" end="(589, 74)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(590, 5)" end="(590, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(590, 5)" end="(590, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(590, 6)" end="(590, 7)">
                <IdentNode start="(590, 6)" end="(590, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(590, 8)" end="(590, 29)">
                <AtomNode start="(590, 8)" end="(590, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(590, 10)" end="(590, 29)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(590, 10)" end="(590, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(590, 10)" end="(590, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(590, 12)" end="(590, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(590, 14)" end="(590, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(590, 17)" end="(590, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(590, 17)" end="(590, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(590, 19)" end="(590, 20)">
                        <IdentNode start="(590, 19)" end="(590, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(590, 21)" end="(590, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(590, 23)" end="(590, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(590, 25)" end="(590, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(590, 29)" end="(590, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(590, 31)" end="(590, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(590, 31)" end="(590, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(590, 32)" end="(590, 33)">
                <IdentNode start="(590, 32)" end="(590, 33)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(590, 34)" end="(590, 44)">
                <AtomNode start="(590, 34)" end="(590, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(590, 36)" end="(590, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(590, 36)" end="(590, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(590, 38)" end="(590, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(590, 40)" end="(590, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(590, 44)" end="(590, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(590, 46)" end="(590, 74)">
              <AtomNode start="(590, 46)" end="(590, 47)" leading="" trailing="" val="("/>
              <NullNode start="(590, 47)" end="(590, 49)">
                <IdentNode start="(590, 47)" end="(590, 49)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(590, 50)" end="(590, 73)">
                <AtomNode start="(590, 50)" end="(590, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(590, 52)" end="(590, 73)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(590, 52)" end="(590, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(590, 54)" end="(590, 57)">
                    <IdentNode start="(590, 54)" end="(590, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(590, 56)" end="(590, 57)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(590, 57)" end="(590, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(590, 59)" end="(590, 73)" kind="«term_=_»">
                    <OtherNode start="(590, 59)" end="(590, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(590, 59)" end="(590, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(590, 61)" end="(590, 67)">
                        <OtherNode start="(590, 61)" end="(590, 67)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(590, 61)" end="(590, 62)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(590, 62)" end="(590, 66)">
                            <IdentNode start="(590, 62)" end="(590, 63)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(590, 63)" end="(590, 64)" leading="" trailing=" " val=","/>
                            <IdentNode start="(590, 65)" end="(590, 66)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(590, 66)" end="(590, 67)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(590, 68)" end="(590, 69)" leading="" trailing=" " val="="/>
                    <OtherNode start="(590, 70)" end="(590, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(590, 70)" end="(590, 71)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(590, 72)" end="(590, 73)">
                        <IdentNode start="(590, 72)" end="(590, 73)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(590, 73)" end="(590, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(590, 75)" end="(591, 43)">
            <AtomNode start="(590, 75)" end="(590, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(591, 5)" end="(591, 43)" kind="«term_=_»">
              <OtherNode start="(591, 5)" end="(591, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(591, 5)" end="(591, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(591, 17)" end="(591, 18)">
                  <IdentNode start="(591, 17)" end="(591, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(591, 19)" end="(591, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(591, 21)" end="(591, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(591, 21)" end="(591, 41)" leading="" trailing=" " raw_val="xs.unattach.findIdx?" val="xs.unattach.findIdx?"/>
                <NullNode start="(591, 42)" end="(591, 43)">
                  <IdentNode start="(591, 42)" end="(591, 43)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(591, 44)" end="(593, 12)">
          <AtomNode start="(591, 44)" end="(591, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(591, 47)" end="(593, 12)">
            <AtomNode start="(591, 47)" end="(591, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(592, 3)" end="(593, 12)">
              <TacticTacticseq1IndentedNode start="(592, 3)" end="(593, 12)">
                <NullNode start="(592, 3)" end="(593, 12)">
                  <OtherNode start="(592, 3)" end="(592, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx? f xs = findIdx? g xs.unattach" state_after="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ findIdx? f { toList := toList✝ } = findIdx? g { toList := toList✝ }.unattach" tactic="cases xs">
                    <AtomNode start="(592, 3)" end="(592, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(592, 9)" end="(592, 11)">
                      <OtherNode start="(592, 9)" end="(592, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(592, 9)" end="(592, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(593, 3)" end="(593, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ findIdx? f { toList := toList✝ } = findIdx? g { toList := toList✝ }.unattach" state_after="no goals" tactic="simp [hf]">
                    <AtomNode start="(593, 3)" end="(593, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(593, 8)" end="(593, 12)">
                      <AtomNode start="(593, 8)" end="(593, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(593, 9)" end="(593, 11)">
                        <OtherNode start="(593, 9)" end="(593, 11)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(593, 9)" end="(593, 11)" leading="" trailing="" raw_val="hf" val="hf"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(593, 11)" end="(593, 12)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(595, 1)" end="(598, 7)" name="findIdx?_take" full_name="Array.findIdx?_take">
      <CommandDeclmodifiersNode start="(595, 1)" end="(595, 8)">
        <NullNode/>
        <NullNode start="(595, 1)" end="(595, 8)">
          <OtherNode start="(595, 1)" end="(595, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(595, 1)" end="(595, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(595, 3)" end="(595, 7)">
              <OtherNode start="(595, 3)" end="(595, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(595, 3)" end="(595, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(595, 3)" end="(595, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(595, 7)" end="(595, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(595, 9)" end="(598, 7)" name="findIdx?_take" full_name="Array.findIdx?_take" _is_private_decl="False">
        <AtomNode start="(595, 9)" end="(595, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(595, 17)" end="(595, 30)">
          <IdentNode start="(595, 17)" end="(595, 30)" leading="" trailing=" " raw_val="findIdx?_take" val="findIdx?_take"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(595, 31)" end="(596, 82)">
          <NullNode start="(595, 31)" end="(595, 70)">
            <OtherNode start="(595, 31)" end="(595, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(595, 31)" end="(595, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(595, 32)" end="(595, 34)">
                <IdentNode start="(595, 32)" end="(595, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(595, 35)" end="(595, 44)">
                <AtomNode start="(595, 35)" end="(595, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(595, 37)" end="(595, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(595, 37)" end="(595, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(595, 43)" end="(595, 44)">
                    <IdentNode start="(595, 43)" end="(595, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(595, 44)" end="(595, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(595, 46)" end="(595, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(595, 46)" end="(595, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(595, 47)" end="(595, 48)">
                <IdentNode start="(595, 47)" end="(595, 48)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(595, 49)" end="(595, 54)">
                <AtomNode start="(595, 49)" end="(595, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(595, 51)" end="(595, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(595, 54)" end="(595, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(595, 56)" end="(595, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(595, 56)" end="(595, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(595, 57)" end="(595, 58)">
                <IdentNode start="(595, 57)" end="(595, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(595, 59)" end="(595, 69)">
                <AtomNode start="(595, 59)" end="(595, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(595, 61)" end="(595, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(595, 61)" end="(595, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(595, 63)" end="(595, 64)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(595, 65)" end="(595, 69)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(595, 69)" end="(595, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(595, 71)" end="(596, 82)">
            <AtomNode start="(595, 71)" end="(595, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(596, 5)" end="(596, 82)" kind="«term_=_»">
              <OtherNode start="(596, 5)" end="(596, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(596, 5)" end="(596, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(596, 5)" end="(596, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(596, 5)" end="(596, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(596, 6)" end="(596, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(596, 6)" end="(596, 13)" leading="" trailing=" " raw_val="xs.take" val="xs.take"/>
                      <NullNode start="(596, 14)" end="(596, 15)">
                        <IdentNode start="(596, 14)" end="(596, 15)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(596, 15)" end="(596, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(596, 16)" end="(596, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(596, 17)" end="(596, 25)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="Array.findIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(596, 26)" end="(596, 27)">
                  <IdentNode start="(596, 26)" end="(596, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(596, 28)" end="(596, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(596, 30)" end="(596, 82)" kind="Lean.Parser.Term.app">
                <OtherNode start="(596, 30)" end="(596, 50)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(596, 30)" end="(596, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(596, 30)" end="(596, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(596, 31)" end="(596, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(596, 31)" end="(596, 42)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(596, 43)" end="(596, 44)">
                        <IdentNode start="(596, 43)" end="(596, 44)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(596, 44)" end="(596, 45)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(596, 45)" end="(596, 46)" leading="" trailing="" val="."/>
                  <IdentNode start="(596, 46)" end="(596, 50)" leading="" trailing=" " raw_val="bind" val="bind" full_name="Option.bind" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(596, 51)" end="(596, 82)">
                  <OtherNode start="(596, 51)" end="(596, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(596, 51)" end="(596, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(596, 52)" end="(596, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(596, 52)" end="(596, 64)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                      <NullNode start="(596, 65)" end="(596, 81)">
                        <OtherNode start="(596, 65)" end="(596, 81)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(596, 65)" end="(596, 66)" leading="" trailing="" val="("/>
                          <OtherNode start="(596, 66)" end="(596, 80)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(596, 66)" end="(596, 69)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(596, 70)" end="(596, 80)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(596, 70)" end="(596, 71)">
                                <IdentNode start="(596, 70)" end="(596, 71)" leading="" trailing=" " raw_val="j" val="j"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(596, 72)" end="(596, 74)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(596, 75)" end="(596, 80)" kind="«term_&amp;lt;_»">
                                <IdentNode start="(596, 75)" end="(596, 76)" leading="" trailing=" " raw_val="j" val="j"/>
                                <AtomNode start="(596, 77)" end="(596, 78)" leading="" trailing=" " val="&amp;lt;"/>
                                <IdentNode start="(596, 79)" end="(596, 80)" leading="" trailing="" raw_val="i" val="i"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(596, 80)" end="(596, 81)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(596, 81)" end="(596, 82)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(596, 83)" end="(598, 7)">
          <AtomNode start="(596, 83)" end="(596, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(596, 86)" end="(598, 7)">
            <AtomNode start="(596, 86)" end="(596, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(597, 3)" end="(598, 7)">
              <TacticTacticseq1IndentedNode start="(597, 3)" end="(598, 7)">
                <NullNode start="(597, 3)" end="(598, 7)">
                  <OtherNode start="(597, 3)" end="(597, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;p : α → Bool&#10;⊢ findIdx? p (xs.take i) = (findIdx? p xs).bind (Option.guard fun j =&amp;gt; decide (j &amp;lt; i))" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findIdx? p ({ toList := toList✝ }.take i) =&#10;    (findIdx? p { toList := toList✝ }).bind (Option.guard fun j =&amp;gt; decide (j &amp;lt; i))" tactic="cases xs">
                    <AtomNode start="(597, 3)" end="(597, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(597, 9)" end="(597, 11)">
                      <OtherNode start="(597, 9)" end="(597, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(597, 9)" end="(597, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(598, 3)" end="(598, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ findIdx? p ({ toList := toList✝ }.take i) =&#10;    (findIdx? p { toList := toList✝ }).bind (Option.guard fun j =&amp;gt; decide (j &amp;lt; i))" state_after="no goals" tactic="simp">
                    <AtomNode start="(598, 3)" end="(598, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(600, 1)" end="(600, 23)" comment="### findFinIdx? -/">
      <AtomNode start="(600, 1)" end="(600, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(600, 5)" end="(600, 23)" leading="" trailing="&#10;&#10;" val="### findFinIdx? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(602, 1)" end="(602, 87)" name="findFinIdx?_empty" full_name="Array.findFinIdx?_empty">
      <CommandDeclmodifiersNode start="(602, 1)" end="(602, 8)">
        <NullNode/>
        <NullNode start="(602, 1)" end="(602, 8)">
          <OtherNode start="(602, 1)" end="(602, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(602, 1)" end="(602, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(602, 3)" end="(602, 7)">
              <OtherNode start="(602, 3)" end="(602, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(602, 3)" end="(602, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(602, 3)" end="(602, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(602, 7)" end="(602, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(602, 9)" end="(602, 87)" name="findFinIdx?_empty" full_name="Array.findFinIdx?_empty" _is_private_decl="False">
        <AtomNode start="(602, 9)" end="(602, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(602, 17)" end="(602, 34)">
          <IdentNode start="(602, 17)" end="(602, 34)" leading="" trailing=" " raw_val="findFinIdx?_empty" val="findFinIdx?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(602, 35)" end="(602, 76)">
          <NullNode start="(602, 35)" end="(602, 49)">
            <OtherNode start="(602, 35)" end="(602, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(602, 35)" end="(602, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(602, 36)" end="(602, 37)">
                <IdentNode start="(602, 36)" end="(602, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(602, 38)" end="(602, 48)">
                <AtomNode start="(602, 38)" end="(602, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(602, 40)" end="(602, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(602, 40)" end="(602, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(602, 42)" end="(602, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(602, 44)" end="(602, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(602, 48)" end="(602, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(602, 50)" end="(602, 76)">
            <AtomNode start="(602, 50)" end="(602, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(602, 52)" end="(602, 76)" kind="«term_=_»">
              <OtherNode start="(602, 52)" end="(602, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(602, 52)" end="(602, 63)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(602, 64)" end="(602, 69)">
                  <IdentNode start="(602, 64)" end="(602, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(602, 66)" end="(602, 69)" kind="«term#[_,]»">
                    <AtomNode start="(602, 66)" end="(602, 68)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(602, 68)" end="(602, 69)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(602, 70)" end="(602, 71)" leading="" trailing=" " val="="/>
              <IdentNode start="(602, 72)" end="(602, 76)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(602, 77)" end="(602, 87)">
          <AtomNode start="(602, 77)" end="(602, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(602, 80)" end="(602, 87)">
            <AtomNode start="(602, 80)" end="(602, 82)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(602, 83)" end="(602, 87)">
              <TacticTacticseq1IndentedNode start="(602, 83)" end="(602, 87)">
                <NullNode start="(602, 83)" end="(602, 87)">
                  <OtherNode start="(602, 83)" end="(602, 87)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;⊢ findFinIdx? p #[] = none" state_after="no goals" tactic="simp">
                    <AtomNode start="(602, 83)" end="(602, 87)" leading="" trailing="&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(603, 1)" end="(605, 7)" name="findFinIdx?_singleton" full_name="Array.findFinIdx?_singleton">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(603, 1)" end="(605, 7)" name="findFinIdx?_singleton" full_name="Array.findFinIdx?_singleton" _is_private_decl="False">
        <AtomNode start="(603, 1)" end="(603, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(603, 9)" end="(603, 30)">
          <IdentNode start="(603, 9)" end="(603, 30)" leading="" trailing=" " raw_val="findFinIdx?_singleton" val="findFinIdx?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(603, 31)" end="(604, 65)">
          <NullNode start="(603, 31)" end="(603, 53)">
            <OtherNode start="(603, 31)" end="(603, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(603, 31)" end="(603, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(603, 32)" end="(603, 33)">
                <IdentNode start="(603, 32)" end="(603, 33)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(603, 34)" end="(603, 37)">
                <AtomNode start="(603, 34)" end="(603, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(603, 36)" end="(603, 37)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(603, 37)" end="(603, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(603, 39)" end="(603, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(603, 39)" end="(603, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(603, 40)" end="(603, 41)">
                <IdentNode start="(603, 40)" end="(603, 41)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(603, 42)" end="(603, 52)">
                <AtomNode start="(603, 42)" end="(603, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(603, 44)" end="(603, 52)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(603, 44)" end="(603, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(603, 46)" end="(603, 47)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(603, 48)" end="(603, 52)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(603, 52)" end="(603, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(603, 54)" end="(604, 65)">
            <AtomNode start="(603, 54)" end="(603, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(604, 5)" end="(604, 65)" kind="«term_=_»">
              <OtherNode start="(604, 5)" end="(604, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(604, 5)" end="(604, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(604, 5)" end="(604, 9)" kind="«term#[_,]»">
                    <AtomNode start="(604, 5)" end="(604, 7)" leading="" trailing="" val="#["/>
                    <NullNode start="(604, 7)" end="(604, 8)">
                      <IdentNode start="(604, 7)" end="(604, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(604, 8)" end="(604, 9)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(604, 9)" end="(604, 10)" leading="" trailing="" val="."/>
                  <IdentNode start="(604, 10)" end="(604, 21)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(604, 22)" end="(604, 23)">
                  <IdentNode start="(604, 22)" end="(604, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(604, 24)" end="(604, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(604, 26)" end="(604, 65)" kind="termIfThenElse">
                <AtomNode start="(604, 26)" end="(604, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(604, 29)" end="(604, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(604, 29)" end="(604, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(604, 31)" end="(604, 32)">
                    <IdentNode start="(604, 31)" end="(604, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(604, 33)" end="(604, 37)" leading="" trailing=" " val="then"/>
                <OtherNode start="(604, 38)" end="(604, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(604, 38)" end="(604, 42)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(604, 43)" end="(604, 55)">
                    <OtherNode start="(604, 43)" end="(604, 55)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(604, 43)" end="(604, 44)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(604, 44)" end="(604, 54)">
                        <OtherNode start="(604, 44)" end="(604, 45)" kind="num">
                          <AtomNode start="(604, 44)" end="(604, 45)" leading="" trailing="" val="0"/>
                        </OtherNode>
                        <AtomNode start="(604, 45)" end="(604, 46)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(604, 47)" end="(604, 54)">
                          <AtomNode start="(604, 47)" end="(604, 49)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(604, 50)" end="(604, 54)">
                            <TacticTacticseq1IndentedNode start="(604, 50)" end="(604, 54)">
                              <NullNode start="(604, 50)" end="(604, 54)">
                                <OtherNode start="(604, 50)" end="(604, 54)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.103724&#10;a : α&#10;p : α → Bool&#10;⊢ 0 &amp;lt; #[a].size" state_after="no goals" tactic="simp">
                                  <AtomNode start="(604, 50)" end="(604, 54)" leading="" trailing="" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                      <AtomNode start="(604, 54)" end="(604, 55)" leading="" trailing=" " val="⟩"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(604, 56)" end="(604, 60)" leading="" trailing=" " val="else"/>
                <IdentNode start="(604, 61)" end="(604, 65)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(604, 66)" end="(605, 7)">
          <AtomNode start="(604, 66)" end="(604, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(604, 69)" end="(605, 7)">
            <AtomNode start="(604, 69)" end="(604, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(605, 3)" end="(605, 7)">
              <TacticTacticseq1IndentedNode start="(605, 3)" end="(605, 7)">
                <NullNode start="(605, 3)" end="(605, 7)">
                  <OtherNode start="(605, 3)" end="(605, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ findFinIdx? p #[a] = if p a = true then some ⟨0, ⋯⟩ else none" state_after="no goals" tactic="simp">
                    <AtomNode start="(605, 3)" end="(605, 7)" leading="" trailing="&#10;&#10;-- We can't mark this as a `@[congr]` lemma since the head of the RHS is not `findFinIdx?`.&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(608, 1)" end="(611, 7)" name="findFinIdx?_congr" full_name="Array.findFinIdx?_congr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(608, 1)" end="(611, 7)" name="findFinIdx?_congr" full_name="Array.findFinIdx?_congr" _is_private_decl="False">
        <AtomNode start="(608, 1)" end="(608, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(608, 9)" end="(608, 26)">
          <IdentNode start="(608, 9)" end="(608, 26)" leading="" trailing=" " raw_val="findFinIdx?_congr" val="findFinIdx?_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(608, 27)" end="(609, 78)">
          <NullNode start="(608, 27)" end="(608, 73)">
            <OtherNode start="(608, 27)" end="(608, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(608, 27)" end="(608, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(608, 28)" end="(608, 29)">
                <IdentNode start="(608, 28)" end="(608, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(608, 30)" end="(608, 40)">
                <AtomNode start="(608, 30)" end="(608, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(608, 32)" end="(608, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(608, 32)" end="(608, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(608, 34)" end="(608, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(608, 36)" end="(608, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(608, 40)" end="(608, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(608, 42)" end="(608, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(608, 42)" end="(608, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(608, 43)" end="(608, 48)">
                <IdentNode start="(608, 43)" end="(608, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(608, 46)" end="(608, 48)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(608, 49)" end="(608, 58)">
                <AtomNode start="(608, 49)" end="(608, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(608, 51)" end="(608, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(608, 51)" end="(608, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(608, 57)" end="(608, 58)">
                    <IdentNode start="(608, 57)" end="(608, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(608, 58)" end="(608, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(608, 60)" end="(608, 73)">
              <AtomNode start="(608, 60)" end="(608, 61)" leading="" trailing="" val="("/>
              <NullNode start="(608, 61)" end="(608, 62)">
                <IdentNode start="(608, 61)" end="(608, 62)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(608, 63)" end="(608, 72)">
                <AtomNode start="(608, 63)" end="(608, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(608, 65)" end="(608, 72)" kind="«term_=_»">
                  <IdentNode start="(608, 65)" end="(608, 67)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(608, 68)" end="(608, 69)" leading="" trailing=" " val="="/>
                  <IdentNode start="(608, 70)" end="(608, 72)" leading="" trailing="" raw_val="ys" val="ys"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(608, 72)" end="(608, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(608, 74)" end="(609, 78)">
            <AtomNode start="(608, 74)" end="(608, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(609, 5)" end="(609, 78)" kind="«term_=_»">
              <OtherNode start="(609, 5)" end="(609, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(609, 5)" end="(609, 16)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(609, 17)" end="(609, 21)">
                  <IdentNode start="(609, 17)" end="(609, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(609, 19)" end="(609, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(609, 22)" end="(609, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(609, 24)" end="(609, 78)" kind="Lean.Parser.Term.app">
                <OtherNode start="(609, 24)" end="(609, 46)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(609, 24)" end="(609, 42)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(609, 24)" end="(609, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(609, 25)" end="(609, 41)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(609, 25)" end="(609, 36)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(609, 37)" end="(609, 41)">
                        <IdentNode start="(609, 37)" end="(609, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(609, 39)" end="(609, 41)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(609, 41)" end="(609, 42)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(609, 42)" end="(609, 43)" leading="" trailing="" val="."/>
                  <IdentNode start="(609, 43)" end="(609, 46)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(609, 47)" end="(609, 78)">
                  <OtherNode start="(609, 47)" end="(609, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(609, 47)" end="(609, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(609, 48)" end="(609, 77)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(609, 48)" end="(609, 51)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(609, 52)" end="(609, 77)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(609, 52)" end="(609, 53)">
                          <IdentNode start="(609, 52)" end="(609, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(609, 54)" end="(609, 56)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(609, 57)" end="(609, 77)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(609, 57)" end="(609, 63)" leading="" trailing=" " raw_val="i.cast" val="i.cast"/>
                          <NullNode start="(609, 64)" end="(609, 77)">
                            <OtherNode start="(609, 64)" end="(609, 77)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(609, 64)" end="(609, 65)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(609, 65)" end="(609, 76)">
                                <AtomNode start="(609, 65)" end="(609, 67)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(609, 68)" end="(609, 76)">
                                  <TacticTacticseq1IndentedNode start="(609, 68)" end="(609, 76)">
                                    <NullNode start="(609, 68)" end="(609, 76)">
                                      <OtherNode start="(609, 68)" end="(609, 76)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.104510&#10;p : α → Bool&#10;xs ys : Array α&#10;w : xs = ys&#10;i : Fin ys.size&#10;⊢ ys.size = xs.size" state_after="no goals" tactic="simp [w]">
                                        <AtomNode start="(609, 68)" end="(609, 72)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(609, 73)" end="(609, 76)">
                                          <AtomNode start="(609, 73)" end="(609, 74)" leading="" trailing="" val="["/>
                                          <NullNode start="(609, 74)" end="(609, 75)">
                                            <OtherNode start="(609, 74)" end="(609, 75)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(609, 74)" end="(609, 75)" leading="" trailing="" raw_val="w" val="w"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(609, 75)" end="(609, 76)" leading="" trailing="" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(609, 76)" end="(609, 77)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(609, 77)" end="(609, 78)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(609, 79)" end="(611, 7)">
          <AtomNode start="(609, 79)" end="(609, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(609, 82)" end="(611, 7)">
            <AtomNode start="(609, 82)" end="(609, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(610, 3)" end="(611, 7)">
              <TacticTacticseq1IndentedNode start="(610, 3)" end="(611, 7)">
                <NullNode start="(610, 3)" end="(611, 7)">
                  <OtherNode start="(610, 3)" end="(610, 10)" kind="Lean.Parser.Tactic.subst" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;w : xs = ys&#10;⊢ findFinIdx? p xs = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? p ys)" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findFinIdx? p xs = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? p xs)" tactic="subst w">
                    <AtomNode start="(610, 3)" end="(610, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(610, 9)" end="(610, 10)">
                      <IdentNode start="(610, 9)" end="(610, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(611, 3)" end="(611, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findFinIdx? p xs = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? p xs)" state_after="no goals" tactic="simp">
                    <AtomNode start="(611, 3)" end="(611, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(613, 1)" end="(618, 58)" name="findFinIdx?_eq_pmap_findIdx?" full_name="Array.findFinIdx?_eq_pmap_findIdx?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(613, 1)" end="(618, 58)" name="findFinIdx?_eq_pmap_findIdx?" full_name="Array.findFinIdx?_eq_pmap_findIdx?" _is_private_decl="False">
        <AtomNode start="(613, 1)" end="(613, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(613, 9)" end="(613, 37)">
          <IdentNode start="(613, 9)" end="(613, 37)" leading="" trailing=" " raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(613, 38)" end="(617, 23)">
          <NullNode start="(613, 38)" end="(613, 67)">
            <OtherNode start="(613, 38)" end="(613, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(613, 38)" end="(613, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(613, 39)" end="(613, 41)">
                <IdentNode start="(613, 39)" end="(613, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(613, 42)" end="(613, 51)">
                <AtomNode start="(613, 42)" end="(613, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(613, 44)" end="(613, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(613, 44)" end="(613, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(613, 50)" end="(613, 51)">
                    <IdentNode start="(613, 50)" end="(613, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(613, 51)" end="(613, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(613, 53)" end="(613, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(613, 53)" end="(613, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(613, 54)" end="(613, 55)">
                <IdentNode start="(613, 54)" end="(613, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(613, 56)" end="(613, 66)">
                <AtomNode start="(613, 56)" end="(613, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(613, 58)" end="(613, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(613, 58)" end="(613, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(613, 60)" end="(613, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(613, 62)" end="(613, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(613, 66)" end="(613, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(613, 68)" end="(617, 23)">
            <AtomNode start="(613, 68)" end="(613, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(614, 5)" end="(617, 23)" kind="«term_=_»">
              <OtherNode start="(614, 5)" end="(614, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(614, 5)" end="(614, 19)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                <NullNode start="(614, 20)" end="(614, 21)">
                  <IdentNode start="(614, 20)" end="(614, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(614, 22)" end="(614, 23)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(615, 7)" end="(617, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(615, 7)" end="(615, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(615, 7)" end="(615, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(615, 7)" end="(615, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(615, 8)" end="(615, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(615, 8)" end="(615, 19)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(615, 20)" end="(615, 21)">
                        <IdentNode start="(615, 20)" end="(615, 21)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(615, 21)" end="(615, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(615, 22)" end="(615, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(615, 23)" end="(615, 27)" leading="" trailing="&#10;        " raw_val="pmap" val="pmap" full_name="Option.pmap" mod_name="Init.Data.Option.Instances" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Instances.lean"/>
                </OtherNode>
                <NullNode start="(616, 9)" end="(617, 23)">
                  <OtherNode start="(616, 9)" end="(616, 86)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(616, 9)" end="(616, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(616, 10)" end="(616, 85)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(616, 10)" end="(616, 13)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(616, 14)" end="(616, 85)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(616, 14)" end="(616, 17)">
                          <IdentNode start="(616, 14)" end="(616, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(616, 16)" end="(616, 17)" leading="" trailing=" " raw_val="m" val="m"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(616, 18)" end="(616, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        <TermBytacticNode start="(616, 21)" end="(616, 85)">
                          <AtomNode start="(616, 21)" end="(616, 23)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(616, 24)" end="(616, 85)">
                            <TacticTacticseq1IndentedNode start="(616, 24)" end="(616, 85)">
                              <NullNode start="(616, 24)" end="(616, 85)">
                                <OtherNode start="(616, 24)" end="(616, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.104808&#10;xs : Array α&#10;p : α → Bool&#10;i : Nat&#10;m : findIdx? p xs = some i&#10;⊢ Fin xs.size" state_after="α : Type ?u.104808&#10;xs : Array α&#10;p : α → Bool&#10;i : Nat&#10;m : ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ Fin xs.size" tactic="simp [findIdx?_eq_some_iff_getElem] at m">
                                  <AtomNode start="(616, 24)" end="(616, 28)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(616, 29)" end="(616, 59)">
                                    <AtomNode start="(616, 29)" end="(616, 30)" leading="" trailing="" val="["/>
                                    <NullNode start="(616, 30)" end="(616, 58)">
                                      <OtherNode start="(616, 30)" end="(616, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(616, 30)" end="(616, 58)" leading="" trailing="" raw_val="findIdx?_eq_some_iff_getElem" val="findIdx?_eq_some_iff_getElem" full_name="Array.findIdx?_eq_some_iff_getElem" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(511, 9)" def_end="(511, 37)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(616, 58)" end="(616, 59)" leading="" trailing=" " val="]"/>
                                  </NullNode>
                                  <NullNode start="(616, 60)" end="(616, 64)">
                                    <OtherNode start="(616, 60)" end="(616, 64)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(616, 60)" end="(616, 62)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(616, 63)" end="(616, 64)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(616, 63)" end="(616, 64)">
                                          <IdentNode start="(616, 63)" end="(616, 64)" leading="" trailing="" raw_val="m" val="m"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(616, 64)" end="(616, 65)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(616, 66)" end="(616, 85)" kind="Lean.Parser.Tactic.exact" state_before="α : Type ?u.104808&#10;xs : Array α&#10;p : α → Bool&#10;i : Nat&#10;m : ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ Fin xs.size" state_after="no goals" tactic="exact ⟨i, m.choose⟩">
                                  <AtomNode start="(616, 66)" end="(616, 71)" leading="" trailing=" " val="exact"/>
                                  <OtherNode start="(616, 72)" end="(616, 85)" kind="Lean.Parser.Term.anonymousCtor">
                                    <AtomNode start="(616, 72)" end="(616, 73)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(616, 73)" end="(616, 84)">
                                      <IdentNode start="(616, 73)" end="(616, 74)" leading="" trailing="" raw_val="i" val="i"/>
                                      <AtomNode start="(616, 74)" end="(616, 75)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(616, 76)" end="(616, 84)" leading="" trailing="" raw_val="m.choose" val="m.choose"/>
                                    </NullNode>
                                    <AtomNode start="(616, 84)" end="(616, 85)" leading="" trailing="" val="⟩"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(616, 85)" end="(616, 86)" leading="" trailing="&#10;        " val=")"/>
                  </OtherNode>
                  <OtherNode start="(617, 9)" end="(617, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(617, 9)" end="(617, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(617, 10)" end="(617, 22)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(617, 10)" end="(617, 13)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(617, 14)" end="(617, 22)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(617, 14)" end="(617, 17)">
                          <IdentNode start="(617, 14)" end="(617, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(617, 16)" end="(617, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(617, 18)" end="(617, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        <IdentNode start="(617, 21)" end="(617, 22)" leading="" trailing="" raw_val="h" val="h"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(617, 22)" end="(617, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(617, 24)" end="(618, 58)">
          <AtomNode start="(617, 24)" end="(617, 26)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(617, 27)" end="(618, 58)">
            <AtomNode start="(617, 27)" end="(617, 29)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(618, 3)" end="(618, 58)">
              <TacticTacticseq1IndentedNode start="(618, 3)" end="(618, 58)">
                <NullNode start="(618, 3)" end="(618, 58)">
                  <OtherNode start="(618, 3)" end="(618, 58)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findFinIdx? p xs = Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯" state_after="no goals" tactic="simp [findIdx?_eq_map_findFinIdx?_val, Option.pmap_map]">
                    <AtomNode start="(618, 3)" end="(618, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(618, 8)" end="(618, 58)">
                      <AtomNode start="(618, 8)" end="(618, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(618, 9)" end="(618, 57)">
                        <OtherNode start="(618, 9)" end="(618, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(618, 9)" end="(618, 40)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="Array.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(618, 40)" end="(618, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(618, 42)" end="(618, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(618, 42)" end="(618, 57)" leading="" trailing="" raw_val="Option.pmap_map" val="Option.pmap_map" full_name="Option.pmap_map" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(618, 57)" end="(618, 58)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(620, 1)" end="(622, 38)" name="findFinIdx?_eq_none_iff" full_name="Array.findFinIdx?_eq_none_iff">
      <CommandDeclmodifiersNode start="(620, 1)" end="(620, 8)">
        <NullNode/>
        <NullNode start="(620, 1)" end="(620, 8)">
          <OtherNode start="(620, 1)" end="(620, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(620, 1)" end="(620, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(620, 3)" end="(620, 7)">
              <OtherNode start="(620, 3)" end="(620, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(620, 3)" end="(620, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(620, 3)" end="(620, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(620, 7)" end="(620, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(620, 9)" end="(622, 38)" name="findFinIdx?_eq_none_iff" full_name="Array.findFinIdx?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(620, 9)" end="(620, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(620, 17)" end="(620, 40)">
          <IdentNode start="(620, 17)" end="(620, 40)" leading="" trailing=" " raw_val="findFinIdx?_eq_none_iff" val="findFinIdx?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(620, 41)" end="(621, 50)">
          <NullNode start="(620, 41)" end="(620, 70)">
            <OtherNode start="(620, 41)" end="(620, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(620, 41)" end="(620, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(620, 42)" end="(620, 44)">
                <IdentNode start="(620, 42)" end="(620, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(620, 45)" end="(620, 54)">
                <AtomNode start="(620, 45)" end="(620, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(620, 47)" end="(620, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(620, 47)" end="(620, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(620, 53)" end="(620, 54)">
                    <IdentNode start="(620, 53)" end="(620, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(620, 54)" end="(620, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(620, 56)" end="(620, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(620, 56)" end="(620, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(620, 57)" end="(620, 58)">
                <IdentNode start="(620, 57)" end="(620, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(620, 59)" end="(620, 69)">
                <AtomNode start="(620, 59)" end="(620, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(620, 61)" end="(620, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(620, 61)" end="(620, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(620, 63)" end="(620, 64)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(620, 65)" end="(620, 69)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(620, 69)" end="(620, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(620, 71)" end="(621, 50)">
            <AtomNode start="(620, 71)" end="(620, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(621, 5)" end="(621, 50)" kind="«term_↔_»">
              <OtherNode start="(621, 5)" end="(621, 28)" kind="«term_=_»">
                <OtherNode start="(621, 5)" end="(621, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(621, 5)" end="(621, 19)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                  <NullNode start="(621, 20)" end="(621, 21)">
                    <IdentNode start="(621, 20)" end="(621, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(621, 22)" end="(621, 23)" leading="" trailing=" " val="="/>
                <IdentNode start="(621, 24)" end="(621, 28)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(621, 29)" end="(621, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(621, 31)" end="(621, 50)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(621, 31)" end="(621, 32)" leading="" trailing=" " val="∀"/>
                <NullNode start="(621, 33)" end="(621, 34)">
                  <IdentNode start="(621, 33)" end="(621, 34)" leading="" trailing="" raw_val="x" val="x"/>
                </NullNode>
                <NullNode/>
                <AtomNode start="(621, 34)" end="(621, 35)" leading="" trailing=" " val=","/>
                <OtherNode start="(621, 36)" end="(621, 50)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(621, 36)" end="(621, 42)" kind="«term_∈_»">
                    <IdentNode start="(621, 36)" end="(621, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(621, 38)" end="(621, 39)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(621, 40)" end="(621, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(621, 43)" end="(621, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(621, 45)" end="(621, 50)" kind="«term¬_»">
                    <AtomNode start="(621, 45)" end="(621, 46)" leading="" trailing=" " val="¬"/>
                    <OtherNode start="(621, 47)" end="(621, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(621, 47)" end="(621, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(621, 49)" end="(621, 50)">
                        <IdentNode start="(621, 49)" end="(621, 50)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(621, 51)" end="(622, 38)">
          <AtomNode start="(621, 51)" end="(621, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(621, 54)" end="(622, 38)">
            <AtomNode start="(621, 54)" end="(621, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(622, 3)" end="(622, 38)">
              <TacticTacticseq1IndentedNode start="(622, 3)" end="(622, 38)">
                <NullNode start="(622, 3)" end="(622, 38)">
                  <OtherNode start="(622, 3)" end="(622, 38)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ findFinIdx? p xs = none ↔ ∀ (x : α), x ∈ xs → ¬p x = true" state_after="no goals" tactic="simp [findFinIdx?_eq_pmap_findIdx?]">
                    <AtomNode start="(622, 3)" end="(622, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(622, 8)" end="(622, 38)">
                      <AtomNode start="(622, 8)" end="(622, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(622, 9)" end="(622, 37)">
                        <OtherNode start="(622, 9)" end="(622, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(622, 9)" end="(622, 37)" leading="" trailing="" raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?" full_name="Array.findFinIdx?_eq_pmap_findIdx?" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(613, 9)" def_end="(613, 37)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(622, 37)" end="(622, 38)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(624, 1)" end="(634, 63)" name="findFinIdx?_eq_some_iff" full_name="Array.findFinIdx?_eq_some_iff">
      <CommandDeclmodifiersNode start="(624, 1)" end="(624, 8)">
        <NullNode/>
        <NullNode start="(624, 1)" end="(624, 8)">
          <OtherNode start="(624, 1)" end="(624, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(624, 1)" end="(624, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(624, 3)" end="(624, 7)">
              <OtherNode start="(624, 3)" end="(624, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(624, 3)" end="(624, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(624, 3)" end="(624, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(624, 7)" end="(624, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(625, 1)" end="(634, 63)" name="findFinIdx?_eq_some_iff" full_name="Array.findFinIdx?_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(625, 1)" end="(625, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(625, 9)" end="(625, 32)">
          <IdentNode start="(625, 9)" end="(625, 32)" leading="" trailing=" " raw_val="findFinIdx?_eq_some_iff" val="findFinIdx?_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(625, 33)" end="(627, 69)">
          <NullNode start="(625, 33)" end="(625, 80)">
            <OtherNode start="(625, 33)" end="(625, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(625, 33)" end="(625, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(625, 34)" end="(625, 36)">
                <IdentNode start="(625, 34)" end="(625, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(625, 37)" end="(625, 46)">
                <AtomNode start="(625, 37)" end="(625, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(625, 39)" end="(625, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(625, 39)" end="(625, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(625, 45)" end="(625, 46)">
                    <IdentNode start="(625, 45)" end="(625, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(625, 46)" end="(625, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(625, 48)" end="(625, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(625, 48)" end="(625, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(625, 49)" end="(625, 50)">
                <IdentNode start="(625, 49)" end="(625, 50)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(625, 51)" end="(625, 61)">
                <AtomNode start="(625, 51)" end="(625, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(625, 53)" end="(625, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(625, 53)" end="(625, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(625, 55)" end="(625, 56)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(625, 57)" end="(625, 61)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(625, 61)" end="(625, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(625, 63)" end="(625, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(625, 63)" end="(625, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(625, 64)" end="(625, 65)">
                <IdentNode start="(625, 64)" end="(625, 65)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(625, 66)" end="(625, 79)">
                <AtomNode start="(625, 66)" end="(625, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(625, 68)" end="(625, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(625, 68)" end="(625, 71)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(625, 72)" end="(625, 79)">
                    <IdentNode start="(625, 72)" end="(625, 79)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(625, 79)" end="(625, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(625, 81)" end="(627, 69)">
            <AtomNode start="(625, 81)" end="(625, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(626, 5)" end="(627, 69)" kind="«term_↔_»">
              <OtherNode start="(626, 5)" end="(626, 30)" kind="«term_=_»">
                <OtherNode start="(626, 5)" end="(626, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(626, 5)" end="(626, 19)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                  <NullNode start="(626, 20)" end="(626, 21)">
                    <IdentNode start="(626, 20)" end="(626, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(626, 22)" end="(626, 23)" leading="" trailing=" " val="="/>
                <OtherNode start="(626, 24)" end="(626, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(626, 24)" end="(626, 28)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(626, 29)" end="(626, 30)">
                    <IdentNode start="(626, 29)" end="(626, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(626, 31)" end="(626, 32)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(627, 7)" end="(627, 69)" kind="«term_∧_»">
                <OtherNode start="(627, 7)" end="(627, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(627, 7)" end="(627, 8)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(627, 9)" end="(627, 14)">
                    <OtherNode start="(627, 9)" end="(627, 14)" kind="«term__[_]»">
                      <IdentNode start="(627, 9)" end="(627, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(627, 11)" end="(627, 12)" leading="" trailing="" val="["/>
                      <IdentNode start="(627, 12)" end="(627, 13)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(627, 13)" end="(627, 14)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(627, 15)" end="(627, 16)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(627, 17)" end="(627, 69)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(627, 17)" end="(627, 18)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(627, 19)" end="(627, 34)">
                    <IdentNode start="(627, 19)" end="(627, 20)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(627, 21)" end="(627, 34)">
                      <AtomNode start="(627, 21)" end="(627, 22)" leading="" trailing="" val="("/>
                      <NullNode start="(627, 22)" end="(627, 25)">
                        <IdentNode start="(627, 22)" end="(627, 25)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(627, 26)" end="(627, 33)">
                        <AtomNode start="(627, 26)" end="(627, 27)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(627, 28)" end="(627, 33)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(627, 28)" end="(627, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(627, 30)" end="(627, 31)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(627, 32)" end="(627, 33)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(627, 33)" end="(627, 34)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(627, 34)" end="(627, 35)" leading="" trailing=" " val=","/>
                  <OtherNode start="(627, 36)" end="(627, 69)" kind="«term¬_»">
                    <AtomNode start="(627, 36)" end="(627, 37)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(627, 37)" end="(627, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(627, 37)" end="(627, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(627, 39)" end="(627, 69)">
                        <OtherNode start="(627, 39)" end="(627, 69)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(627, 39)" end="(627, 40)" leading="" trailing="" val="("/>
                          <OtherNode start="(627, 40)" end="(627, 68)" kind="«term__[_]'_»">
                            <IdentNode start="(627, 40)" end="(627, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(627, 42)" end="(627, 43)" leading="" trailing="" val="["/>
                            <IdentNode start="(627, 43)" end="(627, 44)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(627, 44)" end="(627, 46)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(627, 46)" end="(627, 68)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(627, 46)" end="(627, 47)" leading="" trailing="" val="("/>
                              <OtherNode start="(627, 47)" end="(627, 67)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(627, 47)" end="(627, 59)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(627, 60)" end="(627, 67)">
                                  <IdentNode start="(627, 60)" end="(627, 63)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <OtherNode start="(627, 64)" end="(627, 67)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(627, 64)" end="(627, 65)" leading="" trailing="" raw_val="i" val="i"/>
                                    <AtomNode start="(627, 65)" end="(627, 66)" leading="" trailing="" val="."/>
                                    <OtherNode start="(627, 66)" end="(627, 67)" kind="fieldIdx">
                                      <AtomNode start="(627, 66)" end="(627, 67)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(627, 67)" end="(627, 68)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(627, 68)" end="(627, 69)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(627, 70)" end="(634, 63)">
          <AtomNode start="(627, 70)" end="(627, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(627, 73)" end="(634, 63)">
            <AtomNode start="(627, 73)" end="(627, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(628, 3)" end="(634, 63)">
              <TacticTacticseq1IndentedNode start="(628, 3)" end="(634, 63)">
                <NullNode start="(628, 3)" end="(634, 63)">
                  <OtherNode start="(628, 3)" end="(629, 73)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ findFinIdx? p xs = some i ↔ p xs[i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), ¬p xs[j] = true" state_after="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) ↔ p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false" tactic="simp only [findFinIdx?_eq_pmap_findIdx?, Option.pmap_eq_some_iff, findIdx?_eq_some_iff_getElem,&#10;  Bool.not_eq_true, exists_and_left, and_exists_self, Fin.getElem_fin]">
                    <AtomNode start="(628, 3)" end="(628, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(628, 8)" end="(628, 12)">
                      <AtomNode start="(628, 8)" end="(628, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(628, 13)" end="(629, 73)">
                      <AtomNode start="(628, 13)" end="(628, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(628, 14)" end="(629, 72)">
                        <OtherNode start="(628, 14)" end="(628, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(628, 14)" end="(628, 42)" leading="" trailing="" raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?" full_name="Array.findFinIdx?_eq_pmap_findIdx?" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(613, 9)" def_end="(613, 37)"/>
                        </OtherNode>
                        <AtomNode start="(628, 42)" end="(628, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(628, 44)" end="(628, 67)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(628, 44)" end="(628, 67)" leading="" trailing="" raw_val="Option.pmap_eq_some_iff" val="Option.pmap_eq_some_iff" full_name="Option.pmap_eq_some_iff" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(628, 67)" end="(628, 68)" leading="" trailing=" " val=","/>
                        <OtherNode start="(628, 69)" end="(628, 97)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(628, 69)" end="(628, 97)" leading="" trailing="" raw_val="findIdx?_eq_some_iff_getElem" val="findIdx?_eq_some_iff_getElem" full_name="Array.findIdx?_eq_some_iff_getElem" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(511, 9)" def_end="(511, 37)"/>
                        </OtherNode>
                        <AtomNode start="(628, 97)" end="(628, 98)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(629, 5)" end="(629, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(629, 5)" end="(629, 21)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(629, 21)" end="(629, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(629, 23)" end="(629, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(629, 23)" end="(629, 38)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(629, 38)" end="(629, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(629, 40)" end="(629, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(629, 40)" end="(629, 55)" leading="" trailing="" raw_val="and_exists_self" val="and_exists_self" full_name="and_exists_self" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(629, 55)" end="(629, 56)" leading="" trailing=" " val=","/>
                        <OtherNode start="(629, 57)" end="(629, 72)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(629, 57)" end="(629, 72)" leading="" trailing="" raw_val="Fin.getElem_fin" val="Fin.getElem_fin" full_name="Fin.getElem_fin" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(629, 72)" end="(629, 73)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(630, 3)" end="(630, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) ↔ p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false" state_after="case mp&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) → p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false&#10;&#10;case mpr&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" tactic="constructor">
                    <AtomNode start="(630, 3)" end="(630, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(631, 3)" end="(632, 53)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) → p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false&#10;&#10;case mpr&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" state_after="case mpr&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" tactic="· rintro ⟨a, ⟨h, w₁, w₂⟩, rfl⟩&#10;  exact ⟨w₁, fun j hji =&amp;gt; by simpa using w₂ j hji⟩">
                    <OtherNode start="(631, 3)" end="(631, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(631, 3)" end="(631, 4)" kind="patternIgnore">
                        <OtherNode start="(631, 3)" end="(631, 4)" kind="token.«· »">
                          <AtomNode start="(631, 3)" end="(631, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(631, 5)" end="(632, 53)">
                      <TacticTacticseq1IndentedNode start="(631, 5)" end="(632, 53)">
                        <NullNode start="(631, 5)" end="(632, 53)">
                          <OtherNode start="(631, 5)" end="(631, 33)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) → p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false" state_after="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;a : Nat&#10;h : a &amp;lt; xs.size&#10;w₁ : p xs[a] = true&#10;w₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;⊢ p xs[↑⟨a, ⋯⟩] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; ⟨a, ⋯⟩), p xs[↑j] = false" tactic="rintro ⟨a, ⟨h, w₁, w₂⟩, rfl⟩">
                            <AtomNode start="(631, 5)" end="(631, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(631, 12)" end="(631, 33)">
                              <OtherNode start="(631, 12)" end="(631, 33)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(631, 12)" end="(631, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(631, 12)" end="(631, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(631, 13)" end="(631, 32)">
                                    <OtherNode start="(631, 13)" end="(631, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(631, 13)" end="(631, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(631, 13)" end="(631, 14)">
                                          <OtherNode start="(631, 13)" end="(631, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(631, 13)" end="(631, 14)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(631, 14)" end="(631, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(631, 16)" end="(631, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(631, 16)" end="(631, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(631, 16)" end="(631, 27)">
                                          <OtherNode start="(631, 16)" end="(631, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(631, 16)" end="(631, 17)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(631, 17)" end="(631, 26)">
                                              <OtherNode start="(631, 17)" end="(631, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(631, 17)" end="(631, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(631, 17)" end="(631, 18)">
                                                    <OtherNode start="(631, 17)" end="(631, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(631, 17)" end="(631, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(631, 18)" end="(631, 19)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(631, 20)" end="(631, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(631, 20)" end="(631, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(631, 20)" end="(631, 22)">
                                                    <OtherNode start="(631, 20)" end="(631, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(631, 20)" end="(631, 22)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(631, 22)" end="(631, 23)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(631, 24)" end="(631, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(631, 24)" end="(631, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(631, 24)" end="(631, 26)">
                                                    <OtherNode start="(631, 24)" end="(631, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(631, 24)" end="(631, 26)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(631, 26)" end="(631, 27)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(631, 27)" end="(631, 28)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(631, 29)" end="(631, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(631, 29)" end="(631, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(631, 29)" end="(631, 32)">
                                          <OtherNode start="(631, 29)" end="(631, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(631, 29)" end="(631, 32)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(631, 32)" end="(631, 33)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(632, 5)" end="(632, 53)" kind="Lean.Parser.Tactic.exact" state_before="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;a : Nat&#10;h : a &amp;lt; xs.size&#10;w₁ : p xs[a] = true&#10;w₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;⊢ p xs[↑⟨a, ⋯⟩] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; ⟨a, ⋯⟩), p xs[↑j] = false" state_after="no goals" tactic="exact ⟨w₁, fun j hji =&amp;gt; by simpa using w₂ j hji⟩">
                            <AtomNode start="(632, 5)" end="(632, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(632, 11)" end="(632, 53)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(632, 11)" end="(632, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(632, 12)" end="(632, 52)">
                                <IdentNode start="(632, 12)" end="(632, 14)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                <AtomNode start="(632, 14)" end="(632, 15)" leading="" trailing=" " val=","/>
                                <OtherNode start="(632, 16)" end="(632, 52)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(632, 16)" end="(632, 19)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(632, 20)" end="(632, 52)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(632, 20)" end="(632, 25)">
                                      <IdentNode start="(632, 20)" end="(632, 21)" leading="" trailing=" " raw_val="j" val="j"/>
                                      <IdentNode start="(632, 22)" end="(632, 25)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(632, 26)" end="(632, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(632, 29)" end="(632, 52)">
                                      <AtomNode start="(632, 29)" end="(632, 31)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(632, 32)" end="(632, 52)">
                                        <TacticTacticseq1IndentedNode start="(632, 32)" end="(632, 52)">
                                          <NullNode start="(632, 32)" end="(632, 52)">
                                            <OtherNode start="(632, 32)" end="(632, 52)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;a : Nat&#10;h : a &amp;lt; xs.size&#10;w₁ : p xs[a] = true&#10;w₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;j : Fin xs.size&#10;hji : j &amp;lt; ⟨a, ⋯⟩&#10;⊢ p xs[↑j] = false" state_after="no goals" tactic="simpa using w₂ j hji">
                                              <AtomNode start="(632, 32)" end="(632, 37)" leading="" trailing=" " val="simpa"/>
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(632, 38)" end="(632, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(632, 38)" end="(632, 52)">
                                                  <AtomNode start="(632, 38)" end="(632, 43)" leading="" trailing=" " val="using"/>
                                                  <OtherNode start="(632, 44)" end="(632, 52)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(632, 44)" end="(632, 46)" leading="" trailing=" " raw_val="w₂" val="w₂"/>
                                                    <NullNode start="(632, 47)" end="(632, 52)">
                                                      <IdentNode start="(632, 47)" end="(632, 48)" leading="" trailing=" " raw_val="j" val="j"/>
                                                      <IdentNode start="(632, 49)" end="(632, 52)" leading="" trailing="" raw_val="hji" val="hji"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(632, 52)" end="(632, 53)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(633, 3)" end="(634, 63)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" state_after="no goals" tactic="· rintro ⟨h, w⟩&#10;  exact ⟨i, ⟨i.2, h, fun j hji =&amp;gt; w ⟨j, by omega⟩ hji⟩, rfl⟩">
                    <OtherNode start="(633, 3)" end="(633, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(633, 3)" end="(633, 4)" kind="patternIgnore">
                        <OtherNode start="(633, 3)" end="(633, 4)" kind="token.«· »">
                          <AtomNode start="(633, 3)" end="(633, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(633, 5)" end="(634, 63)">
                      <TacticTacticseq1IndentedNode start="(633, 5)" end="(634, 63)">
                        <NullNode start="(633, 5)" end="(634, 63)">
                          <OtherNode start="(633, 5)" end="(633, 18)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" state_after="case mpr.intro&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;h : p xs[↑i] = true&#10;w : ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false&#10;⊢ ∃ a x, i = ⟨a, ⋯⟩" tactic="rintro ⟨h, w⟩">
                            <AtomNode start="(633, 5)" end="(633, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(633, 12)" end="(633, 18)">
                              <OtherNode start="(633, 12)" end="(633, 18)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(633, 12)" end="(633, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(633, 12)" end="(633, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(633, 13)" end="(633, 17)">
                                    <OtherNode start="(633, 13)" end="(633, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(633, 13)" end="(633, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(633, 13)" end="(633, 14)">
                                          <OtherNode start="(633, 13)" end="(633, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(633, 13)" end="(633, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(633, 14)" end="(633, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(633, 16)" end="(633, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(633, 16)" end="(633, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(633, 16)" end="(633, 17)">
                                          <OtherNode start="(633, 16)" end="(633, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(633, 16)" end="(633, 17)" leading="" trailing="" raw_val="w" val="w"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(633, 17)" end="(633, 18)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(634, 5)" end="(634, 63)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro&#10;α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;h : p xs[↑i] = true&#10;w : ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false&#10;⊢ ∃ a x, i = ⟨a, ⋯⟩" state_after="no goals" tactic="exact ⟨i, ⟨i.2, h, fun j hji =&amp;gt; w ⟨j, by omega⟩ hji⟩, rfl⟩">
                            <AtomNode start="(634, 5)" end="(634, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(634, 11)" end="(634, 63)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(634, 11)" end="(634, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(634, 12)" end="(634, 62)">
                                <IdentNode start="(634, 12)" end="(634, 13)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(634, 13)" end="(634, 14)" leading="" trailing=" " val=","/>
                                <OtherNode start="(634, 15)" end="(634, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(634, 15)" end="(634, 16)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(634, 16)" end="(634, 56)">
                                    <OtherNode start="(634, 16)" end="(634, 19)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(634, 16)" end="(634, 17)" leading="" trailing="" raw_val="i" val="i"/>
                                      <AtomNode start="(634, 17)" end="(634, 18)" leading="" trailing="" val="."/>
                                      <OtherNode start="(634, 18)" end="(634, 19)" kind="fieldIdx">
                                        <AtomNode start="(634, 18)" end="(634, 19)" leading="" trailing="" val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(634, 19)" end="(634, 20)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(634, 21)" end="(634, 22)" leading="" trailing="" raw_val="h" val="h"/>
                                    <AtomNode start="(634, 22)" end="(634, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(634, 24)" end="(634, 56)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(634, 24)" end="(634, 27)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(634, 28)" end="(634, 56)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(634, 28)" end="(634, 33)">
                                          <IdentNode start="(634, 28)" end="(634, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                                          <IdentNode start="(634, 30)" end="(634, 33)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(634, 34)" end="(634, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <OtherNode start="(634, 37)" end="(634, 56)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(634, 37)" end="(634, 38)" leading="" trailing=" " raw_val="w" val="w"/>
                                          <NullNode start="(634, 39)" end="(634, 56)">
                                            <OtherNode start="(634, 39)" end="(634, 52)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(634, 39)" end="(634, 40)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(634, 40)" end="(634, 51)">
                                                <IdentNode start="(634, 40)" end="(634, 41)" leading="" trailing="" raw_val="j" val="j"/>
                                                <AtomNode start="(634, 41)" end="(634, 42)" leading="" trailing=" " val=","/>
                                                <TermBytacticNode start="(634, 43)" end="(634, 51)">
                                                  <AtomNode start="(634, 43)" end="(634, 45)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(634, 46)" end="(634, 51)">
                                                    <TacticTacticseq1IndentedNode start="(634, 46)" end="(634, 51)">
                                                      <NullNode start="(634, 46)" end="(634, 51)">
                                                        <OtherNode start="(634, 46)" end="(634, 51)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;i : Fin xs.size&#10;h : p xs[↑i] = true&#10;w : ∀ (j : Fin xs.size) (hji : j &amp;lt; i), p xs[↑j] = false&#10;j : Nat&#10;hji : j &amp;lt; ↑i&#10;⊢ j &amp;lt; xs.size" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(634, 46)" end="(634, 51)" leading="" trailing="" val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </NullNode>
                                              <AtomNode start="(634, 51)" end="(634, 52)" leading="" trailing=" " val="⟩"/>
                                            </OtherNode>
                                            <IdentNode start="(634, 53)" end="(634, 56)" leading="" trailing="" raw_val="hji" val="hji"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(634, 56)" end="(634, 57)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(634, 57)" end="(634, 58)" leading="" trailing=" " val=","/>
                                <IdentNode start="(634, 59)" end="(634, 62)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(634, 62)" end="(634, 63)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(636, 1)" end="(640, 48)" name="findFinIdx?_push" full_name="Array.findFinIdx?_push">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(636, 1)" end="(640, 48)" name="findFinIdx?_push" full_name="Array.findFinIdx?_push" _is_private_decl="False">
        <AtomNode start="(636, 1)" end="(636, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(636, 9)" end="(636, 25)">
          <IdentNode start="(636, 9)" end="(636, 25)" leading="" trailing=" " raw_val="findFinIdx?_push" val="findFinIdx?_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(636, 26)" end="(638, 105)">
          <NullNode start="(636, 26)" end="(636, 63)">
            <OtherNode start="(636, 26)" end="(636, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(636, 26)" end="(636, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(636, 27)" end="(636, 29)">
                <IdentNode start="(636, 27)" end="(636, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(636, 30)" end="(636, 39)">
                <AtomNode start="(636, 30)" end="(636, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(636, 32)" end="(636, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(636, 32)" end="(636, 37)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(636, 38)" end="(636, 39)">
                    <IdentNode start="(636, 38)" end="(636, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(636, 39)" end="(636, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(636, 41)" end="(636, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(636, 41)" end="(636, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(636, 42)" end="(636, 43)">
                <IdentNode start="(636, 42)" end="(636, 43)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(636, 44)" end="(636, 47)">
                <AtomNode start="(636, 44)" end="(636, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(636, 46)" end="(636, 47)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(636, 47)" end="(636, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(636, 49)" end="(636, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(636, 49)" end="(636, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(636, 50)" end="(636, 51)">
                <IdentNode start="(636, 50)" end="(636, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(636, 52)" end="(636, 62)">
                <AtomNode start="(636, 52)" end="(636, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(636, 54)" end="(636, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(636, 54)" end="(636, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(636, 56)" end="(636, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(636, 58)" end="(636, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(636, 62)" end="(636, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(636, 64)" end="(638, 105)">
            <AtomNode start="(636, 64)" end="(636, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(637, 5)" end="(638, 105)" kind="«term_=_»">
              <OtherNode start="(637, 5)" end="(637, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(637, 5)" end="(637, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(637, 5)" end="(637, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(637, 5)" end="(637, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(637, 6)" end="(637, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(637, 6)" end="(637, 13)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(637, 14)" end="(637, 15)">
                        <IdentNode start="(637, 14)" end="(637, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(637, 15)" end="(637, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(637, 16)" end="(637, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(637, 17)" end="(637, 28)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(637, 29)" end="(637, 30)">
                  <IdentNode start="(637, 29)" end="(637, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(637, 31)" end="(637, 32)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(638, 7)" end="(638, 105)" kind="Lean.Parser.Term.app">
                <OtherNode start="(638, 7)" end="(638, 57)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(638, 7)" end="(638, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(638, 7)" end="(638, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(638, 8)" end="(638, 53)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(638, 8)" end="(638, 30)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(638, 8)" end="(638, 26)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(638, 8)" end="(638, 9)" leading="" trailing="" val="("/>
                          <OtherNode start="(638, 9)" end="(638, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(638, 9)" end="(638, 23)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                            <NullNode start="(638, 24)" end="(638, 25)">
                              <IdentNode start="(638, 24)" end="(638, 25)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(638, 25)" end="(638, 26)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(638, 26)" end="(638, 27)" leading="" trailing="" val="."/>
                        <IdentNode start="(638, 27)" end="(638, 30)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(638, 31)" end="(638, 53)">
                        <OtherNode start="(638, 31)" end="(638, 53)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(638, 31)" end="(638, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(638, 32)" end="(638, 52)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(638, 32)" end="(638, 42)" leading="" trailing=" " raw_val="Fin.castLE" val="Fin.castLE" full_name="Fin.castLE" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            <NullNode start="(638, 43)" end="(638, 52)">
                              <OtherNode start="(638, 43)" end="(638, 52)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(638, 43)" end="(638, 44)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(638, 44)" end="(638, 51)">
                                  <AtomNode start="(638, 44)" end="(638, 46)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(638, 47)" end="(638, 51)">
                                    <TacticTacticseq1IndentedNode start="(638, 47)" end="(638, 51)">
                                      <NullNode start="(638, 47)" end="(638, 51)">
                                        <OtherNode start="(638, 47)" end="(638, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.111077&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ xs.size ≤ (xs.push a).size" state_after="no goals" tactic="simp">
                                          <AtomNode start="(638, 47)" end="(638, 51)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(638, 51)" end="(638, 52)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(638, 52)" end="(638, 53)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(638, 53)" end="(638, 54)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(638, 54)" end="(638, 55)" leading="" trailing="" val="."/>
                  <IdentNode start="(638, 55)" end="(638, 57)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(638, 58)" end="(638, 105)">
                  <OtherNode start="(638, 58)" end="(638, 105)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(638, 58)" end="(638, 59)" leading="" trailing="" val="("/>
                    <OtherNode start="(638, 59)" end="(638, 104)" kind="termIfThenElse">
                      <AtomNode start="(638, 59)" end="(638, 61)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(638, 62)" end="(638, 65)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(638, 62)" end="(638, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(638, 64)" end="(638, 65)">
                          <IdentNode start="(638, 64)" end="(638, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(638, 66)" end="(638, 70)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(638, 71)" end="(638, 94)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(638, 71)" end="(638, 75)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(638, 76)" end="(638, 94)">
                          <OtherNode start="(638, 76)" end="(638, 94)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(638, 76)" end="(638, 77)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(638, 77)" end="(638, 93)">
                              <IdentNode start="(638, 77)" end="(638, 84)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                              <AtomNode start="(638, 84)" end="(638, 85)" leading="" trailing=" " val=","/>
                              <TermBytacticNode start="(638, 86)" end="(638, 93)">
                                <AtomNode start="(638, 86)" end="(638, 88)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(638, 89)" end="(638, 93)">
                                  <TacticTacticseq1IndentedNode start="(638, 89)" end="(638, 93)">
                                    <NullNode start="(638, 89)" end="(638, 93)">
                                      <OtherNode start="(638, 89)" end="(638, 93)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.111077&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ xs.size &amp;lt; (xs.push a).size" state_after="no goals" tactic="simp">
                                        <AtomNode start="(638, 89)" end="(638, 93)" leading="" trailing="" val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                            </NullNode>
                            <AtomNode start="(638, 93)" end="(638, 94)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(638, 95)" end="(638, 99)" leading="" trailing=" " val="else"/>
                      <IdentNode start="(638, 100)" end="(638, 104)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(638, 104)" end="(638, 105)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(638, 106)" end="(640, 48)">
          <AtomNode start="(638, 106)" end="(638, 108)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(638, 109)" end="(640, 48)">
            <AtomNode start="(638, 109)" end="(638, 111)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(639, 3)" end="(640, 48)">
              <TacticTacticseq1IndentedNode start="(639, 3)" end="(640, 48)">
                <NullNode start="(639, 3)" end="(640, 48)">
                  <OtherNode start="(639, 3)" end="(639, 74)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ findFinIdx? p (xs.push a) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p xs)).or (if p a = true then some ⟨xs.size, ⋯⟩ else none)" state_after="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ (match findIdx? p xs, ⋯ with&#10;    | none, h =&amp;gt; Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (if p a = true then some xs.size else none) ⋯&#10;    | some a_1, h =&amp;gt; some ⟨a_1, ⋯⟩) =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (if p a = true then some ⟨xs.size, ⋯⟩ else none)" tactic="simp only [findFinIdx?_eq_pmap_findIdx?, findIdx?_push, Option.pmap_or]">
                    <AtomNode start="(639, 3)" end="(639, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(639, 8)" end="(639, 12)">
                      <AtomNode start="(639, 8)" end="(639, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(639, 13)" end="(639, 74)">
                      <AtomNode start="(639, 13)" end="(639, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(639, 14)" end="(639, 73)">
                        <OtherNode start="(639, 14)" end="(639, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(639, 14)" end="(639, 42)" leading="" trailing="" raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?" full_name="Array.findFinIdx?_eq_pmap_findIdx?" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(613, 9)" def_end="(613, 37)"/>
                        </OtherNode>
                        <AtomNode start="(639, 42)" end="(639, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(639, 44)" end="(639, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(639, 44)" end="(639, 57)" leading="" trailing="" raw_val="findIdx?_push" val="findIdx?_push" full_name="Array.findIdx?_push" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(539, 9)" def_end="(539, 22)"/>
                        </OtherNode>
                        <AtomNode start="(639, 57)" end="(639, 58)" leading="" trailing=" " val=","/>
                        <OtherNode start="(639, 59)" end="(639, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(639, 59)" end="(639, 73)" leading="" trailing="" raw_val="Option.pmap_or" val="Option.pmap_or" full_name="Option.pmap_or" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(639, 73)" end="(639, 74)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(640, 3)" end="(640, 48)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;xs : Array α&#10;a : α&#10;p : α → Bool&#10;⊢ (match findIdx? p xs, ⋯ with&#10;    | none, h =&amp;gt; Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (if p a = true then some xs.size else none) ⋯&#10;    | some a_1, h =&amp;gt; some ⟨a_1, ⋯⟩) =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (if p a = true then some ⟨xs.size, ⋯⟩ else none)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; rename_i h _ &amp;lt;;&amp;gt; split &amp;lt;;&amp;gt; simp [h]">
                    <OtherNode start="(640, 3)" end="(640, 35)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(640, 3)" end="(640, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                        <OtherNode start="(640, 3)" end="(640, 8)" kind="Lean.Parser.Tactic.split">
                          <AtomNode start="(640, 3)" end="(640, 8)" leading="" trailing=" " val="split"/>
                          <NullNode/>
                          <NullNode/>
                        </OtherNode>
                        <AtomNode start="(640, 9)" end="(640, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                        <OtherNode start="(640, 13)" end="(640, 25)" kind="Lean.Parser.Tactic.renameI">
                          <AtomNode start="(640, 13)" end="(640, 21)" leading="" trailing=" " val="rename_i"/>
                          <NullNode start="(640, 22)" end="(640, 25)">
                            <LeanBinderidentNode start="(640, 22)" end="(640, 23)">
                              <IdentNode start="(640, 22)" end="(640, 23)" leading="" trailing=" " raw_val="h" val="h"/>
                            </LeanBinderidentNode>
                            <LeanBinderidentNode start="(640, 24)" end="(640, 25)">
                              <TermHoleNode start="(640, 24)" end="(640, 25)">
                                <AtomNode start="(640, 24)" end="(640, 25)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                            </LeanBinderidentNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(640, 26)" end="(640, 29)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(640, 30)" end="(640, 35)" kind="Lean.Parser.Tactic.split">
                        <AtomNode start="(640, 30)" end="(640, 35)" leading="" trailing=" " val="split"/>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(640, 36)" end="(640, 39)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(640, 40)" end="(640, 48)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(640, 40)" end="(640, 44)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(640, 45)" end="(640, 48)">
                        <AtomNode start="(640, 45)" end="(640, 46)" leading="" trailing="" val="["/>
                        <NullNode start="(640, 46)" end="(640, 47)">
                          <OtherNode start="(640, 46)" end="(640, 47)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(640, 46)" end="(640, 47)" leading="" trailing="" raw_val="h" val="h"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(640, 47)" end="(640, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(642, 1)" end="(649, 13)" name="findFinIdx?_append" full_name="Array.findFinIdx?_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(642, 1)" end="(649, 13)" name="findFinIdx?_append" full_name="Array.findFinIdx?_append" _is_private_decl="False">
        <AtomNode start="(642, 1)" end="(642, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(642, 9)" end="(642, 27)">
          <IdentNode start="(642, 9)" end="(642, 27)" leading="" trailing=" " raw_val="findFinIdx?_append" val="findFinIdx?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(642, 28)" end="(645, 82)">
          <NullNode start="(642, 28)" end="(642, 60)">
            <OtherNode start="(642, 28)" end="(642, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(642, 28)" end="(642, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(642, 29)" end="(642, 34)">
                <IdentNode start="(642, 29)" end="(642, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(642, 32)" end="(642, 34)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(642, 35)" end="(642, 44)">
                <AtomNode start="(642, 35)" end="(642, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(642, 37)" end="(642, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(642, 37)" end="(642, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(642, 43)" end="(642, 44)">
                    <IdentNode start="(642, 43)" end="(642, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(642, 44)" end="(642, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(642, 46)" end="(642, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(642, 46)" end="(642, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(642, 47)" end="(642, 48)">
                <IdentNode start="(642, 47)" end="(642, 48)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(642, 49)" end="(642, 59)">
                <AtomNode start="(642, 49)" end="(642, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(642, 51)" end="(642, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(642, 51)" end="(642, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(642, 53)" end="(642, 54)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(642, 55)" end="(642, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(642, 59)" end="(642, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(642, 61)" end="(645, 82)">
            <AtomNode start="(642, 61)" end="(642, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(643, 5)" end="(645, 82)" kind="«term_=_»">
              <OtherNode start="(643, 5)" end="(643, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(643, 5)" end="(643, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(643, 5)" end="(643, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(643, 5)" end="(643, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(643, 6)" end="(643, 14)" kind="«term_++_»">
                      <IdentNode start="(643, 6)" end="(643, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(643, 9)" end="(643, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(643, 12)" end="(643, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(643, 14)" end="(643, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(643, 15)" end="(643, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(643, 16)" end="(643, 27)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(643, 28)" end="(643, 29)">
                  <IdentNode start="(643, 28)" end="(643, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(643, 30)" end="(643, 31)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(644, 7)" end="(645, 82)" kind="Lean.Parser.Term.app">
                <OtherNode start="(644, 7)" end="(644, 57)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(644, 7)" end="(644, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(644, 7)" end="(644, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(644, 8)" end="(644, 53)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(644, 8)" end="(644, 30)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(644, 8)" end="(644, 26)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(644, 8)" end="(644, 9)" leading="" trailing="" val="("/>
                          <OtherNode start="(644, 9)" end="(644, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(644, 9)" end="(644, 23)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                            <NullNode start="(644, 24)" end="(644, 25)">
                              <IdentNode start="(644, 24)" end="(644, 25)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(644, 25)" end="(644, 26)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(644, 26)" end="(644, 27)" leading="" trailing="" val="."/>
                        <IdentNode start="(644, 27)" end="(644, 30)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(644, 31)" end="(644, 53)">
                        <OtherNode start="(644, 31)" end="(644, 53)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(644, 31)" end="(644, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(644, 32)" end="(644, 52)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(644, 32)" end="(644, 42)" leading="" trailing=" " raw_val="Fin.castLE" val="Fin.castLE" full_name="Fin.castLE" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            <NullNode start="(644, 43)" end="(644, 52)">
                              <OtherNode start="(644, 43)" end="(644, 52)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(644, 43)" end="(644, 44)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(644, 44)" end="(644, 51)">
                                  <AtomNode start="(644, 44)" end="(644, 46)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(644, 47)" end="(644, 51)">
                                    <TacticTacticseq1IndentedNode start="(644, 47)" end="(644, 51)">
                                      <NullNode start="(644, 47)" end="(644, 51)">
                                        <OtherNode start="(644, 47)" end="(644, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.117355&#10;xs ys : Array α&#10;p : α → Bool&#10;⊢ xs.size ≤ (xs ++ ys).size" state_after="no goals" tactic="simp">
                                          <AtomNode start="(644, 47)" end="(644, 51)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(644, 51)" end="(644, 52)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(644, 52)" end="(644, 53)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(644, 53)" end="(644, 54)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(644, 54)" end="(644, 55)" leading="" trailing="" val="."/>
                  <IdentNode start="(644, 55)" end="(644, 57)" leading="" trailing="&#10;        " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(645, 9)" end="(645, 82)">
                  <OtherNode start="(645, 9)" end="(645, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(645, 9)" end="(645, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(645, 10)" end="(645, 81)" kind="Lean.Parser.Term.pipeProj">
                      <OtherNode start="(645, 10)" end="(645, 53)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(645, 10)" end="(645, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(645, 10)" end="(645, 28)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(645, 10)" end="(645, 11)" leading="" trailing="" val="("/>
                            <OtherNode start="(645, 11)" end="(645, 27)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(645, 11)" end="(645, 25)" leading="" trailing=" " raw_val="ys.findFinIdx?" val="ys.findFinIdx?"/>
                              <NullNode start="(645, 26)" end="(645, 27)">
                                <IdentNode start="(645, 26)" end="(645, 27)" leading="" trailing="" raw_val="p" val="p"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(645, 27)" end="(645, 28)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(645, 28)" end="(645, 29)" leading="" trailing="" val="."/>
                          <IdentNode start="(645, 29)" end="(645, 32)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <NullNode start="(645, 33)" end="(645, 53)">
                          <OtherNode start="(645, 33)" end="(645, 53)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(645, 33)" end="(645, 34)" leading="" trailing="" val="("/>
                            <OtherNode start="(645, 34)" end="(645, 52)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(645, 34)" end="(645, 44)" leading="" trailing=" " raw_val="Fin.natAdd" val="Fin.natAdd" full_name="Fin.natAdd" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                              <NullNode start="(645, 45)" end="(645, 52)">
                                <IdentNode start="(645, 45)" end="(645, 52)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(645, 52)" end="(645, 53)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(645, 54)" end="(645, 57)" leading="" trailing="" val="|&amp;gt;."/>
                      <IdentNode start="(645, 57)" end="(645, 60)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(645, 61)" end="(645, 81)">
                        <OtherNode start="(645, 61)" end="(645, 81)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(645, 61)" end="(645, 62)" leading="" trailing="" val="("/>
                          <OtherNode start="(645, 62)" end="(645, 80)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(645, 62)" end="(645, 70)" leading="" trailing=" " raw_val="Fin.cast" val="Fin.cast" full_name="Fin.cast" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            <NullNode start="(645, 71)" end="(645, 80)">
                              <OtherNode start="(645, 71)" end="(645, 80)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(645, 71)" end="(645, 72)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(645, 72)" end="(645, 79)">
                                  <AtomNode start="(645, 72)" end="(645, 74)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(645, 75)" end="(645, 79)">
                                    <TacticTacticseq1IndentedNode start="(645, 75)" end="(645, 79)">
                                      <NullNode start="(645, 75)" end="(645, 79)">
                                        <OtherNode start="(645, 75)" end="(645, 79)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.117355&#10;xs ys : Array α&#10;p : α → Bool&#10;⊢ xs.size + ys.size = (xs ++ ys).size" state_after="no goals" tactic="simp">
                                          <AtomNode start="(645, 75)" end="(645, 79)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(645, 79)" end="(645, 80)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(645, 80)" end="(645, 81)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(645, 81)" end="(645, 82)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(645, 83)" end="(649, 13)">
          <AtomNode start="(645, 83)" end="(645, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(645, 86)" end="(649, 13)">
            <AtomNode start="(645, 86)" end="(645, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(646, 3)" end="(649, 13)">
              <TacticTacticseq1IndentedNode start="(646, 3)" end="(649, 13)">
                <NullNode start="(646, 3)" end="(649, 13)">
                  <OtherNode start="(646, 3)" end="(646, 76)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;⊢ findFinIdx? p (xs ++ ys) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p xs)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (findFinIdx? p ys)))" state_after="α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;⊢ (match findIdx? p xs, ⋯ with&#10;    | none, h =&amp;gt; Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) ⋯&#10;    | some a, h =&amp;gt; some ⟨a, ⋯⟩) =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" tactic="simp only [findFinIdx?_eq_pmap_findIdx?, findIdx?_append, Option.pmap_or]">
                    <AtomNode start="(646, 3)" end="(646, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(646, 8)" end="(646, 12)">
                      <AtomNode start="(646, 8)" end="(646, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(646, 13)" end="(646, 76)">
                      <AtomNode start="(646, 13)" end="(646, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(646, 14)" end="(646, 75)">
                        <OtherNode start="(646, 14)" end="(646, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(646, 14)" end="(646, 42)" leading="" trailing="" raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?" full_name="Array.findFinIdx?_eq_pmap_findIdx?" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(613, 9)" def_end="(613, 37)"/>
                        </OtherNode>
                        <AtomNode start="(646, 42)" end="(646, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(646, 44)" end="(646, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(646, 44)" end="(646, 59)" leading="" trailing="" raw_val="findIdx?_append" val="findIdx?_append" full_name="Array.findIdx?_append" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(532, 17)" def_end="(532, 32)"/>
                        </OtherNode>
                        <AtomNode start="(646, 59)" end="(646, 60)" leading="" trailing=" " val=","/>
                        <OtherNode start="(646, 61)" end="(646, 75)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(646, 61)" end="(646, 75)" leading="" trailing="" raw_val="Option.pmap_or" val="Option.pmap_or" full_name="Option.pmap_or" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(646, 75)" end="(646, 76)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(647, 3)" end="(647, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;⊢ (match findIdx? p xs, ⋯ with&#10;    | none, h =&amp;gt; Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) ⋯&#10;    | some a, h =&amp;gt; some ⟨a, ⋯⟩) =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="case h_1&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    none.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = none&#10;heq✝ : HEq ⋯ h✝&#10;⊢ Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) ⋯ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))&#10;&#10;case h_2&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" tactic="split &amp;lt;;&amp;gt; rename_i h _">
                    <OtherNode start="(647, 3)" end="(647, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(647, 3)" end="(647, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(647, 9)" end="(647, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(647, 13)" end="(647, 25)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(647, 13)" end="(647, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(647, 22)" end="(647, 25)">
                        <LeanBinderidentNode start="(647, 22)" end="(647, 23)">
                          <IdentNode start="(647, 22)" end="(647, 23)" leading="" trailing=" " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(647, 24)" end="(647, 25)">
                          <TermHoleNode start="(647, 24)" end="(647, 25)">
                            <AtomNode start="(647, 24)" end="(647, 25)" leading="" trailing="&#10;  " val="_"/>
                          </TermHoleNode>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(648, 3)" end="(648, 61)" kind="Lean.cdot" state_before="case h_1&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    none.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = none&#10;heq✝ : HEq ⋯ h✝&#10;⊢ Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) ⋯ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))&#10;&#10;case h_2&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="case h_2&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" tactic="· simp [h, Option.pmap_map, Option.map_pmap, Nat.add_comm]">
                    <OtherNode start="(648, 3)" end="(648, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(648, 3)" end="(648, 4)" kind="patternIgnore">
                        <OtherNode start="(648, 3)" end="(648, 4)" kind="token.«· »">
                          <AtomNode start="(648, 3)" end="(648, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(648, 5)" end="(648, 61)">
                      <TacticTacticseq1IndentedNode start="(648, 5)" end="(648, 61)">
                        <NullNode start="(648, 5)" end="(648, 61)">
                          <OtherNode start="(648, 5)" end="(648, 61)" kind="Lean.Parser.Tactic.simp" state_before="case h_1&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    none.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = none&#10;heq✝ : HEq ⋯ h✝&#10;⊢ Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) ⋯ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="no goals" tactic="simp [h, Option.pmap_map, Option.map_pmap, Nat.add_comm]">
                            <AtomNode start="(648, 5)" end="(648, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(648, 10)" end="(648, 61)">
                              <AtomNode start="(648, 10)" end="(648, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(648, 11)" end="(648, 60)">
                                <OtherNode start="(648, 11)" end="(648, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(648, 11)" end="(648, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(648, 12)" end="(648, 13)" leading="" trailing=" " val=","/>
                                <OtherNode start="(648, 14)" end="(648, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(648, 14)" end="(648, 29)" leading="" trailing="" raw_val="Option.pmap_map" val="Option.pmap_map" full_name="Option.pmap_map" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(648, 29)" end="(648, 30)" leading="" trailing=" " val=","/>
                                <OtherNode start="(648, 31)" end="(648, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(648, 31)" end="(648, 46)" leading="" trailing="" raw_val="Option.map_pmap" val="Option.map_pmap" full_name="Option.map_pmap" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(648, 46)" end="(648, 47)" leading="" trailing=" " val=","/>
                                <OtherNode start="(648, 48)" end="(648, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(648, 48)" end="(648, 60)" leading="" trailing="" raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(648, 60)" end="(648, 61)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(649, 3)" end="(649, 13)" kind="Lean.cdot" state_before="case h_2&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="no goals" tactic="· simp [h]">
                    <OtherNode start="(649, 3)" end="(649, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(649, 3)" end="(649, 4)" kind="patternIgnore">
                        <OtherNode start="(649, 3)" end="(649, 4)" kind="token.«· »">
                          <AtomNode start="(649, 3)" end="(649, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(649, 5)" end="(649, 13)">
                      <TacticTacticseq1IndentedNode start="(649, 5)" end="(649, 13)">
                        <NullNode start="(649, 5)" end="(649, 13)">
                          <OtherNode start="(649, 5)" end="(649, 13)" kind="Lean.Parser.Tactic.simp" state_before="case h_2&#10;α : Type u_1&#10;xs ys : Array α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.size) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="no goals" tactic="simp [h]">
                            <AtomNode start="(649, 5)" end="(649, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(649, 10)" end="(649, 13)">
                              <AtomNode start="(649, 10)" end="(649, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(649, 11)" end="(649, 12)">
                                <OtherNode start="(649, 11)" end="(649, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(649, 11)" end="(649, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(649, 12)" end="(649, 13)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(651, 1)" end="(655, 7)" name="isSome_findFinIdx?" full_name="Array.isSome_findFinIdx?">
      <CommandDeclmodifiersNode start="(651, 1)" end="(651, 8)">
        <NullNode/>
        <NullNode start="(651, 1)" end="(651, 8)">
          <OtherNode start="(651, 1)" end="(651, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(651, 1)" end="(651, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(651, 3)" end="(651, 7)">
              <OtherNode start="(651, 3)" end="(651, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(651, 3)" end="(651, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(651, 3)" end="(651, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(651, 7)" end="(651, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(652, 1)" end="(655, 7)" name="isSome_findFinIdx?" full_name="Array.isSome_findFinIdx?" _is_private_decl="False">
        <AtomNode start="(652, 1)" end="(652, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(652, 9)" end="(652, 27)">
          <IdentNode start="(652, 9)" end="(652, 27)" leading="" trailing=" " raw_val="isSome_findFinIdx?" val="isSome_findFinIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(652, 28)" end="(653, 41)">
          <NullNode start="(652, 28)" end="(652, 57)">
            <OtherNode start="(652, 28)" end="(652, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(652, 28)" end="(652, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(652, 29)" end="(652, 31)">
                <IdentNode start="(652, 29)" end="(652, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(652, 32)" end="(652, 41)">
                <AtomNode start="(652, 32)" end="(652, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(652, 34)" end="(652, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(652, 34)" end="(652, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(652, 40)" end="(652, 41)">
                    <IdentNode start="(652, 40)" end="(652, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(652, 41)" end="(652, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(652, 43)" end="(652, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(652, 43)" end="(652, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(652, 44)" end="(652, 45)">
                <IdentNode start="(652, 44)" end="(652, 45)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(652, 46)" end="(652, 56)">
                <AtomNode start="(652, 46)" end="(652, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(652, 48)" end="(652, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(652, 48)" end="(652, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(652, 50)" end="(652, 51)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(652, 52)" end="(652, 56)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(652, 56)" end="(652, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(652, 58)" end="(653, 41)">
            <AtomNode start="(652, 58)" end="(652, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(653, 5)" end="(653, 41)" kind="«term_=_»">
              <OtherNode start="(653, 5)" end="(653, 30)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(653, 5)" end="(653, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(653, 5)" end="(653, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(653, 6)" end="(653, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(653, 6)" end="(653, 20)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                    <NullNode start="(653, 21)" end="(653, 22)">
                      <IdentNode start="(653, 21)" end="(653, 22)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(653, 22)" end="(653, 23)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(653, 23)" end="(653, 24)" leading="" trailing="" val="."/>
                <IdentNode start="(653, 24)" end="(653, 30)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(653, 31)" end="(653, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(653, 33)" end="(653, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(653, 33)" end="(653, 39)" leading="" trailing=" " raw_val="xs.any" val="xs.any"/>
                <NullNode start="(653, 40)" end="(653, 41)">
                  <IdentNode start="(653, 40)" end="(653, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(653, 42)" end="(655, 7)">
          <AtomNode start="(653, 42)" end="(653, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(653, 45)" end="(655, 7)">
            <AtomNode start="(653, 45)" end="(653, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(654, 3)" end="(655, 7)">
              <TacticTacticseq1IndentedNode start="(654, 3)" end="(655, 7)">
                <NullNode start="(654, 3)" end="(655, 7)">
                  <OtherNode start="(654, 3)" end="(654, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ (findFinIdx? p xs).isSome = xs.any p" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findFinIdx? p { toList := xs }).isSome = { toList := xs }.any p" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(654, 3)" end="(654, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(654, 10)" end="(654, 12)">
                      <OtherNode start="(654, 10)" end="(654, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(654, 10)" end="(654, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(654, 13)" end="(654, 22)">
                      <AtomNode start="(654, 13)" end="(654, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(654, 18)" end="(654, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(654, 18)" end="(654, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(654, 18)" end="(654, 22)">
                            <OtherNode start="(654, 18)" end="(654, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(654, 18)" end="(654, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(654, 19)" end="(654, 21)">
                                <OtherNode start="(654, 19)" end="(654, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(654, 19)" end="(654, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(654, 19)" end="(654, 21)">
                                      <OtherNode start="(654, 19)" end="(654, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(654, 19)" end="(654, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(654, 21)" end="(654, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(655, 3)" end="(655, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findFinIdx? p { toList := xs }).isSome = { toList := xs }.any p" state_after="no goals" tactic="simp">
                    <AtomNode start="(655, 3)" end="(655, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(657, 1)" end="(661, 7)" name="isNone_findFinIdx?" full_name="Array.isNone_findFinIdx?">
      <CommandDeclmodifiersNode start="(657, 1)" end="(657, 8)">
        <NullNode/>
        <NullNode start="(657, 1)" end="(657, 8)">
          <OtherNode start="(657, 1)" end="(657, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(657, 1)" end="(657, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(657, 3)" end="(657, 7)">
              <OtherNode start="(657, 3)" end="(657, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(657, 3)" end="(657, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(657, 3)" end="(657, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(657, 7)" end="(657, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(658, 1)" end="(661, 7)" name="isNone_findFinIdx?" full_name="Array.isNone_findFinIdx?" _is_private_decl="False">
        <AtomNode start="(658, 1)" end="(658, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(658, 9)" end="(658, 27)">
          <IdentNode start="(658, 9)" end="(658, 27)" leading="" trailing=" " raw_val="isNone_findFinIdx?" val="isNone_findFinIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(658, 28)" end="(659, 56)">
          <NullNode start="(658, 28)" end="(658, 57)">
            <OtherNode start="(658, 28)" end="(658, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(658, 28)" end="(658, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(658, 29)" end="(658, 31)">
                <IdentNode start="(658, 29)" end="(658, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(658, 32)" end="(658, 41)">
                <AtomNode start="(658, 32)" end="(658, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(658, 34)" end="(658, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(658, 34)" end="(658, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(658, 40)" end="(658, 41)">
                    <IdentNode start="(658, 40)" end="(658, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(658, 41)" end="(658, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(658, 43)" end="(658, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(658, 43)" end="(658, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(658, 44)" end="(658, 45)">
                <IdentNode start="(658, 44)" end="(658, 45)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(658, 46)" end="(658, 56)">
                <AtomNode start="(658, 46)" end="(658, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(658, 48)" end="(658, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(658, 48)" end="(658, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(658, 50)" end="(658, 51)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(658, 52)" end="(658, 56)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(658, 56)" end="(658, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(658, 58)" end="(659, 56)">
            <AtomNode start="(658, 58)" end="(658, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(659, 5)" end="(659, 56)" kind="«term_=_»">
              <OtherNode start="(659, 5)" end="(659, 30)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(659, 5)" end="(659, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(659, 5)" end="(659, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(659, 6)" end="(659, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(659, 6)" end="(659, 20)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                    <NullNode start="(659, 21)" end="(659, 22)">
                      <IdentNode start="(659, 21)" end="(659, 22)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(659, 22)" end="(659, 23)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(659, 23)" end="(659, 24)" leading="" trailing="" val="."/>
                <IdentNode start="(659, 24)" end="(659, 30)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(659, 31)" end="(659, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(659, 33)" end="(659, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(659, 33)" end="(659, 39)" leading="" trailing=" " raw_val="xs.all" val="xs.all"/>
                <NullNode start="(659, 40)" end="(659, 56)">
                  <OtherNode start="(659, 40)" end="(659, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(659, 40)" end="(659, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(659, 41)" end="(659, 55)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(659, 41)" end="(659, 44)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(659, 45)" end="(659, 55)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(659, 45)" end="(659, 46)">
                          <IdentNode start="(659, 45)" end="(659, 46)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(659, 47)" end="(659, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(659, 50)" end="(659, 55)" kind="«term¬_»">
                          <AtomNode start="(659, 50)" end="(659, 51)" leading="" trailing=" " val="¬"/>
                          <OtherNode start="(659, 52)" end="(659, 55)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(659, 52)" end="(659, 53)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(659, 54)" end="(659, 55)">
                              <IdentNode start="(659, 54)" end="(659, 55)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(659, 55)" end="(659, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(659, 57)" end="(661, 7)">
          <AtomNode start="(659, 57)" end="(659, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(659, 60)" end="(661, 7)">
            <AtomNode start="(659, 60)" end="(659, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(660, 3)" end="(661, 7)">
              <TacticTacticseq1IndentedNode start="(660, 3)" end="(661, 7)">
                <NullNode start="(660, 3)" end="(661, 7)">
                  <OtherNode start="(660, 3)" end="(660, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ (findFinIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findFinIdx? p { toList := xs }).isNone = { toList := xs }.all fun x =&amp;gt; decide ¬p x = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(660, 3)" end="(660, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(660, 10)" end="(660, 12)">
                      <OtherNode start="(660, 10)" end="(660, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(660, 10)" end="(660, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(660, 13)" end="(660, 22)">
                      <AtomNode start="(660, 13)" end="(660, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(660, 18)" end="(660, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(660, 18)" end="(660, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(660, 18)" end="(660, 22)">
                            <OtherNode start="(660, 18)" end="(660, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(660, 18)" end="(660, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(660, 19)" end="(660, 21)">
                                <OtherNode start="(660, 19)" end="(660, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(660, 19)" end="(660, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(660, 19)" end="(660, 21)">
                                      <OtherNode start="(660, 19)" end="(660, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(660, 19)" end="(660, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(660, 21)" end="(660, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(661, 3)" end="(661, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ (findFinIdx? p { toList := xs }).isNone = { toList := xs }.all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(661, 3)" end="(661, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(663, 1)" end="(669, 27)" name="findFinIdx?_subtype" full_name="Array.findFinIdx?_subtype">
      <CommandDeclmodifiersNode start="(663, 1)" end="(663, 8)">
        <NullNode/>
        <NullNode start="(663, 1)" end="(663, 8)">
          <OtherNode start="(663, 1)" end="(663, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(663, 1)" end="(663, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(663, 3)" end="(663, 7)">
              <OtherNode start="(663, 3)" end="(663, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(663, 3)" end="(663, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(663, 3)" end="(663, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(663, 7)" end="(663, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(663, 9)" end="(669, 27)" name="findFinIdx?_subtype" full_name="Array.findFinIdx?_subtype" _is_private_decl="False">
        <AtomNode start="(663, 9)" end="(663, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(663, 17)" end="(663, 36)">
          <IdentNode start="(663, 17)" end="(663, 36)" leading="" trailing=" " raw_val="findFinIdx?_subtype" val="findFinIdx?_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(663, 37)" end="(665, 83)">
          <NullNode start="(663, 37)" end="(664, 74)">
            <OtherNode start="(663, 37)" end="(663, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(663, 37)" end="(663, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(663, 38)" end="(663, 39)">
                <IdentNode start="(663, 38)" end="(663, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(663, 40)" end="(663, 50)">
                <AtomNode start="(663, 40)" end="(663, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(663, 42)" end="(663, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(663, 42)" end="(663, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(663, 44)" end="(663, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(663, 46)" end="(663, 50)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(663, 46)" end="(663, 50)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(663, 50)" end="(663, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(663, 52)" end="(663, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(663, 52)" end="(663, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(663, 53)" end="(663, 55)">
                <IdentNode start="(663, 53)" end="(663, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(663, 56)" end="(663, 76)">
                <AtomNode start="(663, 56)" end="(663, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(663, 58)" end="(663, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(663, 58)" end="(663, 63)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(663, 64)" end="(663, 76)">
                    <OtherNode start="(663, 64)" end="(663, 76)" kind="«term{_:_//_}»">
                      <AtomNode start="(663, 64)" end="(663, 65)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(663, 66)" end="(663, 67)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(663, 68)" end="(663, 70)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(663, 71)" end="(663, 74)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(663, 71)" end="(663, 72)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(663, 73)" end="(663, 74)">
                          <IdentNode start="(663, 73)" end="(663, 74)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(663, 75)" end="(663, 76)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(663, 76)" end="(663, 77)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(664, 5)" end="(664, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(664, 5)" end="(664, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(664, 6)" end="(664, 7)">
                <IdentNode start="(664, 6)" end="(664, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(664, 8)" end="(664, 29)">
                <AtomNode start="(664, 8)" end="(664, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(664, 10)" end="(664, 29)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(664, 10)" end="(664, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(664, 10)" end="(664, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(664, 12)" end="(664, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(664, 14)" end="(664, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(664, 17)" end="(664, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(664, 17)" end="(664, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(664, 19)" end="(664, 20)">
                        <IdentNode start="(664, 19)" end="(664, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(664, 21)" end="(664, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(664, 23)" end="(664, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(664, 25)" end="(664, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(664, 29)" end="(664, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(664, 31)" end="(664, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(664, 31)" end="(664, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(664, 32)" end="(664, 33)">
                <IdentNode start="(664, 32)" end="(664, 33)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(664, 34)" end="(664, 44)">
                <AtomNode start="(664, 34)" end="(664, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(664, 36)" end="(664, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(664, 36)" end="(664, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(664, 38)" end="(664, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(664, 40)" end="(664, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(664, 44)" end="(664, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(664, 46)" end="(664, 74)">
              <AtomNode start="(664, 46)" end="(664, 47)" leading="" trailing="" val="("/>
              <NullNode start="(664, 47)" end="(664, 49)">
                <IdentNode start="(664, 47)" end="(664, 49)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(664, 50)" end="(664, 73)">
                <AtomNode start="(664, 50)" end="(664, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(664, 52)" end="(664, 73)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(664, 52)" end="(664, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(664, 54)" end="(664, 57)">
                    <IdentNode start="(664, 54)" end="(664, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(664, 56)" end="(664, 57)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(664, 57)" end="(664, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(664, 59)" end="(664, 73)" kind="«term_=_»">
                    <OtherNode start="(664, 59)" end="(664, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(664, 59)" end="(664, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(664, 61)" end="(664, 67)">
                        <OtherNode start="(664, 61)" end="(664, 67)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(664, 61)" end="(664, 62)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(664, 62)" end="(664, 66)">
                            <IdentNode start="(664, 62)" end="(664, 63)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(664, 63)" end="(664, 64)" leading="" trailing=" " val=","/>
                            <IdentNode start="(664, 65)" end="(664, 66)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(664, 66)" end="(664, 67)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(664, 68)" end="(664, 69)" leading="" trailing=" " val="="/>
                    <OtherNode start="(664, 70)" end="(664, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(664, 70)" end="(664, 71)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(664, 72)" end="(664, 73)">
                        <IdentNode start="(664, 72)" end="(664, 73)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(664, 73)" end="(664, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(664, 75)" end="(665, 83)">
            <AtomNode start="(664, 75)" end="(664, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(665, 5)" end="(665, 83)" kind="«term_=_»">
              <OtherNode start="(665, 5)" end="(665, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(665, 5)" end="(665, 19)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                <NullNode start="(665, 20)" end="(665, 21)">
                  <IdentNode start="(665, 20)" end="(665, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(665, 22)" end="(665, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(665, 24)" end="(665, 83)" kind="Lean.Parser.Term.app">
                <OtherNode start="(665, 24)" end="(665, 55)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(665, 24)" end="(665, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(665, 24)" end="(665, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(665, 25)" end="(665, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(665, 25)" end="(665, 48)" leading="" trailing=" " raw_val="xs.unattach.findFinIdx?" val="xs.unattach.findFinIdx?"/>
                      <NullNode start="(665, 49)" end="(665, 50)">
                        <IdentNode start="(665, 49)" end="(665, 50)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(665, 50)" end="(665, 51)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(665, 51)" end="(665, 52)" leading="" trailing="" val="."/>
                  <IdentNode start="(665, 52)" end="(665, 55)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(665, 56)" end="(665, 83)">
                  <OtherNode start="(665, 56)" end="(665, 83)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(665, 56)" end="(665, 57)" leading="" trailing="" val="("/>
                    <OtherNode start="(665, 57)" end="(665, 82)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(665, 57)" end="(665, 60)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(665, 61)" end="(665, 82)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(665, 61)" end="(665, 62)">
                          <IdentNode start="(665, 61)" end="(665, 62)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(665, 63)" end="(665, 65)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(665, 66)" end="(665, 82)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(665, 66)" end="(665, 72)" leading="" trailing=" " raw_val="i.cast" val="i.cast"/>
                          <NullNode start="(665, 73)" end="(665, 82)">
                            <OtherNode start="(665, 73)" end="(665, 82)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(665, 73)" end="(665, 74)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(665, 74)" end="(665, 81)">
                                <AtomNode start="(665, 74)" end="(665, 76)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(665, 77)" end="(665, 81)">
                                  <TacticTacticseq1IndentedNode start="(665, 77)" end="(665, 81)">
                                    <NullNode start="(665, 77)" end="(665, 81)">
                                      <OtherNode start="(665, 77)" end="(665, 81)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.125445&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;i : Fin xs.unattach.size&#10;⊢ xs.unattach.size = xs.size" state_after="no goals" tactic="simp">
                                        <AtomNode start="(665, 77)" end="(665, 81)" leading="" trailing="" val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(665, 81)" end="(665, 82)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(665, 82)" end="(665, 83)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(665, 84)" end="(669, 27)">
          <AtomNode start="(665, 84)" end="(665, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(665, 87)" end="(669, 27)">
            <AtomNode start="(665, 87)" end="(665, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(666, 3)" end="(669, 27)">
              <TacticTacticseq1IndentedNode start="(666, 3)" end="(669, 27)">
                <NullNode start="(666, 3)" end="(669, 27)">
                  <OtherNode start="(666, 3)" end="(666, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Prop&#10;xs : Array { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findFinIdx? f xs = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g xs.unattach)" state_after="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ findFinIdx? f { toList := toList✝ } =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g { toList := toList✝ }.unattach)" tactic="cases xs">
                    <AtomNode start="(666, 3)" end="(666, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(666, 9)" end="(666, 11)">
                      <OtherNode start="(666, 9)" end="(666, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(666, 9)" end="(666, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(667, 3)" end="(667, 69)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ findFinIdx? f { toList := toList✝ } =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g { toList := toList✝ }.unattach)" state_after="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (List.findFinIdx? g toList✝.unattach) =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g { toList := toList✝ }.unattach)" tactic="simp only [List.findFinIdx?_toArray, hf, List.findFinIdx?_subtype]">
                    <AtomNode start="(667, 3)" end="(667, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(667, 8)" end="(667, 12)">
                      <AtomNode start="(667, 8)" end="(667, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(667, 13)" end="(667, 69)">
                      <AtomNode start="(667, 13)" end="(667, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(667, 14)" end="(667, 68)">
                        <OtherNode start="(667, 14)" end="(667, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(667, 14)" end="(667, 38)" leading="" trailing="" raw_val="List.findFinIdx?_toArray" val="List.findFinIdx?_toArray" full_name="List.findFinIdx?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(667, 38)" end="(667, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(667, 40)" end="(667, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(667, 40)" end="(667, 42)" leading="" trailing="" raw_val="hf" val="hf"/>
                        </OtherNode>
                        <AtomNode start="(667, 42)" end="(667, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(667, 44)" end="(667, 68)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(667, 44)" end="(667, 68)" leading="" trailing="" raw_val="List.findFinIdx?_subtype" val="List.findFinIdx?_subtype" full_name="List.findFinIdx?_subtype" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(667, 68)" end="(667, 69)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(668, 3)" end="(668, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (List.findFinIdx? g toList✝.unattach) =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g { toList := toList✝ }.unattach)" state_after="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (List.findFinIdx? g toList✝.unattach) =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g toList✝.unattach.toArray))" tactic="rw [findFinIdx?_congr List.unattach_toArray]">
                    <AtomNode start="(668, 3)" end="(668, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(668, 6)" end="(668, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(668, 6)" end="(668, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(668, 7)" end="(668, 46)">
                        <OtherNode start="(668, 7)" end="(668, 46)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(668, 7)" end="(668, 46)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(668, 7)" end="(668, 24)" leading="" trailing=" " raw_val="findFinIdx?_congr" val="findFinIdx?_congr" full_name="Array.findFinIdx?_congr" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(608, 9)" def_end="(608, 26)"/>
                            <NullNode start="(668, 25)" end="(668, 46)">
                              <IdentNode start="(668, 25)" end="(668, 46)" leading="" trailing="" raw_val="List.unattach_toArray" val="List.unattach_toArray" full_name="List.unattach_toArray" mod_name="Init.Data.Array.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Attach.lean"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(668, 46)" end="(668, 47)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(669, 3)" end="(669, 27)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;toList✝ : List { x // p x }&#10;⊢ Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (List.findFinIdx? g toList✝.unattach) =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g toList✝.unattach.toArray))" state_after="no goals" tactic="simp [Function.comp_def]">
                    <AtomNode start="(669, 3)" end="(669, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(669, 8)" end="(669, 27)">
                      <AtomNode start="(669, 8)" end="(669, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(669, 9)" end="(669, 26)">
                        <OtherNode start="(669, 9)" end="(669, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(669, 9)" end="(669, 26)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(669, 26)" end="(669, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(671, 1)" end="(675, 3)" comment="### idxOf&#10;&#10;The verification API for `idxOf` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx` (and proved using them).&#10;-/">
      <AtomNode start="(671, 1)" end="(671, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(671, 5)" end="(675, 3)" leading="" trailing="&#10;&#10;" val="### idxOf&#10;&#10;The verification API for `idxOf` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx` (and proved using them).&#10;-/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(677, 1)" end="(684, 18)" name="idxOf_append" full_name="Array.idxOf_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(677, 1)" end="(684, 18)" name="idxOf_append" full_name="Array.idxOf_append" _is_private_decl="False">
        <AtomNode start="(677, 1)" end="(677, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(677, 9)" end="(677, 21)">
          <IdentNode start="(677, 9)" end="(677, 21)" leading="" trailing=" " raw_val="idxOf_append" val="idxOf_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(677, 22)" end="(678, 77)">
          <NullNode start="(677, 22)" end="(677, 69)">
            <OtherNode start="(677, 22)" end="(677, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(677, 22)" end="(677, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(677, 23)" end="(677, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(677, 23)" end="(677, 26)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(677, 27)" end="(677, 28)">
                  <IdentNode start="(677, 27)" end="(677, 28)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(677, 28)" end="(677, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(677, 30)" end="(677, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(677, 30)" end="(677, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(677, 31)" end="(677, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(677, 31)" end="(677, 40)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(677, 41)" end="(677, 42)">
                  <IdentNode start="(677, 41)" end="(677, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(677, 42)" end="(677, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(677, 44)" end="(677, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(677, 44)" end="(677, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(677, 45)" end="(677, 50)">
                <IdentNode start="(677, 45)" end="(677, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(677, 48)" end="(677, 50)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(677, 51)" end="(677, 60)">
                <AtomNode start="(677, 51)" end="(677, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(677, 53)" end="(677, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(677, 53)" end="(677, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(677, 59)" end="(677, 60)">
                    <IdentNode start="(677, 59)" end="(677, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(677, 60)" end="(677, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(677, 62)" end="(677, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(677, 62)" end="(677, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(677, 63)" end="(677, 64)">
                <IdentNode start="(677, 63)" end="(677, 64)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(677, 65)" end="(677, 68)">
                <AtomNode start="(677, 65)" end="(677, 66)" leading="" trailing=" " val=":"/>
                <IdentNode start="(677, 67)" end="(677, 68)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(677, 68)" end="(677, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(677, 70)" end="(678, 77)">
            <AtomNode start="(677, 70)" end="(677, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(678, 5)" end="(678, 77)" kind="«term_=_»">
              <OtherNode start="(678, 5)" end="(678, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(678, 5)" end="(678, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(678, 5)" end="(678, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(678, 5)" end="(678, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(678, 6)" end="(678, 14)" kind="«term_++_»">
                      <IdentNode start="(678, 6)" end="(678, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(678, 9)" end="(678, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(678, 12)" end="(678, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(678, 14)" end="(678, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(678, 15)" end="(678, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(678, 16)" end="(678, 21)" leading="" trailing=" " raw_val="idxOf" val="idxOf" full_name="Array.idxOf" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(678, 22)" end="(678, 23)">
                  <IdentNode start="(678, 22)" end="(678, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(678, 24)" end="(678, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(678, 26)" end="(678, 77)" kind="termIfThenElse">
                <AtomNode start="(678, 26)" end="(678, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(678, 29)" end="(678, 35)" kind="«term_∈_»">
                  <IdentNode start="(678, 29)" end="(678, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(678, 31)" end="(678, 32)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(678, 33)" end="(678, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(678, 36)" end="(678, 40)" leading="" trailing=" " val="then"/>
                <OtherNode start="(678, 41)" end="(678, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(678, 41)" end="(678, 49)" leading="" trailing=" " raw_val="xs.idxOf" val="xs.idxOf"/>
                  <NullNode start="(678, 50)" end="(678, 51)">
                    <IdentNode start="(678, 50)" end="(678, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(678, 52)" end="(678, 56)" leading="" trailing=" " val="else"/>
                <OtherNode start="(678, 57)" end="(678, 77)" kind="«term_+_»">
                  <OtherNode start="(678, 57)" end="(678, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(678, 57)" end="(678, 65)" leading="" trailing=" " raw_val="ys.idxOf" val="ys.idxOf"/>
                    <NullNode start="(678, 66)" end="(678, 67)">
                      <IdentNode start="(678, 66)" end="(678, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(678, 68)" end="(678, 69)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(678, 70)" end="(678, 77)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(678, 78)" end="(684, 18)">
          <AtomNode start="(678, 78)" end="(678, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(678, 81)" end="(684, 18)">
            <AtomNode start="(678, 81)" end="(678, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(679, 3)" end="(684, 18)">
              <TacticTacticseq1IndentedNode start="(679, 3)" end="(684, 18)">
                <NullNode start="(679, 3)" end="(684, 18)">
                  <OtherNode start="(679, 3)" end="(679, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;⊢ idxOf a (xs ++ ys) = if a ∈ xs then idxOf a xs else idxOf a ys + xs.size" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;⊢ (if findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size then findIdx (fun x =&amp;gt; x == a) xs&#10;    else findIdx (fun x =&amp;gt; x == a) ys + xs.size) =&#10;    if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" tactic="rw [idxOf, findIdx_append]">
                    <AtomNode start="(679, 3)" end="(679, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(679, 6)" end="(679, 29)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(679, 6)" end="(679, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(679, 7)" end="(679, 28)">
                        <OtherNode start="(679, 7)" end="(679, 12)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(679, 7)" end="(679, 12)" leading="" trailing="" raw_val="idxOf" val="idxOf" full_name="Array.idxOf" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(679, 12)" end="(679, 13)" leading="" trailing=" " val=","/>
                        <OtherNode start="(679, 14)" end="(679, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(679, 14)" end="(679, 28)" leading="" trailing="" raw_val="findIdx_append" val="findIdx_append" full_name="Array.findIdx_append" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean" def_start="(427, 9)" def_end="(427, 23)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(679, 28)" end="(679, 29)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(680, 3)" end="(680, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;⊢ (if findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size then findIdx (fun x =&amp;gt; x == a) xs&#10;    else findIdx (fun x =&amp;gt; x == a) ys + xs.size) =&#10;    if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" state_after="case isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) xs = if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size&#10;&#10;case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) ys + xs.size =&#10;    if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(680, 3)" end="(680, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(680, 3)" end="(680, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(680, 9)" end="(680, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(680, 13)" end="(680, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(680, 13)" end="(680, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(680, 22)" end="(680, 23)">
                        <LeanBinderidentNode start="(680, 22)" end="(680, 23)">
                          <IdentNode start="(680, 22)" end="(680, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(681, 3)" end="(682, 18)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) xs = if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size&#10;&#10;case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) ys + xs.size =&#10;    if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" state_after="case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) ys + xs.size =&#10;    if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" tactic="· rw [if_pos]&#10;  simpa using h">
                    <OtherNode start="(681, 3)" end="(681, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(681, 3)" end="(681, 4)" kind="patternIgnore">
                        <OtherNode start="(681, 3)" end="(681, 4)" kind="token.«· »">
                          <AtomNode start="(681, 3)" end="(681, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(681, 5)" end="(682, 18)">
                      <TacticTacticseq1IndentedNode start="(681, 5)" end="(682, 18)">
                        <NullNode start="(681, 5)" end="(682, 18)">
                          <OtherNode start="(681, 5)" end="(681, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) xs = if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" state_after="case isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ a ∈ xs" tactic="rw [if_pos]">
                            <AtomNode start="(681, 5)" end="(681, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(681, 8)" end="(681, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(681, 8)" end="(681, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(681, 9)" end="(681, 15)">
                                <OtherNode start="(681, 9)" end="(681, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(681, 9)" end="(681, 15)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(681, 15)" end="(681, 16)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(682, 5)" end="(682, 18)" kind="Lean.Parser.Tactic.simpa" state_before="case isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ a ∈ xs" state_after="no goals" tactic="simpa using h">
                            <AtomNode start="(682, 5)" end="(682, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(682, 11)" end="(682, 18)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(682, 11)" end="(682, 18)">
                                <AtomNode start="(682, 11)" end="(682, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(682, 17)" end="(682, 18)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(683, 3)" end="(684, 18)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) ys + xs.size =&#10;    if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" state_after="no goals" tactic="· rw [if_neg]&#10;  simpa using h">
                    <OtherNode start="(683, 3)" end="(683, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(683, 3)" end="(683, 4)" kind="patternIgnore">
                        <OtherNode start="(683, 3)" end="(683, 4)" kind="token.«· »">
                          <AtomNode start="(683, 3)" end="(683, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(683, 5)" end="(684, 18)">
                      <TacticTacticseq1IndentedNode start="(683, 5)" end="(684, 18)">
                        <NullNode start="(683, 5)" end="(684, 18)">
                          <OtherNode start="(683, 5)" end="(683, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ findIdx (fun x =&amp;gt; x == a) ys + xs.size =&#10;    if a ∈ xs then findIdx (fun x =&amp;gt; x == a) xs else findIdx (fun x =&amp;gt; x == a) ys + xs.size" state_after="case isFalse.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ ¬a ∈ xs" tactic="rw [if_neg]">
                            <AtomNode start="(683, 5)" end="(683, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(683, 8)" end="(683, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(683, 8)" end="(683, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(683, 9)" end="(683, 15)">
                                <OtherNode start="(683, 9)" end="(683, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(683, 9)" end="(683, 15)" leading="" trailing="" raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(683, 15)" end="(683, 16)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(684, 5)" end="(684, 18)" kind="Lean.Parser.Tactic.simpa" state_before="case isFalse.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) xs &amp;lt; xs.size&#10;⊢ ¬a ∈ xs" state_after="no goals" tactic="simpa using h">
                            <AtomNode start="(684, 5)" end="(684, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(684, 11)" end="(684, 18)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(684, 11)" end="(684, 18)">
                                <AtomNode start="(684, 11)" end="(684, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(684, 17)" end="(684, 18)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(686, 1)" end="(688, 49)" name="idxOf_eq_size" full_name="Array.idxOf_eq_size">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(686, 1)" end="(688, 49)" name="idxOf_eq_size" full_name="Array.idxOf_eq_size" _is_private_decl="False">
        <AtomNode start="(686, 1)" end="(686, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(686, 9)" end="(686, 22)">
          <IdentNode start="(686, 9)" end="(686, 22)" leading="" trailing=" " raw_val="idxOf_eq_size" val="idxOf_eq_size"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(686, 23)" end="(686, 95)">
          <NullNode start="(686, 23)" end="(686, 72)">
            <OtherNode start="(686, 23)" end="(686, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(686, 23)" end="(686, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(686, 24)" end="(686, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(686, 24)" end="(686, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(686, 28)" end="(686, 29)">
                  <IdentNode start="(686, 28)" end="(686, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(686, 29)" end="(686, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(686, 31)" end="(686, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(686, 31)" end="(686, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(686, 32)" end="(686, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(686, 32)" end="(686, 41)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(686, 42)" end="(686, 43)">
                  <IdentNode start="(686, 42)" end="(686, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(686, 43)" end="(686, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(686, 45)" end="(686, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(686, 45)" end="(686, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(686, 46)" end="(686, 48)">
                <IdentNode start="(686, 46)" end="(686, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(686, 49)" end="(686, 58)">
                <AtomNode start="(686, 49)" end="(686, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(686, 51)" end="(686, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(686, 51)" end="(686, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(686, 57)" end="(686, 58)">
                    <IdentNode start="(686, 57)" end="(686, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(686, 58)" end="(686, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(686, 60)" end="(686, 72)">
              <AtomNode start="(686, 60)" end="(686, 61)" leading="" trailing="" val="("/>
              <NullNode start="(686, 61)" end="(686, 62)">
                <IdentNode start="(686, 61)" end="(686, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(686, 63)" end="(686, 71)">
                <AtomNode start="(686, 63)" end="(686, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(686, 65)" end="(686, 71)" kind="«term_∉_»">
                  <IdentNode start="(686, 65)" end="(686, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(686, 67)" end="(686, 68)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(686, 69)" end="(686, 71)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(686, 71)" end="(686, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(686, 73)" end="(686, 95)">
            <AtomNode start="(686, 73)" end="(686, 74)" leading="" trailing=" " val=":"/>
            <OtherNode start="(686, 75)" end="(686, 95)" kind="«term_=_»">
              <OtherNode start="(686, 75)" end="(686, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(686, 75)" end="(686, 83)" leading="" trailing=" " raw_val="xs.idxOf" val="xs.idxOf"/>
                <NullNode start="(686, 84)" end="(686, 85)">
                  <IdentNode start="(686, 84)" end="(686, 85)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(686, 86)" end="(686, 87)" leading="" trailing=" " val="="/>
              <IdentNode start="(686, 88)" end="(686, 95)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(686, 96)" end="(688, 49)">
          <AtomNode start="(686, 96)" end="(686, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(686, 99)" end="(688, 49)">
            <AtomNode start="(686, 99)" end="(686, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(687, 3)" end="(688, 49)">
              <TacticTacticseq1IndentedNode start="(687, 3)" end="(688, 49)">
                <NullNode start="(687, 3)" end="(688, 49)">
                  <OtherNode start="(687, 3)" end="(687, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ idxOf a xs = xs.size" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ idxOf a { toList := xs } = { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(687, 3)" end="(687, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(687, 10)" end="(687, 12)">
                      <OtherNode start="(687, 10)" end="(687, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(687, 10)" end="(687, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(687, 13)" end="(687, 22)">
                      <AtomNode start="(687, 13)" end="(687, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(687, 18)" end="(687, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(687, 18)" end="(687, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(687, 18)" end="(687, 22)">
                            <OtherNode start="(687, 18)" end="(687, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(687, 18)" end="(687, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(687, 19)" end="(687, 21)">
                                <OtherNode start="(687, 19)" end="(687, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(687, 19)" end="(687, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(687, 19)" end="(687, 21)">
                                      <OtherNode start="(687, 19)" end="(687, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(687, 19)" end="(687, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(687, 21)" end="(687, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(688, 3)" end="(688, 49)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ idxOf a { toList := xs } = { toList := xs }.size" state_after="no goals" tactic="simp [List.idxOf_eq_length (by simpa using h)]">
                    <AtomNode start="(688, 3)" end="(688, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(688, 8)" end="(688, 49)">
                      <AtomNode start="(688, 8)" end="(688, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(688, 9)" end="(688, 48)">
                        <OtherNode start="(688, 9)" end="(688, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(688, 9)" end="(688, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(688, 9)" end="(688, 29)" leading="" trailing=" " raw_val="List.idxOf_eq_length" val="List.idxOf_eq_length" full_name="List.idxOf_eq_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                            <NullNode start="(688, 30)" end="(688, 48)">
                              <OtherNode start="(688, 30)" end="(688, 48)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(688, 30)" end="(688, 31)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(688, 31)" end="(688, 47)">
                                  <AtomNode start="(688, 31)" end="(688, 33)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(688, 34)" end="(688, 47)">
                                    <TacticTacticseq1IndentedNode start="(688, 34)" end="(688, 47)">
                                      <NullNode start="(688, 34)" end="(688, 47)">
                                        <OtherNode start="(688, 34)" end="(688, 47)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ ¬?m.128652 ∈ ?m.128655" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(688, 34)" end="(688, 39)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(688, 40)" end="(688, 47)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(688, 40)" end="(688, 47)">
                                              <AtomNode start="(688, 40)" end="(688, 45)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(688, 46)" end="(688, 47)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(688, 47)" end="(688, 48)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(688, 48)" end="(688, 49)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(690, 1)" end="(692, 49)" name="idxOf_lt_length" full_name="Array.idxOf_lt_length">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(690, 1)" end="(692, 49)" name="idxOf_lt_length" full_name="Array.idxOf_lt_length" _is_private_decl="False">
        <AtomNode start="(690, 1)" end="(690, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(690, 9)" end="(690, 24)">
          <IdentNode start="(690, 9)" end="(690, 24)" leading="" trailing=" " raw_val="idxOf_lt_length" val="idxOf_lt_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(690, 25)" end="(690, 97)">
          <NullNode start="(690, 25)" end="(690, 74)">
            <OtherNode start="(690, 25)" end="(690, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(690, 25)" end="(690, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(690, 26)" end="(690, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(690, 26)" end="(690, 29)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(690, 30)" end="(690, 31)">
                  <IdentNode start="(690, 30)" end="(690, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(690, 31)" end="(690, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(690, 33)" end="(690, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(690, 33)" end="(690, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(690, 34)" end="(690, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(690, 34)" end="(690, 43)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(690, 44)" end="(690, 45)">
                  <IdentNode start="(690, 44)" end="(690, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(690, 45)" end="(690, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(690, 47)" end="(690, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(690, 47)" end="(690, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(690, 48)" end="(690, 50)">
                <IdentNode start="(690, 48)" end="(690, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(690, 51)" end="(690, 60)">
                <AtomNode start="(690, 51)" end="(690, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(690, 53)" end="(690, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(690, 53)" end="(690, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(690, 59)" end="(690, 60)">
                    <IdentNode start="(690, 59)" end="(690, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(690, 60)" end="(690, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(690, 62)" end="(690, 74)">
              <AtomNode start="(690, 62)" end="(690, 63)" leading="" trailing="" val="("/>
              <NullNode start="(690, 63)" end="(690, 64)">
                <IdentNode start="(690, 63)" end="(690, 64)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(690, 65)" end="(690, 73)">
                <AtomNode start="(690, 65)" end="(690, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(690, 67)" end="(690, 73)" kind="«term_∈_»">
                  <IdentNode start="(690, 67)" end="(690, 68)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(690, 69)" end="(690, 70)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(690, 71)" end="(690, 73)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(690, 73)" end="(690, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(690, 75)" end="(690, 97)">
            <AtomNode start="(690, 75)" end="(690, 76)" leading="" trailing=" " val=":"/>
            <OtherNode start="(690, 77)" end="(690, 97)" kind="«term_&amp;lt;_»">
              <OtherNode start="(690, 77)" end="(690, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(690, 77)" end="(690, 85)" leading="" trailing=" " raw_val="xs.idxOf" val="xs.idxOf"/>
                <NullNode start="(690, 86)" end="(690, 87)">
                  <IdentNode start="(690, 86)" end="(690, 87)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(690, 88)" end="(690, 89)" leading="" trailing=" " val="&amp;lt;"/>
              <IdentNode start="(690, 90)" end="(690, 97)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(690, 98)" end="(692, 49)">
          <AtomNode start="(690, 98)" end="(690, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(690, 101)" end="(692, 49)">
            <AtomNode start="(690, 101)" end="(690, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(691, 3)" end="(692, 49)">
              <TacticTacticseq1IndentedNode start="(691, 3)" end="(692, 49)">
                <NullNode start="(691, 3)" end="(692, 49)">
                  <OtherNode start="(691, 3)" end="(691, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;h : a ∈ xs&#10;⊢ idxOf a xs &amp;lt; xs.size" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;⊢ idxOf a { toList := xs } &amp;lt; { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(691, 3)" end="(691, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(691, 10)" end="(691, 12)">
                      <OtherNode start="(691, 10)" end="(691, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(691, 10)" end="(691, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(691, 13)" end="(691, 22)">
                      <AtomNode start="(691, 13)" end="(691, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(691, 18)" end="(691, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(691, 18)" end="(691, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(691, 18)" end="(691, 22)">
                            <OtherNode start="(691, 18)" end="(691, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(691, 18)" end="(691, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(691, 19)" end="(691, 21)">
                                <OtherNode start="(691, 19)" end="(691, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(691, 19)" end="(691, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(691, 19)" end="(691, 21)">
                                      <OtherNode start="(691, 19)" end="(691, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(691, 19)" end="(691, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(691, 21)" end="(691, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(692, 3)" end="(692, 49)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;⊢ idxOf a { toList := xs } &amp;lt; { toList := xs }.size" state_after="no goals" tactic="simp [List.idxOf_lt_length (by simpa using h)]">
                    <AtomNode start="(692, 3)" end="(692, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(692, 8)" end="(692, 49)">
                      <AtomNode start="(692, 8)" end="(692, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(692, 9)" end="(692, 48)">
                        <OtherNode start="(692, 9)" end="(692, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(692, 9)" end="(692, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(692, 9)" end="(692, 29)" leading="" trailing=" " raw_val="List.idxOf_lt_length" val="List.idxOf_lt_length" full_name="List.idxOf_lt_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                            <NullNode start="(692, 30)" end="(692, 48)">
                              <OtherNode start="(692, 30)" end="(692, 48)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(692, 30)" end="(692, 31)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(692, 31)" end="(692, 47)">
                                  <AtomNode start="(692, 31)" end="(692, 33)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(692, 34)" end="(692, 47)">
                                    <TacticTacticseq1IndentedNode start="(692, 34)" end="(692, 47)">
                                      <NullNode start="(692, 34)" end="(692, 47)">
                                        <OtherNode start="(692, 34)" end="(692, 47)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;⊢ ?m.129011 ∈ ?m.129014" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(692, 34)" end="(692, 39)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(692, 40)" end="(692, 47)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(692, 40)" end="(692, 47)">
                                              <AtomNode start="(692, 40)" end="(692, 45)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(692, 46)" end="(692, 47)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(692, 47)" end="(692, 48)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(692, 48)" end="(692, 49)" leading="" trailing="&#10;&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(695, 1)" end="(699, 3)" comment="### idxOf?&#10;&#10;The verification API for `idxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx?` (and proved using them).&#10;-/">
      <AtomNode start="(695, 1)" end="(695, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(695, 5)" end="(699, 3)" leading="" trailing="&#10;&#10;" val="### idxOf?&#10;&#10;The verification API for `idxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx?` (and proved using them).&#10;-/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(701, 1)" end="(701, 82)" name="idxOf?_empty" full_name="Array.idxOf?_empty">
      <CommandDeclmodifiersNode start="(701, 1)" end="(701, 8)">
        <NullNode/>
        <NullNode start="(701, 1)" end="(701, 8)">
          <OtherNode start="(701, 1)" end="(701, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(701, 1)" end="(701, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(701, 3)" end="(701, 7)">
              <OtherNode start="(701, 3)" end="(701, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(701, 3)" end="(701, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(701, 3)" end="(701, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(701, 7)" end="(701, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(701, 9)" end="(701, 82)" name="idxOf?_empty" full_name="Array.idxOf?_empty" _is_private_decl="False">
        <AtomNode start="(701, 9)" end="(701, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(701, 17)" end="(701, 29)">
          <IdentNode start="(701, 17)" end="(701, 29)" leading="" trailing=" " raw_val="idxOf?_empty" val="idxOf?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(701, 30)" end="(701, 71)">
          <NullNode start="(701, 30)" end="(701, 37)">
            <OtherNode start="(701, 30)" end="(701, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(701, 30)" end="(701, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(701, 31)" end="(701, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(701, 31)" end="(701, 34)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(701, 35)" end="(701, 36)">
                  <IdentNode start="(701, 35)" end="(701, 36)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(701, 36)" end="(701, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(701, 38)" end="(701, 71)">
            <AtomNode start="(701, 38)" end="(701, 39)" leading="" trailing=" " val=":"/>
            <OtherNode start="(701, 40)" end="(701, 71)" kind="«term_=_»">
              <OtherNode start="(701, 40)" end="(701, 64)" kind="Lean.Parser.Term.app">
                <OtherNode start="(701, 40)" end="(701, 62)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(701, 40)" end="(701, 55)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(701, 40)" end="(701, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(701, 41)" end="(701, 44)" kind="«term#[_,]»">
                      <AtomNode start="(701, 41)" end="(701, 43)" leading="" trailing="" val="#["/>
                      <NullNode/>
                      <AtomNode start="(701, 43)" end="(701, 44)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(701, 45)" end="(701, 46)" leading="" trailing=" " val=":"/>
                    <NullNode start="(701, 47)" end="(701, 54)">
                      <OtherNode start="(701, 47)" end="(701, 54)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(701, 47)" end="(701, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(701, 53)" end="(701, 54)">
                          <IdentNode start="(701, 53)" end="(701, 54)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(701, 54)" end="(701, 55)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(701, 55)" end="(701, 56)" leading="" trailing="" val="."/>
                  <IdentNode start="(701, 56)" end="(701, 62)" leading="" trailing=" " raw_val="idxOf?" val="idxOf?" full_name="Array.idxOf?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(701, 63)" end="(701, 64)">
                  <IdentNode start="(701, 63)" end="(701, 64)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(701, 65)" end="(701, 66)" leading="" trailing=" " val="="/>
              <IdentNode start="(701, 67)" end="(701, 71)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(701, 72)" end="(701, 82)">
          <AtomNode start="(701, 72)" end="(701, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(701, 75)" end="(701, 82)">
            <AtomNode start="(701, 75)" end="(701, 77)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(701, 78)" end="(701, 82)">
              <TacticTacticseq1IndentedNode start="(701, 78)" end="(701, 82)">
                <NullNode start="(701, 78)" end="(701, 82)">
                  <OtherNode start="(701, 78)" end="(701, 82)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;inst✝ : BEq α&#10;⊢ #[].idxOf? a = none" state_after="no goals" tactic="simp">
                    <AtomNode start="(701, 78)" end="(701, 82)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(703, 1)" end="(706, 33)" name="idxOf?_eq_none_iff" full_name="Array.idxOf?_eq_none_iff">
      <CommandDeclmodifiersNode start="(703, 1)" end="(703, 8)">
        <NullNode/>
        <NullNode start="(703, 1)" end="(703, 8)">
          <OtherNode start="(703, 1)" end="(703, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(703, 1)" end="(703, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(703, 3)" end="(703, 7)">
              <OtherNode start="(703, 3)" end="(703, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(703, 3)" end="(703, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(703, 3)" end="(703, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(703, 7)" end="(703, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(703, 9)" end="(706, 33)" name="idxOf?_eq_none_iff" full_name="Array.idxOf?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(703, 9)" end="(703, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(703, 17)" end="(703, 35)">
          <IdentNode start="(703, 17)" end="(703, 35)" leading="" trailing=" " raw_val="idxOf?_eq_none_iff" val="idxOf?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(703, 36)" end="(704, 32)">
          <NullNode start="(703, 36)" end="(703, 80)">
            <OtherNode start="(703, 36)" end="(703, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(703, 36)" end="(703, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(703, 37)" end="(703, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(703, 37)" end="(703, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(703, 41)" end="(703, 42)">
                  <IdentNode start="(703, 41)" end="(703, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(703, 42)" end="(703, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(703, 44)" end="(703, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(703, 44)" end="(703, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(703, 45)" end="(703, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(703, 45)" end="(703, 54)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(703, 55)" end="(703, 56)">
                  <IdentNode start="(703, 55)" end="(703, 56)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(703, 56)" end="(703, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(703, 58)" end="(703, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(703, 58)" end="(703, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(703, 59)" end="(703, 61)">
                <IdentNode start="(703, 59)" end="(703, 61)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(703, 62)" end="(703, 71)">
                <AtomNode start="(703, 62)" end="(703, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(703, 64)" end="(703, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(703, 64)" end="(703, 69)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(703, 70)" end="(703, 71)">
                    <IdentNode start="(703, 70)" end="(703, 71)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(703, 71)" end="(703, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(703, 73)" end="(703, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(703, 73)" end="(703, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(703, 74)" end="(703, 75)">
                <IdentNode start="(703, 74)" end="(703, 75)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(703, 76)" end="(703, 79)">
                <AtomNode start="(703, 76)" end="(703, 77)" leading="" trailing=" " val=":"/>
                <IdentNode start="(703, 78)" end="(703, 79)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(703, 79)" end="(703, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(703, 81)" end="(704, 32)">
            <AtomNode start="(703, 81)" end="(703, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(704, 5)" end="(704, 32)" kind="«term_↔_»">
              <OtherNode start="(704, 5)" end="(704, 23)" kind="«term_=_»">
                <OtherNode start="(704, 5)" end="(704, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(704, 5)" end="(704, 14)" leading="" trailing=" " raw_val="xs.idxOf?" val="xs.idxOf?"/>
                  <NullNode start="(704, 15)" end="(704, 16)">
                    <IdentNode start="(704, 15)" end="(704, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(704, 17)" end="(704, 18)" leading="" trailing=" " val="="/>
                <IdentNode start="(704, 19)" end="(704, 23)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(704, 24)" end="(704, 25)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(704, 26)" end="(704, 32)" kind="«term_∉_»">
                <IdentNode start="(704, 26)" end="(704, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(704, 28)" end="(704, 29)" leading="" trailing=" " val="∉"/>
                <IdentNode start="(704, 30)" end="(704, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(704, 33)" end="(706, 33)">
          <AtomNode start="(704, 33)" end="(704, 35)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(704, 36)" end="(706, 33)">
            <AtomNode start="(704, 36)" end="(704, 38)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(705, 3)" end="(706, 33)">
              <TacticTacticseq1IndentedNode start="(705, 3)" end="(706, 33)">
                <NullNode start="(705, 3)" end="(706, 33)">
                  <OtherNode start="(705, 3)" end="(705, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ xs.idxOf? a = none ↔ ¬a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.idxOf? a = none ↔ ¬a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(705, 3)" end="(705, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(705, 10)" end="(705, 12)">
                      <OtherNode start="(705, 10)" end="(705, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(705, 10)" end="(705, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(705, 13)" end="(705, 22)">
                      <AtomNode start="(705, 13)" end="(705, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(705, 18)" end="(705, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(705, 18)" end="(705, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(705, 18)" end="(705, 22)">
                            <OtherNode start="(705, 18)" end="(705, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(705, 18)" end="(705, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(705, 19)" end="(705, 21)">
                                <OtherNode start="(705, 19)" end="(705, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(705, 19)" end="(705, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(705, 19)" end="(705, 21)">
                                      <OtherNode start="(705, 19)" end="(705, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(705, 19)" end="(705, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(705, 21)" end="(705, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(706, 3)" end="(706, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.idxOf? a = none ↔ ¬a ∈ { toList := xs }" state_after="no goals" tactic="simp [List.idxOf?_eq_none_iff]">
                    <AtomNode start="(706, 3)" end="(706, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(706, 8)" end="(706, 33)">
                      <AtomNode start="(706, 8)" end="(706, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(706, 9)" end="(706, 32)">
                        <OtherNode start="(706, 9)" end="(706, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(706, 9)" end="(706, 32)" leading="" trailing="" raw_val="List.idxOf?_eq_none_iff" val="List.idxOf?_eq_none_iff" full_name="List.idxOf?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(706, 32)" end="(706, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(708, 1)" end="(712, 7)" name="isSome_idxOf?" full_name="Array.isSome_idxOf?">
      <CommandDeclmodifiersNode start="(708, 1)" end="(708, 8)">
        <NullNode/>
        <NullNode start="(708, 1)" end="(708, 8)">
          <OtherNode start="(708, 1)" end="(708, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(708, 1)" end="(708, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(708, 3)" end="(708, 7)">
              <OtherNode start="(708, 3)" end="(708, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(708, 3)" end="(708, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(708, 3)" end="(708, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(708, 7)" end="(708, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(709, 1)" end="(712, 7)" name="isSome_idxOf?" full_name="Array.isSome_idxOf?" _is_private_decl="False">
        <AtomNode start="(709, 1)" end="(709, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(709, 9)" end="(709, 22)">
          <IdentNode start="(709, 9)" end="(709, 22)" leading="" trailing=" " raw_val="isSome_idxOf?" val="isSome_idxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(709, 23)" end="(710, 34)">
          <NullNode start="(709, 23)" end="(709, 67)">
            <OtherNode start="(709, 23)" end="(709, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(709, 23)" end="(709, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(709, 24)" end="(709, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(709, 24)" end="(709, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(709, 28)" end="(709, 29)">
                  <IdentNode start="(709, 28)" end="(709, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(709, 29)" end="(709, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(709, 31)" end="(709, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(709, 31)" end="(709, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(709, 32)" end="(709, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(709, 32)" end="(709, 41)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(709, 42)" end="(709, 43)">
                  <IdentNode start="(709, 42)" end="(709, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(709, 43)" end="(709, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(709, 45)" end="(709, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(709, 45)" end="(709, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(709, 46)" end="(709, 48)">
                <IdentNode start="(709, 46)" end="(709, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(709, 49)" end="(709, 58)">
                <AtomNode start="(709, 49)" end="(709, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(709, 51)" end="(709, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(709, 51)" end="(709, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(709, 57)" end="(709, 58)">
                    <IdentNode start="(709, 57)" end="(709, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(709, 58)" end="(709, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(709, 60)" end="(709, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(709, 60)" end="(709, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(709, 61)" end="(709, 62)">
                <IdentNode start="(709, 61)" end="(709, 62)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(709, 63)" end="(709, 66)">
                <AtomNode start="(709, 63)" end="(709, 64)" leading="" trailing=" " val=":"/>
                <IdentNode start="(709, 65)" end="(709, 66)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(709, 66)" end="(709, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(709, 68)" end="(710, 34)">
            <AtomNode start="(709, 68)" end="(709, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(710, 5)" end="(710, 34)" kind="«term_↔_»">
              <OtherNode start="(710, 5)" end="(710, 25)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(710, 5)" end="(710, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(710, 5)" end="(710, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(710, 6)" end="(710, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(710, 6)" end="(710, 15)" leading="" trailing=" " raw_val="xs.idxOf?" val="xs.idxOf?"/>
                    <NullNode start="(710, 16)" end="(710, 17)">
                      <IdentNode start="(710, 16)" end="(710, 17)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(710, 17)" end="(710, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(710, 18)" end="(710, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(710, 19)" end="(710, 25)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(710, 26)" end="(710, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(710, 28)" end="(710, 34)" kind="«term_∈_»">
                <IdentNode start="(710, 28)" end="(710, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(710, 30)" end="(710, 31)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(710, 32)" end="(710, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(710, 35)" end="(712, 7)">
          <AtomNode start="(710, 35)" end="(710, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(710, 38)" end="(712, 7)">
            <AtomNode start="(710, 38)" end="(710, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(711, 3)" end="(712, 7)">
              <TacticTacticseq1IndentedNode start="(711, 3)" end="(712, 7)">
                <NullNode start="(711, 3)" end="(712, 7)">
                  <OtherNode start="(711, 3)" end="(711, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ (xs.idxOf? a).isSome = true ↔ a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ ({ toList := xs }.idxOf? a).isSome = true ↔ a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(711, 3)" end="(711, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(711, 10)" end="(711, 12)">
                      <OtherNode start="(711, 10)" end="(711, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(711, 10)" end="(711, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(711, 13)" end="(711, 22)">
                      <AtomNode start="(711, 13)" end="(711, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(711, 18)" end="(711, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(711, 18)" end="(711, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(711, 18)" end="(711, 22)">
                            <OtherNode start="(711, 18)" end="(711, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(711, 18)" end="(711, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(711, 19)" end="(711, 21)">
                                <OtherNode start="(711, 19)" end="(711, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(711, 19)" end="(711, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(711, 19)" end="(711, 21)">
                                      <OtherNode start="(711, 19)" end="(711, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(711, 19)" end="(711, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(711, 21)" end="(711, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(712, 3)" end="(712, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ ({ toList := xs }.idxOf? a).isSome = true ↔ a ∈ { toList := xs }" state_after="no goals" tactic="simp">
                    <AtomNode start="(712, 3)" end="(712, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(714, 1)" end="(718, 7)" name="isNone_idxOf?" full_name="Array.isNone_idxOf?">
      <CommandDeclmodifiersNode start="(714, 1)" end="(714, 8)">
        <NullNode/>
        <NullNode start="(714, 1)" end="(714, 8)">
          <OtherNode start="(714, 1)" end="(714, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(714, 1)" end="(714, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(714, 3)" end="(714, 7)">
              <OtherNode start="(714, 3)" end="(714, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(714, 3)" end="(714, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(714, 3)" end="(714, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(714, 7)" end="(714, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(715, 1)" end="(718, 7)" name="isNone_idxOf?" full_name="Array.isNone_idxOf?" _is_private_decl="False">
        <AtomNode start="(715, 1)" end="(715, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(715, 9)" end="(715, 22)">
          <IdentNode start="(715, 9)" end="(715, 22)" leading="" trailing=" " raw_val="isNone_idxOf?" val="isNone_idxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(715, 23)" end="(716, 36)">
          <NullNode start="(715, 23)" end="(715, 67)">
            <OtherNode start="(715, 23)" end="(715, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(715, 23)" end="(715, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(715, 24)" end="(715, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(715, 24)" end="(715, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(715, 28)" end="(715, 29)">
                  <IdentNode start="(715, 28)" end="(715, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(715, 29)" end="(715, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(715, 31)" end="(715, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(715, 31)" end="(715, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(715, 32)" end="(715, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(715, 32)" end="(715, 41)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(715, 42)" end="(715, 43)">
                  <IdentNode start="(715, 42)" end="(715, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(715, 43)" end="(715, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(715, 45)" end="(715, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(715, 45)" end="(715, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(715, 46)" end="(715, 48)">
                <IdentNode start="(715, 46)" end="(715, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(715, 49)" end="(715, 58)">
                <AtomNode start="(715, 49)" end="(715, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(715, 51)" end="(715, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(715, 51)" end="(715, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(715, 57)" end="(715, 58)">
                    <IdentNode start="(715, 57)" end="(715, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(715, 58)" end="(715, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(715, 60)" end="(715, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(715, 60)" end="(715, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(715, 61)" end="(715, 62)">
                <IdentNode start="(715, 61)" end="(715, 62)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(715, 63)" end="(715, 66)">
                <AtomNode start="(715, 63)" end="(715, 64)" leading="" trailing=" " val=":"/>
                <IdentNode start="(715, 65)" end="(715, 66)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(715, 66)" end="(715, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(715, 68)" end="(716, 36)">
            <AtomNode start="(715, 68)" end="(715, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(716, 5)" end="(716, 36)" kind="«term_=_»">
              <OtherNode start="(716, 5)" end="(716, 25)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(716, 5)" end="(716, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(716, 5)" end="(716, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(716, 6)" end="(716, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(716, 6)" end="(716, 15)" leading="" trailing=" " raw_val="xs.idxOf?" val="xs.idxOf?"/>
                    <NullNode start="(716, 16)" end="(716, 17)">
                      <IdentNode start="(716, 16)" end="(716, 17)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(716, 17)" end="(716, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(716, 18)" end="(716, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(716, 19)" end="(716, 25)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(716, 26)" end="(716, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(716, 28)" end="(716, 36)" kind="«term¬_»">
                <AtomNode start="(716, 28)" end="(716, 29)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(716, 30)" end="(716, 36)" kind="«term_∈_»">
                  <IdentNode start="(716, 30)" end="(716, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(716, 32)" end="(716, 33)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(716, 34)" end="(716, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(716, 37)" end="(718, 7)">
          <AtomNode start="(716, 37)" end="(716, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(716, 40)" end="(718, 7)">
            <AtomNode start="(716, 40)" end="(716, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(717, 3)" end="(718, 7)">
              <TacticTacticseq1IndentedNode start="(717, 3)" end="(718, 7)">
                <NullNode start="(717, 3)" end="(718, 7)">
                  <OtherNode start="(717, 3)" end="(717, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ ((xs.idxOf? a).isNone = true) = ¬a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ (({ toList := xs }.idxOf? a).isNone = true) = ¬a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(717, 3)" end="(717, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(717, 10)" end="(717, 12)">
                      <OtherNode start="(717, 10)" end="(717, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(717, 10)" end="(717, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(717, 13)" end="(717, 22)">
                      <AtomNode start="(717, 13)" end="(717, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(717, 18)" end="(717, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(717, 18)" end="(717, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(717, 18)" end="(717, 22)">
                            <OtherNode start="(717, 18)" end="(717, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(717, 18)" end="(717, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(717, 19)" end="(717, 21)">
                                <OtherNode start="(717, 19)" end="(717, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(717, 19)" end="(717, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(717, 19)" end="(717, 21)">
                                      <OtherNode start="(717, 19)" end="(717, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(717, 19)" end="(717, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(717, 21)" end="(717, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(718, 3)" end="(718, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ (({ toList := xs }.idxOf? a).isNone = true) = ¬a ∈ { toList := xs }" state_after="no goals" tactic="simp">
                    <AtomNode start="(718, 3)" end="(718, 7)" leading="" trailing="&#10;&#10;&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(722, 1)" end="(726, 3)" comment="### finIdxOf?&#10;&#10;The verification API for `finIdxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findFinIdx?` (and proved using them).&#10;-/">
      <AtomNode start="(722, 1)" end="(722, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(722, 5)" end="(726, 3)" leading="" trailing="&#10;&#10;" val="### finIdxOf?&#10;&#10;The verification API for `finIdxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findFinIdx?` (and proved using them).&#10;-/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(728, 1)" end="(730, 60)" name="idxOf?_eq_map_finIdxOf?_val" full_name="Array.idxOf?_eq_map_finIdxOf?_val">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(728, 1)" end="(730, 60)" name="idxOf?_eq_map_finIdxOf?_val" full_name="Array.idxOf?_eq_map_finIdxOf?_val" _is_private_decl="False">
        <AtomNode start="(728, 1)" end="(728, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(728, 9)" end="(728, 36)">
          <IdentNode start="(728, 9)" end="(728, 36)" leading="" trailing=" " raw_val="idxOf?_eq_map_finIdxOf?_val" val="idxOf?_eq_map_finIdxOf?_val"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(728, 37)" end="(729, 47)">
          <NullNode start="(728, 37)" end="(728, 67)">
            <OtherNode start="(728, 37)" end="(728, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(728, 37)" end="(728, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(728, 38)" end="(728, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(728, 38)" end="(728, 41)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(728, 42)" end="(728, 43)">
                  <IdentNode start="(728, 42)" end="(728, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(728, 43)" end="(728, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(728, 45)" end="(728, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(728, 45)" end="(728, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(728, 46)" end="(728, 48)">
                <IdentNode start="(728, 46)" end="(728, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(728, 49)" end="(728, 58)">
                <AtomNode start="(728, 49)" end="(728, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(728, 51)" end="(728, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(728, 51)" end="(728, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(728, 57)" end="(728, 58)">
                    <IdentNode start="(728, 57)" end="(728, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(728, 58)" end="(728, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(728, 60)" end="(728, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(728, 60)" end="(728, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(728, 61)" end="(728, 62)">
                <IdentNode start="(728, 61)" end="(728, 62)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(728, 63)" end="(728, 66)">
                <AtomNode start="(728, 63)" end="(728, 64)" leading="" trailing=" " val=":"/>
                <IdentNode start="(728, 65)" end="(728, 66)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(728, 66)" end="(728, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(728, 68)" end="(729, 47)">
            <AtomNode start="(728, 68)" end="(728, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(729, 5)" end="(729, 47)" kind="«term_=_»">
              <OtherNode start="(729, 5)" end="(729, 16)" kind="Lean.Parser.Term.app">
                <IdentNode start="(729, 5)" end="(729, 14)" leading="" trailing=" " raw_val="xs.idxOf?" val="xs.idxOf?"/>
                <NullNode start="(729, 15)" end="(729, 16)">
                  <IdentNode start="(729, 15)" end="(729, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(729, 17)" end="(729, 18)" leading="" trailing=" " val="="/>
              <OtherNode start="(729, 19)" end="(729, 47)" kind="Lean.Parser.Term.app">
                <OtherNode start="(729, 19)" end="(729, 39)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(729, 19)" end="(729, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(729, 19)" end="(729, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(729, 20)" end="(729, 34)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(729, 20)" end="(729, 32)" leading="" trailing=" " raw_val="xs.finIdxOf?" val="xs.finIdxOf?"/>
                      <NullNode start="(729, 33)" end="(729, 34)">
                        <IdentNode start="(729, 33)" end="(729, 34)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(729, 34)" end="(729, 35)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(729, 35)" end="(729, 36)" leading="" trailing="" val="."/>
                  <IdentNode start="(729, 36)" end="(729, 39)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(729, 40)" end="(729, 47)">
                  <OtherNode start="(729, 40)" end="(729, 47)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(729, 40)" end="(729, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(729, 41)" end="(729, 46)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(729, 41)" end="(729, 42)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(729, 41)" end="(729, 42)" leading="" trailing="" val="·"/>
                      </OtherNode>
                      <AtomNode start="(729, 42)" end="(729, 43)" leading="" trailing="" val="."/>
                      <IdentNode start="(729, 43)" end="(729, 46)" leading="" trailing="" raw_val="val" val="val" full_name="Fin.val" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(729, 46)" end="(729, 47)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(729, 48)" end="(730, 60)">
          <AtomNode start="(729, 48)" end="(729, 50)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(729, 51)" end="(730, 60)">
            <AtomNode start="(729, 51)" end="(729, 53)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(730, 3)" end="(730, 60)">
              <TacticTacticseq1IndentedNode start="(730, 3)" end="(730, 60)">
                <NullNode start="(730, 3)" end="(730, 60)">
                  <OtherNode start="(730, 3)" end="(730, 60)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;xs : Array α&#10;a : α&#10;⊢ xs.idxOf? a = Option.map (fun x =&amp;gt; ↑x) (xs.finIdxOf? a)" state_after="no goals" tactic="simp [idxOf?, finIdxOf?, findIdx?_eq_map_findFinIdx?_val]">
                    <AtomNode start="(730, 3)" end="(730, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(730, 8)" end="(730, 60)">
                      <AtomNode start="(730, 8)" end="(730, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(730, 9)" end="(730, 59)">
                        <OtherNode start="(730, 9)" end="(730, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(730, 9)" end="(730, 15)" leading="" trailing="" raw_val="idxOf?" val="idxOf?" full_name="Array.idxOf?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(730, 15)" end="(730, 16)" leading="" trailing=" " val=","/>
                        <OtherNode start="(730, 17)" end="(730, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(730, 17)" end="(730, 26)" leading="" trailing="" raw_val="finIdxOf?" val="finIdxOf?" full_name="Array.finIdxOf?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(730, 26)" end="(730, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(730, 28)" end="(730, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(730, 28)" end="(730, 59)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="Array.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(730, 59)" end="(730, 60)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(732, 1)" end="(732, 88)" name="finIdxOf?_empty" full_name="Array.finIdxOf?_empty">
      <CommandDeclmodifiersNode start="(732, 1)" end="(732, 8)">
        <NullNode/>
        <NullNode start="(732, 1)" end="(732, 8)">
          <OtherNode start="(732, 1)" end="(732, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(732, 1)" end="(732, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(732, 3)" end="(732, 7)">
              <OtherNode start="(732, 3)" end="(732, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(732, 3)" end="(732, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(732, 3)" end="(732, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(732, 7)" end="(732, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(732, 9)" end="(732, 88)" name="finIdxOf?_empty" full_name="Array.finIdxOf?_empty" _is_private_decl="False">
        <AtomNode start="(732, 9)" end="(732, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(732, 17)" end="(732, 32)">
          <IdentNode start="(732, 17)" end="(732, 32)" leading="" trailing=" " raw_val="finIdxOf?_empty" val="finIdxOf?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(732, 33)" end="(732, 77)">
          <NullNode start="(732, 33)" end="(732, 40)">
            <OtherNode start="(732, 33)" end="(732, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(732, 33)" end="(732, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(732, 34)" end="(732, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(732, 34)" end="(732, 37)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(732, 38)" end="(732, 39)">
                  <IdentNode start="(732, 38)" end="(732, 39)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(732, 39)" end="(732, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(732, 41)" end="(732, 77)">
            <AtomNode start="(732, 41)" end="(732, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(732, 43)" end="(732, 77)" kind="«term_=_»">
              <OtherNode start="(732, 43)" end="(732, 70)" kind="Lean.Parser.Term.app">
                <OtherNode start="(732, 43)" end="(732, 68)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(732, 43)" end="(732, 58)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(732, 43)" end="(732, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(732, 44)" end="(732, 47)" kind="«term#[_,]»">
                      <AtomNode start="(732, 44)" end="(732, 46)" leading="" trailing="" val="#["/>
                      <NullNode/>
                      <AtomNode start="(732, 46)" end="(732, 47)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(732, 48)" end="(732, 49)" leading="" trailing=" " val=":"/>
                    <NullNode start="(732, 50)" end="(732, 57)">
                      <OtherNode start="(732, 50)" end="(732, 57)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(732, 50)" end="(732, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(732, 56)" end="(732, 57)">
                          <IdentNode start="(732, 56)" end="(732, 57)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(732, 57)" end="(732, 58)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(732, 58)" end="(732, 59)" leading="" trailing="" val="."/>
                  <IdentNode start="(732, 59)" end="(732, 68)" leading="" trailing=" " raw_val="finIdxOf?" val="finIdxOf?" full_name="Array.finIdxOf?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(732, 69)" end="(732, 70)">
                  <IdentNode start="(732, 69)" end="(732, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(732, 71)" end="(732, 72)" leading="" trailing=" " val="="/>
              <IdentNode start="(732, 73)" end="(732, 77)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(732, 78)" end="(732, 88)">
          <AtomNode start="(732, 78)" end="(732, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(732, 81)" end="(732, 88)">
            <AtomNode start="(732, 81)" end="(732, 83)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(732, 84)" end="(732, 88)">
              <TacticTacticseq1IndentedNode start="(732, 84)" end="(732, 88)">
                <NullNode start="(732, 84)" end="(732, 88)">
                  <OtherNode start="(732, 84)" end="(732, 88)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;inst✝ : BEq α&#10;⊢ #[].finIdxOf? a = none" state_after="no goals" tactic="simp">
                    <AtomNode start="(732, 84)" end="(732, 88)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(734, 1)" end="(737, 36)" name="finIdxOf?_eq_none_iff" full_name="Array.finIdxOf?_eq_none_iff">
      <CommandDeclmodifiersNode start="(734, 1)" end="(734, 8)">
        <NullNode/>
        <NullNode start="(734, 1)" end="(734, 8)">
          <OtherNode start="(734, 1)" end="(734, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(734, 1)" end="(734, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(734, 3)" end="(734, 7)">
              <OtherNode start="(734, 3)" end="(734, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(734, 3)" end="(734, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(734, 3)" end="(734, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(734, 7)" end="(734, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(734, 9)" end="(737, 36)" name="finIdxOf?_eq_none_iff" full_name="Array.finIdxOf?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(734, 9)" end="(734, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(734, 17)" end="(734, 38)">
          <IdentNode start="(734, 17)" end="(734, 38)" leading="" trailing=" " raw_val="finIdxOf?_eq_none_iff" val="finIdxOf?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(734, 39)" end="(735, 35)">
          <NullNode start="(734, 39)" end="(734, 83)">
            <OtherNode start="(734, 39)" end="(734, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(734, 39)" end="(734, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(734, 40)" end="(734, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(734, 40)" end="(734, 43)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(734, 44)" end="(734, 45)">
                  <IdentNode start="(734, 44)" end="(734, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(734, 45)" end="(734, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(734, 47)" end="(734, 60)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(734, 47)" end="(734, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(734, 48)" end="(734, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(734, 48)" end="(734, 57)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(734, 58)" end="(734, 59)">
                  <IdentNode start="(734, 58)" end="(734, 59)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(734, 59)" end="(734, 60)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(734, 61)" end="(734, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(734, 61)" end="(734, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(734, 62)" end="(734, 64)">
                <IdentNode start="(734, 62)" end="(734, 64)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(734, 65)" end="(734, 74)">
                <AtomNode start="(734, 65)" end="(734, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(734, 67)" end="(734, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(734, 67)" end="(734, 72)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(734, 73)" end="(734, 74)">
                    <IdentNode start="(734, 73)" end="(734, 74)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(734, 74)" end="(734, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(734, 76)" end="(734, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(734, 76)" end="(734, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(734, 77)" end="(734, 78)">
                <IdentNode start="(734, 77)" end="(734, 78)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(734, 79)" end="(734, 82)">
                <AtomNode start="(734, 79)" end="(734, 80)" leading="" trailing=" " val=":"/>
                <IdentNode start="(734, 81)" end="(734, 82)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(734, 82)" end="(734, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(734, 84)" end="(735, 35)">
            <AtomNode start="(734, 84)" end="(734, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(735, 5)" end="(735, 35)" kind="«term_↔_»">
              <OtherNode start="(735, 5)" end="(735, 26)" kind="«term_=_»">
                <OtherNode start="(735, 5)" end="(735, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(735, 5)" end="(735, 17)" leading="" trailing=" " raw_val="xs.finIdxOf?" val="xs.finIdxOf?"/>
                  <NullNode start="(735, 18)" end="(735, 19)">
                    <IdentNode start="(735, 18)" end="(735, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(735, 20)" end="(735, 21)" leading="" trailing=" " val="="/>
                <IdentNode start="(735, 22)" end="(735, 26)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(735, 27)" end="(735, 28)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(735, 29)" end="(735, 35)" kind="«term_∉_»">
                <IdentNode start="(735, 29)" end="(735, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(735, 31)" end="(735, 32)" leading="" trailing=" " val="∉"/>
                <IdentNode start="(735, 33)" end="(735, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(735, 36)" end="(737, 36)">
          <AtomNode start="(735, 36)" end="(735, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(735, 39)" end="(737, 36)">
            <AtomNode start="(735, 39)" end="(735, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(736, 3)" end="(737, 36)">
              <TacticTacticseq1IndentedNode start="(736, 3)" end="(737, 36)">
                <NullNode start="(736, 3)" end="(737, 36)">
                  <OtherNode start="(736, 3)" end="(736, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ xs.finIdxOf? a = none ↔ ¬a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.finIdxOf? a = none ↔ ¬a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(736, 3)" end="(736, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(736, 10)" end="(736, 12)">
                      <OtherNode start="(736, 10)" end="(736, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(736, 10)" end="(736, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(736, 13)" end="(736, 22)">
                      <AtomNode start="(736, 13)" end="(736, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(736, 18)" end="(736, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(736, 18)" end="(736, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(736, 18)" end="(736, 22)">
                            <OtherNode start="(736, 18)" end="(736, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(736, 18)" end="(736, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(736, 19)" end="(736, 21)">
                                <OtherNode start="(736, 19)" end="(736, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(736, 19)" end="(736, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(736, 19)" end="(736, 21)">
                                      <OtherNode start="(736, 19)" end="(736, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(736, 19)" end="(736, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(736, 21)" end="(736, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(737, 3)" end="(737, 36)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.finIdxOf? a = none ↔ ¬a ∈ { toList := xs }" state_after="no goals" tactic="simp [List.finIdxOf?_eq_none_iff]">
                    <AtomNode start="(737, 3)" end="(737, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(737, 8)" end="(737, 36)">
                      <AtomNode start="(737, 8)" end="(737, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(737, 9)" end="(737, 35)">
                        <OtherNode start="(737, 9)" end="(737, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(737, 9)" end="(737, 35)" leading="" trailing="" raw_val="List.finIdxOf?_eq_none_iff" val="List.finIdxOf?_eq_none_iff" full_name="List.finIdxOf?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(737, 35)" end="(737, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(739, 1)" end="(742, 36)" name="finIdxOf?_eq_some_iff" full_name="Array.finIdxOf?_eq_some_iff">
      <CommandDeclmodifiersNode start="(739, 1)" end="(739, 8)">
        <NullNode/>
        <NullNode start="(739, 1)" end="(739, 8)">
          <OtherNode start="(739, 1)" end="(739, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(739, 1)" end="(739, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(739, 3)" end="(739, 7)">
              <OtherNode start="(739, 3)" end="(739, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(739, 3)" end="(739, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(739, 3)" end="(739, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(739, 7)" end="(739, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(739, 9)" end="(742, 36)" name="finIdxOf?_eq_some_iff" full_name="Array.finIdxOf?_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(739, 9)" end="(739, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(739, 17)" end="(739, 38)">
          <IdentNode start="(739, 17)" end="(739, 38)" leading="" trailing=" " raw_val="finIdxOf?_eq_some_iff" val="finIdxOf?_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(739, 39)" end="(740, 70)">
          <NullNode start="(739, 39)" end="(739, 101)">
            <OtherNode start="(739, 39)" end="(739, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(739, 39)" end="(739, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(739, 40)" end="(739, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(739, 40)" end="(739, 43)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(739, 44)" end="(739, 45)">
                  <IdentNode start="(739, 44)" end="(739, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(739, 45)" end="(739, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(739, 47)" end="(739, 60)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(739, 47)" end="(739, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(739, 48)" end="(739, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(739, 48)" end="(739, 57)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(739, 58)" end="(739, 59)">
                  <IdentNode start="(739, 58)" end="(739, 59)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(739, 59)" end="(739, 60)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(739, 61)" end="(739, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(739, 61)" end="(739, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(739, 62)" end="(739, 64)">
                <IdentNode start="(739, 62)" end="(739, 64)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(739, 65)" end="(739, 74)">
                <AtomNode start="(739, 65)" end="(739, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(739, 67)" end="(739, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(739, 67)" end="(739, 72)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(739, 73)" end="(739, 74)">
                    <IdentNode start="(739, 73)" end="(739, 74)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(739, 74)" end="(739, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(739, 76)" end="(739, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(739, 76)" end="(739, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(739, 77)" end="(739, 78)">
                <IdentNode start="(739, 77)" end="(739, 78)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(739, 79)" end="(739, 82)">
                <AtomNode start="(739, 79)" end="(739, 80)" leading="" trailing=" " val=":"/>
                <IdentNode start="(739, 81)" end="(739, 82)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(739, 82)" end="(739, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(739, 84)" end="(739, 101)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(739, 84)" end="(739, 85)" leading="" trailing="" val="{"/>
              <NullNode start="(739, 85)" end="(739, 86)">
                <IdentNode start="(739, 85)" end="(739, 86)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(739, 87)" end="(739, 100)">
                <AtomNode start="(739, 87)" end="(739, 88)" leading="" trailing=" " val=":"/>
                <OtherNode start="(739, 89)" end="(739, 100)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(739, 89)" end="(739, 92)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(739, 93)" end="(739, 100)">
                    <IdentNode start="(739, 93)" end="(739, 100)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(739, 100)" end="(739, 101)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(739, 102)" end="(740, 70)">
            <AtomNode start="(739, 102)" end="(739, 103)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(740, 5)" end="(740, 70)" kind="«term_↔_»">
              <OtherNode start="(740, 5)" end="(740, 28)" kind="«term_=_»">
                <OtherNode start="(740, 5)" end="(740, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(740, 5)" end="(740, 17)" leading="" trailing=" " raw_val="xs.finIdxOf?" val="xs.finIdxOf?"/>
                  <NullNode start="(740, 18)" end="(740, 19)">
                    <IdentNode start="(740, 18)" end="(740, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(740, 20)" end="(740, 21)" leading="" trailing=" " val="="/>
                <OtherNode start="(740, 22)" end="(740, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(740, 22)" end="(740, 26)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(740, 27)" end="(740, 28)">
                    <IdentNode start="(740, 27)" end="(740, 28)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(740, 29)" end="(740, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(740, 31)" end="(740, 70)" kind="«term_∧_»">
                <OtherNode start="(740, 31)" end="(740, 40)" kind="«term_=_»">
                  <OtherNode start="(740, 31)" end="(740, 36)" kind="«term__[_]»">
                    <IdentNode start="(740, 31)" end="(740, 33)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <AtomNode start="(740, 33)" end="(740, 34)" leading="" trailing="" val="["/>
                    <IdentNode start="(740, 34)" end="(740, 35)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(740, 35)" end="(740, 36)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <AtomNode start="(740, 37)" end="(740, 38)" leading="" trailing=" " val="="/>
                  <IdentNode start="(740, 39)" end="(740, 40)" leading="" trailing=" " raw_val="a" val="a"/>
                </OtherNode>
                <AtomNode start="(740, 41)" end="(740, 42)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(740, 43)" end="(740, 70)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(740, 43)" end="(740, 44)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(740, 45)" end="(740, 58)">
                    <IdentNode start="(740, 45)" end="(740, 46)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(740, 47)" end="(740, 58)">
                      <AtomNode start="(740, 47)" end="(740, 48)" leading="" trailing="" val="("/>
                      <NullNode start="(740, 48)" end="(740, 49)">
                        <TermHoleNode start="(740, 48)" end="(740, 49)">
                          <AtomNode start="(740, 48)" end="(740, 49)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </NullNode>
                      <NullNode start="(740, 50)" end="(740, 57)">
                        <AtomNode start="(740, 50)" end="(740, 51)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(740, 52)" end="(740, 57)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(740, 52)" end="(740, 53)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(740, 54)" end="(740, 55)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(740, 56)" end="(740, 57)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(740, 57)" end="(740, 58)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(740, 58)" end="(740, 59)" leading="" trailing=" " val=","/>
                  <OtherNode start="(740, 60)" end="(740, 70)" kind="«term¬_»">
                    <AtomNode start="(740, 60)" end="(740, 61)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(740, 61)" end="(740, 70)" kind="«term_=_»">
                      <OtherNode start="(740, 61)" end="(740, 66)" kind="«term__[_]»">
                        <IdentNode start="(740, 61)" end="(740, 63)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <AtomNode start="(740, 63)" end="(740, 64)" leading="" trailing="" val="["/>
                        <IdentNode start="(740, 64)" end="(740, 65)" leading="" trailing="" raw_val="j" val="j"/>
                        <AtomNode start="(740, 65)" end="(740, 66)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <AtomNode start="(740, 67)" end="(740, 68)" leading="" trailing=" " val="="/>
                      <IdentNode start="(740, 69)" end="(740, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(740, 71)" end="(742, 36)">
          <AtomNode start="(740, 71)" end="(740, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(740, 74)" end="(742, 36)">
            <AtomNode start="(740, 74)" end="(740, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(741, 3)" end="(742, 36)">
              <TacticTacticseq1IndentedNode start="(741, 3)" end="(742, 36)">
                <NullNode start="(741, 3)" end="(742, 36)">
                  <OtherNode start="(741, 3)" end="(741, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;i : Fin xs.size&#10;⊢ xs.finIdxOf? a = some i ↔ xs[i] = a ∧ ∀ (j : Fin xs.size), j &amp;lt; i → ¬xs[j] = a" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;i : Fin { toList := xs }.size&#10;⊢ { toList := xs }.finIdxOf? a = some i ↔&#10;    { toList := xs }[i] = a ∧ ∀ (j : Fin { toList := xs }.size), j &amp;lt; i → ¬{ toList := xs }[j] = a" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(741, 3)" end="(741, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(741, 10)" end="(741, 12)">
                      <OtherNode start="(741, 10)" end="(741, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(741, 10)" end="(741, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(741, 13)" end="(741, 22)">
                      <AtomNode start="(741, 13)" end="(741, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(741, 18)" end="(741, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(741, 18)" end="(741, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(741, 18)" end="(741, 22)">
                            <OtherNode start="(741, 18)" end="(741, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(741, 18)" end="(741, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(741, 19)" end="(741, 21)">
                                <OtherNode start="(741, 19)" end="(741, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(741, 19)" end="(741, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(741, 19)" end="(741, 21)">
                                      <OtherNode start="(741, 19)" end="(741, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(741, 19)" end="(741, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(741, 21)" end="(741, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(742, 3)" end="(742, 36)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;i : Fin { toList := xs }.size&#10;⊢ { toList := xs }.finIdxOf? a = some i ↔&#10;    { toList := xs }[i] = a ∧ ∀ (j : Fin { toList := xs }.size), j &amp;lt; i → ¬{ toList := xs }[j] = a" state_after="no goals" tactic="simp [List.finIdxOf?_eq_some_iff]">
                    <AtomNode start="(742, 3)" end="(742, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(742, 8)" end="(742, 36)">
                      <AtomNode start="(742, 8)" end="(742, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(742, 9)" end="(742, 35)">
                        <OtherNode start="(742, 9)" end="(742, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(742, 9)" end="(742, 35)" leading="" trailing="" raw_val="List.finIdxOf?_eq_some_iff" val="List.finIdxOf?_eq_some_iff" full_name="List.finIdxOf?_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(742, 35)" end="(742, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(744, 1)" end="(748, 7)" name="isSome_finIdxOf?" full_name="Array.isSome_finIdxOf?">
      <CommandDeclmodifiersNode start="(744, 1)" end="(744, 8)">
        <NullNode/>
        <NullNode start="(744, 1)" end="(744, 8)">
          <OtherNode start="(744, 1)" end="(744, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(744, 1)" end="(744, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(744, 3)" end="(744, 7)">
              <OtherNode start="(744, 3)" end="(744, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(744, 3)" end="(744, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(744, 3)" end="(744, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(744, 7)" end="(744, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(745, 1)" end="(748, 7)" name="isSome_finIdxOf?" full_name="Array.isSome_finIdxOf?" _is_private_decl="False">
        <AtomNode start="(745, 1)" end="(745, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(745, 9)" end="(745, 25)">
          <IdentNode start="(745, 9)" end="(745, 25)" leading="" trailing=" " raw_val="isSome_finIdxOf?" val="isSome_finIdxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(745, 26)" end="(746, 37)">
          <NullNode start="(745, 26)" end="(745, 70)">
            <OtherNode start="(745, 26)" end="(745, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(745, 26)" end="(745, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(745, 27)" end="(745, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(745, 27)" end="(745, 30)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(745, 31)" end="(745, 32)">
                  <IdentNode start="(745, 31)" end="(745, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(745, 32)" end="(745, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(745, 34)" end="(745, 47)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(745, 34)" end="(745, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(745, 35)" end="(745, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(745, 35)" end="(745, 44)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(745, 45)" end="(745, 46)">
                  <IdentNode start="(745, 45)" end="(745, 46)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(745, 46)" end="(745, 47)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(745, 48)" end="(745, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(745, 48)" end="(745, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(745, 49)" end="(745, 51)">
                <IdentNode start="(745, 49)" end="(745, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(745, 52)" end="(745, 61)">
                <AtomNode start="(745, 52)" end="(745, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(745, 54)" end="(745, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(745, 54)" end="(745, 59)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(745, 60)" end="(745, 61)">
                    <IdentNode start="(745, 60)" end="(745, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(745, 61)" end="(745, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(745, 63)" end="(745, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(745, 63)" end="(745, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(745, 64)" end="(745, 65)">
                <IdentNode start="(745, 64)" end="(745, 65)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(745, 66)" end="(745, 69)">
                <AtomNode start="(745, 66)" end="(745, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(745, 68)" end="(745, 69)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(745, 69)" end="(745, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(745, 71)" end="(746, 37)">
            <AtomNode start="(745, 71)" end="(745, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(746, 5)" end="(746, 37)" kind="«term_↔_»">
              <OtherNode start="(746, 5)" end="(746, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(746, 5)" end="(746, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(746, 5)" end="(746, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(746, 6)" end="(746, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(746, 6)" end="(746, 18)" leading="" trailing=" " raw_val="xs.finIdxOf?" val="xs.finIdxOf?"/>
                    <NullNode start="(746, 19)" end="(746, 20)">
                      <IdentNode start="(746, 19)" end="(746, 20)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(746, 20)" end="(746, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(746, 21)" end="(746, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(746, 22)" end="(746, 28)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(746, 29)" end="(746, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(746, 31)" end="(746, 37)" kind="«term_∈_»">
                <IdentNode start="(746, 31)" end="(746, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(746, 33)" end="(746, 34)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(746, 35)" end="(746, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(746, 38)" end="(748, 7)">
          <AtomNode start="(746, 38)" end="(746, 40)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(746, 41)" end="(748, 7)">
            <AtomNode start="(746, 41)" end="(746, 43)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(747, 3)" end="(748, 7)">
              <TacticTacticseq1IndentedNode start="(747, 3)" end="(748, 7)">
                <NullNode start="(747, 3)" end="(748, 7)">
                  <OtherNode start="(747, 3)" end="(747, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ (xs.finIdxOf? a).isSome = true ↔ a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ ({ toList := xs }.finIdxOf? a).isSome = true ↔ a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(747, 3)" end="(747, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(747, 10)" end="(747, 12)">
                      <OtherNode start="(747, 10)" end="(747, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(747, 10)" end="(747, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(747, 13)" end="(747, 22)">
                      <AtomNode start="(747, 13)" end="(747, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(747, 18)" end="(747, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(747, 18)" end="(747, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(747, 18)" end="(747, 22)">
                            <OtherNode start="(747, 18)" end="(747, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(747, 18)" end="(747, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(747, 19)" end="(747, 21)">
                                <OtherNode start="(747, 19)" end="(747, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(747, 19)" end="(747, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(747, 19)" end="(747, 21)">
                                      <OtherNode start="(747, 19)" end="(747, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(747, 19)" end="(747, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(747, 21)" end="(747, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(748, 3)" end="(748, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ ({ toList := xs }.finIdxOf? a).isSome = true ↔ a ∈ { toList := xs }" state_after="no goals" tactic="simp">
                    <AtomNode start="(748, 3)" end="(748, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(750, 1)" end="(754, 7)" name="isNone_finIdxOf?" full_name="Array.isNone_finIdxOf?">
      <CommandDeclmodifiersNode start="(750, 1)" end="(750, 8)">
        <NullNode/>
        <NullNode start="(750, 1)" end="(750, 8)">
          <OtherNode start="(750, 1)" end="(750, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(750, 1)" end="(750, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(750, 3)" end="(750, 7)">
              <OtherNode start="(750, 3)" end="(750, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(750, 3)" end="(750, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(750, 3)" end="(750, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(750, 7)" end="(750, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(751, 1)" end="(754, 7)" name="isNone_finIdxOf?" full_name="Array.isNone_finIdxOf?" _is_private_decl="False">
        <AtomNode start="(751, 1)" end="(751, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(751, 9)" end="(751, 25)">
          <IdentNode start="(751, 9)" end="(751, 25)" leading="" trailing=" " raw_val="isNone_finIdxOf?" val="isNone_finIdxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(751, 26)" end="(752, 39)">
          <NullNode start="(751, 26)" end="(751, 70)">
            <OtherNode start="(751, 26)" end="(751, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(751, 26)" end="(751, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(751, 27)" end="(751, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(751, 27)" end="(751, 30)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(751, 31)" end="(751, 32)">
                  <IdentNode start="(751, 31)" end="(751, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(751, 32)" end="(751, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(751, 34)" end="(751, 47)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(751, 34)" end="(751, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(751, 35)" end="(751, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(751, 35)" end="(751, 44)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(751, 45)" end="(751, 46)">
                  <IdentNode start="(751, 45)" end="(751, 46)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(751, 46)" end="(751, 47)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(751, 48)" end="(751, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(751, 48)" end="(751, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(751, 49)" end="(751, 51)">
                <IdentNode start="(751, 49)" end="(751, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(751, 52)" end="(751, 61)">
                <AtomNode start="(751, 52)" end="(751, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(751, 54)" end="(751, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(751, 54)" end="(751, 59)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(751, 60)" end="(751, 61)">
                    <IdentNode start="(751, 60)" end="(751, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(751, 61)" end="(751, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(751, 63)" end="(751, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(751, 63)" end="(751, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(751, 64)" end="(751, 65)">
                <IdentNode start="(751, 64)" end="(751, 65)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(751, 66)" end="(751, 69)">
                <AtomNode start="(751, 66)" end="(751, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(751, 68)" end="(751, 69)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(751, 69)" end="(751, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(751, 71)" end="(752, 39)">
            <AtomNode start="(751, 71)" end="(751, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(752, 5)" end="(752, 39)" kind="«term_=_»">
              <OtherNode start="(752, 5)" end="(752, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(752, 5)" end="(752, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(752, 5)" end="(752, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(752, 6)" end="(752, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(752, 6)" end="(752, 18)" leading="" trailing=" " raw_val="xs.finIdxOf?" val="xs.finIdxOf?"/>
                    <NullNode start="(752, 19)" end="(752, 20)">
                      <IdentNode start="(752, 19)" end="(752, 20)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(752, 20)" end="(752, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(752, 21)" end="(752, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(752, 22)" end="(752, 28)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(752, 29)" end="(752, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(752, 31)" end="(752, 39)" kind="«term¬_»">
                <AtomNode start="(752, 31)" end="(752, 32)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(752, 33)" end="(752, 39)" kind="«term_∈_»">
                  <IdentNode start="(752, 33)" end="(752, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(752, 35)" end="(752, 36)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(752, 37)" end="(752, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(752, 40)" end="(754, 7)">
          <AtomNode start="(752, 40)" end="(752, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(752, 43)" end="(754, 7)">
            <AtomNode start="(752, 43)" end="(752, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(753, 3)" end="(754, 7)">
              <TacticTacticseq1IndentedNode start="(753, 3)" end="(754, 7)">
                <NullNode start="(753, 3)" end="(754, 7)">
                  <OtherNode start="(753, 3)" end="(753, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ ((xs.finIdxOf? a).isNone = true) = ¬a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ (({ toList := xs }.finIdxOf? a).isNone = true) = ¬a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(753, 3)" end="(753, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(753, 10)" end="(753, 12)">
                      <OtherNode start="(753, 10)" end="(753, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(753, 10)" end="(753, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(753, 13)" end="(753, 22)">
                      <AtomNode start="(753, 13)" end="(753, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(753, 18)" end="(753, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(753, 18)" end="(753, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(753, 18)" end="(753, 22)">
                            <OtherNode start="(753, 18)" end="(753, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(753, 18)" end="(753, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(753, 19)" end="(753, 21)">
                                <OtherNode start="(753, 19)" end="(753, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(753, 19)" end="(753, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(753, 19)" end="(753, 21)">
                                      <OtherNode start="(753, 19)" end="(753, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(753, 19)" end="(753, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(753, 21)" end="(753, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(754, 3)" end="(754, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ (({ toList := xs }.finIdxOf? a).isNone = true) = ¬a ∈ { toList := xs }" state_after="no goals" tactic="simp">
                    <AtomNode start="(754, 3)" end="(754, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(756, 1)" end="(756, 10)" name="Array">
      <AtomNode start="(756, 1)" end="(756, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(756, 5)" end="(756, 10)">
        <IdentNode start="(756, 5)" end="(756, 10)" leading="" trailing="&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(14, 1)" end="(16, 3)" text="# Lemmas about `Array.findSome?`, `Array.find?, `Array.findIdx`, `Array.findIdx?`, `Array.idxOf`.&#10;-/"/>
    <Comment start="(18, 38)" end="(19, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(19, 39)" end="(20, 1)" text="-- Enforce naming conventions for index variables.&#10;"/>
    <Comment start="(24, 1)" end="(24, 21)" text="### findSome? -/"/>
    <Comment start="(124, 1)" end="(125, 1)" text="-- Argument is unused, but used to decide whether `simp` should unfold.&#10;"/>
    <Comment start="(140, 1)" end="(140, 17)" text="### find? -/"/>
    <Comment start="(244, 1)" end="(248, 3)" text="If `find? p` returns `some a` from `xs.flatten`, then `p a` holds, and&#10;some array in `xs` contains `a`, and no earlier element of that array satisfies `p`.&#10;Moreover, no earlier array in `xs` has an element satisfying `p`.&#10;-/"/>
    <Comment start="(311, 1)" end="(312, 1)" text="-- This isn't a `@[simp]` lemma since there is already a lemma for `l.find? p = none` for any `l`.&#10;"/>
    <Comment start="(347, 1)" end="(347, 19)" text="### findIdx -/"/>
    <Comment start="(394, 1)" end="(394, 77)" text="`p` does not hold for elements with indices less than `xs.findIdx p`. -/"/>
    <Comment start="(400, 1)" end="(400, 64)" text="If `¬ p xs[j]` for all `j &lt; i`, then `i ≤ xs.findIdx p`. -/"/>
    <Comment start="(408, 1)" end="(408, 64)" text="If `¬ p xs[j]` for all `j ≤ i`, then `i &lt; xs.findIdx p`. -/"/>
    <Comment start="(416, 1)" end="(416, 74)" text="`xs.findIdx p = i` iff `p xs[i]` and `¬ p xs [j]` for all `j &lt; i`. -/"/>
    <Comment start="(466, 1)" end="(466, 20)" text="### findIdx? -/"/>
    <Comment start="(573, 1)" end="(574, 1)" text="-- See also `findIdx_le_findIdx`.&#10;"/>
    <Comment start="(600, 1)" end="(600, 23)" text="### findFinIdx? -/"/>
    <Comment start="(607, 1)" end="(608, 1)" text="-- We can't mark this as a `@[congr]` lemma since the head of the RHS is not `findFinIdx?`.&#10;"/>
    <Comment start="(671, 1)" end="(675, 3)" text="### idxOf&#10;&#10;The verification API for `idxOf` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx` (and proved using them).&#10;-/"/>
    <Comment start="(695, 1)" end="(699, 3)" text="### idxOf?&#10;&#10;The verification API for `idxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx?` (and proved using them).&#10;-/"/>
    <Comment start="(722, 1)" end="(726, 3)" text="### finIdxOf?&#10;&#10;The verification API for `finIdxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findFinIdx?` (and proved using them).&#10;-/"/>
  </Comments>
</TracedFile>
