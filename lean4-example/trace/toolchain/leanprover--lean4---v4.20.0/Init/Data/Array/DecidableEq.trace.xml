<TracedFile path="src/lean/Init/Data/Array/DecidableEq.lean" md5="b5e8f62a75c2d030313ba3c48cedb86e">
  <FileNode start="(1, 1)" end="(127, 10)">
    <ModuleHeaderNode start="(6, 1)" end="(12, 20)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(12, 20)">
        <ModuleImportNode start="(9, 1)" end="(9, 29)" module="Init.Data.Array.Basic" path="src/lean/Init/Data/Array/Basic.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 29)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Basic" val="Init.Data.Array.Basic"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 21)" module="Init.Data.BEq" path="src/lean/Init/Data/BEq.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 21)" leading="" trailing="&#10;" raw_val="Init.Data.BEq" val="Init.Data.BEq"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 30)" module="Init.Data.List.Nat.BEq" path="src/lean/Init/Data/List/Nat/BEq.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 30)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.BEq" val="Init.Data.List.Nat.BEq"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 20)" module="Init.ByCases" path="src/lean/Init/ByCases.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 20)" leading="" trailing="&#10;&#10;" raw_val="Init.ByCases" val="Init.ByCases"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(14, 1)" end="(14, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(14, 1)" end="(14, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(14, 12)" end="(14, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(14, 33)" end="(14, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(15, 1)" end="(15, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(15, 1)" end="(15, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(15, 12)" end="(15, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(15, 34)" end="(15, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(17, 1)" end="(17, 16)" name="Array">
      <AtomNode start="(17, 1)" end="(17, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(17, 11)" end="(17, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(19, 1)" end="(33, 22)" name="rel_of_isEqvAux" full_name="Array.rel_of_isEqvAux">
      <CommandDeclmodifiersNode start="(19, 1)" end="(19, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(19, 1)" end="(19, 8)">
          <CommandPrivateNode start="(19, 1)" end="(19, 8)">
            <AtomNode start="(19, 1)" end="(19, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(19, 9)" end="(33, 22)" name="rel_of_isEqvAux" full_name="Array.rel_of_isEqvAux" _is_private_decl="True">
        <AtomNode start="(19, 9)" end="(19, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(19, 17)" end="(19, 32)">
          <IdentNode start="(19, 17)" end="(19, 32)" leading="" trailing="&#10;    " raw_val="rel_of_isEqvAux" val="rel_of_isEqvAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(20, 5)" end="(22, 109)">
          <NullNode start="(20, 5)" end="(22, 27)">
            <OtherNode start="(20, 5)" end="(20, 23)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(20, 5)" end="(20, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(20, 6)" end="(20, 7)">
                <IdentNode start="(20, 6)" end="(20, 7)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(20, 8)" end="(20, 22)">
                <AtomNode start="(20, 8)" end="(20, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(20, 10)" end="(20, 22)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(20, 10)" end="(20, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(20, 12)" end="(20, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(20, 14)" end="(20, 22)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(20, 14)" end="(20, 15)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(20, 16)" end="(20, 17)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(20, 18)" end="(20, 22)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(20, 22)" end="(20, 23)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(20, 24)" end="(20, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(20, 24)" end="(20, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(20, 25)" end="(20, 30)">
                <IdentNode start="(20, 25)" end="(20, 27)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(20, 28)" end="(20, 30)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(20, 31)" end="(20, 40)">
                <AtomNode start="(20, 31)" end="(20, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(20, 33)" end="(20, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(20, 33)" end="(20, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(20, 39)" end="(20, 40)">
                    <IdentNode start="(20, 39)" end="(20, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(20, 40)" end="(20, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(20, 42)" end="(20, 67)">
              <AtomNode start="(20, 42)" end="(20, 43)" leading="" trailing="" val="("/>
              <NullNode start="(20, 43)" end="(20, 46)">
                <IdentNode start="(20, 43)" end="(20, 46)" leading="" trailing=" " raw_val="hsz" val="hsz"/>
              </NullNode>
              <NullNode start="(20, 47)" end="(20, 66)">
                <AtomNode start="(20, 47)" end="(20, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(20, 49)" end="(20, 66)" kind="«term_=_»">
                  <IdentNode start="(20, 49)" end="(20, 56)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(20, 57)" end="(20, 58)" leading="" trailing=" " val="="/>
                  <IdentNode start="(20, 59)" end="(20, 66)" leading="" trailing="" raw_val="ys.size" val="ys.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(20, 66)" end="(20, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(20, 68)" end="(20, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(20, 68)" end="(20, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(20, 69)" end="(20, 70)">
                <IdentNode start="(20, 69)" end="(20, 70)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(20, 71)" end="(20, 76)">
                <AtomNode start="(20, 71)" end="(20, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(20, 73)" end="(20, 76)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(20, 76)" end="(20, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(20, 78)" end="(20, 96)">
              <AtomNode start="(20, 78)" end="(20, 79)" leading="" trailing="" val="("/>
              <NullNode start="(20, 79)" end="(20, 81)">
                <IdentNode start="(20, 79)" end="(20, 81)" leading="" trailing=" " raw_val="hi" val="hi"/>
              </NullNode>
              <NullNode start="(20, 82)" end="(20, 95)">
                <AtomNode start="(20, 82)" end="(20, 83)" leading="" trailing=" " val=":"/>
                <OtherNode start="(20, 84)" end="(20, 95)" kind="«term_≤_»">
                  <IdentNode start="(20, 84)" end="(20, 85)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(20, 86)" end="(20, 87)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(20, 88)" end="(20, 95)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(20, 95)" end="(20, 96)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(21, 5)" end="(21, 45)">
              <AtomNode start="(21, 5)" end="(21, 6)" leading="" trailing="" val="("/>
              <NullNode start="(21, 6)" end="(21, 10)">
                <IdentNode start="(21, 6)" end="(21, 10)" leading="" trailing=" " raw_val="heqv" val="heqv"/>
              </NullNode>
              <NullNode start="(21, 11)" end="(21, 44)">
                <AtomNode start="(21, 11)" end="(21, 12)" leading="" trailing=" " val=":"/>
                <OtherNode start="(21, 13)" end="(21, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(21, 13)" end="(21, 27)" leading="" trailing=" " raw_val="Array.isEqvAux" val="Array.isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(21, 28)" end="(21, 44)">
                    <IdentNode start="(21, 28)" end="(21, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(21, 31)" end="(21, 33)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    <IdentNode start="(21, 34)" end="(21, 37)" leading="" trailing=" " raw_val="hsz" val="hsz"/>
                    <IdentNode start="(21, 38)" end="(21, 39)" leading="" trailing=" " raw_val="r" val="r"/>
                    <IdentNode start="(21, 40)" end="(21, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(21, 42)" end="(21, 44)" leading="" trailing="" raw_val="hi" val="hi"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(21, 44)" end="(21, 45)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(22, 5)" end="(22, 14)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(22, 5)" end="(22, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(22, 6)" end="(22, 7)">
                <IdentNode start="(22, 6)" end="(22, 7)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(22, 8)" end="(22, 13)">
                <AtomNode start="(22, 8)" end="(22, 9)" leading="" trailing=" " val=":"/>
                <IdentNode start="(22, 10)" end="(22, 13)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(22, 13)" end="(22, 14)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(22, 15)" end="(22, 27)">
              <AtomNode start="(22, 15)" end="(22, 16)" leading="" trailing="" val="("/>
              <NullNode start="(22, 16)" end="(22, 18)">
                <IdentNode start="(22, 16)" end="(22, 18)" leading="" trailing=" " raw_val="hj" val="hj"/>
              </NullNode>
              <NullNode start="(22, 19)" end="(22, 26)">
                <AtomNode start="(22, 19)" end="(22, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(22, 21)" end="(22, 26)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(22, 21)" end="(22, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(22, 23)" end="(22, 24)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(22, 25)" end="(22, 26)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(22, 26)" end="(22, 27)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(22, 28)" end="(22, 109)">
            <AtomNode start="(22, 28)" end="(22, 29)" leading="" trailing=" " val=":"/>
            <OtherNode start="(22, 30)" end="(22, 109)" kind="Lean.Parser.Term.app">
              <IdentNode start="(22, 30)" end="(22, 31)" leading="" trailing=" " raw_val="r" val="r"/>
              <NullNode start="(22, 32)" end="(22, 109)">
                <OtherNode start="(22, 32)" end="(22, 66)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(22, 32)" end="(22, 33)" leading="" trailing="" val="("/>
                  <OtherNode start="(22, 33)" end="(22, 65)" kind="«term__[_]'_»">
                    <IdentNode start="(22, 33)" end="(22, 35)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <AtomNode start="(22, 35)" end="(22, 36)" leading="" trailing="" val="["/>
                    <IdentNode start="(22, 36)" end="(22, 37)" leading="" trailing="" raw_val="j" val="j"/>
                    <AtomNode start="(22, 37)" end="(22, 39)" leading="" trailing="" val="]'"/>
                    <OtherNode start="(22, 39)" end="(22, 65)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(22, 39)" end="(22, 40)" leading="" trailing="" val="("/>
                      <OtherNode start="(22, 40)" end="(22, 64)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(22, 40)" end="(22, 58)" leading="" trailing=" " raw_val="Nat.lt_of_lt_of_le" val="Nat.lt_of_lt_of_le" full_name="Nat.lt_of_lt_of_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        <NullNode start="(22, 59)" end="(22, 64)">
                          <IdentNode start="(22, 59)" end="(22, 61)" leading="" trailing=" " raw_val="hj" val="hj"/>
                          <IdentNode start="(22, 62)" end="(22, 64)" leading="" trailing="" raw_val="hi" val="hi"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(22, 64)" end="(22, 65)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(22, 65)" end="(22, 66)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(22, 67)" end="(22, 109)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(22, 67)" end="(22, 68)" leading="" trailing="" val="("/>
                  <OtherNode start="(22, 68)" end="(22, 108)" kind="«term__[_]'_»">
                    <IdentNode start="(22, 68)" end="(22, 70)" leading="" trailing="" raw_val="ys" val="ys"/>
                    <AtomNode start="(22, 70)" end="(22, 71)" leading="" trailing="" val="["/>
                    <IdentNode start="(22, 71)" end="(22, 72)" leading="" trailing="" raw_val="j" val="j"/>
                    <AtomNode start="(22, 72)" end="(22, 74)" leading="" trailing="" val="]'"/>
                    <OtherNode start="(22, 74)" end="(22, 108)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(22, 74)" end="(22, 75)" leading="" trailing="" val="("/>
                      <OtherNode start="(22, 75)" end="(22, 107)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(22, 75)" end="(22, 93)" leading="" trailing=" " raw_val="Nat.lt_of_lt_of_le" val="Nat.lt_of_lt_of_le" full_name="Nat.lt_of_lt_of_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        <NullNode start="(22, 94)" end="(22, 107)">
                          <IdentNode start="(22, 94)" end="(22, 96)" leading="" trailing=" " raw_val="hj" val="hj"/>
                          <OtherNode start="(22, 97)" end="(22, 107)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(22, 97)" end="(22, 98)" leading="" trailing="" val="("/>
                            <OtherNode start="(22, 98)" end="(22, 106)" kind="Lean.Parser.Term.subst">
                              <IdentNode start="(22, 98)" end="(22, 101)" leading="" trailing=" " raw_val="hsz" val="hsz"/>
                              <AtomNode start="(22, 102)" end="(22, 103)" leading="" trailing=" " val="▸"/>
                              <NullNode start="(22, 104)" end="(22, 106)">
                                <IdentNode start="(22, 104)" end="(22, 106)" leading="" trailing="" raw_val="hi" val="hi"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(22, 106)" end="(22, 107)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(22, 107)" end="(22, 108)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(22, 108)" end="(22, 109)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(22, 110)" end="(33, 22)">
          <AtomNode start="(22, 110)" end="(22, 112)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(22, 113)" end="(33, 22)">
            <AtomNode start="(22, 113)" end="(22, 115)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(23, 3)" end="(33, 22)">
              <TacticTacticseq1IndentedNode start="(23, 3)" end="(33, 22)">
                <NullNode start="(23, 3)" end="(33, 22)">
                  <OtherNode start="(23, 3)" end="(33, 22)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;i : Nat&#10;hi : i ≤ xs.size&#10;heqv : xs.isEqvAux ys hsz r i hi = true&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true" state_after="no goals" tactic="induction i with&#10;| zero =&amp;gt; contradiction&#10;| succ i ih =&amp;gt;&#10;  simp only [Array.isEqvAux, Bool.and_eq_true, decide_eq_true_eq] at heqv&#10;  by_cases hj' : j &amp;lt; i&#10;  next =&amp;gt;&#10;    exact ih _ heqv.right hj'&#10;  next =&amp;gt;&#10;    replace hj' : j = i := Nat.eq_of_le_of_lt_succ (Nat.not_lt.mp hj') hj&#10;    subst hj'&#10;    exact heqv.left">
                    <AtomNode start="(23, 3)" end="(23, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(23, 13)" end="(23, 14)">
                      <OtherNode start="(23, 13)" end="(23, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(23, 13)" end="(23, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(23, 15)" end="(33, 22)">
                      <OtherNode start="(23, 15)" end="(33, 22)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(23, 15)" end="(23, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(24, 3)" end="(33, 22)">
                          <OtherNode start="(24, 3)" end="(24, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(24, 3)" end="(24, 9)">
                              <OtherNode start="(24, 3)" end="(24, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(24, 3)" end="(24, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(24, 5)" end="(24, 9)">
                                  <NullNode/>
                                  <IdentNode start="(24, 5)" end="(24, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(24, 10)" end="(24, 26)">
                              <AtomNode start="(24, 10)" end="(24, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(24, 13)" end="(24, 26)">
                                <TacticTacticseq1IndentedNode start="(24, 13)" end="(24, 26)">
                                  <NullNode start="(24, 13)" end="(24, 26)">
                                    <OtherNode start="(24, 13)" end="(24, 26)" kind="Lean.Parser.Tactic.contradiction" state_before="case zero&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j : Nat&#10;hi : 0 ≤ xs.size&#10;heqv : xs.isEqvAux ys hsz r 0 hi = true&#10;hj : j &amp;lt; 0&#10;⊢ r xs[j] ys[j] = true" state_after="no goals" tactic="contradiction">
                                      <AtomNode start="(24, 13)" end="(24, 26)" leading="" trailing="&#10;  " val="contradiction"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(25, 3)" end="(33, 22)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(25, 3)" end="(25, 14)">
                              <OtherNode start="(25, 3)" end="(25, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(25, 3)" end="(25, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(25, 5)" end="(25, 9)">
                                  <NullNode/>
                                  <IdentNode start="(25, 5)" end="(25, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(25, 10)" end="(25, 14)">
                                  <IdentNode start="(25, 10)" end="(25, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(25, 12)" end="(25, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(25, 15)" end="(33, 22)">
                              <AtomNode start="(25, 15)" end="(25, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(26, 5)" end="(33, 22)">
                                <TacticTacticseq1IndentedNode start="(26, 5)" end="(33, 22)">
                                  <NullNode start="(26, 5)" end="(33, 22)">
                                    <OtherNode start="(26, 5)" end="(26, 76)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;heqv : xs.isEqvAux ys hsz r (i + 1) hi = true&#10;hj : j &amp;lt; i + 1&#10;⊢ r xs[j] ys[j] = true" state_after="case succ&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;⊢ r xs[j] ys[j] = true" tactic="simp only [Array.isEqvAux, Bool.and_eq_true, decide_eq_true_eq] at heqv">
                                      <AtomNode start="(26, 5)" end="(26, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(26, 10)" end="(26, 14)">
                                        <AtomNode start="(26, 10)" end="(26, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(26, 15)" end="(26, 68)">
                                        <AtomNode start="(26, 15)" end="(26, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(26, 16)" end="(26, 67)">
                                          <OtherNode start="(26, 16)" end="(26, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(26, 16)" end="(26, 30)" leading="" trailing="" raw_val="Array.isEqvAux" val="Array.isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(26, 30)" end="(26, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(26, 32)" end="(26, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(26, 32)" end="(26, 48)" leading="" trailing="" raw_val="Bool.and_eq_true" val="Bool.and_eq_true" full_name="Bool.and_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(26, 48)" end="(26, 49)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(26, 50)" end="(26, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(26, 50)" end="(26, 67)" leading="" trailing="" raw_val="decide_eq_true_eq" val="decide_eq_true_eq" full_name="decide_eq_true_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(26, 67)" end="(26, 68)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(26, 69)" end="(26, 76)">
                                        <OtherNode start="(26, 69)" end="(26, 76)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(26, 69)" end="(26, 71)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(26, 72)" end="(26, 76)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(26, 72)" end="(26, 76)">
                                              <IdentNode start="(26, 72)" end="(26, 76)" leading="" trailing="&#10;    " raw_val="heqv" val="heqv"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(27, 5)" end="(27, 25)" kind="«tacticBy_cases_:_»" state_before="case succ&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;⊢ r xs[j] ys[j] = true" state_after="case pos&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true&#10;&#10;case neg&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : ¬j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true" tactic="by_cases hj' : j &amp;lt; i">
                                      <AtomNode start="(27, 5)" end="(27, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode start="(27, 14)" end="(27, 19)">
                                        <IdentNode start="(27, 14)" end="(27, 17)" leading="" trailing=" " raw_val="hj'" val="hj'"/>
                                        <AtomNode start="(27, 18)" end="(27, 19)" leading="" trailing=" " val=":"/>
                                      </NullNode>
                                      <OtherNode start="(27, 20)" end="(27, 25)" kind="«term_&amp;lt;_»">
                                        <IdentNode start="(27, 20)" end="(27, 21)" leading="" trailing=" " raw_val="j" val="j"/>
                                        <AtomNode start="(27, 22)" end="(27, 23)" leading="" trailing=" " val="&amp;lt;"/>
                                        <IdentNode start="(27, 24)" end="(27, 25)" leading="" trailing="&#10;    " raw_val="i" val="i"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(28, 5)" end="(29, 32)" kind="Lean.Parser.Tactic.«tacticNext_=&amp;gt;_»" state_before="case pos&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true&#10;&#10;case neg&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : ¬j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true" state_after="case neg&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : ¬j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true" tactic="next =&amp;gt;&#10;  exact ih _ heqv.right hj'">
                                      <AtomNode start="(28, 5)" end="(28, 9)" leading="" trailing=" " val="next"/>
                                      <NullNode/>
                                      <AtomNode start="(28, 10)" end="(28, 12)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(29, 7)" end="(29, 32)">
                                        <TacticTacticseq1IndentedNode start="(29, 7)" end="(29, 32)">
                                          <NullNode start="(29, 7)" end="(29, 32)">
                                            <OtherNode start="(29, 7)" end="(29, 32)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true" state_after="no goals" tactic="exact ih _ heqv.right hj'">
                                              <AtomNode start="(29, 7)" end="(29, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(29, 13)" end="(29, 32)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(29, 13)" end="(29, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(29, 16)" end="(29, 32)">
                                                  <TermHoleNode start="(29, 16)" end="(29, 17)">
                                                    <AtomNode start="(29, 16)" end="(29, 17)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <IdentNode start="(29, 18)" end="(29, 28)" leading="" trailing=" " raw_val="heqv.right" val="heqv.right"/>
                                                  <IdentNode start="(29, 29)" end="(29, 32)" leading="" trailing="&#10;    " raw_val="hj'" val="hj'"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(30, 5)" end="(33, 22)" kind="Lean.Parser.Tactic.«tacticNext_=&amp;gt;_»" state_before="case neg&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : ¬j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true" state_after="no goals" tactic="next =&amp;gt;&#10;  replace hj' : j = i := Nat.eq_of_le_of_lt_succ (Nat.not_lt.mp hj') hj&#10;  subst hj'&#10;  exact heqv.left">
                                      <AtomNode start="(30, 5)" end="(30, 9)" leading="" trailing=" " val="next"/>
                                      <NullNode/>
                                      <AtomNode start="(30, 10)" end="(30, 12)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(31, 7)" end="(33, 22)">
                                        <TacticTacticseq1IndentedNode start="(31, 7)" end="(33, 22)">
                                          <NullNode start="(31, 7)" end="(33, 22)">
                                            <OtherNode start="(31, 7)" end="(31, 76)" kind="Lean.Parser.Tactic.replace" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : ¬j &amp;lt; i&#10;⊢ r xs[j] ys[j] = true" state_after="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : j = i&#10;⊢ r xs[j] ys[j] = true" tactic="replace hj' : j = i := Nat.eq_of_le_of_lt_succ (Nat.not_lt.mp hj') hj">
                                              <AtomNode start="(31, 7)" end="(31, 14)" leading="" trailing=" " val="replace"/>
                                              <OtherNode start="(31, 15)" end="(31, 76)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(31, 15)" end="(31, 76)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(31, 15)" end="(31, 18)" kind="Lean.Parser.Term.haveId">
                                                    <IdentNode start="(31, 15)" end="(31, 18)" leading="" trailing=" " raw_val="hj'" val="hj'"/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(31, 19)" end="(31, 26)">
                                                    <TermTypespecNode start="(31, 19)" end="(31, 26)">
                                                      <AtomNode start="(31, 19)" end="(31, 20)" leading="" trailing=" " val=":"/>
                                                      <OtherNode start="(31, 21)" end="(31, 26)" kind="«term_=_»">
                                                        <IdentNode start="(31, 21)" end="(31, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                                                        <AtomNode start="(31, 23)" end="(31, 24)" leading="" trailing=" " val="="/>
                                                        <IdentNode start="(31, 25)" end="(31, 26)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      </OtherNode>
                                                    </TermTypespecNode>
                                                  </NullNode>
                                                  <AtomNode start="(31, 27)" end="(31, 29)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(31, 30)" end="(31, 76)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(31, 30)" end="(31, 53)" leading="" trailing=" " raw_val="Nat.eq_of_le_of_lt_succ" val="Nat.eq_of_le_of_lt_succ" full_name="Nat.eq_of_le_of_lt_succ" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                    <NullNode start="(31, 54)" end="(31, 76)">
                                                      <OtherNode start="(31, 54)" end="(31, 73)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(31, 54)" end="(31, 55)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(31, 55)" end="(31, 72)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(31, 55)" end="(31, 68)" leading="" trailing=" " raw_val="Nat.not_lt.mp" val="Nat.not_lt.mp"/>
                                                          <NullNode start="(31, 69)" end="(31, 72)">
                                                            <IdentNode start="(31, 69)" end="(31, 72)" leading="" trailing="" raw_val="hj'" val="hj'"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(31, 72)" end="(31, 73)" leading="" trailing=" " val=")"/>
                                                      </OtherNode>
                                                      <IdentNode start="(31, 74)" end="(31, 76)" leading="" trailing="&#10;      " raw_val="hj" val="hj"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(32, 7)" end="(32, 16)" kind="Lean.Parser.Tactic.subst" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), xs.isEqvAux ys hsz r i hi = true → ∀ (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;hi : i + 1 ≤ xs.size&#10;hj : j &amp;lt; i + 1&#10;heqv : r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true&#10;hj' : j = i&#10;⊢ r xs[j] ys[j] = true" state_after="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j : Nat&#10;ih : ∀ (hi : j ≤ xs.size), xs.isEqvAux ys hsz r j hi = true → ∀ (hj : j &amp;lt; j), r xs[j] ys[j] = true&#10;hi : j + 1 ≤ xs.size&#10;hj : j &amp;lt; j + 1&#10;heqv : r xs[j] ys[j] = true ∧ xs.isEqvAux ys hsz r j ⋯ = true&#10;⊢ r xs[j] ys[j] = true" tactic="subst hj'">
                                              <AtomNode start="(32, 7)" end="(32, 12)" leading="" trailing=" " val="subst"/>
                                              <NullNode start="(32, 13)" end="(32, 16)">
                                                <IdentNode start="(32, 13)" end="(32, 16)" leading="" trailing="&#10;      " raw_val="hj'" val="hj'"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(33, 7)" end="(33, 22)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;j : Nat&#10;ih : ∀ (hi : j ≤ xs.size), xs.isEqvAux ys hsz r j hi = true → ∀ (hj : j &amp;lt; j), r xs[j] ys[j] = true&#10;hi : j + 1 ≤ xs.size&#10;hj : j &amp;lt; j + 1&#10;heqv : r xs[j] ys[j] = true ∧ xs.isEqvAux ys hsz r j ⋯ = true&#10;⊢ r xs[j] ys[j] = true" state_after="no goals" tactic="exact heqv.left">
                                              <AtomNode start="(33, 7)" end="(33, 12)" leading="" trailing=" " val="exact"/>
                                              <IdentNode start="(33, 13)" end="(33, 22)" leading="" trailing="&#10;&#10;" raw_val="heqv.left" val="heqv.left"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(35, 1)" end="(41, 81)" name="isEqvAux_of_rel" full_name="Array.isEqvAux_of_rel">
      <CommandDeclmodifiersNode start="(35, 1)" end="(35, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(35, 1)" end="(35, 8)">
          <CommandPrivateNode start="(35, 1)" end="(35, 8)">
            <AtomNode start="(35, 1)" end="(35, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(35, 9)" end="(41, 81)" name="isEqvAux_of_rel" full_name="Array.isEqvAux_of_rel" _is_private_decl="True">
        <AtomNode start="(35, 9)" end="(35, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(35, 17)" end="(35, 32)">
          <IdentNode start="(35, 17)" end="(35, 32)" leading="" trailing=" " raw_val="isEqvAux_of_rel" val="isEqvAux_of_rel"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(35, 33)" end="(36, 144)">
          <NullNode start="(35, 33)" end="(36, 110)">
            <OtherNode start="(35, 33)" end="(35, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(35, 33)" end="(35, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(35, 34)" end="(35, 35)">
                <IdentNode start="(35, 34)" end="(35, 35)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(35, 36)" end="(35, 50)">
                <AtomNode start="(35, 36)" end="(35, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 38)" end="(35, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(35, 38)" end="(35, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(35, 40)" end="(35, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(35, 42)" end="(35, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(35, 42)" end="(35, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(35, 44)" end="(35, 45)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(35, 46)" end="(35, 50)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(35, 50)" end="(35, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(35, 52)" end="(35, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(35, 52)" end="(35, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(35, 53)" end="(35, 58)">
                <IdentNode start="(35, 53)" end="(35, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(35, 56)" end="(35, 58)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(35, 59)" end="(35, 68)">
                <AtomNode start="(35, 59)" end="(35, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 61)" end="(35, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(35, 61)" end="(35, 66)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(35, 67)" end="(35, 68)">
                    <IdentNode start="(35, 67)" end="(35, 68)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(35, 68)" end="(35, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(35, 70)" end="(35, 95)">
              <AtomNode start="(35, 70)" end="(35, 71)" leading="" trailing="" val="("/>
              <NullNode start="(35, 71)" end="(35, 74)">
                <IdentNode start="(35, 71)" end="(35, 74)" leading="" trailing=" " raw_val="hsz" val="hsz"/>
              </NullNode>
              <NullNode start="(35, 75)" end="(35, 94)">
                <AtomNode start="(35, 75)" end="(35, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 77)" end="(35, 94)" kind="«term_=_»">
                  <IdentNode start="(35, 77)" end="(35, 84)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(35, 85)" end="(35, 86)" leading="" trailing=" " val="="/>
                  <IdentNode start="(35, 87)" end="(35, 94)" leading="" trailing="" raw_val="ys.size" val="ys.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(35, 94)" end="(35, 95)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(35, 96)" end="(35, 105)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(35, 96)" end="(35, 97)" leading="" trailing="" val="{"/>
              <NullNode start="(35, 97)" end="(35, 98)">
                <IdentNode start="(35, 97)" end="(35, 98)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(35, 99)" end="(35, 104)">
                <AtomNode start="(35, 99)" end="(35, 100)" leading="" trailing=" " val=":"/>
                <IdentNode start="(35, 101)" end="(35, 104)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(35, 104)" end="(35, 105)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(35, 106)" end="(35, 124)">
              <AtomNode start="(35, 106)" end="(35, 107)" leading="" trailing="" val="("/>
              <NullNode start="(35, 107)" end="(35, 109)">
                <IdentNode start="(35, 107)" end="(35, 109)" leading="" trailing=" " raw_val="hi" val="hi"/>
              </NullNode>
              <NullNode start="(35, 110)" end="(35, 123)">
                <AtomNode start="(35, 110)" end="(35, 111)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 112)" end="(35, 123)" kind="«term_≤_»">
                  <IdentNode start="(35, 112)" end="(35, 113)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(35, 114)" end="(35, 115)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(35, 116)" end="(35, 123)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(35, 123)" end="(35, 124)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(36, 5)" end="(36, 110)">
              <AtomNode start="(36, 5)" end="(36, 6)" leading="" trailing="" val="("/>
              <NullNode start="(36, 6)" end="(36, 7)">
                <IdentNode start="(36, 6)" end="(36, 7)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(36, 8)" end="(36, 109)">
                <AtomNode start="(36, 8)" end="(36, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(36, 10)" end="(36, 109)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(36, 10)" end="(36, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(36, 12)" end="(36, 13)">
                    <IdentNode start="(36, 12)" end="(36, 13)" leading="" trailing="" raw_val="j" val="j"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(36, 13)" end="(36, 14)" leading="" trailing=" " val=","/>
                  <OtherNode start="(36, 15)" end="(36, 109)" kind="Lean.Parser.Term.depArrow">
                    <TermExplicitbinderNode start="(36, 15)" end="(36, 27)">
                      <AtomNode start="(36, 15)" end="(36, 16)" leading="" trailing="" val="("/>
                      <NullNode start="(36, 16)" end="(36, 18)">
                        <IdentNode start="(36, 16)" end="(36, 18)" leading="" trailing=" " raw_val="hj" val="hj"/>
                      </NullNode>
                      <NullNode start="(36, 19)" end="(36, 26)">
                        <AtomNode start="(36, 19)" end="(36, 20)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(36, 21)" end="(36, 26)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(36, 21)" end="(36, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(36, 23)" end="(36, 24)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(36, 25)" end="(36, 26)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(36, 26)" end="(36, 27)" leading="" trailing=" " val=")"/>
                    </TermExplicitbinderNode>
                    <AtomNode start="(36, 28)" end="(36, 29)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(36, 30)" end="(36, 109)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(36, 30)" end="(36, 31)" leading="" trailing=" " raw_val="r" val="r"/>
                      <NullNode start="(36, 32)" end="(36, 109)">
                        <OtherNode start="(36, 32)" end="(36, 66)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(36, 32)" end="(36, 33)" leading="" trailing="" val="("/>
                          <OtherNode start="(36, 33)" end="(36, 65)" kind="«term__[_]'_»">
                            <IdentNode start="(36, 33)" end="(36, 35)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(36, 35)" end="(36, 36)" leading="" trailing="" val="["/>
                            <IdentNode start="(36, 36)" end="(36, 37)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(36, 37)" end="(36, 39)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(36, 39)" end="(36, 65)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(36, 39)" end="(36, 40)" leading="" trailing="" val="("/>
                              <OtherNode start="(36, 40)" end="(36, 64)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(36, 40)" end="(36, 58)" leading="" trailing=" " raw_val="Nat.lt_of_lt_of_le" val="Nat.lt_of_lt_of_le" full_name="Nat.lt_of_lt_of_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                <NullNode start="(36, 59)" end="(36, 64)">
                                  <IdentNode start="(36, 59)" end="(36, 61)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                  <IdentNode start="(36, 62)" end="(36, 64)" leading="" trailing="" raw_val="hi" val="hi"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(36, 64)" end="(36, 65)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(36, 65)" end="(36, 66)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(36, 67)" end="(36, 109)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(36, 67)" end="(36, 68)" leading="" trailing="" val="("/>
                          <OtherNode start="(36, 68)" end="(36, 108)" kind="«term__[_]'_»">
                            <IdentNode start="(36, 68)" end="(36, 70)" leading="" trailing="" raw_val="ys" val="ys"/>
                            <AtomNode start="(36, 70)" end="(36, 71)" leading="" trailing="" val="["/>
                            <IdentNode start="(36, 71)" end="(36, 72)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(36, 72)" end="(36, 74)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(36, 74)" end="(36, 108)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(36, 74)" end="(36, 75)" leading="" trailing="" val="("/>
                              <OtherNode start="(36, 75)" end="(36, 107)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(36, 75)" end="(36, 93)" leading="" trailing=" " raw_val="Nat.lt_of_lt_of_le" val="Nat.lt_of_lt_of_le" full_name="Nat.lt_of_lt_of_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                <NullNode start="(36, 94)" end="(36, 107)">
                                  <IdentNode start="(36, 94)" end="(36, 96)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                  <OtherNode start="(36, 97)" end="(36, 107)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(36, 97)" end="(36, 98)" leading="" trailing="" val="("/>
                                    <OtherNode start="(36, 98)" end="(36, 106)" kind="Lean.Parser.Term.subst">
                                      <IdentNode start="(36, 98)" end="(36, 101)" leading="" trailing=" " raw_val="hsz" val="hsz"/>
                                      <AtomNode start="(36, 102)" end="(36, 103)" leading="" trailing=" " val="▸"/>
                                      <NullNode start="(36, 104)" end="(36, 106)">
                                        <IdentNode start="(36, 104)" end="(36, 106)" leading="" trailing="" raw_val="hi" val="hi"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(36, 106)" end="(36, 107)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(36, 107)" end="(36, 108)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(36, 108)" end="(36, 109)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(36, 109)" end="(36, 110)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(36, 111)" end="(36, 144)">
            <AtomNode start="(36, 111)" end="(36, 112)" leading="" trailing=" " val=":"/>
            <OtherNode start="(36, 113)" end="(36, 144)" kind="Lean.Parser.Term.app">
              <IdentNode start="(36, 113)" end="(36, 127)" leading="" trailing=" " raw_val="Array.isEqvAux" val="Array.isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
              <NullNode start="(36, 128)" end="(36, 144)">
                <IdentNode start="(36, 128)" end="(36, 130)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(36, 131)" end="(36, 133)" leading="" trailing=" " raw_val="ys" val="ys"/>
                <IdentNode start="(36, 134)" end="(36, 137)" leading="" trailing=" " raw_val="hsz" val="hsz"/>
                <IdentNode start="(36, 138)" end="(36, 139)" leading="" trailing=" " raw_val="r" val="r"/>
                <IdentNode start="(36, 140)" end="(36, 141)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(36, 142)" end="(36, 144)" leading="" trailing=" " raw_val="hi" val="hi"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(36, 145)" end="(41, 81)">
          <AtomNode start="(36, 145)" end="(36, 147)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(36, 148)" end="(41, 81)">
            <AtomNode start="(36, 148)" end="(36, 150)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(37, 3)" end="(41, 81)">
              <TacticTacticseq1IndentedNode start="(37, 3)" end="(41, 81)">
                <NullNode start="(37, 3)" end="(41, 81)">
                  <OtherNode start="(37, 3)" end="(41, 81)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;i : Nat&#10;hi : i ≤ xs.size&#10;w : ∀ (j : Nat) (hj : j &amp;lt; i), r xs[j] ys[j] = true&#10;⊢ xs.isEqvAux ys hsz r i hi = true" state_after="no goals" tactic="induction i with&#10;| zero =&amp;gt; simp [Array.isEqvAux]&#10;| succ i ih =&amp;gt;&#10;  simp only [isEqvAux, Bool.and_eq_true]&#10;  exact ⟨w i (Nat.lt_add_one i), ih _ fun j hj =&amp;gt; w j (Nat.lt_add_right 1 hj)⟩">
                    <AtomNode start="(37, 3)" end="(37, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(37, 13)" end="(37, 14)">
                      <OtherNode start="(37, 13)" end="(37, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(37, 13)" end="(37, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(37, 15)" end="(41, 81)">
                      <OtherNode start="(37, 15)" end="(41, 81)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(37, 15)" end="(37, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(38, 3)" end="(41, 81)">
                          <OtherNode start="(38, 3)" end="(38, 34)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(38, 3)" end="(38, 9)">
                              <OtherNode start="(38, 3)" end="(38, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(38, 3)" end="(38, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(38, 5)" end="(38, 9)">
                                  <NullNode/>
                                  <IdentNode start="(38, 5)" end="(38, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(38, 10)" end="(38, 34)">
                              <AtomNode start="(38, 10)" end="(38, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(38, 13)" end="(38, 34)">
                                <TacticTacticseq1IndentedNode start="(38, 13)" end="(38, 34)">
                                  <NullNode start="(38, 13)" end="(38, 34)">
                                    <OtherNode start="(38, 13)" end="(38, 34)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;hi : 0 ≤ xs.size&#10;w : ∀ (j : Nat) (hj : j &amp;lt; 0), r xs[j] ys[j] = true&#10;⊢ xs.isEqvAux ys hsz r 0 hi = true" state_after="no goals" tactic="simp [Array.isEqvAux]">
                                      <AtomNode start="(38, 13)" end="(38, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(38, 18)" end="(38, 34)">
                                        <AtomNode start="(38, 18)" end="(38, 19)" leading="" trailing="" val="["/>
                                        <NullNode start="(38, 19)" end="(38, 33)">
                                          <OtherNode start="(38, 19)" end="(38, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(38, 19)" end="(38, 33)" leading="" trailing="" raw_val="Array.isEqvAux" val="Array.isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(38, 33)" end="(38, 34)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(39, 3)" end="(41, 81)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(39, 3)" end="(39, 14)">
                              <OtherNode start="(39, 3)" end="(39, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(39, 3)" end="(39, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(39, 5)" end="(39, 9)">
                                  <NullNode/>
                                  <IdentNode start="(39, 5)" end="(39, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(39, 10)" end="(39, 14)">
                                  <IdentNode start="(39, 10)" end="(39, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(39, 12)" end="(39, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(39, 15)" end="(41, 81)">
                              <AtomNode start="(39, 15)" end="(39, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(40, 5)" end="(41, 81)">
                                <TacticTacticseq1IndentedNode start="(40, 5)" end="(41, 81)">
                                  <NullNode start="(40, 5)" end="(41, 81)">
                                    <OtherNode start="(40, 5)" end="(40, 43)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), (∀ (j : Nat) (hj : j &amp;lt; i), r xs[j] ys[j] = true) → xs.isEqvAux ys hsz r i hi = true&#10;hi : i + 1 ≤ xs.size&#10;w : ∀ (j : Nat) (hj : j &amp;lt; i + 1), r xs[j] ys[j] = true&#10;⊢ xs.isEqvAux ys hsz r (i + 1) hi = true" state_after="case succ&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), (∀ (j : Nat) (hj : j &amp;lt; i), r xs[j] ys[j] = true) → xs.isEqvAux ys hsz r i hi = true&#10;hi : i + 1 ≤ xs.size&#10;w : ∀ (j : Nat) (hj : j &amp;lt; i + 1), r xs[j] ys[j] = true&#10;⊢ r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true" tactic="simp only [isEqvAux, Bool.and_eq_true]">
                                      <AtomNode start="(40, 5)" end="(40, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(40, 10)" end="(40, 14)">
                                        <AtomNode start="(40, 10)" end="(40, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(40, 15)" end="(40, 43)">
                                        <AtomNode start="(40, 15)" end="(40, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(40, 16)" end="(40, 42)">
                                          <OtherNode start="(40, 16)" end="(40, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(40, 16)" end="(40, 24)" leading="" trailing="" raw_val="isEqvAux" val="isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(40, 24)" end="(40, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(40, 26)" end="(40, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(40, 26)" end="(40, 42)" leading="" trailing="" raw_val="Bool.and_eq_true" val="Bool.and_eq_true" full_name="Bool.and_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(40, 42)" end="(40, 43)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(41, 5)" end="(41, 81)" kind="Lean.Parser.Tactic.exact" state_before="case succ&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;hsz : xs.size = ys.size&#10;i : Nat&#10;ih : ∀ (hi : i ≤ xs.size), (∀ (j : Nat) (hj : j &amp;lt; i), r xs[j] ys[j] = true) → xs.isEqvAux ys hsz r i hi = true&#10;hi : i + 1 ≤ xs.size&#10;w : ∀ (j : Nat) (hj : j &amp;lt; i + 1), r xs[j] ys[j] = true&#10;⊢ r xs[i] ys[i] = true ∧ xs.isEqvAux ys hsz r i ⋯ = true" state_after="no goals" tactic="exact ⟨w i (Nat.lt_add_one i), ih _ fun j hj =&amp;gt; w j (Nat.lt_add_right 1 hj)⟩">
                                      <AtomNode start="(41, 5)" end="(41, 10)" leading="" trailing=" " val="exact"/>
                                      <OtherNode start="(41, 11)" end="(41, 81)" kind="Lean.Parser.Term.anonymousCtor">
                                        <AtomNode start="(41, 11)" end="(41, 12)" leading="" trailing="" val="⟨"/>
                                        <NullNode start="(41, 12)" end="(41, 80)">
                                          <OtherNode start="(41, 12)" end="(41, 34)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(41, 12)" end="(41, 13)" leading="" trailing=" " raw_val="w" val="w"/>
                                            <NullNode start="(41, 14)" end="(41, 34)">
                                              <IdentNode start="(41, 14)" end="(41, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                                              <OtherNode start="(41, 16)" end="(41, 34)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(41, 16)" end="(41, 17)" leading="" trailing="" val="("/>
                                                <OtherNode start="(41, 17)" end="(41, 33)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(41, 17)" end="(41, 31)" leading="" trailing=" " raw_val="Nat.lt_add_one" val="Nat.lt_add_one" full_name="Nat.lt_add_one" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  <NullNode start="(41, 32)" end="(41, 33)">
                                                    <IdentNode start="(41, 32)" end="(41, 33)" leading="" trailing="" raw_val="i" val="i"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(41, 33)" end="(41, 34)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(41, 34)" end="(41, 35)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(41, 36)" end="(41, 80)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(41, 36)" end="(41, 38)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                            <NullNode start="(41, 39)" end="(41, 80)">
                                              <TermHoleNode start="(41, 39)" end="(41, 40)">
                                                <AtomNode start="(41, 39)" end="(41, 40)" leading="" trailing=" " val="_"/>
                                              </TermHoleNode>
                                              <OtherNode start="(41, 41)" end="(41, 80)" kind="Lean.Parser.Term.fun">
                                                <AtomNode start="(41, 41)" end="(41, 44)" leading="" trailing=" " val="fun"/>
                                                <OtherNode start="(41, 45)" end="(41, 80)" kind="Lean.Parser.Term.basicFun">
                                                  <NullNode start="(41, 45)" end="(41, 49)">
                                                    <IdentNode start="(41, 45)" end="(41, 46)" leading="" trailing=" " raw_val="j" val="j"/>
                                                    <IdentNode start="(41, 47)" end="(41, 49)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                  <AtomNode start="(41, 50)" end="(41, 52)" leading="" trailing=" " val="=&amp;gt;"/>
                                                  <OtherNode start="(41, 53)" end="(41, 80)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(41, 53)" end="(41, 54)" leading="" trailing=" " raw_val="w" val="w"/>
                                                    <NullNode start="(41, 55)" end="(41, 80)">
                                                      <IdentNode start="(41, 55)" end="(41, 56)" leading="" trailing=" " raw_val="j" val="j"/>
                                                      <OtherNode start="(41, 57)" end="(41, 80)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(41, 57)" end="(41, 58)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(41, 58)" end="(41, 79)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(41, 58)" end="(41, 74)" leading="" trailing=" " raw_val="Nat.lt_add_right" val="Nat.lt_add_right" full_name="Nat.lt_add_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          <NullNode start="(41, 75)" end="(41, 79)">
                                                            <OtherNode start="(41, 75)" end="(41, 76)" kind="num">
                                                            <AtomNode start="(41, 75)" end="(41, 76)" leading="" trailing=" " val="1"/>
                                                            </OtherNode>
                                                            <IdentNode start="(41, 77)" end="(41, 79)" leading="" trailing="" raw_val="hj" val="hj"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(41, 79)" end="(41, 80)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(41, 80)" end="(41, 81)" leading="" trailing="&#10;&#10;-- This is private as the forward direction of `isEqv_iff_rel` may be used.&#10;" val="⟩"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(44, 1)" end="(49, 25)" name="rel_of_isEqv" full_name="Array.rel_of_isEqv">
      <CommandDeclmodifiersNode start="(44, 1)" end="(44, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(44, 1)" end="(44, 8)">
          <CommandPrivateNode start="(44, 1)" end="(44, 8)">
            <AtomNode start="(44, 1)" end="(44, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(44, 9)" end="(49, 25)" name="rel_of_isEqv" full_name="Array.rel_of_isEqv" _is_private_decl="True">
        <AtomNode start="(44, 9)" end="(44, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(44, 17)" end="(44, 29)">
          <IdentNode start="(44, 17)" end="(44, 29)" leading="" trailing=" " raw_val="rel_of_isEqv" val="rel_of_isEqv"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(44, 30)" end="(45, 110)">
          <NullNode start="(44, 30)" end="(44, 66)">
            <OtherNode start="(44, 30)" end="(44, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(44, 30)" end="(44, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(44, 31)" end="(44, 32)">
                <IdentNode start="(44, 31)" end="(44, 32)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(44, 33)" end="(44, 47)">
                <AtomNode start="(44, 33)" end="(44, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(44, 35)" end="(44, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(44, 35)" end="(44, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(44, 37)" end="(44, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(44, 39)" end="(44, 47)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(44, 39)" end="(44, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(44, 41)" end="(44, 42)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(44, 43)" end="(44, 47)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(44, 47)" end="(44, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(44, 49)" end="(44, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(44, 49)" end="(44, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(44, 50)" end="(44, 55)">
                <IdentNode start="(44, 50)" end="(44, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(44, 53)" end="(44, 55)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(44, 56)" end="(44, 65)">
                <AtomNode start="(44, 56)" end="(44, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(44, 58)" end="(44, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(44, 58)" end="(44, 63)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(44, 64)" end="(44, 65)">
                    <IdentNode start="(44, 64)" end="(44, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(44, 65)" end="(44, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(44, 67)" end="(45, 110)">
            <AtomNode start="(44, 67)" end="(44, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(45, 5)" end="(45, 110)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(45, 5)" end="(45, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(45, 5)" end="(45, 16)" leading="" trailing=" " raw_val="Array.isEqv" val="Array.isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(45, 17)" end="(45, 24)">
                  <IdentNode start="(45, 17)" end="(45, 19)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(45, 20)" end="(45, 22)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  <IdentNode start="(45, 23)" end="(45, 24)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(45, 25)" end="(45, 26)" leading="" trailing=" " val="→"/>
              <OtherNode start="(45, 27)" end="(45, 110)" kind="«term∃_,_»">
                <AtomNode start="(45, 27)" end="(45, 28)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(45, 29)" end="(45, 50)" kind="Lean.explicitBinders">
                  <OtherNode start="(45, 29)" end="(45, 50)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(45, 29)" end="(45, 30)">
                      <LeanBinderidentNode start="(45, 29)" end="(45, 30)">
                        <IdentNode start="(45, 29)" end="(45, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode start="(45, 31)" end="(45, 50)">
                      <AtomNode start="(45, 31)" end="(45, 32)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(45, 33)" end="(45, 50)" kind="«term_=_»">
                        <IdentNode start="(45, 33)" end="(45, 40)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                        <AtomNode start="(45, 41)" end="(45, 42)" leading="" trailing=" " val="="/>
                        <IdentNode start="(45, 43)" end="(45, 50)" leading="" trailing="" raw_val="ys.size" val="ys.size"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(45, 50)" end="(45, 51)" leading="" trailing=" " val=","/>
                <OtherNode start="(45, 52)" end="(45, 110)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(45, 52)" end="(45, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(45, 54)" end="(45, 82)">
                    <TermExplicitbinderNode start="(45, 54)" end="(45, 63)">
                      <AtomNode start="(45, 54)" end="(45, 55)" leading="" trailing="" val="("/>
                      <NullNode start="(45, 55)" end="(45, 56)">
                        <IdentNode start="(45, 55)" end="(45, 56)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(45, 57)" end="(45, 62)">
                        <AtomNode start="(45, 57)" end="(45, 58)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(45, 59)" end="(45, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(45, 62)" end="(45, 63)" leading="" trailing=" " val=")"/>
                    </TermExplicitbinderNode>
                    <TermExplicitbinderNode start="(45, 64)" end="(45, 82)">
                      <AtomNode start="(45, 64)" end="(45, 65)" leading="" trailing="" val="("/>
                      <NullNode start="(45, 65)" end="(45, 67)">
                        <IdentNode start="(45, 65)" end="(45, 67)" leading="" trailing=" " raw_val="h'" val="h'"/>
                      </NullNode>
                      <NullNode start="(45, 68)" end="(45, 81)">
                        <AtomNode start="(45, 68)" end="(45, 69)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(45, 70)" end="(45, 81)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(45, 70)" end="(45, 71)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(45, 72)" end="(45, 73)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(45, 74)" end="(45, 81)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(45, 81)" end="(45, 82)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(45, 82)" end="(45, 83)" leading="" trailing=" " val=","/>
                  <OtherNode start="(45, 84)" end="(45, 110)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(45, 84)" end="(45, 85)" leading="" trailing=" " raw_val="r" val="r"/>
                    <NullNode start="(45, 86)" end="(45, 110)">
                      <OtherNode start="(45, 86)" end="(45, 93)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(45, 86)" end="(45, 87)" leading="" trailing="" val="("/>
                        <OtherNode start="(45, 87)" end="(45, 92)" kind="«term__[_]»">
                          <IdentNode start="(45, 87)" end="(45, 89)" leading="" trailing="" raw_val="xs" val="xs"/>
                          <AtomNode start="(45, 89)" end="(45, 90)" leading="" trailing="" val="["/>
                          <IdentNode start="(45, 90)" end="(45, 91)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(45, 91)" end="(45, 92)" leading="" trailing="" val="]"/>
                        </OtherNode>
                        <AtomNode start="(45, 92)" end="(45, 93)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(45, 94)" end="(45, 110)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(45, 94)" end="(45, 95)" leading="" trailing="" val="("/>
                        <OtherNode start="(45, 95)" end="(45, 109)" kind="«term__[_]'_»">
                          <IdentNode start="(45, 95)" end="(45, 97)" leading="" trailing="" raw_val="ys" val="ys"/>
                          <AtomNode start="(45, 97)" end="(45, 98)" leading="" trailing="" val="["/>
                          <IdentNode start="(45, 98)" end="(45, 99)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(45, 99)" end="(45, 101)" leading="" trailing="" val="]'"/>
                          <OtherNode start="(45, 101)" end="(45, 109)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(45, 101)" end="(45, 102)" leading="" trailing="" val="("/>
                            <OtherNode start="(45, 102)" end="(45, 108)" kind="Lean.Parser.Term.subst">
                              <IdentNode start="(45, 102)" end="(45, 103)" leading="" trailing=" " raw_val="h" val="h"/>
                              <AtomNode start="(45, 104)" end="(45, 105)" leading="" trailing=" " val="▸"/>
                              <NullNode start="(45, 106)" end="(45, 108)">
                                <IdentNode start="(45, 106)" end="(45, 108)" leading="" trailing="" raw_val="h'" val="h'"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(45, 108)" end="(45, 109)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(45, 109)" end="(45, 110)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(45, 111)" end="(49, 25)">
          <AtomNode start="(45, 111)" end="(45, 113)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(45, 114)" end="(49, 25)">
            <AtomNode start="(45, 114)" end="(45, 116)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(46, 3)" end="(49, 25)">
              <TacticTacticseq1IndentedNode start="(46, 3)" end="(49, 25)">
                <NullNode start="(46, 3)" end="(49, 25)">
                  <OtherNode start="(46, 3)" end="(46, 20)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;⊢ xs.isEqv ys r = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" state_after="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;⊢ (if h : xs.size = ys.size then xs.isEqvAux ys h r xs.size ⋯ else false) = true →&#10;    ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" tactic="simp only [isEqv]">
                    <AtomNode start="(46, 3)" end="(46, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(46, 8)" end="(46, 12)">
                      <AtomNode start="(46, 8)" end="(46, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(46, 13)" end="(46, 20)">
                      <AtomNode start="(46, 13)" end="(46, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(46, 14)" end="(46, 19)">
                        <OtherNode start="(46, 14)" end="(46, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(46, 14)" end="(46, 19)" leading="" trailing="" raw_val="isEqv" val="isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(46, 19)" end="(46, 20)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(47, 3)" end="(47, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;⊢ (if h : xs.size = ys.size then xs.isEqvAux ys h r xs.size ⋯ else false) = true →&#10;    ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" state_after="case isTrue&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : xs.size = ys.size&#10;⊢ xs.isEqvAux ys h r xs.size ⋯ = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;&#10;case isFalse&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : ¬xs.size = ys.size&#10;⊢ false = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(47, 3)" end="(47, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(47, 3)" end="(47, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(47, 9)" end="(47, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(47, 13)" end="(47, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(47, 13)" end="(47, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(47, 22)" end="(47, 23)">
                        <LeanBinderidentNode start="(47, 22)" end="(47, 23)">
                          <IdentNode start="(47, 22)" end="(47, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(48, 3)" end="(48, 72)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : xs.size = ys.size&#10;⊢ xs.isEqvAux ys h r xs.size ⋯ = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;&#10;case isFalse&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : ¬xs.size = ys.size&#10;⊢ false = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" state_after="case isFalse&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : ¬xs.size = ys.size&#10;⊢ false = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" tactic="· exact fun h' =&amp;gt; ⟨h, fun i =&amp;gt; rel_of_isEqvAux h (Nat.le_refl ..) h'⟩">
                    <OtherNode start="(48, 3)" end="(48, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(48, 3)" end="(48, 4)" kind="patternIgnore">
                        <OtherNode start="(48, 3)" end="(48, 4)" kind="token.«· »">
                          <AtomNode start="(48, 3)" end="(48, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(48, 5)" end="(48, 72)">
                      <TacticTacticseq1IndentedNode start="(48, 5)" end="(48, 72)">
                        <NullNode start="(48, 5)" end="(48, 72)">
                          <OtherNode start="(48, 5)" end="(48, 72)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : xs.size = ys.size&#10;⊢ xs.isEqvAux ys h r xs.size ⋯ = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" state_after="no goals" tactic="exact fun h' =&amp;gt; ⟨h, fun i =&amp;gt; rel_of_isEqvAux h (Nat.le_refl ..) h'⟩">
                            <AtomNode start="(48, 5)" end="(48, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(48, 11)" end="(48, 72)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(48, 11)" end="(48, 14)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(48, 15)" end="(48, 72)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(48, 15)" end="(48, 17)">
                                  <IdentNode start="(48, 15)" end="(48, 17)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(48, 18)" end="(48, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(48, 21)" end="(48, 72)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(48, 21)" end="(48, 22)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(48, 22)" end="(48, 71)">
                                    <IdentNode start="(48, 22)" end="(48, 23)" leading="" trailing="" raw_val="h" val="h"/>
                                    <AtomNode start="(48, 23)" end="(48, 24)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(48, 25)" end="(48, 71)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(48, 25)" end="(48, 28)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(48, 29)" end="(48, 71)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(48, 29)" end="(48, 30)">
                                          <IdentNode start="(48, 29)" end="(48, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(48, 31)" end="(48, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <OtherNode start="(48, 34)" end="(48, 71)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(48, 34)" end="(48, 49)" leading="" trailing=" " raw_val="rel_of_isEqvAux" val="rel_of_isEqvAux" full_name="_private.Init.Data.Array.DecidableEq.0.Array.rel_of_isEqvAux" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(19, 17)" def_end="(19, 32)"/>
                                          <NullNode start="(48, 50)" end="(48, 71)">
                                            <IdentNode start="(48, 50)" end="(48, 51)" leading="" trailing=" " raw_val="h" val="h"/>
                                            <OtherNode start="(48, 52)" end="(48, 68)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(48, 52)" end="(48, 53)" leading="" trailing="" val="("/>
                                              <OtherNode start="(48, 53)" end="(48, 67)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(48, 53)" end="(48, 64)" leading="" trailing=" " raw_val="Nat.le_refl" val="Nat.le_refl" full_name="Nat.le_refl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                <NullNode start="(48, 65)" end="(48, 67)">
                                                  <OtherNode start="(48, 65)" end="(48, 67)" kind="Lean.Parser.Term.ellipsis">
                                                    <AtomNode start="(48, 65)" end="(48, 67)" leading="" trailing="" val=".."/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(48, 67)" end="(48, 68)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                            <IdentNode start="(48, 69)" end="(48, 71)" leading="" trailing="" raw_val="h'" val="h'"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(48, 71)" end="(48, 72)" leading="" trailing="&#10;  " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(49, 3)" end="(49, 25)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : ¬xs.size = ys.size&#10;⊢ false = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" state_after="no goals" tactic="· intro; contradiction">
                    <OtherNode start="(49, 3)" end="(49, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(49, 3)" end="(49, 4)" kind="patternIgnore">
                        <OtherNode start="(49, 3)" end="(49, 4)" kind="token.«· »">
                          <AtomNode start="(49, 3)" end="(49, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(49, 5)" end="(49, 25)">
                      <TacticTacticseq1IndentedNode start="(49, 5)" end="(49, 25)">
                        <NullNode start="(49, 5)" end="(49, 25)">
                          <OtherNode start="(49, 5)" end="(49, 10)" kind="Lean.Parser.Tactic.intro" state_before="case isFalse&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : ¬xs.size = ys.size&#10;⊢ false = true → ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" state_after="case isFalse&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : ¬xs.size = ys.size&#10;a✝ : false = true&#10;⊢ ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" tactic="intro">
                            <AtomNode start="(49, 5)" end="(49, 10)" leading="" trailing="" val="intro"/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(49, 10)" end="(49, 11)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(49, 12)" end="(49, 25)" kind="Lean.Parser.Tactic.contradiction" state_before="case isFalse&#10;α : Type u_1&#10;r : α → α → Bool&#10;xs ys : Array α&#10;h : ¬xs.size = ys.size&#10;a✝ : false = true&#10;⊢ ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true" state_after="no goals" tactic="contradiction">
                            <AtomNode start="(49, 12)" end="(49, 25)" leading="" trailing="&#10;&#10;" val="contradiction"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(51, 1)" end="(55, 45)" name="isEqv_iff_rel" full_name="Array.isEqv_iff_rel">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(51, 1)" end="(55, 45)" name="isEqv_iff_rel" full_name="Array.isEqv_iff_rel" _is_private_decl="False">
        <AtomNode start="(51, 1)" end="(51, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(51, 9)" end="(51, 22)">
          <IdentNode start="(51, 9)" end="(51, 22)" leading="" trailing=" " raw_val="isEqv_iff_rel" val="isEqv_iff_rel"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(51, 23)" end="(52, 110)">
          <NullNode start="(51, 23)" end="(51, 44)">
            <OtherNode start="(51, 23)" end="(51, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(51, 23)" end="(51, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(51, 24)" end="(51, 29)">
                <IdentNode start="(51, 24)" end="(51, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(51, 27)" end="(51, 29)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(51, 30)" end="(51, 39)">
                <AtomNode start="(51, 30)" end="(51, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(51, 32)" end="(51, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(51, 32)" end="(51, 37)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(51, 38)" end="(51, 39)">
                    <IdentNode start="(51, 38)" end="(51, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(51, 39)" end="(51, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(51, 41)" end="(51, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(51, 41)" end="(51, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(51, 42)" end="(51, 43)">
                <IdentNode start="(51, 42)" end="(51, 43)" leading="" trailing="" raw_val="r" val="r"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(51, 43)" end="(51, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(51, 45)" end="(52, 110)">
            <AtomNode start="(51, 45)" end="(51, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(52, 5)" end="(52, 110)" kind="«term_↔_»">
              <OtherNode start="(52, 5)" end="(52, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(52, 5)" end="(52, 16)" leading="" trailing=" " raw_val="Array.isEqv" val="Array.isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(52, 17)" end="(52, 24)">
                  <IdentNode start="(52, 17)" end="(52, 19)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(52, 20)" end="(52, 22)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  <IdentNode start="(52, 23)" end="(52, 24)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(52, 25)" end="(52, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(52, 27)" end="(52, 110)" kind="«term∃_,_»">
                <AtomNode start="(52, 27)" end="(52, 28)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(52, 29)" end="(52, 50)" kind="Lean.explicitBinders">
                  <OtherNode start="(52, 29)" end="(52, 50)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(52, 29)" end="(52, 30)">
                      <LeanBinderidentNode start="(52, 29)" end="(52, 30)">
                        <IdentNode start="(52, 29)" end="(52, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode start="(52, 31)" end="(52, 50)">
                      <AtomNode start="(52, 31)" end="(52, 32)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(52, 33)" end="(52, 50)" kind="«term_=_»">
                        <IdentNode start="(52, 33)" end="(52, 40)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                        <AtomNode start="(52, 41)" end="(52, 42)" leading="" trailing=" " val="="/>
                        <IdentNode start="(52, 43)" end="(52, 50)" leading="" trailing="" raw_val="ys.size" val="ys.size"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(52, 50)" end="(52, 51)" leading="" trailing=" " val=","/>
                <OtherNode start="(52, 52)" end="(52, 110)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(52, 52)" end="(52, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(52, 54)" end="(52, 82)">
                    <TermExplicitbinderNode start="(52, 54)" end="(52, 63)">
                      <AtomNode start="(52, 54)" end="(52, 55)" leading="" trailing="" val="("/>
                      <NullNode start="(52, 55)" end="(52, 56)">
                        <IdentNode start="(52, 55)" end="(52, 56)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(52, 57)" end="(52, 62)">
                        <AtomNode start="(52, 57)" end="(52, 58)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(52, 59)" end="(52, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(52, 62)" end="(52, 63)" leading="" trailing=" " val=")"/>
                    </TermExplicitbinderNode>
                    <TermExplicitbinderNode start="(52, 64)" end="(52, 82)">
                      <AtomNode start="(52, 64)" end="(52, 65)" leading="" trailing="" val="("/>
                      <NullNode start="(52, 65)" end="(52, 67)">
                        <IdentNode start="(52, 65)" end="(52, 67)" leading="" trailing=" " raw_val="h'" val="h'"/>
                      </NullNode>
                      <NullNode start="(52, 68)" end="(52, 81)">
                        <AtomNode start="(52, 68)" end="(52, 69)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(52, 70)" end="(52, 81)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(52, 70)" end="(52, 71)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(52, 72)" end="(52, 73)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(52, 74)" end="(52, 81)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(52, 81)" end="(52, 82)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(52, 82)" end="(52, 83)" leading="" trailing=" " val=","/>
                  <OtherNode start="(52, 84)" end="(52, 110)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(52, 84)" end="(52, 85)" leading="" trailing=" " raw_val="r" val="r"/>
                    <NullNode start="(52, 86)" end="(52, 110)">
                      <OtherNode start="(52, 86)" end="(52, 93)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(52, 86)" end="(52, 87)" leading="" trailing="" val="("/>
                        <OtherNode start="(52, 87)" end="(52, 92)" kind="«term__[_]»">
                          <IdentNode start="(52, 87)" end="(52, 89)" leading="" trailing="" raw_val="xs" val="xs"/>
                          <AtomNode start="(52, 89)" end="(52, 90)" leading="" trailing="" val="["/>
                          <IdentNode start="(52, 90)" end="(52, 91)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(52, 91)" end="(52, 92)" leading="" trailing="" val="]"/>
                        </OtherNode>
                        <AtomNode start="(52, 92)" end="(52, 93)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(52, 94)" end="(52, 110)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(52, 94)" end="(52, 95)" leading="" trailing="" val="("/>
                        <OtherNode start="(52, 95)" end="(52, 109)" kind="«term__[_]'_»">
                          <IdentNode start="(52, 95)" end="(52, 97)" leading="" trailing="" raw_val="ys" val="ys"/>
                          <AtomNode start="(52, 97)" end="(52, 98)" leading="" trailing="" val="["/>
                          <IdentNode start="(52, 98)" end="(52, 99)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(52, 99)" end="(52, 101)" leading="" trailing="" val="]'"/>
                          <OtherNode start="(52, 101)" end="(52, 109)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(52, 101)" end="(52, 102)" leading="" trailing="" val="("/>
                            <OtherNode start="(52, 102)" end="(52, 108)" kind="Lean.Parser.Term.subst">
                              <IdentNode start="(52, 102)" end="(52, 103)" leading="" trailing=" " raw_val="h" val="h"/>
                              <AtomNode start="(52, 104)" end="(52, 105)" leading="" trailing=" " val="▸"/>
                              <NullNode start="(52, 106)" end="(52, 108)">
                                <IdentNode start="(52, 106)" end="(52, 108)" leading="" trailing="" raw_val="h'" val="h'"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(52, 108)" end="(52, 109)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(52, 109)" end="(52, 110)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(52, 111)" end="(55, 45)">
          <AtomNode start="(52, 111)" end="(52, 113)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(53, 3)" end="(55, 45)" kind="Lean.Parser.Term.anonymousCtor">
            <AtomNode start="(53, 3)" end="(53, 4)" leading="" trailing="" val="⟨"/>
            <NullNode start="(53, 4)" end="(55, 44)">
              <IdentNode start="(53, 4)" end="(53, 16)" leading="" trailing="" raw_val="rel_of_isEqv" val="rel_of_isEqv" full_name="_private.Init.Data.Array.DecidableEq.0.Array.rel_of_isEqv" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(44, 17)" def_end="(44, 29)"/>
              <AtomNode start="(53, 16)" end="(53, 17)" leading="" trailing=" " val=","/>
              <OtherNode start="(53, 18)" end="(55, 44)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(53, 18)" end="(53, 21)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(53, 22)" end="(55, 44)" kind="Lean.Parser.Term.basicFun">
                  <NullNode start="(53, 22)" end="(53, 28)">
                    <OtherNode start="(53, 22)" end="(53, 28)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(53, 22)" end="(53, 23)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(53, 23)" end="(53, 27)">
                        <IdentNode start="(53, 23)" end="(53, 24)" leading="" trailing="" raw_val="h" val="h"/>
                        <AtomNode start="(53, 24)" end="(53, 25)" leading="" trailing=" " val=","/>
                        <IdentNode start="(53, 26)" end="(53, 27)" leading="" trailing="" raw_val="w" val="w"/>
                      </NullNode>
                      <AtomNode start="(53, 27)" end="(53, 28)" leading="" trailing=" " val="⟩"/>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(53, 29)" end="(53, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(53, 32)" end="(55, 44)">
                    <AtomNode start="(53, 32)" end="(53, 34)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(54, 5)" end="(55, 44)">
                      <TacticTacticseq1IndentedNode start="(54, 5)" end="(55, 44)">
                        <NullNode start="(54, 5)" end="(55, 44)">
                          <OtherNode start="(54, 5)" end="(54, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;x✝ : ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;h : xs.size = ys.size&#10;w : ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ xs.isEqv ys r = true" state_after="α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;x✝ : ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;h : xs.size = ys.size&#10;w : ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ xs.isEqvAux ys ⋯ r xs.size ⋯ = true" tactic="simp only [isEqv, ← h, ↓reduceDIte]">
                            <AtomNode start="(54, 5)" end="(54, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(54, 10)" end="(54, 14)">
                              <AtomNode start="(54, 10)" end="(54, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(54, 15)" end="(54, 40)">
                              <AtomNode start="(54, 15)" end="(54, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(54, 16)" end="(54, 39)">
                                <OtherNode start="(54, 16)" end="(54, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(54, 16)" end="(54, 21)" leading="" trailing="" raw_val="isEqv" val="isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(54, 21)" end="(54, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(54, 23)" end="(54, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode start="(54, 23)" end="(54, 24)">
                                    <OtherNode start="(54, 23)" end="(54, 24)" kind="patternIgnore">
                                      <OtherNode start="(54, 23)" end="(54, 24)" kind="token.«← »">
                                        <AtomNode start="(54, 23)" end="(54, 24)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <IdentNode start="(54, 25)" end="(54, 26)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(54, 26)" end="(54, 27)" leading="" trailing=" " val=","/>
                                <OtherNode start="(54, 28)" end="(54, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode start="(54, 28)" end="(54, 29)">
                                    <OtherNode start="(54, 28)" end="(54, 29)" kind="Lean.Parser.Tactic.simpPre">
                                      <AtomNode start="(54, 28)" end="(54, 29)" leading="" trailing="" val="↓"/>
                                    </OtherNode>
                                  </NullNode>
                                  <NullNode/>
                                  <IdentNode start="(54, 29)" end="(54, 39)" leading="" trailing="" raw_val="reduceDIte" val="reduceDIte"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(54, 39)" end="(54, 40)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(55, 5)" end="(55, 44)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;x✝ : ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;h : xs.size = ys.size&#10;w : ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ xs.isEqvAux ys ⋯ r xs.size ⋯ = true" state_after="no goals" tactic="exact isEqvAux_of_rel h (by simp [h]) w">
                            <AtomNode start="(55, 5)" end="(55, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(55, 11)" end="(55, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(55, 11)" end="(55, 26)" leading="" trailing=" " raw_val="isEqvAux_of_rel" val="isEqvAux_of_rel" full_name="_private.Init.Data.Array.DecidableEq.0.Array.isEqvAux_of_rel" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(35, 17)" def_end="(35, 32)"/>
                              <NullNode start="(55, 27)" end="(55, 44)">
                                <IdentNode start="(55, 27)" end="(55, 28)" leading="" trailing=" " raw_val="h" val="h"/>
                                <OtherNode start="(55, 29)" end="(55, 42)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(55, 29)" end="(55, 30)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(55, 30)" end="(55, 41)">
                                    <AtomNode start="(55, 30)" end="(55, 32)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(55, 33)" end="(55, 41)">
                                      <TacticTacticseq1IndentedNode start="(55, 33)" end="(55, 41)">
                                        <NullNode start="(55, 33)" end="(55, 41)">
                                          <OtherNode start="(55, 33)" end="(55, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;x✝ : ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;h : xs.size = ys.size&#10;w : ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ xs.size ≤ xs.size" state_after="no goals" tactic="simp [h]">
                                            <AtomNode start="(55, 33)" end="(55, 37)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(55, 38)" end="(55, 41)">
                                              <AtomNode start="(55, 38)" end="(55, 39)" leading="" trailing="" val="["/>
                                              <NullNode start="(55, 39)" end="(55, 40)">
                                                <OtherNode start="(55, 39)" end="(55, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(55, 39)" end="(55, 40)" leading="" trailing="" raw_val="h" val="h"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(55, 40)" end="(55, 41)" leading="" trailing="" val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(55, 41)" end="(55, 42)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(55, 43)" end="(55, 44)" leading="" trailing="" raw_val="w" val="w"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(55, 44)" end="(55, 45)" leading="" trailing="&#10;&#10;" val="⟩"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(57, 1)" end="(69, 35)" name="isEqv_eq_decide" full_name="Array.isEqv_eq_decide">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(57, 1)" end="(69, 35)" name="isEqv_eq_decide" full_name="Array.isEqv_eq_decide" _is_private_decl="False">
        <AtomNode start="(57, 1)" end="(57, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(57, 9)" end="(57, 24)">
          <IdentNode start="(57, 9)" end="(57, 24)" leading="" trailing=" " raw_val="isEqv_eq_decide" val="isEqv_eq_decide"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(57, 25)" end="(59, 115)">
          <NullNode start="(57, 25)" end="(57, 46)">
            <TermExplicitbinderNode start="(57, 25)" end="(57, 42)">
              <AtomNode start="(57, 25)" end="(57, 26)" leading="" trailing="" val="("/>
              <NullNode start="(57, 26)" end="(57, 31)">
                <IdentNode start="(57, 26)" end="(57, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(57, 29)" end="(57, 31)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(57, 32)" end="(57, 41)">
                <AtomNode start="(57, 32)" end="(57, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(57, 34)" end="(57, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(57, 34)" end="(57, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(57, 40)" end="(57, 41)">
                    <IdentNode start="(57, 40)" end="(57, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(57, 41)" end="(57, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(57, 43)" end="(57, 46)">
              <AtomNode start="(57, 43)" end="(57, 44)" leading="" trailing="" val="("/>
              <NullNode start="(57, 44)" end="(57, 45)">
                <IdentNode start="(57, 44)" end="(57, 45)" leading="" trailing="" raw_val="r" val="r"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(57, 45)" end="(57, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(57, 47)" end="(59, 115)">
            <AtomNode start="(57, 47)" end="(57, 48)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(58, 5)" end="(59, 115)" kind="«term_=_»">
              <OtherNode start="(58, 5)" end="(58, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(58, 5)" end="(58, 16)" leading="" trailing=" " raw_val="Array.isEqv" val="Array.isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(58, 17)" end="(58, 24)">
                  <IdentNode start="(58, 17)" end="(58, 19)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(58, 20)" end="(58, 22)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  <IdentNode start="(58, 23)" end="(58, 24)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(58, 25)" end="(58, 26)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(59, 7)" end="(59, 115)" kind="termDepIfThenElse">
                <AtomNode start="(59, 7)" end="(59, 9)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(59, 10)" end="(59, 11)">
                  <IdentNode start="(59, 10)" end="(59, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                </LeanBinderidentNode>
                <AtomNode start="(59, 12)" end="(59, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(59, 14)" end="(59, 31)" kind="«term_=_»">
                  <IdentNode start="(59, 14)" end="(59, 21)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(59, 22)" end="(59, 23)" leading="" trailing=" " val="="/>
                  <IdentNode start="(59, 24)" end="(59, 31)" leading="" trailing=" " raw_val="ys.size" val="ys.size"/>
                </OtherNode>
                <AtomNode start="(59, 32)" end="(59, 36)" leading="" trailing=" " val="then"/>
                <OtherNode start="(59, 37)" end="(59, 104)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(59, 37)" end="(59, 43)" leading="" trailing=" " raw_val="decide" val="decide" full_name="Decidable.decide" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(59, 44)" end="(59, 104)">
                    <OtherNode start="(59, 44)" end="(59, 104)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(59, 44)" end="(59, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(59, 45)" end="(59, 103)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(59, 45)" end="(59, 46)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(59, 47)" end="(59, 75)">
                          <TermExplicitbinderNode start="(59, 47)" end="(59, 56)">
                            <AtomNode start="(59, 47)" end="(59, 48)" leading="" trailing="" val="("/>
                            <NullNode start="(59, 48)" end="(59, 49)">
                              <IdentNode start="(59, 48)" end="(59, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode start="(59, 50)" end="(59, 55)">
                              <AtomNode start="(59, 50)" end="(59, 51)" leading="" trailing=" " val=":"/>
                              <IdentNode start="(59, 52)" end="(59, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(59, 55)" end="(59, 56)" leading="" trailing=" " val=")"/>
                          </TermExplicitbinderNode>
                          <TermExplicitbinderNode start="(59, 57)" end="(59, 75)">
                            <AtomNode start="(59, 57)" end="(59, 58)" leading="" trailing="" val="("/>
                            <NullNode start="(59, 58)" end="(59, 60)">
                              <IdentNode start="(59, 58)" end="(59, 60)" leading="" trailing=" " raw_val="h'" val="h'"/>
                            </NullNode>
                            <NullNode start="(59, 61)" end="(59, 74)">
                              <AtomNode start="(59, 61)" end="(59, 62)" leading="" trailing=" " val=":"/>
                              <OtherNode start="(59, 63)" end="(59, 74)" kind="«term_&amp;lt;_»">
                                <IdentNode start="(59, 63)" end="(59, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                                <AtomNode start="(59, 65)" end="(59, 66)" leading="" trailing=" " val="&amp;lt;"/>
                                <IdentNode start="(59, 67)" end="(59, 74)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(59, 74)" end="(59, 75)" leading="" trailing="" val=")"/>
                          </TermExplicitbinderNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(59, 75)" end="(59, 76)" leading="" trailing=" " val=","/>
                        <OtherNode start="(59, 77)" end="(59, 103)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(59, 77)" end="(59, 78)" leading="" trailing=" " raw_val="r" val="r"/>
                          <NullNode start="(59, 79)" end="(59, 103)">
                            <OtherNode start="(59, 79)" end="(59, 86)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(59, 79)" end="(59, 80)" leading="" trailing="" val="("/>
                              <OtherNode start="(59, 80)" end="(59, 85)" kind="«term__[_]»">
                                <IdentNode start="(59, 80)" end="(59, 82)" leading="" trailing="" raw_val="xs" val="xs"/>
                                <AtomNode start="(59, 82)" end="(59, 83)" leading="" trailing="" val="["/>
                                <IdentNode start="(59, 83)" end="(59, 84)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(59, 84)" end="(59, 85)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(59, 85)" end="(59, 86)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(59, 87)" end="(59, 103)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(59, 87)" end="(59, 88)" leading="" trailing="" val="("/>
                              <OtherNode start="(59, 88)" end="(59, 102)" kind="«term__[_]'_»">
                                <IdentNode start="(59, 88)" end="(59, 90)" leading="" trailing="" raw_val="ys" val="ys"/>
                                <AtomNode start="(59, 90)" end="(59, 91)" leading="" trailing="" val="["/>
                                <IdentNode start="(59, 91)" end="(59, 92)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(59, 92)" end="(59, 94)" leading="" trailing="" val="]'"/>
                                <OtherNode start="(59, 94)" end="(59, 102)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(59, 94)" end="(59, 95)" leading="" trailing="" val="("/>
                                  <OtherNode start="(59, 95)" end="(59, 101)" kind="Lean.Parser.Term.subst">
                                    <IdentNode start="(59, 95)" end="(59, 96)" leading="" trailing=" " raw_val="h" val="h"/>
                                    <AtomNode start="(59, 97)" end="(59, 98)" leading="" trailing=" " val="▸"/>
                                    <NullNode start="(59, 99)" end="(59, 101)">
                                      <IdentNode start="(59, 99)" end="(59, 101)" leading="" trailing="" raw_val="h'" val="h'"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(59, 101)" end="(59, 102)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(59, 102)" end="(59, 103)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(59, 103)" end="(59, 104)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(59, 105)" end="(59, 109)" leading="" trailing=" " val="else"/>
                <IdentNode start="(59, 110)" end="(59, 115)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(59, 116)" end="(69, 35)">
          <AtomNode start="(59, 116)" end="(59, 118)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(59, 119)" end="(69, 35)">
            <AtomNode start="(59, 119)" end="(59, 121)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(60, 3)" end="(69, 35)">
              <TacticTacticseq1IndentedNode start="(60, 3)" end="(69, 35)">
                <NullNode start="(60, 3)" end="(69, 35)">
                  <OtherNode start="(60, 3)" end="(60, 35)" kind="«tacticBy_cases_:_»" state_before="α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" state_after="case pos&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false&#10;&#10;case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ¬xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" tactic="by_cases h : Array.isEqv xs ys r">
                    <AtomNode start="(60, 3)" end="(60, 11)" leading="" trailing=" " val="by_cases"/>
                    <NullNode start="(60, 12)" end="(60, 15)">
                      <IdentNode start="(60, 12)" end="(60, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                      <AtomNode start="(60, 14)" end="(60, 15)" leading="" trailing=" " val=":"/>
                    </NullNode>
                    <OtherNode start="(60, 16)" end="(60, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(60, 16)" end="(60, 27)" leading="" trailing=" " raw_val="Array.isEqv" val="Array.isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(60, 28)" end="(60, 35)">
                        <IdentNode start="(60, 28)" end="(60, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <IdentNode start="(60, 31)" end="(60, 33)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        <IdentNode start="(60, 34)" end="(60, 35)" leading="" trailing="&#10;  " raw_val="r" val="r"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(61, 3)" end="(64, 16)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false&#10;&#10;case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ¬xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" state_after="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ¬xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" tactic="· simp only [h, Bool.true_eq]&#10;  simp only [isEqv_iff_rel] at h&#10;  obtain ⟨h, w⟩ := h&#10;  simp [h, w]">
                    <OtherNode start="(61, 3)" end="(61, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(61, 3)" end="(61, 4)" kind="patternIgnore">
                        <OtherNode start="(61, 3)" end="(61, 4)" kind="token.«· »">
                          <AtomNode start="(61, 3)" end="(61, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(61, 5)" end="(64, 16)">
                      <TacticTacticseq1IndentedNode start="(61, 5)" end="(64, 16)">
                        <NullNode start="(61, 5)" end="(64, 16)">
                          <OtherNode start="(61, 5)" end="(61, 32)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" state_after="case pos&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : xs.isEqv ys r = true&#10;⊢ (if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false) = true" tactic="simp only [h, Bool.true_eq]">
                            <AtomNode start="(61, 5)" end="(61, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(61, 10)" end="(61, 14)">
                              <AtomNode start="(61, 10)" end="(61, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(61, 15)" end="(61, 32)">
                              <AtomNode start="(61, 15)" end="(61, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(61, 16)" end="(61, 31)">
                                <OtherNode start="(61, 16)" end="(61, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(61, 16)" end="(61, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(61, 17)" end="(61, 18)" leading="" trailing=" " val=","/>
                                <OtherNode start="(61, 19)" end="(61, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(61, 19)" end="(61, 31)" leading="" trailing="" raw_val="Bool.true_eq" val="Bool.true_eq" full_name="Bool.true_eq" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(61, 31)" end="(61, 32)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(62, 5)" end="(62, 35)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : xs.isEqv ys r = true&#10;⊢ (if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false) = true" state_after="case pos&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ (if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false) = true" tactic="simp only [isEqv_iff_rel] at h">
                            <AtomNode start="(62, 5)" end="(62, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(62, 10)" end="(62, 14)">
                              <AtomNode start="(62, 10)" end="(62, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(62, 15)" end="(62, 30)">
                              <AtomNode start="(62, 15)" end="(62, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(62, 16)" end="(62, 29)">
                                <OtherNode start="(62, 16)" end="(62, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(62, 16)" end="(62, 29)" leading="" trailing="" raw_val="isEqv_iff_rel" val="isEqv_iff_rel" full_name="Array.isEqv_iff_rel" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(51, 9)" def_end="(51, 22)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(62, 29)" end="(62, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(62, 31)" end="(62, 35)">
                              <OtherNode start="(62, 31)" end="(62, 35)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(62, 31)" end="(62, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(62, 34)" end="(62, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(62, 34)" end="(62, 35)">
                                    <IdentNode start="(62, 34)" end="(62, 35)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(63, 5)" end="(63, 23)" kind="Lean.Parser.Tactic.obtain" state_before="case pos&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ∃ h, ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ (if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false) = true" state_after="case pos.intro&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : xs.size = ys.size&#10;w : ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ (if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false) = true" tactic="obtain ⟨h, w⟩ := h">
                            <AtomNode start="(63, 5)" end="(63, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(63, 12)" end="(63, 18)">
                              <OtherNode start="(63, 12)" end="(63, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(63, 12)" end="(63, 18)">
                                  <OtherNode start="(63, 12)" end="(63, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(63, 12)" end="(63, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(63, 13)" end="(63, 17)">
                                      <OtherNode start="(63, 13)" end="(63, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(63, 13)" end="(63, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(63, 13)" end="(63, 14)">
                                            <OtherNode start="(63, 13)" end="(63, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(63, 13)" end="(63, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(63, 14)" end="(63, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(63, 16)" end="(63, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(63, 16)" end="(63, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(63, 16)" end="(63, 17)">
                                            <OtherNode start="(63, 16)" end="(63, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(63, 16)" end="(63, 17)" leading="" trailing="" raw_val="w" val="w"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(63, 17)" end="(63, 18)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(63, 19)" end="(63, 23)">
                              <AtomNode start="(63, 19)" end="(63, 21)" leading="" trailing=" " val=":="/>
                              <NullNode start="(63, 22)" end="(63, 23)">
                                <IdentNode start="(63, 22)" end="(63, 23)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(64, 5)" end="(64, 16)" kind="Lean.Parser.Tactic.simp" state_before="case pos.intro&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : xs.size = ys.size&#10;w : ∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true&#10;⊢ (if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false) = true" state_after="no goals" tactic="simp [h, w]">
                            <AtomNode start="(64, 5)" end="(64, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(64, 10)" end="(64, 16)">
                              <AtomNode start="(64, 10)" end="(64, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(64, 11)" end="(64, 15)">
                                <OtherNode start="(64, 11)" end="(64, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(64, 11)" end="(64, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(64, 12)" end="(64, 13)" leading="" trailing=" " val=","/>
                                <OtherNode start="(64, 14)" end="(64, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(64, 14)" end="(64, 15)" leading="" trailing="" raw_val="w" val="w"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(64, 15)" end="(64, 16)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(65, 3)" end="(69, 35)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ¬xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" state_after="no goals" tactic="· let h' := h&#10;  simp only [Bool.not_eq_true] at h&#10;  simp only [h, Bool.false_eq, dite_eq_right_iff, decide_eq_false_iff_not, Classical.not_forall,&#10;    Bool.not_eq_true]&#10;  simpa [isEqv_iff_rel] using h'">
                    <OtherNode start="(65, 3)" end="(65, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(65, 3)" end="(65, 4)" kind="patternIgnore">
                        <OtherNode start="(65, 3)" end="(65, 4)" kind="token.«· »">
                          <AtomNode start="(65, 3)" end="(65, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(65, 5)" end="(69, 35)">
                      <TacticTacticseq1IndentedNode start="(65, 5)" end="(69, 35)">
                        <NullNode start="(65, 5)" end="(69, 35)">
                          <OtherNode start="(65, 5)" end="(65, 16)" kind="Lean.Parser.Tactic.tacticLet_" state_before="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ¬xs.isEqv ys r = true&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" state_after="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ¬xs.isEqv ys r = true&#10;h' : ¬xs.isEqv ys r = true := h&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" tactic="let h' := h">
                            <AtomNode start="(65, 5)" end="(65, 8)" leading="" trailing=" " val="let"/>
                            <OtherNode start="(65, 9)" end="(65, 16)" kind="Lean.Parser.Term.letDecl">
                              <OtherNode start="(65, 9)" end="(65, 16)" kind="Lean.Parser.Term.letIdDecl">
                                <IdentNode start="(65, 9)" end="(65, 11)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(65, 12)" end="(65, 14)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(65, 15)" end="(65, 16)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(66, 5)" end="(66, 38)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h : ¬xs.isEqv ys r = true&#10;h' : ¬xs.isEqv ys r = true := h&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" state_after="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h✝ : ¬xs.isEqv ys r = true&#10;h' : ¬xs.isEqv ys r = true := h✝&#10;h : xs.isEqv ys r = false&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" tactic="simp only [Bool.not_eq_true] at h">
                            <AtomNode start="(66, 5)" end="(66, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(66, 10)" end="(66, 14)">
                              <AtomNode start="(66, 10)" end="(66, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(66, 15)" end="(66, 33)">
                              <AtomNode start="(66, 15)" end="(66, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(66, 16)" end="(66, 32)">
                                <OtherNode start="(66, 16)" end="(66, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(66, 16)" end="(66, 32)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(66, 32)" end="(66, 33)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(66, 34)" end="(66, 38)">
                              <OtherNode start="(66, 34)" end="(66, 38)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(66, 34)" end="(66, 36)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(66, 37)" end="(66, 38)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(66, 37)" end="(66, 38)">
                                    <IdentNode start="(66, 37)" end="(66, 38)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(67, 5)" end="(68, 24)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h✝ : ¬xs.isEqv ys r = true&#10;h' : ¬xs.isEqv ys r = true := h✝&#10;h : xs.isEqv ys r = false&#10;⊢ xs.isEqv ys r = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), r xs[i] ys[i] = true) else false" state_after="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h✝ : ¬xs.isEqv ys r = true&#10;h' : ¬xs.isEqv ys r = true := h✝&#10;h : xs.isEqv ys r = false&#10;⊢ ∀ (h : xs.size = ys.size), ∃ x h_1, r xs[x] ys[x] = false" tactic="simp only [h, Bool.false_eq, dite_eq_right_iff, decide_eq_false_iff_not, Classical.not_forall,&#10;  Bool.not_eq_true]">
                            <AtomNode start="(67, 5)" end="(67, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(67, 10)" end="(67, 14)">
                              <AtomNode start="(67, 10)" end="(67, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(67, 15)" end="(68, 24)">
                              <AtomNode start="(67, 15)" end="(67, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(67, 16)" end="(68, 23)">
                                <OtherNode start="(67, 16)" end="(67, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(67, 16)" end="(67, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(67, 17)" end="(67, 18)" leading="" trailing=" " val=","/>
                                <OtherNode start="(67, 19)" end="(67, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(67, 19)" end="(67, 32)" leading="" trailing="" raw_val="Bool.false_eq" val="Bool.false_eq" full_name="Bool.false_eq" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                </OtherNode>
                                <AtomNode start="(67, 32)" end="(67, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(67, 34)" end="(67, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(67, 34)" end="(67, 51)" leading="" trailing="" raw_val="dite_eq_right_iff" val="dite_eq_right_iff" full_name="dite_eq_right_iff" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(67, 51)" end="(67, 52)" leading="" trailing=" " val=","/>
                                <OtherNode start="(67, 53)" end="(67, 76)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(67, 53)" end="(67, 76)" leading="" trailing="" raw_val="decide_eq_false_iff_not" val="decide_eq_false_iff_not" full_name="decide_eq_false_iff_not" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(67, 76)" end="(67, 77)" leading="" trailing=" " val=","/>
                                <OtherNode start="(67, 78)" end="(67, 98)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(67, 78)" end="(67, 98)" leading="" trailing="" raw_val="Classical.not_forall" val="Classical.not_forall" full_name="Classical.not_forall" mod_name="Init.Classical" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Classical.lean"/>
                                </OtherNode>
                                <AtomNode start="(67, 98)" end="(67, 99)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(68, 7)" end="(68, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(68, 7)" end="(68, 23)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(68, 23)" end="(68, 24)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(69, 5)" end="(69, 35)" kind="Lean.Parser.Tactic.simpa" state_before="case neg&#10;α : Type u_1&#10;xs ys : Array α&#10;r : α → α → Bool&#10;h✝ : ¬xs.isEqv ys r = true&#10;h' : ¬xs.isEqv ys r = true := h✝&#10;h : xs.isEqv ys r = false&#10;⊢ ∀ (h : xs.size = ys.size), ∃ x h_1, r xs[x] ys[x] = false" state_after="no goals" tactic="simpa [isEqv_iff_rel] using h'">
                            <AtomNode start="(69, 5)" end="(69, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(69, 11)" end="(69, 35)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(69, 11)" end="(69, 26)">
                                <OtherNode start="(69, 11)" end="(69, 26)" kind="Lean.Parser.Tactic.simpArgs">
                                  <AtomNode start="(69, 11)" end="(69, 12)" leading="" trailing="" val="["/>
                                  <NullNode start="(69, 12)" end="(69, 25)">
                                    <OtherNode start="(69, 12)" end="(69, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(69, 12)" end="(69, 25)" leading="" trailing="" raw_val="isEqv_iff_rel" val="isEqv_iff_rel" full_name="Array.isEqv_iff_rel" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(51, 9)" def_end="(51, 22)"/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(69, 25)" end="(69, 26)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode start="(69, 27)" end="(69, 35)">
                                <AtomNode start="(69, 27)" end="(69, 32)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(69, 33)" end="(69, 35)" leading="" trailing="&#10;&#10;" raw_val="h'" val="h'"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(71, 1)" end="(72, 47)" name="isEqv_toList" full_name="Array.isEqv_toList">
      <CommandDeclmodifiersNode start="(71, 1)" end="(71, 8)">
        <NullNode/>
        <NullNode start="(71, 1)" end="(71, 8)">
          <OtherNode start="(71, 1)" end="(71, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(71, 1)" end="(71, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(71, 3)" end="(71, 7)">
              <OtherNode start="(71, 3)" end="(71, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(71, 3)" end="(71, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(71, 3)" end="(71, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(71, 7)" end="(71, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(71, 9)" end="(72, 47)" name="isEqv_toList" full_name="Array.isEqv_toList" _is_private_decl="False">
        <AtomNode start="(71, 9)" end="(71, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(71, 17)" end="(71, 29)">
          <IdentNode start="(71, 17)" end="(71, 29)" leading="" trailing=" " raw_val="isEqv_toList" val="isEqv_toList"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(71, 30)" end="(71, 105)">
          <NullNode start="(71, 30)" end="(71, 55)">
            <OtherNode start="(71, 30)" end="(71, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(71, 30)" end="(71, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(71, 31)" end="(71, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(71, 31)" end="(71, 34)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(71, 35)" end="(71, 36)">
                  <IdentNode start="(71, 35)" end="(71, 36)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(71, 36)" end="(71, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(71, 38)" end="(71, 55)">
              <AtomNode start="(71, 38)" end="(71, 39)" leading="" trailing="" val="("/>
              <NullNode start="(71, 39)" end="(71, 44)">
                <IdentNode start="(71, 39)" end="(71, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(71, 42)" end="(71, 44)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(71, 45)" end="(71, 54)">
                <AtomNode start="(71, 45)" end="(71, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(71, 47)" end="(71, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(71, 47)" end="(71, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(71, 53)" end="(71, 54)">
                    <IdentNode start="(71, 53)" end="(71, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(71, 54)" end="(71, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(71, 56)" end="(71, 105)">
            <AtomNode start="(71, 56)" end="(71, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(71, 58)" end="(71, 105)" kind="«term_=_»">
              <OtherNode start="(71, 58)" end="(71, 87)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(71, 58)" end="(71, 59)" leading="" trailing="" val="("/>
                <OtherNode start="(71, 59)" end="(71, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(71, 59)" end="(71, 74)" leading="" trailing=" " raw_val="xs.toList.isEqv" val="xs.toList.isEqv"/>
                  <NullNode start="(71, 75)" end="(71, 86)">
                    <IdentNode start="(71, 75)" end="(71, 84)" leading="" trailing=" " raw_val="ys.toList" val="ys.toList"/>
                    <IdentNode start="(71, 85)" end="(71, 86)" leading="" trailing="" raw_val="r" val="r"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(71, 86)" end="(71, 87)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(71, 88)" end="(71, 89)" leading="" trailing=" " val="="/>
              <OtherNode start="(71, 90)" end="(71, 105)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(71, 90)" end="(71, 91)" leading="" trailing="" val="("/>
                <OtherNode start="(71, 91)" end="(71, 104)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(71, 91)" end="(71, 99)" leading="" trailing=" " raw_val="xs.isEqv" val="xs.isEqv"/>
                  <NullNode start="(71, 100)" end="(71, 104)">
                    <IdentNode start="(71, 100)" end="(71, 102)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    <IdentNode start="(71, 103)" end="(71, 104)" leading="" trailing="" raw_val="r" val="r"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(71, 104)" end="(71, 105)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(71, 106)" end="(72, 47)">
          <AtomNode start="(71, 106)" end="(71, 108)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(71, 109)" end="(72, 47)">
            <AtomNode start="(71, 109)" end="(71, 111)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(72, 3)" end="(72, 47)">
              <TacticTacticseq1IndentedNode start="(72, 3)" end="(72, 47)">
                <NullNode start="(72, 3)" end="(72, 47)">
                  <OtherNode start="(72, 3)" end="(72, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;r : α → α → Bool&#10;inst✝ : BEq α&#10;xs ys : Array α&#10;⊢ xs.toList.isEqv ys.toList r = xs.isEqv ys r" state_after="no goals" tactic="simp [isEqv_eq_decide, List.isEqv_eq_decide]">
                    <AtomNode start="(72, 3)" end="(72, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(72, 8)" end="(72, 47)">
                      <AtomNode start="(72, 8)" end="(72, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(72, 9)" end="(72, 46)">
                        <OtherNode start="(72, 9)" end="(72, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(72, 9)" end="(72, 24)" leading="" trailing="" raw_val="isEqv_eq_decide" val="isEqv_eq_decide" full_name="Array.isEqv_eq_decide" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(57, 9)" def_end="(57, 24)"/>
                        </OtherNode>
                        <AtomNode start="(72, 24)" end="(72, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(72, 26)" end="(72, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(72, 26)" end="(72, 46)" leading="" trailing="" raw_val="List.isEqv_eq_decide" val="List.isEqv_eq_decide" full_name="List.isEqv_eq_decide" mod_name="Init.Data.List.Nat.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/BEq.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(72, 46)" end="(72, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(74, 1)" end="(76, 53)" name="eq_of_isEqv" full_name="Array.eq_of_isEqv">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(74, 1)" end="(76, 53)" name="eq_of_isEqv" full_name="Array.eq_of_isEqv" _is_private_decl="False">
        <AtomNode start="(74, 1)" end="(74, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(74, 9)" end="(74, 20)">
          <IdentNode start="(74, 9)" end="(74, 20)" leading="" trailing=" " raw_val="eq_of_isEqv" val="eq_of_isEqv"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(74, 21)" end="(74, 107)">
          <NullNode start="(74, 21)" end="(74, 97)">
            <OtherNode start="(74, 21)" end="(74, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(74, 21)" end="(74, 22)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(74, 22)" end="(74, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(74, 22)" end="(74, 33)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(74, 34)" end="(74, 35)">
                  <IdentNode start="(74, 34)" end="(74, 35)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(74, 35)" end="(74, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(74, 37)" end="(74, 54)">
              <AtomNode start="(74, 37)" end="(74, 38)" leading="" trailing="" val="("/>
              <NullNode start="(74, 38)" end="(74, 43)">
                <IdentNode start="(74, 38)" end="(74, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(74, 41)" end="(74, 43)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(74, 44)" end="(74, 53)">
                <AtomNode start="(74, 44)" end="(74, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(74, 46)" end="(74, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(74, 46)" end="(74, 51)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(74, 52)" end="(74, 53)">
                    <IdentNode start="(74, 52)" end="(74, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(74, 53)" end="(74, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(74, 55)" end="(74, 97)">
              <AtomNode start="(74, 55)" end="(74, 56)" leading="" trailing="" val="("/>
              <NullNode start="(74, 56)" end="(74, 57)">
                <IdentNode start="(74, 56)" end="(74, 57)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(74, 58)" end="(74, 96)">
                <AtomNode start="(74, 58)" end="(74, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(74, 60)" end="(74, 96)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(74, 60)" end="(74, 71)" leading="" trailing=" " raw_val="Array.isEqv" val="Array.isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(74, 72)" end="(74, 96)">
                    <IdentNode start="(74, 72)" end="(74, 74)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(74, 75)" end="(74, 77)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    <OtherNode start="(74, 78)" end="(74, 96)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(74, 78)" end="(74, 79)" leading="" trailing="" val="("/>
                      <OtherNode start="(74, 79)" end="(74, 95)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(74, 79)" end="(74, 82)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(74, 83)" end="(74, 95)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(74, 83)" end="(74, 86)">
                            <IdentNode start="(74, 83)" end="(74, 84)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(74, 85)" end="(74, 86)" leading="" trailing=" " raw_val="y" val="y"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(74, 87)" end="(74, 89)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(74, 90)" end="(74, 95)" kind="«term_=_»">
                            <IdentNode start="(74, 90)" end="(74, 91)" leading="" trailing=" " raw_val="x" val="x"/>
                            <AtomNode start="(74, 92)" end="(74, 93)" leading="" trailing=" " val="="/>
                            <IdentNode start="(74, 94)" end="(74, 95)" leading="" trailing="" raw_val="y" val="y"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(74, 95)" end="(74, 96)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(74, 96)" end="(74, 97)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(74, 98)" end="(74, 107)">
            <AtomNode start="(74, 98)" end="(74, 99)" leading="" trailing=" " val=":"/>
            <OtherNode start="(74, 100)" end="(74, 107)" kind="«term_=_»">
              <IdentNode start="(74, 100)" end="(74, 102)" leading="" trailing=" " raw_val="xs" val="xs"/>
              <AtomNode start="(74, 103)" end="(74, 104)" leading="" trailing=" " val="="/>
              <IdentNode start="(74, 105)" end="(74, 107)" leading="" trailing=" " raw_val="ys" val="ys"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(74, 108)" end="(76, 53)">
          <AtomNode start="(74, 108)" end="(74, 110)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(74, 111)" end="(76, 53)">
            <AtomNode start="(74, 111)" end="(74, 113)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(75, 3)" end="(76, 53)">
              <TacticTacticseq1IndentedNode start="(75, 3)" end="(76, 53)">
                <NullNode start="(75, 3)" end="(76, 53)">
                  <OtherNode start="(75, 3)" end="(75, 33)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;inst✝ : DecidableEq α&#10;xs ys : Array α&#10;h : (xs.isEqv ys fun x y =&amp;gt; decide (x = y)) = true&#10;⊢ xs = ys" state_after="α : Type u_1&#10;inst✝ : DecidableEq α&#10;xs ys : Array α&#10;h✝ : (xs.isEqv ys fun x y =&amp;gt; decide (x = y)) = true&#10;h : xs.size = ys.size&#10;h' : ∀ (i : Nat) (h' : i &amp;lt; xs.size), decide (xs[i] = ys[i]) = true&#10;⊢ xs = ys" tactic="have ⟨h, h'⟩ := rel_of_isEqv h">
                    <AtomNode start="(75, 3)" end="(75, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(75, 8)" end="(75, 33)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(75, 8)" end="(75, 33)" kind="Lean.Parser.Term.letPatDecl">
                        <OtherNode start="(75, 8)" end="(75, 15)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(75, 8)" end="(75, 9)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(75, 9)" end="(75, 14)">
                            <IdentNode start="(75, 9)" end="(75, 10)" leading="" trailing="" raw_val="h" val="h"/>
                            <AtomNode start="(75, 10)" end="(75, 11)" leading="" trailing=" " val=","/>
                            <IdentNode start="(75, 12)" end="(75, 14)" leading="" trailing="" raw_val="h'" val="h'"/>
                          </NullNode>
                          <AtomNode start="(75, 14)" end="(75, 15)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(75, 16)" end="(75, 18)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(75, 19)" end="(75, 33)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(75, 19)" end="(75, 31)" leading="" trailing=" " raw_val="rel_of_isEqv" val="rel_of_isEqv" full_name="_private.Init.Data.Array.DecidableEq.0.Array.rel_of_isEqv" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(44, 17)" def_end="(44, 29)"/>
                          <NullNode start="(75, 32)" end="(75, 33)">
                            <IdentNode start="(75, 32)" end="(75, 33)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(76, 3)" end="(76, 53)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝ : DecidableEq α&#10;xs ys : Array α&#10;h✝ : (xs.isEqv ys fun x y =&amp;gt; decide (x = y)) = true&#10;h : xs.size = ys.size&#10;h' : ∀ (i : Nat) (h' : i &amp;lt; xs.size), decide (xs[i] = ys[i]) = true&#10;⊢ xs = ys" state_after="no goals" tactic="exact ext h (fun i lt _ =&amp;gt; by simpa using h' i lt)">
                    <AtomNode start="(76, 3)" end="(76, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(76, 9)" end="(76, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(76, 9)" end="(76, 12)" leading="" trailing=" " raw_val="ext" val="ext" full_name="Array.ext" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(76, 13)" end="(76, 53)">
                        <IdentNode start="(76, 13)" end="(76, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                        <OtherNode start="(76, 15)" end="(76, 53)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(76, 15)" end="(76, 16)" leading="" trailing="" val="("/>
                          <OtherNode start="(76, 16)" end="(76, 52)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(76, 16)" end="(76, 19)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(76, 20)" end="(76, 52)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(76, 20)" end="(76, 26)">
                                <IdentNode start="(76, 20)" end="(76, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(76, 22)" end="(76, 24)" leading="" trailing=" " raw_val="lt" val="lt"/>
                                <TermHoleNode start="(76, 25)" end="(76, 26)">
                                  <AtomNode start="(76, 25)" end="(76, 26)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(76, 27)" end="(76, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TermBytacticNode start="(76, 30)" end="(76, 52)">
                                <AtomNode start="(76, 30)" end="(76, 32)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(76, 33)" end="(76, 52)">
                                  <TacticTacticseq1IndentedNode start="(76, 33)" end="(76, 52)">
                                    <NullNode start="(76, 33)" end="(76, 52)">
                                      <OtherNode start="(76, 33)" end="(76, 52)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : DecidableEq α&#10;xs ys : Array α&#10;h✝ : (xs.isEqv ys fun x y =&amp;gt; decide (x = y)) = true&#10;h : xs.size = ys.size&#10;h' : ∀ (i : Nat) (h' : i &amp;lt; xs.size), decide (xs[i] = ys[i]) = true&#10;i : Nat&#10;lt : i &amp;lt; xs.size&#10;x✝ : i &amp;lt; ys.size&#10;⊢ xs[i] = ys[i]" state_after="no goals" tactic="simpa using h' i lt">
                                        <AtomNode start="(76, 33)" end="(76, 38)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(76, 39)" end="(76, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(76, 39)" end="(76, 52)">
                                            <AtomNode start="(76, 39)" end="(76, 44)" leading="" trailing=" " val="using"/>
                                            <OtherNode start="(76, 45)" end="(76, 52)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(76, 45)" end="(76, 47)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                              <NullNode start="(76, 48)" end="(76, 52)">
                                                <IdentNode start="(76, 48)" end="(76, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                                                <IdentNode start="(76, 50)" end="(76, 52)" leading="" trailing="" raw_val="lt" val="lt"/>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(76, 52)" end="(76, 53)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(78, 1)" end="(83, 44)" name="isEqvAux_self" full_name="Array.isEqvAux_self">
      <CommandDeclmodifiersNode start="(78, 1)" end="(78, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(78, 1)" end="(78, 8)">
          <CommandPrivateNode start="(78, 1)" end="(78, 8)">
            <AtomNode start="(78, 1)" end="(78, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(78, 9)" end="(83, 44)" name="isEqvAux_self" full_name="Array.isEqvAux_self" _is_private_decl="True">
        <AtomNode start="(78, 9)" end="(78, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(78, 17)" end="(78, 30)">
          <IdentNode start="(78, 17)" end="(78, 30)" leading="" trailing=" " raw_val="isEqvAux_self" val="isEqvAux_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(78, 31)" end="(79, 42)">
          <NullNode start="(78, 31)" end="(78, 110)">
            <TermExplicitbinderNode start="(78, 31)" end="(78, 49)">
              <AtomNode start="(78, 31)" end="(78, 32)" leading="" trailing="" val="("/>
              <NullNode start="(78, 32)" end="(78, 33)">
                <IdentNode start="(78, 32)" end="(78, 33)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(78, 34)" end="(78, 48)">
                <AtomNode start="(78, 34)" end="(78, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 36)" end="(78, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(78, 36)" end="(78, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(78, 38)" end="(78, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(78, 40)" end="(78, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(78, 40)" end="(78, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(78, 42)" end="(78, 43)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(78, 44)" end="(78, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 48)" end="(78, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(78, 50)" end="(78, 67)">
              <AtomNode start="(78, 50)" end="(78, 51)" leading="" trailing="" val="("/>
              <NullNode start="(78, 51)" end="(78, 53)">
                <IdentNode start="(78, 51)" end="(78, 53)" leading="" trailing=" " raw_val="hr" val="hr"/>
              </NullNode>
              <NullNode start="(78, 54)" end="(78, 66)">
                <AtomNode start="(78, 54)" end="(78, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 56)" end="(78, 66)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(78, 56)" end="(78, 57)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(78, 58)" end="(78, 59)">
                    <IdentNode start="(78, 58)" end="(78, 59)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(78, 59)" end="(78, 60)" leading="" trailing=" " val=","/>
                  <OtherNode start="(78, 61)" end="(78, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(78, 61)" end="(78, 62)" leading="" trailing=" " raw_val="r" val="r"/>
                    <NullNode start="(78, 63)" end="(78, 66)">
                      <IdentNode start="(78, 63)" end="(78, 64)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(78, 65)" end="(78, 66)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 66)" end="(78, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(78, 68)" end="(78, 82)">
              <AtomNode start="(78, 68)" end="(78, 69)" leading="" trailing="" val="("/>
              <NullNode start="(78, 69)" end="(78, 71)">
                <IdentNode start="(78, 69)" end="(78, 71)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(78, 72)" end="(78, 81)">
                <AtomNode start="(78, 72)" end="(78, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 74)" end="(78, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 74)" end="(78, 79)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(78, 80)" end="(78, 81)">
                    <IdentNode start="(78, 80)" end="(78, 81)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 81)" end="(78, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(78, 83)" end="(78, 92)">
              <AtomNode start="(78, 83)" end="(78, 84)" leading="" trailing="" val="("/>
              <NullNode start="(78, 84)" end="(78, 85)">
                <IdentNode start="(78, 84)" end="(78, 85)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(78, 86)" end="(78, 91)">
                <AtomNode start="(78, 86)" end="(78, 87)" leading="" trailing=" " val=":"/>
                <IdentNode start="(78, 88)" end="(78, 91)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 91)" end="(78, 92)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(78, 93)" end="(78, 110)">
              <AtomNode start="(78, 93)" end="(78, 94)" leading="" trailing="" val="("/>
              <NullNode start="(78, 94)" end="(78, 95)">
                <IdentNode start="(78, 94)" end="(78, 95)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(78, 96)" end="(78, 109)">
                <AtomNode start="(78, 96)" end="(78, 97)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 98)" end="(78, 109)" kind="«term_≤_»">
                  <IdentNode start="(78, 98)" end="(78, 99)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(78, 100)" end="(78, 101)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(78, 102)" end="(78, 109)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 109)" end="(78, 110)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(78, 111)" end="(79, 42)">
            <AtomNode start="(78, 111)" end="(78, 112)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(79, 5)" end="(79, 42)" kind="«term_=_»">
              <OtherNode start="(79, 5)" end="(79, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(79, 5)" end="(79, 19)" leading="" trailing=" " raw_val="Array.isEqvAux" val="Array.isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(79, 20)" end="(79, 35)">
                  <IdentNode start="(79, 20)" end="(79, 22)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(79, 23)" end="(79, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(79, 26)" end="(79, 29)" leading="" trailing=" " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <IdentNode start="(79, 30)" end="(79, 31)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(79, 32)" end="(79, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(79, 34)" end="(79, 35)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(79, 36)" end="(79, 37)" leading="" trailing=" " val="="/>
              <IdentNode start="(79, 38)" end="(79, 42)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(79, 43)" end="(83, 44)">
          <AtomNode start="(79, 43)" end="(79, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(79, 46)" end="(83, 44)">
            <AtomNode start="(79, 46)" end="(79, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(80, 3)" end="(83, 44)">
              <TacticTacticseq1IndentedNode start="(80, 3)" end="(83, 44)">
                <NullNode start="(80, 3)" end="(83, 44)">
                  <OtherNode start="(80, 3)" end="(83, 44)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;r : α → α → Bool&#10;hr : ∀ (a : α), r a a = true&#10;xs : Array α&#10;i : Nat&#10;h : i ≤ xs.size&#10;⊢ xs.isEqvAux xs ⋯ r i h = true" state_after="no goals" tactic="induction i with&#10;| zero =&amp;gt; simp [Array.isEqvAux]&#10;| succ i ih =&amp;gt;&#10;  simp_all only [isEqvAux, Bool.and_self]">
                    <AtomNode start="(80, 3)" end="(80, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(80, 13)" end="(80, 14)">
                      <OtherNode start="(80, 13)" end="(80, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(80, 13)" end="(80, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(80, 15)" end="(83, 44)">
                      <OtherNode start="(80, 15)" end="(83, 44)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(80, 15)" end="(80, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(81, 3)" end="(83, 44)">
                          <OtherNode start="(81, 3)" end="(81, 34)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(81, 3)" end="(81, 9)">
                              <OtherNode start="(81, 3)" end="(81, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(81, 3)" end="(81, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(81, 5)" end="(81, 9)">
                                  <NullNode/>
                                  <IdentNode start="(81, 5)" end="(81, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(81, 10)" end="(81, 34)">
                              <AtomNode start="(81, 10)" end="(81, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(81, 13)" end="(81, 34)">
                                <TacticTacticseq1IndentedNode start="(81, 13)" end="(81, 34)">
                                  <NullNode start="(81, 13)" end="(81, 34)">
                                    <OtherNode start="(81, 13)" end="(81, 34)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_1&#10;r : α → α → Bool&#10;hr : ∀ (a : α), r a a = true&#10;xs : Array α&#10;h : 0 ≤ xs.size&#10;⊢ xs.isEqvAux xs ⋯ r 0 h = true" state_after="no goals" tactic="simp [Array.isEqvAux]">
                                      <AtomNode start="(81, 13)" end="(81, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(81, 18)" end="(81, 34)">
                                        <AtomNode start="(81, 18)" end="(81, 19)" leading="" trailing="" val="["/>
                                        <NullNode start="(81, 19)" end="(81, 33)">
                                          <OtherNode start="(81, 19)" end="(81, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(81, 19)" end="(81, 33)" leading="" trailing="" raw_val="Array.isEqvAux" val="Array.isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(81, 33)" end="(81, 34)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(82, 3)" end="(83, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(82, 3)" end="(82, 14)">
                              <OtherNode start="(82, 3)" end="(82, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(82, 3)" end="(82, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(82, 5)" end="(82, 9)">
                                  <NullNode/>
                                  <IdentNode start="(82, 5)" end="(82, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(82, 10)" end="(82, 14)">
                                  <IdentNode start="(82, 10)" end="(82, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(82, 12)" end="(82, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(82, 15)" end="(83, 44)">
                              <AtomNode start="(82, 15)" end="(82, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(83, 5)" end="(83, 44)">
                                <TacticTacticseq1IndentedNode start="(83, 5)" end="(83, 44)">
                                  <NullNode start="(83, 5)" end="(83, 44)">
                                    <OtherNode start="(83, 5)" end="(83, 44)" kind="Lean.Parser.Tactic.simpAll" state_before="case succ&#10;α : Type u_1&#10;r : α → α → Bool&#10;hr : ∀ (a : α), r a a = true&#10;xs : Array α&#10;i : Nat&#10;ih : ∀ (h : i ≤ xs.size), xs.isEqvAux xs ⋯ r i h = true&#10;h : i + 1 ≤ xs.size&#10;⊢ xs.isEqvAux xs ⋯ r (i + 1) h = true" state_after="no goals" tactic="simp_all only [isEqvAux, Bool.and_self]">
                                      <AtomNode start="(83, 5)" end="(83, 13)" leading="" trailing=" " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(83, 14)" end="(83, 18)">
                                        <AtomNode start="(83, 14)" end="(83, 18)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(83, 19)" end="(83, 44)">
                                        <AtomNode start="(83, 19)" end="(83, 20)" leading="" trailing="" val="["/>
                                        <NullNode start="(83, 20)" end="(83, 43)">
                                          <OtherNode start="(83, 20)" end="(83, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(83, 20)" end="(83, 28)" leading="" trailing="" raw_val="isEqvAux" val="isEqvAux" full_name="Array.isEqvAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(83, 28)" end="(83, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(83, 30)" end="(83, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(83, 30)" end="(83, 43)" leading="" trailing="" raw_val="Bool.and_self" val="Bool.and_self" full_name="Bool.and_self" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(83, 43)" end="(83, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(85, 1)" end="(86, 30)" name="isEqv_self_beq" full_name="Array.isEqv_self_beq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(85, 1)" end="(86, 30)" name="isEqv_self_beq" full_name="Array.isEqv_self_beq" _is_private_decl="False">
        <AtomNode start="(85, 1)" end="(85, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(85, 9)" end="(85, 23)">
          <IdentNode start="(85, 9)" end="(85, 23)" leading="" trailing=" " raw_val="isEqv_self_beq" val="isEqv_self_beq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(85, 24)" end="(85, 94)">
          <NullNode start="(85, 24)" end="(85, 58)">
            <OtherNode start="(85, 24)" end="(85, 31)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(85, 24)" end="(85, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(85, 25)" end="(85, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 25)" end="(85, 28)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(85, 29)" end="(85, 30)">
                  <IdentNode start="(85, 29)" end="(85, 30)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(85, 30)" end="(85, 31)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(85, 32)" end="(85, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(85, 32)" end="(85, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(85, 33)" end="(85, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 33)" end="(85, 40)" leading="" trailing=" " raw_val="ReflBEq" val="ReflBEq" full_name="ReflBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(85, 41)" end="(85, 42)">
                  <IdentNode start="(85, 41)" end="(85, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(85, 42)" end="(85, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(85, 44)" end="(85, 58)">
              <AtomNode start="(85, 44)" end="(85, 45)" leading="" trailing="" val="("/>
              <NullNode start="(85, 45)" end="(85, 47)">
                <IdentNode start="(85, 45)" end="(85, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(85, 48)" end="(85, 57)">
                <AtomNode start="(85, 48)" end="(85, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(85, 50)" end="(85, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(85, 50)" end="(85, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(85, 56)" end="(85, 57)">
                    <IdentNode start="(85, 56)" end="(85, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(85, 57)" end="(85, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(85, 59)" end="(85, 94)">
            <AtomNode start="(85, 59)" end="(85, 60)" leading="" trailing=" " val=":"/>
            <OtherNode start="(85, 61)" end="(85, 94)" kind="«term_=_»">
              <OtherNode start="(85, 61)" end="(85, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 61)" end="(85, 72)" leading="" trailing=" " raw_val="Array.isEqv" val="Array.isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(85, 73)" end="(85, 87)">
                  <IdentNode start="(85, 73)" end="(85, 75)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(85, 76)" end="(85, 78)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <OtherNode start="(85, 79)" end="(85, 87)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(85, 79)" end="(85, 80)" leading="" trailing="" val="("/>
                    <OtherNode start="(85, 80)" end="(85, 86)" kind="«term_==_»">
                      <OtherNode start="(85, 80)" end="(85, 81)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(85, 80)" end="(85, 81)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(85, 82)" end="(85, 84)" leading="" trailing=" " val="=="/>
                      <OtherNode start="(85, 85)" end="(85, 86)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(85, 85)" end="(85, 86)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(85, 86)" end="(85, 87)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(85, 88)" end="(85, 89)" leading="" trailing=" " val="="/>
              <IdentNode start="(85, 90)" end="(85, 94)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(85, 95)" end="(86, 30)">
          <AtomNode start="(85, 95)" end="(85, 97)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(85, 98)" end="(86, 30)">
            <AtomNode start="(85, 98)" end="(85, 100)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(86, 3)" end="(86, 30)">
              <TacticTacticseq1IndentedNode start="(86, 3)" end="(86, 30)">
                <NullNode start="(86, 3)" end="(86, 30)">
                  <OtherNode start="(86, 3)" end="(86, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : ReflBEq α&#10;xs : Array α&#10;⊢ (xs.isEqv xs fun x1 x2 =&amp;gt; x1 == x2) = true" state_after="no goals" tactic="simp [isEqv, isEqvAux_self]">
                    <AtomNode start="(86, 3)" end="(86, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(86, 8)" end="(86, 30)">
                      <AtomNode start="(86, 8)" end="(86, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 9)" end="(86, 29)">
                        <OtherNode start="(86, 9)" end="(86, 14)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 9)" end="(86, 14)" leading="" trailing="" raw_val="isEqv" val="isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(86, 14)" end="(86, 15)" leading="" trailing=" " val=","/>
                        <OtherNode start="(86, 16)" end="(86, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 16)" end="(86, 29)" leading="" trailing="" raw_val="isEqvAux_self" val="isEqvAux_self" full_name="_private.Init.Data.Array.DecidableEq.0.Array.isEqvAux_self" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(78, 17)" def_end="(78, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 29)" end="(86, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(88, 1)" end="(89, 30)" name="isEqv_self" full_name="Array.isEqv_self">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 1)" end="(89, 30)" name="isEqv_self" full_name="Array.isEqv_self" _is_private_decl="False">
        <AtomNode start="(88, 1)" end="(88, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 9)" end="(88, 19)">
          <IdentNode start="(88, 9)" end="(88, 19)" leading="" trailing=" " raw_val="isEqv_self" val="isEqv_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 20)" end="(88, 85)">
          <NullNode start="(88, 20)" end="(88, 50)">
            <OtherNode start="(88, 20)" end="(88, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(88, 20)" end="(88, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(88, 21)" end="(88, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(88, 21)" end="(88, 32)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(88, 33)" end="(88, 34)">
                  <IdentNode start="(88, 33)" end="(88, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(88, 34)" end="(88, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(88, 36)" end="(88, 50)">
              <AtomNode start="(88, 36)" end="(88, 37)" leading="" trailing="" val="("/>
              <NullNode start="(88, 37)" end="(88, 39)">
                <IdentNode start="(88, 37)" end="(88, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(88, 40)" end="(88, 49)">
                <AtomNode start="(88, 40)" end="(88, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 42)" end="(88, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 42)" end="(88, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(88, 48)" end="(88, 49)">
                    <IdentNode start="(88, 48)" end="(88, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(88, 49)" end="(88, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(88, 51)" end="(88, 85)">
            <AtomNode start="(88, 51)" end="(88, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(88, 53)" end="(88, 85)" kind="«term_=_»">
              <OtherNode start="(88, 53)" end="(88, 78)" kind="Lean.Parser.Term.app">
                <IdentNode start="(88, 53)" end="(88, 64)" leading="" trailing=" " raw_val="Array.isEqv" val="Array.isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(88, 65)" end="(88, 78)">
                  <IdentNode start="(88, 65)" end="(88, 67)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(88, 68)" end="(88, 70)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <OtherNode start="(88, 71)" end="(88, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(88, 71)" end="(88, 72)" leading="" trailing="" val="("/>
                    <OtherNode start="(88, 72)" end="(88, 77)" kind="«term_=_»">
                      <OtherNode start="(88, 72)" end="(88, 73)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(88, 72)" end="(88, 73)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(88, 74)" end="(88, 75)" leading="" trailing=" " val="="/>
                      <OtherNode start="(88, 76)" end="(88, 77)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(88, 76)" end="(88, 77)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(88, 77)" end="(88, 78)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(88, 79)" end="(88, 80)" leading="" trailing=" " val="="/>
              <IdentNode start="(88, 81)" end="(88, 85)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(88, 86)" end="(89, 30)">
          <AtomNode start="(88, 86)" end="(88, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(88, 89)" end="(89, 30)">
            <AtomNode start="(88, 89)" end="(88, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(89, 3)" end="(89, 30)">
              <TacticTacticseq1IndentedNode start="(89, 3)" end="(89, 30)">
                <NullNode start="(89, 3)" end="(89, 30)">
                  <OtherNode start="(89, 3)" end="(89, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : DecidableEq α&#10;xs : Array α&#10;⊢ (xs.isEqv xs fun x1 x2 =&amp;gt; decide (x1 = x2)) = true" state_after="no goals" tactic="simp [isEqv, isEqvAux_self]">
                    <AtomNode start="(89, 3)" end="(89, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(89, 8)" end="(89, 30)">
                      <AtomNode start="(89, 8)" end="(89, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(89, 9)" end="(89, 29)">
                        <OtherNode start="(89, 9)" end="(89, 14)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(89, 9)" end="(89, 14)" leading="" trailing="" raw_val="isEqv" val="isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(89, 14)" end="(89, 15)" leading="" trailing=" " val=","/>
                        <OtherNode start="(89, 16)" end="(89, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(89, 16)" end="(89, 29)" leading="" trailing="" raw_val="isEqvAux_self" val="isEqvAux_self" full_name="_private.Init.Data.Array.DecidableEq.0.Array.isEqvAux_self" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(78, 17)" def_end="(78, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(89, 29)" end="(89, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(91, 1)" end="(95, 82)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(91, 1)" end="(95, 82)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(91, 1)" end="(91, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(91, 10)" end="(91, 49)">
          <NullNode start="(91, 10)" end="(91, 25)">
            <OtherNode start="(91, 10)" end="(91, 25)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(91, 10)" end="(91, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(91, 11)" end="(91, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(91, 11)" end="(91, 22)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(91, 23)" end="(91, 24)">
                  <IdentNode start="(91, 23)" end="(91, 24)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(91, 24)" end="(91, 25)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(91, 26)" end="(91, 49)">
            <AtomNode start="(91, 26)" end="(91, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(91, 28)" end="(91, 49)" kind="Lean.Parser.Term.app">
              <IdentNode start="(91, 28)" end="(91, 39)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode start="(91, 40)" end="(91, 49)">
                <OtherNode start="(91, 40)" end="(91, 49)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(91, 40)" end="(91, 41)" leading="" trailing="" val="("/>
                  <OtherNode start="(91, 41)" end="(91, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(91, 41)" end="(91, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(91, 47)" end="(91, 48)">
                      <IdentNode start="(91, 47)" end="(91, 48)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(91, 48)" end="(91, 49)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(91, 50)" end="(95, 82)">
          <AtomNode start="(91, 50)" end="(91, 52)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(92, 3)" end="(95, 82)" kind="Lean.Parser.Term.fun">
            <AtomNode start="(92, 3)" end="(92, 6)" leading="" trailing=" " val="fun"/>
            <OtherNode start="(92, 7)" end="(95, 82)" kind="Lean.Parser.Term.basicFun">
              <NullNode start="(92, 7)" end="(92, 12)">
                <IdentNode start="(92, 7)" end="(92, 9)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(92, 10)" end="(92, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(92, 13)" end="(92, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
              <OtherNode start="(93, 5)" end="(95, 82)" kind="Lean.Parser.Term.match">
                <AtomNode start="(93, 5)" end="(93, 10)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(93, 11)" end="(93, 43)">
                  <OtherNode start="(93, 11)" end="(93, 43)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode start="(93, 11)" end="(93, 13)">
                      <IdentNode start="(93, 11)" end="(93, 12)" leading="" trailing="" raw_val="h" val="h"/>
                      <AtomNode start="(93, 12)" end="(93, 13)" leading="" trailing="" val=":"/>
                    </NullNode>
                    <OtherNode start="(93, 13)" end="(93, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(93, 13)" end="(93, 18)" leading="" trailing=" " raw_val="isEqv" val="isEqv" full_name="Array.isEqv" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(93, 19)" end="(93, 43)">
                        <IdentNode start="(93, 19)" end="(93, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <IdentNode start="(93, 22)" end="(93, 24)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        <OtherNode start="(93, 25)" end="(93, 43)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(93, 25)" end="(93, 26)" leading="" trailing="" val="("/>
                          <OtherNode start="(93, 26)" end="(93, 42)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(93, 26)" end="(93, 29)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(93, 30)" end="(93, 42)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(93, 30)" end="(93, 33)">
                                <IdentNode start="(93, 30)" end="(93, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(93, 32)" end="(93, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(93, 34)" end="(93, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(93, 37)" end="(93, 42)" kind="«term_=_»">
                                <IdentNode start="(93, 37)" end="(93, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(93, 39)" end="(93, 40)" leading="" trailing=" " val="="/>
                                <IdentNode start="(93, 41)" end="(93, 42)" leading="" trailing="" raw_val="b" val="b"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(93, 42)" end="(93, 43)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(93, 44)" end="(93, 48)" leading="" trailing="&#10;    " val="with"/>
                <OtherNode start="(94, 5)" end="(95, 82)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(94, 5)" end="(95, 82)">
                    <OtherNode start="(94, 5)" end="(94, 44)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(94, 5)" end="(94, 6)" leading="" trailing=" " val="|"/>
                      <NullNode start="(94, 7)" end="(94, 11)">
                        <NullNode start="(94, 7)" end="(94, 11)">
                          <IdentNode start="(94, 7)" end="(94, 11)" leading="" trailing="  " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(94, 13)" end="(94, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(94, 16)" end="(94, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(94, 16)" end="(94, 22)" leading="" trailing=" " raw_val="isTrue" val="isTrue" full_name="Decidable.isTrue" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(94, 23)" end="(94, 44)">
                          <OtherNode start="(94, 23)" end="(94, 44)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(94, 23)" end="(94, 24)" leading="" trailing="" val="("/>
                            <OtherNode start="(94, 24)" end="(94, 43)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(94, 24)" end="(94, 35)" leading="" trailing=" " raw_val="eq_of_isEqv" val="eq_of_isEqv" full_name="Array.eq_of_isEqv" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(74, 9)" def_end="(74, 20)"/>
                              <NullNode start="(94, 36)" end="(94, 43)">
                                <IdentNode start="(94, 36)" end="(94, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(94, 39)" end="(94, 41)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                <IdentNode start="(94, 42)" end="(94, 43)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(94, 43)" end="(94, 44)" leading="" trailing="&#10;    " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(95, 5)" end="(95, 82)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(95, 5)" end="(95, 6)" leading="" trailing=" " val="|"/>
                      <NullNode start="(95, 7)" end="(95, 12)">
                        <NullNode start="(95, 7)" end="(95, 12)">
                          <IdentNode start="(95, 7)" end="(95, 12)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(95, 13)" end="(95, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(95, 16)" end="(95, 82)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(95, 16)" end="(95, 23)" leading="" trailing=" " raw_val="isFalse" val="isFalse" full_name="Decidable.isFalse" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(95, 24)" end="(95, 82)">
                          <OtherNode start="(95, 24)" end="(95, 82)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(95, 24)" end="(95, 27)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(95, 28)" end="(95, 82)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(95, 28)" end="(95, 30)">
                                <IdentNode start="(95, 28)" end="(95, 30)" leading="" trailing=" " raw_val="h'" val="h'"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(95, 31)" end="(95, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TermBytacticNode start="(95, 34)" end="(95, 82)">
                                <AtomNode start="(95, 34)" end="(95, 36)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(95, 37)" end="(95, 82)">
                                  <TacticTacticseq1IndentedNode start="(95, 37)" end="(95, 82)">
                                    <NullNode start="(95, 37)" end="(95, 82)">
                                      <OtherNode start="(95, 37)" end="(95, 45)" kind="Lean.Parser.Tactic.subst" state_before="α : Type ?u.13044&#10;inst✝ : DecidableEq α&#10;xs ys : Array α&#10;h : (xs.isEqv ys fun a b =&amp;gt; decide (a = b)) = false&#10;h' : xs = ys&#10;⊢ False" state_after="α : Type ?u.13044&#10;inst✝ : DecidableEq α&#10;xs : Array α&#10;h : (xs.isEqv xs fun a b =&amp;gt; decide (a = b)) = false&#10;⊢ False" tactic="subst h'">
                                        <AtomNode start="(95, 37)" end="(95, 42)" leading="" trailing=" " val="subst"/>
                                        <NullNode start="(95, 43)" end="(95, 45)">
                                          <IdentNode start="(95, 43)" end="(95, 45)" leading="" trailing="" raw_val="h'" val="h'"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(95, 45)" end="(95, 46)" leading="" trailing=" " val=";"/>
                                      <OtherNode start="(95, 47)" end="(95, 67)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type ?u.13044&#10;inst✝ : DecidableEq α&#10;xs : Array α&#10;h : (xs.isEqv xs fun a b =&amp;gt; decide (a = b)) = false&#10;⊢ False" state_after="α : Type ?u.13044&#10;inst✝ : DecidableEq α&#10;xs : Array α&#10;h : true = false&#10;⊢ False" tactic="rw [isEqv_self] at h">
                                        <AtomNode start="(95, 47)" end="(95, 49)" leading="" trailing=" " val="rw"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <OtherNode start="(95, 50)" end="(95, 62)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                          <AtomNode start="(95, 50)" end="(95, 51)" leading="" trailing="" val="["/>
                                          <NullNode start="(95, 51)" end="(95, 61)">
                                            <OtherNode start="(95, 51)" end="(95, 61)" kind="Lean.Parser.Tactic.rwRule">
                                              <NullNode/>
                                              <IdentNode start="(95, 51)" end="(95, 61)" leading="" trailing="" raw_val="isEqv_self" val="isEqv_self" full_name="Array.isEqv_self" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(88, 9)" def_end="(88, 19)"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(95, 61)" end="(95, 62)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                        <NullNode start="(95, 63)" end="(95, 67)">
                                          <OtherNode start="(95, 63)" end="(95, 67)" kind="Lean.Parser.Tactic.location">
                                            <AtomNode start="(95, 63)" end="(95, 65)" leading="" trailing=" " val="at"/>
                                            <OtherNode start="(95, 66)" end="(95, 67)" kind="Lean.Parser.Tactic.locationHyp">
                                              <NullNode start="(95, 66)" end="(95, 67)">
                                                <IdentNode start="(95, 66)" end="(95, 67)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(95, 67)" end="(95, 68)" leading="" trailing=" " val=";"/>
                                      <OtherNode start="(95, 69)" end="(95, 82)" kind="Lean.Parser.Tactic.contradiction" state_before="α : Type ?u.13044&#10;inst✝ : DecidableEq α&#10;xs : Array α&#10;h : true = false&#10;⊢ False" state_after="no goals" tactic="contradiction">
                                        <AtomNode start="(95, 69)" end="(95, 82)" leading="" trailing="&#10;&#10;" val="contradiction"/>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(97, 1)" end="(100, 34)" name="beq_eq_decide" full_name="Array.beq_eq_decide">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(97, 1)" end="(100, 34)" name="beq_eq_decide" full_name="Array.beq_eq_decide" _is_private_decl="False">
        <AtomNode start="(97, 1)" end="(97, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(97, 9)" end="(97, 22)">
          <IdentNode start="(97, 9)" end="(97, 22)" leading="" trailing=" " raw_val="beq_eq_decide" val="beq_eq_decide"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(97, 23)" end="(99, 82)">
          <NullNode start="(97, 23)" end="(97, 48)">
            <OtherNode start="(97, 23)" end="(97, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(97, 23)" end="(97, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(97, 24)" end="(97, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(97, 24)" end="(97, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(97, 28)" end="(97, 29)">
                  <IdentNode start="(97, 28)" end="(97, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(97, 29)" end="(97, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(97, 31)" end="(97, 48)">
              <AtomNode start="(97, 31)" end="(97, 32)" leading="" trailing="" val="("/>
              <NullNode start="(97, 32)" end="(97, 37)">
                <IdentNode start="(97, 32)" end="(97, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(97, 35)" end="(97, 37)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(97, 38)" end="(97, 47)">
                <AtomNode start="(97, 38)" end="(97, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 40)" end="(97, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(97, 40)" end="(97, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(97, 46)" end="(97, 47)">
                    <IdentNode start="(97, 46)" end="(97, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(97, 47)" end="(97, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(97, 49)" end="(99, 82)">
            <AtomNode start="(97, 49)" end="(97, 50)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(98, 5)" end="(99, 82)" kind="«term_=_»">
              <OtherNode start="(98, 5)" end="(98, 15)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(98, 5)" end="(98, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(98, 6)" end="(98, 14)" kind="«term_==_»">
                  <IdentNode start="(98, 6)" end="(98, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(98, 9)" end="(98, 11)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(98, 12)" end="(98, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(98, 14)" end="(98, 15)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(98, 16)" end="(98, 17)" leading="" trailing=" " val="="/>
              <OtherNode start="(98, 18)" end="(99, 82)" kind="termDepIfThenElse">
                <AtomNode start="(98, 18)" end="(98, 20)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(98, 21)" end="(98, 22)">
                  <IdentNode start="(98, 21)" end="(98, 22)" leading="" trailing=" " raw_val="h" val="h"/>
                </LeanBinderidentNode>
                <AtomNode start="(98, 23)" end="(98, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(98, 25)" end="(98, 42)" kind="«term_=_»">
                  <IdentNode start="(98, 25)" end="(98, 32)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(98, 33)" end="(98, 34)" leading="" trailing=" " val="="/>
                  <IdentNode start="(98, 35)" end="(98, 42)" leading="" trailing=" " raw_val="ys.size" val="ys.size"/>
                </OtherNode>
                <AtomNode start="(98, 43)" end="(98, 47)" leading="" trailing="&#10;      " val="then"/>
                <OtherNode start="(99, 7)" end="(99, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(99, 7)" end="(99, 13)" leading="" trailing=" " raw_val="decide" val="decide" full_name="Decidable.decide" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(99, 14)" end="(99, 71)">
                    <OtherNode start="(99, 14)" end="(99, 71)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(99, 14)" end="(99, 15)" leading="" trailing="" val="("/>
                      <OtherNode start="(99, 15)" end="(99, 70)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(99, 15)" end="(99, 16)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(99, 17)" end="(99, 45)">
                          <TermExplicitbinderNode start="(99, 17)" end="(99, 26)">
                            <AtomNode start="(99, 17)" end="(99, 18)" leading="" trailing="" val="("/>
                            <NullNode start="(99, 18)" end="(99, 19)">
                              <IdentNode start="(99, 18)" end="(99, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode start="(99, 20)" end="(99, 25)">
                              <AtomNode start="(99, 20)" end="(99, 21)" leading="" trailing=" " val=":"/>
                              <IdentNode start="(99, 22)" end="(99, 25)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(99, 25)" end="(99, 26)" leading="" trailing=" " val=")"/>
                          </TermExplicitbinderNode>
                          <TermExplicitbinderNode start="(99, 27)" end="(99, 45)">
                            <AtomNode start="(99, 27)" end="(99, 28)" leading="" trailing="" val="("/>
                            <NullNode start="(99, 28)" end="(99, 30)">
                              <IdentNode start="(99, 28)" end="(99, 30)" leading="" trailing=" " raw_val="h'" val="h'"/>
                            </NullNode>
                            <NullNode start="(99, 31)" end="(99, 44)">
                              <AtomNode start="(99, 31)" end="(99, 32)" leading="" trailing=" " val=":"/>
                              <OtherNode start="(99, 33)" end="(99, 44)" kind="«term_&amp;lt;_»">
                                <IdentNode start="(99, 33)" end="(99, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                                <AtomNode start="(99, 35)" end="(99, 36)" leading="" trailing=" " val="&amp;lt;"/>
                                <IdentNode start="(99, 37)" end="(99, 44)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(99, 44)" end="(99, 45)" leading="" trailing="" val=")"/>
                          </TermExplicitbinderNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(99, 45)" end="(99, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(99, 47)" end="(99, 70)" kind="«term_==_»">
                          <OtherNode start="(99, 47)" end="(99, 52)" kind="«term__[_]»">
                            <IdentNode start="(99, 47)" end="(99, 49)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(99, 49)" end="(99, 50)" leading="" trailing="" val="["/>
                            <IdentNode start="(99, 50)" end="(99, 51)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(99, 51)" end="(99, 52)" leading="" trailing=" " val="]"/>
                          </OtherNode>
                          <AtomNode start="(99, 53)" end="(99, 55)" leading="" trailing=" " val="=="/>
                          <OtherNode start="(99, 56)" end="(99, 70)" kind="«term__[_]'_»">
                            <IdentNode start="(99, 56)" end="(99, 58)" leading="" trailing="" raw_val="ys" val="ys"/>
                            <AtomNode start="(99, 58)" end="(99, 59)" leading="" trailing="" val="["/>
                            <IdentNode start="(99, 59)" end="(99, 60)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(99, 60)" end="(99, 62)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(99, 62)" end="(99, 70)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(99, 62)" end="(99, 63)" leading="" trailing="" val="("/>
                              <OtherNode start="(99, 63)" end="(99, 69)" kind="Lean.Parser.Term.subst">
                                <IdentNode start="(99, 63)" end="(99, 64)" leading="" trailing=" " raw_val="h" val="h"/>
                                <AtomNode start="(99, 65)" end="(99, 66)" leading="" trailing=" " val="▸"/>
                                <NullNode start="(99, 67)" end="(99, 69)">
                                  <IdentNode start="(99, 67)" end="(99, 69)" leading="" trailing="" raw_val="h'" val="h'"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(99, 69)" end="(99, 70)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(99, 70)" end="(99, 71)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(99, 72)" end="(99, 76)" leading="" trailing=" " val="else"/>
                <IdentNode start="(99, 77)" end="(99, 82)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(99, 83)" end="(100, 34)">
          <AtomNode start="(99, 83)" end="(99, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(99, 86)" end="(100, 34)">
            <AtomNode start="(99, 86)" end="(99, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(100, 3)" end="(100, 34)">
              <TacticTacticseq1IndentedNode start="(100, 3)" end="(100, 34)">
                <NullNode start="(100, 3)" end="(100, 34)">
                  <OtherNode start="(100, 3)" end="(100, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;xs ys : Array α&#10;⊢ (xs == ys) = if h : xs.size = ys.size then decide (∀ (i : Nat) (h' : i &amp;lt; xs.size), (xs[i] == ys[i]) = true) else false" state_after="no goals" tactic="simp [BEq.beq, isEqv_eq_decide]">
                    <AtomNode start="(100, 3)" end="(100, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(100, 8)" end="(100, 34)">
                      <AtomNode start="(100, 8)" end="(100, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(100, 9)" end="(100, 33)">
                        <OtherNode start="(100, 9)" end="(100, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(100, 9)" end="(100, 16)" leading="" trailing="" raw_val="BEq.beq" val="BEq.beq" full_name="BEq.beq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <AtomNode start="(100, 16)" end="(100, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(100, 18)" end="(100, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(100, 18)" end="(100, 33)" leading="" trailing="" raw_val="isEqv_eq_decide" val="isEqv_eq_decide" full_name="Array.isEqv_eq_decide" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(57, 9)" def_end="(57, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(100, 33)" end="(100, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(102, 1)" end="(103, 43)" name="beq_toList" full_name="Array.beq_toList">
      <CommandDeclmodifiersNode start="(102, 1)" end="(102, 8)">
        <NullNode/>
        <NullNode start="(102, 1)" end="(102, 8)">
          <OtherNode start="(102, 1)" end="(102, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(102, 1)" end="(102, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(102, 3)" end="(102, 7)">
              <OtherNode start="(102, 3)" end="(102, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(102, 3)" end="(102, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(102, 3)" end="(102, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(102, 7)" end="(102, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(102, 9)" end="(103, 43)" name="beq_toList" full_name="Array.beq_toList" _is_private_decl="False">
        <AtomNode start="(102, 9)" end="(102, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(102, 17)" end="(102, 27)">
          <IdentNode start="(102, 17)" end="(102, 27)" leading="" trailing=" " raw_val="beq_toList" val="beq_toList"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(102, 28)" end="(102, 93)">
          <NullNode start="(102, 28)" end="(102, 53)">
            <OtherNode start="(102, 28)" end="(102, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(102, 28)" end="(102, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(102, 29)" end="(102, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(102, 29)" end="(102, 32)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(102, 33)" end="(102, 34)">
                  <IdentNode start="(102, 33)" end="(102, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(102, 34)" end="(102, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(102, 36)" end="(102, 53)">
              <AtomNode start="(102, 36)" end="(102, 37)" leading="" trailing="" val="("/>
              <NullNode start="(102, 37)" end="(102, 42)">
                <IdentNode start="(102, 37)" end="(102, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(102, 40)" end="(102, 42)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(102, 43)" end="(102, 52)">
                <AtomNode start="(102, 43)" end="(102, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(102, 45)" end="(102, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(102, 45)" end="(102, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(102, 51)" end="(102, 52)">
                    <IdentNode start="(102, 51)" end="(102, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(102, 52)" end="(102, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(102, 54)" end="(102, 93)">
            <AtomNode start="(102, 54)" end="(102, 55)" leading="" trailing=" " val=":"/>
            <OtherNode start="(102, 56)" end="(102, 93)" kind="«term_=_»">
              <OtherNode start="(102, 56)" end="(102, 80)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(102, 56)" end="(102, 57)" leading="" trailing="" val="("/>
                <OtherNode start="(102, 57)" end="(102, 79)" kind="«term_==_»">
                  <IdentNode start="(102, 57)" end="(102, 66)" leading="" trailing=" " raw_val="xs.toList" val="xs.toList"/>
                  <AtomNode start="(102, 67)" end="(102, 69)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(102, 70)" end="(102, 79)" leading="" trailing="" raw_val="ys.toList" val="ys.toList"/>
                </OtherNode>
                <AtomNode start="(102, 79)" end="(102, 80)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(102, 81)" end="(102, 82)" leading="" trailing=" " val="="/>
              <OtherNode start="(102, 83)" end="(102, 93)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(102, 83)" end="(102, 84)" leading="" trailing="" val="("/>
                <OtherNode start="(102, 84)" end="(102, 92)" kind="«term_==_»">
                  <IdentNode start="(102, 84)" end="(102, 86)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(102, 87)" end="(102, 89)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(102, 90)" end="(102, 92)" leading="" trailing="" raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(102, 92)" end="(102, 93)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(102, 94)" end="(103, 43)">
          <AtomNode start="(102, 94)" end="(102, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(102, 97)" end="(103, 43)">
            <AtomNode start="(102, 97)" end="(102, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(103, 3)" end="(103, 43)">
              <TacticTacticseq1IndentedNode start="(103, 3)" end="(103, 43)">
                <NullNode start="(103, 3)" end="(103, 43)">
                  <OtherNode start="(103, 3)" end="(103, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;xs ys : Array α&#10;⊢ (xs.toList == ys.toList) = (xs == ys)" state_after="no goals" tactic="simp [beq_eq_decide, List.beq_eq_decide]">
                    <AtomNode start="(103, 3)" end="(103, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(103, 8)" end="(103, 43)">
                      <AtomNode start="(103, 8)" end="(103, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(103, 9)" end="(103, 42)">
                        <OtherNode start="(103, 9)" end="(103, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(103, 9)" end="(103, 22)" leading="" trailing="" raw_val="beq_eq_decide" val="beq_eq_decide" full_name="Array.beq_eq_decide" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(97, 9)" def_end="(97, 22)"/>
                        </OtherNode>
                        <AtomNode start="(103, 22)" end="(103, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(103, 24)" end="(103, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(103, 24)" end="(103, 42)" leading="" trailing="" raw_val="List.beq_eq_decide" val="List.beq_eq_decide" full_name="List.beq_eq_decide" mod_name="Init.Data.List.Nat.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/BEq.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(103, 42)" end="(103, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(105, 1)" end="(105, 10)" name="Array">
      <AtomNode start="(105, 1)" end="(105, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(105, 5)" end="(105, 10)">
        <IdentNode start="(105, 5)" end="(105, 10)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
    <CommandNamespaceNode start="(107, 1)" end="(107, 15)" name="List">
      <AtomNode start="(107, 1)" end="(107, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(107, 11)" end="(107, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(109, 1)" end="(110, 48)" name="isEqv_toArray" full_name="List.isEqv_toArray">
      <CommandDeclmodifiersNode start="(109, 1)" end="(109, 8)">
        <NullNode/>
        <NullNode start="(109, 1)" end="(109, 8)">
          <OtherNode start="(109, 1)" end="(109, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(109, 1)" end="(109, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(109, 3)" end="(109, 7)">
              <OtherNode start="(109, 3)" end="(109, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(109, 3)" end="(109, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(109, 3)" end="(109, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(109, 7)" end="(109, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(109, 9)" end="(110, 48)" name="isEqv_toArray" full_name="List.isEqv_toArray" _is_private_decl="False">
        <AtomNode start="(109, 9)" end="(109, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(109, 17)" end="(109, 30)">
          <IdentNode start="(109, 17)" end="(109, 30)" leading="" trailing=" " raw_val="isEqv_toArray" val="isEqv_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(109, 31)" end="(109, 107)">
          <NullNode start="(109, 31)" end="(109, 55)">
            <OtherNode start="(109, 31)" end="(109, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(109, 31)" end="(109, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(109, 32)" end="(109, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(109, 32)" end="(109, 35)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(109, 36)" end="(109, 37)">
                  <IdentNode start="(109, 36)" end="(109, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(109, 37)" end="(109, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(109, 39)" end="(109, 55)">
              <AtomNode start="(109, 39)" end="(109, 40)" leading="" trailing="" val="("/>
              <NullNode start="(109, 40)" end="(109, 45)">
                <IdentNode start="(109, 40)" end="(109, 42)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(109, 43)" end="(109, 45)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(109, 46)" end="(109, 54)">
                <AtomNode start="(109, 46)" end="(109, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 48)" end="(109, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 48)" end="(109, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(109, 53)" end="(109, 54)">
                    <IdentNode start="(109, 53)" end="(109, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(109, 54)" end="(109, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(109, 56)" end="(109, 107)">
            <AtomNode start="(109, 56)" end="(109, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(109, 58)" end="(109, 107)" kind="«term_=_»">
              <OtherNode start="(109, 58)" end="(109, 89)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(109, 58)" end="(109, 59)" leading="" trailing="" val="("/>
                <OtherNode start="(109, 59)" end="(109, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 59)" end="(109, 75)" leading="" trailing=" " raw_val="as.toArray.isEqv" val="as.toArray.isEqv"/>
                  <NullNode start="(109, 76)" end="(109, 88)">
                    <IdentNode start="(109, 76)" end="(109, 86)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                    <IdentNode start="(109, 87)" end="(109, 88)" leading="" trailing="" raw_val="r" val="r"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(109, 88)" end="(109, 89)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(109, 90)" end="(109, 91)" leading="" trailing=" " val="="/>
              <OtherNode start="(109, 92)" end="(109, 107)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(109, 92)" end="(109, 93)" leading="" trailing="" val="("/>
                <OtherNode start="(109, 93)" end="(109, 106)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 93)" end="(109, 101)" leading="" trailing=" " raw_val="as.isEqv" val="as.isEqv"/>
                  <NullNode start="(109, 102)" end="(109, 106)">
                    <IdentNode start="(109, 102)" end="(109, 104)" leading="" trailing=" " raw_val="bs" val="bs"/>
                    <IdentNode start="(109, 105)" end="(109, 106)" leading="" trailing="" raw_val="r" val="r"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(109, 106)" end="(109, 107)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(109, 108)" end="(110, 48)">
          <AtomNode start="(109, 108)" end="(109, 110)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(109, 111)" end="(110, 48)">
            <AtomNode start="(109, 111)" end="(109, 113)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(110, 3)" end="(110, 48)">
              <TacticTacticseq1IndentedNode start="(110, 3)" end="(110, 48)">
                <NullNode start="(110, 3)" end="(110, 48)">
                  <OtherNode start="(110, 3)" end="(110, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;r : α → α → Bool&#10;inst✝ : BEq α&#10;as bs : List α&#10;⊢ as.toArray.isEqv bs.toArray r = as.isEqv bs r" state_after="no goals" tactic="simp [isEqv_eq_decide, Array.isEqv_eq_decide]">
                    <AtomNode start="(110, 3)" end="(110, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(110, 8)" end="(110, 48)">
                      <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(110, 9)" end="(110, 47)">
                        <OtherNode start="(110, 9)" end="(110, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(110, 9)" end="(110, 24)" leading="" trailing="" raw_val="isEqv_eq_decide" val="isEqv_eq_decide" full_name="List.isEqv_eq_decide" mod_name="Init.Data.List.Nat.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/BEq.lean"/>
                        </OtherNode>
                        <AtomNode start="(110, 24)" end="(110, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(110, 26)" end="(110, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(110, 26)" end="(110, 47)" leading="" trailing="" raw_val="Array.isEqv_eq_decide" val="Array.isEqv_eq_decide" full_name="Array.isEqv_eq_decide" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(57, 9)" def_end="(57, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(110, 47)" end="(110, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(112, 1)" end="(113, 44)" name="beq_toArray" full_name="List.beq_toArray">
      <CommandDeclmodifiersNode start="(112, 1)" end="(112, 8)">
        <NullNode/>
        <NullNode start="(112, 1)" end="(112, 8)">
          <OtherNode start="(112, 1)" end="(112, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(112, 1)" end="(112, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(112, 3)" end="(112, 7)">
              <OtherNode start="(112, 3)" end="(112, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(112, 3)" end="(112, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(112, 3)" end="(112, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(112, 7)" end="(112, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(112, 9)" end="(113, 44)" name="beq_toArray" full_name="List.beq_toArray" _is_private_decl="False">
        <AtomNode start="(112, 9)" end="(112, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(112, 17)" end="(112, 28)">
          <IdentNode start="(112, 17)" end="(112, 28)" leading="" trailing=" " raw_val="beq_toArray" val="beq_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(112, 29)" end="(112, 95)">
          <NullNode start="(112, 29)" end="(112, 53)">
            <OtherNode start="(112, 29)" end="(112, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(112, 29)" end="(112, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(112, 30)" end="(112, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(112, 30)" end="(112, 33)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(112, 34)" end="(112, 35)">
                  <IdentNode start="(112, 34)" end="(112, 35)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(112, 35)" end="(112, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(112, 37)" end="(112, 53)">
              <AtomNode start="(112, 37)" end="(112, 38)" leading="" trailing="" val="("/>
              <NullNode start="(112, 38)" end="(112, 43)">
                <IdentNode start="(112, 38)" end="(112, 40)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(112, 41)" end="(112, 43)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(112, 44)" end="(112, 52)">
                <AtomNode start="(112, 44)" end="(112, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(112, 46)" end="(112, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(112, 46)" end="(112, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(112, 51)" end="(112, 52)">
                    <IdentNode start="(112, 51)" end="(112, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 52)" end="(112, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(112, 54)" end="(112, 95)">
            <AtomNode start="(112, 54)" end="(112, 55)" leading="" trailing=" " val=":"/>
            <OtherNode start="(112, 56)" end="(112, 95)" kind="«term_=_»">
              <OtherNode start="(112, 56)" end="(112, 82)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(112, 56)" end="(112, 57)" leading="" trailing="" val="("/>
                <OtherNode start="(112, 57)" end="(112, 81)" kind="«term_==_»">
                  <IdentNode start="(112, 57)" end="(112, 67)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <AtomNode start="(112, 68)" end="(112, 70)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(112, 71)" end="(112, 81)" leading="" trailing="" raw_val="bs.toArray" val="bs.toArray"/>
                </OtherNode>
                <AtomNode start="(112, 81)" end="(112, 82)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(112, 83)" end="(112, 84)" leading="" trailing=" " val="="/>
              <OtherNode start="(112, 85)" end="(112, 95)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(112, 85)" end="(112, 86)" leading="" trailing="" val="("/>
                <OtherNode start="(112, 86)" end="(112, 94)" kind="«term_==_»">
                  <IdentNode start="(112, 86)" end="(112, 88)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(112, 89)" end="(112, 91)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(112, 92)" end="(112, 94)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
                <AtomNode start="(112, 94)" end="(112, 95)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(112, 96)" end="(113, 44)">
          <AtomNode start="(112, 96)" end="(112, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(112, 99)" end="(113, 44)">
            <AtomNode start="(112, 99)" end="(112, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(113, 3)" end="(113, 44)">
              <TacticTacticseq1IndentedNode start="(113, 3)" end="(113, 44)">
                <NullNode start="(113, 3)" end="(113, 44)">
                  <OtherNode start="(113, 3)" end="(113, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;as bs : List α&#10;⊢ (as.toArray == bs.toArray) = (as == bs)" state_after="no goals" tactic="simp [beq_eq_decide, Array.beq_eq_decide]">
                    <AtomNode start="(113, 3)" end="(113, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(113, 8)" end="(113, 44)">
                      <AtomNode start="(113, 8)" end="(113, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(113, 9)" end="(113, 43)">
                        <OtherNode start="(113, 9)" end="(113, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(113, 9)" end="(113, 22)" leading="" trailing="" raw_val="beq_eq_decide" val="beq_eq_decide" full_name="List.beq_eq_decide" mod_name="Init.Data.List.Nat.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/BEq.lean"/>
                        </OtherNode>
                        <AtomNode start="(113, 22)" end="(113, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(113, 24)" end="(113, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(113, 24)" end="(113, 43)" leading="" trailing="" raw_val="Array.beq_eq_decide" val="Array.beq_eq_decide" full_name="Array.beq_eq_decide" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(97, 9)" def_end="(97, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(113, 43)" end="(113, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(115, 1)" end="(115, 9)" name="List">
      <AtomNode start="(115, 1)" end="(115, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(115, 5)" end="(115, 9)">
        <IdentNode start="(115, 5)" end="(115, 9)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
    <CommandNamespaceNode start="(117, 1)" end="(117, 16)" name="Array">
      <AtomNode start="(117, 1)" end="(117, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(117, 11)" end="(117, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(119, 1)" end="(120, 43)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(119, 1)" end="(120, 43)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(119, 1)" end="(119, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(119, 10)" end="(119, 49)">
          <NullNode start="(119, 10)" end="(119, 29)">
            <OtherNode start="(119, 10)" end="(119, 17)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(119, 10)" end="(119, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(119, 11)" end="(119, 16)" kind="Lean.Parser.Term.app">
                <IdentNode start="(119, 11)" end="(119, 14)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(119, 15)" end="(119, 16)">
                  <IdentNode start="(119, 15)" end="(119, 16)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(119, 16)" end="(119, 17)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(119, 18)" end="(119, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(119, 18)" end="(119, 19)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(119, 19)" end="(119, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(119, 19)" end="(119, 26)" leading="" trailing=" " raw_val="ReflBEq" val="ReflBEq" full_name="ReflBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(119, 27)" end="(119, 28)">
                  <IdentNode start="(119, 27)" end="(119, 28)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(119, 28)" end="(119, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(119, 30)" end="(119, 49)">
            <AtomNode start="(119, 30)" end="(119, 31)" leading="" trailing=" " val=":"/>
            <OtherNode start="(119, 32)" end="(119, 49)" kind="Lean.Parser.Term.app">
              <IdentNode start="(119, 32)" end="(119, 39)" leading="" trailing=" " raw_val="ReflBEq" val="ReflBEq" full_name="ReflBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(119, 40)" end="(119, 49)">
                <OtherNode start="(119, 40)" end="(119, 49)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(119, 40)" end="(119, 41)" leading="" trailing="" val="("/>
                  <OtherNode start="(119, 41)" end="(119, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(119, 41)" end="(119, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(119, 47)" end="(119, 48)">
                      <IdentNode start="(119, 47)" end="(119, 48)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(119, 48)" end="(119, 49)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(119, 50)" end="(120, 43)">
          <AtomNode start="(119, 50)" end="(119, 55)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(120, 3)" end="(120, 43)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(120, 3)" end="(120, 43)">
              <OtherNode start="(120, 3)" end="(120, 43)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(120, 3)" end="(120, 6)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(120, 3)" end="(120, 6)" leading="" trailing=" " raw_val="rfl" val="rfl"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(120, 7)" end="(120, 43)">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(120, 7)" end="(120, 43)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(120, 7)" end="(120, 9)" leading="" trailing=" " val=":="/>
                    <TermBytacticNode start="(120, 10)" end="(120, 43)">
                      <AtomNode start="(120, 10)" end="(120, 12)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(120, 13)" end="(120, 43)">
                        <TacticTacticseq1IndentedNode start="(120, 13)" end="(120, 43)">
                          <NullNode start="(120, 13)" end="(120, 43)">
                            <OtherNode start="(120, 13)" end="(120, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : ReflBEq α&#10;⊢ ∀ {a : Array α}, (a == a) = true" state_after="no goals" tactic="simp [BEq.beq, isEqv_self_beq]">
                              <AtomNode start="(120, 13)" end="(120, 17)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(120, 18)" end="(120, 43)">
                                <AtomNode start="(120, 18)" end="(120, 19)" leading="" trailing="" val="["/>
                                <NullNode start="(120, 19)" end="(120, 42)">
                                  <OtherNode start="(120, 19)" end="(120, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(120, 19)" end="(120, 26)" leading="" trailing="" raw_val="BEq.beq" val="BEq.beq" full_name="BEq.beq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(120, 26)" end="(120, 27)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(120, 28)" end="(120, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(120, 28)" end="(120, 42)" leading="" trailing="" raw_val="isEqv_self_beq" val="isEqv_self_beq" full_name="Array.isEqv_self_beq" mod_name="Init.Data.Array.DecidableEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/DecidableEq.lean" def_start="(85, 9)" def_end="(85, 23)"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(120, 42)" end="(120, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(122, 1)" end="(125, 18)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(122, 1)" end="(125, 18)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(122, 1)" end="(122, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(122, 10)" end="(122, 53)">
          <NullNode start="(122, 10)" end="(122, 31)">
            <OtherNode start="(122, 10)" end="(122, 17)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(122, 10)" end="(122, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(122, 11)" end="(122, 16)" kind="Lean.Parser.Term.app">
                <IdentNode start="(122, 11)" end="(122, 14)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(122, 15)" end="(122, 16)">
                  <IdentNode start="(122, 15)" end="(122, 16)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(122, 16)" end="(122, 17)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(122, 18)" end="(122, 31)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(122, 18)" end="(122, 19)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(122, 19)" end="(122, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(122, 19)" end="(122, 28)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(122, 29)" end="(122, 30)">
                  <IdentNode start="(122, 29)" end="(122, 30)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(122, 30)" end="(122, 31)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(122, 32)" end="(122, 53)">
            <AtomNode start="(122, 32)" end="(122, 33)" leading="" trailing=" " val=":"/>
            <OtherNode start="(122, 34)" end="(122, 53)" kind="Lean.Parser.Term.app">
              <IdentNode start="(122, 34)" end="(122, 43)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(122, 44)" end="(122, 53)">
                <OtherNode start="(122, 44)" end="(122, 53)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(122, 44)" end="(122, 45)" leading="" trailing="" val="("/>
                  <OtherNode start="(122, 45)" end="(122, 52)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(122, 45)" end="(122, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(122, 51)" end="(122, 52)">
                      <IdentNode start="(122, 51)" end="(122, 52)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(122, 52)" end="(122, 53)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(122, 54)" end="(125, 18)">
          <AtomNode start="(122, 54)" end="(122, 59)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(123, 3)" end="(125, 18)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(123, 3)" end="(125, 18)">
              <OtherNode start="(123, 3)" end="(125, 18)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(123, 3)" end="(123, 12)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(123, 3)" end="(123, 12)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(123, 13)" end="(125, 18)">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(123, 13)" end="(125, 18)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(123, 13)" end="(123, 15)" leading="" trailing=" " val=":="/>
                    <TermBytacticNode start="(123, 16)" end="(125, 18)">
                      <AtomNode start="(123, 16)" end="(123, 18)" leading="" trailing="&#10;    " val="by"/>
                      <TacticTacticseqNode start="(124, 5)" end="(125, 18)">
                        <TacticTacticseq1IndentedNode start="(124, 5)" end="(125, 18)">
                          <NullNode start="(124, 5)" end="(125, 18)">
                            <OtherNode start="(124, 5)" end="(124, 21)" kind="Lean.Parser.Tactic.rintro" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;⊢ ∀ {a b : Array α}, (a == b) = true → a = b" state_after="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;toList✝¹ toList✝ : List α&#10;h : ({ toList := toList✝¹ } == { toList := toList✝ }) = true&#10;⊢ { toList := toList✝¹ } = { toList := toList✝ }" tactic="rintro ⟨_⟩ ⟨_⟩ h">
                              <AtomNode start="(124, 5)" end="(124, 11)" leading="" trailing=" " val="rintro"/>
                              <NullNode start="(124, 12)" end="(124, 21)">
                                <OtherNode start="(124, 12)" end="(124, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                  <OtherNode start="(124, 12)" end="(124, 15)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(124, 12)" end="(124, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(124, 13)" end="(124, 14)">
                                      <OtherNode start="(124, 13)" end="(124, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(124, 13)" end="(124, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(124, 13)" end="(124, 14)">
                                            <OtherNode start="(124, 13)" end="(124, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                              <AtomNode start="(124, 13)" end="(124, 14)" leading="" trailing="" val="_"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(124, 14)" end="(124, 15)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(124, 16)" end="(124, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                                  <OtherNode start="(124, 16)" end="(124, 19)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(124, 16)" end="(124, 17)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(124, 17)" end="(124, 18)">
                                      <OtherNode start="(124, 17)" end="(124, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(124, 17)" end="(124, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(124, 17)" end="(124, 18)">
                                            <OtherNode start="(124, 17)" end="(124, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                              <AtomNode start="(124, 17)" end="(124, 18)" leading="" trailing="" val="_"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(124, 18)" end="(124, 19)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(124, 20)" end="(124, 21)" kind="Lean.Parser.Tactic.rintroPat.one">
                                  <OtherNode start="(124, 20)" end="(124, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(124, 20)" end="(124, 21)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(125, 5)" end="(125, 18)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;toList✝¹ toList✝ : List α&#10;h : ({ toList := toList✝¹ } == { toList := toList✝ }) = true&#10;⊢ { toList := toList✝¹ } = { toList := toList✝ }" state_after="no goals" tactic="simpa using h">
                              <AtomNode start="(125, 5)" end="(125, 10)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(125, 11)" end="(125, 18)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(125, 11)" end="(125, 18)">
                                  <AtomNode start="(125, 11)" end="(125, 16)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(125, 17)" end="(125, 18)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(127, 1)" end="(127, 10)" name="Array">
      <AtomNode start="(127, 1)" end="(127, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(127, 5)" end="(127, 10)">
        <IdentNode start="(127, 5)" end="(127, 10)" leading="" trailing="&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(14, 38)" end="(15, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(15, 39)" end="(17, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(43, 1)" end="(44, 1)" text="-- This is private as the forward direction of `isEqv_iff_rel` may be used.&#10;"/>
  </Comments>
</TracedFile>
