<TracedFile path="src/lean/Init/Data/Array/Erase.lean" md5="13f587a716a394afb2d07e9bad728ef3">
  <FileNode start="(1, 1)" end="(436, 10)">
    <ModuleHeaderNode start="(6, 1)" end="(11, 32)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(11, 32)">
        <ModuleImportNode start="(9, 1)" end="(9, 30)" module="Init.Data.Array.Lemmas" path="src/lean/Init/Data/Array/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Lemmas" val="Init.Data.Array.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 32)" module="Init.Data.List.Nat.Erase" path="src/lean/Init/Data/List/Nat/Erase.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 32)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.Erase" val="Init.Data.List.Nat.Erase"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 32)" module="Init.Data.List.Nat.Basic" path="src/lean/Init/Data/List/Nat/Basic.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 32)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Nat.Basic" val="Init.Data.List.Nat.Basic"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(13, 1)" end="(15, 3)" comment="# Lemmas about `Array.eraseP`, `Array.erase`, and `Array.eraseIdx`.&#10;-/">
      <AtomNode start="(13, 1)" end="(13, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(14, 1)" end="(15, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `Array.eraseP`, `Array.erase`, and `Array.eraseIdx`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(17, 1)" end="(17, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(17, 1)" end="(17, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(17, 12)" end="(17, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(17, 33)" end="(17, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(18, 1)" end="(18, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(18, 1)" end="(18, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(18, 12)" end="(18, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(18, 34)" end="(18, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(20, 1)" end="(20, 16)" name="Array">
      <AtomNode start="(20, 1)" end="(20, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(20, 11)" end="(20, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(22, 1)" end="(22, 9)">
      <AtomNode start="(22, 1)" end="(22, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(22, 6)" end="(22, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(22, 6)" end="(22, 9)">
          <IdentNode start="(22, 6)" end="(22, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(24, 1)" end="(24, 18)" comment="### eraseP -/">
      <AtomNode start="(24, 1)" end="(24, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(24, 5)" end="(24, 18)" leading="" trailing="&#10;&#10;" val="### eraseP -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(26, 1)" end="(26, 61)" name="eraseP_empty" full_name="Array.eraseP_empty">
      <CommandDeclmodifiersNode start="(26, 1)" end="(26, 8)">
        <NullNode/>
        <NullNode start="(26, 1)" end="(26, 8)">
          <OtherNode start="(26, 1)" end="(26, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(26, 1)" end="(26, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(26, 3)" end="(26, 7)">
              <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(26, 3)" end="(26, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(26, 7)" end="(26, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(26, 9)" end="(26, 61)" name="eraseP_empty" full_name="Array.eraseP_empty" _is_private_decl="False">
        <AtomNode start="(26, 9)" end="(26, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(26, 17)" end="(26, 29)">
          <IdentNode start="(26, 17)" end="(26, 29)" leading="" trailing=" " raw_val="eraseP_empty" val="eraseP_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(26, 30)" end="(26, 50)">
          <NullNode/>
          <TermTypespecNode start="(26, 30)" end="(26, 50)">
            <AtomNode start="(26, 30)" end="(26, 31)" leading="" trailing=" " val=":"/>
            <OtherNode start="(26, 32)" end="(26, 50)" kind="«term_=_»">
              <OtherNode start="(26, 32)" end="(26, 44)" kind="Lean.Parser.Term.app">
                <OtherNode start="(26, 32)" end="(26, 42)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(26, 32)" end="(26, 35)" kind="«term#[_,]»">
                    <AtomNode start="(26, 32)" end="(26, 34)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(26, 34)" end="(26, 35)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(26, 35)" end="(26, 36)" leading="" trailing="" val="."/>
                  <IdentNode start="(26, 36)" end="(26, 42)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(26, 43)" end="(26, 44)">
                  <IdentNode start="(26, 43)" end="(26, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(26, 45)" end="(26, 46)" leading="" trailing=" " val="="/>
              <OtherNode start="(26, 47)" end="(26, 50)" kind="«term#[_,]»">
                <AtomNode start="(26, 47)" end="(26, 49)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(26, 49)" end="(26, 50)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(26, 51)" end="(26, 61)">
          <AtomNode start="(26, 51)" end="(26, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(26, 54)" end="(26, 61)">
            <AtomNode start="(26, 54)" end="(26, 56)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(26, 57)" end="(26, 61)">
              <TacticTacticseq1IndentedNode start="(26, 57)" end="(26, 61)">
                <NullNode start="(26, 57)" end="(26, 61)">
                  <OtherNode start="(26, 57)" end="(26, 61)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;⊢ #[].eraseP p = #[]" state_after="no goals" tactic="simp">
                    <AtomNode start="(26, 57)" end="(26, 61)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(28, 1)" end="(30, 39)" name="eraseP_of_forall_mem_not" full_name="Array.eraseP_of_forall_mem_not">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(28, 1)" end="(30, 39)" name="eraseP_of_forall_mem_not" full_name="Array.eraseP_of_forall_mem_not" _is_private_decl="False">
        <AtomNode start="(28, 1)" end="(28, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(28, 9)" end="(28, 33)">
          <IdentNode start="(28, 9)" end="(28, 33)" leading="" trailing=" " raw_val="eraseP_of_forall_mem_not" val="eraseP_of_forall_mem_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(28, 34)" end="(28, 92)">
          <NullNode start="(28, 34)" end="(28, 73)">
            <OtherNode start="(28, 34)" end="(28, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(28, 34)" end="(28, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(28, 35)" end="(28, 37)">
                <IdentNode start="(28, 35)" end="(28, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(28, 38)" end="(28, 47)">
                <AtomNode start="(28, 38)" end="(28, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(28, 40)" end="(28, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(28, 40)" end="(28, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(28, 46)" end="(28, 47)">
                    <IdentNode start="(28, 46)" end="(28, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(28, 47)" end="(28, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(28, 49)" end="(28, 73)">
              <AtomNode start="(28, 49)" end="(28, 50)" leading="" trailing="" val="("/>
              <NullNode start="(28, 50)" end="(28, 51)">
                <IdentNode start="(28, 50)" end="(28, 51)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(28, 52)" end="(28, 72)">
                <AtomNode start="(28, 52)" end="(28, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(28, 54)" end="(28, 72)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(28, 54)" end="(28, 55)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(28, 56)" end="(28, 57)">
                    <IdentNode start="(28, 56)" end="(28, 57)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(28, 57)" end="(28, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(28, 59)" end="(28, 72)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(28, 59)" end="(28, 65)" kind="«term_∈_»">
                      <IdentNode start="(28, 59)" end="(28, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(28, 61)" end="(28, 62)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(28, 63)" end="(28, 65)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(28, 66)" end="(28, 67)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(28, 68)" end="(28, 72)" kind="«term¬_»">
                      <AtomNode start="(28, 68)" end="(28, 69)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(28, 69)" end="(28, 72)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(28, 69)" end="(28, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(28, 71)" end="(28, 72)">
                          <IdentNode start="(28, 71)" end="(28, 72)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(28, 72)" end="(28, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(28, 74)" end="(28, 92)">
            <AtomNode start="(28, 74)" end="(28, 75)" leading="" trailing=" " val=":"/>
            <OtherNode start="(28, 76)" end="(28, 92)" kind="«term_=_»">
              <OtherNode start="(28, 76)" end="(28, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(28, 76)" end="(28, 85)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                <NullNode start="(28, 86)" end="(28, 87)">
                  <IdentNode start="(28, 86)" end="(28, 87)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(28, 88)" end="(28, 89)" leading="" trailing=" " val="="/>
              <IdentNode start="(28, 90)" end="(28, 92)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(28, 93)" end="(30, 39)">
          <AtomNode start="(28, 93)" end="(28, 95)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(28, 96)" end="(30, 39)">
            <AtomNode start="(28, 96)" end="(28, 98)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(29, 3)" end="(30, 39)">
              <TacticTacticseq1IndentedNode start="(29, 3)" end="(30, 39)">
                <NullNode start="(29, 3)" end="(30, 39)">
                  <OtherNode start="(29, 3)" end="(29, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∀ (a : α), a ∈ xs → ¬p a = true&#10;⊢ xs.eraseP p = xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → ¬p a = true&#10;⊢ { toList := xs }.eraseP p = { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(29, 3)" end="(29, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(29, 10)" end="(29, 12)">
                      <OtherNode start="(29, 10)" end="(29, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(29, 10)" end="(29, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(29, 13)" end="(29, 22)">
                      <AtomNode start="(29, 13)" end="(29, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(29, 18)" end="(29, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(29, 18)" end="(29, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(29, 18)" end="(29, 22)">
                            <OtherNode start="(29, 18)" end="(29, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(29, 18)" end="(29, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(29, 19)" end="(29, 21)">
                                <OtherNode start="(29, 19)" end="(29, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(29, 19)" end="(29, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(29, 19)" end="(29, 21)">
                                      <OtherNode start="(29, 19)" end="(29, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(29, 19)" end="(29, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(29, 21)" end="(29, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(30, 3)" end="(30, 39)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → ¬p a = true&#10;⊢ { toList := xs }.eraseP p = { toList := xs }" state_after="no goals" tactic="simp_all [List.eraseP_of_forall_not]">
                    <AtomNode start="(30, 3)" end="(30, 11)" leading="" trailing=" " val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(30, 12)" end="(30, 39)">
                      <AtomNode start="(30, 12)" end="(30, 13)" leading="" trailing="" val="["/>
                      <NullNode start="(30, 13)" end="(30, 38)">
                        <OtherNode start="(30, 13)" end="(30, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(30, 13)" end="(30, 38)" leading="" trailing="" raw_val="List.eraseP_of_forall_not" val="List.eraseP_of_forall_not" full_name="List.eraseP_of_forall_not" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(30, 38)" end="(30, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(32, 1)" end="(36, 16)" name="eraseP_of_forall_getElem_not" full_name="Array.eraseP_of_forall_getElem_not">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(32, 1)" end="(36, 16)" name="eraseP_of_forall_getElem_not" full_name="Array.eraseP_of_forall_getElem_not" _is_private_decl="False">
        <AtomNode start="(32, 1)" end="(32, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(32, 9)" end="(32, 37)">
          <IdentNode start="(32, 9)" end="(32, 37)" leading="" trailing=" " raw_val="eraseP_of_forall_getElem_not" val="eraseP_of_forall_getElem_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(32, 38)" end="(32, 111)">
          <NullNode start="(32, 38)" end="(32, 92)">
            <OtherNode start="(32, 38)" end="(32, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(32, 38)" end="(32, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(32, 39)" end="(32, 41)">
                <IdentNode start="(32, 39)" end="(32, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(32, 42)" end="(32, 51)">
                <AtomNode start="(32, 42)" end="(32, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(32, 44)" end="(32, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(32, 44)" end="(32, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(32, 50)" end="(32, 51)">
                    <IdentNode start="(32, 50)" end="(32, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(32, 51)" end="(32, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(32, 53)" end="(32, 92)">
              <AtomNode start="(32, 53)" end="(32, 54)" leading="" trailing="" val="("/>
              <NullNode start="(32, 54)" end="(32, 55)">
                <IdentNode start="(32, 54)" end="(32, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(32, 56)" end="(32, 91)">
                <AtomNode start="(32, 56)" end="(32, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(32, 58)" end="(32, 91)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(32, 58)" end="(32, 59)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(32, 60)" end="(32, 61)">
                    <IdentNode start="(32, 60)" end="(32, 61)" leading="" trailing="" raw_val="i" val="i"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(32, 61)" end="(32, 62)" leading="" trailing=" " val=","/>
                  <OtherNode start="(32, 63)" end="(32, 91)" kind="Lean.Parser.Term.depArrow">
                    <TermExplicitbinderNode start="(32, 63)" end="(32, 80)">
                      <AtomNode start="(32, 63)" end="(32, 64)" leading="" trailing="" val="("/>
                      <NullNode start="(32, 64)" end="(32, 65)">
                        <IdentNode start="(32, 64)" end="(32, 65)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode start="(32, 66)" end="(32, 79)">
                        <AtomNode start="(32, 66)" end="(32, 67)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(32, 68)" end="(32, 79)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(32, 68)" end="(32, 69)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(32, 70)" end="(32, 71)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(32, 72)" end="(32, 79)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(32, 79)" end="(32, 80)" leading="" trailing=" " val=")"/>
                    </TermExplicitbinderNode>
                    <AtomNode start="(32, 81)" end="(32, 82)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(32, 83)" end="(32, 91)" kind="«term¬_»">
                      <AtomNode start="(32, 83)" end="(32, 84)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(32, 84)" end="(32, 91)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(32, 84)" end="(32, 85)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(32, 86)" end="(32, 91)">
                          <OtherNode start="(32, 86)" end="(32, 91)" kind="«term__[_]»">
                            <IdentNode start="(32, 86)" end="(32, 88)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(32, 88)" end="(32, 89)" leading="" trailing="" val="["/>
                            <IdentNode start="(32, 89)" end="(32, 90)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(32, 90)" end="(32, 91)" leading="" trailing="" val="]"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(32, 91)" end="(32, 92)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(32, 93)" end="(32, 111)">
            <AtomNode start="(32, 93)" end="(32, 94)" leading="" trailing=" " val=":"/>
            <OtherNode start="(32, 95)" end="(32, 111)" kind="«term_=_»">
              <OtherNode start="(32, 95)" end="(32, 106)" kind="Lean.Parser.Term.app">
                <IdentNode start="(32, 95)" end="(32, 104)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                <NullNode start="(32, 105)" end="(32, 106)">
                  <IdentNode start="(32, 105)" end="(32, 106)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(32, 107)" end="(32, 108)" leading="" trailing=" " val="="/>
              <IdentNode start="(32, 109)" end="(32, 111)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(32, 112)" end="(36, 16)">
          <AtomNode start="(32, 112)" end="(32, 114)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(33, 3)" end="(36, 16)" kind="Lean.Parser.Term.app">
            <IdentNode start="(33, 3)" end="(33, 27)" leading="" trailing=" " raw_val="eraseP_of_forall_mem_not" val="eraseP_of_forall_mem_not" full_name="Array.eraseP_of_forall_mem_not" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(28, 9)" def_end="(28, 33)"/>
            <NullNode start="(33, 28)" end="(36, 16)">
              <OtherNode start="(33, 28)" end="(36, 16)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(33, 28)" end="(33, 31)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(33, 32)" end="(36, 16)" kind="Lean.Parser.Term.basicFun">
                  <NullNode start="(33, 32)" end="(33, 35)">
                    <IdentNode start="(33, 32)" end="(33, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(33, 34)" end="(33, 35)" leading="" trailing=" " raw_val="m" val="m"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(33, 36)" end="(33, 38)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(33, 39)" end="(36, 16)">
                    <AtomNode start="(33, 39)" end="(33, 41)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(34, 5)" end="(36, 16)">
                      <TacticTacticseq1IndentedNode start="(34, 5)" end="(36, 16)">
                        <NullNode start="(34, 5)" end="(36, 16)">
                          <OtherNode start="(34, 5)" end="(34, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∀ (i : Nat) (h : i &amp;lt; xs.size), ¬p xs[i] = true&#10;a : α&#10;m : a ∈ xs&#10;⊢ ¬p a = true" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∀ (i : Nat) (h : i &amp;lt; xs.size), ¬p xs[i] = true&#10;a : α&#10;m : ∃ i h, xs[i] = a&#10;⊢ ¬p a = true" tactic="rw [mem_iff_getElem] at m">
                            <AtomNode start="(34, 5)" end="(34, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(34, 8)" end="(34, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(34, 8)" end="(34, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(34, 9)" end="(34, 24)">
                                <OtherNode start="(34, 9)" end="(34, 24)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(34, 9)" end="(34, 24)" leading="" trailing="" raw_val="mem_iff_getElem" val="mem_iff_getElem" full_name="Array.mem_iff_getElem" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(34, 24)" end="(34, 25)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(34, 26)" end="(34, 30)">
                              <OtherNode start="(34, 26)" end="(34, 30)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(34, 26)" end="(34, 28)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(34, 29)" end="(34, 30)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(34, 29)" end="(34, 30)">
                                    <IdentNode start="(34, 29)" end="(34, 30)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(35, 5)" end="(35, 28)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∀ (i : Nat) (h : i &amp;lt; xs.size), ¬p xs[i] = true&#10;a : α&#10;m : ∃ i h, xs[i] = a&#10;⊢ ¬p a = true" state_after="case intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∀ (i : Nat) (h : i &amp;lt; xs.size), ¬p xs[i] = true&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;⊢ ¬p xs[i] = true" tactic="obtain ⟨i, w, rfl⟩ := m">
                            <AtomNode start="(35, 5)" end="(35, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(35, 12)" end="(35, 23)">
                              <OtherNode start="(35, 12)" end="(35, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(35, 12)" end="(35, 23)">
                                  <OtherNode start="(35, 12)" end="(35, 23)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(35, 12)" end="(35, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(35, 13)" end="(35, 22)">
                                      <OtherNode start="(35, 13)" end="(35, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(35, 13)" end="(35, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(35, 13)" end="(35, 14)">
                                            <OtherNode start="(35, 13)" end="(35, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(35, 13)" end="(35, 14)" leading="" trailing="" raw_val="i" val="i"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(35, 14)" end="(35, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(35, 16)" end="(35, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(35, 16)" end="(35, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(35, 16)" end="(35, 17)">
                                            <OtherNode start="(35, 16)" end="(35, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(35, 16)" end="(35, 17)" leading="" trailing="" raw_val="w" val="w"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(35, 17)" end="(35, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(35, 19)" end="(35, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(35, 19)" end="(35, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(35, 19)" end="(35, 22)">
                                            <OtherNode start="(35, 19)" end="(35, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(35, 19)" end="(35, 22)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(35, 22)" end="(35, 23)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(35, 24)" end="(35, 28)">
                              <AtomNode start="(35, 24)" end="(35, 26)" leading="" trailing=" " val=":="/>
                              <NullNode start="(35, 27)" end="(35, 28)">
                                <IdentNode start="(35, 27)" end="(35, 28)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(36, 5)" end="(36, 16)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∀ (i : Nat) (h : i &amp;lt; xs.size), ¬p xs[i] = true&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;⊢ ¬p xs[i] = true" state_after="no goals" tactic="exact h i w">
                            <AtomNode start="(36, 5)" end="(36, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(36, 11)" end="(36, 16)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(36, 11)" end="(36, 12)" leading="" trailing=" " raw_val="h" val="h"/>
                              <NullNode start="(36, 13)" end="(36, 16)">
                                <IdentNode start="(36, 13)" end="(36, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(36, 15)" end="(36, 16)" leading="" trailing="&#10;&#10;" raw_val="w" val="w"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(38, 1)" end="(40, 7)" name="eraseP_eq_empty_iff" full_name="Array.eraseP_eq_empty_iff">
      <CommandDeclmodifiersNode start="(38, 1)" end="(38, 8)">
        <NullNode/>
        <NullNode start="(38, 1)" end="(38, 8)">
          <OtherNode start="(38, 1)" end="(38, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(38, 1)" end="(38, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(38, 3)" end="(38, 7)">
              <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(38, 3)" end="(38, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(38, 7)" end="(38, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(38, 9)" end="(40, 7)" name="eraseP_eq_empty_iff" full_name="Array.eraseP_eq_empty_iff" _is_private_decl="False">
        <AtomNode start="(38, 9)" end="(38, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(38, 17)" end="(38, 36)">
          <IdentNode start="(38, 17)" end="(38, 36)" leading="" trailing=" " raw_val="eraseP_eq_empty_iff" val="eraseP_eq_empty_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(38, 37)" end="(38, 120)">
          <NullNode start="(38, 37)" end="(38, 66)">
            <OtherNode start="(38, 37)" end="(38, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(38, 37)" end="(38, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(38, 38)" end="(38, 40)">
                <IdentNode start="(38, 38)" end="(38, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(38, 41)" end="(38, 50)">
                <AtomNode start="(38, 41)" end="(38, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(38, 43)" end="(38, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(38, 43)" end="(38, 48)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(38, 49)" end="(38, 50)">
                    <IdentNode start="(38, 49)" end="(38, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(38, 50)" end="(38, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(38, 52)" end="(38, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(38, 52)" end="(38, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(38, 53)" end="(38, 54)">
                <IdentNode start="(38, 53)" end="(38, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(38, 55)" end="(38, 65)">
                <AtomNode start="(38, 55)" end="(38, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(38, 57)" end="(38, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(38, 57)" end="(38, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(38, 59)" end="(38, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(38, 61)" end="(38, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(38, 65)" end="(38, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(38, 67)" end="(38, 120)">
            <AtomNode start="(38, 67)" end="(38, 68)" leading="" trailing=" " val=":"/>
            <OtherNode start="(38, 69)" end="(38, 120)" kind="«term_↔_»">
              <OtherNode start="(38, 69)" end="(38, 86)" kind="«term_=_»">
                <OtherNode start="(38, 69)" end="(38, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(38, 69)" end="(38, 78)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(38, 79)" end="(38, 80)">
                    <IdentNode start="(38, 79)" end="(38, 80)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(38, 81)" end="(38, 82)" leading="" trailing=" " val="="/>
                <OtherNode start="(38, 83)" end="(38, 86)" kind="«term#[_,]»">
                  <AtomNode start="(38, 83)" end="(38, 85)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(38, 85)" end="(38, 86)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(38, 87)" end="(38, 88)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(38, 89)" end="(38, 120)" kind="«term_∨_»">
                <OtherNode start="(38, 89)" end="(38, 97)" kind="«term_=_»">
                  <IdentNode start="(38, 89)" end="(38, 91)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(38, 92)" end="(38, 93)" leading="" trailing=" " val="="/>
                  <OtherNode start="(38, 94)" end="(38, 97)" kind="«term#[_,]»">
                    <AtomNode start="(38, 94)" end="(38, 96)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(38, 96)" end="(38, 97)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(38, 98)" end="(38, 99)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(38, 100)" end="(38, 120)" kind="«term∃_,_»">
                  <AtomNode start="(38, 100)" end="(38, 101)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(38, 102)" end="(38, 103)" kind="Lean.explicitBinders">
                    <OtherNode start="(38, 102)" end="(38, 103)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(38, 102)" end="(38, 103)">
                        <LeanBinderidentNode start="(38, 102)" end="(38, 103)">
                          <IdentNode start="(38, 102)" end="(38, 103)" leading="" trailing="" raw_val="x" val="x"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(38, 103)" end="(38, 104)" leading="" trailing=" " val=","/>
                  <OtherNode start="(38, 105)" end="(38, 120)" kind="«term_∧_»">
                    <OtherNode start="(38, 105)" end="(38, 108)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(38, 105)" end="(38, 106)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(38, 107)" end="(38, 108)">
                        <IdentNode start="(38, 107)" end="(38, 108)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(38, 109)" end="(38, 110)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(38, 111)" end="(38, 120)" kind="«term_=_»">
                      <IdentNode start="(38, 111)" end="(38, 113)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(38, 114)" end="(38, 115)" leading="" trailing=" " val="="/>
                      <OtherNode start="(38, 116)" end="(38, 120)" kind="«term#[_,]»">
                        <AtomNode start="(38, 116)" end="(38, 118)" leading="" trailing="" val="#["/>
                        <NullNode start="(38, 118)" end="(38, 119)">
                          <IdentNode start="(38, 118)" end="(38, 119)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                        <AtomNode start="(38, 119)" end="(38, 120)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(38, 121)" end="(40, 7)">
          <AtomNode start="(38, 121)" end="(38, 123)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(38, 124)" end="(40, 7)">
            <AtomNode start="(38, 124)" end="(38, 126)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(39, 3)" end="(40, 7)">
              <TacticTacticseq1IndentedNode start="(39, 3)" end="(40, 7)">
                <NullNode start="(39, 3)" end="(40, 7)">
                  <OtherNode start="(39, 3)" end="(39, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ xs.eraseP p = #[] ↔ xs = #[] ∨ ∃ x, p x = true ∧ xs = #[x]" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ { toList := toList✝ }.eraseP p = #[] ↔ { toList := toList✝ } = #[] ∨ ∃ x, p x = true ∧ { toList := toList✝ } = #[x]" tactic="cases xs">
                    <AtomNode start="(39, 3)" end="(39, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(39, 9)" end="(39, 11)">
                      <OtherNode start="(39, 9)" end="(39, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(39, 9)" end="(39, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(40, 3)" end="(40, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;toList✝ : List α&#10;⊢ { toList := toList✝ }.eraseP p = #[] ↔ { toList := toList✝ } = #[] ∨ ∃ x, p x = true ∧ { toList := toList✝ } = #[x]" state_after="no goals" tactic="simp">
                    <AtomNode start="(40, 3)" end="(40, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(42, 1)" end="(43, 7)" name="eraseP_ne_empty_iff" full_name="Array.eraseP_ne_empty_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(42, 1)" end="(43, 7)" name="eraseP_ne_empty_iff" full_name="Array.eraseP_ne_empty_iff" _is_private_decl="False">
        <AtomNode start="(42, 1)" end="(42, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(42, 9)" end="(42, 28)">
          <IdentNode start="(42, 9)" end="(42, 28)" leading="" trailing=" " raw_val="eraseP_ne_empty_iff" val="eraseP_ne_empty_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(42, 29)" end="(42, 112)">
          <NullNode start="(42, 29)" end="(42, 58)">
            <OtherNode start="(42, 29)" end="(42, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(42, 29)" end="(42, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(42, 30)" end="(42, 32)">
                <IdentNode start="(42, 30)" end="(42, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(42, 33)" end="(42, 42)">
                <AtomNode start="(42, 33)" end="(42, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(42, 35)" end="(42, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(42, 35)" end="(42, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(42, 41)" end="(42, 42)">
                    <IdentNode start="(42, 41)" end="(42, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(42, 42)" end="(42, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(42, 44)" end="(42, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(42, 44)" end="(42, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(42, 45)" end="(42, 46)">
                <IdentNode start="(42, 45)" end="(42, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(42, 47)" end="(42, 57)">
                <AtomNode start="(42, 47)" end="(42, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(42, 49)" end="(42, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(42, 49)" end="(42, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(42, 51)" end="(42, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(42, 53)" end="(42, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(42, 57)" end="(42, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(42, 59)" end="(42, 112)">
            <AtomNode start="(42, 59)" end="(42, 60)" leading="" trailing=" " val=":"/>
            <OtherNode start="(42, 61)" end="(42, 112)" kind="«term_↔_»">
              <OtherNode start="(42, 61)" end="(42, 78)" kind="«term_≠_»">
                <OtherNode start="(42, 61)" end="(42, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(42, 61)" end="(42, 70)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(42, 71)" end="(42, 72)">
                    <IdentNode start="(42, 71)" end="(42, 72)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(42, 73)" end="(42, 74)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(42, 75)" end="(42, 78)" kind="«term#[_,]»">
                  <AtomNode start="(42, 75)" end="(42, 77)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(42, 77)" end="(42, 78)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(42, 79)" end="(42, 80)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(42, 81)" end="(42, 112)" kind="«term_∧_»">
                <OtherNode start="(42, 81)" end="(42, 89)" kind="«term_≠_»">
                  <IdentNode start="(42, 81)" end="(42, 83)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(42, 84)" end="(42, 85)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(42, 86)" end="(42, 89)" kind="«term#[_,]»">
                    <AtomNode start="(42, 86)" end="(42, 88)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(42, 88)" end="(42, 89)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(42, 90)" end="(42, 91)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(42, 92)" end="(42, 112)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(42, 92)" end="(42, 93)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(42, 94)" end="(42, 95)">
                    <IdentNode start="(42, 94)" end="(42, 95)" leading="" trailing="" raw_val="x" val="x"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(42, 95)" end="(42, 96)" leading="" trailing=" " val=","/>
                  <OtherNode start="(42, 97)" end="(42, 112)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(42, 97)" end="(42, 100)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(42, 97)" end="(42, 98)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(42, 99)" end="(42, 100)">
                        <IdentNode start="(42, 99)" end="(42, 100)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(42, 101)" end="(42, 102)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(42, 103)" end="(42, 112)" kind="«term_≠_»">
                      <IdentNode start="(42, 103)" end="(42, 105)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(42, 106)" end="(42, 107)" leading="" trailing=" " val="≠"/>
                      <OtherNode start="(42, 108)" end="(42, 112)" kind="«term#[_,]»">
                        <AtomNode start="(42, 108)" end="(42, 110)" leading="" trailing="" val="#["/>
                        <NullNode start="(42, 110)" end="(42, 111)">
                          <IdentNode start="(42, 110)" end="(42, 111)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                        <AtomNode start="(42, 111)" end="(42, 112)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(42, 113)" end="(43, 7)">
          <AtomNode start="(42, 113)" end="(42, 115)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(42, 116)" end="(43, 7)">
            <AtomNode start="(42, 116)" end="(42, 118)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(43, 3)" end="(43, 7)">
              <TacticTacticseq1IndentedNode start="(43, 3)" end="(43, 7)">
                <NullNode start="(43, 3)" end="(43, 7)">
                  <OtherNode start="(43, 3)" end="(43, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;p : α → Bool&#10;⊢ xs.eraseP p ≠ #[] ↔ xs ≠ #[] ∧ ∀ (x : α), p x = true → xs ≠ #[x]" state_after="no goals" tactic="simp">
                    <AtomNode start="(43, 3)" end="(43, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(45, 1)" end="(49, 76)" name="exists_of_eraseP" full_name="Array.exists_of_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(45, 1)" end="(49, 76)" name="exists_of_eraseP" full_name="Array.exists_of_eraseP" _is_private_decl="False">
        <AtomNode start="(45, 1)" end="(45, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(45, 9)" end="(45, 25)">
          <IdentNode start="(45, 9)" end="(45, 25)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(45, 26)" end="(46, 86)">
          <NullNode start="(45, 26)" end="(45, 69)">
            <OtherNode start="(45, 26)" end="(45, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(45, 26)" end="(45, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(45, 27)" end="(45, 29)">
                <IdentNode start="(45, 27)" end="(45, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(45, 30)" end="(45, 39)">
                <AtomNode start="(45, 30)" end="(45, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 32)" end="(45, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(45, 32)" end="(45, 37)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(45, 38)" end="(45, 39)">
                    <IdentNode start="(45, 38)" end="(45, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(45, 39)" end="(45, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(45, 41)" end="(45, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(45, 41)" end="(45, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(45, 42)" end="(45, 43)">
                <IdentNode start="(45, 42)" end="(45, 43)" leading="" trailing="" raw_val="a" val="a"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(45, 43)" end="(45, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(45, 45)" end="(45, 58)">
              <AtomNode start="(45, 45)" end="(45, 46)" leading="" trailing="" val="("/>
              <NullNode start="(45, 46)" end="(45, 48)">
                <IdentNode start="(45, 46)" end="(45, 48)" leading="" trailing=" " raw_val="hm" val="hm"/>
              </NullNode>
              <NullNode start="(45, 49)" end="(45, 57)">
                <AtomNode start="(45, 49)" end="(45, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 51)" end="(45, 57)" kind="«term_∈_»">
                  <IdentNode start="(45, 51)" end="(45, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(45, 53)" end="(45, 54)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(45, 55)" end="(45, 57)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(45, 57)" end="(45, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(45, 59)" end="(45, 69)">
              <AtomNode start="(45, 59)" end="(45, 60)" leading="" trailing="" val="("/>
              <NullNode start="(45, 60)" end="(45, 62)">
                <IdentNode start="(45, 60)" end="(45, 62)" leading="" trailing=" " raw_val="hp" val="hp"/>
              </NullNode>
              <NullNode start="(45, 63)" end="(45, 68)">
                <AtomNode start="(45, 63)" end="(45, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 65)" end="(45, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(45, 65)" end="(45, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(45, 67)" end="(45, 68)">
                    <IdentNode start="(45, 67)" end="(45, 68)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(45, 68)" end="(45, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(45, 70)" end="(46, 86)">
            <AtomNode start="(45, 70)" end="(45, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(46, 5)" end="(46, 86)" kind="«term∃_,_»">
              <AtomNode start="(46, 5)" end="(46, 6)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(46, 7)" end="(46, 14)" kind="Lean.explicitBinders">
                <OtherNode start="(46, 7)" end="(46, 14)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(46, 7)" end="(46, 14)">
                    <LeanBinderidentNode start="(46, 7)" end="(46, 8)">
                      <IdentNode start="(46, 7)" end="(46, 8)" leading="" trailing=" " raw_val="a" val="a"/>
                    </LeanBinderidentNode>
                    <LeanBinderidentNode start="(46, 9)" end="(46, 11)">
                      <IdentNode start="(46, 9)" end="(46, 11)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    </LeanBinderidentNode>
                    <LeanBinderidentNode start="(46, 12)" end="(46, 14)">
                      <IdentNode start="(46, 12)" end="(46, 14)" leading="" trailing="" raw_val="zs" val="zs"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(46, 14)" end="(46, 15)" leading="" trailing=" " val=","/>
              <OtherNode start="(46, 16)" end="(46, 86)" kind="«term_∧_»">
                <OtherNode start="(46, 16)" end="(46, 32)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(46, 16)" end="(46, 17)" leading="" trailing="" val="("/>
                  <OtherNode start="(46, 17)" end="(46, 31)" kind="Lean.«term∀__,_»">
                    <AtomNode start="(46, 17)" end="(46, 18)" leading="" trailing=" " val="∀"/>
                    <LeanBinderidentNode start="(46, 19)" end="(46, 20)">
                      <IdentNode start="(46, 19)" end="(46, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                    </LeanBinderidentNode>
                    <OtherNode start="(46, 21)" end="(46, 25)" kind="Lean.«binderTerm∈_»">
                      <AtomNode start="(46, 21)" end="(46, 22)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(46, 23)" end="(46, 25)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(46, 25)" end="(46, 26)" leading="" trailing=" " val=","/>
                    <OtherNode start="(46, 27)" end="(46, 31)" kind="«term¬_»">
                      <AtomNode start="(46, 27)" end="(46, 28)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(46, 28)" end="(46, 31)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(46, 28)" end="(46, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(46, 30)" end="(46, 31)">
                          <IdentNode start="(46, 30)" end="(46, 31)" leading="" trailing="" raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(46, 31)" end="(46, 32)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(46, 33)" end="(46, 34)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(46, 35)" end="(46, 86)" kind="«term_∧_»">
                  <OtherNode start="(46, 35)" end="(46, 38)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(46, 35)" end="(46, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(46, 37)" end="(46, 38)">
                      <IdentNode start="(46, 37)" end="(46, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(46, 39)" end="(46, 40)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(46, 41)" end="(46, 86)" kind="«term_∧_»">
                    <OtherNode start="(46, 41)" end="(46, 61)" kind="«term_=_»">
                      <IdentNode start="(46, 41)" end="(46, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(46, 44)" end="(46, 45)" leading="" trailing=" " val="="/>
                      <OtherNode start="(46, 46)" end="(46, 61)" kind="«term_++_»">
                        <OtherNode start="(46, 46)" end="(46, 55)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(46, 46)" end="(46, 53)" leading="" trailing=" " raw_val="ys.push" val="ys.push"/>
                          <NullNode start="(46, 54)" end="(46, 55)">
                            <IdentNode start="(46, 54)" end="(46, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(46, 56)" end="(46, 58)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(46, 59)" end="(46, 61)" leading="" trailing=" " raw_val="zs" val="zs"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(46, 62)" end="(46, 63)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(46, 64)" end="(46, 86)" kind="«term_=_»">
                      <OtherNode start="(46, 64)" end="(46, 75)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(46, 64)" end="(46, 73)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                        <NullNode start="(46, 74)" end="(46, 75)">
                          <IdentNode start="(46, 74)" end="(46, 75)" leading="" trailing=" " raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(46, 76)" end="(46, 77)" leading="" trailing=" " val="="/>
                      <OtherNode start="(46, 78)" end="(46, 86)" kind="«term_++_»">
                        <IdentNode start="(46, 78)" end="(46, 80)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        <AtomNode start="(46, 81)" end="(46, 83)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(46, 84)" end="(46, 86)" leading="" trailing=" " raw_val="zs" val="zs"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(46, 87)" end="(49, 76)">
          <AtomNode start="(46, 87)" end="(46, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(46, 90)" end="(49, 76)">
            <AtomNode start="(46, 90)" end="(46, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(47, 3)" end="(49, 76)">
              <TacticTacticseq1IndentedNode start="(47, 3)" end="(49, 76)">
                <NullNode start="(47, 3)" end="(49, 76)">
                  <OtherNode start="(47, 3)" end="(47, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;a : α&#10;hm : a ∈ xs&#10;hp : p a = true&#10;⊢ ∃ a ys zs, (∀ (b : α), b ∈ ys → ¬p b = true) ∧ p a = true ∧ xs = ys.push a ++ zs ∧ xs.eraseP p = ys ++ zs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;hp : p a = true&#10;xs : List α&#10;hm : a ∈ { toList := xs }&#10;⊢ ∃ a ys zs,&#10;    (∀ (b : α), b ∈ ys → ¬p b = true) ∧&#10;      p a = true ∧ { toList := xs } = ys.push a ++ zs ∧ { toList := xs }.eraseP p = ys ++ zs" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(47, 3)" end="(47, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(47, 10)" end="(47, 12)">
                      <OtherNode start="(47, 10)" end="(47, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(47, 10)" end="(47, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(47, 13)" end="(47, 22)">
                      <AtomNode start="(47, 13)" end="(47, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(47, 18)" end="(47, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(47, 18)" end="(47, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(47, 18)" end="(47, 22)">
                            <OtherNode start="(47, 18)" end="(47, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(47, 18)" end="(47, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(47, 19)" end="(47, 21)">
                                <OtherNode start="(47, 19)" end="(47, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(47, 19)" end="(47, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(47, 19)" end="(47, 21)">
                                      <OtherNode start="(47, 19)" end="(47, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(47, 19)" end="(47, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(47, 21)" end="(47, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(48, 3)" end="(48, 88)" kind="Lean.Parser.Tactic.obtain" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;hp : p a = true&#10;xs : List α&#10;hm : a ∈ { toList := xs }&#10;⊢ ∃ a ys zs,&#10;    (∀ (b : α), b ∈ ys → ¬p b = true) ∧&#10;      p a = true ∧ { toList := xs } = ys.push a ++ zs ∧ { toList := xs }.eraseP p = ys ++ zs" state_after="case mk.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;hp : p a✝ = true&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;hm : a✝ ∈ { toList := l₁ ++ a :: l₂ }&#10;h₃ : List.eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ∃ a_1 ys zs,&#10;    (∀ (b : α), b ∈ ys → ¬p b = true) ∧&#10;      p a_1 = true ∧ { toList := l₁ ++ a :: l₂ } = ys.push a_1 ++ zs ∧ { toList := l₁ ++ a :: l₂ }.eraseP p = ys ++ zs" tactic="obtain ⟨a, l₁, l₂, h₁, h₂, rfl, h₃⟩ := List.exists_of_eraseP (by simpa using hm) (hp)">
                    <AtomNode start="(48, 3)" end="(48, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(48, 10)" end="(48, 38)">
                      <OtherNode start="(48, 10)" end="(48, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(48, 10)" end="(48, 38)">
                          <OtherNode start="(48, 10)" end="(48, 38)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(48, 10)" end="(48, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(48, 11)" end="(48, 37)">
                              <OtherNode start="(48, 11)" end="(48, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(48, 11)" end="(48, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(48, 11)" end="(48, 12)">
                                    <OtherNode start="(48, 11)" end="(48, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(48, 11)" end="(48, 12)" leading="" trailing="" raw_val="a" val="a"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(48, 12)" end="(48, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(48, 14)" end="(48, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(48, 14)" end="(48, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(48, 14)" end="(48, 16)">
                                    <OtherNode start="(48, 14)" end="(48, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(48, 14)" end="(48, 16)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(48, 16)" end="(48, 17)" leading="" trailing=" " val=","/>
                              <OtherNode start="(48, 18)" end="(48, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(48, 18)" end="(48, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(48, 18)" end="(48, 20)">
                                    <OtherNode start="(48, 18)" end="(48, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(48, 18)" end="(48, 20)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(48, 20)" end="(48, 21)" leading="" trailing=" " val=","/>
                              <OtherNode start="(48, 22)" end="(48, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(48, 22)" end="(48, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(48, 22)" end="(48, 24)">
                                    <OtherNode start="(48, 22)" end="(48, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(48, 22)" end="(48, 24)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(48, 24)" end="(48, 25)" leading="" trailing=" " val=","/>
                              <OtherNode start="(48, 26)" end="(48, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(48, 26)" end="(48, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(48, 26)" end="(48, 28)">
                                    <OtherNode start="(48, 26)" end="(48, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(48, 26)" end="(48, 28)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(48, 28)" end="(48, 29)" leading="" trailing=" " val=","/>
                              <OtherNode start="(48, 30)" end="(48, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(48, 30)" end="(48, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(48, 30)" end="(48, 33)">
                                    <OtherNode start="(48, 30)" end="(48, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(48, 30)" end="(48, 33)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(48, 33)" end="(48, 34)" leading="" trailing=" " val=","/>
                              <OtherNode start="(48, 35)" end="(48, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(48, 35)" end="(48, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(48, 35)" end="(48, 37)">
                                    <OtherNode start="(48, 35)" end="(48, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(48, 35)" end="(48, 37)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(48, 37)" end="(48, 38)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(48, 39)" end="(48, 88)">
                      <AtomNode start="(48, 39)" end="(48, 41)" leading="" trailing=" " val=":="/>
                      <NullNode start="(48, 42)" end="(48, 88)">
                        <OtherNode start="(48, 42)" end="(48, 88)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(48, 42)" end="(48, 63)" leading="" trailing=" " raw_val="List.exists_of_eraseP" val="List.exists_of_eraseP" full_name="List.exists_of_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(48, 64)" end="(48, 88)">
                            <OtherNode start="(48, 64)" end="(48, 83)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(48, 64)" end="(48, 65)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(48, 65)" end="(48, 82)">
                                <AtomNode start="(48, 65)" end="(48, 67)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(48, 68)" end="(48, 82)">
                                  <TacticTacticseq1IndentedNode start="(48, 68)" end="(48, 82)">
                                    <NullNode start="(48, 68)" end="(48, 82)">
                                      <OtherNode start="(48, 68)" end="(48, 82)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;hp : p a = true&#10;xs : List α&#10;hm : a ∈ { toList := xs }&#10;⊢ a ∈ ?m.4249" state_after="no goals" tactic="simpa using hm">
                                        <AtomNode start="(48, 68)" end="(48, 73)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(48, 74)" end="(48, 82)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(48, 74)" end="(48, 82)">
                                            <AtomNode start="(48, 74)" end="(48, 79)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(48, 80)" end="(48, 82)" leading="" trailing="" raw_val="hm" val="hm"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(48, 82)" end="(48, 83)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(48, 84)" end="(48, 88)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(48, 84)" end="(48, 85)" leading="" trailing="" val="("/>
                              <IdentNode start="(48, 85)" end="(48, 87)" leading="" trailing="" raw_val="hp" val="hp"/>
                              <AtomNode start="(48, 87)" end="(48, 88)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(49, 3)" end="(49, 76)" kind="Lean.Parser.Tactic.refine" state_before="case mk.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;hp : p a✝ = true&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;hm : a✝ ∈ { toList := l₁ ++ a :: l₂ }&#10;h₃ : List.eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ∃ a_1 ys zs,&#10;    (∀ (b : α), b ∈ ys → ¬p b = true) ∧&#10;      p a_1 = true ∧ { toList := l₁ ++ a :: l₂ } = ys.push a_1 ++ zs ∧ { toList := l₁ ++ a :: l₂ }.eraseP p = ys ++ zs" state_after="no goals" tactic="refine ⟨a, ⟨l₁⟩, ⟨l₂⟩, by simpa using h₁, h₂, by simp, by simpa using h₃⟩">
                    <AtomNode start="(49, 3)" end="(49, 9)" leading="" trailing=" " val="refine"/>
                    <OtherNode start="(49, 10)" end="(49, 76)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(49, 10)" end="(49, 11)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(49, 11)" end="(49, 75)">
                        <IdentNode start="(49, 11)" end="(49, 12)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(49, 12)" end="(49, 13)" leading="" trailing=" " val=","/>
                        <OtherNode start="(49, 14)" end="(49, 18)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(49, 14)" end="(49, 15)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(49, 15)" end="(49, 17)">
                            <IdentNode start="(49, 15)" end="(49, 17)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          </NullNode>
                          <AtomNode start="(49, 17)" end="(49, 18)" leading="" trailing="" val="⟩"/>
                        </OtherNode>
                        <AtomNode start="(49, 18)" end="(49, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(49, 20)" end="(49, 24)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(49, 20)" end="(49, 21)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(49, 21)" end="(49, 23)">
                            <IdentNode start="(49, 21)" end="(49, 23)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                          </NullNode>
                          <AtomNode start="(49, 23)" end="(49, 24)" leading="" trailing="" val="⟩"/>
                        </OtherNode>
                        <AtomNode start="(49, 24)" end="(49, 25)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(49, 26)" end="(49, 43)">
                          <AtomNode start="(49, 26)" end="(49, 28)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(49, 29)" end="(49, 43)">
                            <TacticTacticseq1IndentedNode start="(49, 29)" end="(49, 43)">
                              <NullNode start="(49, 29)" end="(49, 43)">
                                <OtherNode start="(49, 29)" end="(49, 43)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;hp : p a✝ = true&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;hm : a✝ ∈ { toList := l₁ ++ a :: l₂ }&#10;h₃ : List.eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ∀ (b : α), b ∈ { toList := l₁ } → ¬p b = true" state_after="no goals" tactic="simpa using h₁">
                                  <AtomNode start="(49, 29)" end="(49, 34)" leading="" trailing=" " val="simpa"/>
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(49, 35)" end="(49, 43)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(49, 35)" end="(49, 43)">
                                      <AtomNode start="(49, 35)" end="(49, 40)" leading="" trailing=" " val="using"/>
                                      <IdentNode start="(49, 41)" end="(49, 43)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(49, 43)" end="(49, 44)" leading="" trailing=" " val=","/>
                        <IdentNode start="(49, 45)" end="(49, 47)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                        <AtomNode start="(49, 47)" end="(49, 48)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(49, 49)" end="(49, 56)">
                          <AtomNode start="(49, 49)" end="(49, 51)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(49, 52)" end="(49, 56)">
                            <TacticTacticseq1IndentedNode start="(49, 52)" end="(49, 56)">
                              <NullNode start="(49, 52)" end="(49, 56)">
                                <OtherNode start="(49, 52)" end="(49, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;hp : p a✝ = true&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;hm : a✝ ∈ { toList := l₁ ++ a :: l₂ }&#10;h₃ : List.eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ { toList := l₁ ++ a :: l₂ } = { toList := l₁ }.push a ++ { toList := l₂ }" state_after="no goals" tactic="simp">
                                  <AtomNode start="(49, 52)" end="(49, 56)" leading="" trailing="" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(49, 56)" end="(49, 57)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(49, 58)" end="(49, 75)">
                          <AtomNode start="(49, 58)" end="(49, 60)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(49, 61)" end="(49, 75)">
                            <TacticTacticseq1IndentedNode start="(49, 61)" end="(49, 75)">
                              <NullNode start="(49, 61)" end="(49, 75)">
                                <OtherNode start="(49, 61)" end="(49, 75)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;hp : p a✝ = true&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;hm : a✝ ∈ { toList := l₁ ++ a :: l₂ }&#10;h₃ : List.eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ { toList := l₁ ++ a :: l₂ }.eraseP p = { toList := l₁ } ++ { toList := l₂ }" state_after="no goals" tactic="simpa using h₃">
                                  <AtomNode start="(49, 61)" end="(49, 66)" leading="" trailing=" " val="simpa"/>
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(49, 67)" end="(49, 75)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(49, 67)" end="(49, 75)">
                                      <AtomNode start="(49, 67)" end="(49, 72)" leading="" trailing=" " val="using"/>
                                      <IdentNode start="(49, 73)" end="(49, 75)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                      <AtomNode start="(49, 75)" end="(49, 76)" leading="" trailing="&#10;&#10;-- The arguments are explicit here, so this lemma can be used as a case split.&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(52, 1)" end="(59, 50)" name="exists_or_eq_self_of_eraseP" full_name="Array.exists_or_eq_self_of_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(52, 1)" end="(59, 50)" name="exists_or_eq_self_of_eraseP" full_name="Array.exists_or_eq_self_of_eraseP" _is_private_decl="False">
        <AtomNode start="(52, 1)" end="(52, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(52, 9)" end="(52, 36)">
          <IdentNode start="(52, 9)" end="(52, 36)" leading="" trailing=" " raw_val="exists_or_eq_self_of_eraseP" val="exists_or_eq_self_of_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(52, 37)" end="(54, 86)">
          <NullNode start="(52, 37)" end="(52, 55)">
            <TermExplicitbinderNode start="(52, 37)" end="(52, 40)">
              <AtomNode start="(52, 37)" end="(52, 38)" leading="" trailing="" val="("/>
              <NullNode start="(52, 38)" end="(52, 39)">
                <IdentNode start="(52, 38)" end="(52, 39)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(52, 39)" end="(52, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(52, 41)" end="(52, 55)">
              <AtomNode start="(52, 41)" end="(52, 42)" leading="" trailing="" val="("/>
              <NullNode start="(52, 42)" end="(52, 44)">
                <IdentNode start="(52, 42)" end="(52, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(52, 45)" end="(52, 54)">
                <AtomNode start="(52, 45)" end="(52, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(52, 47)" end="(52, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(52, 47)" end="(52, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(52, 53)" end="(52, 54)">
                    <IdentNode start="(52, 53)" end="(52, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(52, 54)" end="(52, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(52, 56)" end="(54, 86)">
            <AtomNode start="(52, 56)" end="(52, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(53, 5)" end="(54, 86)" kind="«term_∨_»">
              <OtherNode start="(53, 5)" end="(53, 21)" kind="«term_=_»">
                <OtherNode start="(53, 5)" end="(53, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(53, 5)" end="(53, 14)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(53, 15)" end="(53, 16)">
                    <IdentNode start="(53, 15)" end="(53, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(53, 17)" end="(53, 18)" leading="" trailing=" " val="="/>
                <IdentNode start="(53, 19)" end="(53, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
              <AtomNode start="(53, 22)" end="(53, 23)" leading="" trailing="&#10;    " val="∨"/>
              <OtherNode start="(54, 5)" end="(54, 86)" kind="«term∃_,_»">
                <AtomNode start="(54, 5)" end="(54, 6)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(54, 7)" end="(54, 14)" kind="Lean.explicitBinders">
                  <OtherNode start="(54, 7)" end="(54, 14)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(54, 7)" end="(54, 14)">
                      <LeanBinderidentNode start="(54, 7)" end="(54, 8)">
                        <IdentNode start="(54, 7)" end="(54, 8)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(54, 9)" end="(54, 11)">
                        <IdentNode start="(54, 9)" end="(54, 11)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(54, 12)" end="(54, 14)">
                        <IdentNode start="(54, 12)" end="(54, 14)" leading="" trailing="" raw_val="zs" val="zs"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(54, 14)" end="(54, 15)" leading="" trailing=" " val=","/>
                <OtherNode start="(54, 16)" end="(54, 86)" kind="«term_∧_»">
                  <OtherNode start="(54, 16)" end="(54, 32)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(54, 16)" end="(54, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(54, 17)" end="(54, 31)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(54, 17)" end="(54, 18)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(54, 19)" end="(54, 20)">
                        <IdentNode start="(54, 19)" end="(54, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(54, 21)" end="(54, 25)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(54, 21)" end="(54, 22)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(54, 23)" end="(54, 25)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </OtherNode>
                      <AtomNode start="(54, 25)" end="(54, 26)" leading="" trailing=" " val=","/>
                      <OtherNode start="(54, 27)" end="(54, 31)" kind="«term¬_»">
                        <AtomNode start="(54, 27)" end="(54, 28)" leading="" trailing="" val="¬"/>
                        <OtherNode start="(54, 28)" end="(54, 31)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(54, 28)" end="(54, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(54, 30)" end="(54, 31)">
                            <IdentNode start="(54, 30)" end="(54, 31)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(54, 31)" end="(54, 32)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(54, 33)" end="(54, 34)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(54, 35)" end="(54, 86)" kind="«term_∧_»">
                    <OtherNode start="(54, 35)" end="(54, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(54, 35)" end="(54, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(54, 37)" end="(54, 38)">
                        <IdentNode start="(54, 37)" end="(54, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(54, 39)" end="(54, 40)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(54, 41)" end="(54, 86)" kind="«term_∧_»">
                      <OtherNode start="(54, 41)" end="(54, 61)" kind="«term_=_»">
                        <IdentNode start="(54, 41)" end="(54, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <AtomNode start="(54, 44)" end="(54, 45)" leading="" trailing=" " val="="/>
                        <OtherNode start="(54, 46)" end="(54, 61)" kind="«term_++_»">
                          <OtherNode start="(54, 46)" end="(54, 55)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(54, 46)" end="(54, 53)" leading="" trailing=" " raw_val="ys.push" val="ys.push"/>
                            <NullNode start="(54, 54)" end="(54, 55)">
                              <IdentNode start="(54, 54)" end="(54, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(54, 56)" end="(54, 58)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(54, 59)" end="(54, 61)" leading="" trailing=" " raw_val="zs" val="zs"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(54, 62)" end="(54, 63)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(54, 64)" end="(54, 86)" kind="«term_=_»">
                        <OtherNode start="(54, 64)" end="(54, 75)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(54, 64)" end="(54, 73)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                          <NullNode start="(54, 74)" end="(54, 75)">
                            <IdentNode start="(54, 74)" end="(54, 75)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(54, 76)" end="(54, 77)" leading="" trailing=" " val="="/>
                        <OtherNode start="(54, 78)" end="(54, 86)" kind="«term_++_»">
                          <IdentNode start="(54, 78)" end="(54, 80)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          <AtomNode start="(54, 81)" end="(54, 83)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(54, 84)" end="(54, 86)" leading="" trailing=" " raw_val="zs" val="zs"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(54, 87)" end="(59, 50)">
          <AtomNode start="(54, 87)" end="(54, 89)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(55, 3)" end="(59, 50)" kind="termDepIfThenElse">
            <AtomNode start="(55, 3)" end="(55, 5)" leading="" trailing=" " val="if"/>
            <LeanBinderidentNode start="(55, 6)" end="(55, 7)">
              <IdentNode start="(55, 6)" end="(55, 7)" leading="" trailing=" " raw_val="h" val="h"/>
            </LeanBinderidentNode>
            <AtomNode start="(55, 8)" end="(55, 9)" leading="" trailing=" " val=":"/>
            <OtherNode start="(55, 10)" end="(55, 23)" kind="Lean.«term∃__,_»">
              <AtomNode start="(55, 10)" end="(55, 11)" leading="" trailing=" " val="∃"/>
              <LeanBinderidentNode start="(55, 12)" end="(55, 13)">
                <IdentNode start="(55, 12)" end="(55, 13)" leading="" trailing=" " raw_val="a" val="a"/>
              </LeanBinderidentNode>
              <OtherNode start="(55, 14)" end="(55, 18)" kind="Lean.«binderTerm∈_»">
                <AtomNode start="(55, 14)" end="(55, 15)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(55, 16)" end="(55, 18)" leading="" trailing="" raw_val="xs" val="xs"/>
              </OtherNode>
              <AtomNode start="(55, 18)" end="(55, 19)" leading="" trailing=" " val=","/>
              <OtherNode start="(55, 20)" end="(55, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(55, 20)" end="(55, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                <NullNode start="(55, 22)" end="(55, 23)">
                  <IdentNode start="(55, 22)" end="(55, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(55, 24)" end="(55, 28)" leading="" trailing="&#10;    " val="then"/>
            <OtherNode start="(56, 5)" end="(57, 34)" kind="Lean.Parser.Term.let">
              <AtomNode start="(56, 5)" end="(56, 8)" leading="" trailing=" " val="let"/>
              <OtherNode start="(56, 9)" end="(56, 25)" kind="Lean.Parser.Term.letDecl">
                <OtherNode start="(56, 9)" end="(56, 25)" kind="Lean.Parser.Term.letPatDecl">
                  <OtherNode start="(56, 9)" end="(56, 20)" kind="Lean.Parser.Term.anonymousCtor">
                    <AtomNode start="(56, 9)" end="(56, 10)" leading="" trailing="" val="⟨"/>
                    <NullNode start="(56, 10)" end="(56, 19)">
                      <TermHoleNode start="(56, 10)" end="(56, 11)">
                        <AtomNode start="(56, 10)" end="(56, 11)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(56, 11)" end="(56, 12)" leading="" trailing=" " val=","/>
                      <IdentNode start="(56, 13)" end="(56, 15)" leading="" trailing="" raw_val="ha" val="ha"/>
                      <AtomNode start="(56, 15)" end="(56, 16)" leading="" trailing=" " val=","/>
                      <IdentNode start="(56, 17)" end="(56, 19)" leading="" trailing="" raw_val="pa" val="pa"/>
                    </NullNode>
                    <AtomNode start="(56, 19)" end="(56, 20)" leading="" trailing=" " val="⟩"/>
                  </OtherNode>
                  <NullNode/>
                  <NullNode/>
                  <AtomNode start="(56, 21)" end="(56, 23)" leading="" trailing=" " val=":="/>
                  <IdentNode start="(56, 24)" end="(56, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                </OtherNode>
              </OtherNode>
              <NullNode/>
              <OtherNode start="(57, 5)" end="(57, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(57, 5)" end="(57, 9)" kind="Lean.Parser.Term.dotIdent">
                  <AtomNode start="(57, 5)" end="(57, 6)" leading="" trailing="" val="."/>
                  <IdentNode start="(57, 6)" end="(57, 9)" leading="" trailing=" " raw_val="inr" val="inr"/>
                </OtherNode>
                <NullNode start="(57, 10)" end="(57, 34)">
                  <OtherNode start="(57, 10)" end="(57, 34)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(57, 10)" end="(57, 11)" leading="" trailing="" val="("/>
                    <OtherNode start="(57, 11)" end="(57, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(57, 11)" end="(57, 27)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP" full_name="Array.exists_of_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(45, 9)" def_end="(45, 25)"/>
                      <NullNode start="(57, 28)" end="(57, 33)">
                        <IdentNode start="(57, 28)" end="(57, 30)" leading="" trailing=" " raw_val="ha" val="ha"/>
                        <IdentNode start="(57, 31)" end="(57, 33)" leading="" trailing="" raw_val="pa" val="pa"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(57, 33)" end="(57, 34)" leading="" trailing="&#10;  " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(58, 3)" end="(58, 7)" leading="" trailing="&#10;    " val="else"/>
            <OtherNode start="(59, 5)" end="(59, 50)" kind="Lean.Parser.Term.app">
              <OtherNode start="(59, 5)" end="(59, 9)" kind="Lean.Parser.Term.dotIdent">
                <AtomNode start="(59, 5)" end="(59, 6)" leading="" trailing="" val="."/>
                <IdentNode start="(59, 6)" end="(59, 9)" leading="" trailing=" " raw_val="inl" val="inl"/>
              </OtherNode>
              <NullNode start="(59, 10)" end="(59, 50)">
                <OtherNode start="(59, 10)" end="(59, 50)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(59, 10)" end="(59, 11)" leading="" trailing="" val="("/>
                  <OtherNode start="(59, 11)" end="(59, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(59, 11)" end="(59, 35)" leading="" trailing=" " raw_val="eraseP_of_forall_mem_not" val="eraseP_of_forall_mem_not" full_name="Array.eraseP_of_forall_mem_not" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(28, 9)" def_end="(28, 33)"/>
                    <NullNode start="(59, 36)" end="(59, 49)">
                      <OtherNode start="(59, 36)" end="(59, 49)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(59, 36)" end="(59, 37)" leading="" trailing="" val="("/>
                        <OtherNode start="(59, 37)" end="(59, 48)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(59, 37)" end="(59, 38)" leading="" trailing=" " raw_val="h" val="h"/>
                          <NullNode start="(59, 39)" end="(59, 48)">
                            <OtherNode start="(59, 39)" end="(59, 48)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(59, 39)" end="(59, 40)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(59, 40)" end="(59, 47)">
                                <OtherNode start="(59, 40)" end="(59, 41)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(59, 40)" end="(59, 41)" leading="" trailing="" val="·"/>
                                </OtherNode>
                                <AtomNode start="(59, 41)" end="(59, 42)" leading="" trailing=" " val=","/>
                                <OtherNode start="(59, 43)" end="(59, 44)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(59, 43)" end="(59, 44)" leading="" trailing="" val="·"/>
                                </OtherNode>
                                <AtomNode start="(59, 44)" end="(59, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(59, 46)" end="(59, 47)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(59, 46)" end="(59, 47)" leading="" trailing="" val="·"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(59, 47)" end="(59, 48)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(59, 48)" end="(59, 49)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(59, 49)" end="(59, 50)" leading="" trailing="&#10;&#10;" val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(61, 1)" end="(64, 34)" name="size_eraseP_of_mem" full_name="Array.size_eraseP_of_mem">
      <CommandDeclmodifiersNode start="(61, 1)" end="(61, 8)">
        <NullNode/>
        <NullNode start="(61, 1)" end="(61, 8)">
          <OtherNode start="(61, 1)" end="(61, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(61, 1)" end="(61, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(61, 3)" end="(61, 7)">
              <OtherNode start="(61, 3)" end="(61, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(61, 3)" end="(61, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(61, 3)" end="(61, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(61, 7)" end="(61, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(61, 9)" end="(64, 34)" name="size_eraseP_of_mem" full_name="Array.size_eraseP_of_mem" _is_private_decl="False">
        <AtomNode start="(61, 9)" end="(61, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(61, 17)" end="(61, 35)">
          <IdentNode start="(61, 17)" end="(61, 35)" leading="" trailing=" " raw_val="size_eraseP_of_mem" val="size_eraseP_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(61, 36)" end="(62, 37)">
          <NullNode start="(61, 36)" end="(61, 75)">
            <OtherNode start="(61, 36)" end="(61, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 36)" end="(61, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 37)" end="(61, 39)">
                <IdentNode start="(61, 37)" end="(61, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(61, 40)" end="(61, 49)">
                <AtomNode start="(61, 40)" end="(61, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 42)" end="(61, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 42)" end="(61, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(61, 48)" end="(61, 49)">
                    <IdentNode start="(61, 48)" end="(61, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(61, 49)" end="(61, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(61, 51)" end="(61, 64)">
              <AtomNode start="(61, 51)" end="(61, 52)" leading="" trailing="" val="("/>
              <NullNode start="(61, 52)" end="(61, 54)">
                <IdentNode start="(61, 52)" end="(61, 54)" leading="" trailing=" " raw_val="al" val="al"/>
              </NullNode>
              <NullNode start="(61, 55)" end="(61, 63)">
                <AtomNode start="(61, 55)" end="(61, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 57)" end="(61, 63)" kind="«term_∈_»">
                  <IdentNode start="(61, 57)" end="(61, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(61, 59)" end="(61, 60)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(61, 61)" end="(61, 63)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(61, 63)" end="(61, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(61, 65)" end="(61, 75)">
              <AtomNode start="(61, 65)" end="(61, 66)" leading="" trailing="" val="("/>
              <NullNode start="(61, 66)" end="(61, 68)">
                <IdentNode start="(61, 66)" end="(61, 68)" leading="" trailing=" " raw_val="pa" val="pa"/>
              </NullNode>
              <NullNode start="(61, 69)" end="(61, 74)">
                <AtomNode start="(61, 69)" end="(61, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 71)" end="(61, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 71)" end="(61, 72)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(61, 73)" end="(61, 74)">
                    <IdentNode start="(61, 73)" end="(61, 74)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(61, 74)" end="(61, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(61, 76)" end="(62, 37)">
            <AtomNode start="(61, 76)" end="(61, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(62, 5)" end="(62, 37)" kind="«term_=_»">
              <OtherNode start="(62, 5)" end="(62, 23)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(62, 5)" end="(62, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(62, 5)" end="(62, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(62, 6)" end="(62, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(62, 6)" end="(62, 15)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                    <NullNode start="(62, 16)" end="(62, 17)">
                      <IdentNode start="(62, 16)" end="(62, 17)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(62, 17)" end="(62, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(62, 18)" end="(62, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(62, 19)" end="(62, 23)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(62, 24)" end="(62, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(62, 26)" end="(62, 37)" kind="«term_-_»">
                <IdentNode start="(62, 26)" end="(62, 33)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                <AtomNode start="(62, 34)" end="(62, 35)" leading="" trailing=" " val="-"/>
                <OtherNode start="(62, 36)" end="(62, 37)" kind="num">
                  <AtomNode start="(62, 36)" end="(62, 37)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(62, 38)" end="(64, 34)">
          <AtomNode start="(62, 38)" end="(62, 40)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(62, 41)" end="(64, 34)">
            <AtomNode start="(62, 41)" end="(62, 43)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(63, 3)" end="(64, 34)">
              <TacticTacticseq1IndentedNode start="(63, 3)" end="(64, 34)">
                <NullNode start="(63, 3)" end="(64, 34)">
                  <OtherNode start="(63, 3)" end="(63, 58)" kind="Lean.Parser.Tactic.tacticLet_" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;al : a ∈ xs&#10;pa : p a = true&#10;⊢ (xs.eraseP p).size = xs.size - 1" state_after="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;al : a ∈ xs&#10;pa : p a = true&#10;w✝ : α&#10;ys zs : Array α&#10;left✝¹ : ∀ (b : α), b ∈ ys → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : xs = ys.push w✝ ++ zs&#10;e₂ : xs.eraseP p = ys ++ zs&#10;⊢ (xs.eraseP p).size = xs.size - 1" tactic="let ⟨_, ys, zs, _, _, e₁, e₂⟩ := exists_of_eraseP al pa">
                    <AtomNode start="(63, 3)" end="(63, 6)" leading="" trailing=" " val="let"/>
                    <OtherNode start="(63, 7)" end="(63, 58)" kind="Lean.Parser.Term.letDecl">
                      <OtherNode start="(63, 7)" end="(63, 58)" kind="Lean.Parser.Term.letPatDecl">
                        <OtherNode start="(63, 7)" end="(63, 32)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(63, 7)" end="(63, 8)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(63, 8)" end="(63, 31)">
                            <TermHoleNode start="(63, 8)" end="(63, 9)">
                              <AtomNode start="(63, 8)" end="(63, 9)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(63, 9)" end="(63, 10)" leading="" trailing=" " val=","/>
                            <IdentNode start="(63, 11)" end="(63, 13)" leading="" trailing="" raw_val="ys" val="ys"/>
                            <AtomNode start="(63, 13)" end="(63, 14)" leading="" trailing=" " val=","/>
                            <IdentNode start="(63, 15)" end="(63, 17)" leading="" trailing="" raw_val="zs" val="zs"/>
                            <AtomNode start="(63, 17)" end="(63, 18)" leading="" trailing=" " val=","/>
                            <TermHoleNode start="(63, 19)" end="(63, 20)">
                              <AtomNode start="(63, 19)" end="(63, 20)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(63, 20)" end="(63, 21)" leading="" trailing=" " val=","/>
                            <TermHoleNode start="(63, 22)" end="(63, 23)">
                              <AtomNode start="(63, 22)" end="(63, 23)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(63, 23)" end="(63, 24)" leading="" trailing=" " val=","/>
                            <IdentNode start="(63, 25)" end="(63, 27)" leading="" trailing="" raw_val="e₁" val="e₁"/>
                            <AtomNode start="(63, 27)" end="(63, 28)" leading="" trailing=" " val=","/>
                            <IdentNode start="(63, 29)" end="(63, 31)" leading="" trailing="" raw_val="e₂" val="e₂"/>
                          </NullNode>
                          <AtomNode start="(63, 31)" end="(63, 32)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(63, 33)" end="(63, 35)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(63, 36)" end="(63, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(63, 36)" end="(63, 52)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP" full_name="Array.exists_of_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(45, 9)" def_end="(45, 25)"/>
                          <NullNode start="(63, 53)" end="(63, 58)">
                            <IdentNode start="(63, 53)" end="(63, 55)" leading="" trailing=" " raw_val="al" val="al"/>
                            <IdentNode start="(63, 56)" end="(63, 58)" leading="" trailing="&#10;  " raw_val="pa" val="pa"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(64, 3)" end="(64, 10)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;al : a ∈ xs&#10;pa : p a = true&#10;w✝ : α&#10;ys zs : Array α&#10;left✝¹ : ∀ (b : α), b ∈ ys → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : xs = ys.push w✝ ++ zs&#10;e₂ : xs.eraseP p = ys ++ zs&#10;⊢ (xs.eraseP p).size = xs.size - 1" state_after="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;al : a ∈ xs&#10;pa : p a = true&#10;w✝ : α&#10;ys zs : Array α&#10;left✝¹ : ∀ (b : α), b ∈ ys → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : xs = ys.push w✝ ++ zs&#10;e₂ : xs.eraseP p = ys ++ zs&#10;⊢ (ys ++ zs).size = xs.size - 1" tactic="rw [e₂]">
                    <AtomNode start="(64, 3)" end="(64, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(64, 6)" end="(64, 10)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(64, 6)" end="(64, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(64, 7)" end="(64, 9)">
                        <OtherNode start="(64, 7)" end="(64, 9)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(64, 7)" end="(64, 9)" leading="" trailing="" raw_val="e₂" val="e₂"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(64, 9)" end="(64, 10)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(64, 10)" end="(64, 11)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(64, 12)" end="(64, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;al : a ∈ xs&#10;pa : p a = true&#10;w✝ : α&#10;ys zs : Array α&#10;left✝¹ : ∀ (b : α), b ∈ ys → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : xs = ys.push w✝ ++ zs&#10;e₂ : xs.eraseP p = ys ++ zs&#10;⊢ (ys ++ zs).size = xs.size - 1" state_after="no goals" tactic="simp [size_append, e₁]">
                    <AtomNode start="(64, 12)" end="(64, 16)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(64, 17)" end="(64, 34)">
                      <AtomNode start="(64, 17)" end="(64, 18)" leading="" trailing="" val="["/>
                      <NullNode start="(64, 18)" end="(64, 33)">
                        <OtherNode start="(64, 18)" end="(64, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(64, 18)" end="(64, 29)" leading="" trailing="" raw_val="size_append" val="size_append" full_name="Array.size_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(64, 29)" end="(64, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(64, 31)" end="(64, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(64, 31)" end="(64, 33)" leading="" trailing="" raw_val="e₁" val="e₁"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(64, 33)" end="(64, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(66, 1)" end="(73, 13)" name="size_eraseP" full_name="Array.size_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(66, 1)" end="(73, 13)" name="size_eraseP" full_name="Array.size_eraseP" _is_private_decl="False">
        <AtomNode start="(66, 1)" end="(66, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(66, 9)" end="(66, 20)">
          <IdentNode start="(66, 9)" end="(66, 20)" leading="" trailing=" " raw_val="size_eraseP" val="size_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(66, 21)" end="(66, 100)">
          <NullNode start="(66, 21)" end="(66, 35)">
            <OtherNode start="(66, 21)" end="(66, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(66, 21)" end="(66, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(66, 22)" end="(66, 24)">
                <IdentNode start="(66, 22)" end="(66, 24)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(66, 25)" end="(66, 34)">
                <AtomNode start="(66, 25)" end="(66, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(66, 27)" end="(66, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(66, 27)" end="(66, 32)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(66, 33)" end="(66, 34)">
                    <IdentNode start="(66, 33)" end="(66, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(66, 34)" end="(66, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(66, 36)" end="(66, 100)">
            <AtomNode start="(66, 36)" end="(66, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(66, 38)" end="(66, 100)" kind="«term_=_»">
              <OtherNode start="(66, 38)" end="(66, 56)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(66, 38)" end="(66, 51)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(66, 38)" end="(66, 39)" leading="" trailing="" val="("/>
                  <OtherNode start="(66, 39)" end="(66, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(66, 39)" end="(66, 48)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                    <NullNode start="(66, 49)" end="(66, 50)">
                      <IdentNode start="(66, 49)" end="(66, 50)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(66, 50)" end="(66, 51)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(66, 51)" end="(66, 52)" leading="" trailing="" val="."/>
                <IdentNode start="(66, 52)" end="(66, 56)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(66, 57)" end="(66, 58)" leading="" trailing=" " val="="/>
              <OtherNode start="(66, 59)" end="(66, 100)" kind="termIfThenElse">
                <AtomNode start="(66, 59)" end="(66, 61)" leading="" trailing=" " val="if"/>
                <OtherNode start="(66, 62)" end="(66, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(66, 62)" end="(66, 68)" leading="" trailing=" " raw_val="xs.any" val="xs.any"/>
                  <NullNode start="(66, 69)" end="(66, 70)">
                    <IdentNode start="(66, 69)" end="(66, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(66, 71)" end="(66, 75)" leading="" trailing=" " val="then"/>
                <OtherNode start="(66, 76)" end="(66, 87)" kind="«term_-_»">
                  <IdentNode start="(66, 76)" end="(66, 83)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(66, 84)" end="(66, 85)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(66, 86)" end="(66, 87)" kind="num">
                    <AtomNode start="(66, 86)" end="(66, 87)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(66, 88)" end="(66, 92)" leading="" trailing=" " val="else"/>
                <IdentNode start="(66, 93)" end="(66, 100)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(66, 101)" end="(73, 13)">
          <AtomNode start="(66, 101)" end="(66, 103)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(66, 104)" end="(73, 13)">
            <AtomNode start="(66, 104)" end="(66, 106)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(67, 3)" end="(73, 13)">
              <TacticTacticseq1IndentedNode start="(67, 3)" end="(73, 13)">
                <NullNode start="(67, 3)" end="(73, 13)">
                  <OtherNode start="(67, 3)" end="(67, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (xs.eraseP p).size = if xs.any p = true then xs.size - 1 else xs.size" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size - 1&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(67, 3)" end="(67, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(67, 3)" end="(67, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(67, 9)" end="(67, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(67, 13)" end="(67, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(67, 13)" end="(67, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(67, 22)" end="(67, 23)">
                        <LeanBinderidentNode start="(67, 22)" end="(67, 23)">
                          <IdentNode start="(67, 22)" end="(67, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(68, 3)" end="(70, 53)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size - 1&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size" tactic="· simp only [any_eq_true] at h&#10;  obtain ⟨i, h, w⟩ := h&#10;  simp [size_eraseP_of_mem (xs := xs) (by simp) w]">
                    <OtherNode start="(68, 3)" end="(68, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(68, 3)" end="(68, 4)" kind="patternIgnore">
                        <OtherNode start="(68, 3)" end="(68, 4)" kind="token.«· »">
                          <AtomNode start="(68, 3)" end="(68, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(68, 5)" end="(70, 53)">
                      <TacticTacticseq1IndentedNode start="(68, 5)" end="(70, 53)">
                        <NullNode start="(68, 5)" end="(70, 53)">
                          <OtherNode start="(68, 5)" end="(68, 33)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size - 1" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∃ i x, p xs[i] = true&#10;⊢ (xs.eraseP p).size = xs.size - 1" tactic="simp only [any_eq_true] at h">
                            <AtomNode start="(68, 5)" end="(68, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(68, 10)" end="(68, 14)">
                              <AtomNode start="(68, 10)" end="(68, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(68, 15)" end="(68, 28)">
                              <AtomNode start="(68, 15)" end="(68, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(68, 16)" end="(68, 27)">
                                <OtherNode start="(68, 16)" end="(68, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(68, 16)" end="(68, 27)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="Array.any_eq_true" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(68, 27)" end="(68, 28)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(68, 29)" end="(68, 33)">
                              <OtherNode start="(68, 29)" end="(68, 33)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(68, 29)" end="(68, 31)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(68, 32)" end="(68, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(68, 32)" end="(68, 33)">
                                    <IdentNode start="(68, 32)" end="(68, 33)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(69, 5)" end="(69, 26)" kind="Lean.Parser.Tactic.obtain" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ∃ i x, p xs[i] = true&#10;⊢ (xs.eraseP p).size = xs.size - 1" state_after="case isTrue.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;w : p xs[i] = true&#10;⊢ (xs.eraseP p).size = xs.size - 1" tactic="obtain ⟨i, h, w⟩ := h">
                            <AtomNode start="(69, 5)" end="(69, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(69, 12)" end="(69, 21)">
                              <OtherNode start="(69, 12)" end="(69, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(69, 12)" end="(69, 21)">
                                  <OtherNode start="(69, 12)" end="(69, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(69, 12)" end="(69, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(69, 13)" end="(69, 20)">
                                      <OtherNode start="(69, 13)" end="(69, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(69, 13)" end="(69, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(69, 13)" end="(69, 14)">
                                            <OtherNode start="(69, 13)" end="(69, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(69, 13)" end="(69, 14)" leading="" trailing="" raw_val="i" val="i"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(69, 14)" end="(69, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(69, 16)" end="(69, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(69, 16)" end="(69, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(69, 16)" end="(69, 17)">
                                            <OtherNode start="(69, 16)" end="(69, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(69, 16)" end="(69, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(69, 17)" end="(69, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(69, 19)" end="(69, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(69, 19)" end="(69, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(69, 19)" end="(69, 20)">
                                            <OtherNode start="(69, 19)" end="(69, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(69, 19)" end="(69, 20)" leading="" trailing="" raw_val="w" val="w"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(69, 20)" end="(69, 21)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(69, 22)" end="(69, 26)">
                              <AtomNode start="(69, 22)" end="(69, 24)" leading="" trailing=" " val=":="/>
                              <NullNode start="(69, 25)" end="(69, 26)">
                                <IdentNode start="(69, 25)" end="(69, 26)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(70, 5)" end="(70, 53)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;w : p xs[i] = true&#10;⊢ (xs.eraseP p).size = xs.size - 1" state_after="no goals" tactic="simp [size_eraseP_of_mem (xs := xs) (by simp) w]">
                            <AtomNode start="(70, 5)" end="(70, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(70, 10)" end="(70, 53)">
                              <AtomNode start="(70, 10)" end="(70, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(70, 11)" end="(70, 52)">
                                <OtherNode start="(70, 11)" end="(70, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(70, 11)" end="(70, 52)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(70, 11)" end="(70, 29)" leading="" trailing=" " raw_val="size_eraseP_of_mem" val="size_eraseP_of_mem" full_name="Array.size_eraseP_of_mem" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(61, 17)" def_end="(61, 35)"/>
                                    <NullNode start="(70, 30)" end="(70, 52)">
                                      <OtherNode start="(70, 30)" end="(70, 40)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(70, 30)" end="(70, 31)" leading="" trailing="" val="("/>
                                        <IdentNode start="(70, 31)" end="(70, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                        <AtomNode start="(70, 34)" end="(70, 36)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(70, 37)" end="(70, 39)" leading="" trailing="" raw_val="xs" val="xs"/>
                                        <AtomNode start="(70, 39)" end="(70, 40)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <OtherNode start="(70, 41)" end="(70, 50)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(70, 41)" end="(70, 42)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(70, 42)" end="(70, 49)">
                                          <AtomNode start="(70, 42)" end="(70, 44)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(70, 45)" end="(70, 49)">
                                            <TacticTacticseq1IndentedNode start="(70, 45)" end="(70, 49)">
                                              <NullNode start="(70, 45)" end="(70, 49)">
                                                <OtherNode start="(70, 45)" end="(70, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;w : p xs[i] = true&#10;⊢ xs[i] ∈ xs" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(70, 45)" end="(70, 49)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(70, 49)" end="(70, 50)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <IdentNode start="(70, 51)" end="(70, 52)" leading="" trailing="" raw_val="w" val="w"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(70, 52)" end="(70, 53)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(71, 3)" end="(73, 13)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size" state_after="no goals" tactic="· simp only [any_eq_true] at h&#10;  rw [eraseP_of_forall_getElem_not]&#10;  simp_all">
                    <OtherNode start="(71, 3)" end="(71, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(71, 3)" end="(71, 4)" kind="patternIgnore">
                        <OtherNode start="(71, 3)" end="(71, 4)" kind="token.«· »">
                          <AtomNode start="(71, 3)" end="(71, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(71, 5)" end="(73, 13)">
                      <TacticTacticseq1IndentedNode start="(71, 5)" end="(73, 13)">
                        <NullNode start="(71, 5)" end="(73, 13)">
                          <OtherNode start="(71, 5)" end="(71, 33)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬xs.any p = true&#10;⊢ (xs.eraseP p).size = xs.size" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬∃ i x, p xs[i] = true&#10;⊢ (xs.eraseP p).size = xs.size" tactic="simp only [any_eq_true] at h">
                            <AtomNode start="(71, 5)" end="(71, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(71, 10)" end="(71, 14)">
                              <AtomNode start="(71, 10)" end="(71, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(71, 15)" end="(71, 28)">
                              <AtomNode start="(71, 15)" end="(71, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(71, 16)" end="(71, 27)">
                                <OtherNode start="(71, 16)" end="(71, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(71, 16)" end="(71, 27)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="Array.any_eq_true" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(71, 27)" end="(71, 28)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(71, 29)" end="(71, 33)">
                              <OtherNode start="(71, 29)" end="(71, 33)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(71, 29)" end="(71, 31)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(71, 32)" end="(71, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(71, 32)" end="(71, 33)">
                                    <IdentNode start="(71, 32)" end="(71, 33)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(72, 5)" end="(72, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬∃ i x, p xs[i] = true&#10;⊢ (xs.eraseP p).size = xs.size" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬∃ i x, p xs[i] = true&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; xs.size), ¬p xs[i] = true" tactic="rw [eraseP_of_forall_getElem_not]">
                            <AtomNode start="(72, 5)" end="(72, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(72, 8)" end="(72, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(72, 8)" end="(72, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(72, 9)" end="(72, 37)">
                                <OtherNode start="(72, 9)" end="(72, 37)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(72, 9)" end="(72, 37)" leading="" trailing="" raw_val="eraseP_of_forall_getElem_not" val="eraseP_of_forall_getElem_not" full_name="Array.eraseP_of_forall_getElem_not" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(32, 9)" def_end="(32, 37)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(72, 37)" end="(72, 38)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(73, 5)" end="(73, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;h : ¬∃ i x, p xs[i] = true&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; xs.size), ¬p xs[i] = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(73, 5)" end="(73, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(75, 1)" end="(77, 36)" name="size_eraseP_le" full_name="Array.size_eraseP_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(75, 1)" end="(77, 36)" name="size_eraseP_le" full_name="Array.size_eraseP_le" _is_private_decl="False">
        <AtomNode start="(75, 1)" end="(75, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(75, 9)" end="(75, 23)">
          <IdentNode start="(75, 9)" end="(75, 23)" leading="" trailing=" " raw_val="size_eraseP_le" val="size_eraseP_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(75, 24)" end="(75, 69)">
          <NullNode start="(75, 24)" end="(75, 38)">
            <OtherNode start="(75, 24)" end="(75, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(75, 24)" end="(75, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(75, 25)" end="(75, 27)">
                <IdentNode start="(75, 25)" end="(75, 27)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(75, 28)" end="(75, 37)">
                <AtomNode start="(75, 28)" end="(75, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(75, 30)" end="(75, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(75, 30)" end="(75, 35)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(75, 36)" end="(75, 37)">
                    <IdentNode start="(75, 36)" end="(75, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(75, 37)" end="(75, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(75, 39)" end="(75, 69)">
            <AtomNode start="(75, 39)" end="(75, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(75, 41)" end="(75, 69)" kind="«term_≤_»">
              <OtherNode start="(75, 41)" end="(75, 59)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(75, 41)" end="(75, 54)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(75, 41)" end="(75, 42)" leading="" trailing="" val="("/>
                  <OtherNode start="(75, 42)" end="(75, 53)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(75, 42)" end="(75, 51)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                    <NullNode start="(75, 52)" end="(75, 53)">
                      <IdentNode start="(75, 52)" end="(75, 53)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(75, 53)" end="(75, 54)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(75, 54)" end="(75, 55)" leading="" trailing="" val="."/>
                <IdentNode start="(75, 55)" end="(75, 59)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(75, 60)" end="(75, 61)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(75, 62)" end="(75, 69)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(75, 70)" end="(77, 36)">
          <AtomNode start="(75, 70)" end="(75, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(75, 73)" end="(77, 36)">
            <AtomNode start="(75, 73)" end="(75, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(76, 3)" end="(77, 36)">
              <TacticTacticseq1IndentedNode start="(76, 3)" end="(77, 36)">
                <NullNode start="(76, 3)" end="(77, 36)">
                  <OtherNode start="(76, 3)" end="(76, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (xs.eraseP p).size ≤ xs.size" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ ({ toList := xs }.eraseP p).size ≤ { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(76, 3)" end="(76, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(76, 10)" end="(76, 12)">
                      <OtherNode start="(76, 10)" end="(76, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(76, 10)" end="(76, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(76, 13)" end="(76, 22)">
                      <AtomNode start="(76, 13)" end="(76, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(76, 18)" end="(76, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(76, 18)" end="(76, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(76, 18)" end="(76, 22)">
                            <OtherNode start="(76, 18)" end="(76, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(76, 18)" end="(76, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(76, 19)" end="(76, 21)">
                                <OtherNode start="(76, 19)" end="(76, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(76, 19)" end="(76, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(76, 19)" end="(76, 21)">
                                      <OtherNode start="(76, 19)" end="(76, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(76, 19)" end="(76, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(76, 21)" end="(76, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(77, 3)" end="(77, 36)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ ({ toList := xs }.eraseP p).size ≤ { toList := xs }.size" state_after="no goals" tactic="simpa using List.length_eraseP_le">
                    <AtomNode start="(77, 3)" end="(77, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(77, 9)" end="(77, 36)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(77, 9)" end="(77, 36)">
                        <AtomNode start="(77, 9)" end="(77, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(77, 15)" end="(77, 36)" leading="" trailing="&#10;&#10;" raw_val="List.length_eraseP_le" val="List.length_eraseP_le" full_name="List.length_eraseP_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(79, 1)" end="(81, 36)" name="le_size_eraseP" full_name="Array.le_size_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(79, 1)" end="(81, 36)" name="le_size_eraseP" full_name="Array.le_size_eraseP" _is_private_decl="False">
        <AtomNode start="(79, 1)" end="(79, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(79, 9)" end="(79, 23)">
          <IdentNode start="(79, 9)" end="(79, 23)" leading="" trailing=" " raw_val="le_size_eraseP" val="le_size_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(79, 24)" end="(79, 73)">
          <NullNode start="(79, 24)" end="(79, 38)">
            <OtherNode start="(79, 24)" end="(79, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(79, 24)" end="(79, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(79, 25)" end="(79, 27)">
                <IdentNode start="(79, 25)" end="(79, 27)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(79, 28)" end="(79, 37)">
                <AtomNode start="(79, 28)" end="(79, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(79, 30)" end="(79, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(79, 30)" end="(79, 35)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(79, 36)" end="(79, 37)">
                    <IdentNode start="(79, 36)" end="(79, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(79, 37)" end="(79, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(79, 39)" end="(79, 73)">
            <AtomNode start="(79, 39)" end="(79, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(79, 41)" end="(79, 73)" kind="«term_≤_»">
              <OtherNode start="(79, 41)" end="(79, 52)" kind="«term_-_»">
                <IdentNode start="(79, 41)" end="(79, 48)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                <AtomNode start="(79, 49)" end="(79, 50)" leading="" trailing=" " val="-"/>
                <OtherNode start="(79, 51)" end="(79, 52)" kind="num">
                  <AtomNode start="(79, 51)" end="(79, 52)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(79, 53)" end="(79, 54)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(79, 55)" end="(79, 73)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(79, 55)" end="(79, 68)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(79, 55)" end="(79, 56)" leading="" trailing="" val="("/>
                  <OtherNode start="(79, 56)" end="(79, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(79, 56)" end="(79, 65)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                    <NullNode start="(79, 66)" end="(79, 67)">
                      <IdentNode start="(79, 66)" end="(79, 67)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(79, 67)" end="(79, 68)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(79, 68)" end="(79, 69)" leading="" trailing="" val="."/>
                <IdentNode start="(79, 69)" end="(79, 73)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(79, 74)" end="(81, 36)">
          <AtomNode start="(79, 74)" end="(79, 76)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(79, 77)" end="(81, 36)">
            <AtomNode start="(79, 77)" end="(79, 79)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(80, 3)" end="(81, 36)">
              <TacticTacticseq1IndentedNode start="(80, 3)" end="(81, 36)">
                <NullNode start="(80, 3)" end="(81, 36)">
                  <OtherNode start="(80, 3)" end="(80, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ xs.size - 1 ≤ (xs.eraseP p).size" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ { toList := xs }.size - 1 ≤ ({ toList := xs }.eraseP p).size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(80, 3)" end="(80, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(80, 10)" end="(80, 12)">
                      <OtherNode start="(80, 10)" end="(80, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(80, 10)" end="(80, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(80, 13)" end="(80, 22)">
                      <AtomNode start="(80, 13)" end="(80, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(80, 18)" end="(80, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(80, 18)" end="(80, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(80, 18)" end="(80, 22)">
                            <OtherNode start="(80, 18)" end="(80, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(80, 18)" end="(80, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(80, 19)" end="(80, 21)">
                                <OtherNode start="(80, 19)" end="(80, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(80, 19)" end="(80, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(80, 19)" end="(80, 21)">
                                      <OtherNode start="(80, 19)" end="(80, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(80, 19)" end="(80, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(80, 21)" end="(80, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(81, 3)" end="(81, 36)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ { toList := xs }.size - 1 ≤ ({ toList := xs }.eraseP p).size" state_after="no goals" tactic="simpa using List.le_length_eraseP">
                    <AtomNode start="(81, 3)" end="(81, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(81, 9)" end="(81, 36)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(81, 9)" end="(81, 36)">
                        <AtomNode start="(81, 9)" end="(81, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(81, 15)" end="(81, 36)" leading="" trailing="&#10;&#10;" raw_val="List.le_length_eraseP" val="List.le_length_eraseP" full_name="List.le_length_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(83, 1)" end="(85, 37)" name="mem_of_mem_eraseP" full_name="Array.mem_of_mem_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(83, 1)" end="(85, 37)" name="mem_of_mem_eraseP" full_name="Array.mem_of_mem_eraseP" _is_private_decl="False">
        <AtomNode start="(83, 1)" end="(83, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(83, 9)" end="(83, 26)">
          <IdentNode start="(83, 9)" end="(83, 26)" leading="" trailing=" " raw_val="mem_of_mem_eraseP" val="mem_of_mem_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(83, 27)" end="(83, 68)">
          <NullNode start="(83, 27)" end="(83, 41)">
            <OtherNode start="(83, 27)" end="(83, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(83, 27)" end="(83, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(83, 28)" end="(83, 30)">
                <IdentNode start="(83, 28)" end="(83, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(83, 31)" end="(83, 40)">
                <AtomNode start="(83, 31)" end="(83, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(83, 33)" end="(83, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(83, 33)" end="(83, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(83, 39)" end="(83, 40)">
                    <IdentNode start="(83, 39)" end="(83, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(83, 40)" end="(83, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(83, 42)" end="(83, 68)">
            <AtomNode start="(83, 42)" end="(83, 43)" leading="" trailing=" " val=":"/>
            <OtherNode start="(83, 44)" end="(83, 68)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(83, 44)" end="(83, 59)" kind="«term_∈_»">
                <IdentNode start="(83, 44)" end="(83, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(83, 46)" end="(83, 47)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(83, 48)" end="(83, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(83, 48)" end="(83, 57)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(83, 58)" end="(83, 59)">
                    <IdentNode start="(83, 58)" end="(83, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(83, 60)" end="(83, 61)" leading="" trailing=" " val="→"/>
              <OtherNode start="(83, 62)" end="(83, 68)" kind="«term_∈_»">
                <IdentNode start="(83, 62)" end="(83, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(83, 64)" end="(83, 65)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(83, 66)" end="(83, 68)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(83, 69)" end="(85, 37)">
          <AtomNode start="(83, 69)" end="(83, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(83, 72)" end="(85, 37)">
            <AtomNode start="(83, 72)" end="(83, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(84, 3)" end="(85, 37)">
              <TacticTacticseq1IndentedNode start="(84, 3)" end="(85, 37)">
                <NullNode start="(84, 3)" end="(85, 37)">
                  <OtherNode start="(84, 3)" end="(84, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;⊢ a ∈ xs.eraseP p → a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xs : List α&#10;⊢ a ∈ { toList := xs }.eraseP p → a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(84, 3)" end="(84, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(84, 10)" end="(84, 12)">
                      <OtherNode start="(84, 10)" end="(84, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(84, 10)" end="(84, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(84, 13)" end="(84, 22)">
                      <AtomNode start="(84, 13)" end="(84, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(84, 18)" end="(84, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(84, 18)" end="(84, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(84, 18)" end="(84, 22)">
                            <OtherNode start="(84, 18)" end="(84, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(84, 18)" end="(84, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(84, 19)" end="(84, 21)">
                                <OtherNode start="(84, 19)" end="(84, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(84, 19)" end="(84, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(84, 19)" end="(84, 21)">
                                      <OtherNode start="(84, 19)" end="(84, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(84, 19)" end="(84, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(84, 21)" end="(84, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(85, 3)" end="(85, 37)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xs : List α&#10;⊢ a ∈ { toList := xs }.eraseP p → a ∈ { toList := xs }" state_after="no goals" tactic="simpa using List.mem_of_mem_eraseP">
                    <AtomNode start="(85, 3)" end="(85, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(85, 9)" end="(85, 37)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(85, 9)" end="(85, 37)">
                        <AtomNode start="(85, 9)" end="(85, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(85, 15)" end="(85, 37)" leading="" trailing="&#10;&#10;" raw_val="List.mem_of_mem_eraseP" val="List.mem_of_mem_eraseP" full_name="List.mem_of_mem_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(87, 1)" end="(89, 40)" name="mem_eraseP_of_neg" full_name="Array.mem_eraseP_of_neg">
      <CommandDeclmodifiersNode start="(87, 1)" end="(87, 8)">
        <NullNode/>
        <NullNode start="(87, 1)" end="(87, 8)">
          <OtherNode start="(87, 1)" end="(87, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(87, 1)" end="(87, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(87, 3)" end="(87, 7)">
              <OtherNode start="(87, 3)" end="(87, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(87, 3)" end="(87, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(87, 3)" end="(87, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(87, 7)" end="(87, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(87, 9)" end="(89, 40)" name="mem_eraseP_of_neg" full_name="Array.mem_eraseP_of_neg" _is_private_decl="False">
        <AtomNode start="(87, 9)" end="(87, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(87, 17)" end="(87, 34)">
          <IdentNode start="(87, 17)" end="(87, 34)" leading="" trailing=" " raw_val="mem_eraseP_of_neg" val="mem_eraseP_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(87, 35)" end="(87, 88)">
          <NullNode start="(87, 35)" end="(87, 61)">
            <OtherNode start="(87, 35)" end="(87, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(87, 35)" end="(87, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(87, 36)" end="(87, 38)">
                <IdentNode start="(87, 36)" end="(87, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(87, 39)" end="(87, 48)">
                <AtomNode start="(87, 39)" end="(87, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(87, 41)" end="(87, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(87, 41)" end="(87, 46)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(87, 47)" end="(87, 48)">
                    <IdentNode start="(87, 47)" end="(87, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(87, 48)" end="(87, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(87, 50)" end="(87, 61)">
              <AtomNode start="(87, 50)" end="(87, 51)" leading="" trailing="" val="("/>
              <NullNode start="(87, 51)" end="(87, 53)">
                <IdentNode start="(87, 51)" end="(87, 53)" leading="" trailing=" " raw_val="pa" val="pa"/>
              </NullNode>
              <NullNode start="(87, 54)" end="(87, 60)">
                <AtomNode start="(87, 54)" end="(87, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(87, 56)" end="(87, 60)" kind="«term¬_»">
                  <AtomNode start="(87, 56)" end="(87, 57)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(87, 57)" end="(87, 60)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(87, 57)" end="(87, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(87, 59)" end="(87, 60)">
                      <IdentNode start="(87, 59)" end="(87, 60)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(87, 60)" end="(87, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(87, 62)" end="(87, 88)">
            <AtomNode start="(87, 62)" end="(87, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(87, 64)" end="(87, 88)" kind="«term_↔_»">
              <OtherNode start="(87, 64)" end="(87, 79)" kind="«term_∈_»">
                <IdentNode start="(87, 64)" end="(87, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(87, 66)" end="(87, 67)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(87, 68)" end="(87, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(87, 68)" end="(87, 77)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(87, 78)" end="(87, 79)">
                    <IdentNode start="(87, 78)" end="(87, 79)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(87, 80)" end="(87, 81)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(87, 82)" end="(87, 88)" kind="«term_∈_»">
                <IdentNode start="(87, 82)" end="(87, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(87, 84)" end="(87, 85)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(87, 86)" end="(87, 88)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(87, 89)" end="(89, 40)">
          <AtomNode start="(87, 89)" end="(87, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(87, 92)" end="(89, 40)">
            <AtomNode start="(87, 92)" end="(87, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(88, 3)" end="(89, 40)">
              <TacticTacticseq1IndentedNode start="(88, 3)" end="(89, 40)">
                <NullNode start="(88, 3)" end="(89, 40)">
                  <OtherNode start="(88, 3)" end="(88, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;pa : ¬p a = true&#10;⊢ a ∈ xs.eraseP p ↔ a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : ¬p a = true&#10;xs : List α&#10;⊢ a ∈ { toList := xs }.eraseP p ↔ a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(88, 3)" end="(88, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(88, 10)" end="(88, 12)">
                      <OtherNode start="(88, 10)" end="(88, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(88, 10)" end="(88, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(88, 13)" end="(88, 22)">
                      <AtomNode start="(88, 13)" end="(88, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(88, 18)" end="(88, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(88, 18)" end="(88, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(88, 18)" end="(88, 22)">
                            <OtherNode start="(88, 18)" end="(88, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(88, 18)" end="(88, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(88, 19)" end="(88, 21)">
                                <OtherNode start="(88, 19)" end="(88, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(88, 19)" end="(88, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(88, 19)" end="(88, 21)">
                                      <OtherNode start="(88, 19)" end="(88, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(88, 19)" end="(88, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(88, 21)" end="(88, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(89, 3)" end="(89, 40)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : ¬p a = true&#10;xs : List α&#10;⊢ a ∈ { toList := xs }.eraseP p ↔ a ∈ { toList := xs }" state_after="no goals" tactic="simpa using List.mem_eraseP_of_neg pa">
                    <AtomNode start="(89, 3)" end="(89, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(89, 9)" end="(89, 40)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(89, 9)" end="(89, 40)">
                        <AtomNode start="(89, 9)" end="(89, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(89, 15)" end="(89, 40)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(89, 15)" end="(89, 37)" leading="" trailing=" " raw_val="List.mem_eraseP_of_neg" val="List.mem_eraseP_of_neg" full_name="List.mem_eraseP_of_neg" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(89, 38)" end="(89, 40)">
                            <IdentNode start="(89, 38)" end="(89, 40)" leading="" trailing="&#10;&#10;" raw_val="pa" val="pa"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(91, 1)" end="(93, 7)" name="eraseP_eq_self_iff" full_name="Array.eraseP_eq_self_iff">
      <CommandDeclmodifiersNode start="(91, 1)" end="(91, 8)">
        <NullNode/>
        <NullNode start="(91, 1)" end="(91, 8)">
          <OtherNode start="(91, 1)" end="(91, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(91, 1)" end="(91, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(91, 3)" end="(91, 7)">
              <OtherNode start="(91, 3)" end="(91, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(91, 3)" end="(91, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(91, 3)" end="(91, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(91, 7)" end="(91, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(91, 9)" end="(93, 7)" name="eraseP_eq_self_iff" full_name="Array.eraseP_eq_self_iff" _is_private_decl="False">
        <AtomNode start="(91, 9)" end="(91, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(91, 17)" end="(91, 35)">
          <IdentNode start="(91, 17)" end="(91, 35)" leading="" trailing=" " raw_val="eraseP_eq_self_iff" val="eraseP_eq_self_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(91, 36)" end="(91, 87)">
          <NullNode start="(91, 36)" end="(91, 50)">
            <OtherNode start="(91, 36)" end="(91, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(91, 36)" end="(91, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(91, 37)" end="(91, 39)">
                <IdentNode start="(91, 37)" end="(91, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(91, 40)" end="(91, 49)">
                <AtomNode start="(91, 40)" end="(91, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(91, 42)" end="(91, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(91, 42)" end="(91, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(91, 48)" end="(91, 49)">
                    <IdentNode start="(91, 48)" end="(91, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(91, 49)" end="(91, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(91, 51)" end="(91, 87)">
            <AtomNode start="(91, 51)" end="(91, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(91, 53)" end="(91, 87)" kind="«term_↔_»">
              <OtherNode start="(91, 53)" end="(91, 69)" kind="«term_=_»">
                <OtherNode start="(91, 53)" end="(91, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(91, 53)" end="(91, 62)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(91, 63)" end="(91, 64)">
                    <IdentNode start="(91, 63)" end="(91, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(91, 65)" end="(91, 66)" leading="" trailing=" " val="="/>
                <IdentNode start="(91, 67)" end="(91, 69)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
              <AtomNode start="(91, 70)" end="(91, 71)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(91, 72)" end="(91, 87)" kind="Lean.«term∀__,_»">
                <AtomNode start="(91, 72)" end="(91, 73)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(91, 74)" end="(91, 75)">
                  <IdentNode start="(91, 74)" end="(91, 75)" leading="" trailing=" " raw_val="a" val="a"/>
                </LeanBinderidentNode>
                <OtherNode start="(91, 76)" end="(91, 80)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(91, 76)" end="(91, 77)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(91, 78)" end="(91, 80)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(91, 80)" end="(91, 81)" leading="" trailing=" " val=","/>
                <OtherNode start="(91, 82)" end="(91, 87)" kind="«term¬_»">
                  <AtomNode start="(91, 82)" end="(91, 83)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(91, 84)" end="(91, 87)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(91, 84)" end="(91, 85)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(91, 86)" end="(91, 87)">
                      <IdentNode start="(91, 86)" end="(91, 87)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(91, 88)" end="(93, 7)">
          <AtomNode start="(91, 88)" end="(91, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(91, 91)" end="(93, 7)">
            <AtomNode start="(91, 91)" end="(91, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(92, 3)" end="(93, 7)">
              <TacticTacticseq1IndentedNode start="(92, 3)" end="(93, 7)">
                <NullNode start="(92, 3)" end="(93, 7)">
                  <OtherNode start="(92, 3)" end="(92, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ xs.eraseP p = xs ↔ ∀ (a : α), a ∈ xs → ¬p a = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ { toList := xs }.eraseP p = { toList := xs } ↔ ∀ (a : α), a ∈ { toList := xs } → ¬p a = true" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(92, 3)" end="(92, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(92, 10)" end="(92, 12)">
                      <OtherNode start="(92, 10)" end="(92, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(92, 10)" end="(92, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(92, 13)" end="(92, 22)">
                      <AtomNode start="(92, 13)" end="(92, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(92, 18)" end="(92, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(92, 18)" end="(92, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(92, 18)" end="(92, 22)">
                            <OtherNode start="(92, 18)" end="(92, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(92, 18)" end="(92, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(92, 19)" end="(92, 21)">
                                <OtherNode start="(92, 19)" end="(92, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(92, 19)" end="(92, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(92, 19)" end="(92, 21)">
                                      <OtherNode start="(92, 19)" end="(92, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(92, 19)" end="(92, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(92, 21)" end="(92, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(93, 3)" end="(93, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ { toList := xs }.eraseP p = { toList := xs } ↔ ∀ (a : α), a ∈ { toList := xs } → ¬p a = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(93, 3)" end="(93, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(95, 1)" end="(97, 30)" name="eraseP_map" full_name="Array.eraseP_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(95, 1)" end="(97, 30)" name="eraseP_map" full_name="Array.eraseP_map" _is_private_decl="False">
        <AtomNode start="(95, 1)" end="(95, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(95, 9)" end="(95, 19)">
          <IdentNode start="(95, 9)" end="(95, 19)" leading="" trailing=" " raw_val="eraseP_map" val="eraseP_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(95, 20)" end="(95, 96)">
          <NullNode start="(95, 20)" end="(95, 46)">
            <OtherNode start="(95, 20)" end="(95, 31)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(95, 20)" end="(95, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(95, 21)" end="(95, 22)">
                <IdentNode start="(95, 21)" end="(95, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(95, 23)" end="(95, 30)">
                <AtomNode start="(95, 23)" end="(95, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 25)" end="(95, 30)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(95, 25)" end="(95, 26)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(95, 27)" end="(95, 28)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(95, 29)" end="(95, 30)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(95, 30)" end="(95, 31)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(95, 32)" end="(95, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(95, 32)" end="(95, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(95, 33)" end="(95, 35)">
                <IdentNode start="(95, 33)" end="(95, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(95, 36)" end="(95, 45)">
                <AtomNode start="(95, 36)" end="(95, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 38)" end="(95, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(95, 38)" end="(95, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(95, 44)" end="(95, 45)">
                    <IdentNode start="(95, 44)" end="(95, 45)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(95, 45)" end="(95, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(95, 47)" end="(95, 96)">
            <AtomNode start="(95, 47)" end="(95, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(95, 49)" end="(95, 96)" kind="«term_=_»">
              <OtherNode start="(95, 49)" end="(95, 68)" kind="Lean.Parser.Term.app">
                <OtherNode start="(95, 49)" end="(95, 66)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(95, 49)" end="(95, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(95, 49)" end="(95, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(95, 50)" end="(95, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(95, 50)" end="(95, 56)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(95, 57)" end="(95, 58)">
                        <IdentNode start="(95, 57)" end="(95, 58)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(95, 58)" end="(95, 59)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(95, 59)" end="(95, 60)" leading="" trailing="" val="."/>
                  <IdentNode start="(95, 60)" end="(95, 66)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(95, 67)" end="(95, 68)">
                  <IdentNode start="(95, 67)" end="(95, 68)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(95, 69)" end="(95, 70)" leading="" trailing=" " val="="/>
              <OtherNode start="(95, 71)" end="(95, 96)" kind="Lean.Parser.Term.app">
                <OtherNode start="(95, 71)" end="(95, 94)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(95, 71)" end="(95, 90)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(95, 71)" end="(95, 72)" leading="" trailing="" val="("/>
                    <OtherNode start="(95, 72)" end="(95, 89)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(95, 72)" end="(95, 81)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                      <NullNode start="(95, 82)" end="(95, 89)">
                        <OtherNode start="(95, 82)" end="(95, 89)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(95, 82)" end="(95, 83)" leading="" trailing="" val="("/>
                          <OtherNode start="(95, 83)" end="(95, 88)" kind="«term_∘_»">
                            <IdentNode start="(95, 83)" end="(95, 84)" leading="" trailing=" " raw_val="p" val="p"/>
                            <AtomNode start="(95, 85)" end="(95, 86)" leading="" trailing=" " val="∘"/>
                            <IdentNode start="(95, 87)" end="(95, 88)" leading="" trailing="" raw_val="f" val="f"/>
                          </OtherNode>
                          <AtomNode start="(95, 88)" end="(95, 89)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(95, 89)" end="(95, 90)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(95, 90)" end="(95, 91)" leading="" trailing="" val="."/>
                  <IdentNode start="(95, 91)" end="(95, 94)" leading="" trailing=" " raw_val="map" val="map" full_name="Array.map" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(95, 95)" end="(95, 96)">
                  <IdentNode start="(95, 95)" end="(95, 96)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(95, 97)" end="(97, 30)">
          <AtomNode start="(95, 97)" end="(95, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(95, 100)" end="(97, 30)">
            <AtomNode start="(95, 100)" end="(95, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(96, 3)" end="(97, 30)">
              <TacticTacticseq1IndentedNode start="(96, 3)" end="(97, 30)">
                <NullNode start="(96, 3)" end="(97, 30)">
                  <OtherNode start="(96, 3)" end="(96, 22)" kind="Lean.Parser.Tactic.rcases" state_before="β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;xs : Array β&#10;⊢ (map f xs).eraseP p = map f (xs.eraseP (p ∘ f))" state_after="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;xs : List β&#10;⊢ (map f { toList := xs }).eraseP p = map f ({ toList := xs }.eraseP (p ∘ f))" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(96, 3)" end="(96, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(96, 10)" end="(96, 12)">
                      <OtherNode start="(96, 10)" end="(96, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(96, 10)" end="(96, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(96, 13)" end="(96, 22)">
                      <AtomNode start="(96, 13)" end="(96, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(96, 18)" end="(96, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(96, 18)" end="(96, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(96, 18)" end="(96, 22)">
                            <OtherNode start="(96, 18)" end="(96, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(96, 18)" end="(96, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(96, 19)" end="(96, 21)">
                                <OtherNode start="(96, 19)" end="(96, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(96, 19)" end="(96, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(96, 19)" end="(96, 21)">
                                      <OtherNode start="(96, 19)" end="(96, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(96, 19)" end="(96, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(96, 21)" end="(96, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(97, 3)" end="(97, 30)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;xs : List β&#10;⊢ (map f { toList := xs }).eraseP p = map f ({ toList := xs }.eraseP (p ∘ f))" state_after="no goals" tactic="simpa using List.eraseP_map">
                    <AtomNode start="(97, 3)" end="(97, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(97, 9)" end="(97, 30)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(97, 9)" end="(97, 30)">
                        <AtomNode start="(97, 9)" end="(97, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(97, 15)" end="(97, 30)" leading="" trailing="&#10;&#10;" raw_val="List.eraseP_map" val="List.eraseP_map" full_name="List.eraseP_map" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(99, 1)" end="(102, 36)" name="eraseP_filterMap" full_name="Array.eraseP_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(99, 1)" end="(102, 36)" name="eraseP_filterMap" full_name="Array.eraseP_filterMap" _is_private_decl="False">
        <AtomNode start="(99, 1)" end="(99, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(99, 9)" end="(99, 25)">
          <IdentNode start="(99, 9)" end="(99, 25)" leading="" trailing=" " raw_val="eraseP_filterMap" val="eraseP_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(99, 26)" end="(100, 114)">
          <NullNode start="(99, 26)" end="(99, 59)">
            <OtherNode start="(99, 26)" end="(99, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(99, 26)" end="(99, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(99, 27)" end="(99, 28)">
                <IdentNode start="(99, 27)" end="(99, 28)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(99, 29)" end="(99, 43)">
                <AtomNode start="(99, 29)" end="(99, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 31)" end="(99, 43)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(99, 31)" end="(99, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(99, 33)" end="(99, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(99, 35)" end="(99, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(99, 35)" end="(99, 41)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(99, 42)" end="(99, 43)">
                      <IdentNode start="(99, 42)" end="(99, 43)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(99, 43)" end="(99, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(99, 45)" end="(99, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(99, 45)" end="(99, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(99, 46)" end="(99, 48)">
                <IdentNode start="(99, 46)" end="(99, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(99, 49)" end="(99, 58)">
                <AtomNode start="(99, 49)" end="(99, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 51)" end="(99, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(99, 51)" end="(99, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(99, 57)" end="(99, 58)">
                    <IdentNode start="(99, 57)" end="(99, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(99, 58)" end="(99, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(99, 60)" end="(100, 114)">
            <AtomNode start="(99, 60)" end="(99, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(100, 5)" end="(100, 114)" kind="«term_=_»">
              <OtherNode start="(100, 5)" end="(100, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(100, 5)" end="(100, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(100, 5)" end="(100, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(100, 5)" end="(100, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(100, 6)" end="(100, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(100, 6)" end="(100, 15)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="Array.filterMap" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(100, 16)" end="(100, 20)">
                        <IdentNode start="(100, 16)" end="(100, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(100, 18)" end="(100, 20)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(100, 20)" end="(100, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(100, 21)" end="(100, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(100, 22)" end="(100, 28)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(100, 29)" end="(100, 30)">
                  <IdentNode start="(100, 29)" end="(100, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(100, 31)" end="(100, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(100, 33)" end="(100, 114)" kind="Lean.Parser.Term.app">
                <IdentNode start="(100, 33)" end="(100, 42)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="Array.filterMap" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(100, 43)" end="(100, 114)">
                  <IdentNode start="(100, 43)" end="(100, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(100, 45)" end="(100, 114)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(100, 45)" end="(100, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(100, 46)" end="(100, 113)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(100, 46)" end="(100, 55)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                      <NullNode start="(100, 56)" end="(100, 113)">
                        <OtherNode start="(100, 56)" end="(100, 113)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(100, 56)" end="(100, 57)" leading="" trailing="" val="("/>
                          <OtherNode start="(100, 57)" end="(100, 112)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(100, 57)" end="(100, 60)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(100, 61)" end="(100, 112)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(100, 61)" end="(100, 62)">
                                <IdentNode start="(100, 61)" end="(100, 62)" leading="" trailing=" " raw_val="x" val="x"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(100, 63)" end="(100, 65)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(100, 66)" end="(100, 112)" kind="Lean.Parser.Term.match">
                                <AtomNode start="(100, 66)" end="(100, 71)" leading="" trailing=" " val="match"/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(100, 72)" end="(100, 75)">
                                  <OtherNode start="(100, 72)" end="(100, 75)" kind="Lean.Parser.Term.matchDiscr">
                                    <NullNode/>
                                    <OtherNode start="(100, 72)" end="(100, 75)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(100, 72)" end="(100, 73)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(100, 74)" end="(100, 75)">
                                        <IdentNode start="(100, 74)" end="(100, 75)" leading="" trailing=" " raw_val="x" val="x"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(100, 76)" end="(100, 80)" leading="" trailing=" " val="with"/>
                                <OtherNode start="(100, 81)" end="(100, 112)" kind="Lean.Parser.Term.matchAlts">
                                  <NullNode start="(100, 81)" end="(100, 112)">
                                    <OtherNode start="(100, 81)" end="(100, 96)" kind="Lean.Parser.Term.matchAlt">
                                      <AtomNode start="(100, 81)" end="(100, 82)" leading="" trailing=" " val="|"/>
                                      <NullNode start="(100, 83)" end="(100, 89)">
                                        <NullNode start="(100, 83)" end="(100, 89)">
                                          <OtherNode start="(100, 83)" end="(100, 89)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(100, 83)" end="(100, 87)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            <NullNode start="(100, 88)" end="(100, 89)">
                                              <IdentNode start="(100, 88)" end="(100, 89)" leading="" trailing=" " raw_val="y" val="y"/>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(100, 90)" end="(100, 92)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <OtherNode start="(100, 93)" end="(100, 96)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(100, 93)" end="(100, 94)" leading="" trailing=" " raw_val="p" val="p"/>
                                        <NullNode start="(100, 95)" end="(100, 96)">
                                          <IdentNode start="(100, 95)" end="(100, 96)" leading="" trailing=" " raw_val="y" val="y"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <OtherNode start="(100, 97)" end="(100, 112)" kind="Lean.Parser.Term.matchAlt">
                                      <AtomNode start="(100, 97)" end="(100, 98)" leading="" trailing=" " val="|"/>
                                      <NullNode start="(100, 99)" end="(100, 103)">
                                        <NullNode start="(100, 99)" end="(100, 103)">
                                          <IdentNode start="(100, 99)" end="(100, 103)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(100, 104)" end="(100, 106)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <IdentNode start="(100, 107)" end="(100, 112)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(100, 112)" end="(100, 113)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(100, 113)" end="(100, 114)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(100, 115)" end="(102, 36)">
          <AtomNode start="(100, 115)" end="(100, 117)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(100, 118)" end="(102, 36)">
            <AtomNode start="(100, 118)" end="(100, 120)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(101, 3)" end="(102, 36)">
              <TacticTacticseq1IndentedNode start="(101, 3)" end="(102, 36)">
                <NullNode start="(101, 3)" end="(102, 36)">
                  <OtherNode start="(101, 3)" end="(101, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;xs : Array α&#10;⊢ (filterMap f xs).eraseP p =&#10;    filterMap f&#10;      (xs.eraseP fun x =&amp;gt;&#10;        match f x with&#10;        | some y =&amp;gt; p y&#10;        | none =&amp;gt; false)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;xs : List α&#10;⊢ (filterMap f { toList := xs }).eraseP p =&#10;    filterMap f&#10;      ({ toList := xs }.eraseP fun x =&amp;gt;&#10;        match f x with&#10;        | some y =&amp;gt; p y&#10;        | none =&amp;gt; false)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(101, 3)" end="(101, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(101, 10)" end="(101, 12)">
                      <OtherNode start="(101, 10)" end="(101, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(101, 10)" end="(101, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(101, 13)" end="(101, 22)">
                      <AtomNode start="(101, 13)" end="(101, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(101, 18)" end="(101, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(101, 18)" end="(101, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(101, 18)" end="(101, 22)">
                            <OtherNode start="(101, 18)" end="(101, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(101, 18)" end="(101, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(101, 19)" end="(101, 21)">
                                <OtherNode start="(101, 19)" end="(101, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(101, 19)" end="(101, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(101, 19)" end="(101, 21)">
                                      <OtherNode start="(101, 19)" end="(101, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(101, 19)" end="(101, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(101, 21)" end="(101, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(102, 3)" end="(102, 36)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;xs : List α&#10;⊢ (filterMap f { toList := xs }).eraseP p =&#10;    filterMap f&#10;      ({ toList := xs }.eraseP fun x =&amp;gt;&#10;        match f x with&#10;        | some y =&amp;gt; p y&#10;        | none =&amp;gt; false)" state_after="no goals" tactic="simpa using List.eraseP_filterMap">
                    <AtomNode start="(102, 3)" end="(102, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(102, 9)" end="(102, 36)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(102, 9)" end="(102, 36)">
                        <AtomNode start="(102, 9)" end="(102, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(102, 15)" end="(102, 36)" leading="" trailing="&#10;&#10;" raw_val="List.eraseP_filterMap" val="List.eraseP_filterMap" full_name="List.eraseP_filterMap" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(104, 1)" end="(107, 33)" name="eraseP_filter" full_name="Array.eraseP_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(104, 1)" end="(107, 33)" name="eraseP_filter" full_name="Array.eraseP_filter" _is_private_decl="False">
        <AtomNode start="(104, 1)" end="(104, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(104, 9)" end="(104, 22)">
          <IdentNode start="(104, 9)" end="(104, 22)" leading="" trailing=" " raw_val="eraseP_filter" val="eraseP_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(104, 23)" end="(105, 72)">
          <NullNode start="(104, 23)" end="(104, 52)">
            <OtherNode start="(104, 23)" end="(104, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(104, 23)" end="(104, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(104, 24)" end="(104, 25)">
                <IdentNode start="(104, 24)" end="(104, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(104, 26)" end="(104, 36)">
                <AtomNode start="(104, 26)" end="(104, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(104, 28)" end="(104, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(104, 28)" end="(104, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(104, 30)" end="(104, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(104, 32)" end="(104, 36)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(104, 36)" end="(104, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(104, 38)" end="(104, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(104, 38)" end="(104, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(104, 39)" end="(104, 41)">
                <IdentNode start="(104, 39)" end="(104, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(104, 42)" end="(104, 51)">
                <AtomNode start="(104, 42)" end="(104, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(104, 44)" end="(104, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(104, 44)" end="(104, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(104, 50)" end="(104, 51)">
                    <IdentNode start="(104, 50)" end="(104, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(104, 51)" end="(104, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(104, 53)" end="(105, 72)">
            <AtomNode start="(104, 53)" end="(104, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(105, 5)" end="(105, 72)" kind="«term_=_»">
              <OtherNode start="(105, 5)" end="(105, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(105, 5)" end="(105, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(105, 5)" end="(105, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(105, 5)" end="(105, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(105, 6)" end="(105, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(105, 6)" end="(105, 12)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(105, 13)" end="(105, 17)">
                        <IdentNode start="(105, 13)" end="(105, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(105, 15)" end="(105, 17)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(105, 17)" end="(105, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(105, 18)" end="(105, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(105, 19)" end="(105, 25)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(105, 26)" end="(105, 27)">
                  <IdentNode start="(105, 26)" end="(105, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(105, 28)" end="(105, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(105, 30)" end="(105, 72)" kind="Lean.Parser.Term.app">
                <IdentNode start="(105, 30)" end="(105, 36)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(105, 37)" end="(105, 72)">
                  <IdentNode start="(105, 37)" end="(105, 38)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(105, 39)" end="(105, 72)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(105, 39)" end="(105, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(105, 40)" end="(105, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(105, 40)" end="(105, 49)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                      <NullNode start="(105, 50)" end="(105, 71)">
                        <OtherNode start="(105, 50)" end="(105, 71)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(105, 50)" end="(105, 51)" leading="" trailing="" val="("/>
                          <OtherNode start="(105, 51)" end="(105, 70)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(105, 51)" end="(105, 54)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(105, 55)" end="(105, 70)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(105, 55)" end="(105, 56)">
                                <IdentNode start="(105, 55)" end="(105, 56)" leading="" trailing=" " raw_val="x" val="x"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(105, 57)" end="(105, 59)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(105, 60)" end="(105, 70)" kind="«term_&amp;amp;&amp;amp;_»">
                                <OtherNode start="(105, 60)" end="(105, 63)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(105, 60)" end="(105, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <NullNode start="(105, 62)" end="(105, 63)">
                                    <IdentNode start="(105, 62)" end="(105, 63)" leading="" trailing=" " raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(105, 64)" end="(105, 66)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                                <OtherNode start="(105, 67)" end="(105, 70)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(105, 67)" end="(105, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(105, 69)" end="(105, 70)">
                                    <IdentNode start="(105, 69)" end="(105, 70)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(105, 70)" end="(105, 71)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(105, 71)" end="(105, 72)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(105, 73)" end="(107, 33)">
          <AtomNode start="(105, 73)" end="(105, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(105, 76)" end="(107, 33)">
            <AtomNode start="(105, 76)" end="(105, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(106, 3)" end="(107, 33)">
              <TacticTacticseq1IndentedNode start="(106, 3)" end="(107, 33)">
                <NullNode start="(106, 3)" end="(107, 33)">
                  <OtherNode start="(106, 3)" end="(106, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p f : α → Bool&#10;xs : Array α&#10;⊢ (filter f xs).eraseP p = filter f (xs.eraseP fun x =&amp;gt; p x &amp;amp;&amp;amp; f x)" state_after="case mk&#10;α : Type u_1&#10;p f : α → Bool&#10;xs : List α&#10;⊢ (filter f { toList := xs }).eraseP p = filter f ({ toList := xs }.eraseP fun x =&amp;gt; p x &amp;amp;&amp;amp; f x)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(106, 3)" end="(106, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(106, 10)" end="(106, 12)">
                      <OtherNode start="(106, 10)" end="(106, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(106, 10)" end="(106, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(106, 13)" end="(106, 22)">
                      <AtomNode start="(106, 13)" end="(106, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(106, 18)" end="(106, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(106, 18)" end="(106, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(106, 18)" end="(106, 22)">
                            <OtherNode start="(106, 18)" end="(106, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(106, 18)" end="(106, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(106, 19)" end="(106, 21)">
                                <OtherNode start="(106, 19)" end="(106, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(106, 19)" end="(106, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(106, 19)" end="(106, 21)">
                                      <OtherNode start="(106, 19)" end="(106, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(106, 19)" end="(106, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(106, 21)" end="(106, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(107, 3)" end="(107, 33)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p f : α → Bool&#10;xs : List α&#10;⊢ (filter f { toList := xs }).eraseP p = filter f ({ toList := xs }.eraseP fun x =&amp;gt; p x &amp;amp;&amp;amp; f x)" state_after="no goals" tactic="simpa using List.eraseP_filter">
                    <AtomNode start="(107, 3)" end="(107, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(107, 9)" end="(107, 33)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(107, 9)" end="(107, 33)">
                        <AtomNode start="(107, 9)" end="(107, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(107, 15)" end="(107, 33)" leading="" trailing="&#10;&#10;" raw_val="List.eraseP_filter" val="List.eraseP_filter" full_name="List.eraseP_filter" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(109, 1)" end="(113, 63)" name="eraseP_append_left" full_name="Array.eraseP_append_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(109, 1)" end="(113, 63)" name="eraseP_append_left" full_name="Array.eraseP_append_left" _is_private_decl="False">
        <AtomNode start="(109, 1)" end="(109, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(109, 9)" end="(109, 27)">
          <IdentNode start="(109, 9)" end="(109, 27)" leading="" trailing=" " raw_val="eraseP_append_left" val="eraseP_append_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(109, 28)" end="(110, 44)">
          <NullNode start="(109, 28)" end="(109, 89)">
            <OtherNode start="(109, 28)" end="(109, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 28)" end="(109, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 29)" end="(109, 30)">
                <IdentNode start="(109, 29)" end="(109, 30)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(109, 31)" end="(109, 34)">
                <AtomNode start="(109, 31)" end="(109, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(109, 33)" end="(109, 34)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(109, 34)" end="(109, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(109, 36)" end="(109, 46)">
              <AtomNode start="(109, 36)" end="(109, 37)" leading="" trailing="" val="("/>
              <NullNode start="(109, 37)" end="(109, 39)">
                <IdentNode start="(109, 37)" end="(109, 39)" leading="" trailing=" " raw_val="pa" val="pa"/>
              </NullNode>
              <NullNode start="(109, 40)" end="(109, 45)">
                <AtomNode start="(109, 40)" end="(109, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 42)" end="(109, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 42)" end="(109, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(109, 44)" end="(109, 45)">
                    <IdentNode start="(109, 44)" end="(109, 45)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(109, 45)" end="(109, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(109, 47)" end="(109, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 47)" end="(109, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 48)" end="(109, 50)">
                <IdentNode start="(109, 48)" end="(109, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(109, 51)" end="(109, 60)">
                <AtomNode start="(109, 51)" end="(109, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 53)" end="(109, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 53)" end="(109, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(109, 59)" end="(109, 60)">
                    <IdentNode start="(109, 59)" end="(109, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(109, 60)" end="(109, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(109, 62)" end="(109, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 62)" end="(109, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 63)" end="(109, 65)">
                <IdentNode start="(109, 63)" end="(109, 65)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(109, 66)" end="(109, 75)">
                <AtomNode start="(109, 66)" end="(109, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 68)" end="(109, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 68)" end="(109, 73)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(109, 74)" end="(109, 75)">
                    <IdentNode start="(109, 74)" end="(109, 75)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(109, 75)" end="(109, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(109, 77)" end="(109, 89)">
              <AtomNode start="(109, 77)" end="(109, 78)" leading="" trailing="" val="("/>
              <NullNode start="(109, 78)" end="(109, 79)">
                <IdentNode start="(109, 78)" end="(109, 79)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(109, 80)" end="(109, 88)">
                <AtomNode start="(109, 80)" end="(109, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 82)" end="(109, 88)" kind="«term_∈_»">
                  <IdentNode start="(109, 82)" end="(109, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(109, 84)" end="(109, 85)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(109, 86)" end="(109, 88)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(109, 88)" end="(109, 89)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(109, 90)" end="(110, 44)">
            <AtomNode start="(109, 90)" end="(109, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(110, 5)" end="(110, 44)" kind="«term_=_»">
              <OtherNode start="(110, 5)" end="(110, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(110, 5)" end="(110, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(110, 5)" end="(110, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(110, 5)" end="(110, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(110, 6)" end="(110, 14)" kind="«term_++_»">
                      <IdentNode start="(110, 6)" end="(110, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(110, 9)" end="(110, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(110, 12)" end="(110, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(110, 14)" end="(110, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(110, 15)" end="(110, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(110, 16)" end="(110, 22)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(110, 23)" end="(110, 24)">
                  <IdentNode start="(110, 23)" end="(110, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(110, 25)" end="(110, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(110, 27)" end="(110, 44)" kind="«term_++_»">
                <OtherNode start="(110, 27)" end="(110, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(110, 27)" end="(110, 36)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(110, 37)" end="(110, 38)">
                    <IdentNode start="(110, 37)" end="(110, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(110, 39)" end="(110, 41)" leading="" trailing=" " val="++"/>
                <IdentNode start="(110, 42)" end="(110, 44)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(110, 45)" end="(113, 63)">
          <AtomNode start="(110, 45)" end="(110, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(110, 48)" end="(113, 63)">
            <AtomNode start="(110, 48)" end="(110, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(111, 3)" end="(113, 63)">
              <TacticTacticseq1IndentedNode start="(111, 3)" end="(113, 63)">
                <NullNode start="(111, 3)" end="(113, 63)">
                  <OtherNode start="(111, 3)" end="(111, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;xs ys : Array α&#10;h : a ∈ xs&#10;⊢ (xs ++ ys).eraseP p = xs.eraseP p ++ ys" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;ys : Array α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;⊢ ({ toList := xs } ++ ys).eraseP p = { toList := xs }.eraseP p ++ ys" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(111, 3)" end="(111, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(111, 10)" end="(111, 12)">
                      <OtherNode start="(111, 10)" end="(111, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(111, 10)" end="(111, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(111, 13)" end="(111, 22)">
                      <AtomNode start="(111, 13)" end="(111, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(111, 18)" end="(111, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(111, 18)" end="(111, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(111, 18)" end="(111, 22)">
                            <OtherNode start="(111, 18)" end="(111, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(111, 18)" end="(111, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(111, 19)" end="(111, 21)">
                                <OtherNode start="(111, 19)" end="(111, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(111, 19)" end="(111, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(111, 19)" end="(111, 21)">
                                      <OtherNode start="(111, 19)" end="(111, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(111, 19)" end="(111, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(111, 21)" end="(111, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(112, 3)" end="(112, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;ys : Array α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;⊢ ({ toList := xs } ++ ys).eraseP p = { toList := xs }.eraseP p ++ ys" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).eraseP p = { toList := xs }.eraseP p ++ { toList := ys }" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(112, 3)" end="(112, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(112, 10)" end="(112, 12)">
                      <OtherNode start="(112, 10)" end="(112, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(112, 10)" end="(112, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(112, 13)" end="(112, 22)">
                      <AtomNode start="(112, 13)" end="(112, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(112, 18)" end="(112, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(112, 18)" end="(112, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(112, 18)" end="(112, 22)">
                            <OtherNode start="(112, 18)" end="(112, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(112, 18)" end="(112, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(112, 19)" end="(112, 21)">
                                <OtherNode start="(112, 19)" end="(112, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(112, 19)" end="(112, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(112, 19)" end="(112, 21)">
                                      <OtherNode start="(112, 19)" end="(112, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(112, 19)" end="(112, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(112, 21)" end="(112, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(113, 3)" end="(113, 63)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).eraseP p = { toList := xs }.eraseP p ++ { toList := ys }" state_after="no goals" tactic="simpa using List.eraseP_append_left pa ys (by simpa using h)">
                    <AtomNode start="(113, 3)" end="(113, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(113, 9)" end="(113, 63)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(113, 9)" end="(113, 63)">
                        <AtomNode start="(113, 9)" end="(113, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(113, 15)" end="(113, 63)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(113, 15)" end="(113, 38)" leading="" trailing=" " raw_val="List.eraseP_append_left" val="List.eraseP_append_left" full_name="List.eraseP_append_left" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(113, 39)" end="(113, 63)">
                            <IdentNode start="(113, 39)" end="(113, 41)" leading="" trailing=" " raw_val="pa" val="pa"/>
                            <IdentNode start="(113, 42)" end="(113, 44)" leading="" trailing=" " raw_val="ys" val="ys"/>
                            <OtherNode start="(113, 45)" end="(113, 63)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(113, 45)" end="(113, 46)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(113, 46)" end="(113, 62)">
                                <AtomNode start="(113, 46)" end="(113, 48)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(113, 49)" end="(113, 62)">
                                  <TacticTacticseq1IndentedNode start="(113, 49)" end="(113, 62)">
                                    <NullNode start="(113, 49)" end="(113, 62)">
                                      <OtherNode start="(113, 49)" end="(113, 62)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;ys : List α&#10;⊢ a ∈ xs" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(113, 49)" end="(113, 54)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(113, 55)" end="(113, 62)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(113, 55)" end="(113, 62)">
                                            <AtomNode start="(113, 55)" end="(113, 60)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(113, 61)" end="(113, 62)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(113, 62)" end="(113, 63)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(115, 1)" end="(119, 61)" name="eraseP_append_right" full_name="Array.eraseP_append_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(115, 1)" end="(119, 61)" name="eraseP_append_right" full_name="Array.eraseP_append_right" _is_private_decl="False">
        <AtomNode start="(115, 1)" end="(115, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(115, 9)" end="(115, 28)">
          <IdentNode start="(115, 9)" end="(115, 28)" leading="" trailing=" " raw_val="eraseP_append_right" val="eraseP_append_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(115, 29)" end="(116, 44)">
          <NullNode start="(115, 29)" end="(115, 67)">
            <OtherNode start="(115, 29)" end="(115, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(115, 29)" end="(115, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(115, 30)" end="(115, 32)">
                <IdentNode start="(115, 30)" end="(115, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(115, 33)" end="(115, 42)">
                <AtomNode start="(115, 33)" end="(115, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(115, 35)" end="(115, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(115, 35)" end="(115, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(115, 41)" end="(115, 42)">
                    <IdentNode start="(115, 41)" end="(115, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(115, 42)" end="(115, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <IdentNode start="(115, 44)" end="(115, 46)" leading="" trailing=" " raw_val="ys" val="ys"/>
            <TermExplicitbinderNode start="(115, 47)" end="(115, 67)">
              <AtomNode start="(115, 47)" end="(115, 48)" leading="" trailing="" val="("/>
              <NullNode start="(115, 48)" end="(115, 49)">
                <IdentNode start="(115, 48)" end="(115, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(115, 50)" end="(115, 66)">
                <AtomNode start="(115, 50)" end="(115, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(115, 52)" end="(115, 66)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(115, 52)" end="(115, 53)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(115, 54)" end="(115, 55)">
                    <IdentNode start="(115, 54)" end="(115, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(115, 56)" end="(115, 60)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(115, 56)" end="(115, 57)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(115, 58)" end="(115, 60)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(115, 60)" end="(115, 61)" leading="" trailing=" " val=","/>
                  <OtherNode start="(115, 62)" end="(115, 66)" kind="«term¬_»">
                    <AtomNode start="(115, 62)" end="(115, 63)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(115, 63)" end="(115, 66)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(115, 63)" end="(115, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(115, 65)" end="(115, 66)">
                        <IdentNode start="(115, 65)" end="(115, 66)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(115, 66)" end="(115, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(115, 68)" end="(116, 44)">
            <AtomNode start="(115, 68)" end="(115, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(116, 5)" end="(116, 44)" kind="«term_=_»">
              <OtherNode start="(116, 5)" end="(116, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(116, 5)" end="(116, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(116, 5)" end="(116, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(116, 5)" end="(116, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(116, 6)" end="(116, 14)" kind="«term_++_»">
                      <IdentNode start="(116, 6)" end="(116, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(116, 9)" end="(116, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(116, 12)" end="(116, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(116, 14)" end="(116, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(116, 15)" end="(116, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(116, 16)" end="(116, 22)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(116, 23)" end="(116, 24)">
                  <IdentNode start="(116, 23)" end="(116, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(116, 25)" end="(116, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(116, 27)" end="(116, 44)" kind="«term_++_»">
                <IdentNode start="(116, 27)" end="(116, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <AtomNode start="(116, 30)" end="(116, 32)" leading="" trailing=" " val="++"/>
                <OtherNode start="(116, 33)" end="(116, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(116, 33)" end="(116, 42)" leading="" trailing=" " raw_val="ys.eraseP" val="ys.eraseP"/>
                  <NullNode start="(116, 43)" end="(116, 44)">
                    <IdentNode start="(116, 43)" end="(116, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(116, 45)" end="(119, 61)">
          <AtomNode start="(116, 45)" end="(116, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(116, 48)" end="(119, 61)">
            <AtomNode start="(116, 48)" end="(116, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(117, 3)" end="(119, 61)">
              <TacticTacticseq1IndentedNode start="(117, 3)" end="(119, 61)">
                <NullNode start="(117, 3)" end="(119, 61)">
                  <OtherNode start="(117, 3)" end="(117, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;h : ∀ (b : α), b ∈ xs → ¬p b = true&#10;⊢ (xs ++ ys).eraseP p = xs ++ ys.eraseP p" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;h : ∀ (b : α), b ∈ { toList := xs } → ¬p b = true&#10;⊢ ({ toList := xs } ++ ys).eraseP p = { toList := xs } ++ ys.eraseP p" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(117, 3)" end="(117, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(117, 10)" end="(117, 12)">
                      <OtherNode start="(117, 10)" end="(117, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(117, 10)" end="(117, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(117, 13)" end="(117, 22)">
                      <AtomNode start="(117, 13)" end="(117, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(117, 18)" end="(117, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(117, 18)" end="(117, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(117, 18)" end="(117, 22)">
                            <OtherNode start="(117, 18)" end="(117, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(117, 18)" end="(117, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(117, 19)" end="(117, 21)">
                                <OtherNode start="(117, 19)" end="(117, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(117, 19)" end="(117, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(117, 19)" end="(117, 21)">
                                      <OtherNode start="(117, 19)" end="(117, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(117, 19)" end="(117, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(117, 21)" end="(117, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(118, 3)" end="(118, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;h : ∀ (b : α), b ∈ { toList := xs } → ¬p b = true&#10;⊢ ({ toList := xs } ++ ys).eraseP p = { toList := xs } ++ ys.eraseP p" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (b : α), b ∈ { toList := xs } → ¬p b = true&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).eraseP p = { toList := xs } ++ { toList := ys }.eraseP p" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(118, 3)" end="(118, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(118, 10)" end="(118, 12)">
                      <OtherNode start="(118, 10)" end="(118, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(118, 10)" end="(118, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(118, 13)" end="(118, 22)">
                      <AtomNode start="(118, 13)" end="(118, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(118, 18)" end="(118, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(118, 18)" end="(118, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(118, 18)" end="(118, 22)">
                            <OtherNode start="(118, 18)" end="(118, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(118, 18)" end="(118, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(118, 19)" end="(118, 21)">
                                <OtherNode start="(118, 19)" end="(118, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(118, 19)" end="(118, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(118, 19)" end="(118, 21)">
                                      <OtherNode start="(118, 19)" end="(118, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(118, 19)" end="(118, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(118, 21)" end="(118, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(119, 3)" end="(119, 61)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (b : α), b ∈ { toList := xs } → ¬p b = true&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).eraseP p = { toList := xs } ++ { toList := ys }.eraseP p" state_after="no goals" tactic="simpa using List.eraseP_append_right ys (by simpa using h)">
                    <AtomNode start="(119, 3)" end="(119, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(119, 9)" end="(119, 61)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(119, 9)" end="(119, 61)">
                        <AtomNode start="(119, 9)" end="(119, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(119, 15)" end="(119, 61)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(119, 15)" end="(119, 39)" leading="" trailing=" " raw_val="List.eraseP_append_right" val="List.eraseP_append_right" full_name="List.eraseP_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(119, 40)" end="(119, 61)">
                            <IdentNode start="(119, 40)" end="(119, 42)" leading="" trailing=" " raw_val="ys" val="ys"/>
                            <OtherNode start="(119, 43)" end="(119, 61)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(119, 43)" end="(119, 44)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(119, 44)" end="(119, 60)">
                                <AtomNode start="(119, 44)" end="(119, 46)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(119, 47)" end="(119, 60)">
                                  <TacticTacticseq1IndentedNode start="(119, 47)" end="(119, 60)">
                                    <NullNode start="(119, 47)" end="(119, 60)">
                                      <OtherNode start="(119, 47)" end="(119, 60)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (b : α), b ∈ { toList := xs } → ¬p b = true&#10;ys : List α&#10;⊢ ∀ (b : α), b ∈ xs → ¬p b = true" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(119, 47)" end="(119, 52)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(119, 53)" end="(119, 60)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(119, 53)" end="(119, 60)">
                                            <AtomNode start="(119, 53)" end="(119, 58)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(119, 59)" end="(119, 60)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(119, 60)" end="(119, 61)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(121, 1)" end="(126, 17)" name="eraseP_append" full_name="Array.eraseP_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(121, 1)" end="(126, 17)" name="eraseP_append" full_name="Array.eraseP_append" _is_private_decl="False">
        <AtomNode start="(121, 1)" end="(121, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(121, 9)" end="(121, 22)">
          <IdentNode start="(121, 9)" end="(121, 22)" leading="" trailing=" " raw_val="eraseP_append" val="eraseP_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(121, 23)" end="(122, 84)">
          <NullNode start="(121, 23)" end="(121, 52)">
            <OtherNode start="(121, 23)" end="(121, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 23)" end="(121, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 24)" end="(121, 26)">
                <IdentNode start="(121, 24)" end="(121, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(121, 27)" end="(121, 36)">
                <AtomNode start="(121, 27)" end="(121, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 29)" end="(121, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(121, 29)" end="(121, 34)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(121, 35)" end="(121, 36)">
                    <IdentNode start="(121, 35)" end="(121, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 36)" end="(121, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(121, 38)" end="(121, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 38)" end="(121, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 39)" end="(121, 41)">
                <IdentNode start="(121, 39)" end="(121, 41)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(121, 42)" end="(121, 51)">
                <AtomNode start="(121, 42)" end="(121, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 44)" end="(121, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(121, 44)" end="(121, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(121, 50)" end="(121, 51)">
                    <IdentNode start="(121, 50)" end="(121, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 51)" end="(121, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(121, 53)" end="(122, 84)">
            <AtomNode start="(121, 53)" end="(121, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(122, 5)" end="(122, 84)" kind="«term_=_»">
              <OtherNode start="(122, 5)" end="(122, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(122, 5)" end="(122, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(122, 5)" end="(122, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(122, 5)" end="(122, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(122, 6)" end="(122, 14)" kind="«term_++_»">
                      <IdentNode start="(122, 6)" end="(122, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(122, 9)" end="(122, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(122, 12)" end="(122, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(122, 14)" end="(122, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(122, 15)" end="(122, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(122, 16)" end="(122, 22)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(122, 23)" end="(122, 24)">
                  <IdentNode start="(122, 23)" end="(122, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(122, 25)" end="(122, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(122, 27)" end="(122, 84)" kind="termIfThenElse">
                <AtomNode start="(122, 27)" end="(122, 29)" leading="" trailing=" " val="if"/>
                <OtherNode start="(122, 30)" end="(122, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(122, 30)" end="(122, 36)" leading="" trailing=" " raw_val="xs.any" val="xs.any"/>
                  <NullNode start="(122, 37)" end="(122, 38)">
                    <IdentNode start="(122, 37)" end="(122, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(122, 39)" end="(122, 43)" leading="" trailing=" " val="then"/>
                <OtherNode start="(122, 44)" end="(122, 61)" kind="«term_++_»">
                  <OtherNode start="(122, 44)" end="(122, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(122, 44)" end="(122, 53)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                    <NullNode start="(122, 54)" end="(122, 55)">
                      <IdentNode start="(122, 54)" end="(122, 55)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(122, 56)" end="(122, 58)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(122, 59)" end="(122, 61)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(122, 62)" end="(122, 66)" leading="" trailing=" " val="else"/>
                <OtherNode start="(122, 67)" end="(122, 84)" kind="«term_++_»">
                  <IdentNode start="(122, 67)" end="(122, 69)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(122, 70)" end="(122, 72)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(122, 73)" end="(122, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(122, 73)" end="(122, 82)" leading="" trailing=" " raw_val="ys.eraseP" val="ys.eraseP"/>
                    <NullNode start="(122, 83)" end="(122, 84)">
                      <IdentNode start="(122, 83)" end="(122, 84)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(122, 85)" end="(126, 17)">
          <AtomNode start="(122, 85)" end="(122, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(122, 88)" end="(126, 17)">
            <AtomNode start="(122, 88)" end="(122, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(123, 3)" end="(126, 17)">
              <TacticTacticseq1IndentedNode start="(123, 3)" end="(126, 17)">
                <NullNode start="(123, 3)" end="(126, 17)">
                  <OtherNode start="(123, 3)" end="(123, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;⊢ (xs ++ ys).eraseP p = if xs.any p = true then xs.eraseP p ++ ys else xs ++ ys.eraseP p" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ ({ toList := xs } ++ ys).eraseP p =&#10;    if { toList := xs }.any p = true then { toList := xs }.eraseP p ++ ys else { toList := xs } ++ ys.eraseP p" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(123, 3)" end="(123, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(123, 10)" end="(123, 12)">
                      <OtherNode start="(123, 10)" end="(123, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(123, 10)" end="(123, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(123, 13)" end="(123, 22)">
                      <AtomNode start="(123, 13)" end="(123, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(123, 18)" end="(123, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(123, 18)" end="(123, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(123, 18)" end="(123, 22)">
                            <OtherNode start="(123, 18)" end="(123, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(123, 18)" end="(123, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(123, 19)" end="(123, 21)">
                                <OtherNode start="(123, 19)" end="(123, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(123, 19)" end="(123, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(123, 19)" end="(123, 21)">
                                      <OtherNode start="(123, 19)" end="(123, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(123, 19)" end="(123, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(123, 21)" end="(123, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(124, 3)" end="(124, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;ys : Array α&#10;xs : List α&#10;⊢ ({ toList := xs } ++ ys).eraseP p =&#10;    if { toList := xs }.any p = true then { toList := xs }.eraseP p ++ ys else { toList := xs } ++ ys.eraseP p" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).eraseP p =&#10;    if { toList := xs }.any p = true then { toList := xs }.eraseP p ++ { toList := ys }&#10;    else { toList := xs } ++ { toList := ys }.eraseP p" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(124, 3)" end="(124, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(124, 10)" end="(124, 12)">
                      <OtherNode start="(124, 10)" end="(124, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(124, 10)" end="(124, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(124, 13)" end="(124, 22)">
                      <AtomNode start="(124, 13)" end="(124, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(124, 18)" end="(124, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(124, 18)" end="(124, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(124, 18)" end="(124, 22)">
                            <OtherNode start="(124, 18)" end="(124, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(124, 18)" end="(124, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(124, 19)" end="(124, 21)">
                                <OtherNode start="(124, 19)" end="(124, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(124, 19)" end="(124, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(124, 19)" end="(124, 21)">
                                      <OtherNode start="(124, 19)" end="(124, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(124, 19)" end="(124, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(124, 21)" end="(124, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(125, 3)" end="(125, 93)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).eraseP p =&#10;    if { toList := xs }.any p = true then { toList := xs }.eraseP p ++ { toList := ys }&#10;    else { toList := xs } ++ { toList := ys }.eraseP p" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if xs.any p = true then List.eraseP p xs ++ ys else xs ++ List.eraseP p ys).toArray =&#10;    if xs.any p = true then (List.eraseP p xs ++ ys).toArray else (xs ++ List.eraseP p ys).toArray" tactic="simp only [List.append_toArray, List.eraseP_toArray, List.eraseP_append, List.any_toArray]">
                    <AtomNode start="(125, 3)" end="(125, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(125, 8)" end="(125, 12)">
                      <AtomNode start="(125, 8)" end="(125, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(125, 13)" end="(125, 93)">
                      <AtomNode start="(125, 13)" end="(125, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(125, 14)" end="(125, 92)">
                        <OtherNode start="(125, 14)" end="(125, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(125, 14)" end="(125, 33)" leading="" trailing="" raw_val="List.append_toArray" val="List.append_toArray" full_name="List.append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(125, 33)" end="(125, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(125, 35)" end="(125, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(125, 35)" end="(125, 54)" leading="" trailing="" raw_val="List.eraseP_toArray" val="List.eraseP_toArray" full_name="List.eraseP_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(125, 54)" end="(125, 55)" leading="" trailing=" " val=","/>
                        <OtherNode start="(125, 56)" end="(125, 74)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(125, 56)" end="(125, 74)" leading="" trailing="" raw_val="List.eraseP_append" val="List.eraseP_append" full_name="List.eraseP_append" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(125, 74)" end="(125, 75)" leading="" trailing=" " val=","/>
                        <OtherNode start="(125, 76)" end="(125, 92)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(125, 76)" end="(125, 92)" leading="" trailing="" raw_val="List.any_toArray" val="List.any_toArray" full_name="List.any_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(125, 92)" end="(125, 93)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(126, 3)" end="(126, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ (if xs.any p = true then List.eraseP p xs ++ ys else xs ++ List.eraseP p ys).toArray =&#10;    if xs.any p = true then (List.eraseP p xs ++ ys).toArray else (xs ++ List.eraseP p ys).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(126, 3)" end="(126, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(126, 3)" end="(126, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(126, 9)" end="(126, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(126, 13)" end="(126, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(126, 13)" end="(126, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(128, 1)" end="(131, 17)" name="eraseP_replicate" full_name="Array.eraseP_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(128, 1)" end="(131, 17)" name="eraseP_replicate" full_name="Array.eraseP_replicate" _is_private_decl="False">
        <AtomNode start="(128, 1)" end="(128, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(128, 9)" end="(128, 25)">
          <IdentNode start="(128, 9)" end="(128, 25)" leading="" trailing=" " raw_val="eraseP_replicate" val="eraseP_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(128, 26)" end="(129, 82)">
          <NullNode start="(128, 26)" end="(128, 58)">
            <OtherNode start="(128, 26)" end="(128, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(128, 26)" end="(128, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(128, 27)" end="(128, 28)">
                <IdentNode start="(128, 27)" end="(128, 28)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(128, 29)" end="(128, 34)">
                <AtomNode start="(128, 29)" end="(128, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(128, 31)" end="(128, 34)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(128, 34)" end="(128, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(128, 36)" end="(128, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(128, 36)" end="(128, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(128, 37)" end="(128, 38)">
                <IdentNode start="(128, 37)" end="(128, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(128, 39)" end="(128, 42)">
                <AtomNode start="(128, 39)" end="(128, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(128, 41)" end="(128, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(128, 42)" end="(128, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(128, 44)" end="(128, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(128, 44)" end="(128, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(128, 45)" end="(128, 46)">
                <IdentNode start="(128, 45)" end="(128, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(128, 47)" end="(128, 57)">
                <AtomNode start="(128, 47)" end="(128, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(128, 49)" end="(128, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(128, 49)" end="(128, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(128, 51)" end="(128, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(128, 53)" end="(128, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(128, 57)" end="(128, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(128, 59)" end="(129, 82)">
            <AtomNode start="(128, 59)" end="(128, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(129, 5)" end="(129, 82)" kind="«term_=_»">
              <OtherNode start="(129, 5)" end="(129, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(129, 5)" end="(129, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(129, 5)" end="(129, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(129, 5)" end="(129, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(129, 6)" end="(129, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(129, 6)" end="(129, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(129, 16)" end="(129, 19)">
                        <IdentNode start="(129, 16)" end="(129, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(129, 18)" end="(129, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(129, 19)" end="(129, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(129, 20)" end="(129, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(129, 21)" end="(129, 27)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(129, 28)" end="(129, 29)">
                  <IdentNode start="(129, 28)" end="(129, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(129, 30)" end="(129, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(129, 32)" end="(129, 82)" kind="termIfThenElse">
                <AtomNode start="(129, 32)" end="(129, 34)" leading="" trailing=" " val="if"/>
                <OtherNode start="(129, 35)" end="(129, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 35)" end="(129, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(129, 37)" end="(129, 38)">
                    <IdentNode start="(129, 37)" end="(129, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(129, 39)" end="(129, 43)" leading="" trailing=" " val="then"/>
                <OtherNode start="(129, 44)" end="(129, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 44)" end="(129, 53)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(129, 54)" end="(129, 63)">
                    <OtherNode start="(129, 54)" end="(129, 61)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(129, 54)" end="(129, 55)" leading="" trailing="" val="("/>
                      <OtherNode start="(129, 55)" end="(129, 60)" kind="«term_-_»">
                        <IdentNode start="(129, 55)" end="(129, 56)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(129, 57)" end="(129, 58)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(129, 59)" end="(129, 60)" kind="num">
                          <AtomNode start="(129, 59)" end="(129, 60)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(129, 60)" end="(129, 61)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(129, 62)" end="(129, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(129, 64)" end="(129, 68)" leading="" trailing=" " val="else"/>
                <OtherNode start="(129, 69)" end="(129, 82)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 69)" end="(129, 78)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(129, 79)" end="(129, 82)">
                    <IdentNode start="(129, 79)" end="(129, 80)" leading="" trailing=" " raw_val="n" val="n"/>
                    <IdentNode start="(129, 81)" end="(129, 82)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(129, 83)" end="(131, 17)">
          <AtomNode start="(129, 83)" end="(129, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(129, 86)" end="(131, 17)">
            <AtomNode start="(129, 86)" end="(129, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(130, 3)" end="(131, 17)">
              <TacticTacticseq1IndentedNode start="(130, 3)" end="(131, 17)">
                <NullNode start="(130, 3)" end="(131, 17)">
                  <OtherNode start="(130, 3)" end="(130, 83)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ (replicate n a).eraseP p = if p a = true then replicate (n - 1) a else replicate n a" state_after="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ (if p a = true then List.replicate (n - 1) a else List.replicate n a).toArray =&#10;    if p a = true then (List.replicate (n - 1) a).toArray else (List.replicate n a).toArray" tactic="simp only [← List.toArray_replicate, List.eraseP_toArray, List.eraseP_replicate]">
                    <AtomNode start="(130, 3)" end="(130, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(130, 8)" end="(130, 12)">
                      <AtomNode start="(130, 8)" end="(130, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(130, 13)" end="(130, 83)">
                      <AtomNode start="(130, 13)" end="(130, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(130, 14)" end="(130, 82)">
                        <OtherNode start="(130, 14)" end="(130, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(130, 14)" end="(130, 15)">
                            <OtherNode start="(130, 14)" end="(130, 15)" kind="patternIgnore">
                              <OtherNode start="(130, 14)" end="(130, 15)" kind="token.«← »">
                                <AtomNode start="(130, 14)" end="(130, 15)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(130, 16)" end="(130, 38)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(130, 38)" end="(130, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(130, 40)" end="(130, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(130, 40)" end="(130, 59)" leading="" trailing="" raw_val="List.eraseP_toArray" val="List.eraseP_toArray" full_name="List.eraseP_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(130, 59)" end="(130, 60)" leading="" trailing=" " val=","/>
                        <OtherNode start="(130, 61)" end="(130, 82)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(130, 61)" end="(130, 82)" leading="" trailing="" raw_val="List.eraseP_replicate" val="List.eraseP_replicate" full_name="List.eraseP_replicate" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(130, 82)" end="(130, 83)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(131, 3)" end="(131, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ (if p a = true then List.replicate (n - 1) a else List.replicate n a).toArray =&#10;    if p a = true then (List.replicate (n - 1) a).toArray else (List.replicate n a).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(131, 3)" end="(131, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(131, 3)" end="(131, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(131, 9)" end="(131, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(131, 13)" end="(131, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(131, 13)" end="(131, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(133, 1)" end="(134, 43)" name="eraseP_mkArray" full_name="Array.eraseP_mkArray">
      <CommandDeclmodifiersNode start="(133, 1)" end="(133, 55)">
        <NullNode/>
        <NullNode start="(133, 1)" end="(133, 55)">
          <OtherNode start="(133, 1)" end="(133, 55)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(133, 1)" end="(133, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(133, 3)" end="(133, 54)">
              <OtherNode start="(133, 3)" end="(133, 54)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(133, 3)" end="(133, 54)" kind="Lean.deprecated">
                  <AtomNode start="(133, 3)" end="(133, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(133, 14)" end="(133, 30)">
                    <IdentNode start="(133, 14)" end="(133, 30)" leading="" trailing=" " raw_val="eraseP_replicate" val="eraseP_replicate" full_name="Array.eraseP_replicate" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(128, 9)" def_end="(128, 25)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(133, 31)" end="(133, 54)">
                    <AtomNode start="(133, 31)" end="(133, 32)" leading="" trailing="" val="("/>
                    <AtomNode start="(133, 32)" end="(133, 37)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(133, 38)" end="(133, 40)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(133, 41)" end="(133, 53)" kind="str">
                      <AtomNode start="(133, 41)" end="(133, 53)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(133, 53)" end="(133, 54)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(133, 54)" end="(133, 55)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(134, 1)" end="(134, 43)" name="eraseP_mkArray">
        <AtomNode start="(134, 1)" end="(134, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(134, 8)" end="(134, 22)">
          <IdentNode start="(134, 8)" end="(134, 22)" leading="" trailing=" " raw_val="eraseP_mkArray" val="eraseP_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(134, 23)" end="(134, 43)">
          <AtomNode start="(134, 23)" end="(134, 25)" leading="" trailing=" " val=":="/>
          <OtherNode start="(134, 26)" end="(134, 43)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(134, 26)" end="(134, 27)" leading="" trailing="" val="@"/>
            <IdentNode start="(134, 27)" end="(134, 43)" leading="" trailing="&#10;&#10;" raw_val="eraseP_replicate" val="eraseP_replicate" full_name="Array.eraseP_replicate" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(128, 9)" def_end="(128, 25)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(136, 1)" end="(139, 11)" name="eraseP_replicate_of_pos" full_name="Array.eraseP_replicate_of_pos">
      <CommandDeclmodifiersNode start="(136, 1)" end="(136, 8)">
        <NullNode/>
        <NullNode start="(136, 1)" end="(136, 8)">
          <OtherNode start="(136, 1)" end="(136, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(136, 1)" end="(136, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(136, 3)" end="(136, 7)">
              <OtherNode start="(136, 3)" end="(136, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(136, 3)" end="(136, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(136, 3)" end="(136, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(136, 7)" end="(136, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(136, 9)" end="(139, 11)" name="eraseP_replicate_of_pos" full_name="Array.eraseP_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(136, 9)" end="(136, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(136, 17)" end="(136, 40)">
          <IdentNode start="(136, 17)" end="(136, 40)" leading="" trailing=" " raw_val="eraseP_replicate_of_pos" val="eraseP_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(136, 41)" end="(137, 51)">
          <NullNode start="(136, 41)" end="(136, 68)">
            <OtherNode start="(136, 41)" end="(136, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 41)" end="(136, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 42)" end="(136, 43)">
                <IdentNode start="(136, 42)" end="(136, 43)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(136, 44)" end="(136, 49)">
                <AtomNode start="(136, 44)" end="(136, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(136, 46)" end="(136, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(136, 49)" end="(136, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(136, 51)" end="(136, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 51)" end="(136, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 52)" end="(136, 53)">
                <IdentNode start="(136, 52)" end="(136, 53)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(136, 54)" end="(136, 57)">
                <AtomNode start="(136, 54)" end="(136, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(136, 56)" end="(136, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(136, 57)" end="(136, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(136, 59)" end="(136, 68)">
              <AtomNode start="(136, 59)" end="(136, 60)" leading="" trailing="" val="("/>
              <NullNode start="(136, 60)" end="(136, 61)">
                <IdentNode start="(136, 60)" end="(136, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(136, 62)" end="(136, 67)">
                <AtomNode start="(136, 62)" end="(136, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(136, 64)" end="(136, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(136, 64)" end="(136, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(136, 66)" end="(136, 67)">
                    <IdentNode start="(136, 66)" end="(136, 67)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(136, 67)" end="(136, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(136, 69)" end="(137, 51)">
            <AtomNode start="(136, 69)" end="(136, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(137, 5)" end="(137, 51)" kind="«term_=_»">
              <OtherNode start="(137, 5)" end="(137, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(137, 5)" end="(137, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(137, 5)" end="(137, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(137, 5)" end="(137, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(137, 6)" end="(137, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(137, 6)" end="(137, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(137, 16)" end="(137, 19)">
                        <IdentNode start="(137, 16)" end="(137, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(137, 18)" end="(137, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(137, 19)" end="(137, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(137, 20)" end="(137, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(137, 21)" end="(137, 27)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(137, 28)" end="(137, 29)">
                  <IdentNode start="(137, 28)" end="(137, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(137, 30)" end="(137, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(137, 32)" end="(137, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(137, 32)" end="(137, 41)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(137, 42)" end="(137, 51)">
                  <OtherNode start="(137, 42)" end="(137, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(137, 42)" end="(137, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(137, 43)" end="(137, 48)" kind="«term_-_»">
                      <IdentNode start="(137, 43)" end="(137, 44)" leading="" trailing=" " raw_val="n" val="n"/>
                      <AtomNode start="(137, 45)" end="(137, 46)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(137, 47)" end="(137, 48)" kind="num">
                        <AtomNode start="(137, 47)" end="(137, 48)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(137, 48)" end="(137, 49)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(137, 50)" end="(137, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(137, 52)" end="(139, 11)">
          <AtomNode start="(137, 52)" end="(137, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(137, 55)" end="(139, 11)">
            <AtomNode start="(137, 55)" end="(137, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(138, 3)" end="(139, 11)">
              <TacticTacticseq1IndentedNode start="(138, 3)" end="(139, 11)">
                <NullNode start="(138, 3)" end="(139, 11)">
                  <OtherNode start="(138, 3)" end="(138, 60)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : p a = true&#10;⊢ (replicate n a).eraseP p = replicate (n - 1) a" state_after="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : p a = true&#10;⊢ (List.eraseP p (List.replicate n a)).toArray = (List.replicate (n - 1) a).toArray" tactic="simp only [← List.toArray_replicate, List.eraseP_toArray]">
                    <AtomNode start="(138, 3)" end="(138, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(138, 8)" end="(138, 12)">
                      <AtomNode start="(138, 8)" end="(138, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(138, 13)" end="(138, 60)">
                      <AtomNode start="(138, 13)" end="(138, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(138, 14)" end="(138, 59)">
                        <OtherNode start="(138, 14)" end="(138, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(138, 14)" end="(138, 15)">
                            <OtherNode start="(138, 14)" end="(138, 15)" kind="patternIgnore">
                              <OtherNode start="(138, 14)" end="(138, 15)" kind="token.«← »">
                                <AtomNode start="(138, 14)" end="(138, 15)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(138, 16)" end="(138, 38)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(138, 38)" end="(138, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(138, 40)" end="(138, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(138, 40)" end="(138, 59)" leading="" trailing="" raw_val="List.eraseP_toArray" val="List.eraseP_toArray" full_name="List.eraseP_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(138, 59)" end="(138, 60)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(139, 3)" end="(139, 11)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : p a = true&#10;⊢ (List.eraseP p (List.replicate n a)).toArray = (List.replicate (n - 1) a).toArray" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(139, 3)" end="(139, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(139, 8)" end="(139, 11)">
                      <AtomNode start="(139, 8)" end="(139, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(139, 9)" end="(139, 10)">
                        <OtherNode start="(139, 9)" end="(139, 10)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(139, 9)" end="(139, 10)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(139, 10)" end="(139, 11)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(141, 1)" end="(142, 57)" name="eraseP_mkArray_of_pos" full_name="Array.eraseP_mkArray_of_pos">
      <CommandDeclmodifiersNode start="(141, 1)" end="(141, 62)">
        <NullNode/>
        <NullNode start="(141, 1)" end="(141, 62)">
          <OtherNode start="(141, 1)" end="(141, 62)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(141, 1)" end="(141, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(141, 3)" end="(141, 61)">
              <OtherNode start="(141, 3)" end="(141, 61)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(141, 3)" end="(141, 61)" kind="Lean.deprecated">
                  <AtomNode start="(141, 3)" end="(141, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(141, 14)" end="(141, 37)">
                    <IdentNode start="(141, 14)" end="(141, 37)" leading="" trailing=" " raw_val="eraseP_replicate_of_pos" val="eraseP_replicate_of_pos" full_name="Array.eraseP_replicate_of_pos" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(136, 17)" def_end="(136, 40)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(141, 38)" end="(141, 61)">
                    <AtomNode start="(141, 38)" end="(141, 39)" leading="" trailing="" val="("/>
                    <AtomNode start="(141, 39)" end="(141, 44)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(141, 45)" end="(141, 47)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(141, 48)" end="(141, 60)" kind="str">
                      <AtomNode start="(141, 48)" end="(141, 60)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(141, 60)" end="(141, 61)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(141, 61)" end="(141, 62)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(142, 1)" end="(142, 57)" name="eraseP_mkArray_of_pos">
        <AtomNode start="(142, 1)" end="(142, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(142, 8)" end="(142, 29)">
          <IdentNode start="(142, 8)" end="(142, 29)" leading="" trailing=" " raw_val="eraseP_mkArray_of_pos" val="eraseP_mkArray_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(142, 30)" end="(142, 57)">
          <AtomNode start="(142, 30)" end="(142, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(142, 33)" end="(142, 57)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(142, 33)" end="(142, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(142, 34)" end="(142, 57)" leading="" trailing="&#10;&#10;" raw_val="eraseP_replicate_of_pos" val="eraseP_replicate_of_pos" full_name="Array.eraseP_replicate_of_pos" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(136, 17)" def_end="(136, 40)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(144, 1)" end="(147, 11)" name="eraseP_replicate_of_neg" full_name="Array.eraseP_replicate_of_neg">
      <CommandDeclmodifiersNode start="(144, 1)" end="(144, 8)">
        <NullNode/>
        <NullNode start="(144, 1)" end="(144, 8)">
          <OtherNode start="(144, 1)" end="(144, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(144, 1)" end="(144, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(144, 3)" end="(144, 7)">
              <OtherNode start="(144, 3)" end="(144, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(144, 3)" end="(144, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(144, 3)" end="(144, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(144, 7)" end="(144, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(144, 9)" end="(147, 11)" name="eraseP_replicate_of_neg" full_name="Array.eraseP_replicate_of_neg" _is_private_decl="False">
        <AtomNode start="(144, 9)" end="(144, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(144, 17)" end="(144, 40)">
          <IdentNode start="(144, 17)" end="(144, 40)" leading="" trailing=" " raw_val="eraseP_replicate_of_neg" val="eraseP_replicate_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(144, 41)" end="(145, 45)">
          <NullNode start="(144, 41)" end="(144, 69)">
            <OtherNode start="(144, 41)" end="(144, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 41)" end="(144, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 42)" end="(144, 43)">
                <IdentNode start="(144, 42)" end="(144, 43)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(144, 44)" end="(144, 49)">
                <AtomNode start="(144, 44)" end="(144, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(144, 46)" end="(144, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(144, 49)" end="(144, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(144, 51)" end="(144, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 51)" end="(144, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 52)" end="(144, 53)">
                <IdentNode start="(144, 52)" end="(144, 53)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(144, 54)" end="(144, 57)">
                <AtomNode start="(144, 54)" end="(144, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(144, 56)" end="(144, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(144, 57)" end="(144, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(144, 59)" end="(144, 69)">
              <AtomNode start="(144, 59)" end="(144, 60)" leading="" trailing="" val="("/>
              <NullNode start="(144, 60)" end="(144, 61)">
                <IdentNode start="(144, 60)" end="(144, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(144, 62)" end="(144, 68)">
                <AtomNode start="(144, 62)" end="(144, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 64)" end="(144, 68)" kind="«term¬_»">
                  <AtomNode start="(144, 64)" end="(144, 65)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(144, 65)" end="(144, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(144, 65)" end="(144, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(144, 67)" end="(144, 68)">
                      <IdentNode start="(144, 67)" end="(144, 68)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 68)" end="(144, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(144, 70)" end="(145, 45)">
            <AtomNode start="(144, 70)" end="(144, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(145, 5)" end="(145, 45)" kind="«term_=_»">
              <OtherNode start="(145, 5)" end="(145, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(145, 5)" end="(145, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(145, 5)" end="(145, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 5)" end="(145, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(145, 6)" end="(145, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(145, 6)" end="(145, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(145, 16)" end="(145, 19)">
                        <IdentNode start="(145, 16)" end="(145, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(145, 18)" end="(145, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(145, 19)" end="(145, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(145, 20)" end="(145, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(145, 21)" end="(145, 27)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(145, 28)" end="(145, 29)">
                  <IdentNode start="(145, 28)" end="(145, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(145, 30)" end="(145, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(145, 32)" end="(145, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(145, 32)" end="(145, 41)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(145, 42)" end="(145, 45)">
                  <IdentNode start="(145, 42)" end="(145, 43)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(145, 44)" end="(145, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(145, 46)" end="(147, 11)">
          <AtomNode start="(145, 46)" end="(145, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(145, 49)" end="(147, 11)">
            <AtomNode start="(145, 49)" end="(145, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(146, 3)" end="(147, 11)">
              <TacticTacticseq1IndentedNode start="(146, 3)" end="(147, 11)">
                <NullNode start="(146, 3)" end="(147, 11)">
                  <OtherNode start="(146, 3)" end="(146, 60)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : ¬p a = true&#10;⊢ (replicate n a).eraseP p = replicate n a" state_after="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : ¬p a = true&#10;⊢ (List.eraseP p (List.replicate n a)).toArray = (List.replicate n a).toArray" tactic="simp only [← List.toArray_replicate, List.eraseP_toArray]">
                    <AtomNode start="(146, 3)" end="(146, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(146, 8)" end="(146, 12)">
                      <AtomNode start="(146, 8)" end="(146, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(146, 13)" end="(146, 60)">
                      <AtomNode start="(146, 13)" end="(146, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(146, 14)" end="(146, 59)">
                        <OtherNode start="(146, 14)" end="(146, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(146, 14)" end="(146, 15)">
                            <OtherNode start="(146, 14)" end="(146, 15)" kind="patternIgnore">
                              <OtherNode start="(146, 14)" end="(146, 15)" kind="token.«← »">
                                <AtomNode start="(146, 14)" end="(146, 15)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(146, 16)" end="(146, 38)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(146, 38)" end="(146, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(146, 40)" end="(146, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(146, 40)" end="(146, 59)" leading="" trailing="" raw_val="List.eraseP_toArray" val="List.eraseP_toArray" full_name="List.eraseP_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(146, 59)" end="(146, 60)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(147, 3)" end="(147, 11)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : ¬p a = true&#10;⊢ (List.eraseP p (List.replicate n a)).toArray = (List.replicate n a).toArray" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(147, 3)" end="(147, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(147, 8)" end="(147, 11)">
                      <AtomNode start="(147, 8)" end="(147, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(147, 9)" end="(147, 10)">
                        <OtherNode start="(147, 9)" end="(147, 10)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(147, 9)" end="(147, 10)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(147, 10)" end="(147, 11)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(149, 1)" end="(150, 57)" name="eraseP_mkArray_of_neg" full_name="Array.eraseP_mkArray_of_neg">
      <CommandDeclmodifiersNode start="(149, 1)" end="(149, 62)">
        <NullNode/>
        <NullNode start="(149, 1)" end="(149, 62)">
          <OtherNode start="(149, 1)" end="(149, 62)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(149, 1)" end="(149, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(149, 3)" end="(149, 61)">
              <OtherNode start="(149, 3)" end="(149, 61)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(149, 3)" end="(149, 61)" kind="Lean.deprecated">
                  <AtomNode start="(149, 3)" end="(149, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(149, 14)" end="(149, 37)">
                    <IdentNode start="(149, 14)" end="(149, 37)" leading="" trailing=" " raw_val="eraseP_replicate_of_neg" val="eraseP_replicate_of_neg" full_name="Array.eraseP_replicate_of_neg" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(144, 17)" def_end="(144, 40)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(149, 38)" end="(149, 61)">
                    <AtomNode start="(149, 38)" end="(149, 39)" leading="" trailing="" val="("/>
                    <AtomNode start="(149, 39)" end="(149, 44)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(149, 45)" end="(149, 47)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(149, 48)" end="(149, 60)" kind="str">
                      <AtomNode start="(149, 48)" end="(149, 60)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(149, 60)" end="(149, 61)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(149, 61)" end="(149, 62)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(150, 1)" end="(150, 57)" name="eraseP_mkArray_of_neg">
        <AtomNode start="(150, 1)" end="(150, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(150, 8)" end="(150, 29)">
          <IdentNode start="(150, 8)" end="(150, 29)" leading="" trailing=" " raw_val="eraseP_mkArray_of_neg" val="eraseP_mkArray_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(150, 30)" end="(150, 57)">
          <AtomNode start="(150, 30)" end="(150, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(150, 33)" end="(150, 57)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(150, 33)" end="(150, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(150, 34)" end="(150, 57)" leading="" trailing="&#10;&#10;" raw_val="eraseP_replicate_of_neg" val="eraseP_replicate_of_neg" full_name="Array.eraseP_replicate_of_neg" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(144, 17)" def_end="(144, 40)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(152, 1)" end="(165, 64)" name="eraseP_eq_iff" full_name="Array.eraseP_eq_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(152, 1)" end="(165, 64)" name="eraseP_eq_iff" full_name="Array.eraseP_eq_iff" _is_private_decl="False">
        <AtomNode start="(152, 1)" end="(152, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(152, 9)" end="(152, 22)">
          <IdentNode start="(152, 9)" end="(152, 22)" leading="" trailing=" " raw_val="eraseP_eq_iff" val="eraseP_eq_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(152, 23)" end="(155, 82)">
          <NullNode start="(152, 23)" end="(152, 41)">
            <OtherNode start="(152, 23)" end="(152, 26)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(152, 23)" end="(152, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(152, 24)" end="(152, 25)">
                <IdentNode start="(152, 24)" end="(152, 25)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(152, 25)" end="(152, 26)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(152, 27)" end="(152, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(152, 27)" end="(152, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(152, 28)" end="(152, 30)">
                <IdentNode start="(152, 28)" end="(152, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(152, 31)" end="(152, 40)">
                <AtomNode start="(152, 31)" end="(152, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 33)" end="(152, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(152, 33)" end="(152, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(152, 39)" end="(152, 40)">
                    <IdentNode start="(152, 39)" end="(152, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(152, 40)" end="(152, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(152, 42)" end="(155, 82)">
            <AtomNode start="(152, 42)" end="(152, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(153, 5)" end="(155, 82)" kind="«term_↔_»">
              <OtherNode start="(153, 5)" end="(153, 21)" kind="«term_=_»">
                <OtherNode start="(153, 5)" end="(153, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(153, 5)" end="(153, 14)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(153, 15)" end="(153, 16)">
                    <IdentNode start="(153, 15)" end="(153, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(153, 17)" end="(153, 18)" leading="" trailing=" " val="="/>
                <IdentNode start="(153, 19)" end="(153, 21)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </OtherNode>
              <AtomNode start="(153, 22)" end="(153, 23)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(154, 7)" end="(155, 82)" kind="«term_∨_»">
                <OtherNode start="(154, 7)" end="(154, 36)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(154, 7)" end="(154, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(154, 8)" end="(154, 35)" kind="«term_∧_»">
                    <OtherNode start="(154, 8)" end="(154, 25)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(154, 8)" end="(154, 9)" leading="" trailing="" val="("/>
                      <OtherNode start="(154, 9)" end="(154, 24)" kind="Lean.«term∀__,_»">
                        <AtomNode start="(154, 9)" end="(154, 10)" leading="" trailing=" " val="∀"/>
                        <LeanBinderidentNode start="(154, 11)" end="(154, 12)">
                          <IdentNode start="(154, 11)" end="(154, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                        <OtherNode start="(154, 13)" end="(154, 17)" kind="Lean.«binderTerm∈_»">
                          <AtomNode start="(154, 13)" end="(154, 14)" leading="" trailing=" " val="∈"/>
                          <IdentNode start="(154, 15)" end="(154, 17)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </OtherNode>
                        <AtomNode start="(154, 17)" end="(154, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(154, 19)" end="(154, 24)" kind="«term¬_»">
                          <AtomNode start="(154, 19)" end="(154, 20)" leading="" trailing=" " val="¬"/>
                          <OtherNode start="(154, 21)" end="(154, 24)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(154, 21)" end="(154, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(154, 23)" end="(154, 24)">
                              <IdentNode start="(154, 23)" end="(154, 24)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(154, 24)" end="(154, 25)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <AtomNode start="(154, 26)" end="(154, 27)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(154, 28)" end="(154, 35)" kind="«term_=_»">
                      <IdentNode start="(154, 28)" end="(154, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(154, 31)" end="(154, 32)" leading="" trailing=" " val="="/>
                      <IdentNode start="(154, 33)" end="(154, 35)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(154, 35)" end="(154, 36)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(154, 37)" end="(154, 38)" leading="" trailing="&#10;        " val="∨"/>
                <OtherNode start="(155, 9)" end="(155, 82)" kind="«term∃_,_»">
                  <AtomNode start="(155, 9)" end="(155, 10)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(155, 11)" end="(155, 18)" kind="Lean.explicitBinders">
                    <OtherNode start="(155, 11)" end="(155, 18)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(155, 11)" end="(155, 18)">
                        <LeanBinderidentNode start="(155, 11)" end="(155, 12)">
                          <IdentNode start="(155, 11)" end="(155, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(155, 13)" end="(155, 15)">
                          <IdentNode start="(155, 13)" end="(155, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(155, 16)" end="(155, 18)">
                          <IdentNode start="(155, 16)" end="(155, 18)" leading="" trailing="" raw_val="bs" val="bs"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(155, 18)" end="(155, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(155, 20)" end="(155, 82)" kind="«term_∧_»">
                    <OtherNode start="(155, 20)" end="(155, 37)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(155, 20)" end="(155, 21)" leading="" trailing="" val="("/>
                      <OtherNode start="(155, 21)" end="(155, 36)" kind="Lean.«term∀__,_»">
                        <AtomNode start="(155, 21)" end="(155, 22)" leading="" trailing=" " val="∀"/>
                        <LeanBinderidentNode start="(155, 23)" end="(155, 24)">
                          <IdentNode start="(155, 23)" end="(155, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                        </LeanBinderidentNode>
                        <OtherNode start="(155, 25)" end="(155, 29)" kind="Lean.«binderTerm∈_»">
                          <AtomNode start="(155, 25)" end="(155, 26)" leading="" trailing=" " val="∈"/>
                          <IdentNode start="(155, 27)" end="(155, 29)" leading="" trailing="" raw_val="as" val="as"/>
                        </OtherNode>
                        <AtomNode start="(155, 29)" end="(155, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(155, 31)" end="(155, 36)" kind="«term¬_»">
                          <AtomNode start="(155, 31)" end="(155, 32)" leading="" trailing=" " val="¬"/>
                          <OtherNode start="(155, 33)" end="(155, 36)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(155, 33)" end="(155, 34)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(155, 35)" end="(155, 36)">
                              <IdentNode start="(155, 35)" end="(155, 36)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(155, 36)" end="(155, 37)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <AtomNode start="(155, 38)" end="(155, 39)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(155, 40)" end="(155, 82)" kind="«term_∧_»">
                      <OtherNode start="(155, 40)" end="(155, 43)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(155, 40)" end="(155, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(155, 42)" end="(155, 43)">
                          <IdentNode start="(155, 42)" end="(155, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(155, 44)" end="(155, 45)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(155, 46)" end="(155, 82)" kind="«term_∧_»">
                        <OtherNode start="(155, 46)" end="(155, 66)" kind="«term_=_»">
                          <IdentNode start="(155, 46)" end="(155, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <AtomNode start="(155, 49)" end="(155, 50)" leading="" trailing=" " val="="/>
                          <OtherNode start="(155, 51)" end="(155, 66)" kind="«term_++_»">
                            <OtherNode start="(155, 51)" end="(155, 60)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(155, 51)" end="(155, 58)" leading="" trailing=" " raw_val="as.push" val="as.push"/>
                              <NullNode start="(155, 59)" end="(155, 60)">
                                <IdentNode start="(155, 59)" end="(155, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(155, 61)" end="(155, 63)" leading="" trailing=" " val="++"/>
                            <IdentNode start="(155, 64)" end="(155, 66)" leading="" trailing=" " raw_val="bs" val="bs"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(155, 67)" end="(155, 68)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(155, 69)" end="(155, 82)" kind="«term_=_»">
                          <IdentNode start="(155, 69)" end="(155, 71)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          <AtomNode start="(155, 72)" end="(155, 73)" leading="" trailing=" " val="="/>
                          <OtherNode start="(155, 74)" end="(155, 82)" kind="«term_++_»">
                            <IdentNode start="(155, 74)" end="(155, 76)" leading="" trailing=" " raw_val="as" val="as"/>
                            <AtomNode start="(155, 77)" end="(155, 79)" leading="" trailing=" " val="++"/>
                            <IdentNode start="(155, 80)" end="(155, 82)" leading="" trailing=" " raw_val="bs" val="bs"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(155, 83)" end="(165, 64)">
          <AtomNode start="(155, 83)" end="(155, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(155, 86)" end="(165, 64)">
            <AtomNode start="(155, 86)" end="(155, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(156, 3)" end="(165, 64)">
              <TacticTacticseq1IndentedNode start="(156, 3)" end="(165, 64)">
                <NullNode start="(156, 3)" end="(165, 64)">
                  <OtherNode start="(156, 3)" end="(156, 21)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;ys : Array α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ xs.eraseP p = ys ↔&#10;    (∀ (a : α), a ∈ xs → ¬p a = true) ∧ xs = ys ∨&#10;      ∃ a as bs, (∀ (b : α), b ∈ as → ¬p b = true) ∧ p a = true ∧ xs = as.push a ++ bs ∧ ys = as ++ bs" state_after="case mk&#10;α : Type u_1&#10;ys : Array α&#10;p : α → Bool&#10;l : List α&#10;⊢ { toList := l }.eraseP p = ys ↔&#10;    (∀ (a : α), a ∈ { toList := l } → ¬p a = true) ∧ { toList := l } = ys ∨&#10;      ∃ a as bs, (∀ (b : α), b ∈ as → ¬p b = true) ∧ p a = true ∧ { toList := l } = as.push a ++ bs ∧ ys = as ++ bs" tactic="rcases xs with ⟨l⟩">
                    <AtomNode start="(156, 3)" end="(156, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(156, 10)" end="(156, 12)">
                      <OtherNode start="(156, 10)" end="(156, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(156, 10)" end="(156, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(156, 13)" end="(156, 21)">
                      <AtomNode start="(156, 13)" end="(156, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(156, 18)" end="(156, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(156, 18)" end="(156, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(156, 18)" end="(156, 21)">
                            <OtherNode start="(156, 18)" end="(156, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(156, 18)" end="(156, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(156, 19)" end="(156, 20)">
                                <OtherNode start="(156, 19)" end="(156, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(156, 19)" end="(156, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(156, 19)" end="(156, 20)">
                                      <OtherNode start="(156, 19)" end="(156, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(156, 19)" end="(156, 20)" leading="" trailing="" raw_val="l" val="l"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(156, 20)" end="(156, 21)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(157, 3)" end="(157, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;ys : Array α&#10;p : α → Bool&#10;l : List α&#10;⊢ { toList := l }.eraseP p = ys ↔&#10;    (∀ (a : α), a ∈ { toList := l } → ¬p a = true) ∧ { toList := l } = ys ∨&#10;      ∃ a as bs, (∀ (b : α), b ∈ as → ¬p b = true) ∧ p a = true ∧ { toList := l } = as.push a ++ bs ∧ ys = as ++ bs" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ { toList := l }.eraseP p = { toList := ys } ↔&#10;    (∀ (a : α), a ∈ { toList := l } → ¬p a = true) ∧ { toList := l } = { toList := ys } ∨&#10;      ∃ a as bs,&#10;        (∀ (b : α), b ∈ as → ¬p b = true) ∧ p a = true ∧ { toList := l } = as.push a ++ bs ∧ { toList := ys } = as ++ bs" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(157, 3)" end="(157, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(157, 10)" end="(157, 12)">
                      <OtherNode start="(157, 10)" end="(157, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(157, 10)" end="(157, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(157, 13)" end="(157, 22)">
                      <AtomNode start="(157, 13)" end="(157, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(157, 18)" end="(157, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(157, 18)" end="(157, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(157, 18)" end="(157, 22)">
                            <OtherNode start="(157, 18)" end="(157, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(157, 18)" end="(157, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(157, 19)" end="(157, 21)">
                                <OtherNode start="(157, 19)" end="(157, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(157, 19)" end="(157, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(157, 19)" end="(157, 21)">
                                      <OtherNode start="(157, 19)" end="(157, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(157, 19)" end="(157, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(157, 21)" end="(157, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(158, 3)" end="(158, 28)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ { toList := l }.eraseP p = { toList := ys } ↔&#10;    (∀ (a : α), a ∈ { toList := l } → ¬p a = true) ∧ { toList := l } = { toList := ys } ∨&#10;      ∃ a as bs,&#10;        (∀ (b : α), b ∈ as → ¬p b = true) ∧ p a = true ∧ { toList := l } = as.push a ++ bs ∧ { toList := ys } = as ++ bs" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x) ↔&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList" tactic="simp [List.eraseP_eq_iff]">
                    <AtomNode start="(158, 3)" end="(158, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(158, 8)" end="(158, 28)">
                      <AtomNode start="(158, 8)" end="(158, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(158, 9)" end="(158, 27)">
                        <OtherNode start="(158, 9)" end="(158, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(158, 9)" end="(158, 27)" leading="" trailing="" raw_val="List.eraseP_eq_iff" val="List.eraseP_eq_iff" full_name="List.eraseP_eq_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(158, 27)" end="(158, 28)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(159, 3)" end="(159, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x) ↔&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList" state_after="case mk.mk.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList&#10;&#10;case mk.mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x" tactic="constructor">
                    <AtomNode start="(159, 3)" end="(159, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(160, 3)" end="(162, 68)" kind="Lean.cdot" state_before="case mk.mk.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList&#10;&#10;case mk.mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x" state_after="case mk.mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x" tactic="· rintro (h | ⟨a, l₁, h₁, h₂, ⟨l, rfl, rfl⟩⟩)&#10;  · exact Or.inl h&#10;  · exact Or.inr ⟨a, ⟨l₁⟩, by simpa using h₁, h₂, ⟨⟨l⟩, by simp⟩⟩">
                    <OtherNode start="(160, 3)" end="(160, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(160, 3)" end="(160, 4)" kind="patternIgnore">
                        <OtherNode start="(160, 3)" end="(160, 4)" kind="token.«· »">
                          <AtomNode start="(160, 3)" end="(160, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(160, 5)" end="(162, 68)">
                      <TacticTacticseq1IndentedNode start="(160, 5)" end="(162, 68)">
                        <NullNode start="(160, 5)" end="(162, 68)">
                          <OtherNode start="(160, 5)" end="(160, 48)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mk.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList" state_after="case mk.mk.mp.inl&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;h : (∀ (a : α), a ∈ l → p a = false) ∧ l = ys&#10;⊢ (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;    ∃ a as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧ p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList&#10;&#10;case mk.mk.mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l → p a_1 = false) ∧ l₁ ++ a :: l = l₁ ++ l ∨&#10;    ∃ a_1 as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧&#10;        p a_1 = true ∧ ∃ x, l₁ ++ a :: l = as.toList ++ a_1 :: x.toList ∧ l₁ ++ l = as.toList ++ x.toList" tactic="rintro (h | ⟨a, l₁, h₁, h₂, ⟨l, rfl, rfl⟩⟩)">
                            <AtomNode start="(160, 5)" end="(160, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(160, 12)" end="(160, 48)">
                              <OtherNode start="(160, 12)" end="(160, 48)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(160, 12)" end="(160, 48)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(160, 12)" end="(160, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(160, 13)" end="(160, 47)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(160, 13)" end="(160, 47)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(160, 13)" end="(160, 47)">
                                        <OtherNode start="(160, 13)" end="(160, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(160, 13)" end="(160, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </OtherNode>
                                        <AtomNode start="(160, 15)" end="(160, 16)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(160, 17)" end="(160, 47)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(160, 17)" end="(160, 18)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(160, 18)" end="(160, 46)">
                                            <OtherNode start="(160, 18)" end="(160, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(160, 18)" end="(160, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(160, 18)" end="(160, 19)">
                                                  <OtherNode start="(160, 18)" end="(160, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(160, 18)" end="(160, 19)" leading="" trailing="" raw_val="a" val="a"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(160, 19)" end="(160, 20)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(160, 21)" end="(160, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(160, 21)" end="(160, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(160, 21)" end="(160, 23)">
                                                  <OtherNode start="(160, 21)" end="(160, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(160, 21)" end="(160, 23)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(160, 23)" end="(160, 24)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(160, 25)" end="(160, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(160, 25)" end="(160, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(160, 25)" end="(160, 27)">
                                                  <OtherNode start="(160, 25)" end="(160, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(160, 25)" end="(160, 27)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(160, 27)" end="(160, 28)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(160, 29)" end="(160, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(160, 29)" end="(160, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(160, 29)" end="(160, 31)">
                                                  <OtherNode start="(160, 29)" end="(160, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(160, 29)" end="(160, 31)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(160, 31)" end="(160, 32)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(160, 33)" end="(160, 46)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(160, 33)" end="(160, 46)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(160, 33)" end="(160, 46)">
                                                  <OtherNode start="(160, 33)" end="(160, 46)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                    <AtomNode start="(160, 33)" end="(160, 34)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(160, 34)" end="(160, 45)">
                                                      <OtherNode start="(160, 34)" end="(160, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(160, 34)" end="(160, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(160, 34)" end="(160, 35)">
                                                            <OtherNode start="(160, 34)" end="(160, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(160, 34)" end="(160, 35)" leading="" trailing="" raw_val="l" val="l"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(160, 35)" end="(160, 36)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(160, 37)" end="(160, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(160, 37)" end="(160, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(160, 37)" end="(160, 40)">
                                                            <OtherNode start="(160, 37)" end="(160, 40)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(160, 37)" end="(160, 40)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(160, 40)" end="(160, 41)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(160, 42)" end="(160, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(160, 42)" end="(160, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(160, 42)" end="(160, 45)">
                                                            <OtherNode start="(160, 42)" end="(160, 45)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(160, 42)" end="(160, 45)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(160, 45)" end="(160, 46)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(160, 46)" end="(160, 47)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(160, 47)" end="(160, 48)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(161, 5)" end="(161, 21)" kind="Lean.cdot" state_before="case mk.mk.mp.inl&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;h : (∀ (a : α), a ∈ l → p a = false) ∧ l = ys&#10;⊢ (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;    ∃ a as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧ p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList&#10;&#10;case mk.mk.mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l → p a_1 = false) ∧ l₁ ++ a :: l = l₁ ++ l ∨&#10;    ∃ a_1 as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧&#10;        p a_1 = true ∧ ∃ x, l₁ ++ a :: l = as.toList ++ a_1 :: x.toList ∧ l₁ ++ l = as.toList ++ x.toList" state_after="case mk.mk.mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l → p a_1 = false) ∧ l₁ ++ a :: l = l₁ ++ l ∨&#10;    ∃ a_1 as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧&#10;        p a_1 = true ∧ ∃ x, l₁ ++ a :: l = as.toList ++ a_1 :: x.toList ∧ l₁ ++ l = as.toList ++ x.toList" tactic="· exact Or.inl h">
                            <OtherNode start="(161, 5)" end="(161, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(161, 5)" end="(161, 6)" kind="patternIgnore">
                                <OtherNode start="(161, 5)" end="(161, 6)" kind="token.«· »">
                                  <AtomNode start="(161, 5)" end="(161, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(161, 7)" end="(161, 21)">
                              <TacticTacticseq1IndentedNode start="(161, 7)" end="(161, 21)">
                                <NullNode start="(161, 7)" end="(161, 21)">
                                  <OtherNode start="(161, 7)" end="(161, 21)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mk.mp.inl&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;h : (∀ (a : α), a ∈ l → p a = false) ∧ l = ys&#10;⊢ (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;    ∃ a as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧ p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList" state_after="no goals" tactic="exact Or.inl h">
                                    <AtomNode start="(161, 7)" end="(161, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(161, 13)" end="(161, 21)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(161, 13)" end="(161, 19)" leading="" trailing=" " raw_val="Or.inl" val="Or.inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(161, 20)" end="(161, 21)">
                                        <IdentNode start="(161, 20)" end="(161, 21)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(162, 5)" end="(162, 68)" kind="Lean.cdot" state_before="case mk.mk.mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l → p a_1 = false) ∧ l₁ ++ a :: l = l₁ ++ l ∨&#10;    ∃ a_1 as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧&#10;        p a_1 = true ∧ ∃ x, l₁ ++ a :: l = as.toList ++ a_1 :: x.toList ∧ l₁ ++ l = as.toList ++ x.toList" state_after="no goals" tactic="· exact Or.inr ⟨a, ⟨l₁⟩, by simpa using h₁, h₂, ⟨⟨l⟩, by simp⟩⟩">
                            <OtherNode start="(162, 5)" end="(162, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(162, 5)" end="(162, 6)" kind="patternIgnore">
                                <OtherNode start="(162, 5)" end="(162, 6)" kind="token.«· »">
                                  <AtomNode start="(162, 5)" end="(162, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(162, 7)" end="(162, 68)">
                              <TacticTacticseq1IndentedNode start="(162, 7)" end="(162, 68)">
                                <NullNode start="(162, 7)" end="(162, 68)">
                                  <OtherNode start="(162, 7)" end="(162, 68)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mk.mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l → p a_1 = false) ∧ l₁ ++ a :: l = l₁ ++ l ∨&#10;    ∃ a_1 as,&#10;      (∀ (b : α), b ∈ as → p b = false) ∧&#10;        p a_1 = true ∧ ∃ x, l₁ ++ a :: l = as.toList ++ a_1 :: x.toList ∧ l₁ ++ l = as.toList ++ x.toList" state_after="no goals" tactic="exact Or.inr ⟨a, ⟨l₁⟩, by simpa using h₁, h₂, ⟨⟨l⟩, by simp⟩⟩">
                                    <AtomNode start="(162, 7)" end="(162, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(162, 13)" end="(162, 68)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(162, 13)" end="(162, 19)" leading="" trailing=" " raw_val="Or.inr" val="Or.inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(162, 20)" end="(162, 68)">
                                        <OtherNode start="(162, 20)" end="(162, 68)" kind="Lean.Parser.Term.anonymousCtor">
                                          <AtomNode start="(162, 20)" end="(162, 21)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(162, 21)" end="(162, 67)">
                                            <IdentNode start="(162, 21)" end="(162, 22)" leading="" trailing="" raw_val="a" val="a"/>
                                            <AtomNode start="(162, 22)" end="(162, 23)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(162, 24)" end="(162, 28)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(162, 24)" end="(162, 25)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(162, 25)" end="(162, 27)">
                                                <IdentNode start="(162, 25)" end="(162, 27)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                              </NullNode>
                                              <AtomNode start="(162, 27)" end="(162, 28)" leading="" trailing="" val="⟩"/>
                                            </OtherNode>
                                            <AtomNode start="(162, 28)" end="(162, 29)" leading="" trailing=" " val=","/>
                                            <TermBytacticNode start="(162, 30)" end="(162, 47)">
                                              <AtomNode start="(162, 30)" end="(162, 32)" leading="" trailing=" " val="by"/>
                                              <TacticTacticseqNode start="(162, 33)" end="(162, 47)">
                                                <TacticTacticseq1IndentedNode start="(162, 33)" end="(162, 47)">
                                                  <NullNode start="(162, 33)" end="(162, 47)">
                                                    <OtherNode start="(162, 33)" end="(162, 47)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ ∀ (b : α), b ∈ { toList := l₁ } → p b = false" state_after="no goals" tactic="simpa using h₁">
                                                      <AtomNode start="(162, 33)" end="(162, 38)" leading="" trailing=" " val="simpa"/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <OtherNode start="(162, 39)" end="(162, 47)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(162, 39)" end="(162, 47)">
                                                          <AtomNode start="(162, 39)" end="(162, 44)" leading="" trailing=" " val="using"/>
                                                          <IdentNode start="(162, 45)" end="(162, 47)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </TermBytacticNode>
                                            <AtomNode start="(162, 47)" end="(162, 48)" leading="" trailing=" " val=","/>
                                            <IdentNode start="(162, 49)" end="(162, 51)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            <AtomNode start="(162, 51)" end="(162, 52)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(162, 53)" end="(162, 67)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(162, 53)" end="(162, 54)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(162, 54)" end="(162, 66)">
                                                <OtherNode start="(162, 54)" end="(162, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                                  <AtomNode start="(162, 54)" end="(162, 55)" leading="" trailing="" val="⟨"/>
                                                  <NullNode start="(162, 55)" end="(162, 56)">
                                                    <IdentNode start="(162, 55)" end="(162, 56)" leading="" trailing="" raw_val="l" val="l"/>
                                                  </NullNode>
                                                  <AtomNode start="(162, 56)" end="(162, 57)" leading="" trailing="" val="⟩"/>
                                                </OtherNode>
                                                <AtomNode start="(162, 57)" end="(162, 58)" leading="" trailing=" " val=","/>
                                                <TermBytacticNode start="(162, 59)" end="(162, 66)">
                                                  <AtomNode start="(162, 59)" end="(162, 61)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(162, 62)" end="(162, 66)">
                                                    <TacticTacticseq1IndentedNode start="(162, 62)" end="(162, 66)">
                                                      <NullNode start="(162, 62)" end="(162, 66)">
                                                        <OtherNode start="(162, 62)" end="(162, 66)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ l₁ ++ a :: l = { toList := l₁ }.toList ++ a :: { toList := l }.toList ∧&#10;    l₁ ++ l = { toList := l₁ }.toList ++ { toList := l }.toList" state_after="no goals" tactic="simp">
                                                          <AtomNode start="(162, 62)" end="(162, 66)" leading="" trailing="" val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </NullNode>
                                              <AtomNode start="(162, 66)" end="(162, 67)" leading="" trailing="" val="⟩"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(162, 67)" end="(162, 68)" leading="" trailing="&#10;  " val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(163, 3)" end="(165, 64)" kind="Lean.cdot" state_before="case mk.mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x" state_after="no goals" tactic="· rintro (h | ⟨a, ⟨l₁⟩, h₁, h₂, ⟨⟨l⟩, rfl, rfl⟩⟩)&#10;  · exact Or.inl h&#10;  · exact Or.inr ⟨a, l₁, by simpa using h₁, h₂, ⟨l, by simp⟩⟩">
                    <OtherNode start="(163, 3)" end="(163, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(163, 3)" end="(163, 4)" kind="patternIgnore">
                        <OtherNode start="(163, 3)" end="(163, 4)" kind="token.«· »">
                          <AtomNode start="(163, 3)" end="(163, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(163, 5)" end="(165, 64)">
                      <TacticTacticseq1IndentedNode start="(163, 5)" end="(165, 64)">
                        <NullNode start="(163, 5)" end="(165, 64)">
                          <OtherNode start="(163, 5)" end="(163, 52)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mk.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;⊢ ((∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a as,&#10;        (∀ (b : α), b ∈ as → p b = false) ∧&#10;          p a = true ∧ ∃ x, l = as.toList ++ a :: x.toList ∧ ys = as.toList ++ x.toList) →&#10;    (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;      ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x" state_after="case mk.mk.mpr.inl&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;h : (∀ (a : α), a ∈ l → p a = false) ∧ l = ys&#10;⊢ (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;    ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x&#10;&#10;case mk.mk.mpr.inr.intro.intro.mk.intro.intro.intro.mk.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ { toList := l₁ } → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ { toList := l₁ }.toList ++ a :: { toList := l }.toList → p a_1 = false) ∧&#10;      { toList := l₁ }.toList ++ a :: { toList := l }.toList = { toList := l₁ }.toList ++ { toList := l }.toList ∨&#10;    ∃ a_1 l₁_1,&#10;      (∀ (b : α), b ∈ l₁_1 → p b = false) ∧&#10;        p a_1 = true ∧&#10;          ∃ x,&#10;            { toList := l₁ }.toList ++ a :: { toList := l }.toList = l₁_1 ++ a_1 :: x ∧&#10;              { toList := l₁ }.toList ++ { toList := l }.toList = l₁_1 ++ x" tactic="rintro (h | ⟨a, ⟨l₁⟩, h₁, h₂, ⟨⟨l⟩, rfl, rfl⟩⟩)">
                            <AtomNode start="(163, 5)" end="(163, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(163, 12)" end="(163, 52)">
                              <OtherNode start="(163, 12)" end="(163, 52)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(163, 12)" end="(163, 52)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(163, 12)" end="(163, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(163, 13)" end="(163, 51)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(163, 13)" end="(163, 51)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(163, 13)" end="(163, 51)">
                                        <OtherNode start="(163, 13)" end="(163, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(163, 13)" end="(163, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </OtherNode>
                                        <AtomNode start="(163, 15)" end="(163, 16)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(163, 17)" end="(163, 51)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(163, 17)" end="(163, 18)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(163, 18)" end="(163, 50)">
                                            <OtherNode start="(163, 18)" end="(163, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(163, 18)" end="(163, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(163, 18)" end="(163, 19)">
                                                  <OtherNode start="(163, 18)" end="(163, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(163, 18)" end="(163, 19)" leading="" trailing="" raw_val="a" val="a"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(163, 19)" end="(163, 20)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(163, 21)" end="(163, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(163, 21)" end="(163, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(163, 21)" end="(163, 25)">
                                                  <OtherNode start="(163, 21)" end="(163, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                    <AtomNode start="(163, 21)" end="(163, 22)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(163, 22)" end="(163, 24)">
                                                      <OtherNode start="(163, 22)" end="(163, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(163, 22)" end="(163, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(163, 22)" end="(163, 24)">
                                                            <OtherNode start="(163, 22)" end="(163, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(163, 22)" end="(163, 24)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(163, 24)" end="(163, 25)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(163, 25)" end="(163, 26)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(163, 27)" end="(163, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(163, 27)" end="(163, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(163, 27)" end="(163, 29)">
                                                  <OtherNode start="(163, 27)" end="(163, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(163, 27)" end="(163, 29)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(163, 29)" end="(163, 30)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(163, 31)" end="(163, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(163, 31)" end="(163, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(163, 31)" end="(163, 33)">
                                                  <OtherNode start="(163, 31)" end="(163, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(163, 31)" end="(163, 33)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(163, 33)" end="(163, 34)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(163, 35)" end="(163, 50)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(163, 35)" end="(163, 50)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(163, 35)" end="(163, 50)">
                                                  <OtherNode start="(163, 35)" end="(163, 50)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                    <AtomNode start="(163, 35)" end="(163, 36)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(163, 36)" end="(163, 49)">
                                                      <OtherNode start="(163, 36)" end="(163, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(163, 36)" end="(163, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(163, 36)" end="(163, 39)">
                                                            <OtherNode start="(163, 36)" end="(163, 39)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(163, 36)" end="(163, 37)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(163, 37)" end="(163, 38)">
                                                            <OtherNode start="(163, 37)" end="(163, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(163, 37)" end="(163, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(163, 37)" end="(163, 38)">
                                                            <OtherNode start="(163, 37)" end="(163, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(163, 37)" end="(163, 38)" leading="" trailing="" raw_val="l" val="l"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(163, 38)" end="(163, 39)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(163, 39)" end="(163, 40)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(163, 41)" end="(163, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(163, 41)" end="(163, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(163, 41)" end="(163, 44)">
                                                            <OtherNode start="(163, 41)" end="(163, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(163, 41)" end="(163, 44)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(163, 44)" end="(163, 45)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(163, 46)" end="(163, 49)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(163, 46)" end="(163, 49)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(163, 46)" end="(163, 49)">
                                                            <OtherNode start="(163, 46)" end="(163, 49)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(163, 46)" end="(163, 49)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(163, 49)" end="(163, 50)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(163, 50)" end="(163, 51)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(163, 51)" end="(163, 52)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(164, 5)" end="(164, 21)" kind="Lean.cdot" state_before="case mk.mk.mpr.inl&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;h : (∀ (a : α), a ∈ l → p a = false) ∧ l = ys&#10;⊢ (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;    ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x&#10;&#10;case mk.mk.mpr.inr.intro.intro.mk.intro.intro.intro.mk.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ { toList := l₁ } → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ { toList := l₁ }.toList ++ a :: { toList := l }.toList → p a_1 = false) ∧&#10;      { toList := l₁ }.toList ++ a :: { toList := l }.toList = { toList := l₁ }.toList ++ { toList := l }.toList ∨&#10;    ∃ a_1 l₁_1,&#10;      (∀ (b : α), b ∈ l₁_1 → p b = false) ∧&#10;        p a_1 = true ∧&#10;          ∃ x,&#10;            { toList := l₁ }.toList ++ a :: { toList := l }.toList = l₁_1 ++ a_1 :: x ∧&#10;              { toList := l₁ }.toList ++ { toList := l }.toList = l₁_1 ++ x" state_after="case mk.mk.mpr.inr.intro.intro.mk.intro.intro.intro.mk.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ { toList := l₁ } → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ { toList := l₁ }.toList ++ a :: { toList := l }.toList → p a_1 = false) ∧&#10;      { toList := l₁ }.toList ++ a :: { toList := l }.toList = { toList := l₁ }.toList ++ { toList := l }.toList ∨&#10;    ∃ a_1 l₁_1,&#10;      (∀ (b : α), b ∈ l₁_1 → p b = false) ∧&#10;        p a_1 = true ∧&#10;          ∃ x,&#10;            { toList := l₁ }.toList ++ a :: { toList := l }.toList = l₁_1 ++ a_1 :: x ∧&#10;              { toList := l₁ }.toList ++ { toList := l }.toList = l₁_1 ++ x" tactic="· exact Or.inl h">
                            <OtherNode start="(164, 5)" end="(164, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(164, 5)" end="(164, 6)" kind="patternIgnore">
                                <OtherNode start="(164, 5)" end="(164, 6)" kind="token.«· »">
                                  <AtomNode start="(164, 5)" end="(164, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(164, 7)" end="(164, 21)">
                              <TacticTacticseq1IndentedNode start="(164, 7)" end="(164, 21)">
                                <NullNode start="(164, 7)" end="(164, 21)">
                                  <OtherNode start="(164, 7)" end="(164, 21)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mk.mpr.inl&#10;α : Type u_1&#10;p : α → Bool&#10;l ys : List α&#10;h : (∀ (a : α), a ∈ l → p a = false) ∧ l = ys&#10;⊢ (∀ (a : α), a ∈ l → p a = false) ∧ l = ys ∨&#10;    ∃ a l₁, (∀ (b : α), b ∈ l₁ → p b = false) ∧ p a = true ∧ ∃ x, l = l₁ ++ a :: x ∧ ys = l₁ ++ x" state_after="no goals" tactic="exact Or.inl h">
                                    <AtomNode start="(164, 7)" end="(164, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(164, 13)" end="(164, 21)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(164, 13)" end="(164, 19)" leading="" trailing=" " raw_val="Or.inl" val="Or.inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(164, 20)" end="(164, 21)">
                                        <IdentNode start="(164, 20)" end="(164, 21)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(165, 5)" end="(165, 64)" kind="Lean.cdot" state_before="case mk.mk.mpr.inr.intro.intro.mk.intro.intro.intro.mk.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ { toList := l₁ } → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ { toList := l₁ }.toList ++ a :: { toList := l }.toList → p a_1 = false) ∧&#10;      { toList := l₁ }.toList ++ a :: { toList := l }.toList = { toList := l₁ }.toList ++ { toList := l }.toList ∨&#10;    ∃ a_1 l₁_1,&#10;      (∀ (b : α), b ∈ l₁_1 → p b = false) ∧&#10;        p a_1 = true ∧&#10;          ∃ x,&#10;            { toList := l₁ }.toList ++ a :: { toList := l }.toList = l₁_1 ++ a_1 :: x ∧&#10;              { toList := l₁ }.toList ++ { toList := l }.toList = l₁_1 ++ x" state_after="no goals" tactic="· exact Or.inr ⟨a, l₁, by simpa using h₁, h₂, ⟨l, by simp⟩⟩">
                            <OtherNode start="(165, 5)" end="(165, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(165, 5)" end="(165, 6)" kind="patternIgnore">
                                <OtherNode start="(165, 5)" end="(165, 6)" kind="token.«· »">
                                  <AtomNode start="(165, 5)" end="(165, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(165, 7)" end="(165, 64)">
                              <TacticTacticseq1IndentedNode start="(165, 7)" end="(165, 64)">
                                <NullNode start="(165, 7)" end="(165, 64)">
                                  <OtherNode start="(165, 7)" end="(165, 64)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mk.mpr.inr.intro.intro.mk.intro.intro.intro.mk.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ { toList := l₁ } → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ { toList := l₁ }.toList ++ a :: { toList := l }.toList → p a_1 = false) ∧&#10;      { toList := l₁ }.toList ++ a :: { toList := l }.toList = { toList := l₁ }.toList ++ { toList := l }.toList ∨&#10;    ∃ a_1 l₁_1,&#10;      (∀ (b : α), b ∈ l₁_1 → p b = false) ∧&#10;        p a_1 = true ∧&#10;          ∃ x,&#10;            { toList := l₁ }.toList ++ a :: { toList := l }.toList = l₁_1 ++ a_1 :: x ∧&#10;              { toList := l₁ }.toList ++ { toList := l }.toList = l₁_1 ++ x" state_after="no goals" tactic="exact Or.inr ⟨a, l₁, by simpa using h₁, h₂, ⟨l, by simp⟩⟩">
                                    <AtomNode start="(165, 7)" end="(165, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(165, 13)" end="(165, 64)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(165, 13)" end="(165, 19)" leading="" trailing=" " raw_val="Or.inr" val="Or.inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(165, 20)" end="(165, 64)">
                                        <OtherNode start="(165, 20)" end="(165, 64)" kind="Lean.Parser.Term.anonymousCtor">
                                          <AtomNode start="(165, 20)" end="(165, 21)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(165, 21)" end="(165, 63)">
                                            <IdentNode start="(165, 21)" end="(165, 22)" leading="" trailing="" raw_val="a" val="a"/>
                                            <AtomNode start="(165, 22)" end="(165, 23)" leading="" trailing=" " val=","/>
                                            <IdentNode start="(165, 24)" end="(165, 26)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                            <AtomNode start="(165, 26)" end="(165, 27)" leading="" trailing=" " val=","/>
                                            <TermBytacticNode start="(165, 28)" end="(165, 45)">
                                              <AtomNode start="(165, 28)" end="(165, 30)" leading="" trailing=" " val="by"/>
                                              <TacticTacticseqNode start="(165, 31)" end="(165, 45)">
                                                <TacticTacticseq1IndentedNode start="(165, 31)" end="(165, 45)">
                                                  <NullNode start="(165, 31)" end="(165, 45)">
                                                    <OtherNode start="(165, 31)" end="(165, 45)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ { toList := l₁ } → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ ∀ (b : α), b ∈ l₁ → p b = false" state_after="no goals" tactic="simpa using h₁">
                                                      <AtomNode start="(165, 31)" end="(165, 36)" leading="" trailing=" " val="simpa"/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <OtherNode start="(165, 37)" end="(165, 45)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(165, 37)" end="(165, 45)">
                                                          <AtomNode start="(165, 37)" end="(165, 42)" leading="" trailing=" " val="using"/>
                                                          <IdentNode start="(165, 43)" end="(165, 45)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </TermBytacticNode>
                                            <AtomNode start="(165, 45)" end="(165, 46)" leading="" trailing=" " val=","/>
                                            <IdentNode start="(165, 47)" end="(165, 49)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            <AtomNode start="(165, 49)" end="(165, 50)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(165, 51)" end="(165, 63)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(165, 51)" end="(165, 52)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(165, 52)" end="(165, 62)">
                                                <IdentNode start="(165, 52)" end="(165, 53)" leading="" trailing="" raw_val="l" val="l"/>
                                                <AtomNode start="(165, 53)" end="(165, 54)" leading="" trailing=" " val=","/>
                                                <TermBytacticNode start="(165, 55)" end="(165, 62)">
                                                  <AtomNode start="(165, 55)" end="(165, 57)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(165, 58)" end="(165, 62)">
                                                    <TacticTacticseq1IndentedNode start="(165, 58)" end="(165, 62)">
                                                      <NullNode start="(165, 58)" end="(165, 62)">
                                                        <OtherNode start="(165, 58)" end="(165, 62)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ : List α&#10;h₁ : ∀ (b : α), b ∈ { toList := l₁ } → p b = false&#10;h₂ : p a = true&#10;l : List α&#10;⊢ { toList := l₁ }.toList ++ a :: { toList := l }.toList = l₁ ++ a :: l ∧&#10;    { toList := l₁ }.toList ++ { toList := l }.toList = l₁ ++ l" state_after="no goals" tactic="simp">
                                                          <AtomNode start="(165, 58)" end="(165, 62)" leading="" trailing="" val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </NullNode>
                                              <AtomNode start="(165, 62)" end="(165, 63)" leading="" trailing="" val="⟩"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(165, 63)" end="(165, 64)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(167, 1)" end="(170, 50)" name="eraseP_comm" full_name="Array.eraseP_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(167, 1)" end="(170, 50)" name="eraseP_comm" full_name="Array.eraseP_comm" _is_private_decl="False">
        <AtomNode start="(167, 1)" end="(167, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(167, 9)" end="(167, 20)">
          <IdentNode start="(167, 9)" end="(167, 20)" leading="" trailing=" " raw_val="eraseP_comm" val="eraseP_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(167, 21)" end="(168, 52)">
          <NullNode start="(167, 21)" end="(167, 65)">
            <OtherNode start="(167, 21)" end="(167, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 21)" end="(167, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 22)" end="(167, 24)">
                <IdentNode start="(167, 22)" end="(167, 24)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(167, 25)" end="(167, 34)">
                <AtomNode start="(167, 25)" end="(167, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 27)" end="(167, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(167, 27)" end="(167, 32)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(167, 33)" end="(167, 34)">
                    <IdentNode start="(167, 33)" end="(167, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(167, 34)" end="(167, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(167, 36)" end="(167, 65)">
              <AtomNode start="(167, 36)" end="(167, 37)" leading="" trailing="" val="("/>
              <NullNode start="(167, 37)" end="(167, 38)">
                <IdentNode start="(167, 37)" end="(167, 38)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(167, 39)" end="(167, 64)">
                <AtomNode start="(167, 39)" end="(167, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 41)" end="(167, 64)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(167, 41)" end="(167, 42)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(167, 43)" end="(167, 44)">
                    <IdentNode start="(167, 43)" end="(167, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(167, 45)" end="(167, 49)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(167, 45)" end="(167, 46)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(167, 47)" end="(167, 49)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(167, 49)" end="(167, 50)" leading="" trailing=" " val=","/>
                  <OtherNode start="(167, 51)" end="(167, 64)" kind="«term_∨_»">
                    <OtherNode start="(167, 51)" end="(167, 56)" kind="«term¬_»">
                      <AtomNode start="(167, 51)" end="(167, 52)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(167, 53)" end="(167, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(167, 53)" end="(167, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(167, 55)" end="(167, 56)">
                          <IdentNode start="(167, 55)" end="(167, 56)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(167, 57)" end="(167, 58)" leading="" trailing=" " val="∨"/>
                    <OtherNode start="(167, 59)" end="(167, 64)" kind="«term¬_»">
                      <AtomNode start="(167, 59)" end="(167, 60)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(167, 61)" end="(167, 64)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(167, 61)" end="(167, 62)" leading="" trailing=" " raw_val="q" val="q"/>
                        <NullNode start="(167, 63)" end="(167, 64)">
                          <IdentNode start="(167, 63)" end="(167, 64)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(167, 64)" end="(167, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(167, 66)" end="(168, 52)">
            <AtomNode start="(167, 66)" end="(167, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(168, 5)" end="(168, 52)" kind="«term_=_»">
              <OtherNode start="(168, 5)" end="(168, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(168, 5)" end="(168, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(168, 5)" end="(168, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(168, 5)" end="(168, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(168, 6)" end="(168, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(168, 6)" end="(168, 15)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                      <NullNode start="(168, 16)" end="(168, 17)">
                        <IdentNode start="(168, 16)" end="(168, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(168, 17)" end="(168, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(168, 18)" end="(168, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(168, 19)" end="(168, 25)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(168, 26)" end="(168, 27)">
                  <IdentNode start="(168, 26)" end="(168, 27)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(168, 28)" end="(168, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(168, 30)" end="(168, 52)" kind="Lean.Parser.Term.app">
                <OtherNode start="(168, 30)" end="(168, 50)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(168, 30)" end="(168, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(168, 30)" end="(168, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(168, 31)" end="(168, 42)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(168, 31)" end="(168, 40)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                      <NullNode start="(168, 41)" end="(168, 42)">
                        <IdentNode start="(168, 41)" end="(168, 42)" leading="" trailing="" raw_val="q" val="q"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(168, 42)" end="(168, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(168, 43)" end="(168, 44)" leading="" trailing="" val="."/>
                  <IdentNode start="(168, 44)" end="(168, 50)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(168, 51)" end="(168, 52)">
                  <IdentNode start="(168, 51)" end="(168, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(168, 53)" end="(170, 50)">
          <AtomNode start="(168, 53)" end="(168, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(168, 56)" end="(170, 50)">
            <AtomNode start="(168, 56)" end="(168, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(169, 3)" end="(170, 50)">
              <TacticTacticseq1IndentedNode start="(169, 3)" end="(170, 50)">
                <NullNode start="(169, 3)" end="(170, 50)">
                  <OtherNode start="(169, 3)" end="(169, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;p q : α → Bool&#10;xs : Array α&#10;h : ∀ (a : α), a ∈ xs → ¬p a = true ∨ ¬q a = true&#10;⊢ (xs.eraseP p).eraseP q = (xs.eraseP q).eraseP p" state_after="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → ¬p a = true ∨ ¬q a = true&#10;⊢ ({ toList := xs }.eraseP p).eraseP q = ({ toList := xs }.eraseP q).eraseP p" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(169, 3)" end="(169, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(169, 10)" end="(169, 12)">
                      <OtherNode start="(169, 10)" end="(169, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(169, 10)" end="(169, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(169, 13)" end="(169, 22)">
                      <AtomNode start="(169, 13)" end="(169, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(169, 18)" end="(169, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(169, 18)" end="(169, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(169, 18)" end="(169, 22)">
                            <OtherNode start="(169, 18)" end="(169, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(169, 18)" end="(169, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(169, 19)" end="(169, 21)">
                                <OtherNode start="(169, 19)" end="(169, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(169, 19)" end="(169, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(169, 19)" end="(169, 21)">
                                      <OtherNode start="(169, 19)" end="(169, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(169, 19)" end="(169, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(169, 21)" end="(169, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(170, 3)" end="(170, 50)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → ¬p a = true ∨ ¬q a = true&#10;⊢ ({ toList := xs }.eraseP p).eraseP q = ({ toList := xs }.eraseP q).eraseP p" state_after="no goals" tactic="simpa using List.eraseP_comm (by simpa using h)">
                    <AtomNode start="(170, 3)" end="(170, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(170, 9)" end="(170, 50)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(170, 9)" end="(170, 50)">
                        <AtomNode start="(170, 9)" end="(170, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(170, 15)" end="(170, 50)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(170, 15)" end="(170, 31)" leading="" trailing=" " raw_val="List.eraseP_comm" val="List.eraseP_comm" full_name="List.eraseP_comm" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(170, 32)" end="(170, 50)">
                            <OtherNode start="(170, 32)" end="(170, 50)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(170, 32)" end="(170, 33)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(170, 33)" end="(170, 49)">
                                <AtomNode start="(170, 33)" end="(170, 35)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(170, 36)" end="(170, 49)">
                                  <TacticTacticseq1IndentedNode start="(170, 36)" end="(170, 49)">
                                    <NullNode start="(170, 36)" end="(170, 49)">
                                      <OtherNode start="(170, 36)" end="(170, 49)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p q : α → Bool&#10;xs : List α&#10;h : ∀ (a : α), a ∈ { toList := xs } → ¬p a = true ∨ ¬q a = true&#10;⊢ ∀ (a : α), a ∈ xs → ¬p a = true ∨ ¬q a = true" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(170, 36)" end="(170, 41)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(170, 42)" end="(170, 49)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(170, 42)" end="(170, 49)">
                                            <AtomNode start="(170, 42)" end="(170, 47)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(170, 48)" end="(170, 49)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(170, 49)" end="(170, 50)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(172, 1)" end="(172, 17)" comment="### erase -/">
      <AtomNode start="(172, 1)" end="(172, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(172, 5)" end="(172, 17)" leading="" trailing="&#10;&#10;" val="### erase -/"/>
    </CommandModuledocNode>
    <CommandSectionNode start="(174, 1)" end="(174, 14)" name="erase">
      <AtomNode start="(174, 1)" end="(174, 8)" leading="" trailing=" " val="section"/>
      <NullNode start="(174, 9)" end="(174, 14)">
        <IdentNode start="(174, 9)" end="(174, 14)" leading="" trailing="&#10;" raw_val="erase" val="erase"/>
      </NullNode>
    </CommandSectionNode>
    <OtherNode start="(175, 1)" end="(175, 17)" kind="Lean.Parser.Command.variable">
      <AtomNode start="(175, 1)" end="(175, 9)" leading="" trailing=" " val="variable"/>
      <NullNode start="(175, 10)" end="(175, 17)">
        <OtherNode start="(175, 10)" end="(175, 17)" kind="Lean.Parser.Term.instBinder">
          <AtomNode start="(175, 10)" end="(175, 11)" leading="" trailing="" val="["/>
          <NullNode/>
          <OtherNode start="(175, 11)" end="(175, 16)" kind="Lean.Parser.Term.app">
            <IdentNode start="(175, 11)" end="(175, 14)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(175, 15)" end="(175, 16)">
              <IdentNode start="(175, 15)" end="(175, 16)" leading="" trailing="" raw_val="α" val="α"/>
            </NullNode>
          </OtherNode>
          <AtomNode start="(175, 16)" end="(175, 17)" leading="" trailing="&#10;&#10;" val="]"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(177, 1)" end="(179, 50)" name="erase_of_not_mem" full_name="Array.erase_of_not_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(177, 1)" end="(179, 50)" name="erase_of_not_mem" full_name="Array.erase_of_not_mem" _is_private_decl="False">
        <AtomNode start="(177, 1)" end="(177, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(177, 9)" end="(177, 25)">
          <IdentNode start="(177, 9)" end="(177, 25)" leading="" trailing=" " raw_val="erase_of_not_mem" val="erase_of_not_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(177, 26)" end="(177, 93)">
          <NullNode start="(177, 26)" end="(177, 75)">
            <OtherNode start="(177, 26)" end="(177, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(177, 26)" end="(177, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(177, 27)" end="(177, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(177, 27)" end="(177, 36)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(177, 37)" end="(177, 38)">
                  <IdentNode start="(177, 37)" end="(177, 38)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(177, 38)" end="(177, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(177, 40)" end="(177, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(177, 40)" end="(177, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(177, 41)" end="(177, 42)">
                <IdentNode start="(177, 41)" end="(177, 42)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(177, 43)" end="(177, 46)">
                <AtomNode start="(177, 43)" end="(177, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(177, 45)" end="(177, 46)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(177, 46)" end="(177, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(177, 48)" end="(177, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(177, 48)" end="(177, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(177, 49)" end="(177, 51)">
                <IdentNode start="(177, 49)" end="(177, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(177, 52)" end="(177, 61)">
                <AtomNode start="(177, 52)" end="(177, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(177, 54)" end="(177, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(177, 54)" end="(177, 59)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(177, 60)" end="(177, 61)">
                    <IdentNode start="(177, 60)" end="(177, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(177, 61)" end="(177, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(177, 63)" end="(177, 75)">
              <AtomNode start="(177, 63)" end="(177, 64)" leading="" trailing="" val="("/>
              <NullNode start="(177, 64)" end="(177, 65)">
                <IdentNode start="(177, 64)" end="(177, 65)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(177, 66)" end="(177, 74)">
                <AtomNode start="(177, 66)" end="(177, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(177, 68)" end="(177, 74)" kind="«term_∉_»">
                  <IdentNode start="(177, 68)" end="(177, 69)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(177, 70)" end="(177, 71)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(177, 72)" end="(177, 74)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(177, 74)" end="(177, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(177, 76)" end="(177, 93)">
            <AtomNode start="(177, 76)" end="(177, 77)" leading="" trailing=" " val=":"/>
            <OtherNode start="(177, 78)" end="(177, 93)" kind="«term_=_»">
              <OtherNode start="(177, 78)" end="(177, 88)" kind="Lean.Parser.Term.app">
                <IdentNode start="(177, 78)" end="(177, 86)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                <NullNode start="(177, 87)" end="(177, 88)">
                  <IdentNode start="(177, 87)" end="(177, 88)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(177, 89)" end="(177, 90)" leading="" trailing=" " val="="/>
              <IdentNode start="(177, 91)" end="(177, 93)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(177, 94)" end="(179, 50)">
          <AtomNode start="(177, 94)" end="(177, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(177, 97)" end="(179, 50)">
            <AtomNode start="(177, 97)" end="(177, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(178, 3)" end="(179, 50)">
              <TacticTacticseq1IndentedNode start="(178, 3)" end="(179, 50)">
                <NullNode start="(178, 3)" end="(179, 50)">
                  <OtherNode start="(178, 3)" end="(178, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ xs.erase a = xs" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ { toList := xs }.erase a = { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(178, 3)" end="(178, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(178, 10)" end="(178, 12)">
                      <OtherNode start="(178, 10)" end="(178, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(178, 10)" end="(178, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(178, 13)" end="(178, 22)">
                      <AtomNode start="(178, 13)" end="(178, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(178, 18)" end="(178, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(178, 18)" end="(178, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(178, 18)" end="(178, 22)">
                            <OtherNode start="(178, 18)" end="(178, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(178, 18)" end="(178, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(178, 19)" end="(178, 21)">
                                <OtherNode start="(178, 19)" end="(178, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(178, 19)" end="(178, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(178, 19)" end="(178, 21)">
                                      <OtherNode start="(178, 19)" end="(178, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(178, 19)" end="(178, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(178, 21)" end="(178, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(179, 3)" end="(179, 50)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ { toList := xs }.erase a = { toList := xs }" state_after="no goals" tactic="simp [List.erase_of_not_mem (by simpa using h)]">
                    <AtomNode start="(179, 3)" end="(179, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(179, 8)" end="(179, 50)">
                      <AtomNode start="(179, 8)" end="(179, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(179, 9)" end="(179, 49)">
                        <OtherNode start="(179, 9)" end="(179, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(179, 9)" end="(179, 49)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(179, 9)" end="(179, 30)" leading="" trailing=" " raw_val="List.erase_of_not_mem" val="List.erase_of_not_mem" full_name="List.erase_of_not_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                            <NullNode start="(179, 31)" end="(179, 49)">
                              <OtherNode start="(179, 31)" end="(179, 49)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(179, 31)" end="(179, 32)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(179, 32)" end="(179, 48)">
                                  <AtomNode start="(179, 32)" end="(179, 34)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(179, 35)" end="(179, 48)">
                                    <TacticTacticseq1IndentedNode start="(179, 35)" end="(179, 48)">
                                      <NullNode start="(179, 35)" end="(179, 48)">
                                        <OtherNode start="(179, 35)" end="(179, 48)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ ¬?m.32333 ∈ ?m.32334" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(179, 35)" end="(179, 40)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(179, 41)" end="(179, 48)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(179, 41)" end="(179, 48)">
                                              <AtomNode start="(179, 41)" end="(179, 46)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(179, 47)" end="(179, 48)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(179, 48)" end="(179, 49)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(179, 49)" end="(179, 50)" leading="" trailing="&#10;&#10;-- The arguments are intentionally explicit.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(182, 1)" end="(184, 31)" name="erase_eq_eraseP'" full_name="Array.erase_eq_eraseP'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(182, 1)" end="(184, 31)" name="erase_eq_eraseP'" full_name="Array.erase_eq_eraseP'" _is_private_decl="False">
        <AtomNode start="(182, 1)" end="(182, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(182, 9)" end="(182, 25)">
          <IdentNode start="(182, 9)" end="(182, 25)" leading="" trailing=" " raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(182, 26)" end="(182, 82)">
          <NullNode start="(182, 26)" end="(182, 48)">
            <TermExplicitbinderNode start="(182, 26)" end="(182, 33)">
              <AtomNode start="(182, 26)" end="(182, 27)" leading="" trailing="" val="("/>
              <NullNode start="(182, 27)" end="(182, 28)">
                <IdentNode start="(182, 27)" end="(182, 28)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(182, 29)" end="(182, 32)">
                <AtomNode start="(182, 29)" end="(182, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(182, 31)" end="(182, 32)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(182, 32)" end="(182, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(182, 34)" end="(182, 48)">
              <AtomNode start="(182, 34)" end="(182, 35)" leading="" trailing="" val="("/>
              <NullNode start="(182, 35)" end="(182, 37)">
                <IdentNode start="(182, 35)" end="(182, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(182, 38)" end="(182, 47)">
                <AtomNode start="(182, 38)" end="(182, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(182, 40)" end="(182, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(182, 40)" end="(182, 45)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(182, 46)" end="(182, 47)">
                    <IdentNode start="(182, 46)" end="(182, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(182, 47)" end="(182, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(182, 49)" end="(182, 82)">
            <AtomNode start="(182, 49)" end="(182, 50)" leading="" trailing=" " val=":"/>
            <OtherNode start="(182, 51)" end="(182, 82)" kind="«term_=_»">
              <OtherNode start="(182, 51)" end="(182, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(182, 51)" end="(182, 59)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                <NullNode start="(182, 60)" end="(182, 61)">
                  <IdentNode start="(182, 60)" end="(182, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(182, 62)" end="(182, 63)" leading="" trailing=" " val="="/>
              <OtherNode start="(182, 64)" end="(182, 82)" kind="Lean.Parser.Term.app">
                <IdentNode start="(182, 64)" end="(182, 73)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                <NullNode start="(182, 74)" end="(182, 82)">
                  <OtherNode start="(182, 74)" end="(182, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(182, 74)" end="(182, 75)" leading="" trailing="" val="("/>
                    <OtherNode start="(182, 75)" end="(182, 81)" kind="«term_==_»">
                      <OtherNode start="(182, 75)" end="(182, 76)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(182, 75)" end="(182, 76)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(182, 77)" end="(182, 79)" leading="" trailing=" " val="=="/>
                      <IdentNode start="(182, 80)" end="(182, 81)" leading="" trailing="" raw_val="a" val="a"/>
                    </OtherNode>
                    <AtomNode start="(182, 81)" end="(182, 82)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(182, 83)" end="(184, 31)">
          <AtomNode start="(182, 83)" end="(182, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(182, 86)" end="(184, 31)">
            <AtomNode start="(182, 86)" end="(182, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(183, 3)" end="(184, 31)">
              <TacticTacticseq1IndentedNode start="(183, 3)" end="(184, 31)">
                <NullNode start="(183, 3)" end="(184, 31)">
                  <OtherNode start="(183, 3)" end="(183, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;xs : Array α&#10;⊢ xs.erase a = xs.eraseP fun x =&amp;gt; x == a" state_after="case mk&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseP fun x =&amp;gt; x == a" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(183, 3)" end="(183, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(183, 10)" end="(183, 12)">
                      <OtherNode start="(183, 10)" end="(183, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(183, 10)" end="(183, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(183, 13)" end="(183, 22)">
                      <AtomNode start="(183, 13)" end="(183, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(183, 18)" end="(183, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(183, 18)" end="(183, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(183, 18)" end="(183, 22)">
                            <OtherNode start="(183, 18)" end="(183, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(183, 18)" end="(183, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(183, 19)" end="(183, 21)">
                                <OtherNode start="(183, 19)" end="(183, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(183, 19)" end="(183, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(183, 19)" end="(183, 21)">
                                      <OtherNode start="(183, 19)" end="(183, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(183, 19)" end="(183, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(183, 21)" end="(183, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(184, 3)" end="(184, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseP fun x =&amp;gt; x == a" state_after="no goals" tactic="simp [List.erase_eq_eraseP']">
                    <AtomNode start="(184, 3)" end="(184, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(184, 8)" end="(184, 31)">
                      <AtomNode start="(184, 8)" end="(184, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(184, 9)" end="(184, 30)">
                        <OtherNode start="(184, 9)" end="(184, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(184, 9)" end="(184, 30)" leading="" trailing="" raw_val="List.erase_eq_eraseP'" val="List.erase_eq_eraseP'" full_name="List.erase_eq_eraseP'" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(184, 30)" end="(184, 31)" leading="" trailing="&#10;&#10;-- The arguments are intentionally explicit.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(187, 1)" end="(189, 30)" name="erase_eq_eraseP" full_name="Array.erase_eq_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(187, 1)" end="(189, 30)" name="erase_eq_eraseP" full_name="Array.erase_eq_eraseP" _is_private_decl="False">
        <AtomNode start="(187, 1)" end="(187, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(187, 9)" end="(187, 24)">
          <IdentNode start="(187, 9)" end="(187, 24)" leading="" trailing=" " raw_val="erase_eq_eraseP" val="erase_eq_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(187, 25)" end="(187, 95)">
          <NullNode start="(187, 25)" end="(187, 61)">
            <OtherNode start="(187, 25)" end="(187, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(187, 25)" end="(187, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(187, 26)" end="(187, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(187, 26)" end="(187, 35)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(187, 36)" end="(187, 37)">
                  <IdentNode start="(187, 36)" end="(187, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(187, 37)" end="(187, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(187, 39)" end="(187, 46)">
              <AtomNode start="(187, 39)" end="(187, 40)" leading="" trailing="" val="("/>
              <NullNode start="(187, 40)" end="(187, 41)">
                <IdentNode start="(187, 40)" end="(187, 41)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(187, 42)" end="(187, 45)">
                <AtomNode start="(187, 42)" end="(187, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(187, 44)" end="(187, 45)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(187, 45)" end="(187, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(187, 47)" end="(187, 61)">
              <AtomNode start="(187, 47)" end="(187, 48)" leading="" trailing="" val="("/>
              <NullNode start="(187, 48)" end="(187, 50)">
                <IdentNode start="(187, 48)" end="(187, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(187, 51)" end="(187, 60)">
                <AtomNode start="(187, 51)" end="(187, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(187, 53)" end="(187, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(187, 53)" end="(187, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(187, 59)" end="(187, 60)">
                    <IdentNode start="(187, 59)" end="(187, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(187, 60)" end="(187, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(187, 62)" end="(187, 95)">
            <AtomNode start="(187, 62)" end="(187, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(187, 64)" end="(187, 95)" kind="«term_=_»">
              <OtherNode start="(187, 64)" end="(187, 74)" kind="Lean.Parser.Term.app">
                <IdentNode start="(187, 64)" end="(187, 72)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                <NullNode start="(187, 73)" end="(187, 74)">
                  <IdentNode start="(187, 73)" end="(187, 74)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(187, 75)" end="(187, 76)" leading="" trailing=" " val="="/>
              <OtherNode start="(187, 77)" end="(187, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(187, 77)" end="(187, 86)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                <NullNode start="(187, 87)" end="(187, 95)">
                  <OtherNode start="(187, 87)" end="(187, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(187, 87)" end="(187, 88)" leading="" trailing="" val="("/>
                    <OtherNode start="(187, 88)" end="(187, 94)" kind="«term_==_»">
                      <IdentNode start="(187, 88)" end="(187, 89)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(187, 90)" end="(187, 92)" leading="" trailing=" " val="=="/>
                      <OtherNode start="(187, 93)" end="(187, 94)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(187, 93)" end="(187, 94)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(187, 94)" end="(187, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(187, 96)" end="(189, 30)">
          <AtomNode start="(187, 96)" end="(187, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(187, 99)" end="(189, 30)">
            <AtomNode start="(187, 99)" end="(187, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(188, 3)" end="(189, 30)">
              <TacticTacticseq1IndentedNode start="(188, 3)" end="(189, 30)">
                <NullNode start="(188, 3)" end="(189, 30)">
                  <OtherNode start="(188, 3)" end="(188, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ xs.erase a = xs.eraseP fun x =&amp;gt; a == x" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseP fun x =&amp;gt; a == x" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(188, 3)" end="(188, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(188, 10)" end="(188, 12)">
                      <OtherNode start="(188, 10)" end="(188, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(188, 10)" end="(188, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(188, 13)" end="(188, 22)">
                      <AtomNode start="(188, 13)" end="(188, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(188, 18)" end="(188, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(188, 18)" end="(188, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(188, 18)" end="(188, 22)">
                            <OtherNode start="(188, 18)" end="(188, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(188, 18)" end="(188, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(188, 19)" end="(188, 21)">
                                <OtherNode start="(188, 19)" end="(188, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(188, 19)" end="(188, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(188, 19)" end="(188, 21)">
                                      <OtherNode start="(188, 19)" end="(188, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(188, 19)" end="(188, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(188, 21)" end="(188, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(189, 3)" end="(189, 30)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseP fun x =&amp;gt; a == x" state_after="no goals" tactic="simp [List.erase_eq_eraseP]">
                    <AtomNode start="(189, 3)" end="(189, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(189, 8)" end="(189, 30)">
                      <AtomNode start="(189, 8)" end="(189, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(189, 9)" end="(189, 29)">
                        <OtherNode start="(189, 9)" end="(189, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(189, 9)" end="(189, 29)" leading="" trailing="" raw_val="List.erase_eq_eraseP" val="List.erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(189, 29)" end="(189, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(191, 1)" end="(194, 31)" name="erase_eq_empty_iff" full_name="Array.erase_eq_empty_iff">
      <CommandDeclmodifiersNode start="(191, 1)" end="(191, 8)">
        <NullNode/>
        <NullNode start="(191, 1)" end="(191, 8)">
          <OtherNode start="(191, 1)" end="(191, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(191, 1)" end="(191, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(191, 3)" end="(191, 7)">
              <OtherNode start="(191, 3)" end="(191, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(191, 3)" end="(191, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(191, 3)" end="(191, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(191, 7)" end="(191, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(191, 9)" end="(194, 31)" name="erase_eq_empty_iff" full_name="Array.erase_eq_empty_iff" _is_private_decl="False">
        <AtomNode start="(191, 9)" end="(191, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(191, 17)" end="(191, 35)">
          <IdentNode start="(191, 17)" end="(191, 35)" leading="" trailing=" " raw_val="erase_eq_empty_iff" val="erase_eq_empty_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(191, 36)" end="(192, 44)">
          <NullNode start="(191, 36)" end="(191, 72)">
            <OtherNode start="(191, 36)" end="(191, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(191, 36)" end="(191, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(191, 37)" end="(191, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(191, 37)" end="(191, 46)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(191, 47)" end="(191, 48)">
                  <IdentNode start="(191, 47)" end="(191, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(191, 48)" end="(191, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(191, 50)" end="(191, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(191, 50)" end="(191, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(191, 51)" end="(191, 53)">
                <IdentNode start="(191, 51)" end="(191, 53)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(191, 54)" end="(191, 63)">
                <AtomNode start="(191, 54)" end="(191, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(191, 56)" end="(191, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(191, 56)" end="(191, 61)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(191, 62)" end="(191, 63)">
                    <IdentNode start="(191, 62)" end="(191, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(191, 63)" end="(191, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(191, 65)" end="(191, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(191, 65)" end="(191, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(191, 66)" end="(191, 67)">
                <IdentNode start="(191, 66)" end="(191, 67)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(191, 68)" end="(191, 71)">
                <AtomNode start="(191, 68)" end="(191, 69)" leading="" trailing=" " val=":"/>
                <IdentNode start="(191, 70)" end="(191, 71)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(191, 71)" end="(191, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(191, 73)" end="(192, 44)">
            <AtomNode start="(191, 73)" end="(191, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(192, 5)" end="(192, 44)" kind="«term_↔_»">
              <OtherNode start="(192, 5)" end="(192, 21)" kind="«term_=_»">
                <OtherNode start="(192, 5)" end="(192, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(192, 5)" end="(192, 13)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(192, 14)" end="(192, 15)">
                    <IdentNode start="(192, 14)" end="(192, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(192, 16)" end="(192, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(192, 18)" end="(192, 21)" kind="«term#[_,]»">
                  <AtomNode start="(192, 18)" end="(192, 20)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(192, 20)" end="(192, 21)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(192, 22)" end="(192, 23)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(192, 24)" end="(192, 44)" kind="«term_∨_»">
                <OtherNode start="(192, 24)" end="(192, 32)" kind="«term_=_»">
                  <IdentNode start="(192, 24)" end="(192, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(192, 27)" end="(192, 28)" leading="" trailing=" " val="="/>
                  <OtherNode start="(192, 29)" end="(192, 32)" kind="«term#[_,]»">
                    <AtomNode start="(192, 29)" end="(192, 31)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(192, 31)" end="(192, 32)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(192, 33)" end="(192, 34)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(192, 35)" end="(192, 44)" kind="«term_=_»">
                  <IdentNode start="(192, 35)" end="(192, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(192, 38)" end="(192, 39)" leading="" trailing=" " val="="/>
                  <OtherNode start="(192, 40)" end="(192, 44)" kind="«term#[_,]»">
                    <AtomNode start="(192, 40)" end="(192, 42)" leading="" trailing="" val="#["/>
                    <NullNode start="(192, 42)" end="(192, 43)">
                      <IdentNode start="(192, 42)" end="(192, 43)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(192, 43)" end="(192, 44)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(192, 45)" end="(194, 31)">
          <AtomNode start="(192, 45)" end="(192, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(192, 48)" end="(194, 31)">
            <AtomNode start="(192, 48)" end="(192, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(193, 3)" end="(194, 31)">
              <TacticTacticseq1IndentedNode start="(193, 3)" end="(194, 31)">
                <NullNode start="(193, 3)" end="(194, 31)">
                  <OtherNode start="(193, 3)" end="(193, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ xs.erase a = #[] ↔ xs = #[] ∨ xs = #[a]" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a = #[] ↔ { toList := xs } = #[] ∨ { toList := xs } = #[a]" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(193, 3)" end="(193, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(193, 10)" end="(193, 12)">
                      <OtherNode start="(193, 10)" end="(193, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(193, 10)" end="(193, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(193, 13)" end="(193, 22)">
                      <AtomNode start="(193, 13)" end="(193, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(193, 18)" end="(193, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(193, 18)" end="(193, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(193, 18)" end="(193, 22)">
                            <OtherNode start="(193, 18)" end="(193, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(193, 18)" end="(193, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(193, 19)" end="(193, 21)">
                                <OtherNode start="(193, 19)" end="(193, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(193, 19)" end="(193, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(193, 19)" end="(193, 21)">
                                      <OtherNode start="(193, 19)" end="(193, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(193, 19)" end="(193, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(193, 21)" end="(193, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(194, 3)" end="(194, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a = #[] ↔ { toList := xs } = #[] ∨ { toList := xs } = #[a]" state_after="no goals" tactic="simp [List.erase_eq_nil_iff]">
                    <AtomNode start="(194, 3)" end="(194, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(194, 8)" end="(194, 31)">
                      <AtomNode start="(194, 8)" end="(194, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(194, 9)" end="(194, 30)">
                        <OtherNode start="(194, 9)" end="(194, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(194, 9)" end="(194, 30)" leading="" trailing="" raw_val="List.erase_eq_nil_iff" val="List.erase_eq_nil_iff" full_name="List.erase_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(194, 30)" end="(194, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(196, 1)" end="(199, 31)" name="erase_ne_empty_iff" full_name="Array.erase_ne_empty_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(196, 1)" end="(199, 31)" name="erase_ne_empty_iff" full_name="Array.erase_ne_empty_iff" _is_private_decl="False">
        <AtomNode start="(196, 1)" end="(196, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(196, 9)" end="(196, 27)">
          <IdentNode start="(196, 9)" end="(196, 27)" leading="" trailing=" " raw_val="erase_ne_empty_iff" val="erase_ne_empty_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(196, 28)" end="(197, 44)">
          <NullNode start="(196, 28)" end="(196, 64)">
            <OtherNode start="(196, 28)" end="(196, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(196, 28)" end="(196, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(196, 29)" end="(196, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(196, 29)" end="(196, 38)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(196, 39)" end="(196, 40)">
                  <IdentNode start="(196, 39)" end="(196, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(196, 40)" end="(196, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(196, 42)" end="(196, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(196, 42)" end="(196, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(196, 43)" end="(196, 45)">
                <IdentNode start="(196, 43)" end="(196, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(196, 46)" end="(196, 55)">
                <AtomNode start="(196, 46)" end="(196, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(196, 48)" end="(196, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(196, 48)" end="(196, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(196, 54)" end="(196, 55)">
                    <IdentNode start="(196, 54)" end="(196, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(196, 55)" end="(196, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(196, 57)" end="(196, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(196, 57)" end="(196, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(196, 58)" end="(196, 59)">
                <IdentNode start="(196, 58)" end="(196, 59)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(196, 60)" end="(196, 63)">
                <AtomNode start="(196, 60)" end="(196, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(196, 62)" end="(196, 63)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(196, 63)" end="(196, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(196, 65)" end="(197, 44)">
            <AtomNode start="(196, 65)" end="(196, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(197, 5)" end="(197, 44)" kind="«term_↔_»">
              <OtherNode start="(197, 5)" end="(197, 21)" kind="«term_≠_»">
                <OtherNode start="(197, 5)" end="(197, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(197, 5)" end="(197, 13)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(197, 14)" end="(197, 15)">
                    <IdentNode start="(197, 14)" end="(197, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(197, 16)" end="(197, 17)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(197, 18)" end="(197, 21)" kind="«term#[_,]»">
                  <AtomNode start="(197, 18)" end="(197, 20)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(197, 20)" end="(197, 21)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(197, 22)" end="(197, 23)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(197, 24)" end="(197, 44)" kind="«term_∧_»">
                <OtherNode start="(197, 24)" end="(197, 32)" kind="«term_≠_»">
                  <IdentNode start="(197, 24)" end="(197, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(197, 27)" end="(197, 28)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(197, 29)" end="(197, 32)" kind="«term#[_,]»">
                    <AtomNode start="(197, 29)" end="(197, 31)" leading="" trailing="" val="#["/>
                    <NullNode/>
                    <AtomNode start="(197, 31)" end="(197, 32)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(197, 33)" end="(197, 34)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(197, 35)" end="(197, 44)" kind="«term_≠_»">
                  <IdentNode start="(197, 35)" end="(197, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(197, 38)" end="(197, 39)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(197, 40)" end="(197, 44)" kind="«term#[_,]»">
                    <AtomNode start="(197, 40)" end="(197, 42)" leading="" trailing="" val="#["/>
                    <NullNode start="(197, 42)" end="(197, 43)">
                      <IdentNode start="(197, 42)" end="(197, 43)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(197, 43)" end="(197, 44)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(197, 45)" end="(199, 31)">
          <AtomNode start="(197, 45)" end="(197, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(197, 48)" end="(199, 31)">
            <AtomNode start="(197, 48)" end="(197, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(198, 3)" end="(199, 31)">
              <TacticTacticseq1IndentedNode start="(198, 3)" end="(199, 31)">
                <NullNode start="(198, 3)" end="(199, 31)">
                  <OtherNode start="(198, 3)" end="(198, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;⊢ xs.erase a ≠ #[] ↔ xs ≠ #[] ∧ xs ≠ #[a]" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a ≠ #[] ↔ { toList := xs } ≠ #[] ∧ { toList := xs } ≠ #[a]" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(198, 3)" end="(198, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(198, 10)" end="(198, 12)">
                      <OtherNode start="(198, 10)" end="(198, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(198, 10)" end="(198, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(198, 13)" end="(198, 22)">
                      <AtomNode start="(198, 13)" end="(198, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(198, 18)" end="(198, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(198, 18)" end="(198, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(198, 18)" end="(198, 22)">
                            <OtherNode start="(198, 18)" end="(198, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(198, 18)" end="(198, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(198, 19)" end="(198, 21)">
                                <OtherNode start="(198, 19)" end="(198, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(198, 19)" end="(198, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(198, 19)" end="(198, 21)">
                                      <OtherNode start="(198, 19)" end="(198, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(198, 19)" end="(198, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(198, 21)" end="(198, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(199, 3)" end="(199, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.erase a ≠ #[] ↔ { toList := xs } ≠ #[] ∧ { toList := xs } ≠ #[a]" state_after="no goals" tactic="simp [List.erase_ne_nil_iff]">
                    <AtomNode start="(199, 3)" end="(199, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(199, 8)" end="(199, 31)">
                      <AtomNode start="(199, 8)" end="(199, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(199, 9)" end="(199, 30)">
                        <OtherNode start="(199, 9)" end="(199, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(199, 9)" end="(199, 30)" leading="" trailing="" raw_val="List.erase_ne_nil_iff" val="List.erase_ne_nil_iff" full_name="List.erase_ne_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(199, 30)" end="(199, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(201, 1)" end="(204, 99)" name="exists_erase_eq" full_name="Array.exists_erase_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(201, 1)" end="(204, 99)" name="exists_erase_eq" full_name="Array.exists_erase_eq" _is_private_decl="False">
        <AtomNode start="(201, 1)" end="(201, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(201, 9)" end="(201, 24)">
          <IdentNode start="(201, 9)" end="(201, 24)" leading="" trailing=" " raw_val="exists_erase_eq" val="exists_erase_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(201, 25)" end="(202, 67)">
          <NullNode start="(201, 25)" end="(201, 74)">
            <OtherNode start="(201, 25)" end="(201, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(201, 25)" end="(201, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(201, 26)" end="(201, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(201, 26)" end="(201, 35)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(201, 36)" end="(201, 37)">
                  <IdentNode start="(201, 36)" end="(201, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(201, 37)" end="(201, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(201, 39)" end="(201, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(201, 39)" end="(201, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(201, 40)" end="(201, 41)">
                <IdentNode start="(201, 40)" end="(201, 41)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(201, 42)" end="(201, 45)">
                <AtomNode start="(201, 42)" end="(201, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(201, 44)" end="(201, 45)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(201, 45)" end="(201, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(201, 47)" end="(201, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(201, 47)" end="(201, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(201, 48)" end="(201, 50)">
                <IdentNode start="(201, 48)" end="(201, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(201, 51)" end="(201, 60)">
                <AtomNode start="(201, 51)" end="(201, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 53)" end="(201, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(201, 53)" end="(201, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(201, 59)" end="(201, 60)">
                    <IdentNode start="(201, 59)" end="(201, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(201, 60)" end="(201, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(201, 62)" end="(201, 74)">
              <AtomNode start="(201, 62)" end="(201, 63)" leading="" trailing="" val="("/>
              <NullNode start="(201, 63)" end="(201, 64)">
                <IdentNode start="(201, 63)" end="(201, 64)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(201, 65)" end="(201, 73)">
                <AtomNode start="(201, 65)" end="(201, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 67)" end="(201, 73)" kind="«term_∈_»">
                  <IdentNode start="(201, 67)" end="(201, 68)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(201, 69)" end="(201, 70)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(201, 71)" end="(201, 73)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(201, 73)" end="(201, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(201, 75)" end="(202, 67)">
            <AtomNode start="(201, 75)" end="(201, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(202, 5)" end="(202, 67)" kind="«term∃_,_»">
              <AtomNode start="(202, 5)" end="(202, 6)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(202, 7)" end="(202, 12)" kind="Lean.explicitBinders">
                <OtherNode start="(202, 7)" end="(202, 12)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(202, 7)" end="(202, 12)">
                    <LeanBinderidentNode start="(202, 7)" end="(202, 9)">
                      <IdentNode start="(202, 7)" end="(202, 9)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    </LeanBinderidentNode>
                    <LeanBinderidentNode start="(202, 10)" end="(202, 12)">
                      <IdentNode start="(202, 10)" end="(202, 12)" leading="" trailing="" raw_val="zs" val="zs"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(202, 12)" end="(202, 13)" leading="" trailing=" " val=","/>
              <OtherNode start="(202, 14)" end="(202, 67)" kind="«term_∧_»">
                <OtherNode start="(202, 14)" end="(202, 20)" kind="«term_∉_»">
                  <IdentNode start="(202, 14)" end="(202, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(202, 16)" end="(202, 17)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(202, 18)" end="(202, 20)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(202, 21)" end="(202, 22)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(202, 23)" end="(202, 67)" kind="«term_∧_»">
                  <OtherNode start="(202, 23)" end="(202, 43)" kind="«term_=_»">
                    <IdentNode start="(202, 23)" end="(202, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <AtomNode start="(202, 26)" end="(202, 27)" leading="" trailing=" " val="="/>
                    <OtherNode start="(202, 28)" end="(202, 43)" kind="«term_++_»">
                      <OtherNode start="(202, 28)" end="(202, 37)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(202, 28)" end="(202, 35)" leading="" trailing=" " raw_val="ys.push" val="ys.push"/>
                        <NullNode start="(202, 36)" end="(202, 37)">
                          <IdentNode start="(202, 36)" end="(202, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(202, 38)" end="(202, 40)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(202, 41)" end="(202, 43)" leading="" trailing=" " raw_val="zs" val="zs"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(202, 44)" end="(202, 45)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(202, 46)" end="(202, 67)" kind="«term_=_»">
                    <OtherNode start="(202, 46)" end="(202, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(202, 46)" end="(202, 54)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                      <NullNode start="(202, 55)" end="(202, 56)">
                        <IdentNode start="(202, 55)" end="(202, 56)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(202, 57)" end="(202, 58)" leading="" trailing=" " val="="/>
                    <OtherNode start="(202, 59)" end="(202, 67)" kind="«term_++_»">
                      <IdentNode start="(202, 59)" end="(202, 61)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      <AtomNode start="(202, 62)" end="(202, 64)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(202, 65)" end="(202, 67)" leading="" trailing=" " raw_val="zs" val="zs"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(202, 68)" end="(204, 99)">
          <AtomNode start="(202, 68)" end="(202, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(202, 71)" end="(204, 99)">
            <AtomNode start="(202, 71)" end="(202, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(203, 3)" end="(204, 99)">
              <TacticTacticseq1IndentedNode start="(203, 3)" end="(204, 99)">
                <NullNode start="(203, 3)" end="(204, 99)">
                  <OtherNode start="(203, 3)" end="(203, 76)" kind="Lean.Parser.Tactic.tacticLet_" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;⊢ ∃ ys zs, ¬a ∈ ys ∧ xs = ys.push a ++ zs ∧ xs.erase a = ys ++ zs" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;w✝ : α&#10;ys zs : Array α&#10;h₁ : ∀ (b : α), b ∈ ys → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : xs = ys.push w✝ ++ zs&#10;h₃ : xs.eraseP (BEq.beq a) = ys ++ zs&#10;⊢ ∃ ys zs, ¬a ∈ ys ∧ xs = ys.push a ++ zs ∧ xs.erase a = ys ++ zs" tactic="let ⟨_, ys, zs, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _)">
                    <AtomNode start="(203, 3)" end="(203, 6)" leading="" trailing=" " val="let"/>
                    <OtherNode start="(203, 7)" end="(203, 76)" kind="Lean.Parser.Term.letDecl">
                      <OtherNode start="(203, 7)" end="(203, 76)" kind="Lean.Parser.Term.letPatDecl">
                        <OtherNode start="(203, 7)" end="(203, 33)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(203, 7)" end="(203, 8)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(203, 8)" end="(203, 32)">
                            <TermHoleNode start="(203, 8)" end="(203, 9)">
                              <AtomNode start="(203, 8)" end="(203, 9)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(203, 9)" end="(203, 10)" leading="" trailing=" " val=","/>
                            <IdentNode start="(203, 11)" end="(203, 13)" leading="" trailing="" raw_val="ys" val="ys"/>
                            <AtomNode start="(203, 13)" end="(203, 14)" leading="" trailing=" " val=","/>
                            <IdentNode start="(203, 15)" end="(203, 17)" leading="" trailing="" raw_val="zs" val="zs"/>
                            <AtomNode start="(203, 17)" end="(203, 18)" leading="" trailing=" " val=","/>
                            <IdentNode start="(203, 19)" end="(203, 21)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                            <AtomNode start="(203, 21)" end="(203, 22)" leading="" trailing=" " val=","/>
                            <IdentNode start="(203, 23)" end="(203, 24)" leading="" trailing="" raw_val="e" val="e"/>
                            <AtomNode start="(203, 24)" end="(203, 25)" leading="" trailing=" " val=","/>
                            <IdentNode start="(203, 26)" end="(203, 28)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                            <AtomNode start="(203, 28)" end="(203, 29)" leading="" trailing=" " val=","/>
                            <IdentNode start="(203, 30)" end="(203, 32)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                          </NullNode>
                          <AtomNode start="(203, 32)" end="(203, 33)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(203, 34)" end="(203, 36)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(203, 37)" end="(203, 76)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(203, 37)" end="(203, 53)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP" full_name="Array.exists_of_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(45, 9)" def_end="(45, 25)"/>
                          <NullNode start="(203, 54)" end="(203, 76)">
                            <IdentNode start="(203, 54)" end="(203, 55)" leading="" trailing=" " raw_val="h" val="h"/>
                            <OtherNode start="(203, 56)" end="(203, 76)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(203, 56)" end="(203, 57)" leading="" trailing="" val="("/>
                              <OtherNode start="(203, 57)" end="(203, 75)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(203, 57)" end="(203, 73)" leading="" trailing=" " raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                <NullNode start="(203, 74)" end="(203, 75)">
                                  <TermHoleNode start="(203, 74)" end="(203, 75)">
                                    <AtomNode start="(203, 74)" end="(203, 75)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(203, 75)" end="(203, 76)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(204, 3)" end="(204, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;w✝ : α&#10;ys zs : Array α&#10;h₁ : ∀ (b : α), b ∈ ys → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : xs = ys.push w✝ ++ zs&#10;h₃ : xs.eraseP (BEq.beq a) = ys ++ zs&#10;⊢ ∃ ys zs, ¬a ∈ ys ∧ xs = ys.push a ++ zs ∧ xs.erase a = ys ++ zs" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;w✝ : α&#10;ys zs : Array α&#10;h₁ : ∀ (b : α), b ∈ ys → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : xs = ys.push w✝ ++ zs&#10;h₃ : xs.eraseP (BEq.beq a) = ys ++ zs&#10;⊢ ∃ ys zs, ¬a ∈ ys ∧ xs = ys.push a ++ zs ∧ (xs.eraseP fun x =&amp;gt; a == x) = ys ++ zs" tactic="rw [erase_eq_eraseP]">
                    <AtomNode start="(204, 3)" end="(204, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(204, 6)" end="(204, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(204, 6)" end="(204, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(204, 7)" end="(204, 22)">
                        <OtherNode start="(204, 7)" end="(204, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(204, 7)" end="(204, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="Array.erase_eq_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(187, 9)" def_end="(187, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(204, 22)" end="(204, 23)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(204, 23)" end="(204, 24)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(204, 25)" end="(204, 99)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;w✝ : α&#10;ys zs : Array α&#10;h₁ : ∀ (b : α), b ∈ ys → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : xs = ys.push w✝ ++ zs&#10;h₃ : xs.eraseP (BEq.beq a) = ys ++ zs&#10;⊢ ∃ ys zs, ¬a ∈ ys ∧ xs = ys.push a ++ zs ∧ (xs.eraseP fun x =&amp;gt; a == x) = ys ++ zs" state_after="no goals" tactic="exact ⟨ys, zs, fun h =&amp;gt; h₁ _ h (beq_self_eq_true _), eq_of_beq e ▸ h₂, h₃⟩">
                    <AtomNode start="(204, 25)" end="(204, 30)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(204, 31)" end="(204, 99)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(204, 31)" end="(204, 32)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(204, 32)" end="(204, 98)">
                        <IdentNode start="(204, 32)" end="(204, 34)" leading="" trailing="" raw_val="ys" val="ys"/>
                        <AtomNode start="(204, 34)" end="(204, 35)" leading="" trailing=" " val=","/>
                        <IdentNode start="(204, 36)" end="(204, 38)" leading="" trailing="" raw_val="zs" val="zs"/>
                        <AtomNode start="(204, 38)" end="(204, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(204, 40)" end="(204, 76)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(204, 40)" end="(204, 43)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(204, 44)" end="(204, 76)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(204, 44)" end="(204, 45)">
                              <IdentNode start="(204, 44)" end="(204, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(204, 46)" end="(204, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(204, 49)" end="(204, 76)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(204, 49)" end="(204, 51)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <NullNode start="(204, 52)" end="(204, 76)">
                                <TermHoleNode start="(204, 52)" end="(204, 53)">
                                  <AtomNode start="(204, 52)" end="(204, 53)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <IdentNode start="(204, 54)" end="(204, 55)" leading="" trailing=" " raw_val="h" val="h"/>
                                <OtherNode start="(204, 56)" end="(204, 76)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(204, 56)" end="(204, 57)" leading="" trailing="" val="("/>
                                  <OtherNode start="(204, 57)" end="(204, 75)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(204, 57)" end="(204, 73)" leading="" trailing=" " raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                    <NullNode start="(204, 74)" end="(204, 75)">
                                      <TermHoleNode start="(204, 74)" end="(204, 75)">
                                        <AtomNode start="(204, 74)" end="(204, 75)" leading="" trailing="" val="_"/>
                                      </TermHoleNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(204, 75)" end="(204, 76)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(204, 76)" end="(204, 77)" leading="" trailing=" " val=","/>
                        <OtherNode start="(204, 78)" end="(204, 94)" kind="Lean.Parser.Term.subst">
                          <OtherNode start="(204, 78)" end="(204, 89)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(204, 78)" end="(204, 87)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(204, 88)" end="(204, 89)">
                              <IdentNode start="(204, 88)" end="(204, 89)" leading="" trailing=" " raw_val="e" val="e"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(204, 90)" end="(204, 91)" leading="" trailing=" " val="▸"/>
                          <NullNode start="(204, 92)" end="(204, 94)">
                            <IdentNode start="(204, 92)" end="(204, 94)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(204, 94)" end="(204, 95)" leading="" trailing=" " val=","/>
                        <IdentNode start="(204, 96)" end="(204, 98)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                      </NullNode>
                      <AtomNode start="(204, 98)" end="(204, 99)" leading="" trailing="&#10;&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(206, 1)" end="(208, 72)" name="size_erase_of_mem" full_name="Array.size_erase_of_mem">
      <CommandDeclmodifiersNode start="(206, 1)" end="(206, 8)">
        <NullNode/>
        <NullNode start="(206, 1)" end="(206, 8)">
          <OtherNode start="(206, 1)" end="(206, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(206, 1)" end="(206, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(206, 3)" end="(206, 7)">
              <OtherNode start="(206, 3)" end="(206, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(206, 3)" end="(206, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(206, 3)" end="(206, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(206, 7)" end="(206, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(206, 9)" end="(208, 72)" name="size_erase_of_mem" full_name="Array.size_erase_of_mem" _is_private_decl="False">
        <AtomNode start="(206, 9)" end="(206, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(206, 17)" end="(206, 34)">
          <IdentNode start="(206, 17)" end="(206, 34)" leading="" trailing=" " raw_val="size_erase_of_mem" val="size_erase_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(206, 35)" end="(207, 36)">
          <NullNode start="(206, 35)" end="(206, 84)">
            <OtherNode start="(206, 35)" end="(206, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(206, 35)" end="(206, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(206, 36)" end="(206, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(206, 36)" end="(206, 45)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(206, 46)" end="(206, 47)">
                  <IdentNode start="(206, 46)" end="(206, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(206, 47)" end="(206, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(206, 49)" end="(206, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 49)" end="(206, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 50)" end="(206, 51)">
                <IdentNode start="(206, 50)" end="(206, 51)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(206, 52)" end="(206, 55)">
                <AtomNode start="(206, 52)" end="(206, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(206, 54)" end="(206, 55)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(206, 55)" end="(206, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(206, 57)" end="(206, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 57)" end="(206, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 58)" end="(206, 60)">
                <IdentNode start="(206, 58)" end="(206, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(206, 61)" end="(206, 70)">
                <AtomNode start="(206, 61)" end="(206, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 63)" end="(206, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(206, 63)" end="(206, 68)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(206, 69)" end="(206, 70)">
                    <IdentNode start="(206, 69)" end="(206, 70)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(206, 70)" end="(206, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(206, 72)" end="(206, 84)">
              <AtomNode start="(206, 72)" end="(206, 73)" leading="" trailing="" val="("/>
              <NullNode start="(206, 73)" end="(206, 74)">
                <IdentNode start="(206, 73)" end="(206, 74)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(206, 75)" end="(206, 83)">
                <AtomNode start="(206, 75)" end="(206, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 77)" end="(206, 83)" kind="«term_∈_»">
                  <IdentNode start="(206, 77)" end="(206, 78)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(206, 79)" end="(206, 80)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(206, 81)" end="(206, 83)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(206, 83)" end="(206, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(206, 85)" end="(207, 36)">
            <AtomNode start="(206, 85)" end="(206, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(207, 5)" end="(207, 36)" kind="«term_=_»">
              <OtherNode start="(207, 5)" end="(207, 22)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(207, 5)" end="(207, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(207, 5)" end="(207, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(207, 6)" end="(207, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(207, 6)" end="(207, 14)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                    <NullNode start="(207, 15)" end="(207, 16)">
                      <IdentNode start="(207, 15)" end="(207, 16)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(207, 16)" end="(207, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(207, 17)" end="(207, 18)" leading="" trailing="" val="."/>
                <IdentNode start="(207, 18)" end="(207, 22)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(207, 23)" end="(207, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(207, 25)" end="(207, 36)" kind="«term_-_»">
                <IdentNode start="(207, 25)" end="(207, 32)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                <AtomNode start="(207, 33)" end="(207, 34)" leading="" trailing=" " val="-"/>
                <OtherNode start="(207, 35)" end="(207, 36)" kind="num">
                  <AtomNode start="(207, 35)" end="(207, 36)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(207, 37)" end="(208, 72)">
          <AtomNode start="(207, 37)" end="(207, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(207, 40)" end="(208, 72)">
            <AtomNode start="(207, 40)" end="(207, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(208, 3)" end="(208, 72)">
              <TacticTacticseq1IndentedNode start="(208, 3)" end="(208, 72)">
                <NullNode start="(208, 3)" end="(208, 72)">
                  <OtherNode start="(208, 3)" end="(208, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;⊢ (xs.erase a).size = xs.size - 1" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;⊢ (xs.eraseP fun x =&amp;gt; a == x).size = xs.size - 1" tactic="rw [erase_eq_eraseP]">
                    <AtomNode start="(208, 3)" end="(208, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(208, 6)" end="(208, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(208, 6)" end="(208, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(208, 7)" end="(208, 22)">
                        <OtherNode start="(208, 7)" end="(208, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(208, 7)" end="(208, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="Array.erase_eq_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(187, 9)" def_end="(187, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(208, 22)" end="(208, 23)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(208, 23)" end="(208, 24)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(208, 25)" end="(208, 72)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : a ∈ xs&#10;⊢ (xs.eraseP fun x =&amp;gt; a == x).size = xs.size - 1" state_after="no goals" tactic="exact size_eraseP_of_mem h (beq_self_eq_true a)">
                    <AtomNode start="(208, 25)" end="(208, 30)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(208, 31)" end="(208, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(208, 31)" end="(208, 49)" leading="" trailing=" " raw_val="size_eraseP_of_mem" val="size_eraseP_of_mem" full_name="Array.size_eraseP_of_mem" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(61, 17)" def_end="(61, 35)"/>
                      <NullNode start="(208, 50)" end="(208, 72)">
                        <IdentNode start="(208, 50)" end="(208, 51)" leading="" trailing=" " raw_val="h" val="h"/>
                        <OtherNode start="(208, 52)" end="(208, 72)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(208, 52)" end="(208, 53)" leading="" trailing="" val="("/>
                          <OtherNode start="(208, 53)" end="(208, 71)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(208, 53)" end="(208, 69)" leading="" trailing=" " raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                            <NullNode start="(208, 70)" end="(208, 71)">
                              <IdentNode start="(208, 70)" end="(208, 71)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(208, 71)" end="(208, 72)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(210, 1)" end="(214, 43)" name="size_erase" full_name="Array.size_erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(210, 1)" end="(214, 43)" name="size_erase" full_name="Array.size_erase" _is_private_decl="False">
        <AtomNode start="(210, 1)" end="(210, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(210, 9)" end="(210, 19)">
          <IdentNode start="(210, 9)" end="(210, 19)" leading="" trailing=" " raw_val="size_erase" val="size_erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(210, 20)" end="(211, 64)">
          <NullNode start="(210, 20)" end="(210, 56)">
            <OtherNode start="(210, 20)" end="(210, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(210, 20)" end="(210, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(210, 21)" end="(210, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(210, 21)" end="(210, 30)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(210, 31)" end="(210, 32)">
                  <IdentNode start="(210, 31)" end="(210, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(210, 32)" end="(210, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(210, 34)" end="(210, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(210, 34)" end="(210, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(210, 35)" end="(210, 36)">
                <IdentNode start="(210, 35)" end="(210, 36)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(210, 37)" end="(210, 40)">
                <AtomNode start="(210, 37)" end="(210, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(210, 39)" end="(210, 40)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(210, 40)" end="(210, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(210, 42)" end="(210, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(210, 42)" end="(210, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(210, 43)" end="(210, 45)">
                <IdentNode start="(210, 43)" end="(210, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(210, 46)" end="(210, 55)">
                <AtomNode start="(210, 46)" end="(210, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(210, 48)" end="(210, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(210, 48)" end="(210, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(210, 54)" end="(210, 55)">
                    <IdentNode start="(210, 54)" end="(210, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(210, 55)" end="(210, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(210, 57)" end="(211, 64)">
            <AtomNode start="(210, 57)" end="(210, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(211, 5)" end="(211, 64)" kind="«term_=_»">
              <OtherNode start="(211, 5)" end="(211, 22)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(211, 5)" end="(211, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(211, 5)" end="(211, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(211, 6)" end="(211, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(211, 6)" end="(211, 14)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                    <NullNode start="(211, 15)" end="(211, 16)">
                      <IdentNode start="(211, 15)" end="(211, 16)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(211, 16)" end="(211, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(211, 17)" end="(211, 18)" leading="" trailing="" val="."/>
                <IdentNode start="(211, 18)" end="(211, 22)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(211, 23)" end="(211, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(211, 25)" end="(211, 64)" kind="termIfThenElse">
                <AtomNode start="(211, 25)" end="(211, 27)" leading="" trailing=" " val="if"/>
                <OtherNode start="(211, 28)" end="(211, 34)" kind="«term_∈_»">
                  <IdentNode start="(211, 28)" end="(211, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(211, 30)" end="(211, 31)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(211, 32)" end="(211, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(211, 35)" end="(211, 39)" leading="" trailing=" " val="then"/>
                <OtherNode start="(211, 40)" end="(211, 51)" kind="«term_-_»">
                  <IdentNode start="(211, 40)" end="(211, 47)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(211, 48)" end="(211, 49)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(211, 50)" end="(211, 51)" kind="num">
                    <AtomNode start="(211, 50)" end="(211, 51)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(211, 52)" end="(211, 56)" leading="" trailing=" " val="else"/>
                <IdentNode start="(211, 57)" end="(211, 64)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(211, 65)" end="(214, 43)">
          <AtomNode start="(211, 65)" end="(211, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(211, 68)" end="(214, 43)">
            <AtomNode start="(211, 68)" end="(211, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(212, 3)" end="(214, 43)">
              <TacticTacticseq1IndentedNode start="(212, 3)" end="(214, 43)">
                <NullNode start="(212, 3)" end="(214, 43)">
                  <OtherNode start="(212, 3)" end="(212, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (xs.erase a).size = if a ∈ xs then xs.size - 1 else xs.size" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (if (xs.any fun x =&amp;gt; a == x) = true then xs.size - 1 else xs.size) = if a ∈ xs then xs.size - 1 else xs.size" tactic="rw [erase_eq_eraseP, size_eraseP]">
                    <AtomNode start="(212, 3)" end="(212, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(212, 6)" end="(212, 36)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(212, 6)" end="(212, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(212, 7)" end="(212, 35)">
                        <OtherNode start="(212, 7)" end="(212, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(212, 7)" end="(212, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="Array.erase_eq_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(187, 9)" def_end="(187, 24)"/>
                        </OtherNode>
                        <AtomNode start="(212, 22)" end="(212, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(212, 24)" end="(212, 35)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(212, 24)" end="(212, 35)" leading="" trailing="" raw_val="size_eraseP" val="size_eraseP" full_name="Array.size_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(66, 9)" def_end="(66, 20)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(212, 35)" end="(212, 36)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(213, 3)" end="(213, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (if (xs.any fun x =&amp;gt; a == x) = true then xs.size - 1 else xs.size) = if a ∈ xs then xs.size - 1 else xs.size" state_after="case e_c&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ ((xs.any fun x =&amp;gt; a == x) = true) = (a ∈ xs)" tactic="congr">
                    <AtomNode start="(213, 3)" end="(213, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(214, 3)" end="(214, 43)" kind="Lean.Parser.Tactic.simp" state_before="case e_c&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ ((xs.any fun x =&amp;gt; a == x) = true) = (a ∈ xs)" state_after="no goals" tactic="simp [mem_iff_getElem, eq_comm (a := a)]">
                    <AtomNode start="(214, 3)" end="(214, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(214, 8)" end="(214, 43)">
                      <AtomNode start="(214, 8)" end="(214, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(214, 9)" end="(214, 42)">
                        <OtherNode start="(214, 9)" end="(214, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(214, 9)" end="(214, 24)" leading="" trailing="" raw_val="mem_iff_getElem" val="mem_iff_getElem" full_name="Array.mem_iff_getElem" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(214, 24)" end="(214, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(214, 26)" end="(214, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(214, 26)" end="(214, 42)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(214, 26)" end="(214, 33)" leading="" trailing=" " raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(214, 34)" end="(214, 42)">
                              <OtherNode start="(214, 34)" end="(214, 42)" kind="Lean.Parser.Term.namedArgument">
                                <AtomNode start="(214, 34)" end="(214, 35)" leading="" trailing="" val="("/>
                                <IdentNode start="(214, 35)" end="(214, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(214, 37)" end="(214, 39)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(214, 40)" end="(214, 41)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(214, 41)" end="(214, 42)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(214, 42)" end="(214, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(216, 1)" end="(218, 35)" name="size_erase_le" full_name="Array.size_erase_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(216, 1)" end="(218, 35)" name="size_erase_le" full_name="Array.size_erase_le" _is_private_decl="False">
        <AtomNode start="(216, 1)" end="(216, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(216, 9)" end="(216, 22)">
          <IdentNode start="(216, 9)" end="(216, 22)" leading="" trailing=" " raw_val="size_erase_le" val="size_erase_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(216, 23)" end="(216, 75)">
          <NullNode start="(216, 23)" end="(216, 45)">
            <OtherNode start="(216, 23)" end="(216, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(216, 23)" end="(216, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(216, 24)" end="(216, 25)">
                <IdentNode start="(216, 24)" end="(216, 25)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(216, 26)" end="(216, 29)">
                <AtomNode start="(216, 26)" end="(216, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(216, 28)" end="(216, 29)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(216, 29)" end="(216, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(216, 31)" end="(216, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(216, 31)" end="(216, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(216, 32)" end="(216, 34)">
                <IdentNode start="(216, 32)" end="(216, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(216, 35)" end="(216, 44)">
                <AtomNode start="(216, 35)" end="(216, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(216, 37)" end="(216, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(216, 37)" end="(216, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(216, 43)" end="(216, 44)">
                    <IdentNode start="(216, 43)" end="(216, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(216, 44)" end="(216, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(216, 46)" end="(216, 75)">
            <AtomNode start="(216, 46)" end="(216, 47)" leading="" trailing=" " val=":"/>
            <OtherNode start="(216, 48)" end="(216, 75)" kind="«term_≤_»">
              <OtherNode start="(216, 48)" end="(216, 65)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(216, 48)" end="(216, 60)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(216, 48)" end="(216, 49)" leading="" trailing="" val="("/>
                  <OtherNode start="(216, 49)" end="(216, 59)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(216, 49)" end="(216, 57)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                    <NullNode start="(216, 58)" end="(216, 59)">
                      <IdentNode start="(216, 58)" end="(216, 59)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(216, 59)" end="(216, 60)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(216, 60)" end="(216, 61)" leading="" trailing="" val="."/>
                <IdentNode start="(216, 61)" end="(216, 65)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(216, 66)" end="(216, 67)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(216, 68)" end="(216, 75)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(216, 76)" end="(218, 35)">
          <AtomNode start="(216, 76)" end="(216, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(216, 79)" end="(218, 35)">
            <AtomNode start="(216, 79)" end="(216, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(217, 3)" end="(218, 35)">
              <TacticTacticseq1IndentedNode start="(217, 3)" end="(218, 35)">
                <NullNode start="(217, 3)" end="(218, 35)">
                  <OtherNode start="(217, 3)" end="(217, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;xs : Array α&#10;⊢ (xs.erase a).size ≤ xs.size" state_after="case mk&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;xs : List α&#10;⊢ ({ toList := xs }.erase a).size ≤ { toList := xs }.size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(217, 3)" end="(217, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(217, 10)" end="(217, 12)">
                      <OtherNode start="(217, 10)" end="(217, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(217, 10)" end="(217, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(217, 13)" end="(217, 22)">
                      <AtomNode start="(217, 13)" end="(217, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(217, 18)" end="(217, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(217, 18)" end="(217, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(217, 18)" end="(217, 22)">
                            <OtherNode start="(217, 18)" end="(217, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(217, 18)" end="(217, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(217, 19)" end="(217, 21)">
                                <OtherNode start="(217, 19)" end="(217, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(217, 19)" end="(217, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(217, 19)" end="(217, 21)">
                                      <OtherNode start="(217, 19)" end="(217, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(217, 19)" end="(217, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(217, 21)" end="(217, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(218, 3)" end="(218, 35)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;xs : List α&#10;⊢ ({ toList := xs }.erase a).size ≤ { toList := xs }.size" state_after="no goals" tactic="simpa using List.length_erase_le">
                    <AtomNode start="(218, 3)" end="(218, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(218, 9)" end="(218, 35)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(218, 9)" end="(218, 35)">
                        <AtomNode start="(218, 9)" end="(218, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(218, 15)" end="(218, 35)" leading="" trailing="&#10;&#10;" raw_val="List.length_erase_le" val="List.length_erase_le" full_name="List.length_erase_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(220, 1)" end="(222, 35)" name="le_size_erase" full_name="Array.le_size_erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(220, 1)" end="(222, 35)" name="le_size_erase" full_name="Array.le_size_erase" _is_private_decl="False">
        <AtomNode start="(220, 1)" end="(220, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(220, 9)" end="(220, 22)">
          <IdentNode start="(220, 9)" end="(220, 22)" leading="" trailing=" " raw_val="le_size_erase" val="le_size_erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(220, 23)" end="(220, 93)">
          <NullNode start="(220, 23)" end="(220, 59)">
            <OtherNode start="(220, 23)" end="(220, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(220, 23)" end="(220, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(220, 24)" end="(220, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(220, 24)" end="(220, 33)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(220, 34)" end="(220, 35)">
                  <IdentNode start="(220, 34)" end="(220, 35)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(220, 35)" end="(220, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(220, 37)" end="(220, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(220, 37)" end="(220, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(220, 38)" end="(220, 39)">
                <IdentNode start="(220, 38)" end="(220, 39)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(220, 40)" end="(220, 43)">
                <AtomNode start="(220, 40)" end="(220, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(220, 42)" end="(220, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(220, 43)" end="(220, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(220, 45)" end="(220, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(220, 45)" end="(220, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(220, 46)" end="(220, 48)">
                <IdentNode start="(220, 46)" end="(220, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(220, 49)" end="(220, 58)">
                <AtomNode start="(220, 49)" end="(220, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(220, 51)" end="(220, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(220, 51)" end="(220, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(220, 57)" end="(220, 58)">
                    <IdentNode start="(220, 57)" end="(220, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(220, 58)" end="(220, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(220, 60)" end="(220, 93)">
            <AtomNode start="(220, 60)" end="(220, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(220, 62)" end="(220, 93)" kind="«term_≤_»">
              <OtherNode start="(220, 62)" end="(220, 73)" kind="«term_-_»">
                <IdentNode start="(220, 62)" end="(220, 69)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                <AtomNode start="(220, 70)" end="(220, 71)" leading="" trailing=" " val="-"/>
                <OtherNode start="(220, 72)" end="(220, 73)" kind="num">
                  <AtomNode start="(220, 72)" end="(220, 73)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(220, 74)" end="(220, 75)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(220, 76)" end="(220, 93)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(220, 76)" end="(220, 88)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(220, 76)" end="(220, 77)" leading="" trailing="" val="("/>
                  <OtherNode start="(220, 77)" end="(220, 87)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(220, 77)" end="(220, 85)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                    <NullNode start="(220, 86)" end="(220, 87)">
                      <IdentNode start="(220, 86)" end="(220, 87)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(220, 87)" end="(220, 88)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(220, 88)" end="(220, 89)" leading="" trailing="" val="."/>
                <IdentNode start="(220, 89)" end="(220, 93)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(220, 94)" end="(222, 35)">
          <AtomNode start="(220, 94)" end="(220, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(220, 97)" end="(222, 35)">
            <AtomNode start="(220, 97)" end="(220, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(221, 3)" end="(222, 35)">
              <TacticTacticseq1IndentedNode start="(221, 3)" end="(222, 35)">
                <NullNode start="(221, 3)" end="(222, 35)">
                  <OtherNode start="(221, 3)" end="(221, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ xs.size - 1 ≤ (xs.erase a).size" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.size - 1 ≤ ({ toList := xs }.erase a).size" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(221, 3)" end="(221, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(221, 10)" end="(221, 12)">
                      <OtherNode start="(221, 10)" end="(221, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(221, 10)" end="(221, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(221, 13)" end="(221, 22)">
                      <AtomNode start="(221, 13)" end="(221, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(221, 18)" end="(221, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(221, 18)" end="(221, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(221, 18)" end="(221, 22)">
                            <OtherNode start="(221, 18)" end="(221, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(221, 18)" end="(221, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(221, 19)" end="(221, 21)">
                                <OtherNode start="(221, 19)" end="(221, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(221, 19)" end="(221, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(221, 19)" end="(221, 21)">
                                      <OtherNode start="(221, 19)" end="(221, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(221, 19)" end="(221, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(221, 21)" end="(221, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(222, 3)" end="(222, 35)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;⊢ { toList := xs }.size - 1 ≤ ({ toList := xs }.erase a).size" state_after="no goals" tactic="simpa using List.le_length_erase">
                    <AtomNode start="(222, 3)" end="(222, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(222, 9)" end="(222, 35)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(222, 9)" end="(222, 35)">
                        <AtomNode start="(222, 9)" end="(222, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(222, 15)" end="(222, 35)" leading="" trailing="&#10;&#10;" raw_val="List.le_length_erase" val="List.le_length_erase" full_name="List.le_length_erase" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(224, 1)" end="(226, 55)" name="mem_of_mem_erase" full_name="Array.mem_of_mem_erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(224, 1)" end="(226, 55)" name="mem_of_mem_erase" full_name="Array.mem_of_mem_erase" _is_private_decl="False">
        <AtomNode start="(224, 1)" end="(224, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(224, 9)" end="(224, 25)">
          <IdentNode start="(224, 9)" end="(224, 25)" leading="" trailing=" " raw_val="mem_of_mem_erase" val="mem_of_mem_erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(224, 26)" end="(224, 80)">
          <NullNode start="(224, 26)" end="(224, 71)">
            <OtherNode start="(224, 26)" end="(224, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(224, 26)" end="(224, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(224, 27)" end="(224, 30)">
                <IdentNode start="(224, 27)" end="(224, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(224, 29)" end="(224, 30)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(224, 31)" end="(224, 34)">
                <AtomNode start="(224, 31)" end="(224, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(224, 33)" end="(224, 34)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(224, 34)" end="(224, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(224, 36)" end="(224, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(224, 36)" end="(224, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(224, 37)" end="(224, 39)">
                <IdentNode start="(224, 37)" end="(224, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(224, 40)" end="(224, 49)">
                <AtomNode start="(224, 40)" end="(224, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(224, 42)" end="(224, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(224, 42)" end="(224, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(224, 48)" end="(224, 49)">
                    <IdentNode start="(224, 48)" end="(224, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(224, 49)" end="(224, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(224, 51)" end="(224, 71)">
              <AtomNode start="(224, 51)" end="(224, 52)" leading="" trailing="" val="("/>
              <NullNode start="(224, 52)" end="(224, 53)">
                <IdentNode start="(224, 52)" end="(224, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(224, 54)" end="(224, 70)">
                <AtomNode start="(224, 54)" end="(224, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(224, 56)" end="(224, 70)" kind="«term_∈_»">
                  <IdentNode start="(224, 56)" end="(224, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(224, 58)" end="(224, 59)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(224, 60)" end="(224, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(224, 60)" end="(224, 68)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                    <NullNode start="(224, 69)" end="(224, 70)">
                      <IdentNode start="(224, 69)" end="(224, 70)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(224, 70)" end="(224, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(224, 72)" end="(224, 80)">
            <AtomNode start="(224, 72)" end="(224, 73)" leading="" trailing=" " val=":"/>
            <OtherNode start="(224, 74)" end="(224, 80)" kind="«term_∈_»">
              <IdentNode start="(224, 74)" end="(224, 75)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(224, 76)" end="(224, 77)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(224, 78)" end="(224, 80)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(224, 81)" end="(226, 55)">
          <AtomNode start="(224, 81)" end="(224, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(224, 84)" end="(226, 55)">
            <AtomNode start="(224, 84)" end="(224, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(225, 3)" end="(226, 55)">
              <TacticTacticseq1IndentedNode start="(225, 3)" end="(226, 55)">
                <NullNode start="(225, 3)" end="(226, 55)">
                  <OtherNode start="(225, 3)" end="(225, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;xs : Array α&#10;h : a ∈ xs.erase b&#10;⊢ a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;xs : List α&#10;h : a ∈ { toList := xs }.erase b&#10;⊢ a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(225, 3)" end="(225, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(225, 10)" end="(225, 12)">
                      <OtherNode start="(225, 10)" end="(225, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(225, 10)" end="(225, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(225, 13)" end="(225, 22)">
                      <AtomNode start="(225, 13)" end="(225, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(225, 18)" end="(225, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(225, 18)" end="(225, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(225, 18)" end="(225, 22)">
                            <OtherNode start="(225, 18)" end="(225, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(225, 18)" end="(225, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(225, 19)" end="(225, 21)">
                                <OtherNode start="(225, 19)" end="(225, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(225, 19)" end="(225, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(225, 19)" end="(225, 21)">
                                      <OtherNode start="(225, 19)" end="(225, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(225, 19)" end="(225, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(225, 21)" end="(225, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(226, 3)" end="(226, 55)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;xs : List α&#10;h : a ∈ { toList := xs }.erase b&#10;⊢ a ∈ { toList := xs }" state_after="no goals" tactic="simpa using List.mem_of_mem_erase (by simpa using h)">
                    <AtomNode start="(226, 3)" end="(226, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(226, 9)" end="(226, 55)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(226, 9)" end="(226, 55)">
                        <AtomNode start="(226, 9)" end="(226, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(226, 15)" end="(226, 55)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(226, 15)" end="(226, 36)" leading="" trailing=" " raw_val="List.mem_of_mem_erase" val="List.mem_of_mem_erase" full_name="List.mem_of_mem_erase" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(226, 37)" end="(226, 55)">
                            <OtherNode start="(226, 37)" end="(226, 55)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(226, 37)" end="(226, 38)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(226, 38)" end="(226, 54)">
                                <AtomNode start="(226, 38)" end="(226, 40)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(226, 41)" end="(226, 54)">
                                  <TacticTacticseq1IndentedNode start="(226, 41)" end="(226, 54)">
                                    <NullNode start="(226, 41)" end="(226, 54)">
                                      <OtherNode start="(226, 41)" end="(226, 54)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;xs : List α&#10;h : a ∈ { toList := xs }.erase b&#10;⊢ a ∈ xs.erase ?m.38446" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(226, 41)" end="(226, 46)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(226, 47)" end="(226, 54)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(226, 47)" end="(226, 54)">
                                            <AtomNode start="(226, 47)" end="(226, 52)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(226, 53)" end="(226, 54)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(226, 54)" end="(226, 55)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(228, 1)" end="(230, 66)" name="mem_erase_of_ne" full_name="Array.mem_erase_of_ne">
      <CommandDeclmodifiersNode start="(228, 1)" end="(228, 8)">
        <NullNode/>
        <NullNode start="(228, 1)" end="(228, 8)">
          <OtherNode start="(228, 1)" end="(228, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(228, 1)" end="(228, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(228, 3)" end="(228, 7)">
              <OtherNode start="(228, 3)" end="(228, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(228, 3)" end="(228, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(228, 3)" end="(228, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(228, 7)" end="(228, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(228, 9)" end="(230, 66)" name="mem_erase_of_ne" full_name="Array.mem_erase_of_ne" _is_private_decl="False">
        <AtomNode start="(228, 9)" end="(228, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(228, 17)" end="(228, 32)">
          <IdentNode start="(228, 17)" end="(228, 32)" leading="" trailing=" " raw_val="mem_erase_of_ne" val="mem_erase_of_ne"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(228, 33)" end="(229, 28)">
          <NullNode start="(228, 33)" end="(228, 84)">
            <OtherNode start="(228, 33)" end="(228, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(228, 33)" end="(228, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(228, 34)" end="(228, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(228, 34)" end="(228, 43)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(228, 44)" end="(228, 45)">
                  <IdentNode start="(228, 44)" end="(228, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(228, 45)" end="(228, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(228, 47)" end="(228, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 47)" end="(228, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 48)" end="(228, 51)">
                <IdentNode start="(228, 48)" end="(228, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(228, 50)" end="(228, 51)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(228, 52)" end="(228, 55)">
                <AtomNode start="(228, 52)" end="(228, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(228, 54)" end="(228, 55)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(228, 55)" end="(228, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(228, 57)" end="(228, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 57)" end="(228, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 58)" end="(228, 60)">
                <IdentNode start="(228, 58)" end="(228, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(228, 61)" end="(228, 70)">
                <AtomNode start="(228, 61)" end="(228, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(228, 63)" end="(228, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(228, 63)" end="(228, 68)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(228, 69)" end="(228, 70)">
                    <IdentNode start="(228, 69)" end="(228, 70)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(228, 70)" end="(228, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(228, 72)" end="(228, 84)">
              <AtomNode start="(228, 72)" end="(228, 73)" leading="" trailing="" val="("/>
              <NullNode start="(228, 73)" end="(228, 75)">
                <IdentNode start="(228, 73)" end="(228, 75)" leading="" trailing=" " raw_val="ab" val="ab"/>
              </NullNode>
              <NullNode start="(228, 76)" end="(228, 83)">
                <AtomNode start="(228, 76)" end="(228, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(228, 78)" end="(228, 83)" kind="«term_≠_»">
                  <IdentNode start="(228, 78)" end="(228, 79)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(228, 80)" end="(228, 81)" leading="" trailing=" " val="≠"/>
                  <IdentNode start="(228, 82)" end="(228, 83)" leading="" trailing="" raw_val="b" val="b"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(228, 83)" end="(228, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(228, 85)" end="(229, 28)">
            <AtomNode start="(228, 85)" end="(228, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(229, 5)" end="(229, 28)" kind="«term_↔_»">
              <OtherNode start="(229, 5)" end="(229, 19)" kind="«term_∈_»">
                <IdentNode start="(229, 5)" end="(229, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(229, 7)" end="(229, 8)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(229, 9)" end="(229, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(229, 9)" end="(229, 17)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(229, 18)" end="(229, 19)">
                    <IdentNode start="(229, 18)" end="(229, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(229, 20)" end="(229, 21)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(229, 22)" end="(229, 28)" kind="«term_∈_»">
                <IdentNode start="(229, 22)" end="(229, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(229, 24)" end="(229, 25)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(229, 26)" end="(229, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(229, 29)" end="(230, 66)">
          <AtomNode start="(229, 29)" end="(229, 31)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(230, 3)" end="(230, 66)" kind="Lean.Parser.Term.subst">
            <OtherNode start="(230, 3)" end="(230, 23)" kind="Lean.Parser.Term.app">
              <IdentNode start="(230, 3)" end="(230, 18)" leading="" trailing=" " raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="Array.erase_eq_eraseP" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(187, 9)" def_end="(187, 24)"/>
              <NullNode start="(230, 19)" end="(230, 23)">
                <IdentNode start="(230, 19)" end="(230, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(230, 21)" end="(230, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
            </OtherNode>
            <AtomNode start="(230, 24)" end="(230, 25)" leading="" trailing=" " val="▸"/>
            <NullNode start="(230, 26)" end="(230, 66)">
              <OtherNode start="(230, 26)" end="(230, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(230, 26)" end="(230, 43)" leading="" trailing=" " raw_val="mem_eraseP_of_neg" val="mem_eraseP_of_neg" full_name="Array.mem_eraseP_of_neg" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(87, 17)" def_end="(87, 34)"/>
                <NullNode start="(230, 44)" end="(230, 66)">
                  <OtherNode start="(230, 44)" end="(230, 66)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(230, 44)" end="(230, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(230, 45)" end="(230, 65)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(230, 45)" end="(230, 47)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      <NullNode start="(230, 48)" end="(230, 65)">
                        <IdentNode start="(230, 48)" end="(230, 57)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        <IdentNode start="(230, 58)" end="(230, 65)" leading="" trailing="" raw_val="ab.symm" val="ab.symm"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(230, 65)" end="(230, 66)" leading="" trailing="&#10;&#10;" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(232, 1)" end="(234, 24)" name="erase_eq_self_iff" full_name="Array.erase_eq_self_iff">
      <CommandDeclmodifiersNode start="(232, 1)" end="(232, 8)">
        <NullNode/>
        <NullNode start="(232, 1)" end="(232, 8)">
          <OtherNode start="(232, 1)" end="(232, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(232, 1)" end="(232, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(232, 3)" end="(232, 7)">
              <OtherNode start="(232, 3)" end="(232, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(232, 3)" end="(232, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(232, 3)" end="(232, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(232, 7)" end="(232, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(232, 9)" end="(234, 24)" name="erase_eq_self_iff" full_name="Array.erase_eq_self_iff" _is_private_decl="False">
        <AtomNode start="(232, 9)" end="(232, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(232, 17)" end="(232, 34)">
          <IdentNode start="(232, 17)" end="(232, 34)" leading="" trailing=" " raw_val="erase_eq_self_iff" val="erase_eq_self_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(232, 35)" end="(232, 90)">
          <NullNode start="(232, 35)" end="(232, 63)">
            <OtherNode start="(232, 35)" end="(232, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(232, 35)" end="(232, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(232, 36)" end="(232, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(232, 36)" end="(232, 45)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(232, 46)" end="(232, 47)">
                  <IdentNode start="(232, 46)" end="(232, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(232, 47)" end="(232, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(232, 49)" end="(232, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 49)" end="(232, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 50)" end="(232, 52)">
                <IdentNode start="(232, 50)" end="(232, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(232, 53)" end="(232, 62)">
                <AtomNode start="(232, 53)" end="(232, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 55)" end="(232, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(232, 55)" end="(232, 60)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(232, 61)" end="(232, 62)">
                    <IdentNode start="(232, 61)" end="(232, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 62)" end="(232, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(232, 64)" end="(232, 90)">
            <AtomNode start="(232, 64)" end="(232, 65)" leading="" trailing=" " val=":"/>
            <OtherNode start="(232, 66)" end="(232, 90)" kind="«term_↔_»">
              <OtherNode start="(232, 66)" end="(232, 81)" kind="«term_=_»">
                <OtherNode start="(232, 66)" end="(232, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(232, 66)" end="(232, 74)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(232, 75)" end="(232, 76)">
                    <IdentNode start="(232, 75)" end="(232, 76)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(232, 77)" end="(232, 78)" leading="" trailing=" " val="="/>
                <IdentNode start="(232, 79)" end="(232, 81)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
              <AtomNode start="(232, 82)" end="(232, 83)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(232, 84)" end="(232, 90)" kind="«term_∉_»">
                <IdentNode start="(232, 84)" end="(232, 85)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(232, 86)" end="(232, 87)" leading="" trailing=" " val="∉"/>
                <IdentNode start="(232, 88)" end="(232, 90)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(232, 91)" end="(234, 24)">
          <AtomNode start="(232, 91)" end="(232, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(232, 94)" end="(234, 24)">
            <AtomNode start="(232, 94)" end="(232, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(233, 3)" end="(234, 24)">
              <TacticTacticseq1IndentedNode start="(233, 3)" end="(234, 24)">
                <NullNode start="(233, 3)" end="(234, 24)">
                  <OtherNode start="(233, 3)" end="(233, 44)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;⊢ xs.erase a = xs ↔ ¬a ∈ xs" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;⊢ (∀ (a_1 : α), a_1 ∈ xs → ¬(a_1 == a) = true) ↔ ¬a ∈ xs" tactic="rw [erase_eq_eraseP', eraseP_eq_self_iff]">
                    <AtomNode start="(233, 3)" end="(233, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(233, 6)" end="(233, 44)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(233, 6)" end="(233, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(233, 7)" end="(233, 43)">
                        <OtherNode start="(233, 7)" end="(233, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(233, 7)" end="(233, 23)" leading="" trailing="" raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'" full_name="Array.erase_eq_eraseP'" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(182, 9)" def_end="(182, 25)"/>
                        </OtherNode>
                        <AtomNode start="(233, 23)" end="(233, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(233, 25)" end="(233, 43)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(233, 25)" end="(233, 43)" leading="" trailing="" raw_val="eraseP_eq_self_iff" val="eraseP_eq_self_iff" full_name="Array.eraseP_eq_self_iff" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(91, 17)" def_end="(91, 35)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(233, 43)" end="(233, 44)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(234, 3)" end="(234, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;⊢ (∀ (a_1 : α), a_1 ∈ xs → ¬(a_1 == a) = true) ↔ ¬a ∈ xs" state_after="no goals" tactic="simp [forall_mem_ne']">
                    <AtomNode start="(234, 3)" end="(234, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(234, 8)" end="(234, 24)">
                      <AtomNode start="(234, 8)" end="(234, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(234, 9)" end="(234, 23)">
                        <OtherNode start="(234, 9)" end="(234, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(234, 9)" end="(234, 23)" leading="" trailing="" raw_val="forall_mem_ne'" val="forall_mem_ne'" full_name="Array.forall_mem_ne'" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(234, 23)" end="(234, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(236, 1)" end="(239, 32)" name="erase_filter" full_name="Array.erase_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(236, 1)" end="(239, 32)" name="erase_filter" full_name="Array.erase_filter" _is_private_decl="False">
        <AtomNode start="(236, 1)" end="(236, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(236, 9)" end="(236, 21)">
          <IdentNode start="(236, 9)" end="(236, 21)" leading="" trailing=" " raw_val="erase_filter" val="erase_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(236, 22)" end="(237, 50)">
          <NullNode start="(236, 22)" end="(236, 65)">
            <OtherNode start="(236, 22)" end="(236, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(236, 22)" end="(236, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(236, 23)" end="(236, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(236, 23)" end="(236, 32)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(236, 33)" end="(236, 34)">
                  <IdentNode start="(236, 33)" end="(236, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(236, 34)" end="(236, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(236, 36)" end="(236, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(236, 36)" end="(236, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(236, 37)" end="(236, 38)">
                <IdentNode start="(236, 37)" end="(236, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(236, 39)" end="(236, 49)">
                <AtomNode start="(236, 39)" end="(236, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(236, 41)" end="(236, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(236, 41)" end="(236, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(236, 43)" end="(236, 44)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(236, 45)" end="(236, 49)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(236, 49)" end="(236, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(236, 51)" end="(236, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(236, 51)" end="(236, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(236, 52)" end="(236, 54)">
                <IdentNode start="(236, 52)" end="(236, 54)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(236, 55)" end="(236, 64)">
                <AtomNode start="(236, 55)" end="(236, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(236, 57)" end="(236, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(236, 57)" end="(236, 62)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(236, 63)" end="(236, 64)">
                    <IdentNode start="(236, 63)" end="(236, 64)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(236, 64)" end="(236, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(236, 66)" end="(237, 50)">
            <AtomNode start="(236, 66)" end="(236, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(237, 5)" end="(237, 50)" kind="«term_=_»">
              <OtherNode start="(237, 5)" end="(237, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(237, 5)" end="(237, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(237, 5)" end="(237, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(237, 5)" end="(237, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(237, 6)" end="(237, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(237, 6)" end="(237, 12)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(237, 13)" end="(237, 17)">
                        <IdentNode start="(237, 13)" end="(237, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(237, 15)" end="(237, 17)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(237, 17)" end="(237, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(237, 18)" end="(237, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(237, 19)" end="(237, 24)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(237, 25)" end="(237, 26)">
                  <IdentNode start="(237, 25)" end="(237, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(237, 27)" end="(237, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(237, 29)" end="(237, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(237, 29)" end="(237, 35)" leading="" trailing=" " raw_val="filter" val="filter" full_name="Array.filter" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(237, 36)" end="(237, 50)">
                  <IdentNode start="(237, 36)" end="(237, 37)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(237, 38)" end="(237, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(237, 38)" end="(237, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(237, 39)" end="(237, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(237, 39)" end="(237, 47)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                      <NullNode start="(237, 48)" end="(237, 49)">
                        <IdentNode start="(237, 48)" end="(237, 49)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(237, 49)" end="(237, 50)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(237, 51)" end="(239, 32)">
          <AtomNode start="(237, 51)" end="(237, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(237, 54)" end="(239, 32)">
            <AtomNode start="(237, 54)" end="(237, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(238, 3)" end="(239, 32)">
              <TacticTacticseq1IndentedNode start="(238, 3)" end="(239, 32)">
                <NullNode start="(238, 3)" end="(239, 32)">
                  <OtherNode start="(238, 3)" end="(238, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;xs : Array α&#10;⊢ (filter f xs).erase a = filter f (xs.erase a)" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;xs : List α&#10;⊢ (filter f { toList := xs }).erase a = filter f ({ toList := xs }.erase a)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(238, 3)" end="(238, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(238, 10)" end="(238, 12)">
                      <OtherNode start="(238, 10)" end="(238, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(238, 10)" end="(238, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(238, 13)" end="(238, 22)">
                      <AtomNode start="(238, 13)" end="(238, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(238, 18)" end="(238, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(238, 18)" end="(238, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(238, 18)" end="(238, 22)">
                            <OtherNode start="(238, 18)" end="(238, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(238, 18)" end="(238, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(238, 19)" end="(238, 21)">
                                <OtherNode start="(238, 19)" end="(238, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(238, 19)" end="(238, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(238, 19)" end="(238, 21)">
                                      <OtherNode start="(238, 19)" end="(238, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(238, 19)" end="(238, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(238, 21)" end="(238, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(239, 3)" end="(239, 32)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;xs : List α&#10;⊢ (filter f { toList := xs }).erase a = filter f ({ toList := xs }.erase a)" state_after="no goals" tactic="simpa using List.erase_filter">
                    <AtomNode start="(239, 3)" end="(239, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(239, 9)" end="(239, 32)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(239, 9)" end="(239, 32)">
                        <AtomNode start="(239, 9)" end="(239, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(239, 15)" end="(239, 32)" leading="" trailing="&#10;&#10;" raw_val="List.erase_filter" val="List.erase_filter" full_name="List.erase_filter" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(241, 1)" end="(245, 59)" name="erase_append_left" full_name="Array.erase_append_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(241, 1)" end="(245, 59)" name="erase_append_left" full_name="Array.erase_append_left" _is_private_decl="False">
        <AtomNode start="(241, 1)" end="(241, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(241, 9)" end="(241, 26)">
          <IdentNode start="(241, 9)" end="(241, 26)" leading="" trailing=" " raw_val="erase_append_left" val="erase_append_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(241, 27)" end="(242, 42)">
          <NullNode start="(241, 27)" end="(241, 73)">
            <OtherNode start="(241, 27)" end="(241, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(241, 27)" end="(241, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(241, 28)" end="(241, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(241, 28)" end="(241, 37)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(241, 38)" end="(241, 39)">
                  <IdentNode start="(241, 38)" end="(241, 39)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(241, 39)" end="(241, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(241, 41)" end="(241, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(241, 41)" end="(241, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(241, 42)" end="(241, 44)">
                <IdentNode start="(241, 42)" end="(241, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(241, 45)" end="(241, 54)">
                <AtomNode start="(241, 45)" end="(241, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(241, 47)" end="(241, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(241, 47)" end="(241, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(241, 53)" end="(241, 54)">
                    <IdentNode start="(241, 53)" end="(241, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(241, 54)" end="(241, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(241, 56)" end="(241, 60)">
              <AtomNode start="(241, 56)" end="(241, 57)" leading="" trailing="" val="("/>
              <NullNode start="(241, 57)" end="(241, 59)">
                <IdentNode start="(241, 57)" end="(241, 59)" leading="" trailing="" raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(241, 59)" end="(241, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(241, 61)" end="(241, 73)">
              <AtomNode start="(241, 61)" end="(241, 62)" leading="" trailing="" val="("/>
              <NullNode start="(241, 62)" end="(241, 63)">
                <IdentNode start="(241, 62)" end="(241, 63)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(241, 64)" end="(241, 72)">
                <AtomNode start="(241, 64)" end="(241, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(241, 66)" end="(241, 72)" kind="«term_∈_»">
                  <IdentNode start="(241, 66)" end="(241, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(241, 68)" end="(241, 69)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(241, 70)" end="(241, 72)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(241, 72)" end="(241, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(241, 74)" end="(242, 42)">
            <AtomNode start="(241, 74)" end="(241, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(242, 5)" end="(242, 42)" kind="«term_=_»">
              <OtherNode start="(242, 5)" end="(242, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(242, 5)" end="(242, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(242, 5)" end="(242, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(242, 5)" end="(242, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(242, 6)" end="(242, 14)" kind="«term_++_»">
                      <IdentNode start="(242, 6)" end="(242, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(242, 9)" end="(242, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(242, 12)" end="(242, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(242, 14)" end="(242, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(242, 15)" end="(242, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(242, 16)" end="(242, 21)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(242, 22)" end="(242, 23)">
                  <IdentNode start="(242, 22)" end="(242, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(242, 24)" end="(242, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(242, 26)" end="(242, 42)" kind="«term_++_»">
                <OtherNode start="(242, 26)" end="(242, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(242, 26)" end="(242, 34)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(242, 35)" end="(242, 36)">
                    <IdentNode start="(242, 35)" end="(242, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(242, 37)" end="(242, 39)" leading="" trailing=" " val="++"/>
                <IdentNode start="(242, 40)" end="(242, 42)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(242, 43)" end="(245, 59)">
          <AtomNode start="(242, 43)" end="(242, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(242, 46)" end="(245, 59)">
            <AtomNode start="(242, 46)" end="(242, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(243, 3)" end="(245, 59)">
              <TacticTacticseq1IndentedNode start="(243, 3)" end="(245, 59)">
                <NullNode start="(243, 3)" end="(245, 59)">
                  <OtherNode start="(243, 3)" end="(243, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;xs ys : Array α&#10;h : a ∈ xs&#10;⊢ (xs ++ ys).erase a = xs.erase a ++ ys" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;ys : Array α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;⊢ ({ toList := xs } ++ ys).erase a = { toList := xs }.erase a ++ ys" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(243, 3)" end="(243, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(243, 10)" end="(243, 12)">
                      <OtherNode start="(243, 10)" end="(243, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(243, 10)" end="(243, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(243, 13)" end="(243, 22)">
                      <AtomNode start="(243, 13)" end="(243, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(243, 18)" end="(243, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(243, 18)" end="(243, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(243, 18)" end="(243, 22)">
                            <OtherNode start="(243, 18)" end="(243, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(243, 18)" end="(243, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(243, 19)" end="(243, 21)">
                                <OtherNode start="(243, 19)" end="(243, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(243, 19)" end="(243, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(243, 19)" end="(243, 21)">
                                      <OtherNode start="(243, 19)" end="(243, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(243, 19)" end="(243, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(243, 21)" end="(243, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(244, 3)" end="(244, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;ys : Array α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;⊢ ({ toList := xs } ++ ys).erase a = { toList := xs }.erase a ++ ys" state_after="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).erase a = { toList := xs }.erase a ++ { toList := ys }" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(244, 3)" end="(244, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(244, 10)" end="(244, 12)">
                      <OtherNode start="(244, 10)" end="(244, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(244, 10)" end="(244, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(244, 13)" end="(244, 22)">
                      <AtomNode start="(244, 13)" end="(244, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(244, 18)" end="(244, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(244, 18)" end="(244, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(244, 18)" end="(244, 22)">
                            <OtherNode start="(244, 18)" end="(244, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(244, 18)" end="(244, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(244, 19)" end="(244, 21)">
                                <OtherNode start="(244, 19)" end="(244, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(244, 19)" end="(244, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(244, 19)" end="(244, 21)">
                                      <OtherNode start="(244, 19)" end="(244, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(244, 19)" end="(244, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(244, 21)" end="(244, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(245, 3)" end="(245, 59)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).erase a = { toList := xs }.erase a ++ { toList := ys }" state_after="no goals" tactic="simpa using List.erase_append_left ys (by simpa using h)">
                    <AtomNode start="(245, 3)" end="(245, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(245, 9)" end="(245, 59)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(245, 9)" end="(245, 59)">
                        <AtomNode start="(245, 9)" end="(245, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(245, 15)" end="(245, 59)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(245, 15)" end="(245, 37)" leading="" trailing=" " raw_val="List.erase_append_left" val="List.erase_append_left" full_name="List.erase_append_left" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(245, 38)" end="(245, 59)">
                            <IdentNode start="(245, 38)" end="(245, 40)" leading="" trailing=" " raw_val="ys" val="ys"/>
                            <OtherNode start="(245, 41)" end="(245, 59)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(245, 41)" end="(245, 42)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(245, 42)" end="(245, 58)">
                                <AtomNode start="(245, 42)" end="(245, 44)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(245, 45)" end="(245, 58)">
                                  <TacticTacticseq1IndentedNode start="(245, 45)" end="(245, 58)">
                                    <NullNode start="(245, 45)" end="(245, 58)">
                                      <OtherNode start="(245, 45)" end="(245, 58)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;h : a ∈ { toList := xs }&#10;ys : List α&#10;⊢ a ∈ xs" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(245, 45)" end="(245, 50)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(245, 51)" end="(245, 58)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(245, 51)" end="(245, 58)">
                                            <AtomNode start="(245, 51)" end="(245, 56)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(245, 57)" end="(245, 58)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(245, 58)" end="(245, 59)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(247, 1)" end="(251, 60)" name="erase_append_right" full_name="Array.erase_append_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(247, 1)" end="(251, 60)" name="erase_append_right" full_name="Array.erase_append_right" _is_private_decl="False">
        <AtomNode start="(247, 1)" end="(247, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(247, 9)" end="(247, 27)">
          <IdentNode start="(247, 9)" end="(247, 27)" leading="" trailing=" " raw_val="erase_append_right" val="erase_append_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(247, 28)" end="(248, 44)">
          <NullNode start="(247, 28)" end="(247, 92)">
            <OtherNode start="(247, 28)" end="(247, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(247, 28)" end="(247, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(247, 29)" end="(247, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(247, 29)" end="(247, 38)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(247, 39)" end="(247, 40)">
                  <IdentNode start="(247, 39)" end="(247, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(247, 40)" end="(247, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(247, 42)" end="(247, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(247, 42)" end="(247, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(247, 43)" end="(247, 44)">
                <IdentNode start="(247, 43)" end="(247, 44)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(247, 45)" end="(247, 48)">
                <AtomNode start="(247, 45)" end="(247, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(247, 47)" end="(247, 48)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(247, 48)" end="(247, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(247, 50)" end="(247, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(247, 50)" end="(247, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(247, 51)" end="(247, 53)">
                <IdentNode start="(247, 51)" end="(247, 53)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(247, 54)" end="(247, 63)">
                <AtomNode start="(247, 54)" end="(247, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(247, 56)" end="(247, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(247, 56)" end="(247, 61)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(247, 62)" end="(247, 63)">
                    <IdentNode start="(247, 62)" end="(247, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(247, 63)" end="(247, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(247, 65)" end="(247, 79)">
              <AtomNode start="(247, 65)" end="(247, 66)" leading="" trailing="" val="("/>
              <NullNode start="(247, 66)" end="(247, 68)">
                <IdentNode start="(247, 66)" end="(247, 68)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(247, 69)" end="(247, 78)">
                <AtomNode start="(247, 69)" end="(247, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(247, 71)" end="(247, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(247, 71)" end="(247, 76)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(247, 77)" end="(247, 78)">
                    <IdentNode start="(247, 77)" end="(247, 78)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(247, 78)" end="(247, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(247, 80)" end="(247, 92)">
              <AtomNode start="(247, 80)" end="(247, 81)" leading="" trailing="" val="("/>
              <NullNode start="(247, 81)" end="(247, 82)">
                <IdentNode start="(247, 81)" end="(247, 82)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(247, 83)" end="(247, 91)">
                <AtomNode start="(247, 83)" end="(247, 84)" leading="" trailing=" " val=":"/>
                <OtherNode start="(247, 85)" end="(247, 91)" kind="«term_∉_»">
                  <IdentNode start="(247, 85)" end="(247, 86)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(247, 87)" end="(247, 88)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(247, 89)" end="(247, 91)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(247, 91)" end="(247, 92)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(247, 93)" end="(248, 44)">
            <AtomNode start="(247, 93)" end="(247, 94)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(248, 5)" end="(248, 44)" kind="«term_=_»">
              <OtherNode start="(248, 5)" end="(248, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(248, 5)" end="(248, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(248, 5)" end="(248, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(248, 5)" end="(248, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(248, 6)" end="(248, 14)" kind="«term_++_»">
                      <IdentNode start="(248, 6)" end="(248, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(248, 9)" end="(248, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(248, 12)" end="(248, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(248, 14)" end="(248, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(248, 15)" end="(248, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(248, 16)" end="(248, 21)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(248, 22)" end="(248, 23)">
                  <IdentNode start="(248, 22)" end="(248, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(248, 24)" end="(248, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(248, 26)" end="(248, 44)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(248, 26)" end="(248, 27)" leading="" trailing="" val="("/>
                <OtherNode start="(248, 27)" end="(248, 43)" kind="«term_++_»">
                  <IdentNode start="(248, 27)" end="(248, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(248, 30)" end="(248, 32)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(248, 33)" end="(248, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(248, 33)" end="(248, 41)" leading="" trailing=" " raw_val="ys.erase" val="ys.erase"/>
                    <NullNode start="(248, 42)" end="(248, 43)">
                      <IdentNode start="(248, 42)" end="(248, 43)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(248, 43)" end="(248, 44)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(248, 45)" end="(251, 60)">
          <AtomNode start="(248, 45)" end="(248, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(248, 48)" end="(251, 60)">
            <AtomNode start="(248, 48)" end="(248, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(249, 3)" end="(251, 60)">
              <TacticTacticseq1IndentedNode start="(249, 3)" end="(251, 60)">
                <NullNode start="(249, 3)" end="(251, 60)">
                  <OtherNode start="(249, 3)" end="(249, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs ys : Array α&#10;h : ¬a ∈ xs&#10;⊢ (xs ++ ys).erase a = xs ++ ys.erase a" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;ys : Array α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ ({ toList := xs } ++ ys).erase a = { toList := xs } ++ ys.erase a" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(249, 3)" end="(249, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(249, 10)" end="(249, 12)">
                      <OtherNode start="(249, 10)" end="(249, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(249, 10)" end="(249, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(249, 13)" end="(249, 22)">
                      <AtomNode start="(249, 13)" end="(249, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(249, 18)" end="(249, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(249, 18)" end="(249, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(249, 18)" end="(249, 22)">
                            <OtherNode start="(249, 18)" end="(249, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(249, 18)" end="(249, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(249, 19)" end="(249, 21)">
                                <OtherNode start="(249, 19)" end="(249, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(249, 19)" end="(249, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(249, 19)" end="(249, 21)">
                                      <OtherNode start="(249, 19)" end="(249, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(249, 19)" end="(249, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(249, 21)" end="(249, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(250, 3)" end="(250, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;ys : Array α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;⊢ ({ toList := xs } ++ ys).erase a = { toList := xs } ++ ys.erase a" state_after="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).erase a = { toList := xs } ++ { toList := ys }.erase a" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(250, 3)" end="(250, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(250, 10)" end="(250, 12)">
                      <OtherNode start="(250, 10)" end="(250, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(250, 10)" end="(250, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(250, 13)" end="(250, 22)">
                      <AtomNode start="(250, 13)" end="(250, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(250, 18)" end="(250, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(250, 18)" end="(250, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(250, 18)" end="(250, 22)">
                            <OtherNode start="(250, 18)" end="(250, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(250, 18)" end="(250, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(250, 19)" end="(250, 21)">
                                <OtherNode start="(250, 19)" end="(250, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(250, 19)" end="(250, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(250, 19)" end="(250, 21)">
                                      <OtherNode start="(250, 19)" end="(250, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(250, 19)" end="(250, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(250, 21)" end="(250, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(251, 3)" end="(251, 60)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).erase a = { toList := xs } ++ { toList := ys }.erase a" state_after="no goals" tactic="simpa using List.erase_append_right ys (by simpa using h)">
                    <AtomNode start="(251, 3)" end="(251, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(251, 9)" end="(251, 60)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(251, 9)" end="(251, 60)">
                        <AtomNode start="(251, 9)" end="(251, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(251, 15)" end="(251, 60)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(251, 15)" end="(251, 38)" leading="" trailing=" " raw_val="List.erase_append_right" val="List.erase_append_right" full_name="List.erase_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(251, 39)" end="(251, 60)">
                            <IdentNode start="(251, 39)" end="(251, 41)" leading="" trailing=" " raw_val="ys" val="ys"/>
                            <OtherNode start="(251, 42)" end="(251, 60)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(251, 42)" end="(251, 43)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(251, 43)" end="(251, 59)">
                                <AtomNode start="(251, 43)" end="(251, 45)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(251, 46)" end="(251, 59)">
                                  <TacticTacticseq1IndentedNode start="(251, 46)" end="(251, 59)">
                                    <NullNode start="(251, 46)" end="(251, 59)">
                                      <OtherNode start="(251, 46)" end="(251, 59)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : List α&#10;h : ¬a ∈ { toList := xs }&#10;ys : List α&#10;⊢ ¬a ∈ xs" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(251, 46)" end="(251, 51)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(251, 52)" end="(251, 59)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(251, 52)" end="(251, 59)">
                                            <AtomNode start="(251, 52)" end="(251, 57)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(251, 58)" end="(251, 59)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(251, 59)" end="(251, 60)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(253, 1)" end="(258, 17)" name="erase_append" full_name="Array.erase_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(253, 1)" end="(258, 17)" name="erase_append" full_name="Array.erase_append" _is_private_decl="False">
        <AtomNode start="(253, 1)" end="(253, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(253, 9)" end="(253, 21)">
          <IdentNode start="(253, 9)" end="(253, 21)" leading="" trailing=" " raw_val="erase_append" val="erase_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(253, 22)" end="(254, 79)">
          <NullNode start="(253, 22)" end="(253, 61)">
            <OtherNode start="(253, 22)" end="(253, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(253, 22)" end="(253, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(253, 23)" end="(253, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(253, 23)" end="(253, 32)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(253, 33)" end="(253, 34)">
                  <IdentNode start="(253, 33)" end="(253, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(253, 34)" end="(253, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(253, 36)" end="(253, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(253, 36)" end="(253, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(253, 37)" end="(253, 38)">
                <IdentNode start="(253, 37)" end="(253, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(253, 39)" end="(253, 42)">
                <AtomNode start="(253, 39)" end="(253, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(253, 41)" end="(253, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(253, 42)" end="(253, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(253, 44)" end="(253, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(253, 44)" end="(253, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(253, 45)" end="(253, 50)">
                <IdentNode start="(253, 45)" end="(253, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(253, 48)" end="(253, 50)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(253, 51)" end="(253, 60)">
                <AtomNode start="(253, 51)" end="(253, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(253, 53)" end="(253, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(253, 53)" end="(253, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(253, 59)" end="(253, 60)">
                    <IdentNode start="(253, 59)" end="(253, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(253, 60)" end="(253, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(253, 62)" end="(254, 79)">
            <AtomNode start="(253, 62)" end="(253, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(254, 5)" end="(254, 79)" kind="«term_=_»">
              <OtherNode start="(254, 5)" end="(254, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(254, 5)" end="(254, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(254, 5)" end="(254, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(254, 5)" end="(254, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(254, 6)" end="(254, 14)" kind="«term_++_»">
                      <IdentNode start="(254, 6)" end="(254, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(254, 9)" end="(254, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(254, 12)" end="(254, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(254, 14)" end="(254, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(254, 15)" end="(254, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(254, 16)" end="(254, 21)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(254, 22)" end="(254, 23)">
                  <IdentNode start="(254, 22)" end="(254, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(254, 24)" end="(254, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(254, 26)" end="(254, 79)" kind="termIfThenElse">
                <AtomNode start="(254, 26)" end="(254, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(254, 29)" end="(254, 35)" kind="«term_∈_»">
                  <IdentNode start="(254, 29)" end="(254, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(254, 31)" end="(254, 32)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(254, 33)" end="(254, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(254, 36)" end="(254, 40)" leading="" trailing=" " val="then"/>
                <OtherNode start="(254, 41)" end="(254, 57)" kind="«term_++_»">
                  <OtherNode start="(254, 41)" end="(254, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(254, 41)" end="(254, 49)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                    <NullNode start="(254, 50)" end="(254, 51)">
                      <IdentNode start="(254, 50)" end="(254, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(254, 52)" end="(254, 54)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(254, 55)" end="(254, 57)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(254, 58)" end="(254, 62)" leading="" trailing=" " val="else"/>
                <OtherNode start="(254, 63)" end="(254, 79)" kind="«term_++_»">
                  <IdentNode start="(254, 63)" end="(254, 65)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(254, 66)" end="(254, 68)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(254, 69)" end="(254, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(254, 69)" end="(254, 77)" leading="" trailing=" " raw_val="ys.erase" val="ys.erase"/>
                    <NullNode start="(254, 78)" end="(254, 79)">
                      <IdentNode start="(254, 78)" end="(254, 79)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(254, 80)" end="(258, 17)">
          <AtomNode start="(254, 80)" end="(254, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(254, 83)" end="(258, 17)">
            <AtomNode start="(254, 83)" end="(254, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(255, 3)" end="(258, 17)">
              <TacticTacticseq1IndentedNode start="(255, 3)" end="(258, 17)">
                <NullNode start="(255, 3)" end="(258, 17)">
                  <OtherNode start="(255, 3)" end="(255, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs ys : Array α&#10;⊢ (xs ++ ys).erase a = if a ∈ xs then xs.erase a ++ ys else xs ++ ys.erase a" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;ys : Array α&#10;xs : List α&#10;⊢ ({ toList := xs } ++ ys).erase a =&#10;    if a ∈ { toList := xs } then { toList := xs }.erase a ++ ys else { toList := xs } ++ ys.erase a" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(255, 3)" end="(255, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(255, 10)" end="(255, 12)">
                      <OtherNode start="(255, 10)" end="(255, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(255, 10)" end="(255, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(255, 13)" end="(255, 22)">
                      <AtomNode start="(255, 13)" end="(255, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(255, 18)" end="(255, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(255, 18)" end="(255, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(255, 18)" end="(255, 22)">
                            <OtherNode start="(255, 18)" end="(255, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(255, 18)" end="(255, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(255, 19)" end="(255, 21)">
                                <OtherNode start="(255, 19)" end="(255, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(255, 19)" end="(255, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(255, 19)" end="(255, 21)">
                                      <OtherNode start="(255, 19)" end="(255, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(255, 19)" end="(255, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(255, 21)" end="(255, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(256, 3)" end="(256, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;ys : Array α&#10;xs : List α&#10;⊢ ({ toList := xs } ++ ys).erase a =&#10;    if a ∈ { toList := xs } then { toList := xs }.erase a ++ ys else { toList := xs } ++ ys.erase a" state_after="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).erase a =&#10;    if a ∈ { toList := xs } then { toList := xs }.erase a ++ { toList := ys }&#10;    else { toList := xs } ++ { toList := ys }.erase a" tactic="rcases ys with ⟨ys⟩">
                    <AtomNode start="(256, 3)" end="(256, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(256, 10)" end="(256, 12)">
                      <OtherNode start="(256, 10)" end="(256, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(256, 10)" end="(256, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(256, 13)" end="(256, 22)">
                      <AtomNode start="(256, 13)" end="(256, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(256, 18)" end="(256, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(256, 18)" end="(256, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(256, 18)" end="(256, 22)">
                            <OtherNode start="(256, 18)" end="(256, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(256, 18)" end="(256, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(256, 19)" end="(256, 21)">
                                <OtherNode start="(256, 19)" end="(256, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(256, 19)" end="(256, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(256, 19)" end="(256, 21)">
                                      <OtherNode start="(256, 19)" end="(256, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(256, 19)" end="(256, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(256, 21)" end="(256, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(257, 3)" end="(257, 86)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs ys : List α&#10;⊢ ({ toList := xs } ++ { toList := ys }).erase a =&#10;    if a ∈ { toList := xs } then { toList := xs }.erase a ++ { toList := ys }&#10;    else { toList := xs } ++ { toList := ys }.erase a" state_after="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs ys : List α&#10;⊢ (if a ∈ xs then xs.erase a ++ ys else xs ++ ys.erase a).toArray =&#10;    if a ∈ xs then (xs.erase a ++ ys).toArray else (xs ++ ys.erase a).toArray" tactic="simp only [List.append_toArray, List.erase_toArray, List.erase_append, mem_toArray]">
                    <AtomNode start="(257, 3)" end="(257, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(257, 8)" end="(257, 12)">
                      <AtomNode start="(257, 8)" end="(257, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(257, 13)" end="(257, 86)">
                      <AtomNode start="(257, 13)" end="(257, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(257, 14)" end="(257, 85)">
                        <OtherNode start="(257, 14)" end="(257, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(257, 14)" end="(257, 33)" leading="" trailing="" raw_val="List.append_toArray" val="List.append_toArray" full_name="List.append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(257, 33)" end="(257, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(257, 35)" end="(257, 53)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(257, 35)" end="(257, 53)" leading="" trailing="" raw_val="List.erase_toArray" val="List.erase_toArray" full_name="List.erase_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(257, 53)" end="(257, 54)" leading="" trailing=" " val=","/>
                        <OtherNode start="(257, 55)" end="(257, 72)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(257, 55)" end="(257, 72)" leading="" trailing="" raw_val="List.erase_append" val="List.erase_append" full_name="List.erase_append" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(257, 72)" end="(257, 73)" leading="" trailing=" " val=","/>
                        <OtherNode start="(257, 74)" end="(257, 85)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(257, 74)" end="(257, 85)" leading="" trailing="" raw_val="mem_toArray" val="mem_toArray" full_name="Array.mem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(257, 85)" end="(257, 86)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(258, 3)" end="(258, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mk.mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs ys : List α&#10;⊢ (if a ∈ xs then xs.erase a ++ ys else xs ++ ys.erase a).toArray =&#10;    if a ∈ xs then (xs.erase a ++ ys).toArray else (xs ++ ys.erase a).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(258, 3)" end="(258, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(258, 3)" end="(258, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(258, 9)" end="(258, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(258, 13)" end="(258, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(258, 13)" end="(258, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(260, 1)" end="(264, 17)" name="erase_replicate" full_name="Array.erase_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(260, 1)" end="(264, 17)" name="erase_replicate" full_name="Array.erase_replicate" _is_private_decl="False">
        <AtomNode start="(260, 1)" end="(260, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(260, 9)" end="(260, 24)">
          <IdentNode start="(260, 9)" end="(260, 24)" leading="" trailing=" " raw_val="erase_replicate" val="erase_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(260, 25)" end="(261, 84)">
          <NullNode start="(260, 25)" end="(260, 58)">
            <OtherNode start="(260, 25)" end="(260, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(260, 25)" end="(260, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(260, 26)" end="(260, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(260, 26)" end="(260, 35)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(260, 36)" end="(260, 37)">
                  <IdentNode start="(260, 36)" end="(260, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(260, 37)" end="(260, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(260, 39)" end="(260, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(260, 39)" end="(260, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(260, 40)" end="(260, 41)">
                <IdentNode start="(260, 40)" end="(260, 41)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(260, 42)" end="(260, 47)">
                <AtomNode start="(260, 42)" end="(260, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(260, 44)" end="(260, 47)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(260, 47)" end="(260, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(260, 49)" end="(260, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(260, 49)" end="(260, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(260, 50)" end="(260, 53)">
                <IdentNode start="(260, 50)" end="(260, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(260, 52)" end="(260, 53)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(260, 54)" end="(260, 57)">
                <AtomNode start="(260, 54)" end="(260, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(260, 56)" end="(260, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(260, 57)" end="(260, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(260, 59)" end="(261, 84)">
            <AtomNode start="(260, 59)" end="(260, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(261, 5)" end="(261, 84)" kind="«term_=_»">
              <OtherNode start="(261, 5)" end="(261, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(261, 5)" end="(261, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(261, 5)" end="(261, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(261, 5)" end="(261, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(261, 6)" end="(261, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(261, 6)" end="(261, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(261, 16)" end="(261, 19)">
                        <IdentNode start="(261, 16)" end="(261, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(261, 18)" end="(261, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(261, 19)" end="(261, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(261, 20)" end="(261, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(261, 21)" end="(261, 26)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(261, 27)" end="(261, 28)">
                  <IdentNode start="(261, 27)" end="(261, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(261, 29)" end="(261, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(261, 31)" end="(261, 84)" kind="termIfThenElse">
                <AtomNode start="(261, 31)" end="(261, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(261, 34)" end="(261, 40)" kind="«term_==_»">
                  <IdentNode start="(261, 34)" end="(261, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(261, 36)" end="(261, 38)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(261, 39)" end="(261, 40)" leading="" trailing=" " raw_val="a" val="a"/>
                </OtherNode>
                <AtomNode start="(261, 41)" end="(261, 45)" leading="" trailing=" " val="then"/>
                <OtherNode start="(261, 46)" end="(261, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(261, 46)" end="(261, 55)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(261, 56)" end="(261, 65)">
                    <OtherNode start="(261, 56)" end="(261, 63)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(261, 56)" end="(261, 57)" leading="" trailing="" val="("/>
                      <OtherNode start="(261, 57)" end="(261, 62)" kind="«term_-_»">
                        <IdentNode start="(261, 57)" end="(261, 58)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(261, 59)" end="(261, 60)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(261, 61)" end="(261, 62)" kind="num">
                          <AtomNode start="(261, 61)" end="(261, 62)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(261, 62)" end="(261, 63)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(261, 64)" end="(261, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(261, 66)" end="(261, 70)" leading="" trailing=" " val="else"/>
                <OtherNode start="(261, 71)" end="(261, 84)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(261, 71)" end="(261, 80)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(261, 81)" end="(261, 84)">
                    <IdentNode start="(261, 81)" end="(261, 82)" leading="" trailing=" " raw_val="n" val="n"/>
                    <IdentNode start="(261, 83)" end="(261, 84)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(261, 85)" end="(264, 17)">
          <AtomNode start="(261, 85)" end="(261, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(261, 88)" end="(264, 17)">
            <AtomNode start="(261, 88)" end="(261, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(262, 3)" end="(264, 17)">
              <TacticTacticseq1IndentedNode start="(262, 3)" end="(264, 17)">
                <NullNode start="(262, 3)" end="(264, 17)">
                  <OtherNode start="(262, 3)" end="(262, 59)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ (replicate n a).erase b = if (b == a) = true then replicate (n - 1) a else replicate n a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ ((List.replicate n a).erase b).toArray =&#10;    if (b == a) = true then (List.replicate (n - 1) a).toArray else (List.replicate n a).toArray" tactic="simp only [← List.toArray_replicate, List.erase_toArray]">
                    <AtomNode start="(262, 3)" end="(262, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(262, 8)" end="(262, 12)">
                      <AtomNode start="(262, 8)" end="(262, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(262, 13)" end="(262, 59)">
                      <AtomNode start="(262, 13)" end="(262, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(262, 14)" end="(262, 58)">
                        <OtherNode start="(262, 14)" end="(262, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(262, 14)" end="(262, 15)">
                            <OtherNode start="(262, 14)" end="(262, 15)" kind="patternIgnore">
                              <OtherNode start="(262, 14)" end="(262, 15)" kind="token.«← »">
                                <AtomNode start="(262, 14)" end="(262, 15)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(262, 16)" end="(262, 38)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(262, 38)" end="(262, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(262, 40)" end="(262, 58)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(262, 40)" end="(262, 58)" leading="" trailing="" raw_val="List.erase_toArray" val="List.erase_toArray" full_name="List.erase_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(262, 58)" end="(262, 59)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(263, 3)" end="(263, 71)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ ((List.replicate n a).erase b).toArray =&#10;    if (b == a) = true then (List.replicate (n - 1) a).toArray else (List.replicate n a).toArray" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ (if (b == a) = true then List.replicate (n - 1) a else List.replicate n a).toArray =&#10;    if (b == a) = true then replicate (n - 1) a else replicate n a" tactic="simp only [List.erase_replicate, beq_iff_eq, List.toArray_replicate]">
                    <AtomNode start="(263, 3)" end="(263, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(263, 8)" end="(263, 12)">
                      <AtomNode start="(263, 8)" end="(263, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(263, 13)" end="(263, 71)">
                      <AtomNode start="(263, 13)" end="(263, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(263, 14)" end="(263, 70)">
                        <OtherNode start="(263, 14)" end="(263, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(263, 14)" end="(263, 34)" leading="" trailing="" raw_val="List.erase_replicate" val="List.erase_replicate" full_name="List.erase_replicate" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(263, 34)" end="(263, 35)" leading="" trailing=" " val=","/>
                        <OtherNode start="(263, 36)" end="(263, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(263, 36)" end="(263, 46)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(263, 46)" end="(263, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(263, 48)" end="(263, 70)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(263, 48)" end="(263, 70)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(263, 70)" end="(263, 71)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(264, 3)" end="(264, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ (if (b == a) = true then List.replicate (n - 1) a else List.replicate n a).toArray =&#10;    if (b == a) = true then replicate (n - 1) a else replicate n a" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(264, 3)" end="(264, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(264, 3)" end="(264, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(264, 9)" end="(264, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(264, 13)" end="(264, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(264, 13)" end="(264, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(266, 1)" end="(267, 41)" name="erase_mkArray" full_name="Array.erase_mkArray">
      <CommandDeclmodifiersNode start="(266, 1)" end="(266, 54)">
        <NullNode/>
        <NullNode start="(266, 1)" end="(266, 54)">
          <OtherNode start="(266, 1)" end="(266, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(266, 1)" end="(266, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(266, 3)" end="(266, 53)">
              <OtherNode start="(266, 3)" end="(266, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(266, 3)" end="(266, 53)" kind="Lean.deprecated">
                  <AtomNode start="(266, 3)" end="(266, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(266, 14)" end="(266, 29)">
                    <IdentNode start="(266, 14)" end="(266, 29)" leading="" trailing=" " raw_val="erase_replicate" val="erase_replicate" full_name="Array.erase_replicate" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(260, 9)" def_end="(260, 24)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(266, 30)" end="(266, 53)">
                    <AtomNode start="(266, 30)" end="(266, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(266, 31)" end="(266, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(266, 37)" end="(266, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(266, 40)" end="(266, 52)" kind="str">
                      <AtomNode start="(266, 40)" end="(266, 52)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(266, 52)" end="(266, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(266, 53)" end="(266, 54)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(267, 1)" end="(267, 41)" name="erase_mkArray">
        <AtomNode start="(267, 1)" end="(267, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(267, 8)" end="(267, 21)">
          <IdentNode start="(267, 8)" end="(267, 21)" leading="" trailing=" " raw_val="erase_mkArray" val="erase_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(267, 22)" end="(267, 41)">
          <AtomNode start="(267, 22)" end="(267, 24)" leading="" trailing=" " val=":="/>
          <OtherNode start="(267, 25)" end="(267, 41)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(267, 25)" end="(267, 26)" leading="" trailing="" val="@"/>
            <IdentNode start="(267, 26)" end="(267, 41)" leading="" trailing="&#10;&#10;-- The arguments `a b` are explicit,&#10;-- so they can be specified to prevent `simp` repeatedly applying the lemma.&#10;" raw_val="erase_replicate" val="erase_replicate" full_name="Array.erase_replicate" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(260, 9)" def_end="(260, 24)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(271, 1)" end="(274, 34)" name="erase_comm" full_name="Array.erase_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(271, 1)" end="(274, 34)" name="erase_comm" full_name="Array.erase_comm" _is_private_decl="False">
        <AtomNode start="(271, 1)" end="(271, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(271, 9)" end="(271, 19)">
          <IdentNode start="(271, 9)" end="(271, 19)" leading="" trailing=" " raw_val="erase_comm" val="erase_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(271, 20)" end="(272, 48)">
          <NullNode start="(271, 20)" end="(271, 58)">
            <OtherNode start="(271, 20)" end="(271, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(271, 20)" end="(271, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(271, 21)" end="(271, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(271, 21)" end="(271, 30)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(271, 31)" end="(271, 32)">
                  <IdentNode start="(271, 31)" end="(271, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(271, 32)" end="(271, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(271, 34)" end="(271, 43)">
              <AtomNode start="(271, 34)" end="(271, 35)" leading="" trailing="" val="("/>
              <NullNode start="(271, 35)" end="(271, 38)">
                <IdentNode start="(271, 35)" end="(271, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(271, 37)" end="(271, 38)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(271, 39)" end="(271, 42)">
                <AtomNode start="(271, 39)" end="(271, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(271, 41)" end="(271, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(271, 42)" end="(271, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(271, 44)" end="(271, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(271, 44)" end="(271, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(271, 45)" end="(271, 47)">
                <IdentNode start="(271, 45)" end="(271, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(271, 48)" end="(271, 57)">
                <AtomNode start="(271, 48)" end="(271, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(271, 50)" end="(271, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(271, 50)" end="(271, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(271, 56)" end="(271, 57)">
                    <IdentNode start="(271, 56)" end="(271, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(271, 57)" end="(271, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(271, 59)" end="(272, 48)">
            <AtomNode start="(271, 59)" end="(271, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(272, 5)" end="(272, 48)" kind="«term_=_»">
              <OtherNode start="(272, 5)" end="(272, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(272, 5)" end="(272, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(272, 5)" end="(272, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(272, 5)" end="(272, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(272, 6)" end="(272, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(272, 6)" end="(272, 14)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                      <NullNode start="(272, 15)" end="(272, 16)">
                        <IdentNode start="(272, 15)" end="(272, 16)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(272, 16)" end="(272, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(272, 17)" end="(272, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(272, 18)" end="(272, 23)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(272, 24)" end="(272, 25)">
                  <IdentNode start="(272, 24)" end="(272, 25)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(272, 26)" end="(272, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(272, 28)" end="(272, 48)" kind="Lean.Parser.Term.app">
                <OtherNode start="(272, 28)" end="(272, 46)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(272, 28)" end="(272, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(272, 28)" end="(272, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(272, 29)" end="(272, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(272, 29)" end="(272, 37)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                      <NullNode start="(272, 38)" end="(272, 39)">
                        <IdentNode start="(272, 38)" end="(272, 39)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(272, 39)" end="(272, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(272, 40)" end="(272, 41)" leading="" trailing="" val="."/>
                  <IdentNode start="(272, 41)" end="(272, 46)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(272, 47)" end="(272, 48)">
                  <IdentNode start="(272, 47)" end="(272, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(272, 49)" end="(274, 34)">
          <AtomNode start="(272, 49)" end="(272, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(272, 52)" end="(274, 34)">
            <AtomNode start="(272, 52)" end="(272, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(273, 3)" end="(274, 34)">
              <TacticTacticseq1IndentedNode start="(273, 3)" end="(274, 34)">
                <NullNode start="(273, 3)" end="(274, 34)">
                  <OtherNode start="(273, 3)" end="(273, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;xs : Array α&#10;⊢ (xs.erase a).erase b = (xs.erase b).erase a" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;xs : List α&#10;⊢ ({ toList := xs }.erase a).erase b = ({ toList := xs }.erase b).erase a" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(273, 3)" end="(273, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(273, 10)" end="(273, 12)">
                      <OtherNode start="(273, 10)" end="(273, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(273, 10)" end="(273, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(273, 13)" end="(273, 22)">
                      <AtomNode start="(273, 13)" end="(273, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(273, 18)" end="(273, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(273, 18)" end="(273, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(273, 18)" end="(273, 22)">
                            <OtherNode start="(273, 18)" end="(273, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(273, 18)" end="(273, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(273, 19)" end="(273, 21)">
                                <OtherNode start="(273, 19)" end="(273, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(273, 19)" end="(273, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(273, 19)" end="(273, 21)">
                                      <OtherNode start="(273, 19)" end="(273, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(273, 19)" end="(273, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(273, 21)" end="(273, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(274, 3)" end="(274, 34)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;xs : List α&#10;⊢ ({ toList := xs }.erase a).erase b = ({ toList := xs }.erase b).erase a" state_after="no goals" tactic="simpa using List.erase_comm a b">
                    <AtomNode start="(274, 3)" end="(274, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(274, 9)" end="(274, 34)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(274, 9)" end="(274, 34)">
                        <AtomNode start="(274, 9)" end="(274, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(274, 15)" end="(274, 34)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(274, 15)" end="(274, 30)" leading="" trailing=" " raw_val="List.erase_comm" val="List.erase_comm" full_name="List.erase_comm" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(274, 31)" end="(274, 34)">
                            <IdentNode start="(274, 31)" end="(274, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(274, 33)" end="(274, 34)" leading="" trailing="&#10;&#10;" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(276, 1)" end="(288, 49)" name="erase_eq_iff" full_name="Array.erase_eq_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(276, 1)" end="(288, 49)" name="erase_eq_iff" full_name="Array.erase_eq_iff" _is_private_decl="False">
        <AtomNode start="(276, 1)" end="(276, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(276, 9)" end="(276, 21)">
          <IdentNode start="(276, 9)" end="(276, 21)" leading="" trailing=" " raw_val="erase_eq_iff" val="erase_eq_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(276, 22)" end="(279, 63)">
          <NullNode start="(276, 22)" end="(276, 58)">
            <OtherNode start="(276, 22)" end="(276, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(276, 22)" end="(276, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(276, 23)" end="(276, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(276, 23)" end="(276, 32)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(276, 33)" end="(276, 34)">
                  <IdentNode start="(276, 33)" end="(276, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(276, 34)" end="(276, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(276, 36)" end="(276, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(276, 36)" end="(276, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(276, 37)" end="(276, 38)">
                <IdentNode start="(276, 37)" end="(276, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(276, 39)" end="(276, 42)">
                <AtomNode start="(276, 39)" end="(276, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(276, 41)" end="(276, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(276, 42)" end="(276, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(276, 44)" end="(276, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(276, 44)" end="(276, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(276, 45)" end="(276, 47)">
                <IdentNode start="(276, 45)" end="(276, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(276, 48)" end="(276, 57)">
                <AtomNode start="(276, 48)" end="(276, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(276, 50)" end="(276, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(276, 50)" end="(276, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(276, 56)" end="(276, 57)">
                    <IdentNode start="(276, 56)" end="(276, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(276, 57)" end="(276, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(276, 59)" end="(279, 63)">
            <AtomNode start="(276, 59)" end="(276, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(277, 5)" end="(279, 63)" kind="«term_↔_»">
              <OtherNode start="(277, 5)" end="(277, 20)" kind="«term_=_»">
                <OtherNode start="(277, 5)" end="(277, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(277, 5)" end="(277, 13)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(277, 14)" end="(277, 15)">
                    <IdentNode start="(277, 14)" end="(277, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(277, 16)" end="(277, 17)" leading="" trailing=" " val="="/>
                <IdentNode start="(277, 18)" end="(277, 20)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </OtherNode>
              <AtomNode start="(277, 21)" end="(277, 22)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(278, 7)" end="(279, 63)" kind="«term_∨_»">
                <OtherNode start="(278, 7)" end="(278, 25)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(278, 7)" end="(278, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(278, 8)" end="(278, 24)" kind="«term_∧_»">
                    <OtherNode start="(278, 8)" end="(278, 14)" kind="«term_∉_»">
                      <IdentNode start="(278, 8)" end="(278, 9)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(278, 10)" end="(278, 11)" leading="" trailing=" " val="∉"/>
                      <IdentNode start="(278, 12)" end="(278, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(278, 15)" end="(278, 16)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(278, 17)" end="(278, 24)" kind="«term_=_»">
                      <IdentNode start="(278, 17)" end="(278, 19)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(278, 20)" end="(278, 21)" leading="" trailing=" " val="="/>
                      <IdentNode start="(278, 22)" end="(278, 24)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(278, 24)" end="(278, 25)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(278, 26)" end="(278, 27)" leading="" trailing="&#10;        " val="∨"/>
                <OtherNode start="(279, 9)" end="(279, 63)" kind="«term∃_,_»">
                  <AtomNode start="(279, 9)" end="(279, 10)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(279, 11)" end="(279, 16)" kind="Lean.explicitBinders">
                    <OtherNode start="(279, 11)" end="(279, 16)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(279, 11)" end="(279, 16)">
                        <LeanBinderidentNode start="(279, 11)" end="(279, 13)">
                          <IdentNode start="(279, 11)" end="(279, 13)" leading="" trailing=" " raw_val="as" val="as"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(279, 14)" end="(279, 16)">
                          <IdentNode start="(279, 14)" end="(279, 16)" leading="" trailing="" raw_val="bs" val="bs"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(279, 16)" end="(279, 17)" leading="" trailing=" " val=","/>
                  <OtherNode start="(279, 18)" end="(279, 63)" kind="«term_∧_»">
                    <OtherNode start="(279, 18)" end="(279, 24)" kind="«term_∉_»">
                      <IdentNode start="(279, 18)" end="(279, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(279, 20)" end="(279, 21)" leading="" trailing=" " val="∉"/>
                      <IdentNode start="(279, 22)" end="(279, 24)" leading="" trailing=" " raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(279, 25)" end="(279, 26)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(279, 27)" end="(279, 63)" kind="«term_∧_»">
                      <OtherNode start="(279, 27)" end="(279, 47)" kind="«term_=_»">
                        <IdentNode start="(279, 27)" end="(279, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <AtomNode start="(279, 30)" end="(279, 31)" leading="" trailing=" " val="="/>
                        <OtherNode start="(279, 32)" end="(279, 47)" kind="«term_++_»">
                          <OtherNode start="(279, 32)" end="(279, 41)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(279, 32)" end="(279, 39)" leading="" trailing=" " raw_val="as.push" val="as.push"/>
                            <NullNode start="(279, 40)" end="(279, 41)">
                              <IdentNode start="(279, 40)" end="(279, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(279, 42)" end="(279, 44)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(279, 45)" end="(279, 47)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(279, 48)" end="(279, 49)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(279, 50)" end="(279, 63)" kind="«term_=_»">
                        <IdentNode start="(279, 50)" end="(279, 52)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        <AtomNode start="(279, 53)" end="(279, 54)" leading="" trailing=" " val="="/>
                        <OtherNode start="(279, 55)" end="(279, 63)" kind="«term_++_»">
                          <IdentNode start="(279, 55)" end="(279, 57)" leading="" trailing=" " raw_val="as" val="as"/>
                          <AtomNode start="(279, 58)" end="(279, 60)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(279, 61)" end="(279, 63)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(279, 64)" end="(288, 49)">
          <AtomNode start="(279, 64)" end="(279, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(279, 67)" end="(288, 49)">
            <AtomNode start="(279, 67)" end="(279, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(280, 3)" end="(288, 49)">
              <TacticTacticseq1IndentedNode start="(280, 3)" end="(288, 49)">
                <NullNode start="(280, 3)" end="(288, 49)">
                  <OtherNode start="(280, 3)" end="(280, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ xs.erase a = ys ↔ ¬a ∈ xs ∧ xs = ys ∨ ∃ as bs, ¬a ∈ as ∧ xs = as.push a ++ bs ∧ ys = as ++ bs" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ ((∀ (a_1 : α), a_1 ∈ xs → ¬(a_1 == a) = true) ∧ xs = ys ∨&#10;      ∃ a_1 as bs,&#10;        (∀ (b : α), b ∈ as → ¬(b == a) = true) ∧ (a_1 == a) = true ∧ xs = as.push a_1 ++ bs ∧ ys = as ++ bs) ↔&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ as bs, ¬a ∈ as ∧ xs = as.push a ++ bs ∧ ys = as ++ bs" tactic="rw [erase_eq_eraseP', eraseP_eq_iff]">
                    <AtomNode start="(280, 3)" end="(280, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(280, 6)" end="(280, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(280, 6)" end="(280, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(280, 7)" end="(280, 38)">
                        <OtherNode start="(280, 7)" end="(280, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(280, 7)" end="(280, 23)" leading="" trailing="" raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'" full_name="Array.erase_eq_eraseP'" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(182, 9)" def_end="(182, 25)"/>
                        </OtherNode>
                        <AtomNode start="(280, 23)" end="(280, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(280, 25)" end="(280, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(280, 25)" end="(280, 38)" leading="" trailing="" raw_val="eraseP_eq_iff" val="eraseP_eq_iff" full_name="Array.eraseP_eq_iff" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(152, 9)" def_end="(152, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(280, 38)" end="(280, 39)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(281, 3)" end="(281, 58)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ ((∀ (a_1 : α), a_1 ∈ xs → ¬(a_1 == a) = true) ∧ xs = ys ∨&#10;      ∃ a_1 as bs,&#10;        (∀ (b : α), b ∈ as → ¬(b == a) = true) ∧ (a_1 == a) = true ∧ xs = as.push a_1 ++ bs ∧ ys = as ++ bs) ↔&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ as bs, ¬a ∈ as ∧ xs = as.push a ++ bs ∧ ys = as ++ bs" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ ys = as ++ x) ↔&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x" tactic="simp only [beq_iff_eq, forall_mem_ne', exists_and_left]">
                    <AtomNode start="(281, 3)" end="(281, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(281, 8)" end="(281, 12)">
                      <AtomNode start="(281, 8)" end="(281, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(281, 13)" end="(281, 58)">
                      <AtomNode start="(281, 13)" end="(281, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(281, 14)" end="(281, 57)">
                        <OtherNode start="(281, 14)" end="(281, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(281, 14)" end="(281, 24)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(281, 24)" end="(281, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(281, 26)" end="(281, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(281, 26)" end="(281, 40)" leading="" trailing="" raw_val="forall_mem_ne'" val="forall_mem_ne'" full_name="Array.forall_mem_ne'" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(281, 40)" end="(281, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(281, 42)" end="(281, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(281, 42)" end="(281, 57)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(281, 57)" end="(281, 58)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(282, 3)" end="(282, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ ys = as ++ x) ↔&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x" state_after="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ a_2 as, ¬a ∈ as ∧ a_2 = a ∧ ∃ x, xs = as.push a_2 ++ x ∧ ys = as ++ x" tactic="constructor">
                    <AtomNode start="(282, 3)" end="(282, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(283, 3)" end="(285, 41)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ a_2 as, ¬a ∈ as ∧ a_2 = a ∧ ∃ x, xs = as.push a_2 ++ x ∧ ys = as ++ x" state_after="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ a_2 as, ¬a ∈ as ∧ a_2 = a ∧ ∃ x, xs = as.push a_2 ++ x ∧ ys = as ++ x" tactic="· rintro (⟨h, rfl⟩ | ⟨a', as, h, rfl, bs, rfl, rfl⟩)&#10;  · left; simp_all&#10;  · right; refine ⟨as, h, bs, by simp⟩">
                    <OtherNode start="(283, 3)" end="(283, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(283, 3)" end="(283, 4)" kind="patternIgnore">
                        <OtherNode start="(283, 3)" end="(283, 4)" kind="token.«· »">
                          <AtomNode start="(283, 3)" end="(283, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(283, 5)" end="(285, 41)">
                      <TacticTacticseq1IndentedNode start="(283, 5)" end="(285, 41)">
                        <NullNode start="(283, 5)" end="(285, 41)">
                          <OtherNode start="(283, 5)" end="(283, 55)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x" state_after="case mp.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ xs = as ++ x&#10;&#10;case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ ¬a' ∈ as.push a' ++ bs ∧ as.push a' ++ bs = as ++ bs ∨&#10;    ∃ as_1, ¬a' ∈ as_1 ∧ ∃ x, as.push a' ++ bs = as_1.push a' ++ x ∧ as ++ bs = as_1 ++ x" tactic="rintro (⟨h, rfl⟩ | ⟨a', as, h, rfl, bs, rfl, rfl⟩)">
                            <AtomNode start="(283, 5)" end="(283, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(283, 12)" end="(283, 55)">
                              <OtherNode start="(283, 12)" end="(283, 55)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(283, 12)" end="(283, 55)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(283, 12)" end="(283, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(283, 13)" end="(283, 54)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(283, 13)" end="(283, 54)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(283, 13)" end="(283, 54)">
                                        <OtherNode start="(283, 13)" end="(283, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(283, 13)" end="(283, 14)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(283, 14)" end="(283, 20)">
                                            <OtherNode start="(283, 14)" end="(283, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 14)" end="(283, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 14)" end="(283, 15)">
                                                  <OtherNode start="(283, 14)" end="(283, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 14)" end="(283, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(283, 15)" end="(283, 16)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(283, 17)" end="(283, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 17)" end="(283, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 17)" end="(283, 20)">
                                                  <OtherNode start="(283, 17)" end="(283, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 17)" end="(283, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(283, 20)" end="(283, 21)" leading="" trailing=" " val="⟩"/>
                                        </OtherNode>
                                        <AtomNode start="(283, 22)" end="(283, 23)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(283, 24)" end="(283, 54)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(283, 24)" end="(283, 25)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(283, 25)" end="(283, 53)">
                                            <OtherNode start="(283, 25)" end="(283, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 25)" end="(283, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 25)" end="(283, 27)">
                                                  <OtherNode start="(283, 25)" end="(283, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 25)" end="(283, 27)" leading="" trailing="" raw_val="a'" val="a'"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(283, 27)" end="(283, 28)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(283, 29)" end="(283, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 29)" end="(283, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 29)" end="(283, 31)">
                                                  <OtherNode start="(283, 29)" end="(283, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 29)" end="(283, 31)" leading="" trailing="" raw_val="as" val="as"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(283, 31)" end="(283, 32)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(283, 33)" end="(283, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 33)" end="(283, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 33)" end="(283, 34)">
                                                  <OtherNode start="(283, 33)" end="(283, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 33)" end="(283, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(283, 34)" end="(283, 35)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(283, 36)" end="(283, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 36)" end="(283, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 36)" end="(283, 39)">
                                                  <OtherNode start="(283, 36)" end="(283, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 36)" end="(283, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(283, 39)" end="(283, 40)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(283, 41)" end="(283, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 41)" end="(283, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 41)" end="(283, 43)">
                                                  <OtherNode start="(283, 41)" end="(283, 43)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 41)" end="(283, 43)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(283, 43)" end="(283, 44)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(283, 45)" end="(283, 48)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 45)" end="(283, 48)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 45)" end="(283, 48)">
                                                  <OtherNode start="(283, 45)" end="(283, 48)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 45)" end="(283, 48)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(283, 48)" end="(283, 49)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(283, 50)" end="(283, 53)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(283, 50)" end="(283, 53)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(283, 50)" end="(283, 53)">
                                                  <OtherNode start="(283, 50)" end="(283, 53)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(283, 50)" end="(283, 53)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(283, 53)" end="(283, 54)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(283, 54)" end="(283, 55)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(284, 5)" end="(284, 21)" kind="Lean.cdot" state_before="case mp.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ xs = as ++ x&#10;&#10;case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ ¬a' ∈ as.push a' ++ bs ∧ as.push a' ++ bs = as ++ bs ∨&#10;    ∃ as_1, ¬a' ∈ as_1 ∧ ∃ x, as.push a' ++ bs = as_1.push a' ++ x ∧ as ++ bs = as_1 ++ x" state_after="case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ ¬a' ∈ as.push a' ++ bs ∧ as.push a' ++ bs = as ++ bs ∨&#10;    ∃ as_1, ¬a' ∈ as_1 ∧ ∃ x, as.push a' ++ bs = as_1.push a' ++ x ∧ as ++ bs = as_1 ++ x" tactic="· left; simp_all">
                            <OtherNode start="(284, 5)" end="(284, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(284, 5)" end="(284, 6)" kind="patternIgnore">
                                <OtherNode start="(284, 5)" end="(284, 6)" kind="token.«· »">
                                  <AtomNode start="(284, 5)" end="(284, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(284, 7)" end="(284, 21)">
                              <TacticTacticseq1IndentedNode start="(284, 7)" end="(284, 21)">
                                <NullNode start="(284, 7)" end="(284, 21)">
                                  <OtherNode start="(284, 7)" end="(284, 11)" kind="Lean.Parser.Tactic.left" state_before="case mp.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ xs = as ++ x" state_after="case mp.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs" tactic="left">
                                    <AtomNode start="(284, 7)" end="(284, 11)" leading="" trailing="" val="left"/>
                                  </OtherNode>
                                  <AtomNode start="(284, 11)" end="(284, 12)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(284, 13)" end="(284, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(284, 13)" end="(284, 21)" leading="" trailing="&#10;    " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(285, 5)" end="(285, 41)" kind="Lean.cdot" state_before="case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ ¬a' ∈ as.push a' ++ bs ∧ as.push a' ++ bs = as ++ bs ∨&#10;    ∃ as_1, ¬a' ∈ as_1 ∧ ∃ x, as.push a' ++ bs = as_1.push a' ++ x ∧ as ++ bs = as_1 ++ x" state_after="no goals" tactic="· right; refine ⟨as, h, bs, by simp⟩">
                            <OtherNode start="(285, 5)" end="(285, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(285, 5)" end="(285, 6)" kind="patternIgnore">
                                <OtherNode start="(285, 5)" end="(285, 6)" kind="token.«· »">
                                  <AtomNode start="(285, 5)" end="(285, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(285, 7)" end="(285, 41)">
                              <TacticTacticseq1IndentedNode start="(285, 7)" end="(285, 41)">
                                <NullNode start="(285, 7)" end="(285, 41)">
                                  <OtherNode start="(285, 7)" end="(285, 12)" kind="Lean.Parser.Tactic.right" state_before="case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ ¬a' ∈ as.push a' ++ bs ∧ as.push a' ++ bs = as ++ bs ∨&#10;    ∃ as_1, ¬a' ∈ as_1 ∧ ∃ x, as.push a' ++ bs = as_1.push a' ++ x ∧ as ++ bs = as_1 ++ x" state_after="case mp.inr.intro.intro.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ ∃ as_1, ¬a' ∈ as_1 ∧ ∃ x, as.push a' ++ bs = as_1.push a' ++ x ∧ as ++ bs = as_1 ++ x" tactic="right">
                                    <AtomNode start="(285, 7)" end="(285, 12)" leading="" trailing="" val="right"/>
                                  </OtherNode>
                                  <AtomNode start="(285, 12)" end="(285, 13)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(285, 14)" end="(285, 41)" kind="Lean.Parser.Tactic.refine" state_before="case mp.inr.intro.intro.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ ∃ as_1, ¬a' ∈ as_1 ∧ ∃ x, as.push a' ++ bs = as_1.push a' ++ x ∧ as ++ bs = as_1 ++ x" state_after="no goals" tactic="refine ⟨as, h, bs, by simp⟩">
                                    <AtomNode start="(285, 14)" end="(285, 20)" leading="" trailing=" " val="refine"/>
                                    <OtherNode start="(285, 21)" end="(285, 41)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(285, 21)" end="(285, 22)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(285, 22)" end="(285, 40)">
                                        <IdentNode start="(285, 22)" end="(285, 24)" leading="" trailing="" raw_val="as" val="as"/>
                                        <AtomNode start="(285, 24)" end="(285, 25)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(285, 26)" end="(285, 27)" leading="" trailing="" raw_val="h" val="h"/>
                                        <AtomNode start="(285, 27)" end="(285, 28)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(285, 29)" end="(285, 31)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        <AtomNode start="(285, 31)" end="(285, 32)" leading="" trailing=" " val=","/>
                                        <TermBytacticNode start="(285, 33)" end="(285, 40)">
                                          <AtomNode start="(285, 33)" end="(285, 35)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(285, 36)" end="(285, 40)">
                                            <TacticTacticseq1IndentedNode start="(285, 36)" end="(285, 40)">
                                              <NullNode start="(285, 36)" end="(285, 40)">
                                                <OtherNode start="(285, 36)" end="(285, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;as : Array α&#10;h : ¬a' ∈ as&#10;bs : Array α&#10;⊢ as.push a' ++ bs = as.push a' ++ bs ∧ as ++ bs = as ++ bs" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(285, 36)" end="(285, 40)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </NullNode>
                                      <AtomNode start="(285, 40)" end="(285, 41)" leading="" trailing="&#10;  " val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(286, 3)" end="(288, 49)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ a_2 as, ¬a ∈ as ∧ a_2 = a ∧ ∃ x, xs = as.push a_2 ++ x ∧ ys = as ++ x" state_after="no goals" tactic="· rintro (⟨h, rfl⟩ | ⟨as, h, bs, rfl, rfl⟩)&#10;  · left; simp_all&#10;  · right; refine ⟨a, as, h, rfl, bs, by simp⟩">
                    <OtherNode start="(286, 3)" end="(286, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(286, 3)" end="(286, 4)" kind="patternIgnore">
                        <OtherNode start="(286, 3)" end="(286, 4)" kind="token.«· »">
                          <AtomNode start="(286, 3)" end="(286, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(286, 5)" end="(288, 49)">
                      <TacticTacticseq1IndentedNode start="(286, 5)" end="(288, 49)">
                        <NullNode start="(286, 5)" end="(288, 49)">
                          <OtherNode start="(286, 5)" end="(286, 46)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;ys : Array α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;⊢ (¬a ∈ xs ∧ xs = ys ∨ ∃ as, ¬a ∈ as ∧ ∃ x, xs = as.push a ++ x ∧ ys = as ++ x) →&#10;    ¬a ∈ xs ∧ xs = ys ∨ ∃ a_2 as, ¬a ∈ as ∧ a_2 = a ∧ ∃ x, xs = as.push a_2 ++ x ∧ ys = as ++ x" state_after="case mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ xs = as ++ x&#10;&#10;case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ ¬a ∈ as.push a ++ bs ∧ as.push a ++ bs = as ++ bs ∨&#10;    ∃ a_1 as_1, ¬a ∈ as_1 ∧ a_1 = a ∧ ∃ x, as.push a ++ bs = as_1.push a_1 ++ x ∧ as ++ bs = as_1 ++ x" tactic="rintro (⟨h, rfl⟩ | ⟨as, h, bs, rfl, rfl⟩)">
                            <AtomNode start="(286, 5)" end="(286, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(286, 12)" end="(286, 46)">
                              <OtherNode start="(286, 12)" end="(286, 46)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(286, 12)" end="(286, 46)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(286, 12)" end="(286, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(286, 13)" end="(286, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(286, 13)" end="(286, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(286, 13)" end="(286, 45)">
                                        <OtherNode start="(286, 13)" end="(286, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(286, 13)" end="(286, 14)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(286, 14)" end="(286, 20)">
                                            <OtherNode start="(286, 14)" end="(286, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(286, 14)" end="(286, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(286, 14)" end="(286, 15)">
                                                  <OtherNode start="(286, 14)" end="(286, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(286, 14)" end="(286, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(286, 15)" end="(286, 16)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(286, 17)" end="(286, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(286, 17)" end="(286, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(286, 17)" end="(286, 20)">
                                                  <OtherNode start="(286, 17)" end="(286, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(286, 17)" end="(286, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(286, 20)" end="(286, 21)" leading="" trailing=" " val="⟩"/>
                                        </OtherNode>
                                        <AtomNode start="(286, 22)" end="(286, 23)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(286, 24)" end="(286, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(286, 24)" end="(286, 25)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(286, 25)" end="(286, 44)">
                                            <OtherNode start="(286, 25)" end="(286, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(286, 25)" end="(286, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(286, 25)" end="(286, 27)">
                                                  <OtherNode start="(286, 25)" end="(286, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(286, 25)" end="(286, 27)" leading="" trailing="" raw_val="as" val="as"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(286, 27)" end="(286, 28)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(286, 29)" end="(286, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(286, 29)" end="(286, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(286, 29)" end="(286, 30)">
                                                  <OtherNode start="(286, 29)" end="(286, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(286, 29)" end="(286, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(286, 30)" end="(286, 31)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(286, 32)" end="(286, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(286, 32)" end="(286, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(286, 32)" end="(286, 34)">
                                                  <OtherNode start="(286, 32)" end="(286, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(286, 32)" end="(286, 34)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(286, 34)" end="(286, 35)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(286, 36)" end="(286, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(286, 36)" end="(286, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(286, 36)" end="(286, 39)">
                                                  <OtherNode start="(286, 36)" end="(286, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(286, 36)" end="(286, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(286, 39)" end="(286, 40)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(286, 41)" end="(286, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(286, 41)" end="(286, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(286, 41)" end="(286, 44)">
                                                  <OtherNode start="(286, 41)" end="(286, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(286, 41)" end="(286, 44)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(286, 44)" end="(286, 45)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(286, 45)" end="(286, 46)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(287, 5)" end="(287, 21)" kind="Lean.cdot" state_before="case mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ xs = as ++ x&#10;&#10;case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ ¬a ∈ as.push a ++ bs ∧ as.push a ++ bs = as ++ bs ∨&#10;    ∃ a_1 as_1, ¬a ∈ as_1 ∧ a_1 = a ∧ ∃ x, as.push a ++ bs = as_1.push a_1 ++ x ∧ as ++ bs = as_1 ++ x" state_after="case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ ¬a ∈ as.push a ++ bs ∧ as.push a ++ bs = as ++ bs ∨&#10;    ∃ a_1 as_1, ¬a ∈ as_1 ∧ a_1 = a ∧ ∃ x, as.push a ++ bs = as_1.push a_1 ++ x ∧ as ++ bs = as_1 ++ x" tactic="· left; simp_all">
                            <OtherNode start="(287, 5)" end="(287, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(287, 5)" end="(287, 6)" kind="patternIgnore">
                                <OtherNode start="(287, 5)" end="(287, 6)" kind="token.«· »">
                                  <AtomNode start="(287, 5)" end="(287, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(287, 7)" end="(287, 21)">
                              <TacticTacticseq1IndentedNode start="(287, 7)" end="(287, 21)">
                                <NullNode start="(287, 7)" end="(287, 21)">
                                  <OtherNode start="(287, 7)" end="(287, 11)" kind="Lean.Parser.Tactic.left" state_before="case mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs ∨ ∃ a_1 as, ¬a ∈ as ∧ a_1 = a ∧ ∃ x, xs = as.push a_1 ++ x ∧ xs = as ++ x" state_after="case mpr.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs" tactic="left">
                                    <AtomNode start="(287, 7)" end="(287, 11)" leading="" trailing="" val="left"/>
                                  </OtherNode>
                                  <AtomNode start="(287, 11)" end="(287, 12)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(287, 13)" end="(287, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case mpr.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;xs : Array α&#10;h : ¬a ∈ xs&#10;⊢ ¬a ∈ xs ∧ xs = xs" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(287, 13)" end="(287, 21)" leading="" trailing="&#10;    " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(288, 5)" end="(288, 49)" kind="Lean.cdot" state_before="case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ ¬a ∈ as.push a ++ bs ∧ as.push a ++ bs = as ++ bs ∨&#10;    ∃ a_1 as_1, ¬a ∈ as_1 ∧ a_1 = a ∧ ∃ x, as.push a ++ bs = as_1.push a_1 ++ x ∧ as ++ bs = as_1 ++ x" state_after="no goals" tactic="· right; refine ⟨a, as, h, rfl, bs, by simp⟩">
                            <OtherNode start="(288, 5)" end="(288, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(288, 5)" end="(288, 6)" kind="patternIgnore">
                                <OtherNode start="(288, 5)" end="(288, 6)" kind="token.«· »">
                                  <AtomNode start="(288, 5)" end="(288, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(288, 7)" end="(288, 49)">
                              <TacticTacticseq1IndentedNode start="(288, 7)" end="(288, 49)">
                                <NullNode start="(288, 7)" end="(288, 49)">
                                  <OtherNode start="(288, 7)" end="(288, 12)" kind="Lean.Parser.Tactic.right" state_before="case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ ¬a ∈ as.push a ++ bs ∧ as.push a ++ bs = as ++ bs ∨&#10;    ∃ a_1 as_1, ¬a ∈ as_1 ∧ a_1 = a ∧ ∃ x, as.push a ++ bs = as_1.push a_1 ++ x ∧ as ++ bs = as_1 ++ x" state_after="case mpr.inr.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ ∃ a_1 as_1, ¬a ∈ as_1 ∧ a_1 = a ∧ ∃ x, as.push a ++ bs = as_1.push a_1 ++ x ∧ as ++ bs = as_1 ++ x" tactic="right">
                                    <AtomNode start="(288, 7)" end="(288, 12)" leading="" trailing="" val="right"/>
                                  </OtherNode>
                                  <AtomNode start="(288, 12)" end="(288, 13)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(288, 14)" end="(288, 49)" kind="Lean.Parser.Tactic.refine" state_before="case mpr.inr.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ ∃ a_1 as_1, ¬a ∈ as_1 ∧ a_1 = a ∧ ∃ x, as.push a ++ bs = as_1.push a_1 ++ x ∧ as ++ bs = as_1 ++ x" state_after="no goals" tactic="refine ⟨a, as, h, rfl, bs, by simp⟩">
                                    <AtomNode start="(288, 14)" end="(288, 20)" leading="" trailing=" " val="refine"/>
                                    <OtherNode start="(288, 21)" end="(288, 49)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(288, 21)" end="(288, 22)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(288, 22)" end="(288, 48)">
                                        <IdentNode start="(288, 22)" end="(288, 23)" leading="" trailing="" raw_val="a" val="a"/>
                                        <AtomNode start="(288, 23)" end="(288, 24)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(288, 25)" end="(288, 27)" leading="" trailing="" raw_val="as" val="as"/>
                                        <AtomNode start="(288, 27)" end="(288, 28)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(288, 29)" end="(288, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                        <AtomNode start="(288, 30)" end="(288, 31)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(288, 32)" end="(288, 35)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <AtomNode start="(288, 35)" end="(288, 36)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(288, 37)" end="(288, 39)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        <AtomNode start="(288, 39)" end="(288, 40)" leading="" trailing=" " val=","/>
                                        <TermBytacticNode start="(288, 41)" end="(288, 48)">
                                          <AtomNode start="(288, 41)" end="(288, 43)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(288, 44)" end="(288, 48)">
                                            <TacticTacticseq1IndentedNode start="(288, 44)" end="(288, 48)">
                                              <NullNode start="(288, 44)" end="(288, 48)">
                                                <OtherNode start="(288, 44)" end="(288, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as : Array α&#10;h : ¬a ∈ as&#10;bs : Array α&#10;⊢ as.push a ++ bs = as.push a ++ bs ∧ as ++ bs = as ++ bs" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(288, 44)" end="(288, 48)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </NullNode>
                                      <AtomNode start="(288, 48)" end="(288, 49)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(290, 1)" end="(293, 30)" name="erase_replicate_self" full_name="Array.erase_replicate_self">
      <CommandDeclmodifiersNode start="(290, 1)" end="(290, 8)">
        <NullNode/>
        <NullNode start="(290, 1)" end="(290, 8)">
          <OtherNode start="(290, 1)" end="(290, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(290, 1)" end="(290, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(290, 3)" end="(290, 7)">
              <OtherNode start="(290, 3)" end="(290, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(290, 3)" end="(290, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(290, 3)" end="(290, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(290, 7)" end="(290, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(290, 9)" end="(293, 30)" name="erase_replicate_self" full_name="Array.erase_replicate_self" _is_private_decl="False">
        <AtomNode start="(290, 9)" end="(290, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(290, 17)" end="(290, 37)">
          <IdentNode start="(290, 17)" end="(290, 37)" leading="" trailing=" " raw_val="erase_replicate_self" val="erase_replicate_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(290, 38)" end="(291, 50)">
          <NullNode start="(290, 38)" end="(290, 59)">
            <OtherNode start="(290, 38)" end="(290, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(290, 38)" end="(290, 39)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(290, 39)" end="(290, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(290, 39)" end="(290, 48)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(290, 49)" end="(290, 50)">
                  <IdentNode start="(290, 49)" end="(290, 50)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(290, 50)" end="(290, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(290, 52)" end="(290, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(290, 52)" end="(290, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(290, 53)" end="(290, 54)">
                <IdentNode start="(290, 53)" end="(290, 54)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(290, 55)" end="(290, 58)">
                <AtomNode start="(290, 55)" end="(290, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(290, 57)" end="(290, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(290, 58)" end="(290, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(290, 60)" end="(291, 50)">
            <AtomNode start="(290, 60)" end="(290, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(291, 5)" end="(291, 50)" kind="«term_=_»">
              <OtherNode start="(291, 5)" end="(291, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(291, 5)" end="(291, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(291, 5)" end="(291, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(291, 5)" end="(291, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(291, 6)" end="(291, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(291, 6)" end="(291, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(291, 16)" end="(291, 19)">
                        <IdentNode start="(291, 16)" end="(291, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(291, 18)" end="(291, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(291, 19)" end="(291, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(291, 20)" end="(291, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(291, 21)" end="(291, 26)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(291, 27)" end="(291, 28)">
                  <IdentNode start="(291, 27)" end="(291, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(291, 29)" end="(291, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(291, 31)" end="(291, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(291, 31)" end="(291, 40)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(291, 41)" end="(291, 50)">
                  <OtherNode start="(291, 41)" end="(291, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(291, 41)" end="(291, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(291, 42)" end="(291, 47)" kind="«term_-_»">
                      <IdentNode start="(291, 42)" end="(291, 43)" leading="" trailing=" " raw_val="n" val="n"/>
                      <AtomNode start="(291, 44)" end="(291, 45)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(291, 46)" end="(291, 47)" kind="num">
                        <AtomNode start="(291, 46)" end="(291, 47)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(291, 47)" end="(291, 48)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(291, 49)" end="(291, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(291, 51)" end="(293, 30)">
          <AtomNode start="(291, 51)" end="(291, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(291, 54)" end="(293, 30)">
            <AtomNode start="(291, 54)" end="(291, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(292, 3)" end="(293, 30)">
              <TacticTacticseq1IndentedNode start="(292, 3)" end="(293, 30)">
                <NullNode start="(292, 3)" end="(293, 30)">
                  <OtherNode start="(292, 3)" end="(292, 59)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ (replicate n a).erase a = replicate (n - 1) a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ ((List.replicate n a).erase a).toArray = (List.replicate (n - 1) a).toArray" tactic="simp only [← List.toArray_replicate, List.erase_toArray]">
                    <AtomNode start="(292, 3)" end="(292, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(292, 8)" end="(292, 12)">
                      <AtomNode start="(292, 8)" end="(292, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(292, 13)" end="(292, 59)">
                      <AtomNode start="(292, 13)" end="(292, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(292, 14)" end="(292, 58)">
                        <OtherNode start="(292, 14)" end="(292, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(292, 14)" end="(292, 15)">
                            <OtherNode start="(292, 14)" end="(292, 15)" kind="patternIgnore">
                              <OtherNode start="(292, 14)" end="(292, 15)" kind="token.«← »">
                                <AtomNode start="(292, 14)" end="(292, 15)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(292, 16)" end="(292, 38)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(292, 38)" end="(292, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(292, 40)" end="(292, 58)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(292, 40)" end="(292, 58)" leading="" trailing="" raw_val="List.erase_toArray" val="List.erase_toArray" full_name="List.erase_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(292, 58)" end="(292, 59)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(293, 3)" end="(293, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ ((List.replicate n a).erase a).toArray = (List.replicate (n - 1) a).toArray" state_after="no goals" tactic="simp [List.erase_replicate]">
                    <AtomNode start="(293, 3)" end="(293, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(293, 8)" end="(293, 30)">
                      <AtomNode start="(293, 8)" end="(293, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(293, 9)" end="(293, 29)">
                        <OtherNode start="(293, 9)" end="(293, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(293, 9)" end="(293, 29)" leading="" trailing="" raw_val="List.erase_replicate" val="List.erase_replicate" full_name="List.erase_replicate" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(293, 29)" end="(293, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(295, 1)" end="(296, 51)" name="erase_mkArray_self" full_name="Array.erase_mkArray_self">
      <CommandDeclmodifiersNode start="(295, 1)" end="(295, 59)">
        <NullNode/>
        <NullNode start="(295, 1)" end="(295, 59)">
          <OtherNode start="(295, 1)" end="(295, 59)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(295, 1)" end="(295, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(295, 3)" end="(295, 58)">
              <OtherNode start="(295, 3)" end="(295, 58)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(295, 3)" end="(295, 58)" kind="Lean.deprecated">
                  <AtomNode start="(295, 3)" end="(295, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(295, 14)" end="(295, 34)">
                    <IdentNode start="(295, 14)" end="(295, 34)" leading="" trailing=" " raw_val="erase_replicate_self" val="erase_replicate_self" full_name="Array.erase_replicate_self" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(290, 17)" def_end="(290, 37)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(295, 35)" end="(295, 58)">
                    <AtomNode start="(295, 35)" end="(295, 36)" leading="" trailing="" val="("/>
                    <AtomNode start="(295, 36)" end="(295, 41)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(295, 42)" end="(295, 44)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(295, 45)" end="(295, 57)" kind="str">
                      <AtomNode start="(295, 45)" end="(295, 57)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(295, 57)" end="(295, 58)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(295, 58)" end="(295, 59)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(296, 1)" end="(296, 51)" name="erase_mkArray_self">
        <AtomNode start="(296, 1)" end="(296, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(296, 8)" end="(296, 26)">
          <IdentNode start="(296, 8)" end="(296, 26)" leading="" trailing=" " raw_val="erase_mkArray_self" val="erase_mkArray_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(296, 27)" end="(296, 51)">
          <AtomNode start="(296, 27)" end="(296, 29)" leading="" trailing=" " val=":="/>
          <OtherNode start="(296, 30)" end="(296, 51)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(296, 30)" end="(296, 31)" leading="" trailing="" val="@"/>
            <IdentNode start="(296, 31)" end="(296, 51)" leading="" trailing="&#10;&#10;" raw_val="erase_replicate_self" val="erase_replicate_self" full_name="Array.erase_replicate_self" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(290, 17)" def_end="(290, 37)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(298, 1)" end="(301, 11)" name="erase_replicate_ne" full_name="Array.erase_replicate_ne">
      <CommandDeclmodifiersNode start="(298, 1)" end="(298, 8)">
        <NullNode/>
        <NullNode start="(298, 1)" end="(298, 8)">
          <OtherNode start="(298, 1)" end="(298, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(298, 1)" end="(298, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(298, 3)" end="(298, 7)">
              <OtherNode start="(298, 3)" end="(298, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(298, 3)" end="(298, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(298, 3)" end="(298, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(298, 7)" end="(298, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(298, 9)" end="(301, 11)" name="erase_replicate_ne" full_name="Array.erase_replicate_ne" _is_private_decl="False">
        <AtomNode start="(298, 9)" end="(298, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(298, 17)" end="(298, 35)">
          <IdentNode start="(298, 17)" end="(298, 35)" leading="" trailing=" " raw_val="erase_replicate_ne" val="erase_replicate_ne"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(298, 36)" end="(299, 44)">
          <NullNode start="(298, 36)" end="(298, 73)">
            <OtherNode start="(298, 36)" end="(298, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(298, 36)" end="(298, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(298, 37)" end="(298, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(298, 37)" end="(298, 46)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(298, 47)" end="(298, 48)">
                  <IdentNode start="(298, 47)" end="(298, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(298, 48)" end="(298, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(298, 50)" end="(298, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(298, 50)" end="(298, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(298, 51)" end="(298, 54)">
                <IdentNode start="(298, 51)" end="(298, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(298, 53)" end="(298, 54)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(298, 55)" end="(298, 58)">
                <AtomNode start="(298, 55)" end="(298, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(298, 57)" end="(298, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(298, 58)" end="(298, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(298, 60)" end="(298, 73)">
              <AtomNode start="(298, 60)" end="(298, 61)" leading="" trailing="" val="("/>
              <NullNode start="(298, 61)" end="(298, 62)">
                <IdentNode start="(298, 61)" end="(298, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(298, 63)" end="(298, 72)">
                <AtomNode start="(298, 63)" end="(298, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(298, 65)" end="(298, 72)" kind="term!_">
                  <AtomNode start="(298, 65)" end="(298, 66)" leading="" trailing="" val="!"/>
                  <OtherNode start="(298, 66)" end="(298, 72)" kind="«term_==_»">
                    <IdentNode start="(298, 66)" end="(298, 67)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(298, 68)" end="(298, 70)" leading="" trailing=" " val="=="/>
                    <IdentNode start="(298, 71)" end="(298, 72)" leading="" trailing="" raw_val="a" val="a"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(298, 72)" end="(298, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(298, 74)" end="(299, 44)">
            <AtomNode start="(298, 74)" end="(298, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(299, 5)" end="(299, 44)" kind="«term_=_»">
              <OtherNode start="(299, 5)" end="(299, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(299, 5)" end="(299, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(299, 5)" end="(299, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(299, 5)" end="(299, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(299, 6)" end="(299, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(299, 6)" end="(299, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(299, 16)" end="(299, 19)">
                        <IdentNode start="(299, 16)" end="(299, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(299, 18)" end="(299, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(299, 19)" end="(299, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(299, 20)" end="(299, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(299, 21)" end="(299, 26)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(299, 27)" end="(299, 28)">
                  <IdentNode start="(299, 27)" end="(299, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(299, 29)" end="(299, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(299, 31)" end="(299, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(299, 31)" end="(299, 40)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(299, 41)" end="(299, 44)">
                  <IdentNode start="(299, 41)" end="(299, 42)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(299, 43)" end="(299, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(299, 45)" end="(301, 11)">
          <AtomNode start="(299, 45)" end="(299, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(299, 48)" end="(301, 11)">
            <AtomNode start="(299, 48)" end="(299, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(300, 3)" end="(301, 11)">
              <TacticTacticseq1IndentedNode start="(300, 3)" end="(301, 11)">
                <NullNode start="(300, 3)" end="(301, 11)">
                  <OtherNode start="(300, 3)" end="(300, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;h : (!b == a) = true&#10;⊢ (replicate n a).erase b = replicate n a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;h : (!b == a) = true&#10;⊢ ¬b ∈ replicate n a" tactic="rw [erase_of_not_mem]">
                    <AtomNode start="(300, 3)" end="(300, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(300, 6)" end="(300, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(300, 6)" end="(300, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(300, 7)" end="(300, 23)">
                        <OtherNode start="(300, 7)" end="(300, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(300, 7)" end="(300, 23)" leading="" trailing="" raw_val="erase_of_not_mem" val="erase_of_not_mem" full_name="Array.erase_of_not_mem" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(177, 9)" def_end="(177, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(300, 23)" end="(300, 24)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(301, 3)" end="(301, 11)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;h : (!b == a) = true&#10;⊢ ¬b ∈ replicate n a" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(301, 3)" end="(301, 11)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(303, 1)" end="(304, 47)" name="erase_mkArray_ne" full_name="Array.erase_mkArray_ne">
      <CommandDeclmodifiersNode start="(303, 1)" end="(303, 57)">
        <NullNode/>
        <NullNode start="(303, 1)" end="(303, 57)">
          <OtherNode start="(303, 1)" end="(303, 57)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(303, 1)" end="(303, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(303, 3)" end="(303, 56)">
              <OtherNode start="(303, 3)" end="(303, 56)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(303, 3)" end="(303, 56)" kind="Lean.deprecated">
                  <AtomNode start="(303, 3)" end="(303, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(303, 14)" end="(303, 32)">
                    <IdentNode start="(303, 14)" end="(303, 32)" leading="" trailing=" " raw_val="erase_replicate_ne" val="erase_replicate_ne" full_name="Array.erase_replicate_ne" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(298, 17)" def_end="(298, 35)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(303, 33)" end="(303, 56)">
                    <AtomNode start="(303, 33)" end="(303, 34)" leading="" trailing="" val="("/>
                    <AtomNode start="(303, 34)" end="(303, 39)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(303, 40)" end="(303, 42)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(303, 43)" end="(303, 55)" kind="str">
                      <AtomNode start="(303, 43)" end="(303, 55)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(303, 55)" end="(303, 56)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(303, 56)" end="(303, 57)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(304, 1)" end="(304, 47)" name="erase_mkArray_ne">
        <AtomNode start="(304, 1)" end="(304, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(304, 8)" end="(304, 24)">
          <IdentNode start="(304, 8)" end="(304, 24)" leading="" trailing=" " raw_val="erase_mkArray_ne" val="erase_mkArray_ne"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(304, 25)" end="(304, 47)">
          <AtomNode start="(304, 25)" end="(304, 27)" leading="" trailing=" " val=":="/>
          <OtherNode start="(304, 28)" end="(304, 47)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(304, 28)" end="(304, 29)" leading="" trailing="" val="@"/>
            <IdentNode start="(304, 29)" end="(304, 47)" leading="" trailing="&#10;&#10;" raw_val="erase_replicate_ne" val="erase_replicate_ne" full_name="Array.erase_replicate_ne" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(298, 17)" def_end="(298, 35)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(306, 1)" end="(306, 10)" name="erase">
      <AtomNode start="(306, 1)" end="(306, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(306, 5)" end="(306, 10)">
        <IdentNode start="(306, 5)" end="(306, 10)" leading="" trailing="&#10;&#10;" raw_val="erase" val="erase"/>
      </NullNode>
    </CommandEndNode>
    <CommandModuledocNode start="(308, 1)" end="(308, 20)" comment="### eraseIdx -/">
      <AtomNode start="(308, 1)" end="(308, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(308, 5)" end="(308, 20)" leading="" trailing="&#10;&#10;" val="### eraseIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(310, 1)" end="(312, 31)" name="eraseIdx_eq_eraseIdxIfInBounds" full_name="Array.eraseIdx_eq_eraseIdxIfInBounds">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(310, 1)" end="(312, 31)" name="eraseIdx_eq_eraseIdxIfInBounds" full_name="Array.eraseIdx_eq_eraseIdxIfInBounds" _is_private_decl="False">
        <AtomNode start="(310, 1)" end="(310, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(310, 9)" end="(310, 39)">
          <IdentNode start="(310, 9)" end="(310, 39)" leading="" trailing=" " raw_val="eraseIdx_eq_eraseIdxIfInBounds" val="eraseIdx_eq_eraseIdxIfInBounds"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(310, 40)" end="(311, 46)">
          <NullNode start="(310, 40)" end="(310, 82)">
            <OtherNode start="(310, 40)" end="(310, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(310, 40)" end="(310, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(310, 41)" end="(310, 43)">
                <IdentNode start="(310, 41)" end="(310, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(310, 44)" end="(310, 53)">
                <AtomNode start="(310, 44)" end="(310, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 46)" end="(310, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(310, 46)" end="(310, 51)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(310, 52)" end="(310, 53)">
                    <IdentNode start="(310, 52)" end="(310, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(310, 53)" end="(310, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(310, 55)" end="(310, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(310, 55)" end="(310, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(310, 56)" end="(310, 57)">
                <IdentNode start="(310, 56)" end="(310, 57)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(310, 58)" end="(310, 63)">
                <AtomNode start="(310, 58)" end="(310, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(310, 60)" end="(310, 63)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(310, 63)" end="(310, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(310, 65)" end="(310, 82)">
              <AtomNode start="(310, 65)" end="(310, 66)" leading="" trailing="" val="("/>
              <NullNode start="(310, 66)" end="(310, 67)">
                <IdentNode start="(310, 66)" end="(310, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(310, 68)" end="(310, 81)">
                <AtomNode start="(310, 68)" end="(310, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 70)" end="(310, 81)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(310, 70)" end="(310, 71)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(310, 72)" end="(310, 73)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(310, 74)" end="(310, 81)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(310, 81)" end="(310, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(310, 83)" end="(311, 46)">
            <AtomNode start="(310, 83)" end="(310, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(311, 5)" end="(311, 46)" kind="«term_=_»">
              <OtherNode start="(311, 5)" end="(311, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(311, 5)" end="(311, 16)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                <NullNode start="(311, 17)" end="(311, 20)">
                  <IdentNode start="(311, 17)" end="(311, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(311, 19)" end="(311, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(311, 21)" end="(311, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(311, 23)" end="(311, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(311, 23)" end="(311, 44)" leading="" trailing=" " raw_val="xs.eraseIdxIfInBounds" val="xs.eraseIdxIfInBounds"/>
                <NullNode start="(311, 45)" end="(311, 46)">
                  <IdentNode start="(311, 45)" end="(311, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(311, 47)" end="(312, 31)">
          <AtomNode start="(311, 47)" end="(311, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(311, 50)" end="(312, 31)">
            <AtomNode start="(311, 50)" end="(311, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(312, 3)" end="(312, 31)">
              <TacticTacticseq1IndentedNode start="(312, 3)" end="(312, 31)">
                <NullNode start="(312, 3)" end="(312, 31)">
                  <OtherNode start="(312, 3)" end="(312, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;⊢ xs.eraseIdx i h = xs.eraseIdxIfInBounds i" state_after="no goals" tactic="simp [eraseIdxIfInBounds, h]">
                    <AtomNode start="(312, 3)" end="(312, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(312, 8)" end="(312, 31)">
                      <AtomNode start="(312, 8)" end="(312, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(312, 9)" end="(312, 30)">
                        <OtherNode start="(312, 9)" end="(312, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(312, 9)" end="(312, 27)" leading="" trailing="" raw_val="eraseIdxIfInBounds" val="eraseIdxIfInBounds" full_name="Array.eraseIdxIfInBounds" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(312, 27)" end="(312, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(312, 29)" end="(312, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(312, 29)" end="(312, 30)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(312, 30)" end="(312, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(314, 1)" end="(322, 7)" name="eraseIdx_eq_take_drop_succ" full_name="Array.eraseIdx_eq_take_drop_succ">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(314, 1)" end="(322, 7)" name="eraseIdx_eq_take_drop_succ" full_name="Array.eraseIdx_eq_take_drop_succ" _is_private_decl="False">
        <AtomNode start="(314, 1)" end="(314, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(314, 9)" end="(314, 35)">
          <IdentNode start="(314, 9)" end="(314, 35)" leading="" trailing=" " raw_val="eraseIdx_eq_take_drop_succ" val="eraseIdx_eq_take_drop_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(314, 36)" end="(315, 51)">
          <NullNode start="(314, 36)" end="(314, 64)">
            <OtherNode start="(314, 36)" end="(314, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(314, 36)" end="(314, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(314, 37)" end="(314, 39)">
                <IdentNode start="(314, 37)" end="(314, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(314, 40)" end="(314, 49)">
                <AtomNode start="(314, 40)" end="(314, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(314, 42)" end="(314, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(314, 42)" end="(314, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(314, 48)" end="(314, 49)">
                    <IdentNode start="(314, 48)" end="(314, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(314, 49)" end="(314, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(314, 51)" end="(314, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(314, 51)" end="(314, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(314, 52)" end="(314, 53)">
                <IdentNode start="(314, 52)" end="(314, 53)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(314, 54)" end="(314, 59)">
                <AtomNode start="(314, 54)" end="(314, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(314, 56)" end="(314, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(314, 59)" end="(314, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(314, 61)" end="(314, 64)">
              <AtomNode start="(314, 61)" end="(314, 62)" leading="" trailing="" val="("/>
              <NullNode start="(314, 62)" end="(314, 63)">
                <IdentNode start="(314, 62)" end="(314, 63)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(314, 63)" end="(314, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(314, 65)" end="(315, 51)">
            <AtomNode start="(314, 65)" end="(314, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(315, 5)" end="(315, 51)" kind="«term_=_»">
              <OtherNode start="(315, 5)" end="(315, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(315, 5)" end="(315, 16)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                <NullNode start="(315, 17)" end="(315, 20)">
                  <IdentNode start="(315, 17)" end="(315, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(315, 19)" end="(315, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(315, 21)" end="(315, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(315, 23)" end="(315, 51)" kind="«term_++_»">
                <OtherNode start="(315, 23)" end="(315, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(315, 23)" end="(315, 30)" leading="" trailing=" " raw_val="xs.take" val="xs.take"/>
                  <NullNode start="(315, 31)" end="(315, 32)">
                    <IdentNode start="(315, 31)" end="(315, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(315, 33)" end="(315, 35)" leading="" trailing=" " val="++"/>
                <OtherNode start="(315, 36)" end="(315, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(315, 36)" end="(315, 43)" leading="" trailing=" " raw_val="xs.drop" val="xs.drop"/>
                  <NullNode start="(315, 44)" end="(315, 51)">
                    <OtherNode start="(315, 44)" end="(315, 51)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(315, 44)" end="(315, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(315, 45)" end="(315, 50)" kind="«term_+_»">
                        <IdentNode start="(315, 45)" end="(315, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(315, 47)" end="(315, 48)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(315, 49)" end="(315, 50)" kind="num">
                          <AtomNode start="(315, 49)" end="(315, 50)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(315, 50)" end="(315, 51)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(315, 52)" end="(322, 7)">
          <AtomNode start="(315, 52)" end="(315, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(315, 55)" end="(322, 7)">
            <AtomNode start="(315, 55)" end="(315, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(316, 3)" end="(322, 7)">
              <TacticTacticseq1IndentedNode start="(316, 3)" end="(322, 7)">
                <NullNode start="(316, 3)" end="(322, 7)">
                  <OtherNode start="(316, 3)" end="(316, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;⊢ xs.eraseIdx i h = xs.take i ++ xs.drop (i + 1)" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ { toList := xs }.eraseIdx i h = { toList := xs }.take i ++ { toList := xs }.drop (i + 1)" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(316, 3)" end="(316, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(316, 10)" end="(316, 12)">
                      <OtherNode start="(316, 10)" end="(316, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(316, 10)" end="(316, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(316, 13)" end="(316, 22)">
                      <AtomNode start="(316, 13)" end="(316, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(316, 18)" end="(316, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(316, 18)" end="(316, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(316, 18)" end="(316, 22)">
                            <OtherNode start="(316, 18)" end="(316, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(316, 18)" end="(316, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(316, 19)" end="(316, 21)">
                                <OtherNode start="(316, 19)" end="(316, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(316, 19)" end="(316, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(316, 19)" end="(316, 21)">
                                      <OtherNode start="(316, 19)" end="(316, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(316, 19)" end="(316, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(316, 21)" end="(316, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(317, 3)" end="(317, 37)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ { toList := xs }.eraseIdx i h = { toList := xs }.take i ++ { toList := xs }.drop (i + 1)" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : i &amp;lt; xs.length&#10;⊢ { toList := xs }.eraseIdx i h✝ = { toList := xs }.take i ++ { toList := xs }.drop (i + 1)" tactic="simp only [List.size_toArray] at h">
                    <AtomNode start="(317, 3)" end="(317, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(317, 8)" end="(317, 12)">
                      <AtomNode start="(317, 8)" end="(317, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(317, 13)" end="(317, 32)">
                      <AtomNode start="(317, 13)" end="(317, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(317, 14)" end="(317, 31)">
                        <OtherNode start="(317, 14)" end="(317, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(317, 14)" end="(317, 31)" leading="" trailing="" raw_val="List.size_toArray" val="List.size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(317, 31)" end="(317, 32)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(317, 33)" end="(317, 37)">
                      <OtherNode start="(317, 33)" end="(317, 37)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(317, 33)" end="(317, 35)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(317, 36)" end="(317, 37)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(317, 36)" end="(317, 37)">
                            <IdentNode start="(317, 36)" end="(317, 37)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(318, 3)" end="(320, 82)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : i &amp;lt; xs.length&#10;⊢ { toList := xs }.eraseIdx i h✝ = { toList := xs }.take i ++ { toList := xs }.drop (i + 1)" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : i &amp;lt; xs.length&#10;⊢ List.drop (i + 1) xs = List.take (xs.length - (i + 1)) (List.drop (i + 1) xs)" tactic="simp only [List.eraseIdx_toArray, List.eraseIdx_eq_take_drop_succ, take_eq_extract,&#10;  List.extract_toArray, List.extract_eq_drop_take, Nat.sub_zero, List.drop_zero, drop_eq_extract,&#10;  List.size_toArray, List.append_toArray, mk.injEq, List.append_cancel_left_eq]">
                    <AtomNode start="(318, 3)" end="(318, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(318, 8)" end="(318, 12)">
                      <AtomNode start="(318, 8)" end="(318, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(318, 13)" end="(320, 82)">
                      <AtomNode start="(318, 13)" end="(318, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(318, 14)" end="(320, 81)">
                        <OtherNode start="(318, 14)" end="(318, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(318, 14)" end="(318, 35)" leading="" trailing="" raw_val="List.eraseIdx_toArray" val="List.eraseIdx_toArray" full_name="List.eraseIdx_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(318, 35)" end="(318, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(318, 37)" end="(318, 68)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(318, 37)" end="(318, 68)" leading="" trailing="" raw_val="List.eraseIdx_eq_take_drop_succ" val="List.eraseIdx_eq_take_drop_succ" full_name="List.eraseIdx_eq_take_drop_succ" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(318, 68)" end="(318, 69)" leading="" trailing=" " val=","/>
                        <OtherNode start="(318, 70)" end="(318, 85)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(318, 70)" end="(318, 85)" leading="" trailing="" raw_val="take_eq_extract" val="take_eq_extract" full_name="Array.take_eq_extract" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(318, 85)" end="(318, 86)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(319, 5)" end="(319, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 5)" end="(319, 25)" leading="" trailing="" raw_val="List.extract_toArray" val="List.extract_toArray" full_name="List.extract_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 25)" end="(319, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(319, 27)" end="(319, 52)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 27)" end="(319, 52)" leading="" trailing="" raw_val="List.extract_eq_drop_take" val="List.extract_eq_drop_take" full_name="List.extract_eq_drop_take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 52)" end="(319, 53)" leading="" trailing=" " val=","/>
                        <OtherNode start="(319, 54)" end="(319, 66)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 54)" end="(319, 66)" leading="" trailing="" raw_val="Nat.sub_zero" val="Nat.sub_zero" full_name="Nat.sub_zero" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 66)" end="(319, 67)" leading="" trailing=" " val=","/>
                        <OtherNode start="(319, 68)" end="(319, 82)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 68)" end="(319, 82)" leading="" trailing="" raw_val="List.drop_zero" val="List.drop_zero" full_name="List.drop_zero" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 82)" end="(319, 83)" leading="" trailing=" " val=","/>
                        <OtherNode start="(319, 84)" end="(319, 99)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(319, 84)" end="(319, 99)" leading="" trailing="" raw_val="drop_eq_extract" val="drop_eq_extract" full_name="Array.drop_eq_extract" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(319, 99)" end="(319, 100)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(320, 5)" end="(320, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(320, 5)" end="(320, 22)" leading="" trailing="" raw_val="List.size_toArray" val="List.size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(320, 22)" end="(320, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(320, 24)" end="(320, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(320, 24)" end="(320, 43)" leading="" trailing="" raw_val="List.append_toArray" val="List.append_toArray" full_name="List.append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(320, 43)" end="(320, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(320, 45)" end="(320, 53)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(320, 45)" end="(320, 53)" leading="" trailing="" raw_val="mk.injEq" val="mk.injEq" full_name="Array.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(320, 53)" end="(320, 54)" leading="" trailing=" " val=","/>
                        <OtherNode start="(320, 55)" end="(320, 81)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(320, 55)" end="(320, 81)" leading="" trailing="" raw_val="List.append_cancel_left_eq" val="List.append_cancel_left_eq" full_name="List.append_cancel_left_eq" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(320, 81)" end="(320, 82)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(321, 3)" end="(321, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : i &amp;lt; xs.length&#10;⊢ List.drop (i + 1) xs = List.take (xs.length - (i + 1)) (List.drop (i + 1) xs)" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : i &amp;lt; xs.length&#10;⊢ (List.drop (i + 1) xs).length ≤ xs.length - (i + 1)" tactic="rw [List.take_of_length_le]">
                    <AtomNode start="(321, 3)" end="(321, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(321, 6)" end="(321, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(321, 6)" end="(321, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(321, 7)" end="(321, 29)">
                        <OtherNode start="(321, 7)" end="(321, 29)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(321, 7)" end="(321, 29)" leading="" trailing="" raw_val="List.take_of_length_le" val="List.take_of_length_le" full_name="List.take_of_length_le" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(321, 29)" end="(321, 30)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(322, 3)" end="(322, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : i &amp;lt; xs.length&#10;⊢ (List.drop (i + 1) xs).length ≤ xs.length - (i + 1)" state_after="no goals" tactic="simp">
                    <AtomNode start="(322, 3)" end="(322, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(324, 1)" end="(327, 32)" name="getElem?_eraseIdx" full_name="Array.getElem?_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(324, 1)" end="(327, 32)" name="getElem?_eraseIdx" full_name="Array.getElem?_eraseIdx" _is_private_decl="False">
        <AtomNode start="(324, 1)" end="(324, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(324, 9)" end="(324, 26)">
          <IdentNode start="(324, 9)" end="(324, 26)" leading="" trailing=" " raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(324, 27)" end="(325, 63)">
          <NullNode start="(324, 27)" end="(324, 79)">
            <OtherNode start="(324, 27)" end="(324, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(324, 27)" end="(324, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(324, 28)" end="(324, 30)">
                <IdentNode start="(324, 28)" end="(324, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(324, 31)" end="(324, 40)">
                <AtomNode start="(324, 31)" end="(324, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(324, 33)" end="(324, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(324, 33)" end="(324, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(324, 39)" end="(324, 40)">
                    <IdentNode start="(324, 39)" end="(324, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(324, 40)" end="(324, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(324, 42)" end="(324, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(324, 42)" end="(324, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(324, 43)" end="(324, 44)">
                <IdentNode start="(324, 43)" end="(324, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(324, 45)" end="(324, 50)">
                <AtomNode start="(324, 45)" end="(324, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(324, 47)" end="(324, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(324, 50)" end="(324, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(324, 52)" end="(324, 69)">
              <AtomNode start="(324, 52)" end="(324, 53)" leading="" trailing="" val="("/>
              <NullNode start="(324, 53)" end="(324, 54)">
                <IdentNode start="(324, 53)" end="(324, 54)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(324, 55)" end="(324, 68)">
                <AtomNode start="(324, 55)" end="(324, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(324, 57)" end="(324, 68)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(324, 57)" end="(324, 58)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(324, 59)" end="(324, 60)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(324, 61)" end="(324, 68)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(324, 68)" end="(324, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(324, 70)" end="(324, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(324, 70)" end="(324, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(324, 71)" end="(324, 72)">
                <IdentNode start="(324, 71)" end="(324, 72)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(324, 73)" end="(324, 78)">
                <AtomNode start="(324, 73)" end="(324, 74)" leading="" trailing=" " val=":"/>
                <IdentNode start="(324, 75)" end="(324, 78)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(324, 78)" end="(324, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(324, 80)" end="(325, 63)">
            <AtomNode start="(324, 80)" end="(324, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(325, 5)" end="(325, 63)" kind="«term_=_»">
              <OtherNode start="(325, 5)" end="(325, 24)" kind="«term__[_]_?»">
                <OtherNode start="(325, 5)" end="(325, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(325, 5)" end="(325, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(325, 6)" end="(325, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(325, 6)" end="(325, 17)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                    <NullNode start="(325, 18)" end="(325, 19)">
                      <IdentNode start="(325, 18)" end="(325, 19)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(325, 19)" end="(325, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(325, 20)" end="(325, 21)" leading="" trailing="" val="["/>
                <IdentNode start="(325, 21)" end="(325, 22)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(325, 22)" end="(325, 23)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(325, 23)" end="(325, 24)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(325, 25)" end="(325, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(325, 27)" end="(325, 63)" kind="termIfThenElse">
                <AtomNode start="(325, 27)" end="(325, 29)" leading="" trailing=" " val="if"/>
                <OtherNode start="(325, 30)" end="(325, 35)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(325, 30)" end="(325, 31)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(325, 32)" end="(325, 33)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(325, 34)" end="(325, 35)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(325, 36)" end="(325, 40)" leading="" trailing=" " val="then"/>
                <OtherNode start="(325, 41)" end="(325, 47)" kind="«term__[_]_?»">
                  <IdentNode start="(325, 41)" end="(325, 43)" leading="" trailing="" raw_val="xs" val="xs"/>
                  <GroupNode/>
                  <AtomNode start="(325, 43)" end="(325, 44)" leading="" trailing="" val="["/>
                  <IdentNode start="(325, 44)" end="(325, 45)" leading="" trailing="" raw_val="j" val="j"/>
                  <AtomNode start="(325, 45)" end="(325, 46)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(325, 46)" end="(325, 47)" leading="" trailing=" " val="?"/>
                </OtherNode>
                <AtomNode start="(325, 48)" end="(325, 52)" leading="" trailing=" " val="else"/>
                <OtherNode start="(325, 53)" end="(325, 63)" kind="«term__[_]_?»">
                  <IdentNode start="(325, 53)" end="(325, 55)" leading="" trailing="" raw_val="xs" val="xs"/>
                  <GroupNode/>
                  <AtomNode start="(325, 55)" end="(325, 56)" leading="" trailing="" val="["/>
                  <OtherNode start="(325, 56)" end="(325, 61)" kind="«term_+_»">
                    <IdentNode start="(325, 56)" end="(325, 57)" leading="" trailing=" " raw_val="j" val="j"/>
                    <AtomNode start="(325, 58)" end="(325, 59)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(325, 60)" end="(325, 61)" kind="num">
                      <AtomNode start="(325, 60)" end="(325, 61)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(325, 61)" end="(325, 62)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(325, 62)" end="(325, 63)" leading="" trailing=" " val="?"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(325, 64)" end="(327, 32)">
          <AtomNode start="(325, 64)" end="(325, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(325, 67)" end="(327, 32)">
            <AtomNode start="(325, 67)" end="(325, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(326, 3)" end="(327, 32)">
              <TacticTacticseq1IndentedNode start="(326, 3)" end="(327, 32)">
                <NullNode start="(326, 3)" end="(327, 32)">
                  <OtherNode start="(326, 3)" end="(326, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;⊢ (xs.eraseIdx i h)[j]? = if j &amp;lt; i then xs[j]? else xs[j + 1]?" state_after="case mk&#10;α : Type u_1&#10;i j : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.eraseIdx i h)[j]? = if j &amp;lt; i then { toList := xs }[j]? else { toList := xs }[j + 1]?" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(326, 3)" end="(326, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(326, 10)" end="(326, 12)">
                      <OtherNode start="(326, 10)" end="(326, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(326, 10)" end="(326, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(326, 13)" end="(326, 22)">
                      <AtomNode start="(326, 13)" end="(326, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(326, 18)" end="(326, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(326, 18)" end="(326, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(326, 18)" end="(326, 22)">
                            <OtherNode start="(326, 18)" end="(326, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(326, 18)" end="(326, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(326, 19)" end="(326, 21)">
                                <OtherNode start="(326, 19)" end="(326, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(326, 19)" end="(326, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(326, 19)" end="(326, 21)">
                                      <OtherNode start="(326, 19)" end="(326, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(326, 19)" end="(326, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(326, 21)" end="(326, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(327, 3)" end="(327, 32)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i j : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.eraseIdx i h)[j]? = if j &amp;lt; i then { toList := xs }[j]? else { toList := xs }[j + 1]?" state_after="no goals" tactic="simp [List.getElem?_eraseIdx]">
                    <AtomNode start="(327, 3)" end="(327, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(327, 8)" end="(327, 32)">
                      <AtomNode start="(327, 8)" end="(327, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(327, 9)" end="(327, 31)">
                        <OtherNode start="(327, 9)" end="(327, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(327, 9)" end="(327, 31)" leading="" trailing="" raw_val="List.getElem?_eraseIdx" val="List.getElem?_eraseIdx" full_name="List.getElem?_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(327, 31)" end="(327, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(329, 1)" end="(332, 12)" name="getElem?_eraseIdx_of_lt" full_name="Array.getElem?_eraseIdx_of_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(329, 1)" end="(332, 12)" name="getElem?_eraseIdx_of_lt" full_name="Array.getElem?_eraseIdx_of_lt" _is_private_decl="False">
        <AtomNode start="(329, 1)" end="(329, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(329, 9)" end="(329, 32)">
          <IdentNode start="(329, 9)" end="(329, 32)" leading="" trailing=" " raw_val="getElem?_eraseIdx_of_lt" val="getElem?_eraseIdx_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(329, 33)" end="(330, 33)">
          <NullNode start="(329, 33)" end="(329, 98)">
            <OtherNode start="(329, 33)" end="(329, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(329, 33)" end="(329, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(329, 34)" end="(329, 36)">
                <IdentNode start="(329, 34)" end="(329, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(329, 37)" end="(329, 46)">
                <AtomNode start="(329, 37)" end="(329, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(329, 39)" end="(329, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(329, 39)" end="(329, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(329, 45)" end="(329, 46)">
                    <IdentNode start="(329, 45)" end="(329, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(329, 46)" end="(329, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(329, 48)" end="(329, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(329, 48)" end="(329, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(329, 49)" end="(329, 50)">
                <IdentNode start="(329, 49)" end="(329, 50)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(329, 51)" end="(329, 56)">
                <AtomNode start="(329, 51)" end="(329, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(329, 53)" end="(329, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(329, 56)" end="(329, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(329, 58)" end="(329, 75)">
              <AtomNode start="(329, 58)" end="(329, 59)" leading="" trailing="" val="("/>
              <NullNode start="(329, 59)" end="(329, 60)">
                <IdentNode start="(329, 59)" end="(329, 60)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(329, 61)" end="(329, 74)">
                <AtomNode start="(329, 61)" end="(329, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(329, 63)" end="(329, 74)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(329, 63)" end="(329, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(329, 65)" end="(329, 66)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(329, 67)" end="(329, 74)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(329, 74)" end="(329, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(329, 76)" end="(329, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(329, 76)" end="(329, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(329, 77)" end="(329, 78)">
                <IdentNode start="(329, 77)" end="(329, 78)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(329, 79)" end="(329, 84)">
                <AtomNode start="(329, 79)" end="(329, 80)" leading="" trailing=" " val=":"/>
                <IdentNode start="(329, 81)" end="(329, 84)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(329, 84)" end="(329, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(329, 86)" end="(329, 98)">
              <AtomNode start="(329, 86)" end="(329, 87)" leading="" trailing="" val="("/>
              <NullNode start="(329, 87)" end="(329, 89)">
                <IdentNode start="(329, 87)" end="(329, 89)" leading="" trailing=" " raw_val="h'" val="h'"/>
              </NullNode>
              <NullNode start="(329, 90)" end="(329, 97)">
                <AtomNode start="(329, 90)" end="(329, 91)" leading="" trailing=" " val=":"/>
                <OtherNode start="(329, 92)" end="(329, 97)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(329, 92)" end="(329, 93)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(329, 94)" end="(329, 95)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(329, 96)" end="(329, 97)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(329, 97)" end="(329, 98)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(329, 99)" end="(330, 33)">
            <AtomNode start="(329, 99)" end="(329, 100)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(330, 5)" end="(330, 33)" kind="«term_=_»">
              <OtherNode start="(330, 5)" end="(330, 24)" kind="«term__[_]_?»">
                <OtherNode start="(330, 5)" end="(330, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(330, 5)" end="(330, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(330, 6)" end="(330, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(330, 6)" end="(330, 17)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                    <NullNode start="(330, 18)" end="(330, 19)">
                      <IdentNode start="(330, 18)" end="(330, 19)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(330, 19)" end="(330, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(330, 20)" end="(330, 21)" leading="" trailing="" val="["/>
                <IdentNode start="(330, 21)" end="(330, 22)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(330, 22)" end="(330, 23)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(330, 23)" end="(330, 24)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(330, 25)" end="(330, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(330, 27)" end="(330, 33)" kind="«term__[_]_?»">
                <IdentNode start="(330, 27)" end="(330, 29)" leading="" trailing="" raw_val="xs" val="xs"/>
                <GroupNode/>
                <AtomNode start="(330, 29)" end="(330, 30)" leading="" trailing="" val="["/>
                <IdentNode start="(330, 30)" end="(330, 31)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(330, 31)" end="(330, 32)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(330, 32)" end="(330, 33)" leading="" trailing=" " val="?"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(330, 34)" end="(332, 12)">
          <AtomNode start="(330, 34)" end="(330, 36)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(330, 37)" end="(332, 12)">
            <AtomNode start="(330, 37)" end="(330, 39)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(331, 3)" end="(332, 12)">
              <TacticTacticseq1IndentedNode start="(331, 3)" end="(332, 12)">
                <NullNode start="(331, 3)" end="(332, 12)">
                  <OtherNode start="(331, 3)" end="(331, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; i&#10;⊢ (xs.eraseIdx i h)[j]? = xs[j]?" state_after="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; i&#10;⊢ (if j &amp;lt; i then xs[j]? else xs[j + 1]?) = xs[j]?" tactic="rw [getElem?_eraseIdx]">
                    <AtomNode start="(331, 3)" end="(331, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(331, 6)" end="(331, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(331, 6)" end="(331, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(331, 7)" end="(331, 24)">
                        <OtherNode start="(331, 7)" end="(331, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(331, 7)" end="(331, 24)" leading="" trailing="" raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx" full_name="Array.getElem?_eraseIdx" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(324, 9)" def_end="(324, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(331, 24)" end="(331, 25)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(332, 3)" end="(332, 12)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; i&#10;⊢ (if j &amp;lt; i then xs[j]? else xs[j + 1]?) = xs[j]?" state_after="no goals" tactic="simp [h']">
                    <AtomNode start="(332, 3)" end="(332, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(332, 8)" end="(332, 12)">
                      <AtomNode start="(332, 8)" end="(332, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(332, 9)" end="(332, 11)">
                        <OtherNode start="(332, 9)" end="(332, 11)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(332, 9)" end="(332, 11)" leading="" trailing="" raw_val="h'" val="h'"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(332, 11)" end="(332, 12)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(334, 1)" end="(339, 8)" name="getElem?_eraseIdx_of_ge" full_name="Array.getElem?_eraseIdx_of_ge">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(334, 1)" end="(339, 8)" name="getElem?_eraseIdx_of_ge" full_name="Array.getElem?_eraseIdx_of_ge" _is_private_decl="False">
        <AtomNode start="(334, 1)" end="(334, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(334, 9)" end="(334, 32)">
          <IdentNode start="(334, 9)" end="(334, 32)" leading="" trailing=" " raw_val="getElem?_eraseIdx_of_ge" val="getElem?_eraseIdx_of_ge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(334, 33)" end="(335, 37)">
          <NullNode start="(334, 33)" end="(334, 98)">
            <OtherNode start="(334, 33)" end="(334, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(334, 33)" end="(334, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(334, 34)" end="(334, 36)">
                <IdentNode start="(334, 34)" end="(334, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(334, 37)" end="(334, 46)">
                <AtomNode start="(334, 37)" end="(334, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(334, 39)" end="(334, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(334, 39)" end="(334, 44)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(334, 45)" end="(334, 46)">
                    <IdentNode start="(334, 45)" end="(334, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(334, 46)" end="(334, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(334, 48)" end="(334, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(334, 48)" end="(334, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(334, 49)" end="(334, 50)">
                <IdentNode start="(334, 49)" end="(334, 50)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(334, 51)" end="(334, 56)">
                <AtomNode start="(334, 51)" end="(334, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(334, 53)" end="(334, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(334, 56)" end="(334, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(334, 58)" end="(334, 75)">
              <AtomNode start="(334, 58)" end="(334, 59)" leading="" trailing="" val="("/>
              <NullNode start="(334, 59)" end="(334, 60)">
                <IdentNode start="(334, 59)" end="(334, 60)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(334, 61)" end="(334, 74)">
                <AtomNode start="(334, 61)" end="(334, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(334, 63)" end="(334, 74)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(334, 63)" end="(334, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(334, 65)" end="(334, 66)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(334, 67)" end="(334, 74)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(334, 74)" end="(334, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(334, 76)" end="(334, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(334, 76)" end="(334, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(334, 77)" end="(334, 78)">
                <IdentNode start="(334, 77)" end="(334, 78)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(334, 79)" end="(334, 84)">
                <AtomNode start="(334, 79)" end="(334, 80)" leading="" trailing=" " val=":"/>
                <IdentNode start="(334, 81)" end="(334, 84)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(334, 84)" end="(334, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(334, 86)" end="(334, 98)">
              <AtomNode start="(334, 86)" end="(334, 87)" leading="" trailing="" val="("/>
              <NullNode start="(334, 87)" end="(334, 89)">
                <IdentNode start="(334, 87)" end="(334, 89)" leading="" trailing=" " raw_val="h'" val="h'"/>
              </NullNode>
              <NullNode start="(334, 90)" end="(334, 97)">
                <AtomNode start="(334, 90)" end="(334, 91)" leading="" trailing=" " val=":"/>
                <OtherNode start="(334, 92)" end="(334, 97)" kind="«term_≤_»">
                  <IdentNode start="(334, 92)" end="(334, 93)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(334, 94)" end="(334, 95)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(334, 96)" end="(334, 97)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(334, 97)" end="(334, 98)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(334, 99)" end="(335, 37)">
            <AtomNode start="(334, 99)" end="(334, 100)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(335, 5)" end="(335, 37)" kind="«term_=_»">
              <OtherNode start="(335, 5)" end="(335, 24)" kind="«term__[_]_?»">
                <OtherNode start="(335, 5)" end="(335, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(335, 5)" end="(335, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(335, 6)" end="(335, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(335, 6)" end="(335, 17)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                    <NullNode start="(335, 18)" end="(335, 19)">
                      <IdentNode start="(335, 18)" end="(335, 19)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(335, 19)" end="(335, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(335, 20)" end="(335, 21)" leading="" trailing="" val="["/>
                <IdentNode start="(335, 21)" end="(335, 22)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(335, 22)" end="(335, 23)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(335, 23)" end="(335, 24)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(335, 25)" end="(335, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(335, 27)" end="(335, 37)" kind="«term__[_]_?»">
                <IdentNode start="(335, 27)" end="(335, 29)" leading="" trailing="" raw_val="xs" val="xs"/>
                <GroupNode/>
                <AtomNode start="(335, 29)" end="(335, 30)" leading="" trailing="" val="["/>
                <OtherNode start="(335, 30)" end="(335, 35)" kind="«term_+_»">
                  <IdentNode start="(335, 30)" end="(335, 31)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(335, 32)" end="(335, 33)" leading="" trailing=" " val="+"/>
                  <OtherNode start="(335, 34)" end="(335, 35)" kind="num">
                    <AtomNode start="(335, 34)" end="(335, 35)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(335, 35)" end="(335, 36)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(335, 36)" end="(335, 37)" leading="" trailing=" " val="?"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(335, 38)" end="(339, 8)">
          <AtomNode start="(335, 38)" end="(335, 40)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(335, 41)" end="(339, 8)">
            <AtomNode start="(335, 41)" end="(335, 43)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(336, 3)" end="(339, 8)">
              <TacticTacticseq1IndentedNode start="(336, 3)" end="(339, 8)">
                <NullNode start="(336, 3)" end="(339, 8)">
                  <OtherNode start="(336, 3)" end="(336, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : i ≤ j&#10;⊢ (xs.eraseIdx i h)[j]? = xs[j + 1]?" state_after="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : i ≤ j&#10;⊢ (if j &amp;lt; i then xs[j]? else xs[j + 1]?) = xs[j + 1]?" tactic="rw [getElem?_eraseIdx]">
                    <AtomNode start="(336, 3)" end="(336, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(336, 6)" end="(336, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(336, 6)" end="(336, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(336, 7)" end="(336, 24)">
                        <OtherNode start="(336, 7)" end="(336, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(336, 7)" end="(336, 24)" leading="" trailing="" raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx" full_name="Array.getElem?_eraseIdx" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(324, 9)" def_end="(324, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(336, 24)" end="(336, 25)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(337, 3)" end="(337, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : i ≤ j&#10;⊢ (if j &amp;lt; i then xs[j]? else xs[j + 1]?) = xs[j + 1]?" state_after="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : i ≤ j&#10;⊢ j &amp;lt; i → xs[j]? = xs[j + 1]?" tactic="simp only [dite_eq_ite, ite_eq_right_iff]">
                    <AtomNode start="(337, 3)" end="(337, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(337, 8)" end="(337, 12)">
                      <AtomNode start="(337, 8)" end="(337, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(337, 13)" end="(337, 44)">
                      <AtomNode start="(337, 13)" end="(337, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(337, 14)" end="(337, 43)">
                        <OtherNode start="(337, 14)" end="(337, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(337, 14)" end="(337, 25)" leading="" trailing="" raw_val="dite_eq_ite" val="dite_eq_ite" full_name="dite_eq_ite" mod_name="Init.ByCases" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/ByCases.lean"/>
                        </OtherNode>
                        <AtomNode start="(337, 25)" end="(337, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(337, 27)" end="(337, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(337, 27)" end="(337, 43)" leading="" trailing="" raw_val="ite_eq_right_iff" val="ite_eq_right_iff" full_name="ite_eq_right_iff" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(337, 43)" end="(337, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(338, 3)" end="(338, 11)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : i ≤ j&#10;⊢ j &amp;lt; i → xs[j]? = xs[j + 1]?" state_after="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h'✝ : i ≤ j&#10;h' : j &amp;lt; i&#10;⊢ xs[j]? = xs[j + 1]?" tactic="intro h'">
                    <AtomNode start="(338, 3)" end="(338, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(338, 9)" end="(338, 11)">
                      <IdentNode start="(338, 9)" end="(338, 11)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(339, 3)" end="(339, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h'✝ : i ≤ j&#10;h' : j &amp;lt; i&#10;⊢ xs[j]? = xs[j + 1]?" state_after="no goals" tactic="omega">
                    <AtomNode start="(339, 3)" end="(339, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(341, 1)" end="(348, 17)" name="getElem_eraseIdx" full_name="Array.getElem_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(341, 1)" end="(348, 17)" name="getElem_eraseIdx" full_name="Array.getElem_eraseIdx" _is_private_decl="False">
        <AtomNode start="(341, 1)" end="(341, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(341, 9)" end="(341, 25)">
          <IdentNode start="(341, 9)" end="(341, 25)" leading="" trailing=" " raw_val="getElem_eraseIdx" val="getElem_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(341, 26)" end="(345, 55)">
          <NullNode start="(341, 26)" end="(341, 110)">
            <OtherNode start="(341, 26)" end="(341, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(341, 26)" end="(341, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(341, 27)" end="(341, 29)">
                <IdentNode start="(341, 27)" end="(341, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(341, 30)" end="(341, 39)">
                <AtomNode start="(341, 30)" end="(341, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(341, 32)" end="(341, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(341, 32)" end="(341, 37)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(341, 38)" end="(341, 39)">
                    <IdentNode start="(341, 38)" end="(341, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(341, 39)" end="(341, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(341, 41)" end="(341, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(341, 41)" end="(341, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(341, 42)" end="(341, 43)">
                <IdentNode start="(341, 42)" end="(341, 43)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(341, 44)" end="(341, 49)">
                <AtomNode start="(341, 44)" end="(341, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(341, 46)" end="(341, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(341, 49)" end="(341, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(341, 51)" end="(341, 68)">
              <AtomNode start="(341, 51)" end="(341, 52)" leading="" trailing="" val="("/>
              <NullNode start="(341, 52)" end="(341, 53)">
                <IdentNode start="(341, 52)" end="(341, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(341, 54)" end="(341, 67)">
                <AtomNode start="(341, 54)" end="(341, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(341, 56)" end="(341, 67)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(341, 56)" end="(341, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(341, 58)" end="(341, 59)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(341, 60)" end="(341, 67)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(341, 67)" end="(341, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(341, 69)" end="(341, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(341, 69)" end="(341, 70)" leading="" trailing="" val="{"/>
              <NullNode start="(341, 70)" end="(341, 71)">
                <IdentNode start="(341, 70)" end="(341, 71)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(341, 72)" end="(341, 77)">
                <AtomNode start="(341, 72)" end="(341, 73)" leading="" trailing=" " val=":"/>
                <IdentNode start="(341, 74)" end="(341, 77)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(341, 77)" end="(341, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(341, 79)" end="(341, 110)">
              <AtomNode start="(341, 79)" end="(341, 80)" leading="" trailing="" val="("/>
              <NullNode start="(341, 80)" end="(341, 82)">
                <IdentNode start="(341, 80)" end="(341, 82)" leading="" trailing=" " raw_val="h'" val="h'"/>
              </NullNode>
              <NullNode start="(341, 83)" end="(341, 109)">
                <AtomNode start="(341, 83)" end="(341, 84)" leading="" trailing=" " val=":"/>
                <OtherNode start="(341, 85)" end="(341, 109)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(341, 85)" end="(341, 86)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(341, 87)" end="(341, 88)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(341, 89)" end="(341, 109)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(341, 89)" end="(341, 104)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(341, 89)" end="(341, 90)" leading="" trailing="" val="("/>
                      <OtherNode start="(341, 90)" end="(341, 103)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(341, 90)" end="(341, 101)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                        <NullNode start="(341, 102)" end="(341, 103)">
                          <IdentNode start="(341, 102)" end="(341, 103)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(341, 103)" end="(341, 104)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(341, 104)" end="(341, 105)" leading="" trailing="" val="."/>
                    <IdentNode start="(341, 105)" end="(341, 109)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(341, 109)" end="(341, 110)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(341, 111)" end="(345, 55)">
            <AtomNode start="(341, 111)" end="(341, 112)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(342, 5)" end="(345, 55)" kind="«term_=_»">
              <OtherNode start="(342, 5)" end="(342, 23)" kind="«term__[_]»">
                <OtherNode start="(342, 5)" end="(342, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(342, 5)" end="(342, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(342, 6)" end="(342, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(342, 6)" end="(342, 17)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                    <NullNode start="(342, 18)" end="(342, 19)">
                      <IdentNode start="(342, 18)" end="(342, 19)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(342, 19)" end="(342, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(342, 20)" end="(342, 21)" leading="" trailing="" val="["/>
                <IdentNode start="(342, 21)" end="(342, 22)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(342, 22)" end="(342, 23)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(342, 24)" end="(342, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(342, 26)" end="(345, 55)" kind="termDepIfThenElse">
                <AtomNode start="(342, 26)" end="(342, 28)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(342, 29)" end="(342, 32)">
                  <IdentNode start="(342, 29)" end="(342, 32)" leading="" trailing=" " raw_val="h''" val="h''"/>
                </LeanBinderidentNode>
                <AtomNode start="(342, 33)" end="(342, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 35)" end="(342, 40)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(342, 35)" end="(342, 36)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(342, 37)" end="(342, 38)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(342, 39)" end="(342, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(342, 41)" end="(342, 45)" leading="" trailing="&#10;        " val="then"/>
                <OtherNode start="(343, 9)" end="(343, 14)" kind="«term__[_]»">
                  <IdentNode start="(343, 9)" end="(343, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                  <AtomNode start="(343, 11)" end="(343, 12)" leading="" trailing="" val="["/>
                  <IdentNode start="(343, 12)" end="(343, 13)" leading="" trailing="" raw_val="j" val="j"/>
                  <AtomNode start="(343, 13)" end="(343, 14)" leading="" trailing="&#10;      " val="]"/>
                </OtherNode>
                <AtomNode start="(344, 7)" end="(344, 11)" leading="" trailing="&#10;        " val="else"/>
                <OtherNode start="(345, 9)" end="(345, 55)" kind="«term__[_]'_»">
                  <IdentNode start="(345, 9)" end="(345, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                  <AtomNode start="(345, 11)" end="(345, 12)" leading="" trailing="" val="["/>
                  <OtherNode start="(345, 12)" end="(345, 17)" kind="«term_+_»">
                    <IdentNode start="(345, 12)" end="(345, 13)" leading="" trailing=" " raw_val="j" val="j"/>
                    <AtomNode start="(345, 14)" end="(345, 15)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(345, 16)" end="(345, 17)" kind="num">
                      <AtomNode start="(345, 16)" end="(345, 17)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(345, 17)" end="(345, 19)" leading="" trailing="" val="]'"/>
                  <OtherNode start="(345, 19)" end="(345, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(345, 19)" end="(345, 20)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(345, 20)" end="(345, 54)">
                      <AtomNode start="(345, 20)" end="(345, 22)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(345, 23)" end="(345, 54)">
                        <TacticTacticseq1IndentedNode start="(345, 23)" end="(345, 54)">
                          <NullNode start="(345, 23)" end="(345, 54)">
                            <OtherNode start="(345, 23)" end="(345, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type ?u.49994&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; (xs.eraseIdx i h).size&#10;h'' : ¬j &amp;lt; i&#10;⊢ j + 1 &amp;lt; xs.size" state_after="α : Type ?u.49994&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; xs.size - 1&#10;h'' : ¬j &amp;lt; i&#10;⊢ j + 1 &amp;lt; xs.size" tactic="rw [size_eraseIdx] at h'">
                              <AtomNode start="(345, 23)" end="(345, 25)" leading="" trailing=" " val="rw"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <OtherNode start="(345, 26)" end="(345, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                <AtomNode start="(345, 26)" end="(345, 27)" leading="" trailing="" val="["/>
                                <NullNode start="(345, 27)" end="(345, 40)">
                                  <OtherNode start="(345, 27)" end="(345, 40)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(345, 27)" end="(345, 40)" leading="" trailing="" raw_val="size_eraseIdx" val="size_eraseIdx" full_name="Array.size_eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(345, 40)" end="(345, 41)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                              <NullNode start="(345, 42)" end="(345, 47)">
                                <OtherNode start="(345, 42)" end="(345, 47)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(345, 42)" end="(345, 44)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(345, 45)" end="(345, 47)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(345, 45)" end="(345, 47)">
                                      <IdentNode start="(345, 45)" end="(345, 47)" leading="" trailing="" raw_val="h'" val="h'"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(345, 47)" end="(345, 48)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(345, 49)" end="(345, 54)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.49994&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; xs.size - 1&#10;h'' : ¬j &amp;lt; i&#10;⊢ j + 1 &amp;lt; xs.size" state_after="no goals" tactic="omega">
                              <AtomNode start="(345, 49)" end="(345, 54)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(345, 54)" end="(345, 55)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(345, 56)" end="(348, 17)">
          <AtomNode start="(345, 56)" end="(345, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(345, 59)" end="(348, 17)">
            <AtomNode start="(345, 59)" end="(345, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(346, 3)" end="(348, 17)">
              <TacticTacticseq1IndentedNode start="(346, 3)" end="(348, 17)">
                <NullNode start="(346, 3)" end="(348, 17)">
                  <OtherNode start="(346, 3)" end="(346, 24)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; (xs.eraseIdx i h).size&#10;⊢ (xs.eraseIdx i h)[j] = if h'' : j &amp;lt; i then xs[j] else xs[j + 1]" state_after="case x&#10;α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; (xs.eraseIdx i h).size&#10;⊢ some (xs.eraseIdx i h)[j] = some (if h'' : j &amp;lt; i then xs[j] else xs[j + 1])" tactic="apply Option.some.inj">
                    <AtomNode start="(346, 3)" end="(346, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(346, 9)" end="(346, 24)" leading="" trailing="&#10;  " raw_val="Option.some.inj" val="Option.some.inj" full_name="Option.some.inj" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(347, 3)" end="(347, 48)" kind="Lean.Parser.Tactic.rwSeq" state_before="case x&#10;α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; (xs.eraseIdx i h).size&#10;⊢ some (xs.eraseIdx i h)[j] = some (if h'' : j &amp;lt; i then xs[j] else xs[j + 1])" state_after="case x&#10;α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; (xs.eraseIdx i h).size&#10;⊢ (if j &amp;lt; i then xs[j]? else xs[j + 1]?) = some (if h'' : j &amp;lt; i then xs[j] else xs[j + 1])" tactic="rw [← getElem?_eq_getElem, getElem?_eraseIdx]">
                    <AtomNode start="(347, 3)" end="(347, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(347, 6)" end="(347, 48)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(347, 6)" end="(347, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(347, 7)" end="(347, 47)">
                        <OtherNode start="(347, 7)" end="(347, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(347, 7)" end="(347, 8)">
                            <OtherNode start="(347, 7)" end="(347, 8)" kind="patternIgnore">
                              <OtherNode start="(347, 7)" end="(347, 8)" kind="token.«← »">
                                <AtomNode start="(347, 7)" end="(347, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(347, 9)" end="(347, 28)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="Array.getElem?_eq_getElem" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(347, 28)" end="(347, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(347, 30)" end="(347, 47)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(347, 30)" end="(347, 47)" leading="" trailing="" raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx" full_name="Array.getElem?_eraseIdx" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(324, 9)" def_end="(324, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(347, 47)" end="(347, 48)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(348, 3)" end="(348, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case x&#10;α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;j : Nat&#10;h' : j &amp;lt; (xs.eraseIdx i h).size&#10;⊢ (if j &amp;lt; i then xs[j]? else xs[j + 1]?) = some (if h'' : j &amp;lt; i then xs[j] else xs[j + 1])" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(348, 3)" end="(348, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(348, 3)" end="(348, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(348, 9)" end="(348, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(348, 13)" end="(348, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(348, 13)" end="(348, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(350, 1)" end="(355, 11)" name="eraseIdx_eq_empty_iff" full_name="Array.eraseIdx_eq_empty_iff">
      <CommandDeclmodifiersNode start="(350, 1)" end="(350, 8)">
        <NullNode/>
        <NullNode start="(350, 1)" end="(350, 8)">
          <OtherNode start="(350, 1)" end="(350, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(350, 1)" end="(350, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(350, 3)" end="(350, 7)">
              <OtherNode start="(350, 3)" end="(350, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(350, 3)" end="(350, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(350, 3)" end="(350, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(350, 7)" end="(350, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(350, 9)" end="(355, 11)" name="eraseIdx_eq_empty_iff" full_name="Array.eraseIdx_eq_empty_iff" _is_private_decl="False">
        <AtomNode start="(350, 9)" end="(350, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(350, 17)" end="(350, 38)">
          <IdentNode start="(350, 17)" end="(350, 38)" leading="" trailing=" " raw_val="eraseIdx_eq_empty_iff" val="eraseIdx_eq_empty_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(350, 39)" end="(350, 111)">
          <NullNode start="(350, 39)" end="(350, 67)">
            <OtherNode start="(350, 39)" end="(350, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(350, 39)" end="(350, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(350, 40)" end="(350, 42)">
                <IdentNode start="(350, 40)" end="(350, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(350, 43)" end="(350, 52)">
                <AtomNode start="(350, 43)" end="(350, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(350, 45)" end="(350, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(350, 45)" end="(350, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(350, 51)" end="(350, 52)">
                    <IdentNode start="(350, 51)" end="(350, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(350, 52)" end="(350, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(350, 54)" end="(350, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(350, 54)" end="(350, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(350, 55)" end="(350, 56)">
                <IdentNode start="(350, 55)" end="(350, 56)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(350, 57)" end="(350, 62)">
                <AtomNode start="(350, 57)" end="(350, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(350, 59)" end="(350, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(350, 62)" end="(350, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(350, 64)" end="(350, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(350, 64)" end="(350, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(350, 65)" end="(350, 66)">
                <IdentNode start="(350, 65)" end="(350, 66)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(350, 66)" end="(350, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(350, 68)" end="(350, 111)">
            <AtomNode start="(350, 68)" end="(350, 69)" leading="" trailing=" " val=":"/>
            <OtherNode start="(350, 70)" end="(350, 111)" kind="«term_↔_»">
              <OtherNode start="(350, 70)" end="(350, 89)" kind="«term_=_»">
                <OtherNode start="(350, 70)" end="(350, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(350, 70)" end="(350, 81)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                  <NullNode start="(350, 82)" end="(350, 83)">
                    <IdentNode start="(350, 82)" end="(350, 83)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(350, 84)" end="(350, 85)" leading="" trailing=" " val="="/>
                <OtherNode start="(350, 86)" end="(350, 89)" kind="«term#[_,]»">
                  <AtomNode start="(350, 86)" end="(350, 88)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(350, 88)" end="(350, 89)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(350, 90)" end="(350, 91)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(350, 92)" end="(350, 111)" kind="«term_∧_»">
                <OtherNode start="(350, 92)" end="(350, 103)" kind="«term_=_»">
                  <IdentNode start="(350, 92)" end="(350, 99)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(350, 100)" end="(350, 101)" leading="" trailing=" " val="="/>
                  <OtherNode start="(350, 102)" end="(350, 103)" kind="num">
                    <AtomNode start="(350, 102)" end="(350, 103)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(350, 104)" end="(350, 105)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(350, 106)" end="(350, 111)" kind="«term_=_»">
                  <IdentNode start="(350, 106)" end="(350, 107)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(350, 108)" end="(350, 109)" leading="" trailing=" " val="="/>
                  <OtherNode start="(350, 110)" end="(350, 111)" kind="num">
                    <AtomNode start="(350, 110)" end="(350, 111)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(350, 112)" end="(355, 11)">
          <AtomNode start="(350, 112)" end="(350, 114)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(350, 115)" end="(355, 11)">
            <AtomNode start="(350, 115)" end="(350, 117)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(351, 3)" end="(355, 11)">
              <TacticTacticseq1IndentedNode start="(351, 3)" end="(355, 11)">
                <NullNode start="(351, 3)" end="(355, 11)">
                  <OtherNode start="(351, 3)" end="(351, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;⊢ xs.eraseIdx i h = #[] ↔ xs.size = 1 ∧ i = 0" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ { toList := xs }.eraseIdx i h = #[] ↔ { toList := xs }.size = 1 ∧ i = 0" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(351, 3)" end="(351, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(351, 10)" end="(351, 12)">
                      <OtherNode start="(351, 10)" end="(351, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(351, 10)" end="(351, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(351, 13)" end="(351, 22)">
                      <AtomNode start="(351, 13)" end="(351, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(351, 18)" end="(351, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(351, 18)" end="(351, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(351, 18)" end="(351, 22)">
                            <OtherNode start="(351, 18)" end="(351, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(351, 18)" end="(351, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(351, 19)" end="(351, 21)">
                                <OtherNode start="(351, 19)" end="(351, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(351, 19)" end="(351, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(351, 19)" end="(351, 21)">
                                      <OtherNode start="(351, 19)" end="(351, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(351, 19)" end="(351, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(351, 21)" end="(351, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(352, 3)" end="(353, 26)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ { toList := xs }.eraseIdx i h = #[] ↔ { toList := xs }.size = 1 ∧ i = 0" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ xs = [] → xs.length = 1 ∧ i = 0" tactic="simp only [List.eraseIdx_toArray, mk.injEq, List.eraseIdx_eq_nil_iff, List.size_toArray,&#10;  or_iff_right_iff_imp]">
                    <AtomNode start="(352, 3)" end="(352, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(352, 8)" end="(352, 12)">
                      <AtomNode start="(352, 8)" end="(352, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(352, 13)" end="(353, 26)">
                      <AtomNode start="(352, 13)" end="(352, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(352, 14)" end="(353, 25)">
                        <OtherNode start="(352, 14)" end="(352, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(352, 14)" end="(352, 35)" leading="" trailing="" raw_val="List.eraseIdx_toArray" val="List.eraseIdx_toArray" full_name="List.eraseIdx_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(352, 35)" end="(352, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(352, 37)" end="(352, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(352, 37)" end="(352, 45)" leading="" trailing="" raw_val="mk.injEq" val="mk.injEq" full_name="Array.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(352, 45)" end="(352, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(352, 47)" end="(352, 71)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(352, 47)" end="(352, 71)" leading="" trailing="" raw_val="List.eraseIdx_eq_nil_iff" val="List.eraseIdx_eq_nil_iff" full_name="List.eraseIdx_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(352, 71)" end="(352, 72)" leading="" trailing=" " val=","/>
                        <OtherNode start="(352, 73)" end="(352, 90)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(352, 73)" end="(352, 90)" leading="" trailing="" raw_val="List.size_toArray" val="List.size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(352, 90)" end="(352, 91)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(353, 5)" end="(353, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(353, 5)" end="(353, 25)" leading="" trailing="" raw_val="or_iff_right_iff_imp" val="or_iff_right_iff_imp" full_name="or_iff_right_iff_imp" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(353, 25)" end="(353, 26)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(354, 3)" end="(354, 13)" kind="Lean.Parser.Tactic.rintro" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ xs = [] → xs.length = 1 ∧ i = 0" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;h : i &amp;lt; { toList := [] }.size&#10;⊢ [].length = 1 ∧ i = 0" tactic="rintro rfl">
                    <AtomNode start="(354, 3)" end="(354, 9)" leading="" trailing=" " val="rintro"/>
                    <NullNode start="(354, 10)" end="(354, 13)">
                      <OtherNode start="(354, 10)" end="(354, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(354, 10)" end="(354, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(354, 10)" end="(354, 13)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(355, 3)" end="(355, 11)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;h : i &amp;lt; { toList := [] }.size&#10;⊢ [].length = 1 ∧ i = 0" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(355, 3)" end="(355, 11)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(357, 1)" end="(362, 9)" name="eraseIdx_ne_empty_iff" full_name="Array.eraseIdx_ne_empty_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(357, 1)" end="(362, 9)" name="eraseIdx_ne_empty_iff" full_name="Array.eraseIdx_ne_empty_iff" _is_private_decl="False">
        <AtomNode start="(357, 1)" end="(357, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(357, 9)" end="(357, 30)">
          <IdentNode start="(357, 9)" end="(357, 30)" leading="" trailing=" " raw_val="eraseIdx_ne_empty_iff" val="eraseIdx_ne_empty_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(357, 31)" end="(357, 95)">
          <NullNode start="(357, 31)" end="(357, 59)">
            <OtherNode start="(357, 31)" end="(357, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(357, 31)" end="(357, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(357, 32)" end="(357, 34)">
                <IdentNode start="(357, 32)" end="(357, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(357, 35)" end="(357, 44)">
                <AtomNode start="(357, 35)" end="(357, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(357, 37)" end="(357, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(357, 37)" end="(357, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(357, 43)" end="(357, 44)">
                    <IdentNode start="(357, 43)" end="(357, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(357, 44)" end="(357, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(357, 46)" end="(357, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(357, 46)" end="(357, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(357, 47)" end="(357, 48)">
                <IdentNode start="(357, 47)" end="(357, 48)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(357, 49)" end="(357, 54)">
                <AtomNode start="(357, 49)" end="(357, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(357, 51)" end="(357, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(357, 54)" end="(357, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(357, 56)" end="(357, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(357, 56)" end="(357, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(357, 57)" end="(357, 58)">
                <IdentNode start="(357, 57)" end="(357, 58)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(357, 58)" end="(357, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(357, 60)" end="(357, 95)">
            <AtomNode start="(357, 60)" end="(357, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(357, 62)" end="(357, 95)" kind="«term_↔_»">
              <OtherNode start="(357, 62)" end="(357, 81)" kind="«term_≠_»">
                <OtherNode start="(357, 62)" end="(357, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(357, 62)" end="(357, 73)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                  <NullNode start="(357, 74)" end="(357, 75)">
                    <IdentNode start="(357, 74)" end="(357, 75)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(357, 76)" end="(357, 77)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(357, 78)" end="(357, 81)" kind="«term#[_,]»">
                  <AtomNode start="(357, 78)" end="(357, 80)" leading="" trailing="" val="#["/>
                  <NullNode/>
                  <AtomNode start="(357, 80)" end="(357, 81)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(357, 82)" end="(357, 83)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(357, 84)" end="(357, 95)" kind="«term_≤_»">
                <OtherNode start="(357, 84)" end="(357, 85)" kind="num">
                  <AtomNode start="(357, 84)" end="(357, 85)" leading="" trailing=" " val="2"/>
                </OtherNode>
                <AtomNode start="(357, 86)" end="(357, 87)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(357, 88)" end="(357, 95)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(357, 96)" end="(362, 9)">
          <AtomNode start="(357, 96)" end="(357, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(357, 99)" end="(362, 9)">
            <AtomNode start="(357, 99)" end="(357, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(358, 3)" end="(362, 9)">
              <TacticTacticseq1IndentedNode start="(358, 3)" end="(362, 9)">
                <NullNode start="(358, 3)" end="(362, 9)">
                  <OtherNode start="(358, 3)" end="(358, 41)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i &amp;lt; xs.size&#10;⊢ xs.eraseIdx i h ≠ #[] ↔ 2 ≤ xs.size" state_after="case mk.nil&#10;α : Type u_1&#10;i : Nat&#10;h : i &amp;lt; { toList := [] }.size&#10;⊢ { toList := [] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [] }.size&#10;&#10;case mk.cons.nil&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; { toList := [a] }.size&#10;⊢ { toList := [a] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [a] }.size&#10;&#10;case mk.cons.cons&#10;α : Type u_1&#10;i : Nat&#10;a b : α&#10;l : List α&#10;h : i &amp;lt; { toList := a :: b :: l }.size&#10;⊢ { toList := a :: b :: l }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := a :: b :: l }.size" tactic="rcases xs with ⟨_ | ⟨a, (_ | ⟨b, l⟩)⟩⟩">
                    <AtomNode start="(358, 3)" end="(358, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(358, 10)" end="(358, 12)">
                      <OtherNode start="(358, 10)" end="(358, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(358, 10)" end="(358, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(358, 13)" end="(358, 41)">
                      <AtomNode start="(358, 13)" end="(358, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(358, 18)" end="(358, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(358, 18)" end="(358, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(358, 18)" end="(358, 41)">
                            <OtherNode start="(358, 18)" end="(358, 41)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(358, 18)" end="(358, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(358, 19)" end="(358, 40)">
                                <OtherNode start="(358, 19)" end="(358, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(358, 19)" end="(358, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(358, 19)" end="(358, 40)">
                                      <OtherNode start="(358, 19)" end="(358, 20)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                        <AtomNode start="(358, 19)" end="(358, 20)" leading="" trailing=" " val="_"/>
                                      </OtherNode>
                                      <AtomNode start="(358, 21)" end="(358, 22)" leading="" trailing=" " val="|"/>
                                      <OtherNode start="(358, 23)" end="(358, 40)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                        <AtomNode start="(358, 23)" end="(358, 24)" leading="" trailing="" val="⟨"/>
                                        <NullNode start="(358, 24)" end="(358, 39)">
                                          <OtherNode start="(358, 24)" end="(358, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                            <OtherNode start="(358, 24)" end="(358, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                              <NullNode start="(358, 24)" end="(358, 25)">
                                                <OtherNode start="(358, 24)" end="(358, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                  <IdentNode start="(358, 24)" end="(358, 25)" leading="" trailing="" raw_val="a" val="a"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(358, 25)" end="(358, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(358, 27)" end="(358, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                            <OtherNode start="(358, 27)" end="(358, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                              <NullNode start="(358, 27)" end="(358, 39)">
                                                <OtherNode start="(358, 27)" end="(358, 39)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                  <AtomNode start="(358, 27)" end="(358, 28)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(358, 28)" end="(358, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                    <OtherNode start="(358, 28)" end="(358, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                      <NullNode start="(358, 28)" end="(358, 38)">
                                                        <OtherNode start="(358, 28)" end="(358, 29)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                          <AtomNode start="(358, 28)" end="(358, 29)" leading="" trailing=" " val="_"/>
                                                        </OtherNode>
                                                        <AtomNode start="(358, 30)" end="(358, 31)" leading="" trailing=" " val="|"/>
                                                        <OtherNode start="(358, 32)" end="(358, 38)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                          <AtomNode start="(358, 32)" end="(358, 33)" leading="" trailing="" val="⟨"/>
                                                          <NullNode start="(358, 33)" end="(358, 37)">
                                                            <OtherNode start="(358, 33)" end="(358, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(358, 33)" end="(358, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(358, 33)" end="(358, 34)">
                                                            <OtherNode start="(358, 33)" end="(358, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(358, 33)" end="(358, 34)" leading="" trailing="" raw_val="b" val="b"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(358, 34)" end="(358, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(358, 36)" end="(358, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(358, 36)" end="(358, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(358, 36)" end="(358, 37)">
                                                            <OtherNode start="(358, 36)" end="(358, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(358, 36)" end="(358, 37)" leading="" trailing="" raw_val="l" val="l"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(358, 37)" end="(358, 38)" leading="" trailing="" val="⟩"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(358, 38)" end="(358, 39)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(358, 39)" end="(358, 40)" leading="" trailing="" val="⟩"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(358, 40)" end="(358, 41)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(359, 3)" end="(359, 9)" kind="Lean.cdot" state_before="case mk.nil&#10;α : Type u_1&#10;i : Nat&#10;h : i &amp;lt; { toList := [] }.size&#10;⊢ { toList := [] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [] }.size&#10;&#10;case mk.cons.nil&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; { toList := [a] }.size&#10;⊢ { toList := [a] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [a] }.size&#10;&#10;case mk.cons.cons&#10;α : Type u_1&#10;i : Nat&#10;a b : α&#10;l : List α&#10;h : i &amp;lt; { toList := a :: b :: l }.size&#10;⊢ { toList := a :: b :: l }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := a :: b :: l }.size" state_after="case mk.cons.nil&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; { toList := [a] }.size&#10;⊢ { toList := [a] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [a] }.size&#10;&#10;case mk.cons.cons&#10;α : Type u_1&#10;i : Nat&#10;a b : α&#10;l : List α&#10;h : i &amp;lt; { toList := a :: b :: l }.size&#10;⊢ { toList := a :: b :: l }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := a :: b :: l }.size" tactic="· simp">
                    <OtherNode start="(359, 3)" end="(359, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(359, 3)" end="(359, 4)" kind="patternIgnore">
                        <OtherNode start="(359, 3)" end="(359, 4)" kind="token.«· »">
                          <AtomNode start="(359, 3)" end="(359, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(359, 5)" end="(359, 9)">
                      <TacticTacticseq1IndentedNode start="(359, 5)" end="(359, 9)">
                        <NullNode start="(359, 5)" end="(359, 9)">
                          <OtherNode start="(359, 5)" end="(359, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mk.nil&#10;α : Type u_1&#10;i : Nat&#10;h : i &amp;lt; { toList := [] }.size&#10;⊢ { toList := [] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [] }.size" state_after="no goals" tactic="simp">
                            <AtomNode start="(359, 5)" end="(359, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(360, 3)" end="(361, 13)" kind="Lean.cdot" state_before="case mk.cons.nil&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; { toList := [a] }.size&#10;⊢ { toList := [a] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [a] }.size&#10;&#10;case mk.cons.cons&#10;α : Type u_1&#10;i : Nat&#10;a b : α&#10;l : List α&#10;h : i &amp;lt; { toList := a :: b :: l }.size&#10;⊢ { toList := a :: b :: l }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := a :: b :: l }.size" state_after="case mk.cons.cons&#10;α : Type u_1&#10;i : Nat&#10;a b : α&#10;l : List α&#10;h : i &amp;lt; { toList := a :: b :: l }.size&#10;⊢ { toList := a :: b :: l }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := a :: b :: l }.size" tactic="· simp at h&#10;  simp [h]">
                    <OtherNode start="(360, 3)" end="(360, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(360, 3)" end="(360, 4)" kind="patternIgnore">
                        <OtherNode start="(360, 3)" end="(360, 4)" kind="token.«· »">
                          <AtomNode start="(360, 3)" end="(360, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(360, 5)" end="(361, 13)">
                      <TacticTacticseq1IndentedNode start="(360, 5)" end="(361, 13)">
                        <NullNode start="(360, 5)" end="(361, 13)">
                          <OtherNode start="(360, 5)" end="(360, 14)" kind="Lean.Parser.Tactic.simp" state_before="case mk.cons.nil&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; { toList := [a] }.size&#10;⊢ { toList := [a] }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := [a] }.size" state_after="case mk.cons.nil&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;h✝ : i &amp;lt; { toList := [a] }.size&#10;h : i = 0&#10;⊢ { toList := [a] }.eraseIdx i h✝ ≠ #[] ↔ 2 ≤ { toList := [a] }.size" tactic="simp at h">
                            <AtomNode start="(360, 5)" end="(360, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(360, 10)" end="(360, 14)">
                              <OtherNode start="(360, 10)" end="(360, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(360, 10)" end="(360, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(360, 13)" end="(360, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(360, 13)" end="(360, 14)">
                                    <IdentNode start="(360, 13)" end="(360, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(361, 5)" end="(361, 13)" kind="Lean.Parser.Tactic.simp" state_before="case mk.cons.nil&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;h✝ : i &amp;lt; { toList := [a] }.size&#10;h : i = 0&#10;⊢ { toList := [a] }.eraseIdx i h✝ ≠ #[] ↔ 2 ≤ { toList := [a] }.size" state_after="no goals" tactic="simp [h]">
                            <AtomNode start="(361, 5)" end="(361, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(361, 10)" end="(361, 13)">
                              <AtomNode start="(361, 10)" end="(361, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(361, 11)" end="(361, 12)">
                                <OtherNode start="(361, 11)" end="(361, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(361, 11)" end="(361, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(361, 12)" end="(361, 13)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(362, 3)" end="(362, 9)" kind="Lean.cdot" state_before="case mk.cons.cons&#10;α : Type u_1&#10;i : Nat&#10;a b : α&#10;l : List α&#10;h : i &amp;lt; { toList := a :: b :: l }.size&#10;⊢ { toList := a :: b :: l }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := a :: b :: l }.size" state_after="no goals" tactic="· simp">
                    <OtherNode start="(362, 3)" end="(362, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(362, 3)" end="(362, 4)" kind="patternIgnore">
                        <OtherNode start="(362, 3)" end="(362, 4)" kind="token.«· »">
                          <AtomNode start="(362, 3)" end="(362, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(362, 5)" end="(362, 9)">
                      <TacticTacticseq1IndentedNode start="(362, 5)" end="(362, 9)">
                        <NullNode start="(362, 5)" end="(362, 9)">
                          <OtherNode start="(362, 5)" end="(362, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mk.cons.cons&#10;α : Type u_1&#10;i : Nat&#10;a b : α&#10;l : List α&#10;h : i &amp;lt; { toList := a :: b :: l }.size&#10;⊢ { toList := a :: b :: l }.eraseIdx i h ≠ #[] ↔ 2 ≤ { toList := a :: b :: l }.size" state_after="no goals" tactic="simp">
                            <AtomNode start="(362, 5)" end="(362, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(364, 1)" end="(366, 58)" name="mem_of_mem_eraseIdx" full_name="Array.mem_of_mem_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(364, 1)" end="(366, 58)" name="mem_of_mem_eraseIdx" full_name="Array.mem_of_mem_eraseIdx" _is_private_decl="False">
        <AtomNode start="(364, 1)" end="(364, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(364, 9)" end="(364, 28)">
          <IdentNode start="(364, 9)" end="(364, 28)" leading="" trailing=" " raw_val="mem_of_mem_eraseIdx" val="mem_of_mem_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(364, 29)" end="(364, 98)">
          <NullNode start="(364, 29)" end="(364, 89)">
            <OtherNode start="(364, 29)" end="(364, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(364, 29)" end="(364, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(364, 30)" end="(364, 32)">
                <IdentNode start="(364, 30)" end="(364, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(364, 33)" end="(364, 42)">
                <AtomNode start="(364, 33)" end="(364, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(364, 35)" end="(364, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(364, 35)" end="(364, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(364, 41)" end="(364, 42)">
                    <IdentNode start="(364, 41)" end="(364, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(364, 42)" end="(364, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(364, 44)" end="(364, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(364, 44)" end="(364, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(364, 45)" end="(364, 46)">
                <IdentNode start="(364, 45)" end="(364, 46)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(364, 47)" end="(364, 52)">
                <AtomNode start="(364, 47)" end="(364, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(364, 49)" end="(364, 52)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(364, 52)" end="(364, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(364, 54)" end="(364, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(364, 54)" end="(364, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(364, 55)" end="(364, 56)">
                <IdentNode start="(364, 55)" end="(364, 56)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(364, 56)" end="(364, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(364, 58)" end="(364, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(364, 58)" end="(364, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(364, 59)" end="(364, 60)">
                <IdentNode start="(364, 59)" end="(364, 60)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(364, 61)" end="(364, 64)">
                <AtomNode start="(364, 61)" end="(364, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(364, 63)" end="(364, 64)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(364, 64)" end="(364, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(364, 66)" end="(364, 89)">
              <AtomNode start="(364, 66)" end="(364, 67)" leading="" trailing="" val="("/>
              <NullNode start="(364, 67)" end="(364, 68)">
                <IdentNode start="(364, 67)" end="(364, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(364, 69)" end="(364, 88)">
                <AtomNode start="(364, 69)" end="(364, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(364, 71)" end="(364, 88)" kind="«term_∈_»">
                  <IdentNode start="(364, 71)" end="(364, 72)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(364, 73)" end="(364, 74)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(364, 75)" end="(364, 88)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(364, 75)" end="(364, 86)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                    <NullNode start="(364, 87)" end="(364, 88)">
                      <IdentNode start="(364, 87)" end="(364, 88)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(364, 88)" end="(364, 89)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(364, 90)" end="(364, 98)">
            <AtomNode start="(364, 90)" end="(364, 91)" leading="" trailing=" " val=":"/>
            <OtherNode start="(364, 92)" end="(364, 98)" kind="«term_∈_»">
              <IdentNode start="(364, 92)" end="(364, 93)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(364, 94)" end="(364, 95)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(364, 96)" end="(364, 98)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(364, 99)" end="(366, 58)">
          <AtomNode start="(364, 99)" end="(364, 101)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(364, 102)" end="(366, 58)">
            <AtomNode start="(364, 102)" end="(364, 104)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(365, 3)" end="(366, 58)">
              <TacticTacticseq1IndentedNode start="(365, 3)" end="(366, 58)">
                <NullNode start="(365, 3)" end="(366, 58)">
                  <OtherNode start="(365, 3)" end="(365, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h✝ : i &amp;lt; xs.size&#10;a : α&#10;h : a ∈ xs.eraseIdx i h✝&#10;⊢ a ∈ xs" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : a ∈ { toList := xs }.eraseIdx i h✝&#10;⊢ a ∈ { toList := xs }" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(365, 3)" end="(365, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(365, 10)" end="(365, 12)">
                      <OtherNode start="(365, 10)" end="(365, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(365, 10)" end="(365, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(365, 13)" end="(365, 22)">
                      <AtomNode start="(365, 13)" end="(365, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(365, 18)" end="(365, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(365, 18)" end="(365, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(365, 18)" end="(365, 22)">
                            <OtherNode start="(365, 18)" end="(365, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(365, 18)" end="(365, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(365, 19)" end="(365, 21)">
                                <OtherNode start="(365, 19)" end="(365, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(365, 19)" end="(365, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(365, 19)" end="(365, 21)">
                                      <OtherNode start="(365, 19)" end="(365, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(365, 19)" end="(365, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(365, 21)" end="(365, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(366, 3)" end="(366, 58)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : a ∈ { toList := xs }.eraseIdx i h✝&#10;⊢ a ∈ { toList := xs }" state_after="no goals" tactic="simpa using List.mem_of_mem_eraseIdx (by simpa using h)">
                    <AtomNode start="(366, 3)" end="(366, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(366, 9)" end="(366, 58)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(366, 9)" end="(366, 58)">
                        <AtomNode start="(366, 9)" end="(366, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(366, 15)" end="(366, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(366, 15)" end="(366, 39)" leading="" trailing=" " raw_val="List.mem_of_mem_eraseIdx" val="List.mem_of_mem_eraseIdx" full_name="List.mem_of_mem_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                          <NullNode start="(366, 40)" end="(366, 58)">
                            <OtherNode start="(366, 40)" end="(366, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(366, 40)" end="(366, 41)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(366, 41)" end="(366, 57)">
                                <AtomNode start="(366, 41)" end="(366, 43)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(366, 44)" end="(366, 57)">
                                  <TacticTacticseq1IndentedNode start="(366, 44)" end="(366, 57)">
                                    <NullNode start="(366, 44)" end="(366, 57)">
                                      <OtherNode start="(366, 44)" end="(366, 57)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;i : Nat&#10;a : α&#10;xs : List α&#10;h✝ : i &amp;lt; { toList := xs }.size&#10;h : a ∈ { toList := xs }.eraseIdx i h✝&#10;⊢ a ∈ xs.eraseIdx ?m.54406" state_after="no goals" tactic="simpa using h">
                                        <AtomNode start="(366, 44)" end="(366, 49)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(366, 50)" end="(366, 57)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(366, 50)" end="(366, 57)">
                                            <AtomNode start="(366, 50)" end="(366, 55)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(366, 56)" end="(366, 57)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(366, 57)" end="(366, 58)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(368, 1)" end="(373, 46)" name="eraseIdx_append_of_lt_size" full_name="Array.eraseIdx_append_of_lt_size">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(368, 1)" end="(373, 46)" name="eraseIdx_append_of_lt_size" full_name="Array.eraseIdx_append_of_lt_size" _is_private_decl="False">
        <AtomNode start="(368, 1)" end="(368, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(368, 9)" end="(368, 35)">
          <IdentNode start="(368, 9)" end="(368, 35)" leading="" trailing=" " raw_val="eraseIdx_append_of_lt_size" val="eraseIdx_append_of_lt_size"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(368, 36)" end="(369, 48)">
          <NullNode start="(368, 36)" end="(368, 98)">
            <OtherNode start="(368, 36)" end="(368, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(368, 36)" end="(368, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(368, 37)" end="(368, 39)">
                <IdentNode start="(368, 37)" end="(368, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(368, 40)" end="(368, 49)">
                <AtomNode start="(368, 40)" end="(368, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(368, 42)" end="(368, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(368, 42)" end="(368, 47)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(368, 48)" end="(368, 49)">
                    <IdentNode start="(368, 48)" end="(368, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(368, 49)" end="(368, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(368, 51)" end="(368, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(368, 51)" end="(368, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(368, 52)" end="(368, 53)">
                <IdentNode start="(368, 52)" end="(368, 53)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(368, 54)" end="(368, 59)">
                <AtomNode start="(368, 54)" end="(368, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(368, 56)" end="(368, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(368, 59)" end="(368, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(368, 61)" end="(368, 79)">
              <AtomNode start="(368, 61)" end="(368, 62)" leading="" trailing="" val="("/>
              <NullNode start="(368, 62)" end="(368, 64)">
                <IdentNode start="(368, 62)" end="(368, 64)" leading="" trailing=" " raw_val="hk" val="hk"/>
              </NullNode>
              <NullNode start="(368, 65)" end="(368, 78)">
                <AtomNode start="(368, 65)" end="(368, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(368, 67)" end="(368, 78)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(368, 67)" end="(368, 68)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(368, 69)" end="(368, 70)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(368, 71)" end="(368, 78)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(368, 78)" end="(368, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(368, 80)" end="(368, 94)">
              <AtomNode start="(368, 80)" end="(368, 81)" leading="" trailing="" val="("/>
              <NullNode start="(368, 81)" end="(368, 83)">
                <IdentNode start="(368, 81)" end="(368, 83)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(368, 84)" end="(368, 93)">
                <AtomNode start="(368, 84)" end="(368, 85)" leading="" trailing=" " val=":"/>
                <OtherNode start="(368, 86)" end="(368, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(368, 86)" end="(368, 91)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(368, 92)" end="(368, 93)">
                    <IdentNode start="(368, 92)" end="(368, 93)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(368, 93)" end="(368, 94)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(368, 95)" end="(368, 98)">
              <AtomNode start="(368, 95)" end="(368, 96)" leading="" trailing="" val="("/>
              <NullNode start="(368, 96)" end="(368, 97)">
                <IdentNode start="(368, 96)" end="(368, 97)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(368, 97)" end="(368, 98)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(368, 99)" end="(369, 48)">
            <AtomNode start="(368, 99)" end="(368, 100)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(369, 5)" end="(369, 48)" kind="«term_=_»">
              <OtherNode start="(369, 5)" end="(369, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(369, 5)" end="(369, 13)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(369, 14)" end="(369, 26)">
                  <OtherNode start="(369, 14)" end="(369, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(369, 14)" end="(369, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(369, 15)" end="(369, 23)" kind="«term_++_»">
                      <IdentNode start="(369, 15)" end="(369, 17)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(369, 18)" end="(369, 20)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(369, 21)" end="(369, 23)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(369, 23)" end="(369, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(369, 25)" end="(369, 26)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(369, 27)" end="(369, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(369, 29)" end="(369, 48)" kind="«term_++_»">
                <OtherNode start="(369, 29)" end="(369, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(369, 29)" end="(369, 37)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(369, 38)" end="(369, 42)">
                    <IdentNode start="(369, 38)" end="(369, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(369, 41)" end="(369, 42)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(369, 43)" end="(369, 45)" leading="" trailing=" " val="++"/>
                <IdentNode start="(369, 46)" end="(369, 48)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(369, 49)" end="(373, 46)">
          <AtomNode start="(369, 49)" end="(369, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(369, 52)" end="(373, 46)">
            <AtomNode start="(369, 52)" end="(369, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(370, 3)" end="(373, 46)">
              <TacticTacticseq1IndentedNode start="(370, 3)" end="(373, 46)">
                <NullNode start="(370, 3)" end="(373, 46)">
                  <OtherNode start="(370, 3)" end="(370, 21)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;k : Nat&#10;hk : k &amp;lt; xs.size&#10;ys : Array α&#10;h : k &amp;lt; (xs ++ ys).size&#10;⊢ (xs ++ ys).eraseIdx k h = xs.eraseIdx k hk ++ ys" state_after="case mk&#10;α : Type u_1&#10;k : Nat&#10;ys : Array α&#10;l : List α&#10;hk : k &amp;lt; { toList := l }.size&#10;h : k &amp;lt; ({ toList := l } ++ ys).size&#10;⊢ ({ toList := l } ++ ys).eraseIdx k h = { toList := l }.eraseIdx k hk ++ ys" tactic="rcases xs with ⟨l⟩">
                    <AtomNode start="(370, 3)" end="(370, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(370, 10)" end="(370, 12)">
                      <OtherNode start="(370, 10)" end="(370, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(370, 10)" end="(370, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(370, 13)" end="(370, 21)">
                      <AtomNode start="(370, 13)" end="(370, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(370, 18)" end="(370, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(370, 18)" end="(370, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(370, 18)" end="(370, 21)">
                            <OtherNode start="(370, 18)" end="(370, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(370, 18)" end="(370, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(370, 19)" end="(370, 20)">
                                <OtherNode start="(370, 19)" end="(370, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(370, 19)" end="(370, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(370, 19)" end="(370, 20)">
                                      <OtherNode start="(370, 19)" end="(370, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(370, 19)" end="(370, 20)" leading="" trailing="" raw_val="l" val="l"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(370, 20)" end="(370, 21)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(371, 3)" end="(371, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;k : Nat&#10;ys : Array α&#10;l : List α&#10;hk : k &amp;lt; { toList := l }.size&#10;h : k &amp;lt; ({ toList := l } ++ ys).size&#10;⊢ ({ toList := l } ++ ys).eraseIdx k h = { toList := l }.eraseIdx k hk ++ ys" state_after="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk : k &amp;lt; { toList := l }.size&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h = { toList := l }.eraseIdx k hk ++ { toList := l' }" tactic="rcases ys with ⟨l'⟩">
                    <AtomNode start="(371, 3)" end="(371, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(371, 10)" end="(371, 12)">
                      <OtherNode start="(371, 10)" end="(371, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(371, 10)" end="(371, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(371, 13)" end="(371, 22)">
                      <AtomNode start="(371, 13)" end="(371, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(371, 18)" end="(371, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(371, 18)" end="(371, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(371, 18)" end="(371, 22)">
                            <OtherNode start="(371, 18)" end="(371, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(371, 18)" end="(371, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(371, 19)" end="(371, 21)">
                                <OtherNode start="(371, 19)" end="(371, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(371, 19)" end="(371, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(371, 19)" end="(371, 21)">
                                      <OtherNode start="(371, 19)" end="(371, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(371, 19)" end="(371, 21)" leading="" trailing="" raw_val="l'" val="l'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(371, 21)" end="(371, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(372, 3)" end="(372, 13)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk : k &amp;lt; { toList := l }.size&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h = { toList := l }.eraseIdx k hk ++ { toList := l' }" state_after="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk✝ : k &amp;lt; { toList := l }.size&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;hk : k &amp;lt; l.length&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h = { toList := l }.eraseIdx k hk✝ ++ { toList := l' }" tactic="simp at hk">
                    <AtomNode start="(372, 3)" end="(372, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(372, 8)" end="(372, 13)">
                      <OtherNode start="(372, 8)" end="(372, 13)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(372, 8)" end="(372, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(372, 11)" end="(372, 13)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(372, 11)" end="(372, 13)">
                            <IdentNode start="(372, 11)" end="(372, 13)" leading="" trailing="&#10;  " raw_val="hk" val="hk"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(373, 3)" end="(373, 46)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk✝ : k &amp;lt; { toList := l }.size&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;hk : k &amp;lt; l.length&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h = { toList := l }.eraseIdx k hk✝ ++ { toList := l' }" state_after="no goals" tactic="simp [List.eraseIdx_append_of_lt_length, *]">
                    <AtomNode start="(373, 3)" end="(373, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(373, 8)" end="(373, 46)">
                      <AtomNode start="(373, 8)" end="(373, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(373, 9)" end="(373, 45)">
                        <OtherNode start="(373, 9)" end="(373, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(373, 9)" end="(373, 42)" leading="" trailing="" raw_val="List.eraseIdx_append_of_lt_length" val="List.eraseIdx_append_of_lt_length" full_name="List.eraseIdx_append_of_lt_length" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(373, 42)" end="(373, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(373, 44)" end="(373, 45)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(373, 44)" end="(373, 45)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(373, 45)" end="(373, 46)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(375, 1)" end="(380, 46)" name="eraseIdx_append_of_length_le" full_name="Array.eraseIdx_append_of_length_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(375, 1)" end="(380, 46)" name="eraseIdx_append_of_length_le" full_name="Array.eraseIdx_append_of_length_le" _is_private_decl="False">
        <AtomNode start="(375, 1)" end="(375, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(375, 9)" end="(375, 37)">
          <IdentNode start="(375, 9)" end="(375, 37)" leading="" trailing=" " raw_val="eraseIdx_append_of_length_le" val="eraseIdx_append_of_length_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(375, 38)" end="(376, 82)">
          <NullNode start="(375, 38)" end="(375, 100)">
            <OtherNode start="(375, 38)" end="(375, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(375, 38)" end="(375, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(375, 39)" end="(375, 41)">
                <IdentNode start="(375, 39)" end="(375, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(375, 42)" end="(375, 51)">
                <AtomNode start="(375, 42)" end="(375, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(375, 44)" end="(375, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(375, 44)" end="(375, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(375, 50)" end="(375, 51)">
                    <IdentNode start="(375, 50)" end="(375, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(375, 51)" end="(375, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(375, 53)" end="(375, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(375, 53)" end="(375, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(375, 54)" end="(375, 55)">
                <IdentNode start="(375, 54)" end="(375, 55)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(375, 56)" end="(375, 61)">
                <AtomNode start="(375, 56)" end="(375, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(375, 58)" end="(375, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(375, 61)" end="(375, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(375, 63)" end="(375, 81)">
              <AtomNode start="(375, 63)" end="(375, 64)" leading="" trailing="" val="("/>
              <NullNode start="(375, 64)" end="(375, 66)">
                <IdentNode start="(375, 64)" end="(375, 66)" leading="" trailing=" " raw_val="hk" val="hk"/>
              </NullNode>
              <NullNode start="(375, 67)" end="(375, 80)">
                <AtomNode start="(375, 67)" end="(375, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(375, 69)" end="(375, 80)" kind="«term_≤_»">
                  <IdentNode start="(375, 69)" end="(375, 76)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                  <AtomNode start="(375, 77)" end="(375, 78)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(375, 79)" end="(375, 80)" leading="" trailing="" raw_val="k" val="k"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(375, 80)" end="(375, 81)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(375, 82)" end="(375, 96)">
              <AtomNode start="(375, 82)" end="(375, 83)" leading="" trailing="" val="("/>
              <NullNode start="(375, 83)" end="(375, 85)">
                <IdentNode start="(375, 83)" end="(375, 85)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(375, 86)" end="(375, 95)">
                <AtomNode start="(375, 86)" end="(375, 87)" leading="" trailing=" " val=":"/>
                <OtherNode start="(375, 88)" end="(375, 95)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(375, 88)" end="(375, 93)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(375, 94)" end="(375, 95)">
                    <IdentNode start="(375, 94)" end="(375, 95)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(375, 95)" end="(375, 96)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(375, 97)" end="(375, 100)">
              <AtomNode start="(375, 97)" end="(375, 98)" leading="" trailing="" val="("/>
              <NullNode start="(375, 98)" end="(375, 99)">
                <IdentNode start="(375, 98)" end="(375, 99)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(375, 99)" end="(375, 100)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(375, 101)" end="(376, 82)">
            <AtomNode start="(375, 101)" end="(375, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(376, 5)" end="(376, 82)" kind="«term_=_»">
              <OtherNode start="(376, 5)" end="(376, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(376, 5)" end="(376, 13)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(376, 14)" end="(376, 26)">
                  <OtherNode start="(376, 14)" end="(376, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(376, 14)" end="(376, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(376, 15)" end="(376, 23)" kind="«term_++_»">
                      <IdentNode start="(376, 15)" end="(376, 17)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(376, 18)" end="(376, 20)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(376, 21)" end="(376, 23)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(376, 23)" end="(376, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(376, 25)" end="(376, 26)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(376, 27)" end="(376, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(376, 29)" end="(376, 82)" kind="«term_++_»">
                <IdentNode start="(376, 29)" end="(376, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <AtomNode start="(376, 32)" end="(376, 34)" leading="" trailing=" " val="++"/>
                <OtherNode start="(376, 35)" end="(376, 82)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(376, 35)" end="(376, 43)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  <NullNode start="(376, 44)" end="(376, 82)">
                    <IdentNode start="(376, 44)" end="(376, 46)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    <OtherNode start="(376, 47)" end="(376, 60)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(376, 47)" end="(376, 48)" leading="" trailing="" val="("/>
                      <OtherNode start="(376, 48)" end="(376, 59)" kind="«term_-_»">
                        <IdentNode start="(376, 48)" end="(376, 49)" leading="" trailing=" " raw_val="k" val="k"/>
                        <AtomNode start="(376, 50)" end="(376, 51)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(376, 52)" end="(376, 59)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                      </OtherNode>
                      <AtomNode start="(376, 59)" end="(376, 60)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(376, 61)" end="(376, 82)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(376, 61)" end="(376, 62)" leading="" trailing="" val="("/>
                      <TermBytacticNode start="(376, 62)" end="(376, 81)">
                        <AtomNode start="(376, 62)" end="(376, 64)" leading="" trailing=" " val="by"/>
                        <TacticTacticseqNode start="(376, 65)" end="(376, 81)">
                          <TacticTacticseq1IndentedNode start="(376, 65)" end="(376, 81)">
                            <NullNode start="(376, 65)" end="(376, 81)">
                              <OtherNode start="(376, 65)" end="(376, 74)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.56489&#10;xs : Array α&#10;k : Nat&#10;hk : xs.size ≤ k&#10;ys : Array α&#10;h : k &amp;lt; (xs ++ ys).size&#10;⊢ k - xs.size &amp;lt; ys.size" state_after="α : Type ?u.56489&#10;xs : Array α&#10;k : Nat&#10;hk : xs.size ≤ k&#10;ys : Array α&#10;h : k &amp;lt; xs.size + ys.size&#10;⊢ k - xs.size &amp;lt; ys.size" tactic="simp at h">
                                <AtomNode start="(376, 65)" end="(376, 69)" leading="" trailing=" " val="simp"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(376, 70)" end="(376, 74)">
                                  <OtherNode start="(376, 70)" end="(376, 74)" kind="Lean.Parser.Tactic.location">
                                    <AtomNode start="(376, 70)" end="(376, 72)" leading="" trailing=" " val="at"/>
                                    <OtherNode start="(376, 73)" end="(376, 74)" kind="Lean.Parser.Tactic.locationHyp">
                                      <NullNode start="(376, 73)" end="(376, 74)">
                                        <IdentNode start="(376, 73)" end="(376, 74)" leading="" trailing="" raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(376, 74)" end="(376, 75)" leading="" trailing=" " val=";"/>
                              <OtherNode start="(376, 76)" end="(376, 81)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.56489&#10;xs : Array α&#10;k : Nat&#10;hk : xs.size ≤ k&#10;ys : Array α&#10;h : k &amp;lt; xs.size + ys.size&#10;⊢ k - xs.size &amp;lt; ys.size" state_after="no goals" tactic="omega">
                                <AtomNode start="(376, 76)" end="(376, 81)" leading="" trailing="" val="omega"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </TermBytacticNode>
                      <AtomNode start="(376, 81)" end="(376, 82)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(376, 83)" end="(380, 46)">
          <AtomNode start="(376, 83)" end="(376, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(376, 86)" end="(380, 46)">
            <AtomNode start="(376, 86)" end="(376, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(377, 3)" end="(380, 46)">
              <TacticTacticseq1IndentedNode start="(377, 3)" end="(380, 46)">
                <NullNode start="(377, 3)" end="(380, 46)">
                  <OtherNode start="(377, 3)" end="(377, 21)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;k : Nat&#10;hk : xs.size ≤ k&#10;ys : Array α&#10;h : k &amp;lt; (xs ++ ys).size&#10;⊢ (xs ++ ys).eraseIdx k h = xs ++ ys.eraseIdx (k - xs.size) ⋯" state_after="case mk&#10;α : Type u_1&#10;k : Nat&#10;ys : Array α&#10;l : List α&#10;hk : { toList := l }.size ≤ k&#10;h : k &amp;lt; ({ toList := l } ++ ys).size&#10;⊢ ({ toList := l } ++ ys).eraseIdx k h = { toList := l } ++ ys.eraseIdx (k - { toList := l }.size) ⋯" tactic="rcases xs with ⟨l⟩">
                    <AtomNode start="(377, 3)" end="(377, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(377, 10)" end="(377, 12)">
                      <OtherNode start="(377, 10)" end="(377, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(377, 10)" end="(377, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(377, 13)" end="(377, 21)">
                      <AtomNode start="(377, 13)" end="(377, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(377, 18)" end="(377, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(377, 18)" end="(377, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(377, 18)" end="(377, 21)">
                            <OtherNode start="(377, 18)" end="(377, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(377, 18)" end="(377, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(377, 19)" end="(377, 20)">
                                <OtherNode start="(377, 19)" end="(377, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(377, 19)" end="(377, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(377, 19)" end="(377, 20)">
                                      <OtherNode start="(377, 19)" end="(377, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(377, 19)" end="(377, 20)" leading="" trailing="" raw_val="l" val="l"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(377, 20)" end="(377, 21)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(378, 3)" end="(378, 22)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;k : Nat&#10;ys : Array α&#10;l : List α&#10;hk : { toList := l }.size ≤ k&#10;h : k &amp;lt; ({ toList := l } ++ ys).size&#10;⊢ ({ toList := l } ++ ys).eraseIdx k h = { toList := l } ++ ys.eraseIdx (k - { toList := l }.size) ⋯" state_after="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk : { toList := l }.size ≤ k&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h =&#10;    { toList := l } ++ { toList := l' }.eraseIdx (k - { toList := l }.size) ⋯" tactic="rcases ys with ⟨l'⟩">
                    <AtomNode start="(378, 3)" end="(378, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(378, 10)" end="(378, 12)">
                      <OtherNode start="(378, 10)" end="(378, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(378, 10)" end="(378, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(378, 13)" end="(378, 22)">
                      <AtomNode start="(378, 13)" end="(378, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(378, 18)" end="(378, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(378, 18)" end="(378, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(378, 18)" end="(378, 22)">
                            <OtherNode start="(378, 18)" end="(378, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(378, 18)" end="(378, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(378, 19)" end="(378, 21)">
                                <OtherNode start="(378, 19)" end="(378, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(378, 19)" end="(378, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(378, 19)" end="(378, 21)">
                                      <OtherNode start="(378, 19)" end="(378, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(378, 19)" end="(378, 21)" leading="" trailing="" raw_val="l'" val="l'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(378, 21)" end="(378, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(379, 3)" end="(379, 13)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk : { toList := l }.size ≤ k&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h =&#10;    { toList := l } ++ { toList := l' }.eraseIdx (k - { toList := l }.size) ⋯" state_after="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk✝ : { toList := l }.size ≤ k&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;hk : l.length ≤ k&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h =&#10;    { toList := l } ++ { toList := l' }.eraseIdx (k - { toList := l }.size) ⋯" tactic="simp at hk">
                    <AtomNode start="(379, 3)" end="(379, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(379, 8)" end="(379, 13)">
                      <OtherNode start="(379, 8)" end="(379, 13)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(379, 8)" end="(379, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(379, 11)" end="(379, 13)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(379, 11)" end="(379, 13)">
                            <IdentNode start="(379, 11)" end="(379, 13)" leading="" trailing="&#10;  " raw_val="hk" val="hk"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(380, 3)" end="(380, 46)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;k : Nat&#10;l : List α&#10;hk✝ : { toList := l }.size ≤ k&#10;l' : List α&#10;h : k &amp;lt; ({ toList := l } ++ { toList := l' }).size&#10;hk : l.length ≤ k&#10;⊢ ({ toList := l } ++ { toList := l' }).eraseIdx k h =&#10;    { toList := l } ++ { toList := l' }.eraseIdx (k - { toList := l }.size) ⋯" state_after="no goals" tactic="simp [List.eraseIdx_append_of_length_le, *]">
                    <AtomNode start="(380, 3)" end="(380, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(380, 8)" end="(380, 46)">
                      <AtomNode start="(380, 8)" end="(380, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(380, 9)" end="(380, 45)">
                        <OtherNode start="(380, 9)" end="(380, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(380, 9)" end="(380, 42)" leading="" trailing="" raw_val="List.eraseIdx_append_of_length_le" val="List.eraseIdx_append_of_length_le" full_name="List.eraseIdx_append_of_length_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(380, 42)" end="(380, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(380, 44)" end="(380, 45)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(380, 44)" end="(380, 45)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(380, 45)" end="(380, 46)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(382, 1)" end="(386, 36)" name="eraseIdx_replicate" full_name="Array.eraseIdx_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(382, 1)" end="(386, 36)" name="eraseIdx_replicate" full_name="Array.eraseIdx_replicate" _is_private_decl="False">
        <AtomNode start="(382, 1)" end="(382, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(382, 9)" end="(382, 27)">
          <IdentNode start="(382, 9)" end="(382, 27)" leading="" trailing=" " raw_val="eraseIdx_replicate" val="eraseIdx_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(382, 28)" end="(383, 53)">
          <NullNode start="(382, 28)" end="(382, 59)">
            <OtherNode start="(382, 28)" end="(382, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(382, 28)" end="(382, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(382, 29)" end="(382, 30)">
                <IdentNode start="(382, 29)" end="(382, 30)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(382, 31)" end="(382, 36)">
                <AtomNode start="(382, 31)" end="(382, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(382, 33)" end="(382, 36)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(382, 36)" end="(382, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(382, 38)" end="(382, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(382, 38)" end="(382, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(382, 39)" end="(382, 40)">
                <IdentNode start="(382, 39)" end="(382, 40)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(382, 41)" end="(382, 44)">
                <AtomNode start="(382, 41)" end="(382, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(382, 43)" end="(382, 44)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(382, 44)" end="(382, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(382, 46)" end="(382, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(382, 46)" end="(382, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(382, 47)" end="(382, 48)">
                <IdentNode start="(382, 47)" end="(382, 48)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(382, 49)" end="(382, 54)">
                <AtomNode start="(382, 49)" end="(382, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(382, 51)" end="(382, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(382, 54)" end="(382, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(382, 56)" end="(382, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(382, 56)" end="(382, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(382, 57)" end="(382, 58)">
                <IdentNode start="(382, 57)" end="(382, 58)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(382, 58)" end="(382, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(382, 60)" end="(383, 53)">
            <AtomNode start="(382, 60)" end="(382, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(383, 5)" end="(383, 53)" kind="«term_=_»">
              <OtherNode start="(383, 5)" end="(383, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(383, 5)" end="(383, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(383, 5)" end="(383, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(383, 5)" end="(383, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(383, 6)" end="(383, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(383, 6)" end="(383, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                      <NullNode start="(383, 16)" end="(383, 19)">
                        <IdentNode start="(383, 16)" end="(383, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(383, 18)" end="(383, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(383, 19)" end="(383, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(383, 20)" end="(383, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(383, 21)" end="(383, 29)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(383, 30)" end="(383, 31)">
                  <IdentNode start="(383, 30)" end="(383, 31)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(383, 32)" end="(383, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(383, 34)" end="(383, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(383, 34)" end="(383, 43)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(383, 44)" end="(383, 53)">
                  <OtherNode start="(383, 44)" end="(383, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(383, 44)" end="(383, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(383, 45)" end="(383, 50)" kind="«term_-_»">
                      <IdentNode start="(383, 45)" end="(383, 46)" leading="" trailing=" " raw_val="n" val="n"/>
                      <AtomNode start="(383, 47)" end="(383, 48)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(383, 49)" end="(383, 50)" kind="num">
                        <AtomNode start="(383, 49)" end="(383, 50)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(383, 50)" end="(383, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(383, 52)" end="(383, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(383, 54)" end="(386, 36)">
          <AtomNode start="(383, 54)" end="(383, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(383, 57)" end="(386, 36)">
            <AtomNode start="(383, 57)" end="(383, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(384, 3)" end="(386, 36)">
              <TacticTacticseq1IndentedNode start="(384, 3)" end="(386, 36)">
                <NullNode start="(384, 3)" end="(386, 36)">
                  <OtherNode start="(384, 3)" end="(384, 12)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; (replicate n a).size&#10;⊢ (replicate n a).eraseIdx k h = replicate (n - 1) a" state_after="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h✝ : k &amp;lt; (replicate n a).size&#10;h : k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k h✝ = replicate (n - 1) a" tactic="simp at h">
                    <AtomNode start="(384, 3)" end="(384, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(384, 8)" end="(384, 12)">
                      <OtherNode start="(384, 8)" end="(384, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(384, 8)" end="(384, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(384, 11)" end="(384, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(384, 11)" end="(384, 12)">
                            <IdentNode start="(384, 11)" end="(384, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(385, 3)" end="(385, 62)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h✝ : k &amp;lt; (replicate n a).size&#10;h : k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k h✝ = replicate (n - 1) a" state_after="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h✝ : k &amp;lt; (replicate n a).size&#10;h : k &amp;lt; n&#10;⊢ ((List.replicate n a).eraseIdx k).toArray = (List.replicate (n - 1) a).toArray" tactic="simp only [← List.toArray_replicate, List.eraseIdx_toArray]">
                    <AtomNode start="(385, 3)" end="(385, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(385, 8)" end="(385, 12)">
                      <AtomNode start="(385, 8)" end="(385, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(385, 13)" end="(385, 62)">
                      <AtomNode start="(385, 13)" end="(385, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(385, 14)" end="(385, 61)">
                        <OtherNode start="(385, 14)" end="(385, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(385, 14)" end="(385, 15)">
                            <OtherNode start="(385, 14)" end="(385, 15)" kind="patternIgnore">
                              <OtherNode start="(385, 14)" end="(385, 15)" kind="token.«← »">
                                <AtomNode start="(385, 14)" end="(385, 15)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(385, 16)" end="(385, 38)" leading="" trailing="" raw_val="List.toArray_replicate" val="List.toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                        <AtomNode start="(385, 38)" end="(385, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(385, 40)" end="(385, 61)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(385, 40)" end="(385, 61)" leading="" trailing="" raw_val="List.eraseIdx_toArray" val="List.eraseIdx_toArray" full_name="List.eraseIdx_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(385, 61)" end="(385, 62)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(386, 3)" end="(386, 36)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h✝ : k &amp;lt; (replicate n a).size&#10;h : k &amp;lt; n&#10;⊢ ((List.replicate n a).eraseIdx k).toArray = (List.replicate (n - 1) a).toArray" state_after="no goals" tactic="simp [List.eraseIdx_replicate, h]">
                    <AtomNode start="(386, 3)" end="(386, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(386, 8)" end="(386, 36)">
                      <AtomNode start="(386, 8)" end="(386, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(386, 9)" end="(386, 35)">
                        <OtherNode start="(386, 9)" end="(386, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(386, 9)" end="(386, 32)" leading="" trailing="" raw_val="List.eraseIdx_replicate" val="List.eraseIdx_replicate" full_name="List.eraseIdx_replicate" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(386, 32)" end="(386, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(386, 34)" end="(386, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(386, 34)" end="(386, 35)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(386, 35)" end="(386, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(388, 1)" end="(389, 47)" name="eraseIdx_mkArray" full_name="Array.eraseIdx_mkArray">
      <CommandDeclmodifiersNode start="(388, 1)" end="(388, 57)">
        <NullNode/>
        <NullNode start="(388, 1)" end="(388, 57)">
          <OtherNode start="(388, 1)" end="(388, 57)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(388, 1)" end="(388, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(388, 3)" end="(388, 56)">
              <OtherNode start="(388, 3)" end="(388, 56)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(388, 3)" end="(388, 56)" kind="Lean.deprecated">
                  <AtomNode start="(388, 3)" end="(388, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(388, 14)" end="(388, 32)">
                    <IdentNode start="(388, 14)" end="(388, 32)" leading="" trailing=" " raw_val="eraseIdx_replicate" val="eraseIdx_replicate" full_name="Array.eraseIdx_replicate" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(382, 9)" def_end="(382, 27)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(388, 33)" end="(388, 56)">
                    <AtomNode start="(388, 33)" end="(388, 34)" leading="" trailing="" val="("/>
                    <AtomNode start="(388, 34)" end="(388, 39)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(388, 40)" end="(388, 42)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(388, 43)" end="(388, 55)" kind="str">
                      <AtomNode start="(388, 43)" end="(388, 55)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(388, 55)" end="(388, 56)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(388, 56)" end="(388, 57)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(389, 1)" end="(389, 47)" name="eraseIdx_mkArray">
        <AtomNode start="(389, 1)" end="(389, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(389, 8)" end="(389, 24)">
          <IdentNode start="(389, 8)" end="(389, 24)" leading="" trailing=" " raw_val="eraseIdx_mkArray" val="eraseIdx_mkArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(389, 25)" end="(389, 47)">
          <AtomNode start="(389, 25)" end="(389, 27)" leading="" trailing=" " val=":="/>
          <OtherNode start="(389, 28)" end="(389, 47)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(389, 28)" end="(389, 29)" leading="" trailing="" val="@"/>
            <IdentNode start="(389, 29)" end="(389, 47)" leading="" trailing="&#10;&#10;" raw_val="eraseIdx_replicate" val="eraseIdx_replicate" full_name="Array.eraseIdx_replicate" mod_name="Init.Data.Array.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Erase.lean" def_start="(382, 9)" def_end="(382, 27)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(391, 1)" end="(393, 42)" name="mem_eraseIdx_iff_getElem" full_name="Array.mem_eraseIdx_iff_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(391, 1)" end="(393, 42)" name="mem_eraseIdx_iff_getElem" full_name="Array.mem_eraseIdx_iff_getElem" _is_private_decl="False">
        <AtomNode start="(391, 1)" end="(391, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(391, 9)" end="(391, 33)">
          <IdentNode start="(391, 9)" end="(391, 33)" leading="" trailing=" " raw_val="mem_eraseIdx_iff_getElem" val="mem_eraseIdx_iff_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(391, 34)" end="(391, 115)">
          <NullNode start="(391, 34)" end="(391, 64)">
            <OtherNode start="(391, 34)" end="(391, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 34)" end="(391, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 35)" end="(391, 36)">
                <IdentNode start="(391, 35)" end="(391, 36)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(391, 37)" end="(391, 40)">
                <AtomNode start="(391, 37)" end="(391, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(391, 39)" end="(391, 40)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(391, 40)" end="(391, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(391, 42)" end="(391, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 42)" end="(391, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 43)" end="(391, 45)">
                <IdentNode start="(391, 43)" end="(391, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(391, 46)" end="(391, 55)">
                <AtomNode start="(391, 46)" end="(391, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(391, 48)" end="(391, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(391, 48)" end="(391, 53)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(391, 54)" end="(391, 55)">
                    <IdentNode start="(391, 54)" end="(391, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(391, 55)" end="(391, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(391, 57)" end="(391, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 57)" end="(391, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 58)" end="(391, 59)">
                <IdentNode start="(391, 58)" end="(391, 59)" leading="" trailing="" raw_val="k" val="k"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(391, 59)" end="(391, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(391, 61)" end="(391, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 61)" end="(391, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 62)" end="(391, 63)">
                <IdentNode start="(391, 62)" end="(391, 63)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(391, 63)" end="(391, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(391, 65)" end="(391, 115)">
            <AtomNode start="(391, 65)" end="(391, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(391, 67)" end="(391, 115)" kind="«term_↔_»">
              <OtherNode start="(391, 67)" end="(391, 86)" kind="«term_∈_»">
                <IdentNode start="(391, 67)" end="(391, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                <AtomNode start="(391, 69)" end="(391, 70)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(391, 71)" end="(391, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(391, 71)" end="(391, 82)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                  <NullNode start="(391, 83)" end="(391, 86)">
                    <IdentNode start="(391, 83)" end="(391, 84)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(391, 85)" end="(391, 86)" leading="" trailing=" " raw_val="h" val="h"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(391, 87)" end="(391, 88)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(391, 89)" end="(391, 115)" kind="«term∃_,_»">
                <AtomNode start="(391, 89)" end="(391, 90)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(391, 91)" end="(391, 94)" kind="Lean.explicitBinders">
                  <OtherNode start="(391, 91)" end="(391, 94)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(391, 91)" end="(391, 94)">
                      <LeanBinderidentNode start="(391, 91)" end="(391, 92)">
                        <IdentNode start="(391, 91)" end="(391, 92)" leading="" trailing=" " raw_val="i" val="i"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(391, 93)" end="(391, 94)">
                        <IdentNode start="(391, 93)" end="(391, 94)" leading="" trailing="" raw_val="w" val="w"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(391, 94)" end="(391, 95)" leading="" trailing=" " val=","/>
                <OtherNode start="(391, 96)" end="(391, 115)" kind="«term_∧_»">
                  <OtherNode start="(391, 96)" end="(391, 101)" kind="«term_≠_»">
                    <IdentNode start="(391, 96)" end="(391, 97)" leading="" trailing=" " raw_val="i" val="i"/>
                    <AtomNode start="(391, 98)" end="(391, 99)" leading="" trailing=" " val="≠"/>
                    <IdentNode start="(391, 100)" end="(391, 101)" leading="" trailing=" " raw_val="k" val="k"/>
                  </OtherNode>
                  <AtomNode start="(391, 102)" end="(391, 103)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(391, 104)" end="(391, 115)" kind="«term_=_»">
                    <OtherNode start="(391, 104)" end="(391, 111)" kind="«term__[_]'_»">
                      <IdentNode start="(391, 104)" end="(391, 106)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(391, 106)" end="(391, 107)" leading="" trailing="" val="["/>
                      <IdentNode start="(391, 107)" end="(391, 108)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(391, 108)" end="(391, 110)" leading="" trailing="" val="]'"/>
                      <IdentNode start="(391, 110)" end="(391, 111)" leading="" trailing=" " raw_val="w" val="w"/>
                    </OtherNode>
                    <AtomNode start="(391, 112)" end="(391, 113)" leading="" trailing=" " val="="/>
                    <IdentNode start="(391, 114)" end="(391, 115)" leading="" trailing=" " raw_val="x" val="x"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(391, 116)" end="(393, 42)">
          <AtomNode start="(391, 116)" end="(391, 118)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(391, 119)" end="(393, 42)">
            <AtomNode start="(391, 119)" end="(391, 121)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(392, 3)" end="(393, 42)">
              <TacticTacticseq1IndentedNode start="(392, 3)" end="(393, 42)">
                <NullNode start="(392, 3)" end="(393, 42)">
                  <OtherNode start="(392, 3)" end="(392, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;x : α&#10;xs : Array α&#10;k : Nat&#10;h : k &amp;lt; xs.size&#10;⊢ x ∈ xs.eraseIdx k h ↔ ∃ i w, i ≠ k ∧ xs[i] = x" state_after="case mk&#10;α : Type u_1&#10;x : α&#10;k : Nat&#10;xs : List α&#10;h : k &amp;lt; { toList := xs }.size&#10;⊢ x ∈ { toList := xs }.eraseIdx k h ↔ ∃ i w, i ≠ k ∧ { toList := xs }[i] = x" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(392, 3)" end="(392, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(392, 10)" end="(392, 12)">
                      <OtherNode start="(392, 10)" end="(392, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(392, 10)" end="(392, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(392, 13)" end="(392, 22)">
                      <AtomNode start="(392, 13)" end="(392, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(392, 18)" end="(392, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(392, 18)" end="(392, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(392, 18)" end="(392, 22)">
                            <OtherNode start="(392, 18)" end="(392, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(392, 18)" end="(392, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(392, 19)" end="(392, 21)">
                                <OtherNode start="(392, 19)" end="(392, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(392, 19)" end="(392, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(392, 19)" end="(392, 21)">
                                      <OtherNode start="(392, 19)" end="(392, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(392, 19)" end="(392, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(392, 21)" end="(392, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(393, 3)" end="(393, 42)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;x : α&#10;k : Nat&#10;xs : List α&#10;h : k &amp;lt; { toList := xs }.size&#10;⊢ x ∈ { toList := xs }.eraseIdx k h ↔ ∃ i w, i ≠ k ∧ { toList := xs }[i] = x" state_after="no goals" tactic="simp [List.mem_eraseIdx_iff_getElem, *]">
                    <AtomNode start="(393, 3)" end="(393, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(393, 8)" end="(393, 42)">
                      <AtomNode start="(393, 8)" end="(393, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(393, 9)" end="(393, 41)">
                        <OtherNode start="(393, 9)" end="(393, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(393, 9)" end="(393, 38)" leading="" trailing="" raw_val="List.mem_eraseIdx_iff_getElem" val="List.mem_eraseIdx_iff_getElem" full_name="List.mem_eraseIdx_iff_getElem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(393, 38)" end="(393, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(393, 40)" end="(393, 41)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(393, 40)" end="(393, 41)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(393, 41)" end="(393, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(395, 1)" end="(397, 43)" name="mem_eraseIdx_iff_getElem?" full_name="Array.mem_eraseIdx_iff_getElem?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(395, 1)" end="(397, 43)" name="mem_eraseIdx_iff_getElem?" full_name="Array.mem_eraseIdx_iff_getElem?" _is_private_decl="False">
        <AtomNode start="(395, 1)" end="(395, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(395, 9)" end="(395, 34)">
          <IdentNode start="(395, 9)" end="(395, 34)" leading="" trailing=" " raw_val="mem_eraseIdx_iff_getElem?" val="mem_eraseIdx_iff_getElem?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(395, 35)" end="(395, 114)">
          <NullNode start="(395, 35)" end="(395, 65)">
            <OtherNode start="(395, 35)" end="(395, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 35)" end="(395, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 36)" end="(395, 37)">
                <IdentNode start="(395, 36)" end="(395, 37)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(395, 38)" end="(395, 41)">
                <AtomNode start="(395, 38)" end="(395, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(395, 40)" end="(395, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(395, 41)" end="(395, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(395, 43)" end="(395, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 43)" end="(395, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 44)" end="(395, 46)">
                <IdentNode start="(395, 44)" end="(395, 46)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(395, 47)" end="(395, 56)">
                <AtomNode start="(395, 47)" end="(395, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(395, 49)" end="(395, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(395, 49)" end="(395, 54)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(395, 55)" end="(395, 56)">
                    <IdentNode start="(395, 55)" end="(395, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(395, 56)" end="(395, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(395, 58)" end="(395, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 58)" end="(395, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 59)" end="(395, 60)">
                <IdentNode start="(395, 59)" end="(395, 60)" leading="" trailing="" raw_val="k" val="k"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(395, 60)" end="(395, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(395, 62)" end="(395, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 62)" end="(395, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 63)" end="(395, 64)">
                <IdentNode start="(395, 63)" end="(395, 64)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(395, 64)" end="(395, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(395, 66)" end="(395, 114)">
            <AtomNode start="(395, 66)" end="(395, 67)" leading="" trailing=" " val=":"/>
            <OtherNode start="(395, 68)" end="(395, 114)" kind="«term_↔_»">
              <OtherNode start="(395, 68)" end="(395, 87)" kind="«term_∈_»">
                <IdentNode start="(395, 68)" end="(395, 69)" leading="" trailing=" " raw_val="x" val="x"/>
                <AtomNode start="(395, 70)" end="(395, 71)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(395, 72)" end="(395, 87)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(395, 72)" end="(395, 83)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                  <NullNode start="(395, 84)" end="(395, 87)">
                    <IdentNode start="(395, 84)" end="(395, 85)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(395, 86)" end="(395, 87)" leading="" trailing=" " raw_val="h" val="h"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(395, 88)" end="(395, 89)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(395, 90)" end="(395, 114)" kind="Lean.«term∃__,_»">
                <AtomNode start="(395, 90)" end="(395, 91)" leading="" trailing=" " val="∃"/>
                <LeanBinderidentNode start="(395, 92)" end="(395, 93)">
                  <IdentNode start="(395, 92)" end="(395, 93)" leading="" trailing=" " raw_val="i" val="i"/>
                </LeanBinderidentNode>
                <OtherNode start="(395, 94)" end="(395, 97)" kind="Lean.«binderTerm≠_»">
                  <AtomNode start="(395, 94)" end="(395, 95)" leading="" trailing=" " val="≠"/>
                  <IdentNode start="(395, 96)" end="(395, 97)" leading="" trailing="" raw_val="k" val="k"/>
                </OtherNode>
                <AtomNode start="(395, 97)" end="(395, 98)" leading="" trailing=" " val=","/>
                <OtherNode start="(395, 99)" end="(395, 114)" kind="«term_=_»">
                  <OtherNode start="(395, 99)" end="(395, 105)" kind="«term__[_]_?»">
                    <IdentNode start="(395, 99)" end="(395, 101)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <GroupNode/>
                    <AtomNode start="(395, 101)" end="(395, 102)" leading="" trailing="" val="["/>
                    <IdentNode start="(395, 102)" end="(395, 103)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(395, 103)" end="(395, 104)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(395, 104)" end="(395, 105)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(395, 106)" end="(395, 107)" leading="" trailing=" " val="="/>
                  <OtherNode start="(395, 108)" end="(395, 114)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(395, 108)" end="(395, 112)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(395, 113)" end="(395, 114)">
                      <IdentNode start="(395, 113)" end="(395, 114)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(395, 115)" end="(397, 43)">
          <AtomNode start="(395, 115)" end="(395, 117)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(395, 118)" end="(397, 43)">
            <AtomNode start="(395, 118)" end="(395, 120)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(396, 3)" end="(397, 43)">
              <TacticTacticseq1IndentedNode start="(396, 3)" end="(397, 43)">
                <NullNode start="(396, 3)" end="(397, 43)">
                  <OtherNode start="(396, 3)" end="(396, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;x : α&#10;xs : Array α&#10;k : Nat&#10;h : k &amp;lt; xs.size&#10;⊢ x ∈ xs.eraseIdx k h ↔ ∃ i, i ≠ k ∧ xs[i]? = some x" state_after="case mk&#10;α : Type u_1&#10;x : α&#10;k : Nat&#10;xs : List α&#10;h : k &amp;lt; { toList := xs }.size&#10;⊢ x ∈ { toList := xs }.eraseIdx k h ↔ ∃ i, i ≠ k ∧ { toList := xs }[i]? = some x" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(396, 3)" end="(396, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(396, 10)" end="(396, 12)">
                      <OtherNode start="(396, 10)" end="(396, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(396, 10)" end="(396, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(396, 13)" end="(396, 22)">
                      <AtomNode start="(396, 13)" end="(396, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(396, 18)" end="(396, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(396, 18)" end="(396, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(396, 18)" end="(396, 22)">
                            <OtherNode start="(396, 18)" end="(396, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(396, 18)" end="(396, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(396, 19)" end="(396, 21)">
                                <OtherNode start="(396, 19)" end="(396, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(396, 19)" end="(396, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(396, 19)" end="(396, 21)">
                                      <OtherNode start="(396, 19)" end="(396, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(396, 19)" end="(396, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(396, 21)" end="(396, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(397, 3)" end="(397, 43)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;x : α&#10;k : Nat&#10;xs : List α&#10;h : k &amp;lt; { toList := xs }.size&#10;⊢ x ∈ { toList := xs }.eraseIdx k h ↔ ∃ i, i ≠ k ∧ { toList := xs }[i]? = some x" state_after="no goals" tactic="simp [List.mem_eraseIdx_iff_getElem?, *]">
                    <AtomNode start="(397, 3)" end="(397, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(397, 8)" end="(397, 43)">
                      <AtomNode start="(397, 8)" end="(397, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(397, 9)" end="(397, 42)">
                        <OtherNode start="(397, 9)" end="(397, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(397, 9)" end="(397, 39)" leading="" trailing="" raw_val="List.mem_eraseIdx_iff_getElem?" val="List.mem_eraseIdx_iff_getElem?" full_name="List.mem_eraseIdx_iff_getElem?" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(397, 39)" end="(397, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(397, 41)" end="(397, 42)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(397, 41)" end="(397, 42)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(397, 42)" end="(397, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(399, 1)" end="(403, 44)" name="erase_eq_eraseIdx_of_idxOf" full_name="Array.erase_eq_eraseIdx_of_idxOf">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(399, 1)" end="(403, 44)" name="erase_eq_eraseIdx_of_idxOf" full_name="Array.erase_eq_eraseIdx_of_idxOf" _is_private_decl="False">
        <AtomNode start="(399, 1)" end="(399, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(399, 9)" end="(399, 35)">
          <IdentNode start="(399, 9)" end="(399, 35)" leading="" trailing=" " raw_val="erase_eq_eraseIdx_of_idxOf" val="erase_eq_eraseIdx_of_idxOf"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(399, 36)" end="(400, 31)">
          <NullNode start="(399, 36)" end="(399, 129)">
            <OtherNode start="(399, 36)" end="(399, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(399, 36)" end="(399, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(399, 37)" end="(399, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(399, 37)" end="(399, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(399, 41)" end="(399, 42)">
                  <IdentNode start="(399, 41)" end="(399, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(399, 42)" end="(399, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(399, 44)" end="(399, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(399, 44)" end="(399, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(399, 45)" end="(399, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(399, 45)" end="(399, 54)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(399, 55)" end="(399, 56)">
                  <IdentNode start="(399, 55)" end="(399, 56)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(399, 56)" end="(399, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(399, 58)" end="(399, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(399, 58)" end="(399, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(399, 59)" end="(399, 61)">
                <IdentNode start="(399, 59)" end="(399, 61)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(399, 62)" end="(399, 71)">
                <AtomNode start="(399, 62)" end="(399, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(399, 64)" end="(399, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(399, 64)" end="(399, 69)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(399, 70)" end="(399, 71)">
                    <IdentNode start="(399, 70)" end="(399, 71)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(399, 71)" end="(399, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(399, 73)" end="(399, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(399, 73)" end="(399, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(399, 74)" end="(399, 75)">
                <IdentNode start="(399, 74)" end="(399, 75)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(399, 76)" end="(399, 79)">
                <AtomNode start="(399, 76)" end="(399, 77)" leading="" trailing=" " val=":"/>
                <IdentNode start="(399, 78)" end="(399, 79)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(399, 79)" end="(399, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(399, 81)" end="(399, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(399, 81)" end="(399, 82)" leading="" trailing="" val="{"/>
              <NullNode start="(399, 82)" end="(399, 83)">
                <IdentNode start="(399, 82)" end="(399, 83)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(399, 84)" end="(399, 89)">
                <AtomNode start="(399, 84)" end="(399, 85)" leading="" trailing=" " val=":"/>
                <IdentNode start="(399, 86)" end="(399, 89)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(399, 89)" end="(399, 90)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(399, 91)" end="(399, 111)">
              <AtomNode start="(399, 91)" end="(399, 92)" leading="" trailing="" val="("/>
              <NullNode start="(399, 92)" end="(399, 93)">
                <IdentNode start="(399, 92)" end="(399, 93)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(399, 94)" end="(399, 110)">
                <AtomNode start="(399, 94)" end="(399, 95)" leading="" trailing=" " val=":"/>
                <OtherNode start="(399, 96)" end="(399, 110)" kind="«term_=_»">
                  <OtherNode start="(399, 96)" end="(399, 106)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(399, 96)" end="(399, 104)" leading="" trailing=" " raw_val="xs.idxOf" val="xs.idxOf"/>
                    <NullNode start="(399, 105)" end="(399, 106)">
                      <IdentNode start="(399, 105)" end="(399, 106)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(399, 107)" end="(399, 108)" leading="" trailing=" " val="="/>
                  <IdentNode start="(399, 109)" end="(399, 110)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(399, 110)" end="(399, 111)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(399, 112)" end="(399, 129)">
              <AtomNode start="(399, 112)" end="(399, 113)" leading="" trailing="" val="("/>
              <NullNode start="(399, 113)" end="(399, 114)">
                <IdentNode start="(399, 113)" end="(399, 114)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(399, 115)" end="(399, 128)">
                <AtomNode start="(399, 115)" end="(399, 116)" leading="" trailing=" " val=":"/>
                <OtherNode start="(399, 117)" end="(399, 128)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(399, 117)" end="(399, 118)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(399, 119)" end="(399, 120)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(399, 121)" end="(399, 128)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(399, 128)" end="(399, 129)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(399, 130)" end="(400, 31)">
            <AtomNode start="(399, 130)" end="(399, 131)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(400, 5)" end="(400, 31)" kind="«term_=_»">
              <OtherNode start="(400, 5)" end="(400, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(400, 5)" end="(400, 13)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                <NullNode start="(400, 14)" end="(400, 15)">
                  <IdentNode start="(400, 14)" end="(400, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(400, 16)" end="(400, 17)" leading="" trailing=" " val="="/>
              <OtherNode start="(400, 18)" end="(400, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(400, 18)" end="(400, 29)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                <NullNode start="(400, 30)" end="(400, 31)">
                  <IdentNode start="(400, 30)" end="(400, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(400, 32)" end="(403, 44)">
          <AtomNode start="(400, 32)" end="(400, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(400, 35)" end="(403, 44)">
            <AtomNode start="(400, 35)" end="(400, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(401, 3)" end="(403, 44)">
              <TacticTacticseq1IndentedNode start="(401, 3)" end="(403, 44)">
                <NullNode start="(401, 3)" end="(403, 44)">
                  <OtherNode start="(401, 3)" end="(401, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : Array α&#10;a : α&#10;i : Nat&#10;w : idxOf a xs = i&#10;h : i &amp;lt; xs.size&#10;⊢ xs.erase a = xs.eraseIdx i h" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;i : Nat&#10;xs : List α&#10;w : idxOf a { toList := xs } = i&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseIdx i h" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(401, 3)" end="(401, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(401, 10)" end="(401, 12)">
                      <OtherNode start="(401, 10)" end="(401, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(401, 10)" end="(401, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(401, 13)" end="(401, 22)">
                      <AtomNode start="(401, 13)" end="(401, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(401, 18)" end="(401, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(401, 18)" end="(401, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(401, 18)" end="(401, 22)">
                            <OtherNode start="(401, 18)" end="(401, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(401, 18)" end="(401, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(401, 19)" end="(401, 21)">
                                <OtherNode start="(401, 19)" end="(401, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(401, 19)" end="(401, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(401, 19)" end="(401, 21)">
                                      <OtherNode start="(401, 19)" end="(401, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(401, 19)" end="(401, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(401, 21)" end="(401, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(402, 3)" end="(402, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;i : Nat&#10;xs : List α&#10;w : idxOf a { toList := xs } = i&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseIdx i h" state_after="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;w : List.idxOf a xs = i&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseIdx i h" tactic="simp at w">
                    <AtomNode start="(402, 3)" end="(402, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(402, 8)" end="(402, 12)">
                      <OtherNode start="(402, 8)" end="(402, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(402, 8)" end="(402, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(402, 11)" end="(402, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(402, 11)" end="(402, 12)">
                            <IdentNode start="(402, 11)" end="(402, 12)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(403, 3)" end="(403, 44)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;i : Nat&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;w : List.idxOf a xs = i&#10;⊢ { toList := xs }.erase a = { toList := xs }.eraseIdx i h" state_after="no goals" tactic="simp [List.erase_eq_eraseIdx_of_idxOf, *]">
                    <AtomNode start="(403, 3)" end="(403, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(403, 8)" end="(403, 44)">
                      <AtomNode start="(403, 8)" end="(403, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(403, 9)" end="(403, 43)">
                        <OtherNode start="(403, 9)" end="(403, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(403, 9)" end="(403, 40)" leading="" trailing="" raw_val="List.erase_eq_eraseIdx_of_idxOf" val="List.erase_eq_eraseIdx_of_idxOf" full_name="List.erase_eq_eraseIdx_of_idxOf" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(403, 40)" end="(403, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(403, 42)" end="(403, 43)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(403, 42)" end="(403, 43)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(403, 43)" end="(403, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(405, 1)" end="(408, 40)" name="getElem_eraseIdx_of_lt" full_name="Array.getElem_eraseIdx_of_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(405, 1)" end="(408, 40)" name="getElem_eraseIdx_of_lt" full_name="Array.getElem_eraseIdx_of_lt" _is_private_decl="False">
        <AtomNode start="(405, 1)" end="(405, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(405, 9)" end="(405, 31)">
          <IdentNode start="(405, 9)" end="(405, 31)" leading="" trailing=" " raw_val="getElem_eraseIdx_of_lt" val="getElem_eraseIdx_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(405, 32)" end="(406, 31)">
          <NullNode start="(405, 32)" end="(405, 128)">
            <OtherNode start="(405, 32)" end="(405, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(405, 32)" end="(405, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(405, 33)" end="(405, 35)">
                <IdentNode start="(405, 33)" end="(405, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(405, 36)" end="(405, 45)">
                <AtomNode start="(405, 36)" end="(405, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(405, 38)" end="(405, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(405, 38)" end="(405, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(405, 44)" end="(405, 45)">
                    <IdentNode start="(405, 44)" end="(405, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(405, 45)" end="(405, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(405, 47)" end="(405, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(405, 47)" end="(405, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(405, 48)" end="(405, 49)">
                <IdentNode start="(405, 48)" end="(405, 49)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(405, 50)" end="(405, 55)">
                <AtomNode start="(405, 50)" end="(405, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(405, 52)" end="(405, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(405, 55)" end="(405, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(405, 57)" end="(405, 74)">
              <AtomNode start="(405, 57)" end="(405, 58)" leading="" trailing="" val="("/>
              <NullNode start="(405, 58)" end="(405, 59)">
                <IdentNode start="(405, 58)" end="(405, 59)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(405, 60)" end="(405, 73)">
                <AtomNode start="(405, 60)" end="(405, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(405, 62)" end="(405, 73)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(405, 62)" end="(405, 63)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(405, 64)" end="(405, 65)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(405, 66)" end="(405, 73)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(405, 73)" end="(405, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(405, 75)" end="(405, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(405, 75)" end="(405, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(405, 76)" end="(405, 77)">
                <IdentNode start="(405, 76)" end="(405, 77)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(405, 78)" end="(405, 83)">
                <AtomNode start="(405, 78)" end="(405, 79)" leading="" trailing=" " val=":"/>
                <IdentNode start="(405, 80)" end="(405, 83)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(405, 83)" end="(405, 84)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(405, 85)" end="(405, 115)">
              <AtomNode start="(405, 85)" end="(405, 86)" leading="" trailing="" val="("/>
              <NullNode start="(405, 86)" end="(405, 87)">
                <IdentNode start="(405, 86)" end="(405, 87)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(405, 88)" end="(405, 114)">
                <AtomNode start="(405, 88)" end="(405, 89)" leading="" trailing=" " val=":"/>
                <OtherNode start="(405, 90)" end="(405, 114)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(405, 90)" end="(405, 91)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(405, 92)" end="(405, 93)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(405, 94)" end="(405, 114)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(405, 94)" end="(405, 109)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(405, 94)" end="(405, 95)" leading="" trailing="" val="("/>
                      <OtherNode start="(405, 95)" end="(405, 108)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(405, 95)" end="(405, 106)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                        <NullNode start="(405, 107)" end="(405, 108)">
                          <IdentNode start="(405, 107)" end="(405, 108)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(405, 108)" end="(405, 109)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(405, 109)" end="(405, 110)" leading="" trailing="" val="."/>
                    <IdentNode start="(405, 110)" end="(405, 114)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(405, 114)" end="(405, 115)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(405, 116)" end="(405, 128)">
              <AtomNode start="(405, 116)" end="(405, 117)" leading="" trailing="" val="("/>
              <NullNode start="(405, 117)" end="(405, 119)">
                <IdentNode start="(405, 117)" end="(405, 119)" leading="" trailing=" " raw_val="h'" val="h'"/>
              </NullNode>
              <NullNode start="(405, 120)" end="(405, 127)">
                <AtomNode start="(405, 120)" end="(405, 121)" leading="" trailing=" " val=":"/>
                <OtherNode start="(405, 122)" end="(405, 127)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(405, 122)" end="(405, 123)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(405, 124)" end="(405, 125)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(405, 126)" end="(405, 127)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(405, 127)" end="(405, 128)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(405, 129)" end="(406, 31)">
            <AtomNode start="(405, 129)" end="(405, 130)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(406, 5)" end="(406, 31)" kind="«term_=_»">
              <OtherNode start="(406, 5)" end="(406, 23)" kind="«term__[_]»">
                <OtherNode start="(406, 5)" end="(406, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(406, 5)" end="(406, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(406, 6)" end="(406, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(406, 6)" end="(406, 17)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                    <NullNode start="(406, 18)" end="(406, 19)">
                      <IdentNode start="(406, 18)" end="(406, 19)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(406, 19)" end="(406, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(406, 20)" end="(406, 21)" leading="" trailing="" val="["/>
                <IdentNode start="(406, 21)" end="(406, 22)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(406, 22)" end="(406, 23)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(406, 24)" end="(406, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(406, 26)" end="(406, 31)" kind="«term__[_]»">
                <IdentNode start="(406, 26)" end="(406, 28)" leading="" trailing="" raw_val="xs" val="xs"/>
                <AtomNode start="(406, 28)" end="(406, 29)" leading="" trailing="" val="["/>
                <IdentNode start="(406, 29)" end="(406, 30)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(406, 30)" end="(406, 31)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(406, 32)" end="(408, 40)">
          <AtomNode start="(406, 32)" end="(406, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(406, 35)" end="(408, 40)">
            <AtomNode start="(406, 35)" end="(406, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(407, 3)" end="(408, 40)">
              <TacticTacticseq1IndentedNode start="(407, 3)" end="(408, 40)">
                <NullNode start="(407, 3)" end="(408, 40)">
                  <OtherNode start="(407, 3)" end="(407, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;h : j &amp;lt; (xs.eraseIdx i w).size&#10;h' : j &amp;lt; i&#10;⊢ (xs.eraseIdx i w)[j] = xs[j]" state_after="case mk&#10;α : Type u_1&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;xs : List α&#10;w : i &amp;lt; { toList := xs }.size&#10;h : j &amp;lt; ({ toList := xs }.eraseIdx i w).size&#10;⊢ ({ toList := xs }.eraseIdx i w)[j] = { toList := xs }[j]" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(407, 3)" end="(407, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(407, 10)" end="(407, 12)">
                      <OtherNode start="(407, 10)" end="(407, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(407, 10)" end="(407, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(407, 13)" end="(407, 22)">
                      <AtomNode start="(407, 13)" end="(407, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(407, 18)" end="(407, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(407, 18)" end="(407, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(407, 18)" end="(407, 22)">
                            <OtherNode start="(407, 18)" end="(407, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(407, 18)" end="(407, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(407, 19)" end="(407, 21)">
                                <OtherNode start="(407, 19)" end="(407, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(407, 19)" end="(407, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(407, 19)" end="(407, 21)">
                                      <OtherNode start="(407, 19)" end="(407, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(407, 19)" end="(407, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(407, 21)" end="(407, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(408, 3)" end="(408, 40)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;xs : List α&#10;w : i &amp;lt; { toList := xs }.size&#10;h : j &amp;lt; ({ toList := xs }.eraseIdx i w).size&#10;⊢ ({ toList := xs }.eraseIdx i w)[j] = { toList := xs }[j]" state_after="no goals" tactic="simp [List.getElem_eraseIdx_of_lt, *]">
                    <AtomNode start="(408, 3)" end="(408, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(408, 8)" end="(408, 40)">
                      <AtomNode start="(408, 8)" end="(408, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(408, 9)" end="(408, 39)">
                        <OtherNode start="(408, 9)" end="(408, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(408, 9)" end="(408, 36)" leading="" trailing="" raw_val="List.getElem_eraseIdx_of_lt" val="List.getElem_eraseIdx_of_lt" full_name="List.getElem_eraseIdx_of_lt" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(408, 36)" end="(408, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(408, 38)" end="(408, 39)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(408, 38)" end="(408, 39)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(408, 39)" end="(408, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(410, 1)" end="(413, 40)" name="getElem_eraseIdx_of_ge" full_name="Array.getElem_eraseIdx_of_ge">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(410, 1)" end="(413, 40)" name="getElem_eraseIdx_of_ge" full_name="Array.getElem_eraseIdx_of_ge" _is_private_decl="False">
        <AtomNode start="(410, 1)" end="(410, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(410, 9)" end="(410, 31)">
          <IdentNode start="(410, 9)" end="(410, 31)" leading="" trailing=" " raw_val="getElem_eraseIdx_of_ge" val="getElem_eraseIdx_of_ge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(410, 32)" end="(411, 57)">
          <NullNode start="(410, 32)" end="(410, 128)">
            <OtherNode start="(410, 32)" end="(410, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(410, 32)" end="(410, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(410, 33)" end="(410, 35)">
                <IdentNode start="(410, 33)" end="(410, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(410, 36)" end="(410, 45)">
                <AtomNode start="(410, 36)" end="(410, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(410, 38)" end="(410, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(410, 38)" end="(410, 43)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(410, 44)" end="(410, 45)">
                    <IdentNode start="(410, 44)" end="(410, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(410, 45)" end="(410, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(410, 47)" end="(410, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(410, 47)" end="(410, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(410, 48)" end="(410, 49)">
                <IdentNode start="(410, 48)" end="(410, 49)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(410, 50)" end="(410, 55)">
                <AtomNode start="(410, 50)" end="(410, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(410, 52)" end="(410, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(410, 55)" end="(410, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(410, 57)" end="(410, 74)">
              <AtomNode start="(410, 57)" end="(410, 58)" leading="" trailing="" val="("/>
              <NullNode start="(410, 58)" end="(410, 59)">
                <IdentNode start="(410, 58)" end="(410, 59)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(410, 60)" end="(410, 73)">
                <AtomNode start="(410, 60)" end="(410, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(410, 62)" end="(410, 73)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(410, 62)" end="(410, 63)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(410, 64)" end="(410, 65)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(410, 66)" end="(410, 73)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(410, 73)" end="(410, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(410, 75)" end="(410, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(410, 75)" end="(410, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(410, 76)" end="(410, 77)">
                <IdentNode start="(410, 76)" end="(410, 77)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(410, 78)" end="(410, 83)">
                <AtomNode start="(410, 78)" end="(410, 79)" leading="" trailing=" " val=":"/>
                <IdentNode start="(410, 80)" end="(410, 83)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(410, 83)" end="(410, 84)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(410, 85)" end="(410, 115)">
              <AtomNode start="(410, 85)" end="(410, 86)" leading="" trailing="" val="("/>
              <NullNode start="(410, 86)" end="(410, 87)">
                <IdentNode start="(410, 86)" end="(410, 87)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(410, 88)" end="(410, 114)">
                <AtomNode start="(410, 88)" end="(410, 89)" leading="" trailing=" " val=":"/>
                <OtherNode start="(410, 90)" end="(410, 114)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(410, 90)" end="(410, 91)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(410, 92)" end="(410, 93)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(410, 94)" end="(410, 114)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(410, 94)" end="(410, 109)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(410, 94)" end="(410, 95)" leading="" trailing="" val="("/>
                      <OtherNode start="(410, 95)" end="(410, 108)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(410, 95)" end="(410, 106)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                        <NullNode start="(410, 107)" end="(410, 108)">
                          <IdentNode start="(410, 107)" end="(410, 108)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(410, 108)" end="(410, 109)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(410, 109)" end="(410, 110)" leading="" trailing="" val="."/>
                    <IdentNode start="(410, 110)" end="(410, 114)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(410, 114)" end="(410, 115)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(410, 116)" end="(410, 128)">
              <AtomNode start="(410, 116)" end="(410, 117)" leading="" trailing="" val="("/>
              <NullNode start="(410, 117)" end="(410, 119)">
                <IdentNode start="(410, 117)" end="(410, 119)" leading="" trailing=" " raw_val="h'" val="h'"/>
              </NullNode>
              <NullNode start="(410, 120)" end="(410, 127)">
                <AtomNode start="(410, 120)" end="(410, 121)" leading="" trailing=" " val=":"/>
                <OtherNode start="(410, 122)" end="(410, 127)" kind="«term_≤_»">
                  <IdentNode start="(410, 122)" end="(410, 123)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(410, 124)" end="(410, 125)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(410, 126)" end="(410, 127)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(410, 127)" end="(410, 128)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(410, 129)" end="(411, 57)">
            <AtomNode start="(410, 129)" end="(410, 130)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(411, 5)" end="(411, 57)" kind="«term_=_»">
              <OtherNode start="(411, 5)" end="(411, 23)" kind="«term__[_]»">
                <OtherNode start="(411, 5)" end="(411, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(411, 5)" end="(411, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(411, 6)" end="(411, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(411, 6)" end="(411, 17)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                    <NullNode start="(411, 18)" end="(411, 19)">
                      <IdentNode start="(411, 18)" end="(411, 19)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(411, 19)" end="(411, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(411, 20)" end="(411, 21)" leading="" trailing="" val="["/>
                <IdentNode start="(411, 21)" end="(411, 22)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(411, 22)" end="(411, 23)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(411, 24)" end="(411, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(411, 26)" end="(411, 57)" kind="«term__[_]'_»">
                <IdentNode start="(411, 26)" end="(411, 28)" leading="" trailing="" raw_val="xs" val="xs"/>
                <AtomNode start="(411, 28)" end="(411, 29)" leading="" trailing="" val="["/>
                <OtherNode start="(411, 29)" end="(411, 34)" kind="«term_+_»">
                  <IdentNode start="(411, 29)" end="(411, 30)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(411, 31)" end="(411, 32)" leading="" trailing=" " val="+"/>
                  <OtherNode start="(411, 33)" end="(411, 34)" kind="num">
                    <AtomNode start="(411, 33)" end="(411, 34)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(411, 34)" end="(411, 36)" leading="" trailing="" val="]'"/>
                <OtherNode start="(411, 36)" end="(411, 57)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(411, 36)" end="(411, 37)" leading="" trailing="" val="("/>
                  <TermBytacticNode start="(411, 37)" end="(411, 56)">
                    <AtomNode start="(411, 37)" end="(411, 39)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(411, 40)" end="(411, 56)">
                      <TacticTacticseq1IndentedNode start="(411, 40)" end="(411, 56)">
                        <NullNode start="(411, 40)" end="(411, 56)">
                          <OtherNode start="(411, 40)" end="(411, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.64019&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;h : j &amp;lt; (xs.eraseIdx i w).size&#10;h' : i ≤ j&#10;⊢ j + 1 &amp;lt; xs.size" state_after="α : Type ?u.64019&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;h' : i ≤ j&#10;h : j &amp;lt; xs.size - 1&#10;⊢ j + 1 &amp;lt; xs.size" tactic="simp at h">
                            <AtomNode start="(411, 40)" end="(411, 44)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(411, 45)" end="(411, 49)">
                              <OtherNode start="(411, 45)" end="(411, 49)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(411, 45)" end="(411, 47)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(411, 48)" end="(411, 49)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(411, 48)" end="(411, 49)">
                                    <IdentNode start="(411, 48)" end="(411, 49)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(411, 49)" end="(411, 50)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(411, 51)" end="(411, 56)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.64019&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;h' : i ≤ j&#10;h : j &amp;lt; xs.size - 1&#10;⊢ j + 1 &amp;lt; xs.size" state_after="no goals" tactic="omega">
                            <AtomNode start="(411, 51)" end="(411, 56)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                  <AtomNode start="(411, 56)" end="(411, 57)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(411, 58)" end="(413, 40)">
          <AtomNode start="(411, 58)" end="(411, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(411, 61)" end="(413, 40)">
            <AtomNode start="(411, 61)" end="(411, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(412, 3)" end="(413, 40)">
              <TacticTacticseq1IndentedNode start="(412, 3)" end="(413, 40)">
                <NullNode start="(412, 3)" end="(413, 40)">
                  <OtherNode start="(412, 3)" end="(412, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;h : j &amp;lt; (xs.eraseIdx i w).size&#10;h' : i ≤ j&#10;⊢ (xs.eraseIdx i w)[j] = xs[j + 1]" state_after="case mk&#10;α : Type u_1&#10;i j : Nat&#10;h' : i ≤ j&#10;xs : List α&#10;w : i &amp;lt; { toList := xs }.size&#10;h : j &amp;lt; ({ toList := xs }.eraseIdx i w).size&#10;⊢ ({ toList := xs }.eraseIdx i w)[j] = { toList := xs }[j + 1]" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(412, 3)" end="(412, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(412, 10)" end="(412, 12)">
                      <OtherNode start="(412, 10)" end="(412, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(412, 10)" end="(412, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(412, 13)" end="(412, 22)">
                      <AtomNode start="(412, 13)" end="(412, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(412, 18)" end="(412, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(412, 18)" end="(412, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(412, 18)" end="(412, 22)">
                            <OtherNode start="(412, 18)" end="(412, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(412, 18)" end="(412, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(412, 19)" end="(412, 21)">
                                <OtherNode start="(412, 19)" end="(412, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(412, 19)" end="(412, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(412, 19)" end="(412, 21)">
                                      <OtherNode start="(412, 19)" end="(412, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(412, 19)" end="(412, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(412, 21)" end="(412, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(413, 3)" end="(413, 40)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i j : Nat&#10;h' : i ≤ j&#10;xs : List α&#10;w : i &amp;lt; { toList := xs }.size&#10;h : j &amp;lt; ({ toList := xs }.eraseIdx i w).size&#10;⊢ ({ toList := xs }.eraseIdx i w)[j] = { toList := xs }[j + 1]" state_after="no goals" tactic="simp [List.getElem_eraseIdx_of_ge, *]">
                    <AtomNode start="(413, 3)" end="(413, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(413, 8)" end="(413, 40)">
                      <AtomNode start="(413, 8)" end="(413, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(413, 9)" end="(413, 39)">
                        <OtherNode start="(413, 9)" end="(413, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(413, 9)" end="(413, 36)" leading="" trailing="" raw_val="List.getElem_eraseIdx_of_ge" val="List.getElem_eraseIdx_of_ge" full_name="List.getElem_eraseIdx_of_ge" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(413, 36)" end="(413, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(413, 38)" end="(413, 39)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(413, 38)" end="(413, 39)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(413, 39)" end="(413, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(415, 1)" end="(418, 33)" name="eraseIdx_set_eq" full_name="Array.eraseIdx_set_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(415, 1)" end="(418, 33)" name="eraseIdx_set_eq" full_name="Array.eraseIdx_set_eq" _is_private_decl="False">
        <AtomNode start="(415, 1)" end="(415, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(415, 9)" end="(415, 24)">
          <IdentNode start="(415, 9)" end="(415, 24)" leading="" trailing=" " raw_val="eraseIdx_set_eq" val="eraseIdx_set_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(415, 25)" end="(416, 61)">
          <NullNode start="(415, 25)" end="(415, 75)">
            <OtherNode start="(415, 25)" end="(415, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(415, 25)" end="(415, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(415, 26)" end="(415, 28)">
                <IdentNode start="(415, 26)" end="(415, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(415, 29)" end="(415, 38)">
                <AtomNode start="(415, 29)" end="(415, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(415, 31)" end="(415, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(415, 31)" end="(415, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(415, 37)" end="(415, 38)">
                    <IdentNode start="(415, 37)" end="(415, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(415, 38)" end="(415, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(415, 40)" end="(415, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(415, 40)" end="(415, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(415, 41)" end="(415, 42)">
                <IdentNode start="(415, 41)" end="(415, 42)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(415, 43)" end="(415, 48)">
                <AtomNode start="(415, 43)" end="(415, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(415, 45)" end="(415, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(415, 48)" end="(415, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(415, 50)" end="(415, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(415, 50)" end="(415, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(415, 51)" end="(415, 52)">
                <IdentNode start="(415, 51)" end="(415, 52)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(415, 53)" end="(415, 56)">
                <AtomNode start="(415, 53)" end="(415, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(415, 55)" end="(415, 56)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(415, 56)" end="(415, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(415, 58)" end="(415, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(415, 58)" end="(415, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(415, 59)" end="(415, 60)">
                <IdentNode start="(415, 59)" end="(415, 60)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(415, 61)" end="(415, 74)">
                <AtomNode start="(415, 61)" end="(415, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(415, 63)" end="(415, 74)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(415, 63)" end="(415, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(415, 65)" end="(415, 66)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(415, 67)" end="(415, 74)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(415, 74)" end="(415, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(415, 76)" end="(416, 61)">
            <AtomNode start="(415, 76)" end="(415, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(416, 5)" end="(416, 61)" kind="«term_=_»">
              <OtherNode start="(416, 5)" end="(416, 45)" kind="Lean.Parser.Term.app">
                <OtherNode start="(416, 5)" end="(416, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(416, 5)" end="(416, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(416, 5)" end="(416, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(416, 6)" end="(416, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(416, 6)" end="(416, 12)" leading="" trailing=" " raw_val="xs.set" val="xs.set"/>
                      <NullNode start="(416, 13)" end="(416, 16)">
                        <IdentNode start="(416, 13)" end="(416, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(416, 15)" end="(416, 16)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(416, 16)" end="(416, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(416, 17)" end="(416, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(416, 18)" end="(416, 26)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(416, 27)" end="(416, 45)">
                  <IdentNode start="(416, 27)" end="(416, 28)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(416, 29)" end="(416, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(416, 29)" end="(416, 30)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(416, 30)" end="(416, 44)">
                      <AtomNode start="(416, 30)" end="(416, 32)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(416, 33)" end="(416, 44)">
                        <TacticTacticseq1IndentedNode start="(416, 33)" end="(416, 44)">
                          <NullNode start="(416, 33)" end="(416, 44)">
                            <OtherNode start="(416, 33)" end="(416, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.65010&#10;xs : Array α&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; xs.size&#10;⊢ i &amp;lt; (xs.set i a h).size" state_after="α : Type ?u.65010&#10;xs : Array α&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; xs.size&#10;⊢ i &amp;lt; xs.size" tactic="simp">
                              <AtomNode start="(416, 33)" end="(416, 37)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(416, 37)" end="(416, 38)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(416, 39)" end="(416, 44)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.65010&#10;xs : Array α&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; xs.size&#10;⊢ i &amp;lt; xs.size" state_after="no goals" tactic="omega">
                              <AtomNode start="(416, 39)" end="(416, 44)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(416, 44)" end="(416, 45)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(416, 46)" end="(416, 47)" leading="" trailing=" " val="="/>
              <OtherNode start="(416, 48)" end="(416, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(416, 48)" end="(416, 59)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                <NullNode start="(416, 60)" end="(416, 61)">
                  <IdentNode start="(416, 60)" end="(416, 61)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(416, 62)" end="(418, 33)">
          <AtomNode start="(416, 62)" end="(416, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(416, 65)" end="(418, 33)">
            <AtomNode start="(416, 65)" end="(416, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(417, 3)" end="(418, 33)">
              <TacticTacticseq1IndentedNode start="(417, 3)" end="(418, 33)">
                <NullNode start="(417, 3)" end="(418, 33)">
                  <OtherNode start="(417, 3)" end="(417, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; xs.size&#10;⊢ (xs.set i a h).eraseIdx i ⋯ = xs.eraseIdx i h" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.set i a h).eraseIdx i ⋯ = { toList := xs }.eraseIdx i h" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(417, 3)" end="(417, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(417, 10)" end="(417, 12)">
                      <OtherNode start="(417, 10)" end="(417, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(417, 10)" end="(417, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(417, 13)" end="(417, 22)">
                      <AtomNode start="(417, 13)" end="(417, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(417, 18)" end="(417, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(417, 18)" end="(417, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(417, 18)" end="(417, 22)">
                            <OtherNode start="(417, 18)" end="(417, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(417, 18)" end="(417, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(417, 19)" end="(417, 21)">
                                <OtherNode start="(417, 19)" end="(417, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(417, 19)" end="(417, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(417, 19)" end="(417, 21)">
                                      <OtherNode start="(417, 19)" end="(417, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(417, 19)" end="(417, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(417, 21)" end="(417, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(418, 3)" end="(418, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;a : α&#10;xs : List α&#10;h : i &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.set i a h).eraseIdx i ⋯ = { toList := xs }.eraseIdx i h" state_after="no goals" tactic="simp [List.eraseIdx_set_eq, *]">
                    <AtomNode start="(418, 3)" end="(418, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(418, 8)" end="(418, 33)">
                      <AtomNode start="(418, 8)" end="(418, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(418, 9)" end="(418, 32)">
                        <OtherNode start="(418, 9)" end="(418, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(418, 9)" end="(418, 29)" leading="" trailing="" raw_val="List.eraseIdx_set_eq" val="List.eraseIdx_set_eq" full_name="List.eraseIdx_set_eq" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(418, 29)" end="(418, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(418, 31)" end="(418, 32)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(418, 31)" end="(418, 32)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(418, 32)" end="(418, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(420, 1)" end="(423, 33)" name="eraseIdx_set_lt" full_name="Array.eraseIdx_set_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(420, 1)" end="(423, 33)" name="eraseIdx_set_lt" full_name="Array.eraseIdx_set_lt" _is_private_decl="False">
        <AtomNode start="(420, 1)" end="(420, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(420, 9)" end="(420, 24)">
          <IdentNode start="(420, 9)" end="(420, 24)" leading="" trailing=" " raw_val="eraseIdx_set_lt" val="eraseIdx_set_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(420, 25)" end="(421, 94)">
          <NullNode start="(420, 25)" end="(420, 97)">
            <OtherNode start="(420, 25)" end="(420, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(420, 25)" end="(420, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(420, 26)" end="(420, 28)">
                <IdentNode start="(420, 26)" end="(420, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(420, 29)" end="(420, 38)">
                <AtomNode start="(420, 29)" end="(420, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(420, 31)" end="(420, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(420, 31)" end="(420, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(420, 37)" end="(420, 38)">
                    <IdentNode start="(420, 37)" end="(420, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(420, 38)" end="(420, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(420, 40)" end="(420, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(420, 40)" end="(420, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(420, 41)" end="(420, 42)">
                <IdentNode start="(420, 41)" end="(420, 42)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(420, 43)" end="(420, 48)">
                <AtomNode start="(420, 43)" end="(420, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(420, 45)" end="(420, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(420, 48)" end="(420, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(420, 50)" end="(420, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(420, 50)" end="(420, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(420, 51)" end="(420, 52)">
                <IdentNode start="(420, 51)" end="(420, 52)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(420, 53)" end="(420, 66)">
                <AtomNode start="(420, 53)" end="(420, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(420, 55)" end="(420, 66)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(420, 55)" end="(420, 56)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(420, 57)" end="(420, 58)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(420, 59)" end="(420, 66)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(420, 66)" end="(420, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(420, 68)" end="(420, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(420, 68)" end="(420, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(420, 69)" end="(420, 70)">
                <IdentNode start="(420, 69)" end="(420, 70)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(420, 71)" end="(420, 76)">
                <AtomNode start="(420, 71)" end="(420, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(420, 73)" end="(420, 76)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(420, 76)" end="(420, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(420, 78)" end="(420, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(420, 78)" end="(420, 79)" leading="" trailing="" val="{"/>
              <NullNode start="(420, 79)" end="(420, 80)">
                <IdentNode start="(420, 79)" end="(420, 80)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(420, 81)" end="(420, 84)">
                <AtomNode start="(420, 81)" end="(420, 82)" leading="" trailing=" " val=":"/>
                <IdentNode start="(420, 83)" end="(420, 84)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(420, 84)" end="(420, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(420, 86)" end="(420, 97)">
              <AtomNode start="(420, 86)" end="(420, 87)" leading="" trailing="" val="("/>
              <NullNode start="(420, 87)" end="(420, 88)">
                <IdentNode start="(420, 87)" end="(420, 88)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(420, 89)" end="(420, 96)">
                <AtomNode start="(420, 89)" end="(420, 90)" leading="" trailing=" " val=":"/>
                <OtherNode start="(420, 91)" end="(420, 96)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(420, 91)" end="(420, 92)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(420, 93)" end="(420, 94)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(420, 95)" end="(420, 96)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(420, 96)" end="(420, 97)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(420, 98)" end="(421, 94)">
            <AtomNode start="(420, 98)" end="(420, 99)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(421, 5)" end="(421, 94)" kind="«term_=_»">
              <OtherNode start="(421, 5)" end="(421, 45)" kind="Lean.Parser.Term.app">
                <OtherNode start="(421, 5)" end="(421, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(421, 5)" end="(421, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(421, 5)" end="(421, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(421, 6)" end="(421, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(421, 6)" end="(421, 12)" leading="" trailing=" " raw_val="xs.set" val="xs.set"/>
                      <NullNode start="(421, 13)" end="(421, 16)">
                        <IdentNode start="(421, 13)" end="(421, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(421, 15)" end="(421, 16)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(421, 16)" end="(421, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(421, 17)" end="(421, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(421, 18)" end="(421, 26)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(421, 27)" end="(421, 45)">
                  <IdentNode start="(421, 27)" end="(421, 28)" leading="" trailing=" " raw_val="j" val="j"/>
                  <OtherNode start="(421, 29)" end="(421, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(421, 29)" end="(421, 30)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(421, 30)" end="(421, 44)">
                      <AtomNode start="(421, 30)" end="(421, 32)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(421, 33)" end="(421, 44)">
                        <TacticTacticseq1IndentedNode start="(421, 33)" end="(421, 44)">
                          <NullNode start="(421, 33)" end="(421, 44)">
                            <OtherNode start="(421, 33)" end="(421, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.65425&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ j &amp;lt; (xs.set i a w).size" state_after="α : Type ?u.65425&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ j &amp;lt; xs.size" tactic="simp">
                              <AtomNode start="(421, 33)" end="(421, 37)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(421, 37)" end="(421, 38)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(421, 39)" end="(421, 44)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.65425&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ j &amp;lt; xs.size" state_after="no goals" tactic="omega">
                              <AtomNode start="(421, 39)" end="(421, 44)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(421, 44)" end="(421, 45)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(421, 46)" end="(421, 47)" leading="" trailing=" " val="="/>
              <OtherNode start="(421, 48)" end="(421, 94)" kind="Lean.Parser.Term.app">
                <OtherNode start="(421, 48)" end="(421, 67)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(421, 48)" end="(421, 63)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(421, 48)" end="(421, 49)" leading="" trailing="" val="("/>
                    <OtherNode start="(421, 49)" end="(421, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(421, 49)" end="(421, 60)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                      <NullNode start="(421, 61)" end="(421, 62)">
                        <IdentNode start="(421, 61)" end="(421, 62)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(421, 62)" end="(421, 63)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(421, 63)" end="(421, 64)" leading="" trailing="" val="."/>
                  <IdentNode start="(421, 64)" end="(421, 67)" leading="" trailing=" " raw_val="set" val="set" full_name="Array.set" mod_name="Init.Data.Array.Set" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Set.lean"/>
                </OtherNode>
                <NullNode start="(421, 68)" end="(421, 94)">
                  <OtherNode start="(421, 68)" end="(421, 75)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(421, 68)" end="(421, 69)" leading="" trailing="" val="("/>
                    <OtherNode start="(421, 69)" end="(421, 74)" kind="«term_-_»">
                      <IdentNode start="(421, 69)" end="(421, 70)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(421, 71)" end="(421, 72)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(421, 73)" end="(421, 74)" kind="num">
                        <AtomNode start="(421, 73)" end="(421, 74)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(421, 74)" end="(421, 75)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(421, 76)" end="(421, 77)" leading="" trailing=" " raw_val="a" val="a"/>
                  <OtherNode start="(421, 78)" end="(421, 94)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(421, 78)" end="(421, 79)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(421, 79)" end="(421, 93)">
                      <AtomNode start="(421, 79)" end="(421, 81)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(421, 82)" end="(421, 93)">
                        <TacticTacticseq1IndentedNode start="(421, 82)" end="(421, 93)">
                          <NullNode start="(421, 82)" end="(421, 93)">
                            <OtherNode start="(421, 82)" end="(421, 86)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.65425&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ i - 1 &amp;lt; (xs.eraseIdx j ⋯).size" state_after="α : Type ?u.65425&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ i - 1 &amp;lt; xs.size - 1" tactic="simp">
                              <AtomNode start="(421, 82)" end="(421, 86)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(421, 86)" end="(421, 87)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(421, 88)" end="(421, 93)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.65425&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ i - 1 &amp;lt; xs.size - 1" state_after="no goals" tactic="omega">
                              <AtomNode start="(421, 88)" end="(421, 93)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(421, 93)" end="(421, 94)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(421, 95)" end="(423, 33)">
          <AtomNode start="(421, 95)" end="(421, 97)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(421, 98)" end="(423, 33)">
            <AtomNode start="(421, 98)" end="(421, 100)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(422, 3)" end="(423, 33)">
              <TacticTacticseq1IndentedNode start="(422, 3)" end="(423, 33)">
                <NullNode start="(422, 3)" end="(423, 33)">
                  <OtherNode start="(422, 3)" end="(422, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;w : i &amp;lt; xs.size&#10;j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ (xs.set i a w).eraseIdx j ⋯ = (xs.eraseIdx j ⋯).set (i - 1) a ⋯" state_after="case mk&#10;α : Type u_1&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;xs : List α&#10;w : i &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.set i a w).eraseIdx j ⋯ = ({ toList := xs }.eraseIdx j ⋯).set (i - 1) a ⋯" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(422, 3)" end="(422, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(422, 10)" end="(422, 12)">
                      <OtherNode start="(422, 10)" end="(422, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(422, 10)" end="(422, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(422, 13)" end="(422, 22)">
                      <AtomNode start="(422, 13)" end="(422, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(422, 18)" end="(422, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(422, 18)" end="(422, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(422, 18)" end="(422, 22)">
                            <OtherNode start="(422, 18)" end="(422, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(422, 18)" end="(422, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(422, 19)" end="(422, 21)">
                                <OtherNode start="(422, 19)" end="(422, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(422, 19)" end="(422, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(422, 19)" end="(422, 21)">
                                      <OtherNode start="(422, 19)" end="(422, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(422, 19)" end="(422, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(422, 21)" end="(422, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(423, 3)" end="(423, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;xs : List α&#10;w : i &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.set i a w).eraseIdx j ⋯ = ({ toList := xs }.eraseIdx j ⋯).set (i - 1) a ⋯" state_after="no goals" tactic="simp [List.eraseIdx_set_lt, *]">
                    <AtomNode start="(423, 3)" end="(423, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(423, 8)" end="(423, 33)">
                      <AtomNode start="(423, 8)" end="(423, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(423, 9)" end="(423, 32)">
                        <OtherNode start="(423, 9)" end="(423, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(423, 9)" end="(423, 29)" leading="" trailing="" raw_val="List.eraseIdx_set_lt" val="List.eraseIdx_set_lt" full_name="List.eraseIdx_set_lt" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(423, 29)" end="(423, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(423, 31)" end="(423, 32)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(423, 31)" end="(423, 32)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(423, 32)" end="(423, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(425, 1)" end="(428, 33)" name="eraseIdx_set_gt" full_name="Array.eraseIdx_set_gt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(425, 1)" end="(428, 33)" name="eraseIdx_set_gt" full_name="Array.eraseIdx_set_gt" _is_private_decl="False">
        <AtomNode start="(425, 1)" end="(425, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(425, 9)" end="(425, 24)">
          <IdentNode start="(425, 9)" end="(425, 24)" leading="" trailing=" " raw_val="eraseIdx_set_gt" val="eraseIdx_set_gt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(425, 25)" end="(426, 88)">
          <NullNode start="(425, 25)" end="(425, 97)">
            <OtherNode start="(425, 25)" end="(425, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(425, 25)" end="(425, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(425, 26)" end="(425, 28)">
                <IdentNode start="(425, 26)" end="(425, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(425, 29)" end="(425, 38)">
                <AtomNode start="(425, 29)" end="(425, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(425, 31)" end="(425, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(425, 31)" end="(425, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(425, 37)" end="(425, 38)">
                    <IdentNode start="(425, 37)" end="(425, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(425, 38)" end="(425, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(425, 40)" end="(425, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(425, 40)" end="(425, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(425, 41)" end="(425, 42)">
                <IdentNode start="(425, 41)" end="(425, 42)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(425, 43)" end="(425, 48)">
                <AtomNode start="(425, 43)" end="(425, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(425, 45)" end="(425, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(425, 48)" end="(425, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(425, 50)" end="(425, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(425, 50)" end="(425, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(425, 51)" end="(425, 52)">
                <IdentNode start="(425, 51)" end="(425, 52)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(425, 53)" end="(425, 58)">
                <AtomNode start="(425, 53)" end="(425, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(425, 55)" end="(425, 58)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(425, 58)" end="(425, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(425, 60)" end="(425, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(425, 60)" end="(425, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(425, 61)" end="(425, 62)">
                <IdentNode start="(425, 61)" end="(425, 62)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(425, 63)" end="(425, 66)">
                <AtomNode start="(425, 63)" end="(425, 64)" leading="" trailing=" " val=":"/>
                <IdentNode start="(425, 65)" end="(425, 66)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(425, 66)" end="(425, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(425, 68)" end="(425, 79)">
              <AtomNode start="(425, 68)" end="(425, 69)" leading="" trailing="" val="("/>
              <NullNode start="(425, 69)" end="(425, 70)">
                <IdentNode start="(425, 69)" end="(425, 70)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(425, 71)" end="(425, 78)">
                <AtomNode start="(425, 71)" end="(425, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(425, 73)" end="(425, 78)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(425, 73)" end="(425, 74)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(425, 75)" end="(425, 76)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(425, 77)" end="(425, 78)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(425, 78)" end="(425, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(425, 80)" end="(425, 97)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(425, 80)" end="(425, 81)" leading="" trailing="" val="{"/>
              <NullNode start="(425, 81)" end="(425, 82)">
                <IdentNode start="(425, 81)" end="(425, 82)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(425, 83)" end="(425, 96)">
                <AtomNode start="(425, 83)" end="(425, 84)" leading="" trailing=" " val=":"/>
                <OtherNode start="(425, 85)" end="(425, 96)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(425, 85)" end="(425, 86)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(425, 87)" end="(425, 88)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(425, 89)" end="(425, 96)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(425, 96)" end="(425, 97)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(425, 98)" end="(426, 88)">
            <AtomNode start="(425, 98)" end="(425, 99)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(426, 5)" end="(426, 88)" kind="«term_=_»">
              <OtherNode start="(426, 5)" end="(426, 45)" kind="Lean.Parser.Term.app">
                <OtherNode start="(426, 5)" end="(426, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(426, 5)" end="(426, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(426, 5)" end="(426, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(426, 6)" end="(426, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(426, 6)" end="(426, 12)" leading="" trailing=" " raw_val="xs.set" val="xs.set"/>
                      <NullNode start="(426, 13)" end="(426, 16)">
                        <IdentNode start="(426, 13)" end="(426, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(426, 15)" end="(426, 16)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(426, 16)" end="(426, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(426, 17)" end="(426, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(426, 18)" end="(426, 26)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(426, 27)" end="(426, 45)">
                  <IdentNode start="(426, 27)" end="(426, 28)" leading="" trailing=" " raw_val="j" val="j"/>
                  <OtherNode start="(426, 29)" end="(426, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(426, 29)" end="(426, 30)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(426, 30)" end="(426, 44)">
                      <AtomNode start="(426, 30)" end="(426, 32)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(426, 33)" end="(426, 44)">
                        <TacticTacticseq1IndentedNode start="(426, 33)" end="(426, 44)">
                          <NullNode start="(426, 33)" end="(426, 44)">
                            <OtherNode start="(426, 33)" end="(426, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.67030&#10;xs : Array α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;w : j &amp;lt; xs.size&#10;⊢ j &amp;lt; (xs.set i a ⋯).size" state_after="α : Type ?u.67030&#10;xs : Array α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;w : j &amp;lt; xs.size&#10;⊢ j &amp;lt; xs.size" tactic="simp">
                              <AtomNode start="(426, 33)" end="(426, 37)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(426, 37)" end="(426, 38)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(426, 39)" end="(426, 44)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.67030&#10;xs : Array α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;w : j &amp;lt; xs.size&#10;⊢ j &amp;lt; xs.size" state_after="no goals" tactic="omega">
                              <AtomNode start="(426, 39)" end="(426, 44)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(426, 44)" end="(426, 45)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(426, 46)" end="(426, 47)" leading="" trailing=" " val="="/>
              <OtherNode start="(426, 48)" end="(426, 88)" kind="Lean.Parser.Term.app">
                <OtherNode start="(426, 48)" end="(426, 67)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(426, 48)" end="(426, 63)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(426, 48)" end="(426, 49)" leading="" trailing="" val="("/>
                    <OtherNode start="(426, 49)" end="(426, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(426, 49)" end="(426, 60)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                      <NullNode start="(426, 61)" end="(426, 62)">
                        <IdentNode start="(426, 61)" end="(426, 62)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(426, 62)" end="(426, 63)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(426, 63)" end="(426, 64)" leading="" trailing="" val="."/>
                  <IdentNode start="(426, 64)" end="(426, 67)" leading="" trailing=" " raw_val="set" val="set" full_name="Array.set" mod_name="Init.Data.Array.Set" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Set.lean"/>
                </OtherNode>
                <NullNode start="(426, 68)" end="(426, 88)">
                  <IdentNode start="(426, 68)" end="(426, 69)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(426, 70)" end="(426, 71)" leading="" trailing=" " raw_val="a" val="a"/>
                  <OtherNode start="(426, 72)" end="(426, 88)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(426, 72)" end="(426, 73)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(426, 73)" end="(426, 87)">
                      <AtomNode start="(426, 73)" end="(426, 75)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(426, 76)" end="(426, 87)">
                        <TacticTacticseq1IndentedNode start="(426, 76)" end="(426, 87)">
                          <NullNode start="(426, 76)" end="(426, 87)">
                            <OtherNode start="(426, 76)" end="(426, 80)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.67030&#10;xs : Array α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;w : j &amp;lt; xs.size&#10;⊢ i &amp;lt; (xs.eraseIdx j w).size" state_after="α : Type ?u.67030&#10;xs : Array α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;w : j &amp;lt; xs.size&#10;⊢ i &amp;lt; xs.size - 1" tactic="simp">
                              <AtomNode start="(426, 76)" end="(426, 80)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(426, 80)" end="(426, 81)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(426, 82)" end="(426, 87)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.67030&#10;xs : Array α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;w : j &amp;lt; xs.size&#10;⊢ i &amp;lt; xs.size - 1" state_after="no goals" tactic="omega">
                              <AtomNode start="(426, 82)" end="(426, 87)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(426, 87)" end="(426, 88)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(426, 89)" end="(428, 33)">
          <AtomNode start="(426, 89)" end="(426, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(426, 92)" end="(428, 33)">
            <AtomNode start="(426, 92)" end="(426, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(427, 3)" end="(428, 33)">
              <TacticTacticseq1IndentedNode start="(427, 3)" end="(428, 33)">
                <NullNode start="(427, 3)" end="(428, 33)">
                  <OtherNode start="(427, 3)" end="(427, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;w : j &amp;lt; xs.size&#10;⊢ (xs.set i a ⋯).eraseIdx j ⋯ = (xs.eraseIdx j w).set i a ⋯" state_after="case mk&#10;α : Type u_1&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;xs : List α&#10;w : j &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.set i a ⋯).eraseIdx j ⋯ = ({ toList := xs }.eraseIdx j w).set i a ⋯" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(427, 3)" end="(427, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(427, 10)" end="(427, 12)">
                      <OtherNode start="(427, 10)" end="(427, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(427, 10)" end="(427, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(427, 13)" end="(427, 22)">
                      <AtomNode start="(427, 13)" end="(427, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(427, 18)" end="(427, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(427, 18)" end="(427, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(427, 18)" end="(427, 22)">
                            <OtherNode start="(427, 18)" end="(427, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(427, 18)" end="(427, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(427, 19)" end="(427, 21)">
                                <OtherNode start="(427, 19)" end="(427, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(427, 19)" end="(427, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(427, 19)" end="(427, 21)">
                                      <OtherNode start="(427, 19)" end="(427, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(427, 19)" end="(427, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(427, 21)" end="(427, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(428, 3)" end="(428, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;xs : List α&#10;w : j &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.set i a ⋯).eraseIdx j ⋯ = ({ toList := xs }.eraseIdx j w).set i a ⋯" state_after="no goals" tactic="simp [List.eraseIdx_set_gt, *]">
                    <AtomNode start="(428, 3)" end="(428, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(428, 8)" end="(428, 33)">
                      <AtomNode start="(428, 8)" end="(428, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(428, 9)" end="(428, 32)">
                        <OtherNode start="(428, 9)" end="(428, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(428, 9)" end="(428, 29)" leading="" trailing="" raw_val="List.eraseIdx_set_gt" val="List.eraseIdx_set_gt" full_name="List.eraseIdx_set_gt" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(428, 29)" end="(428, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(428, 31)" end="(428, 32)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(428, 31)" end="(428, 32)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(428, 32)" end="(428, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(430, 1)" end="(434, 48)" name="set_getElem_succ_eraseIdx_succ" full_name="Array.set_getElem_succ_eraseIdx_succ">
      <CommandDeclmodifiersNode start="(430, 1)" end="(430, 8)">
        <NullNode/>
        <NullNode start="(430, 1)" end="(430, 8)">
          <OtherNode start="(430, 1)" end="(430, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(430, 1)" end="(430, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(430, 3)" end="(430, 7)">
              <OtherNode start="(430, 3)" end="(430, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(430, 3)" end="(430, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(430, 3)" end="(430, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(430, 7)" end="(430, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(430, 9)" end="(434, 48)" name="set_getElem_succ_eraseIdx_succ" full_name="Array.set_getElem_succ_eraseIdx_succ" _is_private_decl="False">
        <AtomNode start="(430, 9)" end="(430, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(430, 17)" end="(430, 47)">
          <IdentNode start="(430, 17)" end="(430, 47)" leading="" trailing="&#10;    " raw_val="set_getElem_succ_eraseIdx_succ" val="set_getElem_succ_eraseIdx_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(431, 5)" end="(432, 75)">
          <NullNode start="(431, 5)" end="(431, 51)">
            <OtherNode start="(431, 5)" end="(431, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(431, 5)" end="(431, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(431, 6)" end="(431, 8)">
                <IdentNode start="(431, 6)" end="(431, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(431, 9)" end="(431, 18)">
                <AtomNode start="(431, 9)" end="(431, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(431, 11)" end="(431, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(431, 11)" end="(431, 16)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(431, 17)" end="(431, 18)">
                    <IdentNode start="(431, 17)" end="(431, 18)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(431, 18)" end="(431, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(431, 20)" end="(431, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(431, 20)" end="(431, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(431, 21)" end="(431, 22)">
                <IdentNode start="(431, 21)" end="(431, 22)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(431, 23)" end="(431, 28)">
                <AtomNode start="(431, 23)" end="(431, 24)" leading="" trailing=" " val=":"/>
                <IdentNode start="(431, 25)" end="(431, 28)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(431, 28)" end="(431, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(431, 30)" end="(431, 51)">
              <AtomNode start="(431, 30)" end="(431, 31)" leading="" trailing="" val="("/>
              <NullNode start="(431, 31)" end="(431, 32)">
                <IdentNode start="(431, 31)" end="(431, 32)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(431, 33)" end="(431, 50)">
                <AtomNode start="(431, 33)" end="(431, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(431, 35)" end="(431, 50)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(431, 35)" end="(431, 40)" kind="«term_+_»">
                    <IdentNode start="(431, 35)" end="(431, 36)" leading="" trailing=" " raw_val="i" val="i"/>
                    <AtomNode start="(431, 37)" end="(431, 38)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(431, 39)" end="(431, 40)" kind="num">
                      <AtomNode start="(431, 39)" end="(431, 40)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(431, 41)" end="(431, 42)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(431, 43)" end="(431, 50)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(431, 50)" end="(431, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(431, 52)" end="(432, 75)">
            <AtomNode start="(431, 52)" end="(431, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(432, 5)" end="(432, 75)" kind="«term_=_»">
              <OtherNode start="(432, 5)" end="(432, 59)" kind="Lean.Parser.Term.app">
                <OtherNode start="(432, 5)" end="(432, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(432, 5)" end="(432, 26)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(432, 5)" end="(432, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(432, 6)" end="(432, 25)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(432, 6)" end="(432, 17)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                      <NullNode start="(432, 18)" end="(432, 25)">
                        <OtherNode start="(432, 18)" end="(432, 25)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(432, 18)" end="(432, 19)" leading="" trailing="" val="("/>
                          <OtherNode start="(432, 19)" end="(432, 24)" kind="«term_+_»">
                            <IdentNode start="(432, 19)" end="(432, 20)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(432, 21)" end="(432, 22)" leading="" trailing=" " val="+"/>
                            <OtherNode start="(432, 23)" end="(432, 24)" kind="num">
                              <AtomNode start="(432, 23)" end="(432, 24)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(432, 24)" end="(432, 25)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(432, 25)" end="(432, 26)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(432, 26)" end="(432, 27)" leading="" trailing="" val="."/>
                  <IdentNode start="(432, 27)" end="(432, 30)" leading="" trailing=" " raw_val="set" val="set" full_name="Array.set" mod_name="Init.Data.Array.Set" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Set.lean"/>
                </OtherNode>
                <NullNode start="(432, 31)" end="(432, 59)">
                  <IdentNode start="(432, 31)" end="(432, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(432, 33)" end="(432, 42)" kind="«term__[_]»">
                    <IdentNode start="(432, 33)" end="(432, 35)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <AtomNode start="(432, 35)" end="(432, 36)" leading="" trailing="" val="["/>
                    <OtherNode start="(432, 36)" end="(432, 41)" kind="«term_+_»">
                      <IdentNode start="(432, 36)" end="(432, 37)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(432, 38)" end="(432, 39)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(432, 40)" end="(432, 41)" kind="num">
                        <AtomNode start="(432, 40)" end="(432, 41)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(432, 41)" end="(432, 42)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <OtherNode start="(432, 43)" end="(432, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(432, 43)" end="(432, 44)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(432, 44)" end="(432, 58)">
                      <AtomNode start="(432, 44)" end="(432, 46)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(432, 47)" end="(432, 58)">
                        <TacticTacticseq1IndentedNode start="(432, 47)" end="(432, 58)">
                          <NullNode start="(432, 47)" end="(432, 58)">
                            <OtherNode start="(432, 47)" end="(432, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.68340&#10;xs : Array α&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.size&#10;⊢ i &amp;lt; (xs.eraseIdx (i + 1) h).size" state_after="α : Type ?u.68340&#10;xs : Array α&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.size&#10;⊢ i &amp;lt; xs.size - 1" tactic="simp">
                              <AtomNode start="(432, 47)" end="(432, 51)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(432, 51)" end="(432, 52)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(432, 53)" end="(432, 58)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.68340&#10;xs : Array α&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.size&#10;⊢ i &amp;lt; xs.size - 1" state_after="no goals" tactic="omega">
                              <AtomNode start="(432, 53)" end="(432, 58)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(432, 58)" end="(432, 59)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(432, 60)" end="(432, 61)" leading="" trailing=" " val="="/>
              <OtherNode start="(432, 62)" end="(432, 75)" kind="Lean.Parser.Term.app">
                <IdentNode start="(432, 62)" end="(432, 73)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                <NullNode start="(432, 74)" end="(432, 75)">
                  <IdentNode start="(432, 74)" end="(432, 75)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(432, 76)" end="(434, 48)">
          <AtomNode start="(432, 76)" end="(432, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(432, 79)" end="(434, 48)">
            <AtomNode start="(432, 79)" end="(432, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(433, 3)" end="(434, 48)">
              <TacticTacticseq1IndentedNode start="(433, 3)" end="(434, 48)">
                <NullNode start="(433, 3)" end="(434, 48)">
                  <OtherNode start="(433, 3)" end="(433, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.size&#10;⊢ (xs.eraseIdx (i + 1) h).set i xs[i + 1] ⋯ = xs.eraseIdx i ⋯" state_after="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i + 1 &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.eraseIdx (i + 1) h).set i { toList := xs }[i + 1] ⋯ = { toList := xs }.eraseIdx i ⋯" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(433, 3)" end="(433, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(433, 10)" end="(433, 12)">
                      <OtherNode start="(433, 10)" end="(433, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(433, 10)" end="(433, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(433, 13)" end="(433, 22)">
                      <AtomNode start="(433, 13)" end="(433, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(433, 18)" end="(433, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(433, 18)" end="(433, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(433, 18)" end="(433, 22)">
                            <OtherNode start="(433, 18)" end="(433, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(433, 18)" end="(433, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(433, 19)" end="(433, 21)">
                                <OtherNode start="(433, 19)" end="(433, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(433, 19)" end="(433, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(433, 19)" end="(433, 21)">
                                      <OtherNode start="(433, 19)" end="(433, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(433, 19)" end="(433, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(433, 21)" end="(433, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(434, 3)" end="(434, 48)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;i : Nat&#10;xs : List α&#10;h : i + 1 &amp;lt; { toList := xs }.size&#10;⊢ ({ toList := xs }.eraseIdx (i + 1) h).set i { toList := xs }[i + 1] ⋯ = { toList := xs }.eraseIdx i ⋯" state_after="no goals" tactic="simp [List.set_getElem_succ_eraseIdx_succ, *]">
                    <AtomNode start="(434, 3)" end="(434, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(434, 8)" end="(434, 48)">
                      <AtomNode start="(434, 8)" end="(434, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(434, 9)" end="(434, 47)">
                        <OtherNode start="(434, 9)" end="(434, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(434, 9)" end="(434, 44)" leading="" trailing="" raw_val="List.set_getElem_succ_eraseIdx_succ" val="List.set_getElem_succ_eraseIdx_succ" full_name="List.set_getElem_succ_eraseIdx_succ" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(434, 44)" end="(434, 45)" leading="" trailing=" " val=","/>
                        <OtherNode start="(434, 46)" end="(434, 47)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(434, 46)" end="(434, 47)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(434, 47)" end="(434, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(436, 1)" end="(436, 10)" name="Array">
      <AtomNode start="(436, 1)" end="(436, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(436, 5)" end="(436, 10)">
        <IdentNode start="(436, 5)" end="(436, 10)" leading="" trailing="&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(13, 1)" end="(15, 3)" text="# Lemmas about `Array.eraseP`, `Array.erase`, and `Array.eraseIdx`.&#10;-/"/>
    <Comment start="(17, 38)" end="(18, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(18, 39)" end="(20, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(24, 1)" end="(24, 18)" text="### eraseP -/"/>
    <Comment start="(51, 1)" end="(52, 1)" text="-- The arguments are explicit here, so this lemma can be used as a case split.&#10;"/>
    <Comment start="(172, 1)" end="(172, 17)" text="### erase -/"/>
    <Comment start="(181, 1)" end="(182, 1)" text="-- The arguments are intentionally explicit.&#10;"/>
    <Comment start="(186, 1)" end="(187, 1)" text="-- The arguments are intentionally explicit.&#10;"/>
    <Comment start="(269, 1)" end="(271, 1)" text="-- The arguments `a b` are explicit,&#10;-- so they can be specified to prevent `simp` repeatedly applying the lemma.&#10;"/>
    <Comment start="(308, 1)" end="(308, 20)" text="### eraseIdx -/"/>
  </Comments>
</TracedFile>
